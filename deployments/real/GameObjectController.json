{
  "address": "0x34f2Eb57291Bcf5422caFcA97bDD30DF635c4474",
  "abi": [
    {
      "inputs": [],
      "name": "EmptyObjects",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ErrorNotDeployer",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ErrorNotDungeonFactory",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FightDelay",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "name": "GenObjectIdBiomeOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "GenObjectIdIdOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "subType",
          "type": "uint256"
        }
      ],
      "name": "GenObjectIdSubTypeOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "value",
          "type": "int256"
        }
      ],
      "name": "IntOutOfRange",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "value",
          "type": "int256"
        }
      ],
      "name": "IntValueOutOfRange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidInitialization",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LengthsMismatch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotInitializing",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ObjectNotFound",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "chance",
          "type": "uint32"
        }
      ],
      "name": "TooHighChance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "TooHighValue",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "objectSubType",
          "type": "uint8"
        }
      ],
      "name": "UnknownObjectTypeForSubtype",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "objectType",
          "type": "uint8"
        }
      ],
      "name": "UnknownObjectTypeGoc1",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "objectType",
          "type": "uint8"
        }
      ],
      "name": "UnknownObjectTypeGoc2",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "objectType",
          "type": "uint8"
        }
      ],
      "name": "UnknownObjectTypeGocLib1",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "objectType",
          "type": "uint8"
        }
      ],
      "name": "UnknownObjectTypeGocLib2",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "chances",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "maxChances",
          "type": "uint32"
        }
      ],
      "name": "WrongChances",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "WrongGetObjectTypeInput",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroChance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroStoryIdAction",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroValue",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroValueNotAllowed",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ts",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "block",
          "type": "uint256"
        }
      ],
      "name": "ContractInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "biome",
              "type": "uint8"
            },
            {
              "internalType": "uint16",
              "name": "eventId",
              "type": "uint16"
            },
            {
              "internalType": "enum IGOC.ObjectSubType",
              "name": "subType",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "goodChance",
              "type": "uint32"
            },
            {
              "components": [
                {
                  "internalType": "uint8[]",
                  "name": "ids",
                  "type": "uint8[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "values",
                  "type": "int32[]"
                }
              ],
              "internalType": "struct IGOC.AttributeGenerateInfo",
              "name": "goodAttributes",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint8[]",
                  "name": "ids",
                  "type": "uint8[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "values",
                  "type": "int32[]"
                }
              ],
              "internalType": "struct IGOC.AttributeGenerateInfo",
              "name": "badAttributes",
              "type": "tuple"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "int32",
              "name": "heal",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "manaRegen",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "lifeChancesRecovered",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "damage",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "manaConsumed",
              "type": "int32"
            },
            {
              "internalType": "address[]",
              "name": "mintItems",
              "type": "address[]"
            },
            {
              "internalType": "uint32[]",
              "name": "mintItemsChances",
              "type": "uint32[]"
            }
          ],
          "indexed": false,
          "internalType": "struct IGOC.EventRegInfo",
          "name": "eventRegInfo",
          "type": "tuple"
        }
      ],
      "name": "EventRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "version",
          "type": "uint64"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        },
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "monsterId",
              "type": "uint16"
            },
            {
              "internalType": "uint8",
              "name": "biome",
              "type": "uint8"
            },
            {
              "internalType": "enum IGOC.ObjectSubType",
              "name": "subType",
              "type": "uint8"
            },
            {
              "internalType": "uint8[]",
              "name": "attributeIds",
              "type": "uint8[]"
            },
            {
              "internalType": "int32[]",
              "name": "attributeValues",
              "type": "int32[]"
            },
            {
              "internalType": "uint8",
              "name": "level",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "race",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "uint8",
              "name": "maxDropItems",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "attackToken",
              "type": "address"
            },
            {
              "internalType": "uint64",
              "name": "attackTokenId",
              "type": "uint64"
            },
            {
              "internalType": "uint8",
              "name": "attackType",
              "type": "uint8"
            },
            {
              "internalType": "address[]",
              "name": "mintItems",
              "type": "address[]"
            },
            {
              "internalType": "uint32[]",
              "name": "mintItemsChances",
              "type": "uint32[]"
            }
          ],
          "indexed": false,
          "internalType": "struct IGOC.MonsterGenInfo",
          "name": "monsterGenInfo",
          "type": "tuple"
        }
      ],
      "name": "MonsterRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "ObjectRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "dungeonId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "enum IGOC.ObjectType",
          "name": "objectType",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "stageId",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "iteration",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "bool",
              "name": "kill",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "completed",
              "type": "bool"
            },
            {
              "internalType": "address",
              "name": "heroToken",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "mintItems",
              "type": "address[]"
            },
            {
              "internalType": "int32",
              "name": "heal",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "manaRegen",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "lifeChancesRecovered",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "damage",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "manaConsumed",
              "type": "int32"
            },
            {
              "internalType": "uint32",
              "name": "objectId",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "uint256",
              "name": "heroTokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "iteration",
              "type": "uint256"
            },
            {
              "internalType": "uint32[]",
              "name": "rewriteNextObject",
              "type": "uint32[]"
            }
          ],
          "indexed": false,
          "internalType": "struct IGOC.ActionResult",
          "name": "result",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "salt",
          "type": "uint256"
        }
      ],
      "name": "ObjectResultEvent",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "RevisionIncreased",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        }
      ],
      "name": "StoryRegistered",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CONTROLLABLE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "dungeonId",
          "type": "uint64"
        },
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "stageId",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "action",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "kill",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "completed",
              "type": "bool"
            },
            {
              "internalType": "address",
              "name": "heroToken",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "mintItems",
              "type": "address[]"
            },
            {
              "internalType": "int32",
              "name": "heal",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "manaRegen",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "lifeChancesRecovered",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "damage",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "manaConsumed",
              "type": "int32"
            },
            {
              "internalType": "uint32",
              "name": "objectId",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "uint256",
              "name": "heroTokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "iteration",
              "type": "uint256"
            },
            {
              "internalType": "uint32[]",
              "name": "rewriteNextObject",
              "type": "uint32[]"
            }
          ],
          "internalType": "struct IGOC.ActionResult",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "created",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "createdBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "getEventInfo",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "goodChance",
              "type": "uint32"
            },
            {
              "internalType": "bytes32[]",
              "name": "goodAttributes",
              "type": "bytes32[]"
            },
            {
              "internalType": "bytes32[]",
              "name": "badAttributes",
              "type": "bytes32[]"
            },
            {
              "internalType": "bytes32",
              "name": "statsChange",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32[]",
              "name": "mintItems",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct IGOC.EventInfo",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getFightDelay",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "objId",
          "type": "uint32"
        }
      ],
      "name": "getIteration",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "getLastHeroFightTs",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "getMonsterInfo",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "monsterId",
              "type": "uint16"
            },
            {
              "internalType": "uint8",
              "name": "biome",
              "type": "uint8"
            },
            {
              "internalType": "enum IGOC.ObjectSubType",
              "name": "subType",
              "type": "uint8"
            },
            {
              "internalType": "uint8[]",
              "name": "attributeIds",
              "type": "uint8[]"
            },
            {
              "internalType": "int32[]",
              "name": "attributeValues",
              "type": "int32[]"
            },
            {
              "internalType": "uint8",
              "name": "level",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "race",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "uint8",
              "name": "maxDropItems",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "attackToken",
              "type": "address"
            },
            {
              "internalType": "uint64",
              "name": "attackTokenId",
              "type": "uint64"
            },
            {
              "internalType": "uint8",
              "name": "attackType",
              "type": "uint8"
            },
            {
              "internalType": "address[]",
              "name": "mintItems",
              "type": "address[]"
            },
            {
              "internalType": "uint32[]",
              "name": "mintItemsChances",
              "type": "uint32[]"
            }
          ],
          "internalType": "struct IGOC.MonsterGenInfo",
          "name": "mGenInfo",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bool",
              "name": "generated",
              "type": "bool"
            },
            {
              "internalType": "uint8",
              "name": "turnCounter",
              "type": "uint8"
            },
            {
              "internalType": "int32",
              "name": "hp",
              "type": "int32"
            },
            {
              "internalType": "uint32",
              "name": "amplifier",
              "type": "uint32"
            }
          ],
          "internalType": "struct IGOC.GeneratedMonster",
          "name": "gen",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "heroNgLevel",
          "type": "uint8"
        }
      ],
      "name": "getMonsterMultiplier",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "enum IGOC.ObjectSubType",
          "name": "subType",
          "type": "uint8"
        }
      ],
      "name": "getObjectIds",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "getObjectMeta",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "objectSubType",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "getObjectTypeBySubType",
      "outputs": [
        {
          "internalType": "enum IGOC.ObjectType",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8[]",
          "name": "cTypes",
          "type": "uint8[]"
        },
        {
          "internalType": "uint32[]",
          "name": "chances",
          "type": "uint32[]"
        },
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "getRandomObject",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "getStoryId",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "increaseRevision",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "controller_",
          "type": "address"
        }
      ],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "objId",
          "type": "uint32"
        }
      ],
      "name": "isAvailableForHero",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "isBattleObject",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isController",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isGovernance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "open",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "iteration",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "previousImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "biome",
              "type": "uint8"
            },
            {
              "internalType": "uint16",
              "name": "eventId",
              "type": "uint16"
            },
            {
              "internalType": "enum IGOC.ObjectSubType",
              "name": "subType",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "goodChance",
              "type": "uint32"
            },
            {
              "components": [
                {
                  "internalType": "uint8[]",
                  "name": "ids",
                  "type": "uint8[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "values",
                  "type": "int32[]"
                }
              ],
              "internalType": "struct IGOC.AttributeGenerateInfo",
              "name": "goodAttributes",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint8[]",
                  "name": "ids",
                  "type": "uint8[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "values",
                  "type": "int32[]"
                }
              ],
              "internalType": "struct IGOC.AttributeGenerateInfo",
              "name": "badAttributes",
              "type": "tuple"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "int32",
              "name": "heal",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "manaRegen",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "lifeChancesRecovered",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "damage",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "manaConsumed",
              "type": "int32"
            },
            {
              "internalType": "address[]",
              "name": "mintItems",
              "type": "address[]"
            },
            {
              "internalType": "uint32[]",
              "name": "mintItemsChances",
              "type": "uint32[]"
            }
          ],
          "internalType": "struct IGOC.EventRegInfo",
          "name": "regInfo",
          "type": "tuple"
        }
      ],
      "name": "registerEvent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "monsterId",
              "type": "uint16"
            },
            {
              "internalType": "uint8",
              "name": "biome",
              "type": "uint8"
            },
            {
              "internalType": "enum IGOC.ObjectSubType",
              "name": "subType",
              "type": "uint8"
            },
            {
              "internalType": "uint8[]",
              "name": "attributeIds",
              "type": "uint8[]"
            },
            {
              "internalType": "int32[]",
              "name": "attributeValues",
              "type": "int32[]"
            },
            {
              "internalType": "uint8",
              "name": "level",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "race",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "uint8",
              "name": "maxDropItems",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "attackToken",
              "type": "address"
            },
            {
              "internalType": "uint64",
              "name": "attackTokenId",
              "type": "uint64"
            },
            {
              "internalType": "uint8",
              "name": "attackType",
              "type": "uint8"
            },
            {
              "internalType": "address[]",
              "name": "mintItems",
              "type": "address[]"
            },
            {
              "internalType": "uint32[]",
              "name": "mintItemsChances",
              "type": "uint32[]"
            }
          ],
          "internalType": "struct IGOC.MonsterGenInfo",
          "name": "monsterGenInfo",
          "type": "tuple"
        }
      ],
      "name": "registerMonster",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "enum IGOC.ObjectSubType",
          "name": "subType",
          "type": "uint8"
        }
      ],
      "name": "registerStory",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "removeObject",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "revision",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x85d6962eacc02f524f3f449debcc2cb1198005ccc5f46533a769fce8ff3e2d19",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0x34f2Eb57291Bcf5422caFcA97bDD30DF635c4474",
    "transactionIndex": 1,
    "gasUsed": "8166992",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000012000000000000000000",
    "blockHash": "0xecb71b1700257c9239f6b07024a68cb3970e9f8538b9b85a8c077f23c2fdc194",
    "transactionHash": "0x85d6962eacc02f524f3f449debcc2cb1198005ccc5f46533a769fce8ff3e2d19",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 1201239,
        "transactionHash": "0x85d6962eacc02f524f3f449debcc2cb1198005ccc5f46533a769fce8ff3e2d19",
        "address": "0x34f2Eb57291Bcf5422caFcA97bDD30DF635c4474",
        "topics": [
          "0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 0,
        "blockHash": "0xecb71b1700257c9239f6b07024a68cb3970e9f8538b9b85a8c077f23c2fdc194"
      }
    ],
    "blockNumber": 1201239,
    "cumulativeGasUsed": "8166992",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 27,
  "solcInputHash": "1c5f5fd0b61f54e5cdb86891b80cc3ef",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"EmptyObjects\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ErrorNotDeployer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ErrorNotDungeonFactory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FightDelay\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"name\":\"GenObjectIdBiomeOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"GenObjectIdIdOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"subType\",\"type\":\"uint256\"}],\"name\":\"GenObjectIdSubTypeOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"IntOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"IntValueOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthsMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ObjectNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"chance\",\"type\":\"uint32\"}],\"name\":\"TooHighChance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TooHighValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"objectSubType\",\"type\":\"uint8\"}],\"name\":\"UnknownObjectTypeForSubtype\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"objectType\",\"type\":\"uint8\"}],\"name\":\"UnknownObjectTypeGoc1\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"objectType\",\"type\":\"uint8\"}],\"name\":\"UnknownObjectTypeGoc2\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"objectType\",\"type\":\"uint8\"}],\"name\":\"UnknownObjectTypeGocLib1\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"objectType\",\"type\":\"uint8\"}],\"name\":\"UnknownObjectTypeGocLib2\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"chances\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxChances\",\"type\":\"uint32\"}],\"name\":\"WrongChances\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongGetObjectTypeInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroChance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroStoryIdAction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroValueNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"ContractInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"eventId\",\"type\":\"uint16\"},{\"internalType\":\"enum IGOC.ObjectSubType\",\"name\":\"subType\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"goodChance\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"ids\",\"type\":\"uint8[]\"},{\"internalType\":\"int32[]\",\"name\":\"values\",\"type\":\"int32[]\"}],\"internalType\":\"struct IGOC.AttributeGenerateInfo\",\"name\":\"goodAttributes\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"ids\",\"type\":\"uint8[]\"},{\"internalType\":\"int32[]\",\"name\":\"values\",\"type\":\"int32[]\"}],\"internalType\":\"struct IGOC.AttributeGenerateInfo\",\"name\":\"badAttributes\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"int32\",\"name\":\"heal\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaRegen\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"lifeChancesRecovered\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"damage\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaConsumed\",\"type\":\"int32\"},{\"internalType\":\"address[]\",\"name\":\"mintItems\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"mintItemsChances\",\"type\":\"uint32[]\"}],\"indexed\":false,\"internalType\":\"struct IGOC.EventRegInfo\",\"name\":\"eventRegInfo\",\"type\":\"tuple\"}],\"name\":\"EventRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"monsterId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"enum IGOC.ObjectSubType\",\"name\":\"subType\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"attributeIds\",\"type\":\"uint8[]\"},{\"internalType\":\"int32[]\",\"name\":\"attributeValues\",\"type\":\"int32[]\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"race\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"maxDropItems\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"attackToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"attackTokenId\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"attackType\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"mintItems\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"mintItemsChances\",\"type\":\"uint32[]\"}],\"indexed\":false,\"internalType\":\"struct IGOC.MonsterGenInfo\",\"name\":\"monsterGenInfo\",\"type\":\"tuple\"}],\"name\":\"MonsterRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"ObjectRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dungeonId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"enum IGOC.ObjectType\",\"name\":\"objectType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"stageId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"kill\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"mintItems\",\"type\":\"address[]\"},{\"internalType\":\"int32\",\"name\":\"heal\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaRegen\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"lifeChancesRecovered\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"damage\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaConsumed\",\"type\":\"int32\"},{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"rewriteNextObject\",\"type\":\"uint32[]\"}],\"indexed\":false,\"internalType\":\"struct IGOC.ActionResult\",\"name\":\"result\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"ObjectResultEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"RevisionIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"}],\"name\":\"StoryRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTROLLABLE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"dungeonId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"stageId\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"action\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"kill\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"mintItems\",\"type\":\"address[]\"},{\"internalType\":\"int32\",\"name\":\"heal\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaRegen\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"lifeChancesRecovered\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"damage\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaConsumed\",\"type\":\"int32\"},{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"rewriteNextObject\",\"type\":\"uint32[]\"}],\"internalType\":\"struct IGOC.ActionResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"getEventInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"goodChance\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[]\",\"name\":\"goodAttributes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"badAttributes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"statsChange\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"mintItems\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct IGOC.EventInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFightDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"objId\",\"type\":\"uint32\"}],\"name\":\"getIteration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"getLastHeroFightTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"getMonsterInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"monsterId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"enum IGOC.ObjectSubType\",\"name\":\"subType\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"attributeIds\",\"type\":\"uint8[]\"},{\"internalType\":\"int32[]\",\"name\":\"attributeValues\",\"type\":\"int32[]\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"race\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"maxDropItems\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"attackToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"attackTokenId\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"attackType\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"mintItems\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"mintItemsChances\",\"type\":\"uint32[]\"}],\"internalType\":\"struct IGOC.MonsterGenInfo\",\"name\":\"mGenInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"generated\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"turnCounter\",\"type\":\"uint8\"},{\"internalType\":\"int32\",\"name\":\"hp\",\"type\":\"int32\"},{\"internalType\":\"uint32\",\"name\":\"amplifier\",\"type\":\"uint32\"}],\"internalType\":\"struct IGOC.GeneratedMonster\",\"name\":\"gen\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"heroNgLevel\",\"type\":\"uint8\"}],\"name\":\"getMonsterMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"enum IGOC.ObjectSubType\",\"name\":\"subType\",\"type\":\"uint8\"}],\"name\":\"getObjectIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"getObjectMeta\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"objectSubType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"getObjectTypeBySubType\",\"outputs\":[{\"internalType\":\"enum IGOC.ObjectType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"cTypes\",\"type\":\"uint8[]\"},{\"internalType\":\"uint32[]\",\"name\":\"chances\",\"type\":\"uint32[]\"},{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"getRandomObject\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"getStoryId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"increaseRevision\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"objId\",\"type\":\"uint32\"}],\"name\":\"isAvailableForHero\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"isBattleObject\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"open\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"eventId\",\"type\":\"uint16\"},{\"internalType\":\"enum IGOC.ObjectSubType\",\"name\":\"subType\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"goodChance\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"ids\",\"type\":\"uint8[]\"},{\"internalType\":\"int32[]\",\"name\":\"values\",\"type\":\"int32[]\"}],\"internalType\":\"struct IGOC.AttributeGenerateInfo\",\"name\":\"goodAttributes\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"ids\",\"type\":\"uint8[]\"},{\"internalType\":\"int32[]\",\"name\":\"values\",\"type\":\"int32[]\"}],\"internalType\":\"struct IGOC.AttributeGenerateInfo\",\"name\":\"badAttributes\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"int32\",\"name\":\"heal\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaRegen\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"lifeChancesRecovered\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"damage\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaConsumed\",\"type\":\"int32\"},{\"internalType\":\"address[]\",\"name\":\"mintItems\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"mintItemsChances\",\"type\":\"uint32[]\"}],\"internalType\":\"struct IGOC.EventRegInfo\",\"name\":\"regInfo\",\"type\":\"tuple\"}],\"name\":\"registerEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"monsterId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"enum IGOC.ObjectSubType\",\"name\":\"subType\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"attributeIds\",\"type\":\"uint8[]\"},{\"internalType\":\"int32[]\",\"name\":\"attributeValues\",\"type\":\"int32[]\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"race\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"maxDropItems\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"attackToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"attackTokenId\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"attackType\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"mintItems\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"mintItemsChances\",\"type\":\"uint32[]\"}],\"internalType\":\"struct IGOC.MonsterGenInfo\",\"name\":\"monsterGenInfo\",\"type\":\"tuple\"}],\"name\":\"registerMonster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"enum IGOC.ObjectSubType\",\"name\":\"subType\",\"type\":\"uint8\"}],\"name\":\"registerStory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"removeObject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidInitialization()\":[{\"details\":\"The contract is already initialized.\"}],\"NotInitializing()\":[{\"details\":\"The contract is not initializing.\"}]},\"events\":{\"Initialized(uint64)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"}},\"kind\":\"dev\",\"methods\":{\"created()\":{\"returns\":{\"_0\":\"Creation timestamp\"}},\"createdBlock()\":{\"returns\":{\"_0\":\"Creation block number\"}},\"getObjectMeta(uint32)\":{\"details\":\"represent object registration if non zero values\"},\"getRandomObject(uint8[],uint32[],uint8,address,uint256)\":{\"details\":\"Chances in range 0-1e9\"},\"increaseRevision(address)\":{\"details\":\"Revision should be increased on each contract upgrade\"},\"isController(address)\":{\"details\":\"Return true if given address is controller\"},\"previousImplementation()\":{\"details\":\"Previous logic implementation\"},\"revision()\":{\"details\":\"Contract upgrade counter\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"CONTROLLABLE_VERSION()\":{\"notice\":\"Version of the contract\"},\"VERSION()\":{\"notice\":\"Version of the contract\"},\"controller()\":{\"notice\":\"Return controller address saved in the contract slot\"},\"created()\":{\"notice\":\"Return creation timestamp\"},\"createdBlock()\":{\"notice\":\"Return creation block number\"},\"isGovernance(address)\":{\"notice\":\"Return true if given address is setup as governance in Controller\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/GameObjectController.sol\":\"GameObjectController\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":50},\"remappings\":[]},\"sources\":{\"contracts/core/GameObjectController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../proxy/Controllable.sol\\\";\\nimport \\\"../lib/GameObjectControllerLib.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\nimport \\\"../lib/EventLib.sol\\\";\\nimport \\\"../lib/StoryLib.sol\\\";\\nimport \\\"../lib/MonsterLib.sol\\\";\\nimport \\\"../lib/GOCLib.sol\\\";\\n\\ncontract GameObjectController is Controllable, IGOC {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using PackingLib for bytes32;\\n  using PackingLib for uint16;\\n  using PackingLib for uint8;\\n  using PackingLib for address;\\n  using PackingLib for uint32[];\\n  using PackingLib for uint32;\\n  using PackingLib for uint64;\\n  using PackingLib for int32[];\\n  using PackingLib for int32;\\n\\n  //region ------------------------ CONSTANTS\\n\\n  /// @notice Version of the contract\\n  string public constant VERSION = \\\"1.1.5\\\";\\n  //endregion ------------------------ CONSTANTS\\n\\n  //region ------------------------ INITIALIZER\\n\\n  function init(address controller_) external initializer {\\n    __Controllable_init(controller_);\\n  }\\n  //endregion ------------------------ INITIALIZER\\n\\n  //region ------------------------ VIEWS\\n\\n  function getObjectMeta(uint32 objectId) external view override returns (uint8 biome, uint8 objectSubType) {\\n    return GameObjectControllerLib.getObjectMeta(objectId);\\n  }\\n\\n  function isAvailableForHero(address heroToken, uint heroTokenId, uint32 objId) external view returns (bool) {\\n    return GameObjectControllerLib.isAvailableForHero(IController(controller()), heroToken, heroTokenId, objId);\\n  }\\n\\n  function isBattleObject(uint32 objectId) external view override returns (bool) {\\n    return GameObjectControllerLib.isBattleObject(objectId);\\n  }\\n\\n  function getObjectTypeBySubType(uint32 objectId) external view returns (ObjectType) {\\n    return GameObjectControllerLib.getObjectTypeBySubType(objectId);\\n  }\\n\\n  function getMonsterInfo(address hero, uint heroId, uint32 objectId) external view returns (IGOC.MonsterGenInfo memory mGenInfo, IGOC.GeneratedMonster memory gen) {\\n    return GameObjectControllerLib.getMonsterInfo(hero, heroId, objectId);\\n  }\\n\\n  function getIteration(address heroToken, uint heroTokenId, uint32 objId) external view returns (uint) {\\n    return GameObjectControllerLib.getIteration(heroToken, heroTokenId, objId);\\n  }\\n\\n  function getLastHeroFightTs(address heroToken, uint heroTokenId) external view returns (uint) {\\n    return GameObjectControllerLib.getLastHeroFightTs(heroToken, heroTokenId);\\n  }\\n\\n  function getFightDelay() external view returns (uint) {\\n    return GameObjectControllerLib.getFightDelay();\\n  }\\n\\n  function getStoryId(uint32 objectId) external view returns (uint16) {\\n    return GameObjectControllerLib.getStoryId(objectId);\\n  }\\n\\n  function getEventInfo(uint32 objectId) external view returns (EventInfo memory) {\\n    return GameObjectControllerLib.getEventInfo(objectId);\\n  }\\n\\n  function getObjectIds(uint8 biome, ObjectSubType subType) external view returns (uint[] memory) {\\n    return GameObjectControllerLib.getObjectIds(biome, subType);\\n  }\\n\\n  function getMonsterMultiplier(uint8 heroNgLevel) external pure returns (uint) {\\n    return MonsterLib.monsterMultiplier(heroNgLevel);\\n  }\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ REGISTRATION\\n\\n  function registerEvent(EventRegInfo memory regInfo) external {\\n    GameObjectControllerLib.registerEvent(IController(controller()), regInfo);\\n  }\\n\\n  function registerStory(uint16 storyId, uint8 biome, ObjectSubType subType) external {\\n    GameObjectControllerLib.registerStory(IController(controller()), storyId, biome, subType);\\n  }\\n\\n  function registerMonster(MonsterGenInfo memory monsterGenInfo) external {\\n    GameObjectControllerLib.registerMonster(IController(controller()), monsterGenInfo);\\n  }\\n\\n  function removeObject(uint32 objectId) external {\\n    GameObjectControllerLib.removeObject(IController(controller()), objectId);\\n  }\\n\\n  //endregion ------------------------ REGISTRATION\\n\\n  //region ------------------------ OBJECT\\n\\n  /// @dev Chances in range 0-1e9\\n  function getRandomObject(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biome,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external override returns (uint32 objectId) {\\n    return GameObjectControllerLib.getRandomObject(IController(controller()), cTypes, chances, biome, heroToken, heroTokenId);\\n  }\\n\\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external override returns (uint iteration) {\\n    return GameObjectControllerLib.open(IController(controller()), heroToken, heroTokenId, objectId);\\n  }\\n\\n  function action(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) external override returns (ActionResult memory) {\\n    return GameObjectControllerLib.action(IController(controller()), sender, dungeonId, objectId, heroToken, heroTokenId, stageId, data);\\n  }\\n\\n  //endregion ------------------------ OBJECT\\n\\n}\\n\",\"keccak256\":\"0xa4231fe5eaa02a2a7a4b2c034d7b5785a9bd28948b384e4c2aa362725e0d1df5\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IAppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @notice All errors of the app\\ninterface IAppErrors {\\n\\n  //region ERC20Errors\\n  /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n  error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n  /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n  error ERC20InvalidSender(address sender);\\n\\n  /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n  error ERC20InvalidReceiver(address receiver);\\n\\n  /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n  error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n  /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n  error ERC20InvalidApprover(address approver);\\n\\n  /**\\n   * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n  error ERC20InvalidSpender(address spender);\\n\\n  //endregion ERC20Errors\\n\\n  //region ERC721Errors\\n\\n  /**\\n  * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n  error ERC721InvalidOwner(address owner);\\n\\n  /**\\n   * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n  error ERC721NonexistentToken(uint256 tokenId);\\n\\n  /**\\n   * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n  error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n  /**\\n   * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n  error ERC721InvalidSender(address sender);\\n\\n  /**\\n   * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n  error ERC721InvalidReceiver(address receiver);\\n\\n  /**\\n   * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n  error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n  /**\\n   * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n  error ERC721InvalidApprover(address approver);\\n\\n  /**\\n   * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n  error ERC721InvalidOperator(address operator);\\n\\n  //endregion ERC721Errors\\n\\n  error ZeroAddress();\\n  error ZeroValueNotAllowed();\\n  error ZeroToken();\\n  error LengthsMismatch();\\n  error NotEnoughBalance();\\n  error NotEnoughAllowance();\\n  error EmptyNameNotAllowed();\\n  error NotInitialized();\\n  error AlreadyInitialized();\\n  error ReentrancyGuardReentrantCall();\\n  error TooLongString();\\n  error AlreadyDeployed(address deployed);\\n\\n  //region Restrictions\\n  error ErrorNotDeployer(address sender);\\n  error ErrorNotGoc();\\n  error NotGovernance(address sender);\\n  error ErrorOnlyEoa();\\n  error NotEOA(address sender);\\n  error ErrorForbidden(address sender);\\n  error AdminOnly();\\n  error ErrorNotItemController(address sender);\\n  error ErrorNotHeroController(address sender);\\n  error ErrorNotDungeonFactory(address sender);\\n  error ErrorNotObjectController(address sender);\\n  error ErrorNotStoryController();\\n  error ErrorNotAllowedSender();\\n  error MintNotAllowed();\\n  //endregion Restrictions\\n\\n  //region PackingLib\\n  error TooHighValue(uint value);\\n  error IntValueOutOfRange(int value);\\n  error OutOfBounds(uint index, uint length);\\n  error UnexpectedValue(uint expected, uint actual);\\n  error WrongValue(uint newValue, uint actual);\\n  error IntOutOfRange(int value);\\n  error ZeroValue();\\n  /// @notice packCustomDataChange requires an input string with two zero bytes at the beginning\\n  ///         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// This error happens if these bytes are not zero\\n  error IncompatibleInputString();\\n  error IncorrectOtherItemTypeKind(uint8 kind);\\n  //endregion PackingLib\\n\\n  //region Hero\\n  error ErrorHeroIsNotRegistered(address heroToken);\\n  error ErrorHeroIsDead(address heroToken, uint heroTokenId);\\n  error ErrorHeroNotInDungeon();\\n  error HeroInDungeon();\\n  error ErrorNotOwner(address token, uint tokenId);\\n  error Staked(address heroToken, uint heroId);\\n  error NameTaken();\\n  error TooBigName();\\n  error WrongSymbolsInTheName();\\n  error NoPayToken(address token, uint payTokenAmount);\\n  error AlreadyHaveReinforcement();\\n  /// @notice SIP-001 - Reinforcement requires 3 skills\\n  error ErrorReinforcementRequiresThreeSkills();\\n  error WrongTier(uint tier);\\n  error NotEnoughNgLevel(uint8 ngLevel);\\n  error NgpNotActive(address hero);\\n  error RebornNotAllowed();\\n  error AlreadyPrePaidHero();\\n  //endregion Hero\\n\\n  //region Dungeon\\n  error ErrorDungeonIsFreeAlready();\\n  error ErrorNoEligibleDungeons();\\n  error ErrorDungeonBusy();\\n  error ErrorNoDungeonsForBiome(uint8 heroBiome);\\n  error ErrorDungeonCompleted();\\n  error ErrorAlreadyInDungeon();\\n  error NotEnoughTokens(uint balance, uint expectedBalance);\\n  error DungeonAlreadySpecific(uint16 dungNum);\\n  error DungeonAlreadySpecific2(uint16 dungNum);\\n  error WrongSpecificDungeon();\\n  //endregion Dungeon\\n\\n  //region Items\\n  error ErrorItemNotEligibleForTheSlot(uint itemType, uint8 itemSlot);\\n  error ErrorItemSlotBusyHand(uint8 slot);\\n  error ErrorItemSlotBusy();\\n  error ErrorItemNotInSlot();\\n  error ErrorConsumableItemIsUsed(address item);\\n  error ErrorCannotRemoveItemFromMap();\\n  error ErrorCannotRemoveDataFromMap();\\n  error EquippedItemsExist();\\n  error ItemEquipped(address item, uint itemId);\\n  error ZeroItemMetaType();\\n  error NotZeroOtherItemMetaType();\\n  error ZeroLevel();\\n  error ItemTypeChanged();\\n  error ItemMetaTypeChanged();\\n  error UnknownItem(address item);\\n  error ErrorEquipForbidden();\\n  error EquipForbiddenInDungeon();\\n  error TakeOffForbiddenInDungeon();\\n  error Consumable(address item);\\n  error NotConsumable(address item);\\n  error Broken(address item);\\n  error ZeroLife();\\n  error RequirementsToItemAttributes();\\n  error NotEquipped(address item);\\n  error ZeroDurability();\\n  error ZeroAugmentation();\\n  error TooHighAgLevel(uint8 augmentationLevel);\\n  error UseForbiddenZeroPayToken();\\n  error IncorrectMinMaxAttributeRange(int32 min, int32 max);\\n  error SameIdsNotAllowed();\\n  error ZeroFragility();\\n  error OtherTypeItemNotRepairable();\\n  error NotOther();\\n  error DoubleItemUsageForbidden(uint itemIndex, address[] items);\\n  error ItemAlreadyUsedInSlot(address item, uint8 equippedSlot);\\n  error WrongWayToRegisterItem();\\n  error UnionItemNotFound(address item);\\n  error WrongListUnionItemTokens(address item, uint countTokens, uint requiredCountTokens);\\n  error UnknownUnionConfig(uint unionConfigId);\\n  error UserHasNoKeyPass(address user, address keyPassItem);\\n  error MaxValue(uint value);\\n  error UnexpectedOtherItem(address item);\\n  error NotExist();\\n  //endregion Items\\n\\n  //region Stages\\n  error ErrorWrongStage(uint stage);\\n  error ErrorNotStages();\\n  //endregion Stages\\n\\n  //region Level\\n  error ErrorWrongLevel(uint heroLevel);\\n  error ErrorLevelTooLow(uint heroLevel);\\n  error ErrorHeroLevelStartFrom1();\\n  error ErrorWrongLevelUpSum();\\n  error ErrorMaxLevel();\\n  //endregion Level\\n\\n  //region Treasure\\n  error ErrorNotValidTreasureToken(address treasureToken);\\n  //endregion Treasure\\n\\n  //region State\\n  error ErrorPaused();\\n  error ErrorNotReady();\\n  error ErrorNotObject1();\\n  error ErrorNotObject2();\\n  error ErrorNotCompleted();\\n  //endregion State\\n\\n  //region Biome\\n  error ErrorNotBiome();\\n  error ErrorIncorrectBiome(uint biome);\\n  error TooHighBiome(uint biome);\\n  //endregion Biome\\n\\n  //region Misc\\n  error ErrorWrongMultiplier(uint multiplier);\\n  error ErrorNotEnoughMana(uint32 mana, uint requiredMana);\\n  error ErrorExperienceMustNotDecrease();\\n  error ErrorNotEnoughExperience();\\n  error ErrorNotChances();\\n  error ErrorNotEligible(address heroToken, uint16 dungNum);\\n  error ErrorZeroKarmaNotAllowed();\\n  //endregion Misc\\n\\n  //region GOC\\n  error GenObjectIdBiomeOverflow(uint8 biome);\\n  error GenObjectIdSubTypeOverflow(uint subType);\\n  error GenObjectIdIdOverflow(uint id);\\n  error UnknownObjectTypeGoc1(uint8 objectType);\\n  error UnknownObjectTypeGoc2(uint8 objectType);\\n  error UnknownObjectTypeGocLib1(uint8 objectType);\\n  error UnknownObjectTypeGocLib2(uint8 objectType);\\n  error UnknownObjectTypeForSubtype(uint8 objectSubType);\\n  error FightDelay();\\n  error ZeroChance();\\n  error TooHighChance(uint32 chance);\\n  error TooHighRandom(uint random);\\n  error EmptyObjects();\\n  error ObjectNotFound();\\n  error WrongGetObjectTypeInput();\\n  error WrongChances(uint32 chances, uint32 maxChances);\\n  //endregion GOC\\n\\n  //region Story\\n  error PageNotRemovedError(uint pageId);\\n  error NotItem1();\\n  error NotItem2();\\n  error NotRandom(uint32 random);\\n  error NotHeroData();\\n  error NotGlobalData();\\n  error ZeroStoryIdRemoveStory();\\n  error ZeroStoryIdStoryAction();\\n  error ZeroStoryIdAction();\\n  error NotEnoughAmount(uint balance, uint requiredAmount);\\n  error NotAnswer();\\n  error AnswerStoryIdMismatch(uint16 storyId, uint16 storyIdFromAnswerHash);\\n  error AnswerPageIdMismatch(uint16 pageId, uint16 pageIdFromAnswerHash);\\n  //endregion Story\\n\\n  //region FightLib\\n  error NotMagic();\\n  error NotAType(uint atype);\\n  //endregion FightLib\\n\\n  //region MonsterLib\\n  error NotYourDebuffItem();\\n  error UnknownAttackType(uint attackType);\\n  error NotYourAttackItem();\\n  /// @notice The skill item cannot be used because it doesn't belong either to the hero or to the hero's helper\\n  error NotYourBuffItem();\\n  //endregion MonsterLib\\n\\n  //region GameToken\\n  error ApproveToZeroAddress();\\n  error MintToZeroAddress();\\n  error TransferToZeroAddress();\\n  error TransferAmountExceedsBalance(uint balance, uint value);\\n  error InsufficientAllowance();\\n  error BurnAmountExceedsBalance();\\n  error NotMinter(address sender);\\n  //endregion GameToken\\n\\n  //region NFT\\n  error TokenTransferNotAllowed();\\n  error IdOverflow(uint id);\\n  error NotExistToken(uint tokenId);\\n  error EquippedItemIsNotAllowedToTransfer(uint tokenId);\\n  //endregion NFT\\n\\n  //region CalcLib\\n  error TooLowX(uint x);\\n  //endregion CalcLib\\n\\n  //region Controller\\n  error NotFutureGovernance(address sender);\\n  //endregion Controller\\n\\n  //region Oracle\\n  error OracleWrongInput();\\n  //endregion Oracle\\n\\n  //region ReinforcementController\\n  error AlreadyStaked();\\n  error MaxFee(uint8 fee);\\n  error MinFee(uint8 fee);\\n  error StakeHeroNotStats();\\n  error NotStaked();\\n  error NoStakedHeroes();\\n  error GuildHelperNotAvailable(uint guildId, address helper, uint helperId);\\n  error HelperNotAvailableInGivenBiome();\\n  //endregion ReinforcementController\\n\\n  //region SponsoredHero\\n  error InvalidHeroClass();\\n  error ZeroAmount();\\n  error InvalidProof();\\n  error NoHeroesAvailable();\\n  error AlreadyRegistered();\\n  //endregion SponsoredHero\\n\\n  //region SacraRelay\\n  error SacraRelayNotOwner();\\n  error SacraRelayNotDelegator();\\n  error SacraRelayNotOperator();\\n  error SacraRelayInvalidChainId(uint callChainId, uint blockChainId);\\n  error SacraRelayInvalidNonce(uint callNonce, uint txNonce);\\n  error SacraRelayDeadline();\\n  error SacraRelayDelegationExpired();\\n  error SacraRelayNotAllowed();\\n  error SacraRelayInvalidSignature();\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error by selector, see tests\\n  error SacraRelayNoErrorSelector(bytes4 selector, string tracingInfo);\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error manually from {errorBytes} as following:\\n  /// if (keccak256(abi.encodeWithSignature(\\\"MyError()\\\")) == keccak256(errorBytes)) { ... }\\n  error SacraRelayUnexpectedReturnData(bytes errorBytes, string tracingInfo);\\n  error SacraRelayCallToNotContract(address notContract, string tracingInfo);\\n  //endregion SacraRelay\\n\\n  //region Misc\\n  error UnknownHeroClass(uint heroClass);\\n  error AbsDiff(int32 a, int32 b);\\n  //region Misc\\n\\n  //region ------------------------ UserController\\n  error NoAvailableLootBox(address msgSender, uint lootBoxKind);\\n  error FameHallHeroAlreadyRegistered(uint8 openedNgLevel);\\n\\n  //endregion ------------------------ UserController\\n\\n  //region ------------------------ Guilds\\n  error AlreadyGuildMember();\\n  error NotGuildMember();\\n  error WrongGuild();\\n  error GuildActionForbidden(uint right);\\n  error GuildHasMaxSize(uint guildSize);\\n  error GuildHasMaxLevel(uint level);\\n  error TooLongUrl();\\n  error TooLongDescription();\\n  error CannotRemoveGuildOwnerFromNotEmptyGuild();\\n  error GuildControllerOnly();\\n  error GuildAlreadyHasShelter();\\n  error ShelterIsBusy();\\n  error ShelterIsNotRegistered();\\n  error ShelterIsNotOwnedByTheGuild();\\n  error ShelterIsInUse();\\n  error GuildHasNoShelter();\\n  error ShelterBidIsNotAllowedToBeUsed();\\n  error ShelterHasHeroesInside();\\n  error SecondGuildAdminIsNotAllowed();\\n  error NotEnoughGuildBankBalance(uint guildId);\\n\\n  error GuildReinforcementCooldownPeriod();\\n  error NoStakedGuildHeroes();\\n  error NotStakedInGuild();\\n  error ShelterHasNotEnoughLevelForReinforcement();\\n  error NotBusyGuildHelper();\\n\\n  error GuildRequestNotActive();\\n  error GuildRequestNotAvailable();\\n  error NotAdminCannotAddMemberWithNotZeroRights();\\n  //endregion ------------------------ Guilds\\n\\n  //region ------------------------ Shelters\\n  error ErrorNotShelterController();\\n  error ErrorNotGuildController();\\n  error ShelterHasNotItem(uint shelterId, address item);\\n  error MaxNumberItemsSoldToday(uint numSoldItems, uint limit);\\n  error GuildHasNotEnoughPvpPoints(uint64 pointsAvailable, uint pointRequired);\\n  error FreeShelterItemsAreNotAllowed(uint shelterId, address item);\\n  error TooLowShelterLevel(uint8 shelterLevel, uint8 allowedShelterLevel);\\n  error NotEnoughPvpPointsCapacity(address user, uint usedPoints, uint pricePvpPoints, uint64 capactiy);\\n  error IncorrectShelterLevel(uint8 shelterLevel);\\n  //endregion ------------------------ Shelters\\n\\n  //region ------------------------ Auction\\n  error WrongAuctionPosition();\\n  error AuctionPositionClosed();\\n  error AuctionBidOpened(uint positionId);\\n  error TooLowAmountToBid();\\n  error AuctionEnded();\\n  error TooLowAmountForNewBid();\\n  error AuctionSellerOnly();\\n  error AuctionBuyerOnly();\\n  error AuctionBidNotFound();\\n  error AuctionBidClosed();\\n  error OnlyShelterAuction();\\n  error CannotCloseLastBid();\\n  error AuctionNotEnded();\\n  error NotShelterAuction();\\n  error AuctionPositionOpened(uint positionId);\\n  error AuctionSellerCannotBid();\\n  error CannotApplyNotLastBid();\\n  error AuctionGuildWithShelterCannotBid();\\n  //endregion ------------------------ Auction\\n\\n  //region ------------------------ Pawnshop\\n  error AuctionPositionNotSupported(uint positionId);\\n  error PositionNotSupported(uint positionId);\\n  error NotNftPositionNotSupported(uint positionId);\\n  error CallFailed(bytes callResultData);\\n\\n  error PawnShopZeroOwner();\\n  error PawnShopZeroFeeRecipient();\\n  error PawnShopNotOwner();\\n  error PawnShopAlreadyAnnounced();\\n  error PawnShopTimeLock();\\n  error PawnShopWrongAddressValue();\\n  error PawnShopWrongUintValue();\\n  error PawnShopZeroAddress();\\n  error PawnShopTooHighValue();\\n  error PawnShopZeroAToken();\\n  error PawnShopZeroCToken();\\n  error PawnShopWrongAmounts();\\n  error PawnShopPosFeeForInstantDealForbidden();\\n  error PawnShopPosFeeAbsurdlyHigh();\\n  error PawnShopIncorrect();\\n  error PawnShopWrongId();\\n  error PawnShopNotBorrower();\\n  error PawnShopPositionClosed();\\n  error PawnShopPositionExecuted();\\n  error PawnShopWrongBidAmount();\\n  error PawnShopTooLowBid();\\n  error PawnShopNewBidTooLow();\\n  error PawnShopBidAlreadyExists();\\n  error PawnShopAuctionEnded();\\n  error PawnShopNotLender();\\n  error PawnShopTooEarlyToClaim();\\n  error PawnShopPositionNotExecuted();\\n  error PawnShopAlreadyClaimed();\\n  error PawnShopAuctionNotEnded();\\n  error PawnShopBidClosed();\\n  error PawnShopNoBids();\\n  error PawnShopAuctionBidNotFound();\\n  error PawnShopWrongBid();\\n  error PawnShopBidNotFound();\\n\\n  //endregion ------------------------ Pawnshop\\n}\\n\\n\",\"keccak256\":\"0x99ca976a36aded6991d48e7c8eed1585784957183cfd60003f86b37050178875\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IApplicationEvents.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IDungeonFactory.sol\\\";\\nimport \\\"./IStoryController.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\n\\n/// @notice All events of the app\\ninterface IApplicationEvents {\\n\\n  //region ------------------ StatController\\n  event HeroItemSlotChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint itemType,\\n    uint itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip,\\n    address caller\\n  );\\n  event CurrentStatsChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats change,\\n    bool increase,\\n    address caller\\n  );\\n  event BonusAttributesChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    bool add,\\n    bool temporally,\\n    address caller\\n  );\\n  event TemporallyAttributesCleared(address heroToken, uint heroTokenId, address caller);\\n  event NewHeroInited(address heroToken, uint heroTokenId, IStatController.ChangeableStats stats);\\n  event LevelUp(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes change\\n  );\\n  event ConsumableUsed(address heroToken, uint heroTokenId, address item);\\n  event RemoveConsumableUsage(address heroToken, uint heroTokenId, address item);\\n  event HeroCustomDataChanged(address token, uint tokenId, bytes32 index, uint value);\\n  event HeroCustomDataChangedNg(address token, uint tokenId, bytes32 index, uint value, uint8 ngLevel);\\n  event HeroCustomDataCleared(address token, uint tokenId);\\n  event GlobalCustomDataChanged(bytes32 index, uint value);\\n  //endregion ------------------ StatController\\n\\n  //region ------------------ DungeonFactoryController\\n  event DungeonLaunched(\\n    uint16 dungeonLogicNum,\\n    uint64 dungeonId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken,\\n    uint treasuryAmount\\n  );\\n\\n  event BossCompleted(uint32 objectId, uint biome, address hero, uint heroId);\\n  event FreeDungeonAdded(uint8 biome, uint64 dungeonId);\\n\\n  event ObjectOpened(uint64 dungId, address hero, uint id, uint32 objId, uint iteration, uint currentStage);\\n  event Clear(uint64 dungId);\\n\\n  event DungeonLogicRegistered(uint16 dungLogicId, IDungeonFactory.DungeonGenerateInfo info);\\n  event DungeonLogicRemoved(uint16 dungLogicId);\\n  event DungeonSpecificLogicRegistered(uint16 dungLogicId, uint biome, uint heroCls);\\n  event DungeonSpecificLogicRemoved(uint16 dungLogicId, uint heroLvl, uint heroCls);\\n  event DungeonRegistered(uint16 dungLogicId, uint64 dungeonId);\\n  event DungeonRemoved(uint16 dungLogicId, uint64 dungeonId);\\n  event MinLevelForTreasuryChanged(address token, uint level);\\n\\n  event ObjectAction(\\n    uint64 dungId,\\n    IGOC.ActionResult result,\\n    uint currentStage,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint newStage\\n  );\\n  /// @notice On add the item to the dungeon\\n  event AddTreasuryItem(uint64 dungId, address itemAdr, uint itemId);\\n  event AddTreasuryToken(uint64 dungId, address token, uint amount);\\n  event ClaimToken(uint64 dungId, address token, uint amount);\\n  event ClaimItem(uint64 dungId, address token, uint id);\\n\\n  event Entered(uint64 dungId, address hero, uint id);\\n  event DungeonCompleted(uint16 dungLogicNum, uint64 dungId, address hero, uint heroId);\\n  event Exit(uint64 dungId, bool claim);\\n  event ExitForcibly(uint64 dungId, address hero, uint heroId);\\n  event FreeDungeonRemoved(uint8 biome, uint64 dungeonId);\\n  event HeroCurrentDungeonChanged(address hero, uint heroId, uint64 dungeonId);\\n  //endregion ------------------ DungeonFactoryController\\n\\n  //region ------------------ GameObjectController\\n  event EventRegistered(uint32 objectId, IGOC.EventRegInfo eventRegInfo);\\n  event StoryRegistered(uint32 objectId, uint16 storyId);\\n  event MonsterRegistered(uint32 objectId, IGOC.MonsterGenInfo monsterGenInfo);\\n  event ObjectRemoved(uint32 objectId);\\n  event ObjectResultEvent(\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    IGOC.ObjectType objectType,\\n    address hero,\\n    uint heroId,\\n    uint8 stageId,\\n    uint iteration,\\n    bytes data,\\n    IGOC.ActionResult result,\\n    uint salt\\n  );\\n  //endregion ------------------ GameObjectController\\n\\n  //region ------------------ StoryController\\n  event SetBurnItemsMeta(uint storyId, IStoryController.AnswerBurnRandomItemMeta meta);\\n  event SetNextObjRewriteMeta(uint storyId, IStoryController.NextObjRewriteMeta meta);\\n  event SetAnswersMeta(uint storyId, uint16[] answerPageIds, uint8[] answerHeroClasses, uint16[] answerIds);\\n  event SetAnswerNextPageMeta(uint storyId, IStoryController.AnswerNextPageMeta meta);\\n  event SetAnswerAttributeRequirements(uint storyId, IStoryController.AnswerAttributeRequirementsMeta meta);\\n  event SetAnswerItemRequirements(uint storyId, IStoryController.AnswerItemRequirementsMeta meta);\\n  event SetAnswerTokenRequirementsMeta(uint storyId, IStoryController.AnswerTokenRequirementsMeta meta);\\n  event SetAnswerAttributes(uint storyId, IStoryController.AnswerAttributesMeta meta);\\n  event SetAnswerHeroCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetAnswerGlobalCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetSuccessInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetFailInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetCustomDataResult(uint storyId, IStoryController.AnswerCustomDataResultMeta meta, IStoryController.CustomDataResult _type);\\n  event StoryCustomDataRequirements(uint storyId, bytes32 requiredCustomDataIndex, uint requiredCustomDataMinValue, uint requiredCustomDataMaxValue, bool requiredCustomDataIsHero);\\n  event StoryRequiredLevel(uint storyId, uint requiredLevel);\\n  event StoryFinalized(uint32 objectId, uint storyId);\\n  event StoryRemoved(uint32 objectId, uint storyId);\\n\\n  event ItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  /// @notice Durability of the item was reduced to 0\\n  event ItemBroken(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n\\n  event NotEquippedItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event StoryChangeAttributes(\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    uint stageId,\\n    uint iteration,\\n    int32[] attributes\\n  );\\n  //endregion ------------------ StoryController\\n\\n  //region ------------------------ HeroController\\n  event HeroRegistered(address hero, uint8 heroClass, address payToken, uint payAmount);\\n  event HeroCreatedNgp(address hero, uint heroId, string name, address owner, string refCode, uint8 tier, uint8 ngLevel);\\n  event BiomeChanged(address hero, uint heroId, uint8 biome);\\n  event LevelUp(address hero, uint heroId, address owner, IStatController.CoreAttributes change);\\n  event ReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event GuildReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event OtherItemGuildReinforcement(address item, uint itemId, address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event ReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event GuildReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event Killed(address hero, uint heroId, address killer, bytes32[] dropItems, uint dropTokenAmount);\\n  event Reborn(address hero, uint heroId, uint8 newNgLevel);\\n  event BossKilled(address account, address hero, uint heroId, uint8 biome, uint8 newNgLevel, bool reborn, uint rewardAmount);\\n  event TierSetup(uint8 tier, address hero, uint72 payAmount, uint8[] slots, address[][] items);\\n  //endregion ------------------------ HeroController\\n\\n  //region ------------------------ FightLib\\n  event FightResultProcessed(\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    IFightCalculator.FightCall callData,\\n    uint iteration\\n  );\\n  //endregion ------------------------ FightLib\\n\\n  //region ------------------------ Oracle\\n  event Random(uint number, uint max);\\n  //endregion ------------------------ Oracle\\n\\n  //region ------------------------ Controller\\n  event OfferGovernance(address newGov);\\n  event GovernanceAccepted(address gov);\\n  event StatControllerChanged(address value);\\n  event StoryControllerChanged(address value);\\n  event GameObjectControllerChanged(address value);\\n  event ReinforcementControllerChanged(address value);\\n  event OracleChanged(address value);\\n  event TreasuryChanged(address value);\\n  event ItemControllerChanged(address value);\\n  event HeroControllerChanged(address value);\\n  event GameTokenChanged(address value);\\n  event DungeonFactoryChanged(address value);\\n  event ProxyUpdated(address proxy, address logic);\\n  event Claimed(address token, uint amount);\\n  event TokenStatusChanged(address token, bool status);\\n  event UserControllerChanged(address value);\\n  event GuildControllerChanged(address value);\\n  event GameTokenPriceChanged(uint value);\\n  event RewardsPoolChanged(address value);\\n  event Process(address token, uint amount, address from, uint toBurn, uint toTreasury, uint toGov);\\n  //endregion ------------------------ Controller\\n\\n\\n  //region ------------------------ ReinforcementController\\n  event HeroStaked(address heroToken, uint heroId, uint biome, uint score);\\n  event HeroStakedV2(address heroToken, uint heroId, uint biome, uint rewardAmount);\\n  event HeroWithdraw(address heroToken, uint heroId);\\n  event HeroAsk(address heroToken, uint heroId);\\n  event HeroAskV2(address heroToken, uint heroId, uint hitsLast24h, uint fixedFee, uint helperRewardAmount);\\n  event TokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint totalAmount);\\n  event GuildTokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint guildId);\\n  event NftRewardRegistered(address heroToken, uint heroId, address token, uint id);\\n  event GuildNftRewardRegistered(address heroToken, uint heroId, address token, uint id, uint guildId);\\n  event ToHelperRatioChanged(uint value);\\n  event ClaimedToken(address heroToken, uint heroId, address token, uint amount, address recipient);\\n  event ClaimedItem(address heroToken, uint heroId, address item, uint itemId, address recipient);\\n  event MinLevelChanged(uint8 value);\\n  event MinLifeChancesChanged(uint value);\\n  //endregion ------------------------ ReinforcementController\\n\\n  //region ------------------------ Treasury, reward pool\\n  event AssetsSentToDungeon(address dungeon, address token, uint amount);\\n  event RewardSentToUser(address receiver, address token, uint rewardAmount);\\n  event NotEnoughReward(address receiver, address token, uint rewardAmountToPay);\\n  event BaseAmountChanged(uint oldValue, uint newValue);\\n  //endregion ------------------------ Treasury, reward pool\\n\\n  //region ------------------------ EventLib\\n  event EventResult(uint64 dungeonId, address heroToken, uint heroTokenId, uint8 stageId, IStatController.ActionInternalInfo gen, uint iteration);\\n  //endregion ------------------------ EventLib\\n\\n  //region ------------------------ Item controller and helper contracts\\n  event ItemRegistered(address item, IItemController.RegisterItemParams info);\\n  event OtherItemRegistered(address item, IItemController.ItemMeta meta, bytes packedItemMetaData);\\n  event ItemRemoved(address item);\\n  event OtherItemRemoved(address item);\\n  event NewItemMinted(address item, uint itemId, IItemController.MintInfo info);\\n  event Equipped(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot);\\n  event TakenOff(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot, address destination);\\n  event ItemRepaired(address item, uint itemId, uint consumedItemId, uint16 baseDurability);\\n  event FailedToRepairItem(address item, uint itemId, uint consumedItemId, uint16 itemDurability);\\n  event Augmented(address item, uint itemId, uint consumedItemId, uint8 augLevel, IItemController.AugmentInfo info);\\n  event NotAugmented(address item, uint itemId, uint consumedItemId, uint8 augLevel);\\n  event ReduceDurability(address item, uint itemId, uint newDurability);\\n  event Used(address item, uint tokenId, address heroToken, uint heroTokenId);\\n  event Destroyed(address item, uint itemId);\\n  event FragilityReduced(address item, uint itemId, address consumedItem, uint consumedItemId, uint fragility);\\n  event ItemControllerHelper(address helper);\\n  event SetUnionConfig(uint configId, address[] items, uint[] count, address itemToMint);\\n  event RemoveUnionConfig(uint configId);\\n  event SetUnionKeyPass(address keyPassItem);\\n  event CombineItems(address msgSender, uint configId, address[] items, uint[][] itemIds, address mintedItem, uint mintedItemId);\\n  //endregion ------------------------ Item controller and helper contracts\\n\\n  //region ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n  event ChangePauseStatus(bool value);\\n  event MinterChanged(address value);\\n\\n  event UniqueUriChanged(uint id, string uri);\\n  event BaseUriChanged(string uri);\\n\\n  event HeroMinted(uint heroId);\\n  event HeroBurned(uint heroId);\\n  event HeroUriByStatusChanged(string uri, uint statusLvl);\\n\\n  event ItemMinted(uint tokenId);\\n  event ItemBurned(uint tokenId);\\n  event UriByRarityChanged(string uri, uint rarity);\\n  event SponsoredHeroCreated(address msgSender, address heroAddress, uint heroId, string heroName);\\n  //endregion ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n\\n  //region ------------------------ User controller\\n  event SetUserName(address user, string name);\\n  event SetUserAvatar(address user, string avatar);\\n  event LootBoxOpened(address user, uint lootBoxKind, address[] itemTokens, uint[] itemTokenIds);\\n  event LootBoxConfigChanged(uint lootBoxKind, address[] mintItems, uint32[] mintItemsChances, uint maxDropItems);\\n  event SetFeeRenaming(uint feeRenaming);\\n  event ActivityCompleted(address user, bool daily, bool weekly);\\n  event FameHallHeroRegistered(address hero, uint heroId, address heroOwner, uint8 openedNgLevel);\\n  //endregion ------------------------ User controller\\n\\n  //region ------------------------ Guild\\n\\n  event GuildCreated(address owner, uint guildId, string name, string urlLogo);\\n  event AddToGuild(uint guildId, address newUser);\\n  event ChangeGuildRights(uint guildId, address user, uint rights);\\n  event RemoveFromGuild(uint guildId, address user);\\n  event GuildDeleted(uint guildId);\\n  event GuildLevelUp(uint guildId, uint8 newLevel);\\n  event GuildRename(uint guildId, string newName);\\n  event GuildLogoChanged(uint guildId, string newLogoUrl);\\n  event GuildDescriptionChanged(uint guildId, string newDescription);\\n  event SetGuildRelation(uint guildId1, uint guildId2, bool peace);\\n  event TransferFromGuildBank(address user, address token, uint amount, address recipient);\\n  event TransferNftFromGuildBank(address user, address[] nfts, uint[] tokenIds, address recipient);\\n  event GuildBankDeployed(uint guildId, address guildBank);\\n\\n  event SetToHelperRatio(uint guildId, uint8 value, address user);\\n  event TopUpGuildBank(address msgSender, uint guildId, address guildBank, uint amount);\\n\\n  event GuildRequestRegistered(address msgSender, uint guildId, string userMessage, uint depositAmount);\\n  event GuildRequestStatusChanged(address msgSender, uint guildRequestId, uint8 newStatus, address user);\\n  event SetToHelperRatio(uint guildId, address msgSender, uint8 toHelperRatio);\\n  event SetGuildRequestDepositAmount(uint guildId, address msgSender, uint amount);\\n  event SetGuildBaseFee(uint fee);\\n  event SetPvpPointsCapacity(address msgSender, uint64 capacityPvpPoints, address[] users);\\n  event SetShelterController(address shelterController);\\n  event SetShelterAuction(address shelterAuction);\\n  event PayForBidFromGuildBank(uint guildId, uint amount, uint bid);\\n  //endregion ------------------------ Guild\\n\\n  //region ------------------------ Guild shelter\\n  event RegisterShelter(uint sheleterId, uint price);\\n  event SetShelterItems(\\n    uint shelterId,\\n    address[] items,\\n    uint64[] pricesInPvpPoints,\\n    uint128[] pricesInGameTokens,\\n    uint16[] maxItemsPerDayThresholds\\n  );\\n  event RemoveShelterItems(uint shelterId, address[] items);\\n  event BuyShelter(uint guidlId, uint shelterId);\\n  event LeaveShelter(uint guildId, uint shelterId);\\n  event NewShelterBid(uint shelterId, uint buyerGuildId, uint amount);\\n  event RevokeShelterBid(uint shelterId);\\n  event UseShelterBid(uint shelterId, uint sellerGuildId, uint buyerGuidId, uint amount);\\n  event PurchaseShelterItem(address msgSender, address item, uint numSoldItems, uint priceInPvpPoints, uint priceInGameToken);\\n  event ChangeShelterOwner(uint shelterId, uint fromGuildId, uint toGuildId);\\n  event RestInShelter(address msgSender, address heroToken, uint heroTokenId);\\n  //endregion ------------------------ Guild shelter\\n\\n  //region ------------------------ Guild reinforcement\\n  event GuildHeroStaked(address heroToken, uint heroId, uint guildId);\\n  event GuildHeroWithdrawn(address heroToken, uint heroId, uint guildId);\\n  event GuildHeroAsked(address heroToken, uint heroId, uint guildId, address user);\\n\\n  /// @param user Address can be 0 if heroId was already burnt at the moment of reinforcement releasing\\n  event GuildHeroReleased(address heroToken, uint heroId, uint guildId, address user);\\n  //endregion ------------------------ Guild reinforcement\\n\\n  //region ------------------------ Guild auction\\n  event AuctionPositionOpened(uint positionId, uint shelterId, uint sellerGuildId, address msgSender, uint minAuctionPrice);\\n  event AuctionPositionClosed(uint positionId, address msgSender);\\n  event AuctionBidOpened(uint bidId, uint positionId, uint amount, address msgSender);\\n  //endregion ------------------------ Guild auction\\n\\n  //region ------------------------ Guild bank\\n  event GuildBankTransfer(address token, address recipient, uint amount);\\n  event GuildBankTransferNft(address to, address nft, uint tokenId);\\n  event GuildBankTransferNftMulti(address to, address[] nfts, uint[] tokenIds);\\n  //endregion ------------------------ Guild bank\\n\\n  //region ------------------------ Pawnshop\\n  event PawnShopRouterDeployed(address pawnShop, address gameToken, address routerOwner, address deployed);\\n  event PawnShopRouterTransfer(address token, uint amount, address receiver);\\n  event PawnShopRouterBulkSell(address[] nfts, uint[] nftIds, uint[] prices, address nftOwner, uint[] positionIds);\\n  event PawnShopRouterClosePositions(uint[] positionIds, address receiver);\\n  event PawnShopRouterBulkBuy(uint[] positionIds, address receiver);\\n\\n  //endregion ------------------------ Pawnshop\\n}\\n\",\"keccak256\":\"0xf718b42b00e9d4b03e0b0ac43b403fe25baea08e10ccbd9f75ebc0ed40232318\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IControllable {\\n\\n  function VERSION() external pure returns (string memory);\\n\\n  function revision() external view returns (uint);\\n\\n  function previousImplementation() external view returns (address);\\n\\n  function isController(address contract_) external view returns (bool);\\n\\n  function isGovernance(address contract_) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0x296b634c46b5d178b2408523fcf569ed370e20a719b7b3f2183b278631b94f65\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IController {\\n\\n  function governance() external view returns (address);\\n\\n  function statController() external view returns (address);\\n\\n  function storyController() external view returns (address);\\n\\n  function gameObjectController() external view returns (address);\\n\\n  function reinforcementController() external view returns (address);\\n\\n  function oracle() external view returns (address);\\n\\n  function treasury() external view returns (address);\\n\\n  function itemController() external view returns (address);\\n\\n  function heroController() external view returns (address);\\n\\n  function dungeonFactory() external view returns (address);\\n\\n  function gameToken() external view returns (address);\\n\\n  function validTreasuryTokens(address token) external view returns (bool);\\n\\n  function isDeployer(address adr) external view returns (bool);\\n\\n  function onPause() external view returns (bool);\\n\\n  function userController() external view returns (address);\\n\\n  function guildController() external view returns (address);\\n\\n  function rewardsPool() external view returns (address);\\n\\n  function gameTokenPrice() external view returns (uint);\\n\\n  function process(address token, uint amount, address from) external;\\n}\\n\",\"keccak256\":\"0xb10c5b5c21f1794f98ab2b46f559ad86ae909d9beba674e68a29ab85c8947d7f\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDungeonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IDungeonFactory {\\n\\n  /// @custom:storage-location erc7201:dungeon.factory.main\\n  struct MainState {\\n    /// @dev biome => dungeonLaunchedId\\n    mapping(uint => EnumerableSet.UintSet) freeDungeons;\\n    /// @dev hero + heroId + biome (packMapObject) -> completed\\n    mapping(bytes32 => bool) bossCompleted;\\n    /// @dev hero + heroId + dungNum (packDungeonKey) -> completed\\n    mapping(bytes32 => bool) specificDungeonCompleted;\\n    /// @notice Max biome completed by the hero\\n    /// @dev hero + heroId (nftPacked) -> max biome completed\\n    mapping(bytes32 => uint8) maxBiomeCompleted;\\n    /// @notice which dungeon the hero is currently in\\n    /// @dev hero+id => current DungeonId\\n    mapping(bytes32 => uint64) heroCurrentDungeon;\\n\\n    // ---\\n\\n    /// @notice Specific dungeon for the given pair of hero level + hero class\\n    ///         ALl specific dungeons are listed also in allSpecificDungeons\\n    /// @dev packUint8Array(specReqBiome, specReqHeroClass) => dungNum\\n    mapping(bytes32 => uint16) dungeonSpecific;\\n    /// @dev contains all specific dungNum for easy management\\n    EnumerableSet.UintSet allSpecificDungeons;\\n    /// @dev biome => dungNum\\n    mapping(uint8 => EnumerableSet.UintSet) dungeonsLogicByBiome;\\n\\n    // ---\\n\\n    /// @dev max available biome. auto-increment with new dung deploy\\n    uint8 maxBiome;\\n\\n    /// @notice Address of treasure token => min hero level required\\n    /// @dev manual threshold for treasury\\n    mapping(address => uint) minLevelForTreasury;\\n\\n    /// @notice Contains arrays for SKILL_1, SKILL_2, SKILL_3 with 0 or 1\\n    /// i.e. [0, 1, 0] means that durability of SKILL_2 should be reduced\\n    /// @dev hero + heroId => uint8[] array where idx = slotNum\\n    mapping(bytes32 => bytes32) skillSlotsForDurabilityReduction;\\n\\n    /// @notice Counter of dungeons, it's incremented on launch of a new dungeon\\n    uint64 dungeonCounter;\\n\\n    /// @dev dungNum = init attributes\\n    mapping(uint16 => DungeonAttributes) dungeonAttributes;\\n    /// @dev dungeonId => status\\n    mapping(uint64 => DungeonStatus) dungeonStatuses;\\n  }\\n\\n  struct ObjectGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    /// @dev uint8 types, packed using PackingLib.packUint8Array\\n    bytes32[] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    /// @dev uint64 chances\\n    uint32[][] objChancesByStages;\\n  }\\n\\n  struct DungeonGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    uint8[][] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    uint32[][] objChancesByStages;\\n\\n    uint32[] uniqObjects;\\n\\n    uint8 minLevel;\\n    uint8 maxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n  }\\n\\n  /// @notice Attributes of the given dungeon logic\\n  struct DungeonAttributes {\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    uint8 stages;\\n    uint8 biome;\\n\\n    /// @notice Default list of objects that should be passed in the dungeon\\n    uint32[] uniqObjects;\\n\\n    /// @dev min+max (packUint8Array)\\n    bytes32 minMaxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    /// @notice Packed DungeonGenerateInfo.requiredCustomData: MinValue, MaxValue, IsHero\\n    /// @dev min+max+isHero(packStoryCustomDataRequirements)\\n    bytes32[] requiredCustomDataValue;\\n\\n    ObjectGenerateInfo info;\\n  }\\n\\n  /// @notice Current status of the given dungeon\\n  struct DungeonStatus {\\n    uint64 dungeonId;\\n    /// @notice Dungeon logic id\\n    uint16 dungNum;\\n\\n    /// @notice True if the dungeon is completed by the hero\\n    bool isCompleted;\\n\\n    /// @notice Hero in the dungeon or 0\\n    address heroToken;\\n    uint heroTokenId;\\n    /// @notice Current object that should be passed by the hero. 0 - new object is not opened\\n    uint32 currentObject;\\n    /// @notice Current stage in the dungeon that should be passed by the hero.\\n    uint8 currentStage;\\n\\n    EnumerableMap.AddressToUintMap treasuryTokens;\\n    /// @notice All items that were minted on result of made actions\\n    bytes32[] treasuryItems;\\n\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    /// This value can be bigger than length of uniqObjects\\n    uint8 stages;\\n    /// @notice List of objects to be passed in the stage. The list can be dynamically changed during passing the stages\\n    uint32[] uniqObjects;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n\\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external returns (uint64 dungeonId);\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8);\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64);\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result);\\n\\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external;\\n\\n  /// @notice Hero exists current dungeon forcibly same as when dying but without loosing life chance\\n  function exitForcibly(address heroToken, uint heroTokenId, address msgSender) external;\\n\\n  function maxAvailableBiome() external view returns (uint8);\\n\\n  function reborn(address hero, uint heroId) external;\\n}\\n\",\"keccak256\":\"0xc3442984b7b3ff846bafe6dcddc090ee0393ea9cfff30cdf5550173307364540\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbca9de297214bb9c30daefda5ecaedd0af2c3e8e0440403ad543fb33528c5ef8\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xa365c0e17de806f6262765ef6236512674ac8563a6ee3436e81cec7b1d87468e\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  /**\\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n   */\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n   */\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of tokens in ``owner``'s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\n   *\\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n   * The approval is cleared when the token is transferred.\\n   *\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n   *\\n   * Requirements:\\n   *\\n   * - The caller must own the token or be an approved operator.\\n   * - `tokenId` must exist.\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address to, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Returns the account approved for `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  /**\\n   * @dev Approve or remove `operator` as an operator for the caller.\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n   *\\n   * Requirements:\\n   *\\n   * - The `operator` cannot be the caller.\\n   *\\n   * Emits an {ApprovalForAll} event.\\n   */\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  /**\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n   *\\n   * See {setApprovalForAll}\\n   */\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0xe7d89e4cdfc41317d90bf469428b6ef17cec6eb6fccab0080bdf0378129d2708\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n  /**\\n   * @dev Returns the total amount of tokens stored by the contract.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n   * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n   * Use along with {totalSupply} to enumerate all tokens.\\n   */\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xfb4922e02edfabbe39d004e4c856701b6911d5d64174097f6c5c2ceee9b6faa3\",\"license\":\"MIT\"},\"contracts/interfaces/IFightCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface IFightCalculator {\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    MELEE, // 1\\n    MAGIC, // 2\\n    SLOT_3,\\n    SLOT_4,\\n    SLOT_5,\\n    SLOT_6,\\n    SLOT_7,\\n    SLOT_8,\\n    SLOT_9,\\n    SLOT_10\\n  }\\n\\n  /// @notice Attacker info: suitable both for hero and monsters\\n  struct AttackInfo {\\n    /// @notice Type of the attack\\n    /// by default, if attack token presents, it's magic attack and not-magic otherwise\\n    /// but this logic can become more complicated after introducing new attack types\\n    AttackType attackType;\\n    /// @notice NFT selected by hero for attack, it should be equip on.\\n    /// If attacker is a monster, this is a special case (stub NFT with zero ID is used)\\n    address attackToken;\\n    uint attackTokenId;\\n    address[] skillTokens;\\n    uint[] skillTokenIds;\\n  }\\n\\n  struct FighterInfo {\\n    int32[] fighterAttributes;\\n    IStatController.ChangeableStats fighterStats;\\n    AttackType attackType;\\n    address attackToken;\\n    uint attackTokenId;\\n    uint race;\\n  }\\n\\n  struct Statuses {\\n    bool stun;\\n    bool burn;\\n    bool freeze;\\n    bool confuse;\\n    bool curse;\\n    bool poison;\\n    bool gotCriticalHit;\\n    bool missed;\\n    bool hitBlocked;\\n  }\\n\\n  struct FightResult {\\n    int32 healthA;\\n    int32 healthB;\\n    int32 manaConsumedA;\\n    int32 manaConsumedB;\\n  }\\n\\n  struct FightCall {\\n    FighterInfo fighterA;\\n    FighterInfo fighterB;\\n    uint64 dungeonId;\\n    uint32 objectId;\\n    address heroAdr;\\n    uint heroId;\\n    uint8 stageId;\\n    uint iteration;\\n    uint8 turn;\\n  }\\n\\n  struct SkillSlots {\\n    bool slot1;\\n    bool slot2;\\n    bool slot3;\\n  }\\n\\n  //region ------------------------ FightLib-internal (FightInfoInternal is required by IApplicationEvents..)\\n  struct FightInfoInternal {\\n    Fighter fighterA;\\n    Fighter fighterB;\\n  }\\n\\n  struct Fighter {\\n    IFightCalculator.FighterInfo info;\\n    IItemController.AttackInfo magicAttack;\\n    int32 health;\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 damagePoison;\\n    int32 damageReflect;\\n    IFightCalculator.Statuses statuses;\\n  }\\n  //endregion ------------------------ FightLib-internal\\n\\n  function fight(FightCall memory callData) external returns (FightResult memory);\\n}\\n\",\"keccak256\":\"0xdf9ba809ea21a35a24eed12bf80e53452b0d772623d59211a35498b518eb604b\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGOC.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\n\\ninterface IGOC {\\n\\n  enum ObjectType {\\n    UNKNOWN, // 0\\n    EVENT, // 1\\n    MONSTER, // 2\\n    STORY, // 3\\n    END_SLOT\\n  }\\n\\n  enum ObjectSubType {\\n    UNKNOWN_0, // 0\\n    ENEMY_NPC_1, // 1\\n    ENEMY_NPC_SUPER_RARE_2, // 2\\n    BOSS_3, // 3\\n    SHRINE_4, // 4\\n    CHEST_5, // 5\\n    STORY_6, // 6\\n    STORY_UNIQUE_7, // 7\\n    SHRINE_UNIQUE_8, // 8\\n    CHEST_UNIQUE_9, // 9\\n    ENEMY_NPC_UNIQUE_10, // 10\\n    STORY_ON_ROAD_11, // 11\\n    STORY_UNDERGROUND_12, // 12\\n    STORY_NIGHT_CAMP_13, // 13\\n    STORY_MOUNTAIN_14, // 14\\n    STORY_WATER_15, // 15\\n    STORY_CASTLE_16, // 16\\n    STORY_HELL_17, // 17\\n    STORY_SPACE_18, // 18\\n    STORY_WOOD_19, // 19\\n    STORY_CATACOMBS_20, // 20\\n    STORY_BAD_HOUSE_21, // 21\\n    STORY_GOOD_TOWN_22, // 22\\n    STORY_BAD_TOWN_23, // 23\\n    STORY_BANDIT_CAMP_24, // 24\\n    STORY_BEAST_LAIR_25, // 25\\n    STORY_PRISON_26, // 26\\n    STORY_SWAMP_27, // 27\\n    STORY_INSIDE_28, // 28\\n    STORY_OUTSIDE_29, // 29\\n    STORY_INSIDE_RARE_30,\\n    STORY_OUTSIDE_RARE_31,\\n    ENEMY_NPC_INSIDE_32,\\n    ENEMY_NPC_INSIDE_RARE_33,\\n    ENEMY_NPC_OUTSIDE_34,\\n    ENEMY_NPC_OUTSIDE_RARE_35,\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:game.object.controller.main\\n  struct MainState {\\n\\n    /// @dev objId = biome(00) type(00) id(0000) => biome(uint8) + objType(uint8)\\n    /// Id is id of the event, story or monster.\\n    mapping(uint32 => bytes32) objectMeta;\\n\\n    /// @dev biome(uint8) + objType(uint8) => set of object id\\n    mapping(bytes32 => EnumerableSet.UintSet) objectIds;\\n\\n    /// @dev heroAdr180 + heroId64 + cType8 + biome8 => set of already played objects. Should be cleared periodically\\n    mapping(bytes32 => EnumerableSet.UintSet) playedObjects;\\n\\n    /// @dev HeroAdr(160) + heroId(uint64) + objId(uint32) => iteration count. It needs for properly emit events for every new entrance.\\n    mapping(bytes32 => uint) iterations;\\n\\n    /// @dev objId(uint32) => EventInfo\\n    mapping(uint32 => EventInfo) eventInfos;\\n\\n    /// @dev objId(uint32) => storyId\\n    mapping(uint32 => uint16) storyIds;\\n\\n    /// @dev objId(uint32) => MonsterInfo\\n    mapping(uint32 => MonsterInfo) monsterInfos;\\n\\n    /// @dev hero+id => last fight action timestamp\\n    mapping(bytes32 => uint) lastHeroFightTs;\\n\\n    /// @dev delay for user actions in fight (suppose to prevent bot actions)\\n    uint fightDelay;\\n  }\\n\\n  struct ActionResult {\\n    bool kill;\\n    bool completed;\\n    address heroToken;\\n    address[] mintItems;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n    uint32 objectId;\\n    uint32 experience;\\n    uint heroTokenId;\\n    uint iteration;\\n    uint32[] rewriteNextObject;\\n  }\\n\\n  struct EventInfo {\\n    /// @dev chance to use good or bad attributes/stats\\n    uint32 goodChance;\\n\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] goodAttributes;\\n    bytes32[] badAttributes;\\n\\n    /// @dev experience(uint32) + heal(int32) + manaRegen(int32) + lifeChancesRecovered(int32) + damage(int32) + manaConsume(int32) packStatsChange\\n    bytes32 statsChange;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n  }\\n\\n  struct MonsterInfo {\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] attributes;\\n    /// @dev level(uint8) + race(uint8) + experience(uint32) + maxDropItems(uint8) packMonsterStats\\n    bytes32 stats;\\n    /// @dev attackToken(160) + attackTokenId(uint64) + attackType(uint8) packAttackInfo\\n    bytes32 attackInfo;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n\\n    /// @dev heroAdr(160) + heroId(uint64) => iteration => GeneratedMonster packed\\n    mapping(bytes32 => mapping(uint => bytes32)) _generatedMonsters;\\n  }\\n\\n  struct MultiplierInfo {\\n    uint8 biome;\\n    /// @notice NG_LEVEL of the hero who is going to fight with the given monster\\n    /// Use type(uint8).max for !NG+\\n    uint8 heroNgLevel;\\n  }\\n\\n  struct GeneratedMonster {\\n    bool generated;\\n    uint8 turnCounter;\\n    int32 hp;\\n    uint32 amplifier;\\n  }\\n\\n  struct MonsterGenInfo {\\n    uint16 monsterId;\\n    uint8 biome;\\n    ObjectSubType subType;\\n\\n    uint8[] attributeIds;\\n    int32[] attributeValues;\\n\\n    uint8 level;\\n    uint8 race;\\n    uint32 experience;\\n    uint8 maxDropItems;\\n\\n    address attackToken;\\n    uint64 attackTokenId;\\n    uint8 attackType;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct ActionContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    uint8 biome;\\n    uint8 objectSubType;\\n    uint8 stageId;\\n    uint8 heroNgLevel;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint heroTokenId;\\n    uint salt;\\n    uint iteration;\\n    bytes data;\\n  }\\n\\n  struct EventRegInfo {\\n    uint8 biome;\\n    uint16 eventId;\\n    ObjectSubType subType;\\n\\n    uint32 goodChance;\\n\\n    AttributeGenerateInfo goodAttributes;\\n    AttributeGenerateInfo badAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct AttributeGenerateInfo {\\n    uint8[] ids;\\n    int32[] values;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev represent object registration if non zero values\\n  function getObjectMeta(uint32 objectId) external view returns (uint8 biome, uint8 objectSubType);\\n\\n  function isBattleObject(uint32 objectId) external view returns (bool);\\n\\n  function getRandomObject(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biomeLevel,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external returns (uint32 objectId);\\n\\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint iteration);\\n\\n  function action(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) external returns (ActionResult memory);\\n\\n}\\n\",\"keccak256\":\"0x9f12869021850ca2a16a083d0f1808f112061ca2d0278e82fe77f2839330b0d3\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGameToken.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IGameToken is IERC20 {\\n\\n  function minter() external view returns (address);\\n\\n  function mint(address account, uint amount) external returns (bool);\\n\\n  function burn(uint amount) external returns (bool);\\n\\n  function setMinter(address minter_) external;\\n\\n  function pause(bool value) external;\\n\\n}\\n\",\"keccak256\":\"0x55fbc7d57c7c72905132decd85a2008a901e550d0b71cf7ac5db6b36a1c598d6\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGuildBank.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\n\\ninterface IGuildBank {\\n  function transfer(address token, address recipient, uint amount) external;\\n\\n  function approve(address token, address spender, uint256 amount) external returns (bool);\\n\\n  function transferNft(address to, address nft, uint256 tokenId) external;\\n\\n  function transferNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external;\\n\\n  function approveNft(address to, address nft, uint256 tokenId) external;\\n\\n  function approveNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external;\\n}\",\"keccak256\":\"0x89143aa04e65d7668b2668a36825c7b1d5203a34dbe6a6ececaa71b5d67a2895\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGuildController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IGuildController {\\n  enum GuildRightBits {\\n    ADMIN_0,\\n    RENAME_1,\\n    CHANGE_LOGO_2,\\n    CHANGE_SHELTER_3,\\n    ADD_MEMBER_4,\\n    REMOVE_MEMBER_5,\\n    BANK_TOKENS_OPERATION_6,\\n    CHANGE_ROLES_7,\\n    LEVEL_UP_8,\\n    SET_RELATION_KIND_9,\\n    BANK_ITEMS_OPERATION_10,\\n    SET_GUILD_PARAMS_11,\\n    CHANGE_PURCHASING_SHELTER_ITEMS_CAPACITY_12\\n  }\\n\\n  enum GuildsParams {\\n    NONE_0,\\n    COUNTER_GUILD_IDS_1,\\n    BASE_FEE_2,\\n    COUNTER_GUILD_REQUESTS_3,\\n    REENTRANT_STATUS_4,\\n    SHELTER_CONTROLLER_5,\\n    SHELTER_AUCTION_6\\n  }\\n\\n  enum GuildRequestStatus {\\n    NONE_0,\\n    ACCEPTED_1,\\n    REJECTED_2,\\n    CANCELED_3\\n  }\\n\\n  /// @custom:storage-location erc7201:guild.controller.main\\n  struct MainState {\\n    /// @notice Mapping to store various guilds params (with global values for all guilds)\\n    mapping(GuildsParams param => uint value) guildsParam;\\n\\n    /// @notice guildId => address of instance of GuildBank contract\\n    mapping(uint guildId => address) guildBanks;\\n\\n    /// @notice guild id => guild data (owner, name, logo, etc)\\n    mapping(uint guildId => GuildData) guildData;\\n\\n    /// @notice name => guild id\\n    mapping(string guildName => uint guildId) nameToGuild;\\n\\n    /// @notice EOA => guild id, EOA can be a member of a single guild only\\n    mapping(address member => uint guildId) memberToGuild;\\n\\n    /// @notice List of participants of guilds\\n    /// @dev Allowed number of members is 20 + 5 * guildLevel\\n    mapping(uint guildId => EnumerableSet.AddressSet listEoa) members;\\n\\n    /// @notice Rights of the member in the guild, mask of GuildRightBits\\n    mapping(address member => uint maskRights) rights;\\n\\n    /// @notice _getGuildsPairKey(guild1, guild2) => status (false - war, true - peace)\\n    mapping(bytes32 guildsPairKey => bool) relationsPeaceful;\\n\\n    // ---------------------------- Request to join to the guild\\n    /// @notice Full list of requests registered for the guild\\n    mapping(uint guildId => mapping(GuildRequestStatus status => EnumerableSet.UintSet guildRequestIds)) guildRequests;\\n\\n    /// @notice List of active requests created by the given user.\\n    /// \\\"Active\\\" => deposit should be returned to the user.\\n    /// All not-active requests are removed from here automatically.\\n    mapping(address user => EnumerableSet.UintSet guildRequestIds) userActiveGuildRequests;\\n\\n    /// @notice Data of all guild requests ever created\\n    mapping(uint guildRequestId => GuildRequestData) guildRequestData;\\n\\n    /// @notice Deposit amount required to create a guild request\\n    mapping(uint guildId => GuildRequestDeposit) guildRequestDepositAmounts;\\n\\n    /// @notice Counter of spent pvp points + number of guild pvp-points allowed to be used by the guild member\\n    mapping(uint guildId => mapping(address member => UserPvpPoints)) userPvpPoints;\\n\\n    /// @notice guild id => guildDescription\\n    mapping(uint guildId => string) guildDescription;\\n  }\\n\\n  struct GuildData {\\n    /// @notice Not empty unique guild name\\n    string guildName;\\n\\n    /// @notice URL of guild logo (empty is allowed)\\n    string urlLogo;\\n\\n    /// @notice Creator (owner) of the guild\\n    address owner;\\n\\n    /// @notice Guild level [1...10]\\n    uint8 guildLevel;\\n\\n    /// @notice Percent of guild reinforcement fee Value in range [_FEE_MIN ... _TO_HELPER_RATIO_MAX], i.e. [10..50]\\n    uint8 toHelperRatio;\\n\\n    /// @notice Global guild points counter, it's incremented on each victory in php-fight.\\n    /// @dev Assume here, that uint64 is enough to store any sums of scores\\n    uint64 pvpCounter;\\n  }\\n\\n  struct GuildRequestData {\\n    GuildRequestStatus status;\\n    /// @notice Creator of the guild request that asks to include him to the guild\\n    address user;\\n    /// @notice Message to the guild owner from the user\\n    string userMessage;\\n    uint guildId;\\n  }\\n\\n  struct GuildRequestDeposit {\\n    bool initialized;\\n    uint192 amount;\\n  }\\n\\n  struct UserPvpPoints {\\n    /// @notice How many guild pvp-points the user is allowed to use\\n    uint64 capacityPvpPoints;\\n\\n    /// @notice How many guild pvp-points the user has used\\n    uint64 spentPvpPoints;\\n  }\\n\\n  /// ----------------------------------------------------------------------------------------------\\n\\n  function memberOf(address user) external view returns (uint guildId);\\n  function guildToShelter(uint guildId) external view returns (uint shelterId);\\n\\n  function getGuildData(uint guildId) external view returns (\\n    string memory guildName,\\n    string memory urlLogo,\\n    address owner,\\n    uint8 guildLevel,\\n    uint64 pvpCounter,\\n    uint toHelperRatio\\n  );\\n\\n  function getRights(address user) external view returns (uint);\\n  function getGuildBank(uint guildId) external view returns (address);\\n  function shelterController() external view returns (address);\\n\\n  function usePvpPoints(uint guildId, address user, uint64 priceInPvpPoints) external;\\n  function payFromGuildBank(uint guildId, uint shelterPrice) external;\\n  function payFromBalance(uint amount, address user) external;\\n\\n  /// @notice Ensure that the {user} has given {right}, revert otherwise\\n  function checkPermissions(address user, uint right) external view returns (uint guildId, uint rights);\\n  function shelterAuctionController() external view returns (address);\\n  function payForAuctionBid(uint guildId, uint amount, uint bid) external;\\n}\\n\",\"keccak256\":\"0x660a6d032109a08b8ff5bc139d93ff0f634fafbdeedfe78f9932c226de1a2f53\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IHeroController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IHeroController {\\n\\n  /// @custom:storage-location erc7201:hero.controller.main\\n  struct MainState {\\n\\n    /// @dev A central place for all hero tokens\\n    /// @dev Deprecated. Controller is used instead.\\n    address heroTokensVault;\\n\\n    /// @dev heroAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) payToken;\\n\\n    /// @dev heroAdr => heroCls8\\n    mapping(address => uint8) heroClass;\\n\\n    // ---\\n\\n    /// @dev hero+id => individual hero name\\n    mapping(bytes32 => string) heroName;\\n\\n    /// @dev name => hero+id, needs for checking uniq names\\n    mapping(string => bytes32) nameToHero;\\n\\n    // ---\\n\\n    /// @dev hero+id => biome\\n    mapping(bytes32 => uint8) heroBiome;\\n\\n    /// @notice Exist reinforcement of any kind for the given hero\\n    /// @dev hero+id => packed reinforcement helper+id\\n    mapping(bytes32 => bytes32) reinforcementHero;\\n\\n    /// @dev hero+id => reinforcement packed attributes\\n    mapping(bytes32 => bytes32[]) reinforcementHeroAttributes;\\n\\n    /// @notice packedHero (hero + id) => count of calls of beforeTokenTransfer\\n    mapping(bytes32 => uint) countHeroTransfers;\\n\\n\\n    // ------------------------------------ NG plus\\n\\n    /// @notice (tier, hero address) => TierInfo, where tier = [2, 3]\\n    /// @dev For tier=1 no data is required. Amount for tier 1 is stored in {payToken}, no items are minted\\n    /// Token from {payToken} is equal for all tiers\\n    mapping(bytes32 packedTierHero => TierInfo) tiers;\\n\\n    mapping(bytes32 packedHero => HeroInfo) heroInfo;\\n\\n    /// @notice Max NG_LVL reached by the heroes of a given account\\n    mapping(address user => uint8 maxNgLevel) maxUserNgLevel;\\n\\n    /// @notice When the hero has killed boss on the given biome first time\\n    /// packedBiomeNgLevel = packed (biome, NG_LEVEL)\\n    mapping(bytes32 packedHero => mapping (bytes32 packedBiomeNgLevel => uint timestamp)) killedBosses;\\n\\n    /// @notice Max NG_LEVEL reached by any user\\n    uint maxOpenedNgLevel;\\n  }\\n\\n  /// @notice Tier = hero creation cost option\\n  /// There are 3 tiers:\\n  /// 1: most chip option, just pay fixed amount {payTokens} - new hero is created\\n  /// 2: pay bigger amount - random skill is equipped on the newly created hero\\n  /// 3: pay even more amount - random sill + some random items are equipped on the newly created hero\\n  struct TierInfo {\\n    /// @notice Cost of the hero creation using the given tier in terms of the token stored in {payToken}\\n    /// This amount is used for tiers 2, 3. For tier 1 the amount is taken from {payToken}\\n    uint amount;\\n\\n    /// @notice All slots for which items-to-mint are registered in {itemsToMint}\\n    EnumerableSet.UintSet slots;\\n\\n    /// @notice slot => items that can be minted and equipped on the hero to the given {slot} after hero creation\\n    mapping(uint8 slot => address[] items) itemsToMint;\\n  }\\n\\n  /// @notice Current NG+-related values\\n  struct HeroInfo {\\n    /// @notice Hero tier = [0..3]. 0 - the hero is post-paid, it can be changed by upgrading the hero to pre-paid\\n    uint8 tier;\\n\\n    /// @notice NG_LVL of the hero\\n    uint8 ngLevel;\\n\\n    /// @notice True if hero has passed last biome on current NG+ and so NG_LEVEL can be incremented (reborn is allowed)\\n    bool rebornAllowed;\\n\\n    /// @notice Amount paid for the hero on creation OR on upgrade to NG+\\n    /// Amount paid for creation of the hero in terms of game token (!NG+) is NOT stored here.\\n    /// @dev uint72 is used here to pack the whole struct to single slot\\n    uint72 paidAmount;\\n\\n    /// @notice Pay token used to pay {paidAmount}\\n    address paidToken;\\n  }\\n\\n  /// @notice Input data to create new hero\\n  struct HeroCreationData {\\n    /// @notice Desired NG_LVL of the hero\\n    uint8 ngLevel;\\n\\n    /// @notice Desired tire of the newly created hero. Allowed values: [1..3]\\n    uint8 tier;\\n\\n    /// @notice Enter to the dungeon after creation\\n    bool enter;\\n\\n    /// @notice Desired hero name\\n    string heroName;\\n\\n    /// @notice Optional: user account for which the hero is created\\n    address targetUserAccount;\\n\\n    /// @notice Optional: ref-code to be passed to the hero-creation-related event\\n    string refCode;\\n  }\\n\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function heroClass(address hero) external view returns (uint8);\\n\\n  function heroBiome(address hero, uint heroId) external view returns (uint8);\\n\\n  function payTokenInfo(address hero) external view returns (address token, uint amount);\\n\\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (address helperHeroToken, uint helperHeroId);\\n\\n  function score(address hero, uint heroId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool);\\n\\n  function beforeTokenTransfer(address hero, uint heroId) external returns (bool);\\n\\n  // ---\\n\\n  function create(address hero, string memory heroName_, bool enter) external returns (uint);\\n\\n  function kill(address hero, uint heroId) external returns (bytes32[] memory dropItems);\\n\\n  /// @notice Take off all items from the hero, reduce life to 1. The hero is NOT burnt.\\n  /// Optionally reduce mana to zero and/or decrease life chance.\\n  function softKill(address hero, uint heroId, bool decLifeChances, bool resetMana) external returns (bytes32[] memory dropItems);\\n\\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId);\\n\\n  function resetLifeAndMana(address hero, uint heroId) external;\\n\\n  function countHeroTransfers(address hero, uint heroId) external view returns (uint);\\n\\n  function askGuildReinforcement(address hero, uint heroId, address helper, uint helperId) external;\\n\\n  function getHeroInfo(address hero, uint heroId) external view returns (IHeroController.HeroInfo memory data);\\n\\n  function registerKilledBoss(address hero, uint heroId, uint32 objectId) external;\\n\\n  function maxOpenedNgLevel() external view returns (uint);\\n}\\n\",\"keccak256\":\"0xcab64849520acbfbdd1ecff59728d70d07b2b64ac3620b25ff7e9c92e25acb08\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItem.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IItem {\\n\\n  function isItem() external pure returns (bool);\\n\\n  function mintFor(address recipient) external returns (uint tokenId);\\n\\n  function burn(uint tokenId) external;\\n\\n  function controlledTransfer(address from, address to, uint tokenId) external;\\n}\\n\",\"keccak256\":\"0x766165af1a0ef65f8969414e165fdbc38294b5f249d280a3be272cbaa90721a7\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IItemController {\\n\\n  enum GlobalParam {\\n    UNKNOWN_0,\\n\\n    /// @notice Address of ItemControllerHelper\\n    ITEM_CONTROLLER_HELPER_ADDRESS_1\\n  }\\n\\n  /// @custom:storage-location erc7201:item.controller.main\\n  struct MainState {\\n\\n    ////////////////// GENERATE //////////////////\\n\\n    EnumerableSet.AddressSet items;\\n\\n    /// @dev itemAdr => itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n    mapping(address => bytes32) itemMeta;\\n\\n    /// @dev itemAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) augmentInfo;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoAttributes;\\n\\n    // --- consumable ---\\n\\n    /// @dev itemAdr => ids+values (toBytes32ArrayWithIds)\\n    mapping(address => bytes32[]) _itemConsumableAttributes;\\n\\n    /// @dev itemAdr => IStatController.ChangeableStats packed int32[]\\n    mapping(address => bytes32) itemConsumableStats;\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoCasterAttributes;\\n\\n    /// @dev itemAdr => id8 + minDmg(int32) + maxDmg(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(address => bytes32) generateInfoAttack;\\n\\n    ////////////////// ITEMS INFO //////////////////\\n\\n    /// @dev itemAdr+id => itemRarity8 + augmentationLevel8 + itemDurability16\\n    mapping(bytes32 => bytes32) itemInfo;\\n\\n    /// @dev itemAdr+id => heroAdr+id\\n    mapping(bytes32 => bytes32) equippedOn;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemAttributes;\\n\\n    // --- consumable ---\\n\\n    // consumable stats unchangeable, get them by address\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemCasterAttributes;\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr+Id => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(bytes32 => bytes32) _itemAttackInfo;\\n\\n    ////////////////// Additional generate info //////////////////\\n\\n    /// @notice (itemAdr) => Bitmask of ConsumableActionBits\\n    mapping(address => uint) _consumableActionMask;\\n\\n\\n    /// --------------------------------- SIP-003: Item fragility\\n    /// @notice itemAdr + id => item fragility counter that displays the chance of an unsuccessful repair\\n    /// @dev [0...100_000], decimals 3\\n    mapping(bytes32 packedItem => uint fragility) itemFragility;\\n\\n    /// @notice Universal mapping to store various addresses and numbers (params of the contract)\\n    mapping (GlobalParam param => uint value) globalParam;\\n\\n    /// @notice Item address => packedMetadata\\n    /// {packedMetaData} is encoded using abi.encode/abi.decode\\n    /// Read first byte, detect meta data type by the byte value, apply proper decoder from PackingLib\\n    mapping(address item => bytes packedMetaData) packedItemMetaData;\\n  }\\n\\n  struct RegisterItemParams {\\n    ItemMeta itemMeta;\\n    address augmentToken;\\n    uint augmentAmount;\\n    ItemGenerateInfo commonAttributes;\\n\\n    IGOC.AttributeGenerateInfo consumableAttributes;\\n    IStatController.ChangeableStats consumableStats;\\n\\n    ItemGenerateInfo casterAttributes;\\n    ItemGenerateInfo targetAttributes;\\n\\n    AttackInfo genAttackInfo;\\n    /// @notice Bit mask of ConsumableActionBits\\n    uint consumableActionMask;\\n  }\\n\\n  /// @notice Possible actions that can be triggered by using the consumable item\\n  enum ConsumableActionBits {\\n    CLEAR_TEMPORARY_ATTRIBUTES_0,\\n    EXIT_FROM_DUNGEON_1,\\n    RESERVED_2,\\n    REST_IN_SHELTER_3\\n  }\\n\\n  struct ItemGenerateInfo {\\n    /// @notice Attribute ids\\n    uint8[] ids;\\n    /// @notice Min value of the attribute, != 0\\n    int32[] mins;\\n    /// @notice Max value of the attribute, != 0\\n    int32[] maxs;\\n    /// @notice Chance of the selection [0..MAX_CHANCES]\\n    uint32[] chances;\\n  }\\n\\n  struct ItemMeta {\\n    uint8 itemMetaType;\\n    // Level in range 1-99. Reducing durability in low level dungeons. lvl/5+1 = biome\\n    uint8 itemLevel;\\n    IItemController.ItemType itemType;\\n    uint16 baseDurability;\\n    uint8 defaultRarity;\\n    uint32 manaCost;\\n\\n    // it doesn't include positions with 100% chance\\n    uint8 minRandomAttributes;\\n    uint8 maxRandomAttributes;\\n\\n    IStatController.CoreAttributes requirements;\\n  }\\n\\n  // Deprecated. Todo - remove\\n  enum FeeType {\\n    UNKNOWN,\\n    REPAIR,\\n    AUGMENT,\\n    STORY,\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemRarity {\\n    UNKNOWN, // 0\\n    NORMAL, // 1\\n    MAGIC, // 2\\n    RARE, // 3\\n    SET, // 4\\n    UNIQUE, // 5\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemType {\\n    NO_SLOT, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    RING, // 6\\n    OFF_HAND, // 7\\n    BOOTS, // 8\\n    ONE_HAND, // 9\\n    TWO_HAND, // 10\\n    SKILL, // 11\\n    OTHER, // 12\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemMetaType {\\n    UNKNOWN, // 0\\n    COMMON, // 1\\n    ATTACK, // 2\\n    BUFF, // 3\\n    CONSUMABLE, // 4\\n\\n    END_SLOT\\n  }\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    FIRE, // 1\\n    COLD, // 2\\n    LIGHTNING, // 3\\n    CHAOS, // 4\\n\\n    END_SLOT\\n  }\\n\\n  struct AttackInfo {\\n    AttackType aType;\\n    int32 min;\\n    int32 max;\\n    // if not zero - activate attribute factor for the attribute\\n    IStatController.CoreAttributes attributeFactors;\\n  }\\n\\n  struct ItemInfo {\\n    ItemRarity rarity;\\n    uint8 augmentationLevel;\\n    uint16 durability;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct MintInfo {\\n    IItemController.ItemMeta meta;\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.ItemRarity itemRarity;\\n\\n    IItemController.AttackInfo attackInfo;\\n\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct AugmentInfo {\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.AttackInfo attackInfo;\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  ///region ------------------------ Item type \\\"Other\\\"\\n  /// @notice Possible kinds of \\\"Other\\\" items\\n  /// Each \\\"Other\\\" item has each own structure for metadata, see OtherItemXXX\\n  enum OtherSubtypeKind {\\n    UNKNOWN_0,\\n    /// @notice Item to reduce fragility, see SCB-1014. Metadata is {OtherItemReduceFragility}\\n    REDUCE_FRAGILITY_1,\\n\\n    /// @notice This item allows asking guild reinforcement to the guild member\\n    USE_GUILD_REINFORCEMENT_2,\\n\\n    END_SLOT\\n  }\\n  struct OtherItemReduceFragility {\\n    /// @notice \\\"Other\\\" item kind. It MUST BE first field in the struct.\\n    uint8 kind;\\n\\n    /// @notice Value on which the fragility will be reduced.\\n    /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n    uint248 value;\\n  }\\n  ///endregion ------------------------ Item type \\\"Other\\\"\\n\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function itemMeta(address item) external view returns (ItemMeta memory meta);\\n\\n  function augmentInfo(address item) external view returns (address token, uint amount);\\n\\n  function genAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genCasterAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genTargetAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genAttackInfo(address item) external view returns (AttackInfo memory info);\\n\\n  function itemInfo(address item, uint itemId) external view returns (ItemInfo memory info);\\n\\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId);\\n\\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats);\\n\\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function itemAttackInfo(address item, uint itemId) external view returns (AttackInfo memory info);\\n\\n  function score(address item, uint tokenId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address item, uint tokenId) external view returns (bool);\\n\\n  // ---\\n\\n  function mint(address item, address recipient) external returns (uint itemId);\\n\\n  function reduceDurability(address hero, uint heroId, uint8 biome, bool reduceDurabilityAllSkills) external;\\n\\n  function destroy(address item, uint tokenId) external;\\n\\n  function takeOffDirectly(\\n    address item,\\n    uint itemId,\\n    address hero,\\n    uint heroId,\\n    uint8 itemSlot,\\n    address destination,\\n    bool broken\\n  ) external;\\n\\n  /// @notice SIP-003: item fragility counter that displays the chance of an unsuccessful repair.\\n  /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n  function itemFragility(address item, uint itemId) external view returns (uint);\\n\\n  /// @notice SIP-003: The quest mechanic that previously burned the item will increase its fragility by 1%\\n  function incBrokenItemFragility(address item, uint itemId) external;\\n\\n  function equip(\\n    address hero,\\n    uint heroId,\\n    address[] calldata items,\\n    uint[] calldata itemIds,\\n    uint8[] calldata itemSlots\\n  ) external;\\n}\\n\",\"keccak256\":\"0x6db2366d167d1a1077974b053d7b3fae242e44a28554e7497b730f175022ed28\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IOracle {\\n\\n  function getRandomNumber(uint max, uint seed) external returns (uint);\\n\\n  function getRandomNumberInRange(uint min, uint max, uint seed) external returns (uint);\\n\\n}\\n\",\"keccak256\":\"0x75a2bed27cbd9be6c76b6f3e941ee5f6f55380f61cd867254a0c766fc3b71976\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IReinforcementController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\n/// @notice Terms\\n/// Reinforcement v1: helper is selected randomly in askHero, fixed part of rewards (tokens and NFT) is sent to the helper.\\n/// Guild reinforcement: helper is selected from guild heroes. Rewards are sent to guild bank.\\n/// Reinforcement v2: helper is selected manually in askHeroV2, helper receives fixed amount.\\ninterface IReinforcementController {\\n\\n  enum ConfigParams {\\n    /// @notice Packed MinMaxBoardV2\\n    V2_MIN_MAX_BOARD_0\\n  }\\n\\n  /// @custom:storage-location erc7201:reinforcement.controller.main\\n  struct MainState {\\n\\n    // ------------------------ Reinforcement v1\\n\\n    /// @dev minLvl8 + minLifeChances8\\n    bytes32 config;\\n    /// @dev hero token + hero id => heroInfo(biome8 + score128 + fee8 + stakeTs64)\\n    mapping(bytes32 => bytes32) _stakedHeroes;\\n    /// @dev biome => helperAdr+id\\n    mapping(uint => EnumerableSet.Bytes32Set) _internalIdsByBiomes;\\n    /// @dev biome => score  // The field is deprecated and not updated any more\\n    mapping(uint => uint) maxScore;\\n    /// @dev heroAdr+id => itemAdr+id\\n    mapping(bytes32 => bytes32[]) _heroNftRewards;\\n    /// @dev heroAdr+id => tokenAdr and amount map\\n    mapping(bytes32 => EnumerableMap.AddressToUintMap) _heroTokenRewards;\\n\\n\\n    // ------------------------ Guild reinforcement\\n\\n    /// @notice All staked guild heroes for the given guild\\n    /// @dev helper (hero token + hero id) => guild\\n    mapping(bytes32 packedHero => uint guildId) stakedGuildHeroes;\\n\\n    /// @notice All guild heroes that are currently in use by guild reinforcement\\n    /// It's allowed to withdraw a hero before reinforcement releasing,\\n    /// so it's possible to have !0 in {guildBusyHelpers} and 0 in {stakedGuildHeroes} simultaneously.\\n    /// @dev helper (hero token + hero id) => guildId (guild at the moment of askGuildReinforcement)\\n    mapping(bytes32 packedHero => uint guildId) busyGuildHelpers;\\n\\n    /// @notice All (free and busy) staked guild heroes per guild.\\n    /// guild => (packed helper => guild where the helper is busy currently)\\n    /// @dev There is a chance that guilds are different here\\n    /// i.e. hero can be:\\n    /// 1) added to G1 2) staked in G1 3) asked for help 4) withdrawn 5) G1=>G2 6) staked in G2\\n    /// In such case guildHelpers[G2][hero] = G1, guildHelpers[G1][hero] = 0\\n    /// After releasing guildHelpers[G2][hero] = 0\\n    mapping(uint guildId => EnumerableMap.Bytes32ToUintMap) guildHelpers;\\n\\n    /// @notice Moment of withdrawing the hero from staking. Next staking is possible in 1 day since withdrawing\\n    mapping(bytes32 packedHero => uint lastWithdrawTimestamp) lastGuildHeroWithdrawTs;\\n\\n\\n    // ------------------------ Reinforcement v2\\n    /// @notice Map to store various config params\\n    mapping(ConfigParams paramId => uint) configParams;\\n\\n    mapping(bytes32 packedHero => HeroInfoV2) stakedHeroesV2;\\n\\n    /// @notice biome => set of packedHero. All staked heroes (they can be busy of free currently)\\n    mapping(uint biome => EnumerableSet.Bytes32Set) heroesByBiomeV2;\\n\\n    mapping(uint biome => LastWindowsV2) stat24hV2;\\n  }\\n\\n\\n  /// @notice Deprecated. Reinforcement v1\\n  struct HeroInfo {\\n    uint8 biome;\\n    uint score; // stored in 128 but easy to use 256\\n    /// @notice To helper ratio\\n    uint8 fee;\\n    uint64 stakeTs;\\n  }\\n\\n  struct HeroInfoV2 {\\n    uint8 biome;\\n    uint64 stakeTs;\\n    /// @notice Amount of game token that is paid to the helper at the moment of the call {askHeroV2}\\n    uint128 rewardAmount;\\n  }\\n\\n  /// @notice Statistic of askHeroV2 calls per last 24 hours at the moment of the last call\\n  struct LastWindowsV2 {\\n    /// @notice 24 hours are divided on 8 intervals, each interval is 3 hour\\n    /// Current basket has index {basketIndex}\\n    /// {baskets[current basket]} contains \\\"old\\\" value.\\n    /// New value for the current basket is collected in {basketValue}.\\n    /// The value for the current basket is calculated as weighted average of old and new values.\\n    /// New value replaces the old value at the moment of changing current basket index.\\n    uint24[8] baskets;\\n    /// @notice New value (hits counter) for current basket\\n    uint24 basketValue;\\n    /// @notice Abs. index of the current basket (abs. hour / 3)\\n    uint48 basketIndex;\\n  }\\n\\n  /// @dev 1 slot\\n  struct ConfigReinforcementV2 {\\n    /// @notice if Number-of-askHeroV2-calls is below given value then burn fee has min value\\n    uint32 minNumberHits;\\n    /// @notice if Number-of-askHeroV2-calls is above given value then burn fee has max value\\n    uint32 maxNumberHits;\\n    /// @notice Lowest fee = amountForDungeon / given value, i.e. 100 => amountForDungeon/100 as lower fee\\n    uint32 lowDivider;\\n    /// @notice Highest fee = amountForDungeon / given value, i.e. 2 => amountForDungeon/2 as highest fee\\n    uint32 highDivider;\\n    /// @notice Limit for min level of the staked hero\\n    /// In practice we need following limitation: (stats.level < 5 || (stats.level - 5) / 5 < biome)\\n    /// so, levelLimit should be equal 5\\n    /// In tests we need to be able to disable such limitation, so levelLimit = 0 allow to disable that constraint\\n    uint8 levelLimit;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function toHelperRatio(address heroToken, uint heroId) external view returns (uint);\\n\\n  function isStaked(address heroToken, uint heroId) external view returns (bool);\\n\\n  function registerTokenReward(address heroToken, uint heroId, address token, uint amount) external;\\n\\n  function registerNftReward(address heroToken, uint heroId, address token, uint tokenId) external;\\n\\n  function askHeroV2(address hero, uint heroId, address helper, uint helperId) external returns (int32[] memory attributes);\\n\\n  function askGuildHero(address hero, uint heroId, address helper, uint helperId) external returns (int32[] memory attributes);\\n\\n  /// @notice Return the guild in which the hero is currently asked for guild reinforcement\\n  function busyGuildHelperOf(address heroToken, uint heroId) external view returns (uint guildId);\\n\\n  function releaseGuildHero(address helperHeroToken, uint helperHeroTokenId) external;\\n}\",\"keccak256\":\"0x9db4175e2a6415c55ef773a1abd960feba58b2973afce83691762fb679d7fd13\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IRewardsPool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IRewardsPool {\\n\\n  /// @custom:storage-location erc7201:rewards.pool.main\\n  struct MainState {\\n    mapping(address token => uint baseAmountValue) baseAmounts;\\n  }\\n\\n  function balanceOfToken(address token) external view returns (uint);\\n\\n  function rewardAmount(address token, uint maxBiome, uint maxNgLevel, uint biome, uint heroNgLevel) external view returns (uint);\\n\\n  function sendReward(address token, uint rewardAmount_, address receiver) external;\\n\\n  function lostProfitPercent(uint maxBiome, uint maxNgLevel, uint heroNgLevel) external view returns (uint percent);\\n}\\n\",\"keccak256\":\"0x1059791209fc6106767c7c2d894b38a08ef2d806eff084b07f663d25fdf18609\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IShelterAuction.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IShelterAuction {\\n  enum ShelterAuctionParams {\\n    NONE_0,\\n    POSITION_COUNTER_1,\\n    BID_COUNTER_2,\\n    FEE_3\\n  }\\n\\n  //region ------------------------ Data types\\n  /// @custom:storage-location erc7201:shelter.auction.main\\n  struct MainState {\\n\\n    /// @notice Mapping to store auction params (i.e. counters)\\n    mapping(ShelterAuctionParams param => uint value) params;\\n\\n    /// @notice Hold all positions. Any record should not be removed\\n    mapping(uint positionId => Position) positions;\\n\\n    /// @dev BidId => Bid. Hold all bids. Any record should not be removed\\n    mapping(uint bidId => AuctionBid) auctionBids;\\n\\n    /// @notice List of currently opened positions\\n    EnumerableSet.UintSet openPositions;\\n\\n    /// @notice Seller to position map\\n    /// At any moment each guild can have only one opened position to sell\\n    mapping(uint sellerGuildId => uint openedPositionId) sellerPosition;\\n\\n    /// @notice Position that the buyer is going to purchase.\\n    /// At any moment each guild can have only one opened position to purchase\\n    mapping(uint buyerGuildId => BuyerPositionData) buyerPosition;\\n\\n    /// @notice All open and close bids for the given position\\n    mapping(uint positionId => uint[] bidIds) positionToBidIds;\\n\\n    /// @notice Timestamp of the last bid for the auction\\n    mapping(uint positionId => uint timestamp) lastAuctionBidTs;\\n}\\n\\n  struct Position {\\n    bool open;\\n    /// @notice User that opens the position. The user belongs to the guild with id = {sellerGuildId}\\n    address seller;\\n\\n    /// @notice Assume that shelter can be stored as uint64\\n    uint64 shelterId;\\n\\n    uint128 positionId;\\n\\n    /// @notice Min allowed (initial) auction price. Only first bid is able to use it.\\n    uint128 minAuctionPrice;\\n\\n    uint128 sellerGuildId;\\n  }\\n\\n  struct AuctionBid {\\n    bool open;\\n    /// @notice User that opens the bid. The user belongs to the guild with id = {buyerGuildId}\\n    address buyer;\\n\\n    uint128 bidId;\\n    uint128 positionId;\\n    /// @notice Bid amount in terms of game token. This amount is transferred from guild Bank to ShelterAuction balance\\n    uint128 amount;\\n    uint128 buyerGuildId;\\n  }\\n\\n  struct BuyerPositionData {\\n    /// @notice ID of the position that the buyer is going to purchase\\n    uint128 positionId;\\n\\n    /// @notice 0-based index of the opened bid in {positionToBidIds}\\n    uint128 bidIndex;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function positionBySeller(uint sellerGuildId_) external view returns (uint positionId);\\n  function positionByBuyer(uint buyerGuildId) external view returns (uint positionId, uint bidIndex);\\n  function posByShelter(uint shelterId_) external view returns (uint positionId);\\n}\",\"keccak256\":\"0x3b95f4a99131b15c724b0c693dbba42d11ce57d126df07b85f432140538434a0\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IShelterController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IShelterController {\\n  /// @custom:storage-location erc7201:shelter.controller.main\\n  struct MainState {\\n    /// @notice List of items allowed to be purchased in the shelter\\n    mapping(uint shelterId => EnumerableSet.AddressSet) shelterItems;\\n\\n    /// @notice Data of items available for purchasing in the given shelter\\n    mapping(uint shelterId => mapping(address item => ShelterItemData)) shelterItemData;\\n\\n    // @notice Statistics how much items were purchased per day\\n    mapping(uint shelterId => mapping(uint32 epochDay => mapping(address item => uint))) countPurchasedItems;\\n\\n    /// @notice List of registered shelters in {biome}\\n    mapping(uint biome => EnumerableSet.UintSet shelterUids) shelters;\\n\\n    /// @notice Initial price of the shelters in game tokens\\n    mapping(uint shelterId => uint) shelterPrices;\\n\\n    /// @notice Shelters belong to a specific guild (not the player)\\n    /// Shelters can be free (don't belong to any guild)\\n    mapping(uint shelterId => uint guildId) shelterToGuild;\\n\\n    /// @notice Each guild can own 0 or 1 shelter\\n    mapping(uint guildId => uint shelterId) guildToShelter;\\n  }\\n\\n  struct ShelterItemData {\\n    /// @notice Price of the item in pvp-points\\n    uint64 priceInPvpPoints;\\n    /// @notice Price of the item game token\\n    uint128 priceInGameToken;\\n    /// @notice Max number of items that can be purchases per day in the shelter. 0 - no limitations\\n    uint16 maxItemsPerDayLimit;\\n  }\\n\\n  /// ----------------------------------------------------------------------------------------------\\n\\n  function clearShelter(uint guildId) external;\\n  function guildToShelter(uint guildId) external view returns (uint shelterId);\\n  function changeShelterOwner(uint shelterId, uint newOwnerGuildId) external;\\n  function shelterToGuild(uint shelterId) external view returns (uint guildId);\\n}\",\"keccak256\":\"0xc8b28682a31cb937edc424881e770259f07587eb9fb64de723d9b8ff6369f322\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStatController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IStatController {\\n\\n  /// @custom:storage-location erc7201:stat.controller.main\\n  struct MainState {\\n    mapping(bytes32 => bytes32[]) heroTotalAttributes;\\n    /// @dev heroAdr+heroId => int32 packed strength, dexterity, vitality, energy\\n    mapping(bytes32 => bytes32) _heroCore;\\n    mapping(bytes32 => bytes32[]) heroBonusAttributes;\\n    mapping(bytes32 => bytes32[]) heroTemporallyAttributes;\\n    /// @dev heroAdr+heroId => uint32 packed level, experience, life, mana, lifeChances\\n    mapping(bytes32 => bytes32) heroStats;\\n    /// @dev heroAdr+heroId+itemSlot => itemAdr + itemId\\n    mapping(bytes32 => bytes32) heroSlots;\\n    /// @dev heroAdr+heroId => busy slots uint8[] packed\\n    mapping(bytes32 => bytes32) heroBusySlots;\\n    mapping(bytes32 => EnumerableSet.AddressSet) usedConsumables;\\n    /// @dev heroCustomDataV2 is used instead\\n    mapping(bytes32 => mapping(bytes32 => uint)) _deprecated_heroCustomData;\\n    mapping(bytes32 => uint) globalCustomData;\\n\\n    /// @notice packNftIdWithValue(hero, heroId, ngLevel) => hero custom data map\\n    /// @dev initially it was packedHero => hero custom data map\\n    mapping(bytes32 => EnumerableMap.Bytes32ToUintMap) heroCustomDataV2;\\n  }\\n\\n\\n  enum ATTRIBUTES {\\n    // core\\n    STRENGTH, // 0\\n    DEXTERITY, // 1\\n    VITALITY, // 2\\n    ENERGY, // 3\\n    // attributes\\n    DAMAGE_MIN, // 4\\n    DAMAGE_MAX, // 5\\n    ATTACK_RATING, // 6\\n    DEFENSE, // 7\\n    BLOCK_RATING, // 8\\n    LIFE, // 9\\n    MANA, // 10\\n    // resistance\\n    FIRE_RESISTANCE, // 11\\n    COLD_RESISTANCE, // 12\\n    LIGHTNING_RESISTANCE, // 13\\n    // dmg against\\n    DMG_AGAINST_HUMAN, // 14\\n    DMG_AGAINST_UNDEAD, // 15\\n    DMG_AGAINST_DAEMON, // 16\\n    DMG_AGAINST_BEAST, // 17\\n\\n    // defence against\\n    DEF_AGAINST_HUMAN, // 18\\n    DEF_AGAINST_UNDEAD, // 19\\n    DEF_AGAINST_DAEMON, // 20\\n    DEF_AGAINST_BEAST, // 21\\n\\n    // --- unique, not augmentable\\n    // hero will not die until have positive chances\\n    LIFE_CHANCES, // 22\\n    // increase chance to get an item\\n    MAGIC_FIND, // 23\\n    // decrease chance to get an item\\n    DESTROY_ITEMS, // 24\\n    // percent of chance x2 dmg\\n    CRITICAL_HIT, // 25\\n    // dmg factors\\n    MELEE_DMG_FACTOR, // 26\\n    FIRE_DMG_FACTOR, // 27\\n    COLD_DMG_FACTOR, // 28\\n    LIGHTNING_DMG_FACTOR, // 29\\n    // increase attack rating on given percent\\n    AR_FACTOR, // 30\\n    // percent of damage will be converted to HP\\n    LIFE_STOLEN_PER_HIT, // 31\\n    // amount of mana restored after each battle\\n    MANA_AFTER_KILL, // 32\\n    // reduce all damage on percent after all other reductions\\n    DAMAGE_REDUCTION, // 33\\n\\n    // -- statuses\\n    // chance to stun an enemy, stunned enemy skip next hit\\n    STUN, // 34\\n    // chance burn an enemy, burned enemy will loss 50% of defence\\n    BURN, // 35\\n    // chance freeze an enemy, frozen enemy will loss 50% of MELEE damage\\n    FREEZE, // 36\\n    // chance to reduce enemy's attack rating on 50%\\n    CONFUSE, // 37\\n    // chance curse an enemy, cursed enemy will loss 50% of resistance\\n    CURSE, // 38\\n    // percent of dmg return to attacker\\n    REFLECT_DAMAGE_MELEE, // 39\\n    REFLECT_DAMAGE_MAGIC, // 40\\n    // chance to poison enemy, poisoned enemy will loss 10% of the current health\\n    POISON, // 41\\n    // reduce chance get any of uniq statuses\\n    RESIST_TO_STATUSES, // 42\\n\\n    END_SLOT // 46\\n  }\\n\\n  // possible\\n  // HEAL_FACTOR\\n\\n  struct CoreAttributes {\\n    int32 strength;\\n    int32 dexterity;\\n    int32 vitality;\\n    int32 energy;\\n  }\\n\\n  struct ChangeableStats {\\n    uint32 level;\\n    uint32 experience;\\n    uint32 life;\\n    uint32 mana;\\n    uint32 lifeChances;\\n  }\\n\\n  enum ItemSlots {\\n    UNKNOWN, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    BOOTS, // 6\\n    RIGHT_RING, // 7\\n    LEFT_RING, // 8\\n    RIGHT_HAND, // 9\\n    LEFT_HAND, // 10\\n    TWO_HAND, // 11\\n    SKILL_1, // 12\\n    SKILL_2, // 13\\n    SKILL_3, // 14\\n    END_SLOT // 15\\n  }\\n\\n  struct NftItem {\\n    address token;\\n    uint tokenId;\\n  }\\n\\n  enum Race {\\n    UNKNOWN, // 0\\n    HUMAN, // 1\\n    UNDEAD, // 2\\n    DAEMON, // 3\\n    BEAST, // 4\\n    END_SLOT // 5\\n  }\\n\\n  struct ChangeAttributesInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    int32[] changeAttributes;\\n    bool add;\\n    bool temporally;\\n  }\\n\\n  struct BuffInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    uint32 heroLevel;\\n    address[] buffTokens;\\n    uint[] buffTokenIds;\\n  }\\n\\n  /// @dev This struct is used inside event, so it's moved here from lib\\n  struct ActionInternalInfo {\\n    int32[] posAttributes;\\n    int32[] negAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintedItems;\\n  }\\n\\n  function initNewHero(address token, uint tokenId, uint heroClass) external;\\n\\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory);\\n\\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32);\\n\\n  function heroAttributesLength(address token, uint tokenId) external view returns (uint);\\n\\n  function heroBaseAttributes(address token, uint tokenId) external view returns (CoreAttributes memory);\\n\\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint);\\n\\n  function globalCustomData(bytes32 index) external view returns (uint);\\n\\n  function heroStats(address token, uint tokenId) external view returns (ChangeableStats memory);\\n\\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked);\\n\\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory);\\n\\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function levelUp(address token, uint tokenId, uint heroClass, CoreAttributes memory change) external returns (uint newLvl);\\n\\n  function changeHeroItemSlot(\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) external;\\n\\n  function changeCurrentStats(\\n    address token,\\n    uint tokenId,\\n    ChangeableStats memory change,\\n    bool increase\\n  ) external;\\n\\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external;\\n\\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external;\\n\\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external;\\n\\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external;\\n\\n  function buffHero(BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed);\\n\\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external;\\n\\n  function setGlobalCustomData(bytes32 index, uint value) external;\\n\\n  /// @notice Restore life and mana during reinforcement\\n  /// @dev Life and mana will be increased on ((current life/mana attr value) - (prev life/mana attr value))\\n  /// @param prevAttributes Hero attributes before reinforcement\\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external;\\n\\n  function reborn(address heroToken, uint heroTokenId, uint heroClass) external;\\n}\\n\",\"keccak256\":\"0x5347ef90b52cf225333751b447b17cd2ad8db2af36f278bb67efe345d5e7d536\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStoryController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"./IController.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./IHeroController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStoryController {\\n\\n  enum AnswerResultId {\\n    UNKNOWN, // 0\\n    SUCCESS, // 1\\n    ATTRIBUTE_FAIL, // 2\\n    RANDOM_FAIL, // 3\\n    DELAY_FAIL, // 4\\n    HERO_CUSTOM_DATA_FAIL, // 5\\n    GLOBAL_CUSTOM_DATA_FAIL, // 6\\n\\n    END_SLOT\\n  }\\n\\n  enum CustomDataResult {\\n    UNKNOWN, // 0\\n    HERO_SUCCESS, // 1\\n    HERO_FAIL, // 2\\n    GLOBAL_SUCCESS, // 3\\n    GLOBAL_FAIL, // 4\\n\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:story.controller.main\\n  struct MainState {\\n\\n    // --- STORY REG INFO ---\\n\\n    /// @dev Uniq story identification.\\n    mapping(uint32 => uint16) storyIds;\\n    /// @dev Revers mapping for stories for using in the next object rewrite logic.\\n    mapping(uint16 => uint32) idToStory;\\n    /// @dev Store used ids for stories.\\n    mapping(uint16 => bool) _usedStoryIds;\\n    /// @dev Prevent register the story twice\\n    mapping(uint32 => bool) registeredStories;\\n\\n    // --- ANSWER MAPPING ---\\n\\n    /// @dev storyId => all story pages. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.UintSet) allStoryPages;\\n\\n    /// @dev storyId => all possible answers. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.Bytes32Set) allStoryAnswers;\\n\\n    /// @dev storyId + pageId + heroClass (zero is default answers) => storyId + pageId + heroClass (zero is default answers) + answerId\\n    mapping(bytes32 => bytes32[]) answers;\\n    /// @dev answerUnPackedId + answerResultId => nextPageIds (will be chosen randomly from this array)\\n    ///      where answerResultId is:\\n    ///      0 - unknown,\\n    ///      1 - success,\\n    ///      2 - attr fail\\n    ///      3 - random fail\\n    ///      4 - delay fail\\n    ///      5 - hero custom data fail\\n    ///      6 - global custom data fail\\n    ///      see COUNT_ANSWER_RESULT_IDS\\n    mapping(bytes32 => uint16[]) nextPageIds;\\n    /// @dev story + pageId + heroClass (zero is default answers) => random nextObjs (adr + id, like packed nft id)\\n    mapping(bytes32 => uint32[]) nextObjectsRewrite;\\n\\n    /// @dev answerPackedId => packed array of uint32[]\\n    ///      0 - random requirement(uint32, 1 - 99% success of this action, zero means no check)\\n    ///      1 - delay requirement(uint32, if time since the last call more than this value the check is fail, zero means no check)\\n    ///      2 - isFinalAnswer(uint8)\\n    mapping(bytes32 => bytes32) answerAttributes;\\n\\n    // --- ANSWER REQUIREMENTS ---\\n\\n    /// @dev answerPackedId => array of AttributeRequirementsPacked\\n    mapping(bytes32 => bytes32[]) attributeRequirements;\\n    /// @dev answerPackedId=> array of ItemRequirementsPacked\\n    mapping(bytes32 => bytes32[]) itemRequirements;\\n    /// @dev answerPackedId => array of TokenRequirementsPacked\\n    mapping(bytes32 => bytes32[]) tokenRequirements;\\n    /// @dev answerPackedId => custom data for hero\\n    mapping(bytes32 => CustomDataRequirementPacked[]) heroCustomDataRequirement;\\n    /// @dev answerPackedId => global custom data\\n    mapping(bytes32 => CustomDataRequirementPacked[]) globalCustomDataRequirement;\\n\\n    // --- ANSWER RESULTS ---\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) successInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) successInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) successInfoMintItems;\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) failInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) failInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) failInfoMintItems;\\n\\n    /// @dev answerUnPackedId + CustomDataResult => custom data array change\\n    ///      where CustomDataResult is\\n    ///      1 - hero success\\n    ///      2 - hero fail\\n    ///      3 - global success\\n    ///      4 - global fail\\n    ///      see COUNT_CUSTOM_DATA_RESULT_IDS\\n    mapping(bytes32 => bytes32[]) customDataResult;\\n\\n    /// @notice answerPackedId => slot+chance+stopIfBurnt\\n    /// @dev Since SIP-003 the items are not burn but broke\\n    mapping(bytes32 => bytes32[]) burnItem;\\n\\n    // --- GENERAL STORY REQUIREMENTS ---\\n\\n    /// @dev story => Custom hero data requirements for a story. If exist and hero is not eligible should be not chose in a dungeon.\\n    mapping(uint => CustomDataRequirementRangePacked[]) storyRequiredHeroData;\\n    /// @dev story => Minimal level for the history. 0 means no requirements.\\n    mapping(uint => uint) storyRequiredLevel;\\n\\n    // --- HERO STATES ---\\n\\n    /// @dev hero + heroId + storyId => pageId + heroLastActionTS\\n    mapping(bytes32 => bytes32) heroState;\\n\\n    // --- OTHER ---\\n\\n    /// @dev storyId => build hash for the last update\\n    mapping(uint16 => uint) storyBuildHash;\\n\\n    /// @notice Number of already minted items by the user within the given iteration of the story.\\n    /// Only minting of the given number of items is allowed per iteration (see MAX_MINTED_ITEMS_PER_ITERATION).\\n    /// @dev hero, heroId, story => mintedInIteration\\n    /// This map is not cleared: storyId:objectId is 1:1, each object has own sequence of iterations without duplicates\\n    mapping(bytes32 => mapping(uint iteration => uint countMintedItems)) mintedInIteration;\\n  }\\n\\n  /// @dev We need to have flat structure coz Solidity can not handle arrays of structs properly\\n  struct StoryMetaInfo {\\n    uint16 storyId;\\n\\n    // --- story reqs\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n    uint minLevel;\\n\\n    // --- answer reqs\\n\\n    AnswersMeta answersMeta;\\n    AnswerNextPageMeta answerNextPage;\\n    AnswerAttributeRequirementsMeta answerAttributeRequirements;\\n    AnswerItemRequirementsMeta answerItemRequirements;\\n    AnswerTokenRequirementsMeta answerTokenRequirements;\\n    AnswerAttributesMeta answerAttributes;\\n    AnswerCustomDataMeta answerHeroCustomDataRequirement;\\n    AnswerCustomDataMeta answerGlobalCustomDataRequirement;\\n\\n    // --- answer results\\n\\n    AnswerBurnRandomItemMeta answerBurnRandomItemMeta;\\n    NextObjRewriteMeta nextObjRewriteMeta;\\n\\n    // --- story results\\n\\n    AnswerResultMeta successInfo;\\n    AnswerResultMeta failInfo;\\n\\n    AnswerCustomDataResultMeta successHeroCustomData;\\n    AnswerCustomDataResultMeta failHeroCustomData;\\n    AnswerCustomDataResultMeta successGlobalCustomData;\\n    AnswerCustomDataResultMeta failGlobalCustomData;\\n  }\\n\\n  struct NextObjRewriteMeta {\\n    uint16[] nextObjPageIds;\\n    uint8[] nextObjHeroClasses;\\n    uint32[][] nextObjIds;\\n  }\\n\\n  struct AnswersMeta {\\n    uint16[] answerPageIds;\\n    uint8[] answerHeroClasses;\\n    uint16[] answerIds;\\n  }\\n\\n  struct AnswerNextPageMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint8[] answerResultIds;\\n    uint16[][] answerNextPageIds;\\n  }\\n\\n  struct AnswerAttributeRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    bool[][] cores;\\n    uint8[][] ids;\\n    int32[][] values;\\n  }\\n\\n  struct AnswerItemRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireItems;\\n    bool[][] requireItemBurn;\\n    bool[][] requireItemEquipped;\\n  }\\n\\n  struct AnswerTokenRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireToken;\\n    uint88[][] requireAmount;\\n    bool[][] requireTransfer;\\n  }\\n\\n  struct AnswerAttributesMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint32[] randomRequirements;\\n    uint32[] delayRequirements;\\n    bool[] isFinalAnswer;\\n  }\\n\\n  struct AnswerCustomDataMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    bool[][] mandatory;\\n    uint64[][] dataValuesMin;\\n    uint64[][] dataValuesMax;\\n  }\\n\\n  struct AnswerResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    uint8[][] attributeIds;\\n    /// @dev Max value is limitied by int24, see toBytes32ArrayWithIds impl\\n    int32[][] attributeValues;\\n\\n    uint32[] experience;\\n    int32[] heal;\\n    int32[] manaRegen;\\n    int32[] lifeChancesRecovered;\\n    int32[] damage;\\n    int32[] manaConsumed;\\n\\n    address[][] mintItems;\\n    uint32[][] mintItemsChances;\\n  }\\n\\n  struct AnswerCustomDataResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    int16[][] dataValues;\\n  }\\n\\n  struct AnswerBurnRandomItemMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    /// @notice 0 - random slot\\n    uint8[][] slots;\\n    /// @notice typical chances are [0..100] (no decimals here)\\n    uint64[][] chances;\\n    /// @notice Since SIP-003 the burning is replaced by breaking bu the name is kept as is\\n    bool[][] isStopIfBurnt;\\n  }\\n\\n  struct CustomDataRequirementPacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + mandatory(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct CustomDataRequirementRangePacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + isHeroData(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct StatsChange {\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n  }\\n\\n  struct StoryActionContext {\\n    uint stageId;\\n    uint iteration;\\n    bytes32 answerIdHash;\\n    bytes32 answerAttributes;\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IStatController statController;\\n    IHeroController heroController;\\n    IOracle oracle;\\n    IItemController itemController;\\n    uint8 heroClass;\\n    uint8 heroClassFromAnswerHash;\\n    uint8 biome;\\n    uint16 storyId;\\n    uint16 storyIdFromAnswerHash;\\n    uint16 pageIdFromAnswerHash;\\n    uint16 answerNumber;\\n    uint16 pageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint40 heroLastActionTS;\\n    uint80 heroTokenId;\\n    IStatController.ChangeableStats heroStats;\\n  }\\n\\n  // --- WRITE ---\\n\\n  function storyAction(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) external returns (IGOC.ActionResult memory);\\n\\n  // --- READ ---\\n\\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function idToStory(uint16 id) external view returns (uint32 objectId);\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId);\\n\\n  function storyIds(uint32 objectId) external view returns (uint16);\\n\\n  function registeredStories(uint32 objectId) external view returns (bool);\\n\\n}\\n\",\"keccak256\":\"0x7822f79d53590b18455c5d54d91f5b38fabc1330f24ae41db546a785c151e61d\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/ITreasury.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface ITreasury {\\n\\n  function balanceOfToken(address token) external view returns (uint);\\n\\n  function sendToDungeon(address dungeon, address token, uint amount) external;\\n}\\n\",\"keccak256\":\"0x0977372e2310cd09e7b99c5f2b1af75949bf18ebcabfd0fc114e4f8714760414\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IUserController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IUserController {\\n\\n  //region ------------------------ Data types\\n\\n  enum LootBoxKind {\\n    /// @notice small loot box - reward for the daily activity\\n    DAILY_0,\\n    /// @notice large loot box - reward for the weekly activity (daily activity is passed each ot of the 7 days)\\n    WEEKLY_1,\\n\\n    END_SLOT\\n  }\\n\\n  /// @dev registerPassedDungeon assumes that the whole struct takes single slot only, not more\\n  struct UserActivity {\\n    /// @notice A day for which the daily activity is calculated (see counterXXX below)\\n    /// The number of days since 1970-01-01\\n    uint32 epochDay;\\n\\n    /// @notice A week for which total count of daily activities were calculated\\n    /// The number of weeks since (1970-01-01 Thursday) - 3 days = (1969-12-29 Monday)\\n    uint32 epochWeek;\\n\\n    /// @notice Count of dungeons passed during the day\\n    uint32 counterPassedDungeons;\\n    /// @notice Count of PvP during the day\\n    uint32 counterPvp;\\n\\n    /// @notice Count of daily activities completed per the week\\n    uint16 dailyActivities;\\n\\n    /// @notice Daily activity is completed and small loot box is added to the earned loot boxes\\n    bool dailyLootBoxReceived;\\n    /// @notice Weekly activity is completed and large loot box is added to the earned loot boxes\\n    bool weeklyLootBoxReceived;\\n  }\\n\\n  struct EarnedLootBoxes {\\n    /// @notice Count of loot boxes earned by daily activity\\n    uint32 dailyCounter;\\n    /// @notice Count of loot boxes earned by weekly activity\\n    uint32 weeklyCounter;\\n  }\\n\\n  struct LootBoxConfig {\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n    uint maxDropItems;\\n  }\\n\\n  /// @custom:storage-location erc7201:user.controller.main\\n  struct MainState {\\n    /// @notice Amount of sacra required to rename user account\\n    uint feeRenaming;\\n\\n    /// @dev user EOA => account name\\n    mapping(address => string) userAccountName;\\n\\n    /// @dev name => user EOA, needs for checking uniq names\\n    mapping(string => address) nameToUserAccount;\\n\\n    /// @notice user => daily activity info\\n    mapping(address => UserActivity) userActivity;\\n\\n    /// @notice user => earned loot boxes\\n    mapping(address => EarnedLootBoxes) counterLootBoxes;\\n\\n    /// @notice Configs of loot boxes of various kinds\\n    mapping(LootBoxKind => LootBoxConfig) lootBoxConfig;\\n\\n    /// @dev Deprecated, controller is used instead.\\n    address userTokensVault;\\n\\n    /// @dev user EOA => account avatar\\n    mapping(address => string) userAvatar;\\n\\n    // @notice Hall of Fame: ngLevel [1...99] => who opened the NG_LEVEL first\\n    mapping(uint8 ngLevel => FameHallData) fameHall;\\n  }\\n\\n  struct FameHallData {\\n    // ------------ slot 1\\n    /// @notice The hero who opened given the NG_LEVEL first\\n    address hero;\\n    uint64 heroId;\\n    // ------------ slot 2\\n    /// @notice The owner of the hero\\n    address heroOwner;\\n    /// @notice Timestamp of the moment of the opening given NG_LEVEL\\n    uint64 tsOpen;\\n  }\\n\\n  //endregion ------------------------ Data types\\n\\n  /// @notice Register daily activity - a dungeon was passed\\n  /// @param user Owner of the hero who has passed the dungeon\\n  function registerPassedDungeon(address user) external;\\n\\n  /// @notice Register daily activity - PvP was made\\n  /// @param user Owner of the hero who has taken participation in the PvP\\n  function registerPvP(address user, bool isWinner) external;\\n\\n  function registerFameHallHero(address hero, uint heroId, uint8 openedNgLevel) external;\\n}\\n\",\"keccak256\":\"0xf9eb38037fa8a86873a7e9670df98caa9d848ead06926c0ff4e24ed96c1f4af3\",\"license\":\"BUSL-1.1\"},\"contracts/lib/CalcLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\n\\nlibrary CalcLib {\\n\\n  uint32 public constant MAX_CHANCE = 1e9;\\n\\n  function minI32(int32 a, int32 b) internal pure returns (int32) {\\n    return a < b ? a : b;\\n  }\\n\\n  function max32(int32 a, int32 b) internal pure returns (int32) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function absDiff(int32 a, int32 b) internal pure returns (uint32) {\\n    if (!((a >= 0 && b >= 0) || (a <= 0 && b <= 0))) revert IAppErrors.AbsDiff(a, b);\\n    if (a < 0) {\\n      a = - a;\\n    }\\n    if (b < 0) {\\n      b = - b;\\n    }\\n    return uint32(uint(int(a >= b ? a - b : b - a)));\\n  }\\n\\n  function toUint(int32 n) internal pure returns (uint) {\\n    if (n < 0) {\\n      return 0;\\n    }\\n    if (n <= 0) {\\n      return 0;\\n    }\\n    return uint(int(n));\\n  }\\n\\n  function toInt32(uint a) internal pure returns (int32){\\n    if (a >= uint(int(type(int32).max))) {\\n      return type(int32).max;\\n    }\\n    return int32(int(a));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandom(uint maxValue) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n\\n    uint salt = genSalt();\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), salt))) % (maxValue + 1));\\n  }\\n\\n  function genSalt() internal view returns (uint salt) {\\n    // skale has a RNG Endpoint\\n    if (\\n      block.chainid == uint(1351057110)\\n      || block.chainid == uint(37084624)\\n    ) {\\n      assembly {\\n        let freemem := mload(0x40)\\n        let start_addr := add(freemem, 0)\\n        if iszero(staticcall(gas(), 0x18, 0, 0, start_addr, 32)) {\\n          invalid()\\n        }\\n        salt := mload(freemem)\\n      }\\n    }\\n  }\\n\\n  function pseudoRandomUint32(uint32 maxValue) internal view returns (uint32) {\\n    return uint32(pseudoRandom(uint(maxValue)));\\n  }\\n\\n  /// @notice Generate pseudo-random uint in the range [0..maxValue) using Solady pseudo-random function\\n  function nextPrng(LibPRNG.PRNG memory prng, uint maxValue) internal pure returns (uint) {\\n    return LibPRNG.next(prng) % maxValue;\\n  }\\n\\n  /// @notice pseudoRandomUint32 with customizable pseudoRandom()\\n  function pseudoRandomUint32Flex(\\n    uint32 maxValue,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint32) {\\n    return uint32(random_(uint(maxValue)));\\n  }\\n\\n  function pseudoRandomInt32(int32 maxValue) internal view returns (int32) {\\n    bool neg;\\n    if (maxValue < 0) {\\n      neg = true;\\n      maxValue = - maxValue;\\n    }\\n    uint32 v = uint32(pseudoRandom(uint(int(maxValue))));\\n    return neg\\n      ? - int32(int(uint(v)))\\n      : int32(int(uint(v)));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandomWithSeed(uint maxValue, uint seed) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    uint salt = genSalt();\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), seed, salt))) % (maxValue + 1));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  function pseudoRandomInRange(uint min, uint max) internal view returns (uint) {\\n    if (min >= max) {\\n      return max;\\n    }\\n    uint r = pseudoRandom(max - min);\\n    return min + r;\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  ///      Equal to pseudoRandomInRange(min, max, pseudoRandom)\\n  function pseudoRandomInRangeFlex(\\n    uint min,\\n    uint max,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint) {\\n    return min >= max ? max : min + random_(max - min);\\n  }\\n\\n  function minusWithZeroFloor(uint a, uint b) internal pure returns (uint){\\n    if (a <= b) {\\n      return 0;\\n    }\\n    return a - b;\\n  }\\n\\n  function minusWithMinFloorI32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) - int(b) < type(int32).min) {\\n      return type(int32).min;\\n    }\\n    return a - b;\\n  }\\n\\n  function plusWithMaxFloor32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) + int(b) >= type(int32).max) {\\n      return type(int32).max;\\n    }\\n    return a + b;\\n  }\\n\\n  function sqrt(uint x) internal pure returns (uint z) {\\n    assembly {\\n    // Start off with z at 1.\\n      z := 1\\n\\n    // Used below to help find a nearby power of 2.\\n      let y := x\\n\\n    // Find the lowest power of 2 that is at least sqrt(x).\\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n        y := shr(128, y) // Like dividing by 2 ** 128.\\n        z := shl(64, z) // Like multiplying by 2 ** 64.\\n      }\\n      if iszero(lt(y, 0x10000000000000000)) {\\n        y := shr(64, y) // Like dividing by 2 ** 64.\\n        z := shl(32, z) // Like multiplying by 2 ** 32.\\n      }\\n      if iszero(lt(y, 0x100000000)) {\\n        y := shr(32, y) // Like dividing by 2 ** 32.\\n        z := shl(16, z) // Like multiplying by 2 ** 16.\\n      }\\n      if iszero(lt(y, 0x10000)) {\\n        y := shr(16, y) // Like dividing by 2 ** 16.\\n        z := shl(8, z) // Like multiplying by 2 ** 8.\\n      }\\n      if iszero(lt(y, 0x100)) {\\n        y := shr(8, y) // Like dividing by 2 ** 8.\\n        z := shl(4, z) // Like multiplying by 2 ** 4.\\n      }\\n      if iszero(lt(y, 0x10)) {\\n        y := shr(4, y) // Like dividing by 2 ** 4.\\n        z := shl(2, z) // Like multiplying by 2 ** 2.\\n      }\\n      if iszero(lt(y, 0x8)) {\\n      // Equivalent to 2 ** z.\\n        z := shl(1, z)\\n      }\\n\\n    // Shifting right by 1 is like dividing by 2.\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n\\n    // Compute a rounded down version of z.\\n      let zRoundDown := div(x, z)\\n\\n    // If zRoundDown is smaller, use it.\\n      if lt(zRoundDown, z) {\\n        z := zRoundDown\\n      }\\n    }\\n  }\\n\\n  /*********************************************\\n *              PRB-MATH                      *\\n *   https://github.com/hifi-finance/prb-math *\\n **********************************************/\\n  /// @notice Calculates the binary logarithm of x.\\n  ///\\n  /// @dev Based on the iterative approximation algorithm.\\n  /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n  ///\\n  /// Requirements:\\n  /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n  ///\\n  /// Caveats:\\n  /// - The results are nor perfectly accurate to the last decimal,\\n  ///   due to the lossy precision of the iterative approximation.\\n  ///\\n  /// @param x The unsigned 60.18-decimal fixed-point number for which\\n  ///           to calculate the binary logarithm.\\n  /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n  function log2(uint256 x) internal pure returns (uint256 result) {\\n    if (x < 1e18) revert IAppErrors.TooLowX(x);\\n\\n    // Calculate the integer part of the logarithm\\n    // and add it to the result and finally calculate y = x * 2^(-n).\\n    uint256 n = mostSignificantBit(x / 1e18);\\n\\n    // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number.\\n    // The operation can't overflow because n is maximum 255 and SCALE is 1e18.\\n    uint256 rValue = n * 1e18;\\n\\n    // This is y = x * 2^(-n).\\n    uint256 y = x >> n;\\n\\n    // If y = 1, the fractional part is zero.\\n    if (y == 1e18) {\\n      return rValue;\\n    }\\n\\n    // Calculate the fractional part via the iterative approximation.\\n    // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n    for (uint256 delta = 5e17; delta > 0; delta >>= 1) {\\n      y = (y * y) / 1e18;\\n\\n      // Is y^2 > 2 and so in the range [2,4)?\\n      if (y >= 2 * 1e18) {\\n        // Add the 2^(-m) factor to the logarithm.\\n        rValue += delta;\\n\\n        // Corresponds to z/2 on Wikipedia.\\n        y >>= 1;\\n      }\\n    }\\n    return rValue;\\n  }\\n\\n  /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n  /// @dev See the note on msb in the \\\"Find First Set\\\"\\n  ///      Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n  /// @param x The uint256 number for which to find the index of the most significant bit.\\n  /// @return msb The index of the most significant bit as an uint256.\\n  //noinspection NoReturn\\n  function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n    if (x >= 2 ** 128) {\\n      x >>= 128;\\n      msb += 128;\\n    }\\n    if (x >= 2 ** 64) {\\n      x >>= 64;\\n      msb += 64;\\n    }\\n    if (x >= 2 ** 32) {\\n      x >>= 32;\\n      msb += 32;\\n    }\\n    if (x >= 2 ** 16) {\\n      x >>= 16;\\n      msb += 16;\\n    }\\n    if (x >= 2 ** 8) {\\n      x >>= 8;\\n      msb += 8;\\n    }\\n    if (x >= 2 ** 4) {\\n      x >>= 4;\\n      msb += 4;\\n    }\\n    if (x >= 2 ** 2) {\\n      x >>= 2;\\n      msb += 2;\\n    }\\n    if (x >= 2 ** 1) {\\n      // No need to shift x any more.\\n      msb += 1;\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x5422c2046a6f6e2a009b4999258a5e94b49b8fa60c63e5da431302699205b113\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ControllerContextLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\nimport \\\"../interfaces/IDungeonFactory.sol\\\";\\nimport \\\"../interfaces/IReinforcementController.sol\\\";\\nimport \\\"../interfaces/IGameToken.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IUserController.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IRewardsPool.sol\\\";\\n\\n/// @notice Provide context-struct with all controller addresses and routines for lazy init\\n/// Usage:\\n///       Create an instance of the structure\\n///               cc = ControllerContextLib.init(controller);\\n///       access controller directly\\n///               cc.controller.xxx();\\n///       access other contracts indirectly\\n///               sc = ControllerContextLib.getStatController(cc);\\nlibrary ControllerContextLib {\\n  struct ControllerContext {\\n    IController controller;\\n    IStatController statController;\\n    IStoryController storyController;\\n    IOracle oracle;\\n    ITreasury treasury;\\n    IDungeonFactory dungeonFactory;\\n    IGOC gameObjectController;\\n    IReinforcementController reinforcementController;\\n    IItemController itemController;\\n    IHeroController heroController;\\n    IGameToken gameToken;\\n    IUserController userController;\\n    IGuildController guildController;\\n    IRewardsPool rewardsPool;\\n  }\\n\\n  function init(IController controller) internal pure returns (ControllerContext memory cc) {\\n    cc.controller = controller;\\n    return cc;\\n  }\\n\\n  function getStatController(ControllerContext memory cc) internal view returns (IStatController statController) {\\n    if (address(cc.statController) == address(0)) {\\n      cc.statController = IStatController(cc.controller.statController());\\n    }\\n    return cc.statController;\\n  }\\n\\n  function getStoryController(ControllerContext memory cc) internal view returns (IStoryController storyController) {\\n    if (address(cc.storyController) == address(0)) {\\n      cc.storyController = IStoryController(cc.controller.storyController());\\n    }\\n    return cc.storyController;\\n  }\\n\\n  function getOracle(ControllerContext memory cc) internal view returns (IOracle oracle) {\\n    if (address(cc.oracle) == address(0)) {\\n      cc.oracle = IOracle(cc.controller.oracle());\\n    }\\n    return cc.oracle;\\n  }\\n\\n  function getTreasury(ControllerContext memory cc) internal view returns (ITreasury treasury) {\\n    if (address(cc.treasury) == address(0)) {\\n      cc.treasury = ITreasury(cc.controller.treasury());\\n    }\\n    return cc.treasury;\\n  }\\n\\n  function getDungeonFactory(ControllerContext memory cc) internal view returns (IDungeonFactory dungeonFactory) {\\n    if (address(cc.dungeonFactory) == address(0)) {\\n      cc.dungeonFactory = IDungeonFactory(cc.controller.dungeonFactory());\\n    }\\n    return cc.dungeonFactory;\\n  }\\n\\n  function getGameObjectController(ControllerContext memory cc) internal view returns (IGOC gameObjectController) {\\n    if (address(cc.gameObjectController) == address(0)) {\\n      cc.gameObjectController = IGOC(cc.controller.gameObjectController());\\n    }\\n    return cc.gameObjectController;\\n  }\\n\\n  function getReinforcementController(ControllerContext memory cc) internal view returns (IReinforcementController reinforcementController) {\\n    if (address(cc.reinforcementController) == address(0)) {\\n      cc.reinforcementController = IReinforcementController(cc.controller.reinforcementController());\\n    }\\n    return cc.reinforcementController;\\n  }\\n\\n  function getItemController(ControllerContext memory cc) internal view returns (IItemController itemController) {\\n    if (address(cc.itemController) == address(0)) {\\n      cc.itemController = IItemController(cc.controller.itemController());\\n    }\\n    return cc.itemController;\\n  }\\n\\n  function getHeroController(ControllerContext memory cc) internal view returns (IHeroController heroController) {\\n    if (address(cc.heroController) == address(0)) {\\n      cc.heroController = IHeroController(cc.controller.heroController());\\n    }\\n    return cc.heroController;\\n  }\\n\\n  function getGameToken(ControllerContext memory cc) internal view returns (IGameToken gameToken) {\\n    if (address(cc.gameToken) == address(0)) {\\n      cc.gameToken = IGameToken(cc.controller.gameToken());\\n    }\\n    return cc.gameToken;\\n  }\\n\\n  function getUserController(ControllerContext memory cc) internal view returns (IUserController userController) {\\n    if (address(cc.userController) == address(0)) {\\n      cc.userController = IUserController(cc.controller.userController());\\n    }\\n    return cc.userController;\\n  }\\n\\n  function getGuildController(ControllerContext memory cc) internal view returns (IGuildController guildController) {\\n    if (address(cc.guildController) == address(0)) {\\n      cc.guildController = IGuildController(cc.controller.guildController());\\n    }\\n    return cc.guildController;\\n  }\\n\\n  function getRewardsPool(ControllerContext memory cc) internal view returns (IRewardsPool rewardsPool) {\\n    if (address(cc.rewardsPool) == address(0)) {\\n      cc.rewardsPool = IRewardsPool(cc.controller.rewardsPool());\\n    }\\n    return cc.rewardsPool;\\n  }\\n}\",\"keccak256\":\"0x01f2366db544f684cc2d7e97fd010f83d1c534c53d18b40af499797ec89af185\",\"license\":\"BUSL-1.1\"},\"contracts/lib/EventLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\nimport \\\"./ItemLib.sol\\\";\\nimport \\\"./StoryLib.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\n\\nlibrary EventLib {\\n  using CalcLib for int32;\\n  using PackingLib for bytes32;\\n  using PackingLib for bytes32[];\\n  using PackingLib for uint16;\\n  using PackingLib for uint8;\\n  using PackingLib for address;\\n  using PackingLib for uint32[];\\n  using PackingLib for uint32;\\n  using PackingLib for uint64;\\n  using PackingLib for int32[];\\n  using PackingLib for int32;\\n\\n  //region ------------------------ Main logic\\n\\n  function action(IGOC.ActionContext calldata ctx, IGOC.EventInfo storage info) external returns (\\n    IGOC.ActionResult memory\\n  ) {\\n    (bool accept) = abi.decode(ctx.data, (bool));\\n    return accept\\n      ? _eventAcceptResult(ctx, info)\\n      : _noActionResult();\\n  }\\n\\n  /// @notice Save data from {regInfo} to {info}\\n  function eventRegInfoToInfo(IGOC.EventRegInfo calldata regInfo, IGOC.EventInfo storage info) external {\\n    info.goodChance = regInfo.goodChance;\\n    info.goodAttributes = regInfo.goodAttributes.values.toBytes32ArrayWithIds(regInfo.goodAttributes.ids);\\n    info.badAttributes = regInfo.badAttributes.values.toBytes32ArrayWithIds(regInfo.badAttributes.ids);\\n    info.statsChange = regInfo.experience.packStatsChange(\\n      regInfo.heal,\\n      regInfo.manaRegen,\\n      regInfo.lifeChancesRecovered,\\n      regInfo.damage,\\n      regInfo.manaConsumed\\n    );\\n\\n    bytes32[] memory mintItems = new bytes32[](regInfo.mintItems.length);\\n\\n    for (uint i; i < mintItems.length; ++i) {\\n      mintItems[i] = regInfo.mintItems[i].packItemMintInfo(regInfo.mintItemsChances[i]);\\n    }\\n    info.mintItems = mintItems;\\n  }\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ Internal logic\\n  function _eventAcceptResult(IGOC.ActionContext calldata ctx, IGOC.EventInfo storage info) internal returns (\\n    IGOC.ActionResult memory result\\n  ) {\\n    IStatController sc = IStatController(ctx.controller.statController());\\n\\n    IStatController.ActionInternalInfo memory gen = _generate(ctx, info, sc);\\n\\n    if (gen.posAttributes.length != 0) {\\n      sc.changeBonusAttributes(IStatController.ChangeAttributesInfo({\\n        heroToken: ctx.heroToken,\\n        heroTokenId: ctx.heroTokenId,\\n        changeAttributes: gen.posAttributes,\\n        add: true,\\n        temporally: true\\n      }));\\n    }\\n\\n    if (gen.negAttributes.length != 0) {\\n      sc.changeBonusAttributes(IStatController.ChangeAttributesInfo({\\n        heroToken: ctx.heroToken,\\n        heroTokenId: ctx.heroTokenId,\\n        changeAttributes: gen.negAttributes,\\n        add: true,\\n        temporally: true\\n      }));\\n    }\\n\\n    // refreshed stats\\n    IStatController.ChangeableStats memory stats = sc.heroStats(ctx.heroToken, ctx.heroTokenId);\\n\\n    result.completed = true;\\n    result.experience = gen.experience;\\n    result.heal = gen.heal;\\n    result.manaRegen = gen.manaRegen;\\n    result.lifeChancesRecovered = gen.lifeChancesRecovered;\\n    result.damage = gen.damage;\\n    result.manaConsumed = CalcLib.minI32(gen.manaConsumed, int32(stats.mana));\\n    result.mintItems = gen.mintedItems;\\n\\n    if (stats.life <= gen.damage.toUint()) {\\n      result.kill = true;\\n    }\\n\\n    emit IApplicationEvents.EventResult(ctx.dungeonId, ctx.heroToken, ctx.heroTokenId, ctx.stageId, gen, ctx.iteration);\\n    return result;\\n  }\\n\\n  /// @notice Generate empty result structure, only \\\"completed\\\" is true\\n  function _noActionResult() internal pure returns (IGOC.ActionResult memory result) {\\n    result.completed = true;\\n    return result;\\n  }\\n\\n  /// @notice Generate either positive or negative attributes, mint single item in any case\\n  function _generate(IGOC.ActionContext calldata ctx, IGOC.EventInfo storage info, IStatController sc) internal returns (\\n    IStatController.ActionInternalInfo memory result\\n  ) {\\n    uint32 goodChance = info.goodChance;\\n    if (goodChance > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighChance(goodChance);\\n\\n    IOracle oracle = IOracle(ctx.controller.oracle());\\n\\n    uint random = goodChance == CalcLib.MAX_CHANCE ? CalcLib.MAX_CHANCE : oracle.getRandomNumber(CalcLib.MAX_CHANCE, 0);\\n    if (random <= goodChance) {\\n      result.posAttributes = StoryLib._generateAttributes(info.goodAttributes);\\n      (result.experience,\\n        result.heal,\\n        result.manaRegen,\\n        result.lifeChancesRecovered,,) = info.statsChange.unpackStatsChange();\\n    } else {\\n      result.negAttributes = StoryLib._generateAttributes(info.badAttributes);\\n      (,,,, result.damage, result.manaConsumed) = info.statsChange.unpackStatsChange();\\n    }\\n\\n    // always mint possible items even if bad result\\n    result.mintedItems = _mintRandomItem(ctx, info, oracle, sc, CalcLib.nextPrng);\\n\\n    return result;\\n  }\\n\\n  /// @notice Mint single random item\\n  /// @param nextPrng_ CalcLib.nextPrng, param is required by unit tests\\n  function _mintRandomItem(\\n    IGOC.ActionContext calldata ctx,\\n    IGOC.EventInfo storage info,\\n    IOracle oracle,\\n    IStatController sc,\\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\\n  ) internal returns (address[] memory minted) {\\n    bytes32[] memory mintItemsPacked = info.mintItems;\\n    if (mintItemsPacked.length == 0) {\\n      return minted;\\n    }\\n\\n    IStatController.ChangeableStats memory stats = sc.heroStats(ctx.heroToken, ctx.heroTokenId);\\n\\n    address[] memory mintItems = new address[](mintItemsPacked.length);\\n    uint32[] memory mintItemsChances = new uint32[](mintItemsPacked.length);\\n\\n    for (uint i = 0; i < mintItemsPacked.length; i++) {\\n      (mintItems[i], mintItemsChances[i]) = mintItemsPacked[i].unpackItemMintInfo();\\n    }\\n\\n    return ItemLib._mintRandomItems(\\n      ItemLib.MintItemInfo({\\n        mintItems: mintItems,\\n        mintItemsChances: mintItemsChances,\\n        amplifier: 0,\\n        seed: 0,\\n        oracle: oracle,\\n        magicFind: 0,\\n        destroyItems: 0,\\n        maxItems: 1, // MINT ONLY 1 ITEM!\\n        mintDropChanceDelta: StatLib.mintDropChanceDelta(stats.experience, uint8(stats.level), ctx.biome),\\n        mintDropChanceNgLevelMultiplier: 1e18\\n      }),\\n      nextPrng_\\n    );\\n  }\\n  //endregion ------------------------ Internal logic\\n}\\n\",\"keccak256\":\"0x247c814eaecfb63e4fe36625191121f6e6892d78dd58da80f6a4d76a8dd77994\",\"license\":\"BUSL-1.1\"},\"contracts/lib/FightLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IFightCalculator.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../lib/StatLib.sol\\\";\\nimport \\\"../lib/CalcLib.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\nimport \\\"../solady/FixedPointMathLib.sol\\\";\\n\\nlibrary FightLib {\\n  using PackingLib for bytes32;\\n  using CalcLib for int32;\\n\\n  //region ------------------------ Data types\\n  struct AttackResult {\\n    int32 defenderHealth;\\n    int32 damage;\\n    int32 lifeStolen;\\n    int32 reflectDamage;\\n    uint8 critical;\\n    uint8 missed;\\n    uint8 blocked;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Constants\\n  uint internal constant MAX_FIGHT_CYCLES = 100;\\n  int32 internal constant RESISTANCE_DENOMINATOR = 100;\\n  int32 internal constant _MAX_RESIST = 90;\\n\\n  /// @notice SIP-002 constant: desired capacity\\n  uint internal constant CAPACITY_RESISTS_DEFS = 90;\\n  /// @notice SIP-002 constant: desired capacity\\n  uint internal constant CAPACITY_CRITICAL_HIT_STATUSES = 100;\\n  /// @notice SIP-002 constant: the factor of how fast the value will reach the capacity\\n  uint internal constant K_FACTOR = 100;\\n  /// @notice ln(2), decimals 18\\n  int internal constant LN2 = 693147180559945309;\\n\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Main logic\\n\\n  /// @dev Items ownership must be checked before\\n  ///      it is no write actions but we need to emit an event for properly handle the battle on UI\\n  ///      return huge structs more expensive that call an event here\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests\\n  function fight(\\n    IItemController ic,\\n    IFightCalculator.FightCall memory callData,\\n    address msgSender,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (\\n    IFightCalculator.FightResult memory\\n  ) {\\n    IFightCalculator.FightInfoInternal memory fResult = prepareFightInternalInfo(ic, callData.fighterA, callData.fighterB);\\n\\n    fightProcessing(fResult, random_);\\n\\n    emit IApplicationEvents.FightResultProcessed(msgSender, fResult, callData, callData.iteration);\\n\\n    return IFightCalculator.FightResult({\\n      healthA: fResult.fighterA.health,\\n      healthB: fResult.fighterB.health,\\n      manaConsumedA: fResult.fighterA.manaConsumed,\\n      manaConsumedB: fResult.fighterB.manaConsumed\\n    });\\n  }\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ High level of internal logic\\n  function fightProcessing(\\n    IFightCalculator.FightInfoInternal memory fResult,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n\\n    bool firstA = calcFirstHit(fResult);\\n\\n    setStatuses(fResult, firstA, random_);\\n    setStatuses(fResult, !firstA, random_);\\n\\n    reduceAttributesByStatuses(fResult.fighterA.info.fighterAttributes, fResult.fighterA.statuses, fResult.fighterB.info.fighterAttributes);\\n    reduceAttributesByStatuses(fResult.fighterB.info.fighterAttributes, fResult.fighterB.statuses, fResult.fighterA.info.fighterAttributes);\\n\\n    AttackResult memory resultA = processAttack(fResult, true, random_);\\n    AttackResult memory resultB = processAttack(fResult, false, random_);\\n\\n    fResult.fighterA.statuses.gotCriticalHit = resultA.critical != 0;\\n    fResult.fighterA.statuses.missed = resultA.missed != 0;\\n    fResult.fighterA.statuses.hitBlocked = resultA.blocked != 0;\\n\\n    fResult.fighterB.statuses.gotCriticalHit = resultB.critical != 0;\\n    fResult.fighterB.statuses.missed = resultB.missed != 0;\\n    fResult.fighterB.statuses.hitBlocked = resultB.blocked != 0;\\n\\n    reduceHp(\\n      firstA ? resultA : resultB,\\n      firstA ? resultB : resultA,\\n      firstA ? fResult.fighterA : fResult.fighterB,\\n      firstA ? fResult.fighterB : fResult.fighterA\\n    );\\n\\n    // restore health from stolen life\\n    stealLife(fResult.fighterA, resultA);\\n    stealLife(fResult.fighterB, resultB);\\n  }\\n\\n  function processAttack(\\n    IFightCalculator.FightInfoInternal memory fResult,\\n    bool isA,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (AttackResult memory attackResult) {\\n\\n    int32 defenderHealth = isA ? fResult.fighterB.health : fResult.fighterA.health;\\n\\n    if (skipTurn(fResult, isA)) {\\n      return AttackResult({\\n        defenderHealth: defenderHealth,\\n        damage: 0,\\n        lifeStolen: 0,\\n        reflectDamage: 0,\\n        critical: 0,\\n        missed: 0,\\n        blocked: 0\\n      });\\n    }\\n\\n    IFightCalculator.FighterInfo memory attackerInfo = isA ? fResult.fighterA.info : fResult.fighterB.info;\\n    IFightCalculator.FighterInfo memory defenderInfo = isA ? fResult.fighterB.info : fResult.fighterA.info;\\n\\n    if (attackerInfo.attackType == IFightCalculator.AttackType.MELEE) {\\n      attackResult = meleeDamageCalculation(attackerInfo, defenderInfo, defenderHealth, random_);\\n    } else if (attackerInfo.attackType == IFightCalculator.AttackType.MAGIC) {\\n      attackResult = magicDamageCalculation(\\n        attackerInfo,\\n        defenderInfo,\\n        isA ? fResult.fighterA.magicAttack : fResult.fighterB.magicAttack,\\n        defenderHealth,\\n        random_\\n      );\\n    } else {\\n      revert IAppErrors.NotAType(uint(attackerInfo.attackType));\\n    }\\n  }\\n  //endregion ------------------------ High level of internal logic\\n\\n  //region ------------------------ Internal logic\\n  function prepareFightInternalInfo(\\n    IItemController ic,\\n    IFightCalculator.FighterInfo memory fighterA,\\n    IFightCalculator.FighterInfo memory fighterB\\n  ) internal view returns (IFightCalculator.FightInfoInternal memory) {\\n    IFightCalculator.FightInfoInternal memory fInfo;\\n    _setFightData(ic, fighterA, fInfo.fighterA);\\n    _setFightData(ic, fighterB, fInfo.fighterB);\\n    return fInfo;\\n  }\\n\\n  /// @dev A part of prepareFightInternalInfo\\n  function _setFightData(\\n    IItemController ic,\\n    IFightCalculator.FighterInfo memory fighter,\\n    IFightCalculator.Fighter memory dest\\n  ) internal view {\\n    dest.info = fighter;\\n    dest.health = int32(fighter.fighterStats.life);\\n    if (fighter.attackToken != address(0)) {\\n      if (fighter.attackType != IFightCalculator.AttackType.MAGIC) revert IAppErrors.NotMagic();\\n      dest.magicAttack = ic.itemAttackInfo(fighter.attackToken, fighter.attackTokenId);\\n    }\\n    // dest.manaConsumed is 0 by default, in current implementation we don't need to change it\\n  }\\n\\n  /// @param random_ Either _pseudoRandom or pseudo-random for ut\\n  function statusChance(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IItemController.AttackInfo memory attackerMA,\\n    IStatController.ATTRIBUTES index,\\n    int32 resist,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (bool) {\\n    int32 chance = _getChance(attackerInfo, attackerMA.aType, index, resist);\\n    if (chance == 0) {\\n      return false;\\n    }\\n    if (chance >= RESISTANCE_DENOMINATOR) {\\n      return true;\\n    }\\n    return random_(RESISTANCE_DENOMINATOR.toUint()) < chance.toUint();\\n  }\\n\\n  /// @notice set fResult.fighterB.statuses (for isA = true) or fResult.fighterA.statuses (for isA = false)\\n  /// @param random_ Either _pseudoRandom or pseudo-random for ut\\n  function setStatuses(\\n    IFightCalculator.FightInfoInternal memory fResult,\\n    bool isA,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    // setStatuses is called twice one by one: first time for A, second time for B\\n    // if stun is set for A, setStatuses is skipped for B completely\\n    if (!skipTurn(fResult, isA)) {\\n      IFightCalculator.FighterInfo memory attackerInfo = isA ? fResult.fighterA.info : fResult.fighterB.info;\\n      IFightCalculator.FighterInfo memory defenderInfo = isA ? fResult.fighterB.info : fResult.fighterA.info;\\n\\n      IItemController.AttackInfo memory attackerMA = isA ? fResult.fighterA.magicAttack : fResult.fighterB.magicAttack;\\n\\n      IFightCalculator.Statuses memory statuses = isA ? fResult.fighterB.statuses : fResult.fighterA.statuses;\\n\\n      int32 resist = _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.RESIST_TO_STATUSES);\\n\\n      statuses.stun = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.STUN, resist, random_);\\n      statuses.burn = statusChance(\\n        attackerInfo,\\n        attackerMA,\\n        IStatController.ATTRIBUTES.BURN,\\n        _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.FIRE_RESISTANCE),\\n        random_\\n      );\\n      statuses.freeze = statusChance(\\n        attackerInfo,\\n        attackerMA,\\n        IStatController.ATTRIBUTES.FREEZE,\\n        _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.COLD_RESISTANCE),\\n        random_\\n      );\\n      statuses.confuse = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.CONFUSE, resist, random_);\\n      statuses.curse = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.CURSE, resist, random_);\\n      statuses.poison = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.POISON, resist, random_);\\n    }\\n  }\\n\\n  function magicDamageCalculation(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IFightCalculator.FighterInfo memory defenderInfo,\\n    IItemController.AttackInfo memory magicAttack,\\n    int32 defenderHealth,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (AttackResult memory attackResult) {\\n    // generate damage\\n    int32 damage = getMagicDamage(\\n      attackerInfo,\\n      magicAttack,\\n      CalcLib.pseudoRandomInRangeFlex(magicAttack.min.toUint(), magicAttack.max.toUint(), random_)\\n    );\\n    damage = increaseMagicDmgByFactor(damage, attackerInfo, magicAttack.aType);\\n    damage = increaseRaceDmg(damage, attackerInfo, defenderInfo.race);\\n    bool critical = isCriticalHit(attackerInfo, random_(RESISTANCE_DENOMINATOR.toUint()));\\n    damage = critical ? damage * 2 : damage;\\n\\n    // decrease damage\\n    damage = decreaseRaceDmg(damage, defenderInfo, attackerInfo.race);\\n    damage = decreaseDmgByDmgReduction(damage, defenderInfo);\\n\\n    if (magicAttack.aType == IItemController.AttackType.FIRE) {\\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.FIRE_RESISTANCE);\\n    } else if (magicAttack.aType == IItemController.AttackType.COLD) {\\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.COLD_RESISTANCE);\\n    } else if (magicAttack.aType == IItemController.AttackType.LIGHTNING) {\\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE);\\n    }\\n\\n    int32 defenderHealthResult = defenderHealth < damage ? int32(0) : defenderHealth - damage;\\n    damage = defenderHealth - defenderHealthResult;\\n\\n    return AttackResult({\\n      defenderHealth: defenderHealthResult,\\n      damage: damage,\\n      lifeStolen: lifeStolenPerHit(damage, attackerInfo),\\n      reflectDamage: reflectMagicDmg(damage, defenderInfo) + reflectChaos(magicAttack, attackerInfo, random_(1e18)),\\n      critical: critical ? uint8(1) : uint8(0),\\n      missed: 0,\\n      blocked: 0\\n    });\\n  }\\n\\n  function meleeDamageCalculation(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IFightCalculator.FighterInfo memory defenderInfo,\\n    int32 defenderHealth,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (AttackResult memory attackResult) {\\n    attackResult = (new AttackResult[](1))[0];\\n\\n    // generate damage\\n    int32 damage = getDamage(attackerInfo.fighterAttributes, random_);\\n    damage = increaseMeleeDmgByFactor(damage, attackerInfo);\\n    damage = increaseRaceDmg(damage, attackerInfo, defenderInfo.race);\\n    attackResult.critical = isCriticalHit(attackerInfo, random_(RESISTANCE_DENOMINATOR.toUint())) ? uint8(1) : uint8(0);\\n    damage = attackResult.critical == 0 ? damage : damage * 2;\\n\\n    // decrease damage\\n    damage = decreaseRaceDmg(damage, defenderInfo, attackerInfo.race);\\n    damage = decreaseDmgByDmgReduction(damage, defenderInfo);\\n\\n    attackResult.missed = random_(1e18) > StatLib.chanceToHit(\\n      _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.ATTACK_RATING).toUint(),\\n      _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.DEFENSE).toUint(),\\n      attackerInfo.fighterStats.level,\\n      defenderInfo.fighterStats.level,\\n      _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.AR_FACTOR).toUint()\\n    ) ? 1 : 0;\\n\\n    attackResult.blocked = (random_(100) < _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.BLOCK_RATING).toUint()) ? 1 : 0;\\n\\n    if (attackResult.missed != 0 || attackResult.blocked != 0) {\\n      damage = 0;\\n    }\\n\\n    int32 defenderHealthResult = defenderHealth <= damage ? int32(0) : defenderHealth - damage;\\n    damage = defenderHealth - defenderHealthResult;\\n\\n\\n    attackResult.defenderHealth = defenderHealthResult;\\n    attackResult.damage = damage;\\n    attackResult.lifeStolen = lifeStolenPerHit(damage, attackerInfo);\\n    attackResult.reflectDamage = reflectMeleeDmg(damage, defenderInfo);\\n  }\\n\\n  function getDamage(\\n    int32[] memory attributes,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (int32) {\\n    return int32(int(CalcLib.pseudoRandomInRangeFlex(\\n      _getAttrValue(attributes, IStatController.ATTRIBUTES.DAMAGE_MIN).toUint(),\\n      _getAttrValue(attributes, IStatController.ATTRIBUTES.DAMAGE_MAX).toUint(),\\n      random_\\n    )));\\n  }\\n\\n  //endregion ------------------------ Internal logic\\n\\n  //region ------------------------ Pure utils\\n\\n  /// @notice Modify values in {targetAttributes} and {casterAttributes} according to {statuses}\\n  function reduceAttributesByStatuses(\\n    int32[] memory targetAttributes,\\n    IFightCalculator.Statuses memory statuses,\\n    int32[] memory casterAttributes\\n  ) internal pure {\\n\\n    if (statuses.burn) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.DEFENSE)] -= (targetAttributes[uint(IStatController.ATTRIBUTES.DEFENSE)] / 3);\\n      targetAttributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)] += 50;\\n      casterAttributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)] += 10;\\n      casterAttributes[uint(IStatController.ATTRIBUTES.DESTROY_ITEMS)] += 20;\\n    }\\n    if (statuses.freeze) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] -= targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] / 3;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)] += 50;\\n    }\\n    if (statuses.confuse) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] /= 2;\\n    }\\n    if (statuses.curse) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE)] /= 2;\\n    }\\n    if (statuses.stun) {\\n      casterAttributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)] += 10;\\n    }\\n    if (statuses.poison) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] /= 2;\\n    }\\n\\n  }\\n\\n  /// @notice Calculate new damage value depending on {defenderRace} and value of corresponded DMG_AGAINST_XXX attribute\\n  /// @param defenderRace See IStatController.Race\\n  /// @return Updated damage value\\n  function increaseRaceDmg(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo, uint defenderRace)\\n  internal pure returns (int32) {\\n    if (defenderRace == uint(IStatController.Race.HUMAN)) {\\n      return dmg + _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.DMG_AGAINST_HUMAN) * dmg / RESISTANCE_DENOMINATOR;\\n    } else if (defenderRace == uint(IStatController.Race.UNDEAD)) {\\n      return dmg + _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.DMG_AGAINST_UNDEAD) * dmg / RESISTANCE_DENOMINATOR;\\n    } else if (defenderRace == uint(IStatController.Race.DAEMON)) {\\n      return dmg + _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.DMG_AGAINST_DAEMON) * dmg / RESISTANCE_DENOMINATOR;\\n    } else if (defenderRace == uint(IStatController.Race.BEAST)) {\\n      return dmg + _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.DMG_AGAINST_BEAST) * dmg / RESISTANCE_DENOMINATOR;\\n    } else {\\n      return dmg;\\n    }\\n  }\\n\\n  /// @notice Decrease damage depending on {attackerRace}\\n  function decreaseRaceDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo, uint attackerRace) internal pure returns (int32) {\\n    if (attackerRace == uint(IStatController.Race.HUMAN)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_HUMAN);\\n    } else if (attackerRace == uint(IStatController.Race.UNDEAD)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_UNDEAD);\\n    } else if (attackerRace == uint(IStatController.Race.DAEMON)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_DAEMON);\\n    } else if (attackerRace == uint(IStatController.Race.BEAST)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_BEAST);\\n    } else {\\n      return dmg;\\n    }\\n  }\\n\\n  /// @notice Calculate damage after Melee-attack\\n  function increaseMeleeDmgByFactor(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo) internal pure returns (int32){\\n    return dmg + _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.MELEE_DMG_FACTOR) * dmg / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  /// @notice Calculate damage after Magic-attack\\n  function increaseMagicDmgByFactor(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo, IItemController.AttackType aType) internal pure returns (int32) {\\n    if (aType == IItemController.AttackType.FIRE) {\\n      return dmg + dmg * _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.FIRE_DMG_FACTOR) / RESISTANCE_DENOMINATOR;\\n    } else if (aType == IItemController.AttackType.COLD) {\\n      return dmg + dmg * _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.COLD_DMG_FACTOR) / RESISTANCE_DENOMINATOR;\\n    } else if (aType == IItemController.AttackType.LIGHTNING) {\\n      return dmg + dmg * _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.LIGHTNING_DMG_FACTOR) / RESISTANCE_DENOMINATOR;\\n    } else {\\n      return dmg;\\n    }\\n  }\\n\\n  /// @notice Reduce damage depending on value of Damage Reduction attribute\\n  function decreaseDmgByDmgReduction(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\\n    return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DAMAGE_REDUCTION);\\n  }\\n\\n  /// @notice Calculate poison damage < {health}\\n  function poisonDmg(int32 health, IFightCalculator.Statuses memory statuses) internal pure returns (int32) {\\n    // poison should not kill\\n    if (statuses.poison && health.toUint() > 1) {\\n      // at least 1 dmg\\n      return int32(int(Math.max(health.toUint() / 10, 1)));\\n    }\\n    return 0;\\n  }\\n\\n  /// @notice Reduce health of the fighters according to attacks results, calc damagePoison, damage and damageReflect.\\n  function reduceHp(\\n    AttackResult memory firstAttack,\\n    AttackResult memory secondAttack,\\n    IFightCalculator.Fighter memory firstFighter,\\n    IFightCalculator.Fighter memory secondFighter\\n  ) internal pure {\\n    secondFighter.health = firstAttack.defenderHealth;\\n    firstFighter.damage = firstAttack.damage;\\n\\n    // hit only if second fighter survived\\n    if (secondFighter.health != 0) {\\n      firstFighter.health = secondAttack.defenderHealth;\\n      secondFighter.damage = secondAttack.damage;\\n\\n      // reflect damage from second to first\\n      secondFighter.damageReflect = (CalcLib.minI32(firstAttack.reflectDamage, firstFighter.health));\\n      firstFighter.health -= secondFighter.damageReflect;\\n\\n      // reflect damage from first to second\\n      firstFighter.damageReflect = (CalcLib.minI32(secondAttack.reflectDamage, secondFighter.health));\\n      secondFighter.health -= firstFighter.damageReflect;\\n    }\\n\\n    // poison second firstly (he got damage and statuses early)\\n    firstFighter.damagePoison = poisonDmg(secondFighter.health, secondFighter.statuses);\\n    secondFighter.health -= firstFighter.damagePoison;\\n\\n    // poison first fighter\\n    secondFighter.damagePoison = poisonDmg(firstFighter.health, firstFighter.statuses);\\n    firstFighter.health -= secondFighter.damagePoison;\\n  }\\n\\n  /// @notice Calculate life-stolen-per-hit value for the given {damage} value\\n  function lifeStolenPerHit(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo) internal pure returns (int32) {\\n    return dmg * _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.LIFE_STOLEN_PER_HIT) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  /// @notice Increase {fighter.health} on the value of life-stolen-per-hit (only if the health > 0)\\n  function stealLife(IFightCalculator.Fighter memory fighter, AttackResult memory attackResult) internal pure {\\n    if (fighter.health != 0) {\\n      int32 newHealth = fighter.health + attackResult.lifeStolen;\\n      int32 maxHealth = _getAttrValue(fighter.info.fighterAttributes, IStatController.ATTRIBUTES.LIFE);\\n      fighter.health = (CalcLib.minI32(newHealth, maxHealth));\\n    }\\n  }\\n\\n  function skipTurn(IFightCalculator.FightInfoInternal memory fResult, bool isA) internal pure returns (bool) {\\n    return isA ? fResult.fighterA.statuses.stun : fResult.fighterB.statuses.stun;\\n  }\\n\\n  /// @notice Detect which hero is faster and makes the hit first. Magic is faster melee.\\n  /// Otherwise first hit is made by the fighter with higher attack rating (A is selected if the ratings are equal)\\n  function calcFirstHit(IFightCalculator.FightInfoInternal memory fInfo) internal pure returns (bool aFirst){\\n    if (fInfo.fighterA.info.attackType == IFightCalculator.AttackType.MAGIC) {\\n      if (fInfo.fighterB.info.attackType == IFightCalculator.AttackType.MAGIC) {\\n        // if both fighters use magic we check attack rating\\n        aFirst = isAttackerFaster(fInfo.fighterA.info, fInfo.fighterB.info);\\n      } else {\\n        // otherwise, magic always faster than melee\\n        aFirst = true;\\n      }\\n    } else {\\n      if (fInfo.fighterB.info.attackType == IFightCalculator.AttackType.MAGIC) {\\n        // if fighter use magic he will be faster\\n        aFirst = false;\\n      } else {\\n        // otherwise, check attack rating\\n        aFirst = isAttackerFaster(fInfo.fighterA.info, fInfo.fighterB.info);\\n      }\\n    }\\n  }\\n\\n  function isAttackerFaster(\\n    IFightCalculator.FighterInfo memory fighterAInfo,\\n    IFightCalculator.FighterInfo memory fighterBInfo\\n  ) internal pure returns (bool) {\\n    return _getAttrValue(fighterAInfo.fighterAttributes, IStatController.ATTRIBUTES.ATTACK_RATING)\\n      >= _getAttrValue(fighterBInfo.fighterAttributes, IStatController.ATTRIBUTES.ATTACK_RATING);\\n  }\\n\\n  function reflectMeleeDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\\n    return dmg * _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.REFLECT_DAMAGE_MELEE) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  function reflectMagicDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\\n    return dmg * _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.REFLECT_DAMAGE_MAGIC) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  function _getChance(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IItemController.AttackType aType,\\n    IStatController.ATTRIBUTES index,\\n    int32 resist\\n  ) internal pure returns (int32 chance) {\\n    int32 chanceBase = attackerInfo.fighterAttributes[uint(index)];\\n\\n    if (attackerInfo.attackType == IFightCalculator.AttackType.MAGIC) {\\n      if (index == IStatController.ATTRIBUTES.BURN && aType == IItemController.AttackType.FIRE) {\\n        chanceBase += int32(20);\\n      }\\n      if (index == IStatController.ATTRIBUTES.FREEZE && aType == IItemController.AttackType.COLD) {\\n        chanceBase += int32(20);\\n      }\\n      if (index == IStatController.ATTRIBUTES.CONFUSE && aType == IItemController.AttackType.LIGHTNING) {\\n        chanceBase += int32(20);\\n      }\\n    }\\n\\n    chance = _getAdjustedAttributeValue(chanceBase, index);\\n\\n    return chance - chance * (CalcLib.minI32(resist, _MAX_RESIST)) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  /// @param randomValue Result of call _pseudoRandom, value in the range [0...RESISTANCE_DENOMINATOR)\\n  function isCriticalHit(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    uint randomValue\\n  ) internal pure returns (bool) {\\n    return randomValue < _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.CRITICAL_HIT).toUint();\\n  }\\n\\n  /// @param randomValue Result of call CalcLib.pseudoRandom(1e18)\\n  function reflectChaos(\\n    IItemController.AttackInfo memory magicAttack,\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    uint randomValue\\n  ) internal pure returns (int32) {\\n    return (magicAttack.aType == IItemController.AttackType.CHAOS && randomValue > 5e17)\\n      ? int32(attackerInfo.fighterStats.life) / int32(2)\\n      : int32(0);\\n  }\\n\\n  function _calcDmgInline(int32 dmg, IFightCalculator.FighterInfo memory info, IStatController.ATTRIBUTES index) internal pure returns (int32) {\\n    return dmg * (CalcLib.minI32(_getAttrValue(info.fighterAttributes, index), _MAX_RESIST)) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  function getMagicDamage(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IItemController.AttackInfo memory mAttack,\\n    uint randomValue_\\n  ) internal pure returns (int32) {\\n\\n    int32 attributeFactorResult = (_getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.STRENGTH) * mAttack.attributeFactors.strength / 100);\\n    attributeFactorResult += (_getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.DEXTERITY) * mAttack.attributeFactors.dexterity / 100);\\n    attributeFactorResult += (_getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.VITALITY) * mAttack.attributeFactors.vitality / 100);\\n    attributeFactorResult += (_getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.ENERGY) * mAttack.attributeFactors.energy / 100);\\n\\n    return int32(int(randomValue_)) + attributeFactorResult;\\n  }\\n  //endregion ------------------------ Pure utils\\n\\n  //region ------------------------ SIP-002\\n\\n  /// @notice SIP-002: Implement smooth increase that approaches to y0 but never reaches that value\\n  /// @dev https://discord.com/channels/1134537718039318608/1265261881652674631\\n  /// @param y0 is desired capacity, 90 for resists/defs, 100 for critical hit and statuses\\n  /// @param x current value, base attribute. Assume x >= 0\\n  /// @param k is the factor of how fast the value will reach 90 capacity, k=100 by default\\n  /// @return new attribute value that is used in calculations, decimals 18\\n  function getReducedValue(uint y0, uint x, uint k) internal pure returns (uint) {\\n    // 2^n = exp(ln(2^n)) = exp(n * ln2)\\n    int t = FixedPointMathLib.expWad(-int(x) * LN2 / int(k));\\n    return t < 0\\n      ? 0 // some mistake happens (???)\\n      : y0 * (1e18 - uint(t));\\n  }\\n\\n  /// @notice Apply {getReducedValue} to the given attribute, change value in place\\n  function _getAdjustedValue(int32 attributeValue, uint y0, uint k) internal pure returns (int32) {\\n    return attributeValue <= 0\\n      ? int32(0) // negative values => 0\\n      : int32(int(getReducedValue(y0, uint(int(attributeValue)), k) / 1e18));\\n  }\\n\\n  /// @notice Return adjusted attribute value. Adjust selected attributes using y=z(1\\u22122^(\\u2212x/k)) formula\\n  /// Value in array {attributes} is NOT changed.\\n  function _getAttrValue(int32[] memory attributes, IStatController.ATTRIBUTES attrId) internal pure returns (int32) {\\n    return _getAdjustedAttributeValue(attributes[uint(attrId)], attrId);\\n  }\\n\\n  function _getAdjustedAttributeValue(int32 value, IStatController.ATTRIBUTES attrId) internal pure returns (int32) {\\n    if (\\n      attrId == IStatController.ATTRIBUTES.BLOCK_RATING\\n      || attrId == IStatController.ATTRIBUTES.FIRE_RESISTANCE\\n      || attrId == IStatController.ATTRIBUTES.COLD_RESISTANCE\\n      || attrId == IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE\\n      || attrId == IStatController.ATTRIBUTES.DEF_AGAINST_HUMAN\\n      || attrId == IStatController.ATTRIBUTES.DEF_AGAINST_UNDEAD\\n      || attrId == IStatController.ATTRIBUTES.DEF_AGAINST_DAEMON\\n      || attrId == IStatController.ATTRIBUTES.DEF_AGAINST_BEAST\\n      || attrId == IStatController.ATTRIBUTES.DAMAGE_REDUCTION\\n      || attrId == IStatController.ATTRIBUTES.RESIST_TO_STATUSES\\n    ) {\\n      // use CAPACITY_RESISTS_DEFS, K_FACTOR\\n      return _getAdjustedValue(value, CAPACITY_RESISTS_DEFS, K_FACTOR);\\n    } else if (\\n      attrId == IStatController.ATTRIBUTES.CRITICAL_HIT\\n      || attrId == IStatController.ATTRIBUTES.STUN\\n      || attrId == IStatController.ATTRIBUTES.BURN\\n      || attrId == IStatController.ATTRIBUTES.FREEZE\\n      || attrId == IStatController.ATTRIBUTES.CONFUSE\\n      || attrId == IStatController.ATTRIBUTES.CURSE\\n      || attrId == IStatController.ATTRIBUTES.POISON\\n    ) {\\n      // use CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR\\n      return _getAdjustedValue(value, CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR);\\n    } else {\\n      return value;\\n    }\\n  }\\n\\n  //endregion ------------------------ SIP-002\\n\\n}\\n\",\"keccak256\":\"0x7ddbd43d187a75f6761d664ff801c59c4039653344495214318333f8d945c5f4\",\"license\":\"BUSL-1.1\"},\"contracts/lib/GOCLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\n\\nlibrary GOCLib {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using PackingLib for address;\\n\\n  /// @param cTypes Array of object subtypes, see IGOC.ObjectSubType.XXX\\n  /// @param chances Chances in range 0-1e9, chances are corresponded to {cTypes} array\\n  function getRandomObject(\\n    IGOC.MainState storage s,\\n    IStoryController sc,\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biome,\\n    address heroToken,\\n    uint heroTokenId\\n  ) internal returns (uint32 objectId) {\\n\\n    uint8 cType = _getObjectType(cTypes, chances, CalcLib.pseudoRandom);\\n\\n    EnumerableSet.UintSet storage objects = s.objectIds[packObjectMeta(biome, cType)];\\n    uint len = objects.length();\\n    if (len == 0) revert IAppErrors.EmptyObjects();\\n    uint objectArrayIdx = len == 1\\n      ? 0\\n      : CalcLib.pseudoRandom(len - 1);\\n\\n    EnumerableSet.UintSet storage played = s.playedObjects[heroToken.packPlayedObjKey(uint64(heroTokenId), cType, biome)];\\n    objectId = _searchObject(sc, len, objects, played, objectArrayIdx, false, heroToken, heroTokenId, cType);\\n\\n    if (objectId == 0) revert IAppErrors.ObjectNotFound();\\n    played.add(objectId);\\n  }\\n\\n  /// @notice Select cType using pseudo-random value according to the given {chances}\\n  /// @param cTypes Zero values are ignored.\\n  /// @param chances [0..100], decimals 9. At least once item should have value 100 to avoid {UnknownObjectType} error.\\n  /// @param random_ CalcLib.pseudoRandom, required for unit tests\\n  function _getObjectType(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint8 cType) {\\n    uint len = cTypes.length;\\n    if (len == 0 || len != chances.length) revert IAppErrors.WrongGetObjectTypeInput();\\n\\n    if (len == 1) {\\n      cType = cTypes[0];\\n    } else {\\n      uint random = random_(CalcLib.MAX_CHANCE);\\n      uint minChance = CalcLib.MAX_CHANCE + 1;\\n      for (uint i; i < len; ++i) {\\n        // obj set can contain empty values, ignore them\\n        if (cTypes[i] == 0) continue;\\n        if (chances[i] > CalcLib.MAX_CHANCE) revert IAppErrors.WrongChances(chances[i], CalcLib.MAX_CHANCE);\\n        if ((CalcLib.MAX_CHANCE - chances[i]) <= random) {\\n          if (chances[i] < minChance) {\\n            minChance = chances[i];\\n            cType = cTypes[i];\\n          }\\n        }\\n      }\\n    }\\n\\n    if (cType == 0) revert IAppErrors.UnknownObjectTypeGoc1(0);\\n    return cType;\\n  }\\n\\n  /// @notice Find first object in {objects} available for the hero starting from {objArrayIdx}\\n  /// If object not found clear {played} and try to search again.\\n  /// @param lenObjects Length of {objects}\\n  /// @param objArrayIdx Start index in objects\\n  /// @param cType Object subtype\\n  /// @param skipPlayed true - don't check if the found object was already played\\n  /// @return objectId ID of the found object or 0 if the object is not found\\n  function _searchObject(\\n    IStoryController sc,\\n    uint lenObjects,\\n    EnumerableSet.UintSet storage objects,\\n    EnumerableSet.UintSet storage played,\\n    uint objArrayIdx,\\n    bool skipPlayed,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 cType\\n  ) internal returns (uint32 objectId) {\\n\\n    // clear played objects if we played them all at the current biome\\n    if (played.length() >= lenObjects) {\\n      skipPlayed = true;\\n      _clearPlayedObjects(played);\\n    }\\n\\n    bool foundValid;\\n\\n    unchecked {\\n    // search in a loop available objects\\n      for (uint i; i < lenObjects; ++i) {\\n        if (objArrayIdx >= lenObjects) {\\n          objArrayIdx = 0;\\n        }\\n        uint32 objId = uint32(objects.at(objArrayIdx));\\n        if (\\n          isAvailableForHero(sc, objId, cType, heroToken, heroTokenId)\\n          && (skipPlayed || !played.contains(objId))\\n        ) {\\n          foundValid = true;\\n          objectId = objId;\\n          break;\\n        }\\n\\n        ++objArrayIdx;\\n      }\\n    }\\n    // in case when we do not have available objects it is possible they are not eligible and need to reset counter\\n    if (!foundValid && !skipPlayed) {\\n      _clearPlayedObjects(played);\\n      objectId = _searchObject(sc, lenObjects, objects, played, objArrayIdx, true, heroToken, heroTokenId, cType);\\n    }\\n\\n    return objectId;\\n  }\\n\\n  function _clearPlayedObjects(EnumerableSet.UintSet storage played) internal {\\n    uint[] memory values = played.values();\\n    for (uint i; i < values.length; ++i) {\\n      played.remove(values[i]);\\n    }\\n  }\\n\\n  /// @notice Check if the object subtype is available for the hero\\n  function isAvailableForHero(IStoryController sc, uint32 objId, uint8 objectSubType, address hero, uint heroId) internal view returns (bool) {\\n    IGOC.ObjectType objType = getObjectTypeBySubType(IGOC.ObjectSubType(objectSubType));\\n    if (objType == IGOC.ObjectType.EVENT) {\\n      // no checks\\n      return true;\\n    } else if (objType == IGOC.ObjectType.MONSTER) {\\n      // no checks\\n      return true;\\n    } else if (objType == IGOC.ObjectType.STORY) {\\n      return sc.isStoryAvailableForHero(objId, hero, heroId);\\n    } else {\\n      // actually, this case is impossible, getObjectTypeBySubType will revert above if objectSubType is incorrect\\n      revert IAppErrors.UnknownObjectTypeForSubtype(objectSubType);\\n    }\\n  }\\n\\n  function packObjectMeta(uint8 biome, uint8 oType) internal pure returns (bytes32) {\\n    return PackingLib.packUint8Array3(biome, oType, 0);\\n  }\\n\\n  function unpackObjectMeta(bytes32 data) internal pure returns (uint8 biome, uint8 oType) {\\n    (biome, oType,) = PackingLib.unpackUint8Array3(data);\\n  }\\n\\n  /// @notice Get object type for the given {subType}\\n  function getObjectTypeBySubType(IGOC.ObjectSubType subType) internal pure returns (IGOC.ObjectType) {\\n    if (\\n      subType == IGOC.ObjectSubType.SHRINE_4\\n      || subType == IGOC.ObjectSubType.CHEST_5\\n      || subType == IGOC.ObjectSubType.SHRINE_UNIQUE_8\\n    ) {\\n      return IGOC.ObjectType.EVENT;\\n    } else if (\\n      subType == IGOC.ObjectSubType.ENEMY_NPC_1\\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_SUPER_RARE_2\\n      || subType == IGOC.ObjectSubType.BOSS_3\\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_UNIQUE_10\\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_INSIDE_32\\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_INSIDE_RARE_33\\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_OUTSIDE_34\\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_OUTSIDE_RARE_35\\n    ) {\\n      return IGOC.ObjectType.MONSTER;\\n    } else if (\\n      subType == IGOC.ObjectSubType.STORY_6\\n      || subType == IGOC.ObjectSubType.STORY_UNIQUE_7\\n      || subType == IGOC.ObjectSubType.STORY_ON_ROAD_11\\n      || subType == IGOC.ObjectSubType.STORY_UNDERGROUND_12\\n      || subType == IGOC.ObjectSubType.STORY_NIGHT_CAMP_13\\n      || subType == IGOC.ObjectSubType.STORY_MOUNTAIN_14\\n      || subType == IGOC.ObjectSubType.STORY_WATER_15\\n      || subType == IGOC.ObjectSubType.STORY_CASTLE_16\\n      || subType == IGOC.ObjectSubType.STORY_HELL_17\\n      || subType == IGOC.ObjectSubType.STORY_SPACE_18\\n      || subType == IGOC.ObjectSubType.STORY_WOOD_19\\n      || subType == IGOC.ObjectSubType.STORY_CATACOMBS_20\\n      || subType == IGOC.ObjectSubType.STORY_BAD_HOUSE_21\\n      || subType == IGOC.ObjectSubType.STORY_GOOD_TOWN_22\\n      || subType == IGOC.ObjectSubType.STORY_BAD_TOWN_23\\n      || subType == IGOC.ObjectSubType.STORY_BANDIT_CAMP_24\\n      || subType == IGOC.ObjectSubType.STORY_BEAST_LAIR_25\\n      || subType == IGOC.ObjectSubType.STORY_PRISON_26\\n      || subType == IGOC.ObjectSubType.STORY_SWAMP_27\\n      || subType == IGOC.ObjectSubType.STORY_INSIDE_28\\n      || subType == IGOC.ObjectSubType.STORY_OUTSIDE_29\\n      || subType == IGOC.ObjectSubType.STORY_INSIDE_RARE_30\\n      || subType == IGOC.ObjectSubType.STORY_OUTSIDE_RARE_31\\n    ) {\\n      return IGOC.ObjectType.STORY;\\n    } else {\\n      revert IAppErrors.UnknownObjectTypeGoc2(uint8(subType));\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xda53ed0a5695ae11e3395b2afc1a6df5b0f16ebb54880773ed448895aa96b9c8\",\"license\":\"BUSL-1.1\"},\"contracts/lib/GameObjectControllerLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../proxy/Controllable.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\nimport \\\"../lib/EventLib.sol\\\";\\nimport \\\"../lib/StoryLib.sol\\\";\\nimport \\\"../lib/MonsterLib.sol\\\";\\nimport \\\"../lib/GOCLib.sol\\\";\\n\\ninterface ArbSys {\\n  function arbBlockNumber() external view returns (uint256);\\n}\\n\\nlibrary GameObjectControllerLib {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using PackingLib for bytes32;\\n  using PackingLib for uint16;\\n  using PackingLib for uint8;\\n  using PackingLib for address;\\n  using PackingLib for uint32[];\\n  using PackingLib for uint32;\\n  using PackingLib for uint64;\\n  using PackingLib for int32[];\\n  using PackingLib for int32;\\n\\n  //region ------------------------ CONSTANTS\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"game.object.controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0xfa9e067a92ca4a9057b7b4465a8f29d633e1758238bd3a4a8ec5d0f904f6b900;\\n  //endregion ------------------------ CONSTANTS\\n\\n  //region ------------------------ RESTRICTIONS\\n\\n  function onlyDeployer(IController controller) internal view {\\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n\\n  function onlyDungeonFactory(IController c) internal view {\\n    if (c.dungeonFactory() != msg.sender) revert IAppErrors.ErrorNotDungeonFactory(msg.sender);\\n  }\\n  //endregion ------------------------ RESTRICTIONS\\n\\n  //region ------------------------ VIEWS\\n\\n  function _S() internal pure returns (IGOC.MainState storage s) {\\n    assembly {\\n      s.slot := MAIN_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n\\n  function getObjectMeta(uint32 objectId) internal view returns (uint8 biome, uint8 objectSubType) {\\n    return GOCLib.unpackObjectMeta(_S().objectMeta[objectId]);\\n  }\\n\\n  function isAvailableForHero(IController controller, address heroToken, uint heroTokenId, uint32 objId) internal view returns (bool) {\\n    (, uint8 objectSubType) = getObjectMeta(objId);\\n    return GOCLib.isAvailableForHero(IStoryController(controller.storyController()), objId, objectSubType, heroToken, heroTokenId);\\n  }\\n\\n  function isBattleObject(uint32 objectId) internal view returns (bool) {\\n    (,uint8 objectSubType) = GOCLib.unpackObjectMeta(_S().objectMeta[objectId]);\\n    return GOCLib.getObjectTypeBySubType(IGOC.ObjectSubType(objectSubType)) == IGOC.ObjectType.MONSTER;\\n  }\\n\\n  function getObjectTypeBySubType(uint32 objectId) internal view returns (IGOC.ObjectType) {\\n    (,uint8 objectSubType) = GOCLib.unpackObjectMeta(_S().objectMeta[objectId]);\\n    return GOCLib.getObjectTypeBySubType(IGOC.ObjectSubType(objectSubType));\\n  }\\n\\n  function getMonsterInfo(address hero, uint heroId, uint32 objectId) internal view returns (IGOC.MonsterGenInfo memory mGenInfo, IGOC.GeneratedMonster memory gen) {\\n    uint iteration = _S().iterations[hero.packIterationKey(uint64(heroId), objectId)];\\n    mGenInfo = MonsterLib.unpackMonsterInfo(_S().monsterInfos[objectId]);\\n    gen = MonsterLib.unpackGeneratedMonster(_S().monsterInfos[objectId]._generatedMonsters[hero.packNftId(heroId)][iteration]);\\n  }\\n\\n  function getIteration(address heroToken, uint heroTokenId, uint32 objId) internal view returns (uint) {\\n    return _S().iterations[_iterationKey(heroToken, heroTokenId, objId)];\\n  }\\n\\n  function getLastHeroFightTs(address heroToken, uint heroTokenId) internal view returns (uint) {\\n    return _S().lastHeroFightTs[heroToken.packNftId(heroTokenId)];\\n  }\\n\\n  function getFightDelay() internal view returns (uint) {\\n    return _S().fightDelay;\\n  }\\n\\n  function getStoryId(uint32 objectId) internal view returns (uint16) {\\n    return _S().storyIds[objectId];\\n  }\\n\\n  function getEventInfo(uint32 objectId) internal view returns (IGOC.EventInfo memory) {\\n    return _S().eventInfos[objectId];\\n  }\\n\\n  function getObjectIds(uint8 biome, IGOC.ObjectSubType subType) internal view returns (uint[] memory) {\\n    return _S().objectIds[GOCLib.packObjectMeta(biome, uint8(subType))].values();\\n  }\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ REGISTRATION\\n\\n  function registerEvent(IController controller, IGOC.EventRegInfo memory regInfo) internal {\\n    onlyDeployer(controller);\\n    _checkMintItems(regInfo.mintItems, regInfo.mintItemsChances);\\n    uint32 objectId = _registerMetaId(regInfo.biome, regInfo.subType, regInfo.eventId);\\n    EventLib.eventRegInfoToInfo(regInfo, _S().eventInfos[objectId]);\\n    emit IApplicationEvents.EventRegistered(objectId, regInfo);\\n  }\\n\\n  function registerStory(IController controller, uint16 storyId, uint8 biome, IGOC.ObjectSubType subType) internal {\\n    onlyDeployer(controller);\\n    uint32 objectId = _registerMetaId(biome, subType, storyId);\\n    _S().storyIds[objectId] = storyId;\\n    emit IApplicationEvents.StoryRegistered(objectId, storyId);\\n  }\\n\\n  function registerMonster(IController controller, IGOC.MonsterGenInfo memory monsterGenInfo) internal {\\n    onlyDeployer(controller);\\n    _checkMintItems(monsterGenInfo.mintItems, monsterGenInfo.mintItemsChances);\\n    uint32 objectId = _registerMetaId(monsterGenInfo.biome, monsterGenInfo.subType, monsterGenInfo.monsterId);\\n\\n    delete _S().monsterInfos[objectId];\\n\\n    MonsterLib.packMonsterInfo(monsterGenInfo, _S().monsterInfos[objectId]);\\n    emit IApplicationEvents.MonsterRegistered(objectId, monsterGenInfo);\\n  }\\n\\n  function removeObject(IController controller, uint32 objectId) internal {\\n    onlyDeployer(controller);\\n    bytes32 meta = _S().objectMeta[objectId];\\n    delete _S().objectMeta[objectId];\\n    _S().objectIds[meta].remove(objectId);\\n\\n    emit IApplicationEvents.ObjectRemoved(objectId);\\n  }\\n  //endregion ------------------------ REGISTRATION\\n\\n  //region ------------------------ OBJECT ACTIONS\\n\\n  /// @param cTypes Array of object subtypes, see IGOC.ObjectSubType.XXX\\n  /// @param chances Chances in range 0-1e9, chances are corresponded to {cTypes} array\\n  function getRandomObject(\\n    IController c,\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biome,\\n    address heroToken,\\n    uint heroTokenId\\n  ) internal returns (uint32 objectId) {\\n    onlyDungeonFactory(c);\\n    return GOCLib.getRandomObject(\\n      _S(),\\n      IStoryController(c.storyController()),\\n      cTypes,\\n      chances,\\n      biome,\\n      heroToken,\\n      heroTokenId\\n    );\\n  }\\n\\n  /// @notice Open {object}: increase iteration, [generate monsters]\\n  function open(IController c, address heroToken, uint heroTokenId, uint32 objectId) internal returns (uint iteration) {\\n    onlyDungeonFactory(c);\\n\\n    iteration = _increaseIteration(heroToken, heroTokenId, objectId);\\n\\n    (, uint8 objectSubType) = getObjectMeta(objectId);\\n    IHeroController.HeroInfo memory heroInfo = IHeroController(c.heroController()).getHeroInfo(heroToken, heroTokenId);\\n    uint8 t = uint8(GOCLib.getObjectTypeBySubType(IGOC.ObjectSubType(objectSubType)));\\n\\n    if (t == uint8(IGOC.ObjectType.EVENT)) {\\n      // noop\\n    } else if (t == uint8(IGOC.ObjectType.MONSTER)) {\\n      MonsterLib.initialGeneration(\\n        _S().monsterInfos[objectId],\\n        heroToken,\\n        heroTokenId,\\n        iteration,\\n        heroInfo.ngLevel\\n      );\\n    } else if (t == uint8(IGOC.ObjectType.STORY)) {\\n      // noop\\n    } else {\\n      revert IAppErrors.UnknownObjectTypeGocLib1(t);\\n    }\\n  }\\n\\n  /// @notice Execute event/story/monster action\\n  /// @param data Object type-specified data packed using abi.encode.\\n  /// For events: bool (accept / not accept results)\\n  /// For monsters: AttackInfo\\n  /// For story: bytes32 (answer id)\\n  function action(\\n    IController c,\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) internal returns (IGOC.ActionResult memory) {\\n    onlyDungeonFactory(c);\\n\\n    IGOC.ActionContext memory ctx;\\n\\n    ctx.objectId = objectId;\\n    ctx.sender = sender;\\n    ctx.heroToken = heroToken;\\n    ctx.heroTokenId = heroTokenId;\\n    ctx.stageId = stageId;\\n    ctx.data = data;\\n    (ctx.biome, ctx.objectSubType) = getObjectMeta(objectId);\\n    ctx.heroNgLevel = IHeroController(c.heroController()).getHeroInfo(heroToken, heroTokenId).ngLevel;\\n\\n    ctx.dungeonId = dungeonId;\\n    ctx.iteration = _S().iterations[_iterationKey(heroToken, heroTokenId, objectId)];\\n    ctx.controller = c;\\n\\n    IGOC.ActionResult memory r;\\n    uint8 t = uint8(GOCLib.getObjectTypeBySubType(IGOC.ObjectSubType(ctx.objectSubType)));\\n    ctx.salt = block.number;\\n\\n    // for L2 chains need to get correct block number from precompiled contracts\\n    if(block.chainid == uint(111188)) {\\n      ctx.salt = ArbSys(address(100)).arbBlockNumber();\\n    }\\n\\n    if (t == uint8(IGOC.ObjectType.EVENT)) {\\n      r = EventLib.action(ctx, _S().eventInfos[objectId]);\\n    } else if (t == uint8(IGOC.ObjectType.MONSTER)) {\\n      _checkAndRefreshFightTs(heroToken, heroTokenId);\\n      (r, ctx.salt) = MonsterLib.action(ctx, _S().monsterInfos[objectId]);\\n    } else if (t == uint8(IGOC.ObjectType.STORY)) {\\n      r = StoryLib.action(ctx, _S().storyIds[objectId]);\\n    } else {\\n      revert IAppErrors.UnknownObjectTypeGocLib2(t);\\n    }\\n\\n    r.objectId = ctx.objectId;\\n    r.heroToken = heroToken;\\n    r.heroTokenId = heroTokenId;\\n    r.iteration = ctx.iteration;\\n\\n\\n    emit IApplicationEvents.ObjectResultEvent(\\n      dungeonId,\\n      objectId,\\n      IGOC.ObjectType(t),\\n      heroToken,\\n      heroTokenId,\\n      stageId,\\n      ctx.iteration,\\n      data,\\n      r,\\n      ctx.salt\\n    );\\n    return r;\\n  }\\n//endregion ------------------------ OBJECT ACTIONS\\n\\n  //region ------------------------ Utils\\n\\n  /// @notice Generate object ID using (biome, subType, id)\\n  /// @param biome Biome to which the object belongs. [1..99]\\n  /// @param subType Subtype of the object, see IGOC.ObjectSubType.XXX. [1..99]\\n  /// @param id Id of the event / story / monster. [1..10_000]\\n  function _genObjectId(uint8 biome, uint8 subType, uint16 id) internal pure returns (uint32 objectId) {\\n    if (biome == 0 || subType == 0 || id == 0) revert IAppErrors.ZeroValueNotAllowed();\\n    if (biome >= 100) revert IAppErrors.GenObjectIdBiomeOverflow(biome);\\n    if (uint(subType) >= 100) revert IAppErrors.GenObjectIdSubTypeOverflow(subType);\\n    if (id > 10_000) revert IAppErrors.GenObjectIdIdOverflow(id);\\n    objectId = uint32(biome) * 1_000_000 + uint32(subType) * 10_000 + uint32(id);\\n  }\\n\\n  /// @notice Register the object in objectMeta and objectIds\\n  /// @param biome Biome to which the object belongs. [1..99]\\n  /// @param subType Subtype of the object, [1..99]\\n  /// @param id Id of the event / story / monster. [1..10_000]\\n  /// @return objectId Object id generated by {_genObjectId}\\n  function _registerMetaId(uint8 biome, IGOC.ObjectSubType subType, uint16 id) internal returns (uint32 objectId) {\\n    IGOC.MainState storage s = _S();\\n    objectId = _genObjectId(biome, uint8(subType), id);\\n    bytes32 meta = GOCLib.packObjectMeta(biome, uint8(subType));\\n    s.objectMeta[objectId] = meta;\\n    s.objectIds[meta].add(objectId);\\n  }\\n\\n  /// @notice Update last-hero-fight-timestamp\\n  function _checkAndRefreshFightTs(address heroToken, uint heroTokenId) internal {\\n    IGOC.MainState storage s = _S();\\n    bytes32 key = heroToken.packNftId(heroTokenId);\\n    if (s.lastHeroFightTs[key] + s.fightDelay > block.timestamp) revert IAppErrors.FightDelay();\\n    s.lastHeroFightTs[key] = block.timestamp;\\n  }\\n\\n  function _increaseIteration(address heroToken, uint heroTokenId, uint32 objId) internal returns (uint iteration) {\\n    IGOC.MainState storage s = _S();\\n    bytes32 key = _iterationKey(heroToken, heroTokenId, objId);\\n    iteration = s.iterations[key] + 1;\\n    s.iterations[key] = iteration;\\n  }\\n\\n  function _iterationKey(address heroToken, uint heroTokenId, uint32 objId) internal pure returns (bytes32) {\\n    return heroToken.packIterationKey(uint64(heroTokenId), objId);\\n  }\\n\\n  /// @notice Validate passed {mintItems_} and {mintItemsChances_}\\n  function _checkMintItems(address[] memory mintItems_, uint32[] memory mintItemsChances_) internal pure {\\n    uint length = mintItems_.length;\\n    if (mintItemsChances_.length != length) revert IAppErrors.LengthsMismatch();\\n\\n    for (uint i; i < length; ++i) {\\n      if (mintItems_[i] == address(0)) revert IAppErrors.ZeroAddress();\\n      if (mintItemsChances_[i] == 0) revert IAppErrors.ZeroChance();\\n      if (mintItemsChances_[i] > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighChance(mintItemsChances_[i]);\\n    }\\n  }\\n  //endregion ------------------------ Utils\\n}\\n\",\"keccak256\":\"0xdffd7bbaaf39e2293d989671104ccca18f1c65b0105e5896e1d326d0bf796efb\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ItemLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IItem.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./ControllerContextLib.sol\\\";\\nimport \\\"./ShelterLib.sol\\\";\\nimport \\\"./StatLib.sol\\\";\\n\\nlibrary ItemLib {\\n  using CalcLib for int32;\\n  using PackingLib for address;\\n  using PackingLib for bytes32;\\n  using PackingLib for bytes32[];\\n  using PackingLib for uint32[];\\n  using PackingLib for int32[];\\n\\n  //region ------------------------ Data types\\n  struct GenerateAttributesContext {\\n    /// @notice True if max allowed amount of random attributes were reached inside {_prepareAttributes}\\n    bool stopGenerateRandom;\\n    /// @notice Flag - attribute was generated. The array matches to info.ids\\n    bool[] usedIndexes;\\n    /// @notice Ids of the generated attributes\\n    uint8[] ids;\\n    /// @notice Randomly selected values of the generated attributes\\n    int32[] values;\\n    /// @notice Counter of the stored values into {ids} and {values}\\n    uint counter;\\n    /// @notice Total number of random attributes that were generated inside {_prepareAttributes}\\n    uint randomAttrCounter;\\n    /// @notice Total sum of all {random} values for random attributes generated in {_prepareAttributes}\\n    uint randomSum;\\n    /// @notice Total sum of all chances of the random attributes generated in {_prepareAttributes}\\n    uint chancesSum;\\n    /// @notice Total number of random attributes that can be generated\\n    uint totalRandomAttrsPossible;\\n  }\\n\\n  struct MintItemInfo {\\n    uint8 maxItems;\\n    int32 magicFind;\\n    int32 destroyItems;\\n    uint32[] mintItemsChances;\\n    IOracle oracle;\\n    address[] mintItems;\\n    uint amplifier;\\n    uint seed;\\n    /// @notice Penalty to reduce chance as chance/delta if the hero not in his biome\\n    /// @dev Use StatLib.mintDropChanceDelta\\n    uint mintDropChanceDelta;\\n    /// @notice SCR-1064: drop chance depends on NG_LEVEL, decimals 18, value is in the range [0...1e18]\\n    /// it's always 100% for NG0 (no reduce, value is 1e18)\\n    /// Use {dropChancePercent} to calculate actual value\\n    uint mintDropChanceNgLevelMultiplier;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Restrictions\\n  /// @notice ensure that the user belongs to a guild, the guild has a shelter, the shelter has highest level 3\\n  function _onlyMemberOfGuildWithShelterMaxLevel(IController controller, address msgSender) internal view {\\n    // ensure that signer belongs to a guild and the guild has a shelter of ANY level\\n    IGuildController gc = IGuildController(controller.guildController());\\n\\n    uint guildId = gc.memberOf(msgSender);\\n    if (guildId == 0) revert IAppErrors.NotGuildMember();\\n\\n    uint shelterId = gc.guildToShelter(guildId);\\n    if (shelterId == 0) revert IAppErrors.GuildHasNoShelter();\\n\\n    // only highest level of shelters gives possibility to exit from dungeon\\n    (, uint8 shelterLevel,) = PackingLib.unpackShelterId(shelterId);\\n    if (shelterLevel != ShelterLib.MAX_SHELTER_LEVEL) revert IAppErrors.TooLowShelterLevel(shelterLevel, ShelterLib.MAX_SHELTER_LEVEL);\\n  }\\n\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ Main logic\\n\\n  /// @notice Mint new item, setup attributes, make extra setup if necessary (setup attack item, buff item)\\n  /// @param sender Dungeon Factory / User Controller / Guild Controller are allowed\\n  /// @param item Item to be minted\\n  /// @param recipient The item is minted for the given recipient\\n  /// @return itemId Id of the newly minted item\\n  function mintNewItem(\\n    IItemController.MainState storage s,\\n    IController controller,\\n    address sender,\\n    address item,\\n    address recipient\\n  ) external returns (uint itemId) {\\n    ControllerContextLib.ControllerContext memory ctx = ControllerContextLib.init(controller);\\n\\n    address guildController = address(ControllerContextLib.getGuildController(ctx));\\n    address shelterController = guildController == address(0)\\n      ? address(0)\\n      : IGuildController(guildController).shelterController();\\n\\n    if (\\n      address(ControllerContextLib.getDungeonFactory(ctx)) != sender\\n      && address(ControllerContextLib.getUserController(ctx)) != sender\\n      && guildController != sender\\n      && shelterController != sender\\n      && address(ControllerContextLib.getItemController(ctx)) != sender\\n      && address(ControllerContextLib.getHeroController(ctx)) != sender\\n    ) revert IAppErrors.MintNotAllowed();\\n\\n    itemId = IItem(item).mintFor(recipient);\\n\\n    IItemController.MintInfo memory info;\\n\\n    (\\n      info.meta,\\n      info.attributesIds,\\n      info.attributesValues,\\n      info.itemRarity\\n    ) = _setupNewAttributes(s, item, itemId, CalcLib.pseudoRandom);\\n\\n    // setup extra info\\n\\n    if (info.meta.itemMetaType == uint8(IItemController.ItemMetaType.ATTACK)) {\\n      info.attackInfo = unpackItemAttackInfo(_setupNewAttackItem(s, item, itemId));\\n    } else if (info.meta.itemMetaType == uint8(IItemController.ItemMetaType.BUFF)) {\\n      (\\n        info.casterIds,\\n        info.casterValues,\\n        info.targetIds,\\n        info.targetValues\\n      ) = _setupNewBuffItem(s, item, itemId, CalcLib.pseudoRandom);\\n    }\\n    // consumable stats unchangeable, get them by address\\n\\n    emit IApplicationEvents.NewItemMinted(item, itemId, info);\\n  }\\n\\n  /// @notice Mint random items, not more than {info.maxItems}\\n  function mintRandomItems(MintItemInfo memory info) internal returns (address[] memory) {\\n    return _mintRandomItems(info, CalcLib.nextPrng);\\n  }\\n\\n  function applyActionMasks(\\n    uint actionMask,\\n    IStatController statController,\\n    IController controller,\\n    address msgSender,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external {\\n    if ((actionMask & (2 ** uint(IItemController.ConsumableActionBits.CLEAR_TEMPORARY_ATTRIBUTES_0))) != 0) {\\n      statController.clearTemporallyAttributes(heroToken, heroTokenId);\\n    }\\n    if ((actionMask & (2 ** uint(IItemController.ConsumableActionBits.EXIT_FROM_DUNGEON_1))) != 0) {\\n      _actionExitFromDungeon(controller, msgSender, heroToken, heroTokenId);\\n    }\\n    if ((actionMask & (2 ** uint(IItemController.ConsumableActionBits.REST_IN_SHELTER_3))) != 0) {\\n      _actionRestInShelter(controller, statController, msgSender, heroToken, heroTokenId);\\n    }\\n  }\\n\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ Consumable actions\\n  /// @notice Exit from the dungeon: same to the death without reducing life chance\\n  function _actionExitFromDungeon(IController controller, address msgSender, address heroToken, uint heroTokenId) internal {\\n    _onlyMemberOfGuildWithShelterMaxLevel(controller, msgSender);\\n\\n    // exit from the dungeon ~ \\\"soft kill\\\"\\n    IDungeonFactory(controller.dungeonFactory()).exitForcibly(heroToken, heroTokenId, msgSender);\\n  }\\n\\n  /// @notice Rest in the shelter of 3d level: restore of hp & mp, clear temporally attributes, clear used consumables\\n  function _actionRestInShelter(\\n    IController controller,\\n    IStatController statController,\\n    address msgSender,\\n    address heroToken,\\n    uint heroTokenId\\n  ) internal {\\n    _onlyMemberOfGuildWithShelterMaxLevel(controller, msgSender);\\n\\n    // restore life and mana to default values from the total attributes\\n    statController.restoreLifeAndMana(heroToken, heroTokenId, statController.heroAttributes(heroToken, heroTokenId));\\n\\n    statController.clearTemporallyAttributes(heroToken, heroTokenId);\\n    statController.clearUsedConsumables(heroToken, heroTokenId);\\n\\n    emit IApplicationEvents.RestInShelter(msgSender, heroToken, heroTokenId);\\n  }\\n  //endregion ------------------------ Consumable actions\\n\\n  //region ------------------------ Internal logic\\n  /// @param nextPrng_ CalcLib.nextPrng, param is required by unit tests\\n  function _mintRandomItems(\\n    MintItemInfo memory info,\\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\\n  ) internal returns (address[] memory) {\\n\\n    // if hero is not in his biome do not mint at all\\n    if (info.mintDropChanceDelta != 0) {\\n      return new address[](0);\\n    }\\n\\n    uint len = info.mintItems.length;\\n\\n    // Fisher\\u2013Yates shuffle\\n    LibPRNG.PRNG memory prng = LibPRNG.PRNG(info.oracle.getRandomNumber(CalcLib.MAX_CHANCE, info.seed));\\n    uint[] memory indices = new uint[](len);\\n    for (uint i = 1; i < len; ++i) {\\n      indices[i] = i;\\n    }\\n    LibPRNG.shuffle(prng, indices);\\n\\n    address[] memory minted = new address[](len);\\n    uint mintedLength;\\n    uint di = Math.min(CalcLib.toUint(info.destroyItems), 100);\\n\\n    for (uint i; i < len; ++i) {\\n      if (info.mintItemsChances[indices[i]] > CalcLib.MAX_CHANCE) {\\n        revert IAppErrors.TooHighChance(info.mintItemsChances[indices[i]]);\\n      }\\n\\n      uint chance = _adjustChance(info.mintItemsChances[indices[i]], info, di);\\n\\n      // need to call random in each loop coz each minted item should have dedicated chance\\n      uint rnd = nextPrng_(prng, CalcLib.MAX_CHANCE); // randomWithSeed_(CalcLib.MAX_CHANCE, rndSeed);\\n\\n      if (chance != 0 && (chance >= CalcLib.MAX_CHANCE || rnd < chance)) {\\n        // There is no break here: the cycle is continued even if the number of the minted items reaches the max.\\n        // The reason: gas consumption of success operation must be great of equal of the gas consumption of fail op.\\n        if (mintedLength < info.maxItems) {\\n          minted[i] = info.mintItems[indices[i]];\\n          ++mintedLength;\\n        }\\n      }\\n    }\\n\\n    address[] memory mintedAdjusted = new address[](mintedLength);\\n    uint j;\\n    for (uint i; i < len; ++i) {\\n      if (minted[i] != address(0)) {\\n        mintedAdjusted[j] = minted[i];\\n        ++j;\\n      }\\n    }\\n\\n    return mintedAdjusted;\\n  }\\n\\n  /// @notice Apply all corrections to the chance of item drop\\n  /// There are two params to increase chances: amplifier and magicFind\\n  /// There are two params to decrease chances: destroyItems and mintDropChanceNgLevelMultiplier\\n  /// @param info Assume here, that info.mintDropChanceNgLevelMultiplier is in the range [0..1e18]\\n  /// @param di Assume that di <= 100\\n  function _adjustChance(uint32 itemChance, MintItemInfo memory info, uint di) internal pure returns (uint) {\\n    uint chance = uint(itemChance) * Math.min(1e18, info.mintDropChanceNgLevelMultiplier) / 1e18;\\n    chance += chance * info.amplifier / StatLib._MAX_AMPLIFIER;\\n    chance += chance * CalcLib.toUint(info.magicFind) / 100;\\n    chance -= chance * di / 100;\\n    return chance;\\n  }\\n\\n  function _setupNewAttributes(\\n    IItemController.MainState storage s,\\n    address item,\\n    uint itemId,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (\\n    IItemController.ItemMeta memory meta,\\n    uint8[] memory ids,\\n    int32[] memory values,\\n    IItemController.ItemRarity itemRarity\\n  ){\\n    meta = unpackedItemMeta(s.itemMeta[item]);\\n    (ids, values, itemRarity) = _generateAttributes(unpackItemGenerateInfo(s.generateInfoAttributes[item]), meta, random_);\\n\\n    bytes32 packedItemId = item.packNftId(itemId);\\n    if (ids.length != 0) {\\n      s._itemAttributes[packedItemId] = values.toBytes32ArrayWithIds(ids);\\n    }\\n\\n    s.itemInfo[packedItemId] = PackingLib.packItemInfo(uint8(itemRarity), 0, meta.baseDurability);\\n  }\\n\\n  function _setupNewAttackItem(IItemController.MainState storage s, address item, uint itemId) internal returns (bytes32 attackInfo){\\n    // we just write data for attack item, no need to generate, it will be augmented later so need individual data for itemId\\n    attackInfo = s.generateInfoAttack[item];\\n    s._itemAttackInfo[item.packNftId(itemId)] = attackInfo;\\n  }\\n\\n  function _setupNewBuffItem(\\n    IItemController.MainState storage s,\\n    address item,\\n    uint itemId,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (\\n    uint8[] memory casterIds,\\n    int32[] memory casterValues,\\n    uint8[] memory targetIds,\\n    int32[] memory targetValues\\n  ){\\n\\n    // CASTER\\n    (casterIds, casterValues) = _generateSimpleAttributes(\\n      unpackItemGenerateInfo(s.generateInfoCasterAttributes[item]),\\n      true,\\n      random_\\n    );\\n\\n    if (casterIds.length != 0) {\\n      s._itemCasterAttributes[item.packNftId(itemId)] = casterValues.toBytes32ArrayWithIds(casterIds);\\n    }\\n\\n    // TARGET\\n    (targetIds, targetValues) = _generateSimpleAttributes(\\n      unpackItemGenerateInfo(s.generateInfoTargetAttributes[item]),\\n      true,\\n      random_\\n    );\\n\\n    if (targetIds.length != 0) {\\n      s._itemTargetAttributes[item.packNftId(itemId)] = targetValues.toBytes32ArrayWithIds(targetIds);\\n    }\\n  }\\n\\n  /// @notice Generate all mandatory attributes and try to generate required number of random attributes.\\n  /// Generate at least {info.minRandomAttributes} of random attributes if it's possible\\n  /// but not more than {info.maxRandomAttributes}. Value of each attribute is generated randomly according its chances.\\n  /// @param meta Assume, that meta.min != 0, meta.max != 0 and both meta.min and meta.min should have same sign\\n  /// because results value cannot be 0\\n  /// @return ids Ids of the attributes, zero id is allowed\\n  /// @return values Randomly generated attributes values, min <= value <= max\\n  /// @return itemRarity Rarity of the item (Either meta.defaultRarity or calculated if there is no default rarity)\\n  function _generateAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    IItemController.ItemMeta memory meta,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    uint8[] memory ids,\\n    int32[] memory values,\\n    IItemController.ItemRarity itemRarity\\n  ) {\\n    GenerateAttributesContext memory ctx;\\n\\n    uint len = info.ids.length;\\n    if (len != 0) {\\n      ctx.ids = new uint8[](len);\\n      ctx.values = new int32[](len);\\n      ctx.usedIndexes = new bool[](len);\\n\\n      // Fisher\\u2013Yates shuffle\\n      _shuffleInfo(info, random_);\\n\\n      // initialize ctx by initial values\\n      // generate all mandatory attributes, try to generate not more than {meta.maxRandomAttributes} random attributes\\n      _prepareAttributes(info, meta.maxRandomAttributes, ctx, random_);\\n\\n      // generate missing random attributes if it's necessary, ctx.counter is incremented\\n      _generateMissingRandomAttributes(info, meta.minRandomAttributes, ctx, random_);\\n\\n      itemRarity = meta.defaultRarity == 0\\n        ? _calculateRarity(ctx.randomSum, ctx.chancesSum, ctx.randomAttrCounter, meta.maxRandomAttributes)\\n        : IItemController.ItemRarity(meta.defaultRarity);\\n    } else {\\n      itemRarity = IItemController.ItemRarity.UNKNOWN;\\n    }\\n\\n    (ids, values) = _fixLengthsIdsValues(ctx.ids, ctx.values, ctx.counter);\\n  }\\n\\n  /// @notice Generate missing random attributes if necessary\\n  function _generateMissingRandomAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    uint8 minRandomAttributes,\\n    GenerateAttributesContext memory ctx,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint attrToGen = Math.min(ctx.totalRandomAttrsPossible, minRandomAttributes);\\n    if (ctx.randomAttrCounter < attrToGen && ctx.totalRandomAttrsPossible > ctx.randomAttrCounter) {\\n      // it's necessary AND possible to generate more random attributes\\n      uint possibleRemainingAttrs = ctx.totalRandomAttrsPossible - ctx.randomAttrCounter;\\n      uint remainingAttrsToGen = attrToGen - ctx.randomAttrCounter;\\n\\n      uint[] memory indicesToGen = new uint[](possibleRemainingAttrs);\\n      uint indicesToGenCounter;\\n\\n      // enumerate all attributes, add all indices of not-generated attributes to {indexesToGen}\\n      for (uint i; i < info.ids.length; ++i) {\\n        // mandatory attrs should be already generated and no need to check\\n        if (!ctx.usedIndexes[i]) {\\n          indicesToGen[indicesToGenCounter] = i;\\n          indicesToGenCounter++;\\n        }\\n      }\\n\\n      // Shuffle indices of not-generated attributes using Fisher\\u2013Yates shuffle\\n      if (possibleRemainingAttrs > 1) {\\n        for (uint i; i < possibleRemainingAttrs - 1; ++i) {\\n          uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, possibleRemainingAttrs - 1, random_);\\n          (indicesToGen[randomIndex], indicesToGen[i]) = (indicesToGen[i], indicesToGen[randomIndex]);\\n        }\\n      }\\n      // Generate necessary amount of attributes. Fist (shuffled) attributes are selected (MAX_CHANCE is used for each)\\n      for (uint i; i < remainingAttrsToGen; ++i) {\\n        uint idx = indicesToGen[i];\\n        (int32 attr,) = _generateAttribute(info.mins[idx], info.maxs[idx], CalcLib.MAX_CHANCE, random_);\\n        ctx.ids[ctx.counter] = info.ids[idx];\\n        ctx.values[ctx.counter] = attr;\\n        ctx.counter++;\\n      }\\n    }\\n  }\\n\\n  /// @notice Generate all mandatory attributes, generate not more than {meta.maxRandomAttributes} random attributes.\\n  /// Updates context:\\n  ///   {ctx.totalRandomAttrsPossible} - total number of possible random attributes\\n  ///   {ctx.randomAttrCounter} - total number of generated random attributes  <= {maxRandomAttributes}\\n  ///   {ctx.randomSum} = sum of random of all random attributes.\\n  ///   {ctx.chancesSum} = sum of chances of all random attributes.\\n  ///   {ctx.counter} = total number of generated attributes. Values of ctx.ids, ctx.values, ctx.usedIndexes are\\n  ///   initialized in the range [0...ctx.counter)\\n  /// @param ctx Empty struct but arrays ids, values and usedIndexes should be allocated for info.ids.length items\\n  function _prepareAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    uint8 maxRandomAttributes,\\n    GenerateAttributesContext memory ctx,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint len = info.ids.length;\\n    for (uint i; i < len; ++i) {\\n      if (info.chances[i] != CalcLib.MAX_CHANCE) {\\n        ctx.totalRandomAttrsPossible++;\\n      }\\n\\n      if (info.chances[i] >= CalcLib.MAX_CHANCE || !ctx.stopGenerateRandom) {\\n        (int32 attr, uint random) = _generateAttribute(info.mins[i], info.maxs[i], info.chances[i], random_);\\n\\n        // count only random attributes for calc rarity\\n        if (attr != 0) {\\n\\n          if (\\n            info.chances[i] < CalcLib.MAX_CHANCE\\n            // && random != 0 // commented: random = 0 can produce crash in _generateMissingRandomAttributes\\n          ) {\\n            ctx.randomAttrCounter++;\\n            ctx.randomSum += random;\\n            ctx.chancesSum += info.chances[i];\\n          }\\n          ctx.ids[ctx.counter] = info.ids[i];\\n          ctx.values[ctx.counter] = attr;\\n          ctx.counter++;\\n          ctx.usedIndexes[i] = true;\\n        }\\n\\n        // it is a bit less fair random for attrs in the end of the list, however we assume it should be pretty rare case\\n        if (ctx.randomAttrCounter == maxRandomAttributes) {\\n          ctx.stopGenerateRandom = true;\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Shuffle info arrays using Fisher\\u2013Yates shuffle algo\\n  function _shuffleInfo(\\n    IItemController.ItemGenerateInfo memory info,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint len = info.ids.length;\\n    if (len > 1) {\\n      for (uint i; i < len - 1; i++) {\\n        uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, len - 1, random_);\\n\\n        (info.ids[randomIndex], info.ids[i]) = (info.ids[i], info.ids[randomIndex]);\\n        (info.mins[randomIndex], info.mins[i]) = (info.mins[i], info.mins[randomIndex]);\\n        (info.maxs[randomIndex], info.maxs[i]) = (info.maxs[i], info.maxs[randomIndex]);\\n        (info.chances[randomIndex], info.chances[i]) = (info.chances[i], info.chances[randomIndex]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Generate array [0,1,2.. N-1] and shuffle it using Fisher\\u2013Yates shuffle algo\\n  function _shuffleIndices(\\n    uint countItems,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint[] memory indices){\\n    indices = new uint[](countItems);\\n    for (uint i = 1; i < countItems; ++i) {\\n      indices[i] = i;\\n    }\\n    if (countItems > 1) {\\n      for (uint i; i < countItems - 1; i++) {\\n        uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, countItems - 1, random_);\\n        (indices[randomIndex], indices[i]) = (indices[i], indices[randomIndex]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Reduce lengths of {ids} and {values} to {count}\\n  function _fixLengthsIdsValues(uint8[] memory ids, int32[] memory values, uint count) internal pure returns (\\n    uint8[] memory idsOut,\\n    int32[] memory valuesOut\\n  ) {\\n    if (count == ids.length) {\\n      return (ids, values);\\n    }\\n\\n    idsOut = new uint8[](count);\\n    valuesOut = new int32[](count);\\n    for (uint i; i < count; ++i) {\\n      idsOut[i] = ids[i];\\n      valuesOut[i] = values[i];\\n    }\\n    return (idsOut, valuesOut);\\n  }\\n\\n  /// @param random_ Pass CalcLib.pseudoRandom here, param is required for unit tests. Max value is MAX_CHANCE\\n  function _generateSimpleAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    bool maxChance,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    uint8[] memory ids,\\n    int32[] memory values\\n  ) {\\n    uint len = info.ids.length;\\n    ids = new uint8[](len);\\n    values = new int32[](len);\\n\\n    uint n = 0;\\n    for (uint i; i < len; ++i) {\\n      (int32 attr,) = _generateAttribute(\\n        info.mins[i],\\n        info.maxs[i],\\n        maxChance ? CalcLib.MAX_CHANCE : info.chances[i],\\n        random_\\n      );\\n      if (attr != 0) {\\n        ids[n] = info.ids[i];\\n        values[n] = attr;\\n        ++n;\\n      }\\n    }\\n\\n    return _fixLengthsIdsValues(ids, values, n);\\n  }\\n\\n  //endregion ------------------------ Internal logic\\n\\n  //region ------------------------ Internal utils\\n  /// @param chance Chance in the range [0...MAX_CHANCE], MAX_CHANCE=1e9 means \\\"mandatory\\\" element.\\n  /// @param random_ Pass CalcLib.pseudoRandom here, param is required for unit tests\\n  /// @return attr Either 0 or min <= attr <= max\\n  /// @return rnd Random value in the range [0...MAX_CHANCE]; It's always 0 for mandatory elements\\n  function _generateAttribute(\\n    int32 min,\\n    int32 max,\\n    uint32 chance,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    int32 attr,\\n    uint rnd\\n  ) {\\n    if (chance > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighChance(chance);\\n\\n    uint diff = uint(CalcLib.absDiff(min, max));\\n\\n    if (chance < CalcLib.MAX_CHANCE) {\\n      uint32 random = CalcLib.pseudoRandomUint32Flex(CalcLib.MAX_CHANCE, random_);\\n      if (random < chance) {\\n        uint r = uint(CalcLib.MAX_CHANCE - random * (CalcLib.MAX_CHANCE / chance));\\n        int32 k = int32(int(r * diff / uint(CalcLib.MAX_CHANCE)));\\n        return (min + k, random);\\n      }\\n    } else { // chance == CalcLib.MAX_CHANCE => mandatory element\\n      if (diff == 0) {\\n        return (min, 0);\\n      } else {\\n        uint r = uint(CalcLib.pseudoRandomUint32Flex(CalcLib.MAX_CHANCE, random_));\\n        int32 k = int32(int(r % (diff + 1)));\\n\\n        // return zero random - no need to calc rarity for mandatory elements\\n        return (min + k, 0);\\n      }\\n    }\\n\\n    return (0, 0);\\n  }\\n\\n  /// @notice Calculate item rarity\\n  /// @param randomSum Total sum random values of all random attributes in ItemGenerateInfo, [0...MAX_CHANCE/attrCounter]\\n  /// @param chancesSum Total sum of all random chances in ItemGenerateInfo\\n  /// @param attrCounter Count of random attributes in ItemGenerateInfo\\n  /// @param maxAttr Index of max allowed random attribute (all attributes with higher indices are not random)\\n  /// @return item rarity\\n  function _calculateRarity(uint randomSum, uint chancesSum, uint attrCounter, uint maxAttr) internal pure returns (\\n    IItemController.ItemRarity\\n  ) {\\n    if (attrCounter == 0) {\\n      return IItemController.ItemRarity.NORMAL;\\n    }\\n\\n    uint random = randomSum / attrCounter;\\n    uint averageChance = chancesSum / attrCounter;\\n\\n    if (random > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighRandom(random);\\n\\n    if (random < averageChance / 4 && attrCounter == maxAttr) {\\n      return IItemController.ItemRarity.RARE;\\n    } else if (random < averageChance * 3 / 4) {\\n      return attrCounter > 2\\n        ? IItemController.ItemRarity.RARE\\n        : IItemController.ItemRarity.MAGIC;\\n    } else {\\n      return attrCounter > 1\\n        ? IItemController.ItemRarity.MAGIC\\n        : IItemController.ItemRarity.NORMAL;\\n    }\\n  }\\n  //endregion ------------------------ Internal utils\\n\\n  //region ------------------------ PACKING\\n\\n  function packItemGenerateInfo(IItemController.ItemGenerateInfo memory info) internal pure returns (bytes32[] memory result) {\\n    uint len = info.ids.length;\\n    if (len != info.mins.length || len != info.maxs.length || len != info.chances.length) {\\n      revert IAppErrors.LengthsMismatch();\\n    }\\n\\n    result = new bytes32[](len);\\n\\n    for (uint i; i < len; ++i) {\\n      result[i] = PackingLib.packItemGenerateInfo(info.ids[i], info.mins[i], info.maxs[i], info.chances[i]);\\n    }\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32[] memory gen) internal pure returns (\\n    IItemController.ItemGenerateInfo memory\\n  ) {\\n    uint length = gen.length;\\n\\n    uint8[] memory ids = new uint8[](length);\\n    int32[] memory mins = new int32[](length);\\n    int32[] memory maxs = new int32[](length);\\n    uint32[] memory chances = new uint32[](length);\\n\\n    for (uint i; i < length; ++i) {\\n      (ids[i], mins[i], maxs[i], chances[i]) = gen[i].unpackItemGenerateInfo();\\n    }\\n\\n    return IItemController.ItemGenerateInfo(ids, mins, maxs, chances);\\n  }\\n\\n  function packItemMeta(IItemController.ItemMeta memory meta) internal pure returns (bytes32) {\\n    return PackingLib.packItemMeta(\\n      meta.itemMetaType,\\n      meta.itemLevel,\\n      uint8(meta.itemType),\\n      meta.baseDurability,\\n      meta.defaultRarity,\\n      meta.minRandomAttributes,\\n      meta.maxRandomAttributes,\\n      meta.manaCost,\\n      meta.requirements\\n    );\\n  }\\n\\n  function unpackedItemMeta(bytes32 meta) internal pure returns (IItemController.ItemMeta memory result) {\\n    return meta.unpackItemMeta();\\n  }\\n\\n  function packItemInfo(IItemController.ItemInfo memory info) internal pure returns (bytes32) {\\n    return PackingLib.packItemInfo(uint8(info.rarity), info.augmentationLevel, info.durability);\\n  }\\n\\n  function unpackedItemInfo(bytes32 info) internal pure returns (IItemController.ItemInfo memory result) {\\n    uint8 rarity;\\n    (rarity, result.augmentationLevel, result.durability) = info.unpackItemInfo();\\n\\n    result.rarity = IItemController.ItemRarity(rarity);\\n    return result;\\n  }\\n\\n  function packItemAttackInfo(IItemController.AttackInfo memory info) internal pure returns (bytes32) {\\n    return PackingLib.packItemAttackInfo(\\n      uint8(info.aType),\\n      info.min,\\n      info.max,\\n      info.attributeFactors.strength,\\n      info.attributeFactors.dexterity,\\n      info.attributeFactors.vitality,\\n      info.attributeFactors.energy\\n    );\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 info) internal pure returns (IItemController.AttackInfo memory result) {\\n    IStatController.CoreAttributes memory fs;\\n    uint8 aType;\\n    (aType, result.min, result.max, fs.strength, fs.dexterity, fs.vitality, fs.energy) = info.unpackItemAttackInfo();\\n\\n    result.aType = IItemController.AttackType(aType);\\n    result.attributeFactors = fs;\\n\\n    return result;\\n  }\\n  //endregion ------------------------ PACKING\\n}\\n\",\"keccak256\":\"0xf6771268a4ef0034ccebd4c254ad43fc6019eca7933c800a8f1ad412ff740f49\",\"license\":\"BUSL-1.1\"},\"contracts/lib/MonsterLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\nimport \\\"./StatLib.sol\\\";\\nimport \\\"./ItemLib.sol\\\";\\nimport \\\"./StringLib.sol\\\";\\nimport \\\"./FightLib.sol\\\";\\nimport \\\"./RewardsPoolLib.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IFightCalculator.sol\\\";\\nimport \\\"../interfaces/IDungeonFactory.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary MonsterLib {\\n  using CalcLib for int32;\\n  using PackingLib for bytes32;\\n  using PackingLib for bytes32[];\\n  using PackingLib for uint16;\\n  using PackingLib for uint8;\\n  using PackingLib for address;\\n  using PackingLib for uint32[];\\n  using PackingLib for uint32;\\n  using PackingLib for uint64;\\n  using PackingLib for int32[];\\n  using PackingLib for int32;\\n\\n  /// @notice Max value for monster rarity and monster/dungeon multiplier\\n  uint32 internal constant _MAX_AMPLIFIER = 1e9;\\n  uint private constant _TOTAL_SUPPLY_BASE = 10_000_000e18;\\n\\n  /// @notice Base monster multiplier for NG+. Multiplier = base multiplier * hero ng_level\\n  uint internal constant _MONSTER_MULTIPLIER_NGP_BASE = uint(_MAX_AMPLIFIER);\\n\\n  //region ------------------------ Data types\\n  struct AdrContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IOracle oracle;\\n    IStatController statController;\\n    IItemController itemController;\\n    uint heroTokenId;\\n  }\\n\\n  struct FightInternalInfo {\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 heroLifeRegen;\\n    int32 heroHp;\\n    int32 monsterHp;\\n    uint32 monsterRarity;\\n    IFightCalculator.FighterInfo heroFightInfo;\\n    IFightCalculator.FighterInfo monsterFightInfo;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Main logic\\n\\n  /// @param heroNgLevel Pass type(uint8).max for !NG+\\n  function initialGeneration(\\n    IGOC.MonsterInfo storage mInfo,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint iteration,\\n    uint8 heroNgLevel\\n  ) internal {\\n    return _initialGeneration(mInfo, heroToken, heroTokenId, iteration, _pseudoRandom, heroNgLevel);\\n  }\\n\\n  /// @notice Fight, post fight, generate fight results\\n  /// @return result Fields objectId, heroToken, heroTokenId, iteration remain uninitialized here.\\n  /// Caller is responsible to set that values.\\n  /// @dev weird, but memory ctx is more efficient here than calldata ctx\\n  function action(IGOC.ActionContext memory ctx, IGOC.MonsterInfo storage mInfo) external returns (\\n    IGOC.ActionResult memory result,\\n    uint8 turn\\n  ) {\\n    return _action(ctx, mInfo, _pseudoRandom, FightLib.fight);\\n  }\\n\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ Internal calculations\\n  function _action(\\n    IGOC.ActionContext memory ctx,\\n    IGOC.MonsterInfo storage mInfo,\\n    function (uint) internal view returns (uint) random_,\\n    function(\\n      IItemController,\\n      IFightCalculator.FightCall memory,\\n      address,\\n      function (uint) internal view returns (uint)\\n    ) internal returns (IFightCalculator.FightResult memory) fight_\\n  ) internal returns (\\n    IGOC.ActionResult memory result,\\n    uint8 turn\\n  ) {\\n    AdrContext memory adrCtx = _context(ctx);\\n    IGOC.GeneratedMonster memory gen = unpackGeneratedMonster(mInfo._generatedMonsters[ctx.heroToken.packNftId(ctx.heroTokenId)][ctx.iteration]);\\n    turn = gen.turnCounter;\\n\\n    (FightInternalInfo memory fInfo, IGOC.MonsterGenInfo memory genInfo) = _fight(ctx, mInfo, gen, adrCtx, random_, fight_);\\n    result = _postFight(mInfo, ctx, adrCtx, fInfo, genInfo, gen);\\n  }\\n\\n  /// @dev This function was extracted from {action()} to simplify unit testing\\n  /// @param gen These values CAN BE modified in place in some cases.\\n  /// @return result Fields objectId, heroToken, heroTokenId, iteration remain uninitialized here.\\n  /// Caller is responsible to set that values.\\n  function _postFight(\\n    IGOC.MonsterInfo storage mInfo,\\n    IGOC.ActionContext memory ctx,\\n    AdrContext memory adrCtx,\\n    FightInternalInfo memory fInfo,\\n    IGOC.MonsterGenInfo memory genInfo,\\n    IGOC.GeneratedMonster memory gen\\n  ) internal returns (\\n    IGOC.ActionResult memory result\\n  ) {\\n    bytes32 heroPackedId = ctx.heroToken.packNftId(ctx.heroTokenId);\\n    if (gen.turnCounter > 100) {\\n      // instant kill hero if too long battle\\n      fInfo.heroHp = 0;\\n    }\\n\\n    bool isMonsterDead = fInfo.monsterHp == 0;\\n    bool isHeroDead = fInfo.heroHp == 0;\\n\\n    if (isMonsterDead) {\\n      _bossDefeated(adrCtx, ctx);\\n    }\\n\\n    if (isMonsterDead || isHeroDead) {\\n      if (gen.generated) {\\n        delete mInfo._generatedMonsters[heroPackedId][ctx.iteration];\\n      }\\n      // assume that if the hero is dead clearUsedConsumables will be called in _objectAction\\n      if (isMonsterDead) {\\n        adrCtx.statController.clearUsedConsumables(ctx.heroToken, ctx.heroTokenId);\\n      }\\n    } else {\\n      if (gen.generated) {\\n        gen.hp = fInfo.monsterHp;\\n        gen.turnCounter = gen.turnCounter + 1;\\n      } else {\\n        // new instance of gen is created\\n        gen = IGOC.GeneratedMonster({\\n          generated: true,\\n          amplifier: fInfo.monsterRarity,\\n          hp: fInfo.monsterHp,\\n          turnCounter: 1\\n        });\\n      }\\n\\n      mInfo._generatedMonsters[heroPackedId][ctx.iteration] = packGeneratedMonster(gen);\\n    }\\n\\n    if (isMonsterDead) {\\n      bytes32 index = _getMonsterCounterIndex(ctx.objectId);\\n      uint curValue = adrCtx.statController.heroCustomData(ctx.heroToken, ctx.heroTokenId, index);\\n      adrCtx.statController.setHeroCustomData(ctx.heroToken, ctx.heroTokenId, index, curValue + 1);\\n    }\\n\\n    // --- generate result\\n    result.kill = isHeroDead;\\n    result.experience = isMonsterDead\\n      ? StatLib.expPerMonster(\\n        fInfo.monsterFightInfo.fighterStats.experience,\\n        fInfo.monsterRarity,\\n        fInfo.heroFightInfo.fighterStats.experience,\\n        fInfo.heroFightInfo.fighterStats.level,\\n        ctx.biome\\n      )\\n      : 0;\\n\\n    result.heal = fInfo.heroLifeRegen;\\n    result.manaRegen = isMonsterDead ? fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MANA_AFTER_KILL)] : int32(0);\\n    // result.lifeChancesRecovered = 0; // zero by default\\n    result.damage = fInfo.damage;\\n    result.manaConsumed = fInfo.manaConsumed;\\n    result.mintItems = isMonsterDead\\n      ? _mintRandomItems(fInfo, ctx, genInfo, CalcLib.nextPrng)\\n      : new address[](0);\\n    result.completed = isMonsterDead || isHeroDead;\\n\\n    return result;\\n  }\\n\\n  /// @notice Generate new {GeneratedMonster} and put it to {mInfo._generatedMonsters}\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...MAX_AMPLIFIER]\\n  /// @param heroNgLevel Assume type(uint8).max for !NG+\\n  function _initialGeneration(\\n    IGOC.MonsterInfo storage mInfo,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint iteration,\\n    function (uint) internal view returns (uint) random_,\\n    uint8 heroNgLevel\\n  ) internal {\\n    IGOC.GeneratedMonster memory gen = IGOC.GeneratedMonster({\\n      generated: true,\\n      amplifier: uint32(random_(_MAX_AMPLIFIER)),\\n      hp: 0,\\n      turnCounter: 0\\n    });\\n\\n    IGOC.MonsterGenInfo memory info = unpackMonsterInfo(mInfo);\\n\\n    (int32[] memory attributes,) = generateMonsterAttributes(\\n      info.attributeIds,\\n      info.attributeValues,\\n      gen.amplifier,\\n      monsterMultiplier(heroNgLevel),\\n      info.experience\\n    );\\n    gen.hp = attributes[uint(IStatController.ATTRIBUTES.LIFE)];\\n\\n    mInfo._generatedMonsters[heroToken.packNftId(heroTokenId)][iteration] = packGeneratedMonster(gen);\\n  }\\n\\n  function _bossDefeated(AdrContext memory adrCtx, IGOC.ActionContext memory ctx) internal {\\n    if (ctx.objectSubType == uint8(IGOC.ObjectSubType.BOSS_3)) {\\n      IDungeonFactory(adrCtx.controller.dungeonFactory()).setBossCompleted(ctx.objectId, ctx.heroToken, ctx.heroTokenId, ctx.biome);\\n    }\\n  }\\n\\n  function _collectHeroFighterInfo(\\n    IFightCalculator.AttackInfo memory attackInfo,\\n    AdrContext memory adrContext\\n  ) internal view returns (\\n    IFightCalculator.FighterInfo memory fInfo,\\n    int32 manaConsumed\\n  ) {\\n    IStatController.ChangeableStats memory heroStats = adrContext.statController.heroStats(adrContext.heroToken, adrContext.heroTokenId);\\n\\n    (int32[] memory heroAttributes, int32 _manaConsumed) = _buffAndGetHeroAttributes(heroStats.level, attackInfo, adrContext);\\n\\n    manaConsumed = _manaConsumed;\\n\\n    if (attackInfo.attackType == IFightCalculator.AttackType.MAGIC) {\\n      manaConsumed += int32(adrContext.itemController.itemMeta(attackInfo.attackToken).manaCost);\\n    }\\n\\n    fInfo = IFightCalculator.FighterInfo({\\n      fighterAttributes: heroAttributes,\\n      fighterStats: heroStats,\\n      attackType: attackInfo.attackType,\\n      attackToken: attackInfo.attackToken,\\n      attackTokenId: attackInfo.attackTokenId,\\n      race: uint(IStatController.Race.HUMAN)\\n    });\\n  }\\n\\n  function _buffAndGetHeroAttributes(\\n    uint level,\\n    IFightCalculator.AttackInfo memory attackInfo,\\n    AdrContext memory context\\n  ) internal view returns (\\n    int32[] memory heroAttributes,\\n    int32 manaConsumed\\n  ) {\\n    return context.statController.buffHero(IStatController.BuffInfo({\\n      heroToken: context.heroToken,\\n      heroTokenId: context.heroTokenId,\\n      heroLevel: uint32(level),\\n      buffTokens: attackInfo.skillTokens,\\n      buffTokenIds: attackInfo.skillTokenIds\\n    }));\\n  }\\n\\n  /// @notice Get skill tokens, ensure that they are equipped on, add skill-tokens target attributes to hero attributes\\n  /// @param attributes Hero attributes. These values are incremented in place\\n  // @param heroAttackInfo Checked attack info. Assume that all skill tokens belong either to the hero or to the helper.\\n  function _debuff(\\n    int32[] memory attributes,\\n    IFightCalculator.AttackInfo memory heroAttackInfo,\\n    AdrContext memory context\\n  ) internal view {\\n    uint length = heroAttackInfo.skillTokens.length;\\n    for (uint i; i < length; ++i) {\\n      (int32[] memory values, uint8[] memory ids) = context.itemController.targetAttributes(\\n        heroAttackInfo.skillTokens[i],\\n        heroAttackInfo.skillTokenIds[i]\\n      );\\n\\n      StatLib.attributesAdd(attributes, StatLib.valuesToFullAttributesArray(values, ids));\\n    }\\n  }\\n\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...MAX_AMPLIFIER]\\n  function _collectMonsterFighterInfo(\\n    IGOC.MultiplierInfo memory multiplierInfo,\\n    IGOC.MonsterInfo storage mInfo,\\n    IGOC.GeneratedMonster memory gen,\\n    IFightCalculator.AttackInfo memory heroAttackInfo,\\n    uint heroLevel,\\n    AdrContext memory adrCtx,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    IFightCalculator.FighterInfo memory fighterInfo,\\n    uint32 rarity,\\n    IGOC.MonsterGenInfo memory genInfo\\n  ) {\\n    IFightCalculator.AttackInfo memory attackInfo;\\n\\n    rarity = gen.generated ? gen.amplifier : uint32(random_(_MAX_AMPLIFIER));\\n    (\\n      fighterInfo.fighterAttributes,\\n      fighterInfo.fighterStats.level,\\n      fighterInfo.fighterStats.experience,\\n      attackInfo,\\n      genInfo\\n    ) = _generateMonsterInfo(\\n      mInfo,\\n      rarity,\\n      monsterMultiplier(multiplierInfo.heroNgLevel),\\n      heroLevel,\\n      multiplierInfo.biome,\\n      random_\\n    );\\n\\n    _debuff(fighterInfo.fighterAttributes, heroAttackInfo, adrCtx);\\n\\n    fighterInfo.fighterStats.life = gen.generated\\n      ? uint32(gen.hp)\\n      : fighterInfo.fighterStats.life = uint32(CalcLib.max32(fighterInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.LIFE)], int32(1)));\\n\\n    fighterInfo.fighterStats.mana = uint32(fighterInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MANA)]);\\n\\n    fighterInfo.attackType = attackInfo.attackType;\\n    fighterInfo.attackToken = attackInfo.attackToken;\\n    fighterInfo.attackTokenId = attackInfo.attackTokenId;\\n    fighterInfo.race = genInfo.race;\\n\\n    return (fighterInfo, rarity, genInfo);\\n  }\\n\\n  /// @param random_ Pass _pseudoRandom here, param is required to simplify unit testing\\n  /// @param fight_ Pass FightLib.fight here, param is required to simplify unit testing\\n  function _fight(\\n    IGOC.ActionContext memory ctx,\\n    IGOC.MonsterInfo storage mInfo,\\n    IGOC.GeneratedMonster memory gen,\\n    AdrContext memory adrCtx,\\n    function (uint) internal view returns (uint) random_,\\n    function(\\n      IItemController,\\n      IFightCalculator.FightCall memory,\\n      address,\\n      function (uint) internal view returns (uint)\\n    ) internal returns (IFightCalculator.FightResult memory) fight_\\n  ) internal returns (\\n    FightInternalInfo memory fInfo,\\n    IGOC.MonsterGenInfo memory info\\n  ) {\\n    IFightCalculator.FighterInfo memory heroFightInfo;\\n    IFightCalculator.FighterInfo memory monsterFightInfo;\\n\\n    {\\n      IFightCalculator.AttackInfo memory heroAttackInfo = decodeAndCheckAttackInfo(\\n        adrCtx.itemController,\\n        IHeroController(IController(adrCtx.controller).heroController()),\\n        ctx.data,\\n        adrCtx.heroToken,\\n        adrCtx.heroTokenId\\n      );\\n\\n      // use fInfo.manaConsumed and fInfo.monsterRarity to story values temporally to avoid creation of additional vars\\n      (heroFightInfo, fInfo.manaConsumed) = _collectHeroFighterInfo(heroAttackInfo, adrCtx);\\n      (monsterFightInfo, fInfo.monsterRarity, info) = _collectMonsterFighterInfo(\\n        IGOC.MultiplierInfo({\\n          biome: ctx.biome,\\n          heroNgLevel: ctx.heroNgLevel\\n        }),\\n        mInfo,\\n        gen,\\n        heroAttackInfo,\\n        heroFightInfo.fighterStats.level,\\n        adrCtx,\\n        random_\\n      );\\n    }\\n\\n    // >>> FIGHT!\\n    IFightCalculator.FightResult memory fightResult = fight_(\\n      adrCtx.itemController,\\n      IFightCalculator.FightCall({\\n        fighterA: heroFightInfo,\\n        fighterB: monsterFightInfo,\\n        dungeonId: ctx.dungeonId,\\n        objectId: ctx.objectId,\\n        heroAdr: adrCtx.heroToken,\\n        heroId: adrCtx.heroTokenId,\\n        stageId: ctx.stageId,\\n        iteration: ctx.iteration,\\n        turn: gen.turnCounter\\n      }),\\n      ctx.sender,\\n      random_\\n    );\\n\\n    fInfo = FightInternalInfo({\\n      manaConsumed: fInfo.manaConsumed + fightResult.manaConsumedA,\\n      monsterRarity: fInfo.monsterRarity,\\n      damage: _calcDmg(int32(heroFightInfo.fighterStats.life), fightResult.healthA),\\n      heroFightInfo: heroFightInfo,\\n      monsterFightInfo: monsterFightInfo,\\n      heroLifeRegen: fightResult.healthA > int32(heroFightInfo.fighterStats.life) ? fightResult.healthA - int32(heroFightInfo.fighterStats.life) : int32(0),\\n      heroHp: fightResult.healthA,\\n      monsterHp: fightResult.healthB\\n    });\\n  }\\n\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...1e18]\\n  /// @return attributes Attributes amplified on amplifier and dungeonMultiplier\\n  /// @return level Result level in the range: [mInfo.level .. heroLevel]\\n  /// @return experience Experience amplified on amplifier and dungeonMultiplier\\n  /// @return attackInfo Attack info. For magic hero attack type monster will have melee in half hits (randomly)\\n  /// @return info Unpacked data from {mInfo}, some fields can be uninitialized, see comments to unpackMonsterInfo (!)\\n  function _generateMonsterInfo(\\n    IGOC.MonsterInfo storage mInfo,\\n    uint32 amplifier,\\n    uint dungeonMultiplier,\\n    uint heroLevel,\\n    uint biome,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    int32[] memory attributes,\\n    uint32 level,\\n    uint32 experience,\\n    IFightCalculator.AttackInfo memory attackInfo,\\n    IGOC.MonsterGenInfo memory info\\n  ) {\\n    info = unpackMonsterInfo(mInfo);\\n\\n    level = uint32(info.level);\\n    if (level < heroLevel + 1) {\\n      level = uint32(Math.min(level + ((heroLevel - level) * 10 / 15), biome * 5));\\n    }\\n\\n    if (info.attackType == uint8(IFightCalculator.AttackType.MAGIC)) {\\n      // sometimes use melee (25% chance)\\n      uint rnd = random_(1e18);\\n      if (rnd > 0.75e18) {\\n        attackInfo.attackType = IFightCalculator.AttackType.MELEE;\\n      } else {\\n        attackInfo.attackType = IFightCalculator.AttackType.MAGIC;\\n        attackInfo.attackToken = info.attackToken;\\n        attackInfo.attackTokenId = info.attackTokenId;\\n      }\\n    } else {\\n      attackInfo.attackType = IFightCalculator.AttackType(info.attackType);\\n    }\\n\\n    (attributes, experience) = generateMonsterAttributes(\\n      info.attributeIds,\\n      info.attributeValues,\\n      amplifier,\\n      dungeonMultiplier,\\n      info.experience\\n    );\\n\\n    return (attributes, level, experience, attackInfo, info);\\n  }\\n\\n  function _mintRandomItems(\\n    FightInternalInfo memory fInfo,\\n    IGOC.ActionContext memory ctx,\\n    IGOC.MonsterGenInfo memory genInfo,\\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\\n  ) internal returns (\\n    address[] memory\\n  ) {\\n    return ItemLib._mintRandomItems(\\n      ItemLib.MintItemInfo({\\n        mintItems: genInfo.mintItems,\\n        mintItemsChances: genInfo.mintItemsChances,\\n        amplifier: fInfo.monsterRarity,\\n        seed: 0,\\n        oracle: IOracle(ctx.controller.oracle()),\\n        magicFind: fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MAGIC_FIND)],\\n        destroyItems: fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DESTROY_ITEMS)],\\n        maxItems: genInfo.maxDropItems,\\n        mintDropChanceDelta: ctx.objectSubType == uint8(IGOC.ObjectSubType.BOSS_3) ? 0 : // do not reduce drop for bosses at all\\n        StatLib.mintDropChanceDelta(\\n          fInfo.heroFightInfo.fighterStats.experience,\\n          uint8(fInfo.heroFightInfo.fighterStats.level),\\n          ctx.biome\\n        ),\\n        mintDropChanceNgLevelMultiplier: _getMintDropChanceNgLevelMultiplier(ctx)\\n      }),\\n      nextPrng_\\n    );\\n  }\\n\\n  /// @return drop chance multiplier, decimals 1e18; result value is guaranteed to be <= 1e18\\n  function _getMintDropChanceNgLevelMultiplier(IGOC.ActionContext memory ctx) internal view returns (uint) {\\n    return Math.min(1e18, RewardsPoolLib.dropChancePercent(\\n      IDungeonFactory(ctx.controller.dungeonFactory()).maxAvailableBiome(),\\n      IHeroController(ctx.controller.heroController()).maxOpenedNgLevel(),\\n      ctx.heroNgLevel\\n    ));\\n  }\\n\\n  //endregion ------------------------ Internal calculations\\n\\n  //region ------------------------ Utils\\n\\n  function _context(IGOC.ActionContext memory ctx) internal view returns (AdrContext memory context) {\\n    context = AdrContext({\\n      sender: ctx.sender,\\n      heroToken: ctx.heroToken,\\n      heroTokenId: ctx.heroTokenId,\\n      controller: ctx.controller,\\n      oracle: IOracle(ctx.controller.oracle()),\\n      statController: IStatController(ctx.controller.statController()),\\n      itemController: IItemController(ctx.controller.itemController())\\n    });\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 gen) internal pure returns (IGOC.GeneratedMonster memory result) {\\n    (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) = gen.unpackGeneratedMonster();\\n    result = IGOC.GeneratedMonster({\\n      generated: generated,\\n      amplifier: amplifier,\\n      hp: hp,\\n      turnCounter: turnCounter\\n    });\\n  }\\n\\n  function packGeneratedMonster(IGOC.GeneratedMonster memory gen) internal pure returns (bytes32) {\\n    return PackingLib.packGeneratedMonster(gen.generated, gen.amplifier, gen.hp, gen.turnCounter);\\n  }\\n\\n  function packMonsterInfo(IGOC.MonsterGenInfo memory mInfo, IGOC.MonsterInfo storage info) internal {\\n    info.attributes = mInfo.attributeValues.toBytes32ArrayWithIds(mInfo.attributeIds);\\n    info.stats = PackingLib.packMonsterStats(mInfo.level, mInfo.race, mInfo.experience, mInfo.maxDropItems);\\n    info.attackInfo = PackingLib.packAttackInfo(mInfo.attackToken, mInfo.attackTokenId, mInfo.attackType);\\n\\n    uint len = mInfo.mintItems.length;\\n    bytes32[] memory mintItems = new bytes32[](len);\\n\\n    for (uint i; i < len; ++i) {\\n      mintItems[i] = mInfo.mintItems[i].packItemMintInfo(mInfo.mintItemsChances[i]);\\n    }\\n\\n    info.mintItems = mintItems;\\n  }\\n\\n  /// @return Attention: Following fields are not initialized: biome, subType, monsterId\\n  function unpackMonsterInfo(IGOC.MonsterInfo storage mInfo) internal view returns (IGOC.MonsterGenInfo memory) {\\n    IGOC.MonsterGenInfo memory result;\\n    (result.attributeValues, result.attributeIds) = mInfo.attributes.toInt32ArrayWithIds();\\n    (result.level, result.race, result.experience, result.maxDropItems) = mInfo.stats.unpackMonsterStats();\\n    (result.attackToken, result.attackTokenId, result.attackType) = mInfo.attackInfo.unpackAttackInfo();\\n\\n    uint len = mInfo.mintItems.length;\\n    result.mintItems = new address[](len);\\n    result.mintItemsChances = new uint32[](len);\\n\\n    for (uint i = 0; i < len; i++) {\\n      (result.mintItems[i], result.mintItemsChances[i]) = mInfo.mintItems[i].unpackItemMintInfo();\\n    }\\n\\n    // Attention: result.biome, result.subType, result.monsterId are not initialized\\n    return result;\\n  }\\n\\n  /// @notice Decode attack info. Ensure that attack token belongs to the hero.\\n  /// Ensure that skill tokens belong to the hero OR to the current helper (SIP-001)\\n  function decodeAndCheckAttackInfo(\\n    IItemController ic,\\n    IHeroController heroController,\\n    bytes memory data,\\n    address heroToken,\\n    uint heroId\\n  ) internal view returns (IFightCalculator.AttackInfo memory) {\\n    (IFightCalculator.AttackInfo memory attackInfo) = abi.decode(data, (IFightCalculator.AttackInfo));\\n\\n    if (uint(attackInfo.attackType) == 0) revert IAppErrors.UnknownAttackType(uint(attackInfo.attackType));\\n\\n    if (attackInfo.attackToken != address(0)) {\\n      (address h, uint hId) = ic.equippedOn(attackInfo.attackToken, attackInfo.attackTokenId);\\n      if (heroToken != h || hId != heroId) revert IAppErrors.NotYourAttackItem();\\n    }\\n\\n    (address helperHeroToken, uint helperHeroId) = heroController.heroReinforcementHelp(heroToken, heroId);\\n    for (uint i; i < attackInfo.skillTokens.length; ++i) {\\n      (address h, uint hId) = ic.equippedOn(attackInfo.skillTokens[i], attackInfo.skillTokenIds[i]);\\n      if (\\n        (heroToken != h || hId != heroId)\\n        && ((helperHeroToken == address(0)) || (helperHeroToken != h || helperHeroId != hId))\\n      ) revert IAppErrors.NotYourBuffItem();\\n    }\\n\\n    return attackInfo;\\n  }\\n\\n  /// @dev Monsters power is increased on 100% with each increment of hero NG_LEVEL\\n  function monsterMultiplier(uint8 heroNgLevel) internal pure returns (uint) {\\n    return _MONSTER_MULTIPLIER_NGP_BASE * uint(heroNgLevel);\\n  }\\n\\n  function amplifyMonsterAttribute(int32 value, uint32 amplifier, uint dungeonMultiplier) internal pure returns (int32) {\\n    if (value == 0) {\\n      return 0;\\n    }\\n\\n    int destValue = int(value)\\n      + (int(value) * int(uint(amplifier)) / int(uint(_MAX_AMPLIFIER)))\\n      + (int(value) * int(dungeonMultiplier) / int(uint(_MAX_AMPLIFIER)));\\n    if (destValue > type(int32).max || destValue < type(int32).min) revert IAppErrors.IntValueOutOfRange(destValue);\\n\\n    return int32(destValue);\\n  }\\n\\n  /// @dev A wrapper around {CalcLib.pseudoRandom} to pass it as param (to be able to implement unit tests}\\n  function _pseudoRandom(uint max) internal view returns (uint) {\\n    return CalcLib.pseudoRandom(max);\\n  }\\n\\n  /// @notice Amplify values of the attributes and of the experience\\n  ///         using randomly generated {amplifier} and {dungeonMultiplier}.\\n  ///         Attributes = amplify(ids, values), experience = amplify(baseExperience)\\n  function generateMonsterAttributes(\\n    uint8[] memory ids,\\n    int32[] memory values,\\n    uint32 amplifier,\\n    uint dungeonMultiplier,\\n    uint32 baseExperience\\n  ) internal pure returns (\\n    int32[] memory attributes,\\n    uint32 experience\\n  ) {\\n    // reduce random\\n    amplifier = amplifier / 4;\\n\\n    attributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < ids.length; ++i) {\\n      attributes[ids[i]] = amplifyMonsterAttribute(values[i], amplifier, dungeonMultiplier);\\n    }\\n    experience = uint32(amplifyMonsterAttribute(int32(baseExperience), amplifier, 0));\\n  }\\n\\n  function _calcDmg(int32 heroLifeBefore, int32 heroLifeAfter) internal pure returns (int32 damage) {\\n    return heroLifeAfter == 0\\n      ? heroLifeBefore\\n      : heroLifeBefore - CalcLib.minI32(heroLifeAfter, heroLifeBefore);\\n  }\\n\\n  function _getMonsterCounterIndex(uint32 objectId) internal pure returns (bytes32) {\\n    return bytes32(abi.encodePacked(\\\"MONSTER_\\\", StringLib._toString(uint(objectId))));\\n  }\\n  //endregion ------------------------ Utils\\n\\n\\n}\\n\",\"keccak256\":\"0xaa4bc308dba6ffcc4dcb57b793b257374d7f4a415892ad268d70ecec8d1fa004\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PackingLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\n\\nlibrary PackingLib {\\n\\n  //////////////////////////\\n  // ---- PACKING LOGIC ----\\n  //////////////////////////\\n\\n  //region ------------------------------------ COMMON\\n\\n  function packNftId(address token, uint id) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert IAppErrors.TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n  }\\n\\n  function unpackNftId(bytes32 data) internal pure returns (address token, uint id) {\\n    token = address(uint160(uint(data)));\\n    id = uint(data) >> 160;\\n  }\\n\\n  function packAddressWithAmount(address token, uint amount) internal pure returns (bytes32 data) {\\n    if (amount > uint(type(uint96).max)) revert IAppErrors.TooHighValue(amount);\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(uint96(amount))) << 160;\\n  }\\n\\n  function unpackAddressWithAmount(bytes32 data) internal pure returns (address token, uint amount) {\\n    token = address(uint160(uint(data)));\\n    amount = uint(data) >> 160;\\n  }\\n\\n  function packItemMintInfo(address item, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(chance)) << 160;\\n  }\\n\\n  function unpackItemMintInfo(bytes32 data) internal pure returns (address item, uint32 chance) {\\n    item = address(uint160(uint(data)));\\n    chance = uint32(uint(data) >> 160);\\n  }\\n\\n  /// @param customDataIndex We assume, that two lowest bytes of this string are always zero\\n  /// So, the string looks like following: 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// Last 2 bytes will be used to encode {value}\\n  function packCustomDataChange(bytes32 customDataIndex, int16 value) internal pure returns (bytes32 data) {\\n    if (uint(customDataIndex) != (uint(customDataIndex) >> 16) << 16) revert IAppErrors.IncompatibleInputString();\\n    data = bytes32(uint(customDataIndex));\\n    data |= bytes32(uint(uint16(value)));\\n  }\\n\\n  function unpackCustomDataChange(bytes32 data) internal pure returns (bytes32 customDataIndex, int16 value) {\\n    customDataIndex = bytes32((uint(data) >> 16) << 16);\\n    value = int16(int(uint(uint16(uint(data)))));\\n  }\\n\\n  /// @dev min(uint64) + max(uint64) + isHeroData/isMandatory(uint8)\\n  function packCustomDataRequirements(uint64 min, uint64 max, bool key) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(min));\\n    data |= bytes32(uint(max)) << 64;\\n    data |= bytes32(uint(key ? uint8(1) : uint8(0))) << (64 + 64);\\n  }\\n\\n  function unpackCustomDataRequirements(bytes32 data) internal pure returns (uint64 min, uint64 max, bool key) {\\n    min = uint64(uint(data));\\n    max = uint64(uint(data) >> 64);\\n    key = uint8(uint(data) >> (64 + 64)) == uint8(1);\\n  }\\n\\n  function packStatsChange(\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(experience));\\n    data |= bytes32(uint(uint32(heal))) << 32;\\n    data |= bytes32(uint(uint32(manaRegen))) << (32 + 32);\\n    data |= bytes32(uint(uint32(lifeChancesRecovered))) << (32 + 32 + 32);\\n    data |= bytes32(uint(uint32(damage))) << (32 + 32 + 32 + 32);\\n    data |= bytes32(uint(uint32(manaConsumed))) << (32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackStatsChange(bytes32 data) internal pure returns (\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) {\\n    experience = uint32(uint(data));\\n    heal = int32(int(uint(data) >> 32));\\n    manaRegen = int32(int(uint(data) >> (32 + 32)));\\n    lifeChancesRecovered = int32(int(uint(data) >> (32 + 32 + 32)));\\n    damage = int32(int(uint(data) >> (32 + 32 + 32 + 32)));\\n    manaConsumed = int32(int(uint(data) >> (32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packNftIdWithValue(address token, uint id, uint32 value) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert IAppErrors.TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n    serialized |= bytes32(uint(value)) << 160 + 64;\\n  }\\n\\n  function unpackNftIdWithValue(bytes32 data) internal pure returns (address token, uint id, uint32 value) {\\n    token = address(uint160(uint(data)));\\n    id = uint64(uint(data) >> 160);\\n    value = uint32(uint(data) >> 160 + 64);\\n  }\\n  //endregion ------------------------------------ COMMON\\n\\n  //region ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(bytes20(objectAddress));\\n    packedData |= bytes32(uint(objectId) << 32);\\n    packedData |= bytes32(uint(objectType) << 24);\\n  }\\n\\n  function unpackMapObject(bytes32 packedData) internal pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\\n    objectAddress = address(bytes20(packedData));\\n    objectId = uint64(uint(packedData) >> 32);\\n    objectType = uint8(uint(packedData) >> 24);\\n  }\\n\\n  function packCoordinate(uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(x));\\n    packedData |= bytes32(uint(y) << 128);\\n  }\\n\\n  function unpackCoordinate(bytes32 packedData) internal pure returns (uint128 x, uint128 y) {\\n    x = uint128(uint(packedData));\\n    y = uint128(uint(packedData) >> 128);\\n  }\\n\\n  /// @param x Assume x <= max uint64\\n  /// @param y Assume y <= max uint64\\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    // 256 => 128 + 128;\\n    // 1) 128 is used for biomeMapFieldId, territoryNumber and probably other fields in the future\\n    // 2) 128 is used to store x, y as uint64, uint64\\n\\n    // we will use uint64 for coordinates assuming it is more than enough for biome map\\n    packedData = bytes32(uint(biomeMapFieldId));\\n    packedData |= bytes32(uint(territoryNumber) << (8));\\n    packedData |= bytes32(uint(uint64(x)) << 128);\\n    packedData |= bytes32(uint(uint64(y)) << (64 + 128));\\n  }\\n\\n  function unpackBattlefieldId(bytes32 packedData) internal pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\\n    biomeMapFieldId = uint8(uint(packedData));\\n    territoryNumber = uint8(uint(packedData) >> (8));\\n    x = uint128(uint64(uint(packedData) >> (128)));\\n    y = uint128(uint64(uint(packedData) >> (64 + 128)));\\n  }\\n  //endregion ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  //region ------------------------------------ REINFORCEMENT\\n\\n  function packReinforcementHeroInfo(uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(biome));\\n    packedData |= bytes32(uint(score) << 8);\\n    packedData |= bytes32(uint(fee) << (8 + 128));\\n    packedData |= bytes32(uint(stakeTs) << (8 + 128 + 8));\\n  }\\n\\n  function unpackReinforcementHeroInfo(bytes32 packedData) internal pure returns (uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) {\\n    biome = uint8(uint(packedData));\\n    score = uint128(uint(packedData) >> 8);\\n    fee = uint8(uint(packedData) >> (8 + 128));\\n    stakeTs = uint64(uint(packedData) >> (8 + 128 + 8));\\n  }\\n\\n  function packConfigReinforcementV2(uint32 min, uint32 max, uint32 lowDivider, uint32 highDivider, uint8 levelLimit) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(min));\\n    packedData |= bytes32(uint(max) << 32);\\n    packedData |= bytes32(uint(lowDivider) << 64);\\n    packedData |= bytes32(uint(highDivider) << 96);\\n    packedData |= bytes32(uint(levelLimit) << 128);\\n  }\\n\\n  function unpackConfigReinforcementV2(bytes32 packedData) internal pure returns (uint32 min, uint32 max, uint32 lowDivider, uint32 highDivider, uint8 levelLimit) {\\n    min = uint32(uint(packedData));\\n    max = uint32(uint(packedData) >> 32);\\n    lowDivider = uint32(uint(packedData) >> 64);\\n    highDivider = uint32(uint(packedData) >> 96);\\n    levelLimit = uint8(uint(packedData) >> 128);\\n  }\\n  //endregion ------------------------------------ REINFORCEMENT\\n\\n  //region ------------------------------------ DUNGEON\\n\\n  function packDungeonKey(address heroAdr, uint80 heroId, uint16 dungLogicNum) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(dungLogicNum)) << (160 + 80);\\n  }\\n\\n  function unpackDungeonKey(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 dungLogicNum) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    dungLogicNum = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  // --- GAME OBJECTS ---\\n\\n  function packIterationKey(address heroAdr, uint64 heroId, uint32 objId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(objId)) << (160 + 64);\\n  }\\n\\n  function unpackIterationKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint32 objId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    objId = uint32(uint(data) >> (160 + 64));\\n  }\\n\\n  function packMonsterStats(\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(level));\\n    data |= bytes32(uint(race)) << 8;\\n    data |= bytes32(uint(experience)) << (8 + 8);\\n    data |= bytes32(uint(maxDropItems)) << (8 + 8 + 32);\\n  }\\n\\n  function unpackMonsterStats(bytes32 data) internal pure returns (\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) {\\n    level = uint8(uint(data));\\n    race = uint8(uint(data) >> 8);\\n    experience = uint32(uint(data) >> (8 + 8));\\n    maxDropItems = uint8(uint(data) >> (8 + 8 + 32));\\n  }\\n\\n  function packAttackInfo(\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(attackToken)));\\n    data |= bytes32(uint(attackTokenId)) << 160;\\n    data |= bytes32(uint(attackType)) << (160 + 64);\\n  }\\n\\n  function unpackAttackInfo(bytes32 data) internal pure returns (\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) {\\n    attackToken = address(uint160(uint(data)));\\n    attackTokenId = uint64(uint(data) >> 160);\\n    attackType = uint8(uint(data) >> (160 + 64));\\n  }\\n\\n  function packPlayedObjKey(address heroAdr, uint64 heroId, uint8 oType, uint8 biome) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(oType)) << (160 + 64);\\n    data |= bytes32(uint(biome)) << (160 + 64 + 8);\\n  }\\n\\n  function unpackPlayedObjKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint8 oType, uint8 biome) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    oType = uint8(uint(data) >> (160 + 64));\\n    biome = uint8(uint(data) >> (160 + 64 + 8));\\n  }\\n\\n  function packGeneratedMonster(bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint8(generated ? 1 : 0)));\\n    data |= bytes32(uint(amplifier)) << 8;\\n    data |= bytes32(uint(uint32(hp))) << (8 + 32);\\n    data |= bytes32(uint(turnCounter)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 data) internal pure returns (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) {\\n    generated = uint8(uint(data)) == uint8(1);\\n    amplifier = uint32(uint(data) >> 8);\\n    hp = int32(int(uint(data) >> (8 + 32)));\\n    turnCounter = uint8(uint(data) >> (8 + 32 + 32));\\n  }\\n  //endregion ------------------------------------ DUNGEON\\n\\n  //region ------------------------------------ ITEMS\\n\\n  /// @notice itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n  /// @param itemType This is ItemType enum\\n  function packItemMeta(\\n    uint8 itemMetaType,\\n    uint8 itemLvl,\\n    uint8 itemType,\\n    uint16 baseDurability,\\n    uint8 defaultRarity,\\n    uint8 minAttr,\\n    uint8 maxAttr,\\n    uint32 manaCost,\\n    IStatController.CoreAttributes memory req\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(itemMetaType));\\n    data |= bytes32(uint(itemLvl)) << 8;\\n    data |= bytes32(uint(itemType)) << (8 + 8);\\n    data |= bytes32(uint(baseDurability)) << (8 + 8 + 8);\\n    data |= bytes32(uint(defaultRarity)) << (8 + 8 + 8 + 16);\\n    data |= bytes32(uint(minAttr)) << (8 + 8 + 8 + 16 + 8);\\n    data |= bytes32(uint(maxAttr)) << (8 + 8 + 8 + 16 + 8 + 8);\\n    data |= bytes32(uint(manaCost)) << (8 + 8 + 8 + 16 + 8 + 8 + 8);\\n    data |= bytes32(uint(int(req.strength))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32);\\n    data |= bytes32(uint(int(req.dexterity))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32);\\n    data |= bytes32(uint(int(req.vitality))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(req.energy))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemMeta(bytes32 data) internal pure returns (IItemController.ItemMeta memory) {\\n    IItemController.ItemMeta memory result;\\n\\n    result.itemMetaType = uint8(uint(data));\\n    result.itemLevel = uint8(uint(data) >> 8);\\n    result.itemType = IItemController.ItemType(uint8(uint(data) >> (8 + 8)));\\n    result.baseDurability = uint16(uint(data) >> (8 + 8 + 8));\\n    result.defaultRarity = uint8(uint(data) >> (8 + 8 + 8 + 16));\\n    result.minRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8));\\n    result.maxRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8));\\n    result.manaCost = uint32(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8));\\n    result.requirements.strength = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32)));\\n    result.requirements.dexterity = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32)));\\n    result.requirements.vitality = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32)));\\n    result.requirements.energy = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32)));\\n\\n    return result;\\n  }\\n\\n  function packItemGenerateInfo(uint8 id, int32 min, int32 max, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(id));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(chance)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32 data) internal pure returns (uint8 id, int32 min, int32 max, uint32 chance) {\\n    id = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    chance = uint32(uint(data) >> (8 + 32 + 32));\\n  }\\n\\n  function packItemAttackInfo(\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attackType));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(int(factorStr))) << (8 + 32 + 32);\\n    data |= bytes32(uint(int(factorDex))) << (8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorVit))) << (8 + 32 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorEng))) << (8 + 32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 data) internal pure returns (\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) {\\n    attackType = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    factorStr = int32(int(uint(data) >> (8 + 32 + 32)));\\n    factorDex = int32(int(uint(data) >> (8 + 32 + 32 + 32)));\\n    factorVit = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32)));\\n    factorEng = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packItemInfo(uint8 rarity, uint8 augmentationLevel, uint16 durability) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(rarity));\\n    data |= bytes32(uint(augmentationLevel)) << 8;\\n    data |= bytes32(uint(durability)) << (8 + 8);\\n  }\\n\\n  function unpackItemInfo(bytes32 data) internal pure returns (uint8 rarity, uint8 augmentationLevel, uint16 durability) {\\n    rarity = uint8(uint(data));\\n    augmentationLevel = uint8(uint(data) >> 8);\\n    durability = uint16(uint(data) >> (8 + 8));\\n  }\\n  //endregion ------------------------------------ ITEMS\\n\\n  //region ------------------------------------ STORIES\\n\\n  function packStoryPageId(uint16 storyId, uint16 pageId, uint8 heroClass) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n  }\\n\\n  function unpackStoryPageId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n  }\\n\\n  function packStoryAnswerId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n  }\\n\\n  function unpackStoryAnswerId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n  }\\n\\n  function packStoryNextPagesId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(resultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryNextPagesId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    resultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryAttributeRequirement(uint8 attributeIndex, int32 value, bool isCore) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attributeIndex));\\n    data |= bytes32(uint(uint32(value))) << 8;\\n    data |= bytes32(uint(isCore ? uint8(1) : uint8(0))) << (8 + 32);\\n  }\\n\\n  function unpackStoryAttributeRequirement(bytes32 data) internal pure returns (uint8 attributeIndex, int32 value, bool isCore) {\\n    attributeIndex = uint8(uint(data));\\n    value = int32(int(uint(data) >> 8));\\n    isCore = uint8(uint(data) >> (8 + 32)) == uint8(1);\\n  }\\n\\n  function packStoryItemRequirement(address item, bool requireItemBurn, bool requireItemEquipped) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(requireItemBurn ? uint8(1) : uint8(0))) << 160;\\n    data |= bytes32(uint(requireItemEquipped ? uint8(1) : uint8(0))) << (160 + 8);\\n  }\\n\\n  function unpackStoryItemRequirement(bytes32 data) internal pure returns (address item, bool requireItemBurn, bool requireItemEquipped) {\\n    item = address(uint160(uint(data)));\\n    requireItemBurn = uint8(uint(data) >> 160) == uint8(1);\\n    requireItemEquipped = uint8(uint(data) >> (160 + 8)) == uint8(1);\\n  }\\n\\n  /// @dev max amount is 309,485,009 for token with 18 decimals\\n  function packStoryTokenRequirement(address token, uint88 amount, bool requireTransfer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(amount)) << 160;\\n    data |= bytes32(uint(requireTransfer ? uint8(1) : uint8(0))) << (160 + 88);\\n  }\\n\\n  function unpackStoryTokenRequirement(bytes32 data) internal pure returns (address token, uint88 amount, bool requireTransfer) {\\n    token = address(uint160(uint(data)));\\n    amount = uint88(uint(data) >> 160);\\n    requireTransfer = uint8(uint(data) >> (160 + 88)) == uint8(1);\\n  }\\n\\n  function packStoryCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(customDataResultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryCustomDataResult(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    customDataResultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryHeroState(uint16 pageId, uint40 heroLastActionTS) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(pageId));\\n    data |= bytes32(uint(heroLastActionTS)) << 16;\\n  }\\n\\n  function unpackStoryHeroState(bytes32 data) internal pure returns (uint16 pageId, uint40 heroLastActionTS) {\\n    pageId = uint16(uint(data));\\n    heroLastActionTS = uint40(uint(data) >> 16);\\n  }\\n\\n  function packStoryHeroStateId(address heroAdr, uint80 heroId, uint16 storyId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(storyId)) << (160 + 80);\\n  }\\n\\n  function unpackStoryHeroStateId(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 storyId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    storyId = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  function packStorySimpleRequirement(uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(randomRequirement));\\n    data |= bytes32(uint(delayRequirement)) << 32;\\n    data |= bytes32(uint(isFinalAnswer ? uint8(1) : uint8(0))) << (32 + 32);\\n  }\\n\\n  function unpackStorySimpleRequirement(bytes32 data) internal pure returns (uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) {\\n    randomRequirement = uint32(uint(data));\\n    delayRequirement = uint32(uint(data) >> 32);\\n    isFinalAnswer = uint8(uint(data) >> (32 + 32)) == uint8(1);\\n  }\\n\\n  function packBreakInfo(uint8 slot, uint64 chance, bool stopIfBroken) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(slot));\\n    data |= bytes32(uint(chance)) << 8;\\n    data |= bytes32(uint(stopIfBroken ? uint8(1) : uint8(0))) << (8 + 64);\\n  }\\n\\n  function unpackBreakInfo(bytes32 data) internal pure returns (uint8 slot, uint64 chance, bool stopIfBurned) {\\n    slot = uint8(uint(data));\\n    chance = uint64(uint(data) >> 8);\\n    stopIfBurned = uint8(uint(data) >> (8 + 64)) == uint8(1);\\n  }\\n  //endregion ------------------------------------ STORIES\\n\\n  //region ------------------------------------ Hero controller\\n  function packTierHero(uint8 tier, address hero) internal pure returns (bytes32 packedTierHero) {\\n    packedTierHero = bytes32(uint(tier));\\n    packedTierHero |= bytes32(uint(uint160(hero)) << 8);\\n  }\\n\\n  function unpackTierHero(bytes32 packedTierHero) internal pure returns (uint8 tier, address hero) {\\n    tier = uint8(uint(packedTierHero));\\n    hero = address(uint160(uint(packedTierHero) >> 8));\\n  }\\n\\n  //endregion ------------------------------------ Hero controller\\n\\n  ////////////////////////////////////////////////////////////////////////////////////\\n  // ---- ARRAYS LOGIC ----\\n  ////////////////////////////////////////////////////////////////////////////////////\\n\\n  //region ------------------------------------ SIMPLE ARRAYS\\n\\n\\n  function packUint8Array(uint8[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 32) revert IAppErrors.OutOfBounds(len, 32);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 8);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {packUint8Array} for small number of items\\n  ///         It allows to exclude dynamic array creation.\\n  function packUint8Array3(uint8 a, uint8 b, uint8 c) internal pure returns (bytes32) {\\n    bytes32 result = bytes32(uint(a));\\n    result |= bytes32(uint(b)) << (1 * 8);\\n    result |= bytes32(uint(c)) << (2 * 8);\\n    return result;\\n  }\\n\\n\\n  function unpackUint8Array(bytes32 data) internal pure returns (uint8[] memory) {\\n    uint8[] memory result = new uint8[](32);\\n    for (uint i = 0; i < 32; i++) {\\n      result[i] = uint8(uint(data) >> (i * 8));\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {unpackUint8Array} for small number of items\\n  ///         It allows to exclude only first 3 values\\n  function unpackUint8Array3(bytes32 data) internal pure returns (uint8 a, uint8 b, uint8 c) {\\n    a = uint8(uint(data));\\n    b = uint8(uint(data) >> (1 * 8));\\n    c = uint8(uint(data) >> (2 * 8));\\n  }\\n\\n  function changeUnit8ArrayWithCheck(bytes32 data, uint index, uint8 value, uint8 expectedPrevValue) internal pure returns (bytes32 newData) {\\n    uint8[] memory arr = unpackUint8Array(data);\\n    if (arr[index] != expectedPrevValue) revert IAppErrors.UnexpectedValue(uint(expectedPrevValue), uint(arr[index]));\\n    arr[index] = value;\\n    return packUint8Array(arr);\\n  }\\n\\n  function packInt32Array(int32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert IAppErrors.OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i; i < len; i++) {\\n      result |= bytes32(uint(uint32(data[i]))) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackInt32Array(bytes32 data) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = int32(int(uint(data) >> (i * 32)));\\n    }\\n    return result;\\n  }\\n\\n  function packUint32Array(uint32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert IAppErrors.OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackUint32Array(bytes32 data) internal pure returns (uint32[] memory) {\\n    uint32[] memory result = new uint32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = uint32(uint(data) >> (i * 32));\\n    }\\n    return result;\\n  }\\n  //endregion ------------------------------------ SIMPLE ARRAYS\\n\\n  //region ------------------------------------ COMPLEX ARRAYS\\n\\n  // We should represent arrays without concrete size.\\n  // For this reason we must not revert IAppErrors.on out of bounds but return zero value instead.\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getInt32AsInt24(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n//    if (idx / 8 >= arr.length) {\\n//      return int32(0);\\n//    }\\n//    return int32(int24(int(uint(arr[idx / 8]) >> ((idx % 8) * 32))));\\n//  }\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getUnit8From32Step(bytes32[] memory arr, uint idx) internal pure returns (uint8) {\\n//    if (idx / 8 >= arr.length) {\\n//      return uint8(0);\\n//    }\\n//    return uint8(uint(arr[idx / 8]) >> ((idx % 8) * 32 + 24));\\n//  }\\n\\n  function getInt32Memory(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function getInt32(bytes32[] storage arr, uint idx) internal view returns (int32) {\\n    // additional gas usage, but we should not revert IAppErrors.on out of bounds\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function setInt32(bytes32[] storage arr, uint idx, int32 value) internal {\\n    uint pos = idx / 8;\\n    uint shift = (idx % 8) * 32;\\n\\n    uint curLength = arr.length;\\n    if (pos >= curLength) {\\n      arr.push(0);\\n      for (uint i = curLength; i < pos; ++i) {\\n        arr.push(0);\\n      }\\n    }\\n\\n    arr[pos] = bytes32(uint(arr[pos]) & ~(uint(0xffffffff) << shift) | (uint(uint32(value)) & 0xffffffff) << shift);\\n  }\\n\\n  /// @notice Increment {idx}-th item on {value}\\n  function changeInt32(bytes32[] storage arr, uint idx, int32 value) internal returns (int32 newValue, int32 change) {\\n    int32 cur = int32(int(getInt32(arr, idx)));\\n    int newValueI = int(cur) + int(value);\\n    newValue = int32(newValueI);\\n    change = int32(newValueI - int(cur));\\n\\n    setInt32(arr, idx, newValue);\\n  }\\n\\n  function toInt32Array(bytes32[] memory arr, uint size) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](size);\\n    for (uint i = 0; i < arr.length; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= size) break;\\n        result[idx] = getInt32Memory(arr, idx);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array\\n  function toBytes32Array(int32[] memory arr) internal pure returns (bytes32[] memory) {\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n        result[i] |= bytes32(uint(uint32(arr[idx]))) << (j * 32);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array using last 8bytes for ids\\n  ///      we can not use zero values coz will not able to properly unpack it later\\n  function toBytes32ArrayWithIds(int32[] memory arr, uint8[] memory ids) internal pure returns (bytes32[] memory) {\\n    if (arr.length != ids.length) revert IAppErrors.LengthsMismatch();\\n\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n\\n        if (arr[idx] > type(int24).max || arr[idx] < type(int24).min) revert IAppErrors.IntOutOfRange(int(arr[idx]));\\n        if (arr[idx] == 0) revert IAppErrors.ZeroValue();\\n        result[i] |= bytes32(uint(uint24(int24(arr[idx])))) << (j * 32);\\n        result[i] |= bytes32(uint(ids[idx])) << (j * 32 + 24);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev we do not know exact size of array, assume zero values is not acceptable for this array\\n  function toInt32ArrayWithIds(bytes32[] memory arr) internal pure returns (int32[] memory values, uint8[] memory ids) {\\n    uint len = arr.length;\\n    uint size = len * 8;\\n    int32[] memory valuesTmp = new int32[](size);\\n    uint8[] memory idsTmp = new uint8[](size);\\n    uint counter;\\n    for (uint i = 0; i < len; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        // if (idx >= size) break;  // it looks like a useless check\\n        valuesTmp[idx] = int32(int24(int(uint(arr[i]) >> (j * 32)))); // getInt32AsInt24(arr, idx);\\n        idsTmp[idx] = uint8(uint(arr[i]) >> (j * 32 + 24)); // getUnit8From32Step(arr, idx);\\n        if (valuesTmp[idx] == 0) {\\n          break;\\n        }\\n        counter++;\\n      }\\n    }\\n\\n    values = new int32[](counter);\\n    ids = new uint8[](counter);\\n    for (uint i; i < counter; ++i) {\\n      values[i] = valuesTmp[i];\\n      ids[i] = idsTmp[i];\\n    }\\n  }\\n  //endregion ------------------------------------ COMPLEX ARRAYS\\n\\n  //region ------------------------------------ Guilds\\n  /// @dev ShelterID is uint. But in the code we assume that this ID can be stored as uint64 (see auctions)\\n  /// @param biome 1, 2, 3...\\n  /// @param shelterLevel 1, 2 or 3.\\n  /// @param shelterIndex 0, 1, 2 ...\\n  function packShelterId(uint8 biome, uint8 shelterLevel, uint8 shelterIndex) internal pure returns (uint) {\\n    return uint(biome) | (uint(shelterLevel) << 8) | (uint(shelterIndex) << 16);\\n  }\\n\\n  function unpackShelterId(uint shelterId) internal pure returns (uint8 biome, uint8 shelterLevel, uint8 shelterIndex) {\\n    return (uint8(shelterId), uint8(shelterId >> 8), uint8(shelterId >> 16));\\n  }\\n  //endregion ------------------------------------ Guilds\\n\\n  //region ------------------------------------ Metadata of IItemController.OtherSubtypeKind\\n\\n  function getOtherItemTypeKind(bytes memory packedData) internal pure returns (IItemController.OtherSubtypeKind) {\\n    bytes32 serialized;\\n    assembly {\\n      serialized := mload(add(packedData, 32))\\n    }\\n    uint8 kind = uint8(uint(serialized));\\n    if (kind == 0 || kind >= uint8(IItemController.OtherSubtypeKind.END_SLOT)) revert IAppErrors.IncorrectOtherItemTypeKind(kind);\\n    return IItemController.OtherSubtypeKind(kind);\\n  }\\n\\n  function packOtherItemReduceFragility(uint value) internal pure returns (bytes memory packedData) {\\n    bytes32 serialized = bytes32(uint(uint8(IItemController.OtherSubtypeKind.REDUCE_FRAGILITY_1)));\\n    serialized |= bytes32(uint(uint248(value))) << 8;\\n    return bytes.concat(serialized);\\n  }\\n\\n  function unpackOtherItemReduceFragility(bytes memory packedData) internal pure returns (uint) {\\n    bytes32 serialized;\\n    assembly {\\n      serialized := mload(add(packedData, 32))\\n    }\\n    uint8 kind = uint8(uint(serialized));\\n    if (kind != uint8(IItemController.OtherSubtypeKind.REDUCE_FRAGILITY_1)) revert IAppErrors.IncorrectOtherItemTypeKind(kind);\\n    uint value = uint248(uint(serialized) >> 8);\\n    return value;\\n  }\\n  //endregion ------------------------------------ Metadata of IItemController.OtherSubtypeKind\\n}\\n\",\"keccak256\":\"0xad88fc3fd2d436b3593cfbd2e19a838bfa73c5eaf31838ea2bdf9c84de38b65f\",\"license\":\"BUSL-1.1\"},\"contracts/lib/RewardsPoolLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IGameToken.sol\\\";\\nimport \\\"../interfaces/IRewardsPool.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../proxy/Controllable.sol\\\";\\n\\nlibrary RewardsPoolLib {\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"rewards.pool.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant REWARDS_POOL_STORAGE_LOCATION = 0x6ad655e44097c54b487e7c9215cc0bbf37bbe7fc2f8034e2ddf6749036fda500; // rewards.pool.main\\n\\n  //region ------------------------ Storage\\n\\n  function _S() internal pure returns (IRewardsPool.MainState storage s) {\\n    assembly {\\n      s.slot := REWARDS_POOL_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n  //endregion ------------------------ Storage\\n\\n  //region ------------------------ Restrictions\\n  function onlyHeroController(IController controller) internal view {\\n    if (controller.heroController() != msg.sender) revert IAppErrors.ErrorNotHeroController(msg.sender);\\n  }\\n\\n  function _onlyDeployer(IController controller) internal view {\\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n\\n  function _onlyGovernance(IController controller) internal view {\\n    if (controller.governance() != msg.sender) revert IAppErrors.NotGovernance(msg.sender);\\n  }\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ View\\n  function balanceOfToken(address token) internal view returns (uint) {\\n    return IERC20(token).balanceOf(address(this));\\n  }\\n\\n  function baseAmount(address token) internal view returns (uint) {\\n    return _S().baseAmounts[token];\\n  }\\n\\n  /// @param maxBiome Max available biome, see {IDungeonFactory.state.maxBiome}\\n  /// @param maxNgLevel Max opened NG_LEVEL, see {IHeroController.state.maxOpenedNgLevel}\\n  /// @param biome Current hero biome [0..19\\n  /// @param heroNgLevel Current hero NG_LVL [0..99]\\n  /// @return Reward percent, decimals 18\\n  function rewardPercent(uint maxBiome, uint maxNgLevel, uint biome, uint heroNgLevel) internal pure returns (uint) {\\n    // biome_sum = max biome*(max biome+1)/2\\n    // biome_weight = biome / biome_sum\\n    // reward_percent = biome_weight * (1 + NG_LVL) / ng_sum\\n    return  1e18 * biome * (1 + heroNgLevel)\\n      / (maxBiome * (maxBiome + 1) / 2) // biome_sum\\n      / getNgSum(maxNgLevel);\\n  }\\n\\n  /// @notice be definition  ng_sum  = (max_ng + 1) * (max_ng+2) / 2\\n  function getNgSum(uint maxNgLevel) internal pure returns (uint) {\\n    return ((maxNgLevel + 1) * (maxNgLevel + 2) / 2);\\n  }\\n\\n  function rewardAmount(address token, uint maxBiome, uint maxNgLevel, uint biome, uint heroNgLevel) internal view returns (uint) {\\n    return baseAmount(token) * rewardPercent(maxBiome, maxNgLevel, biome, heroNgLevel) / 1e18;\\n  }\\n\\n  /// @notice Calculate lost profit amount in percents in the case when hero is created on {heroNgLevel} > 0\\n  /// @param maxBiome Max available biome, see {IDungeonFactory.state.maxBiome}\\n  /// @param maxNgLevel Max opened NG_LEVEL, see {IHeroController.state.maxOpenedNgLevel}\\n  /// @param heroNgLevel NG_LVL [1..99] where the hero is created, assume heroNgLevel > 0\\n  /// @return Lost reward percent, decimals 18\\n  function lostProfitPercent(uint maxBiome, uint maxNgLevel, uint heroNgLevel) internal pure returns (uint) {\\n    uint percent;\\n    for (uint8 ngLevel = 0; ngLevel < heroNgLevel; ++ngLevel) {\\n      percent += totalProfitOnLevel(maxBiome, maxNgLevel, ngLevel);\\n    }\\n    return percent;\\n  }\\n\\n  /// @notice SCR-1064: Calculate a percent to reduce drop chance of the monsters on various NG-levels.\\n  /// The percent is reverse to the percent of the rewards.\\n  /// @param maxBiome Max available biome, see {IDungeonFactory.state.maxBiome}\\n  /// @param maxNgLevel Max opened NG_LEVEL, see {IHeroController.state.maxOpenedNgLevel}\\n  /// @param heroNgLevel NG_LVL [1..99] where the hero is created, assume heroNgLevel > 0\\n  /// @return Drop chance percent, decimals 18\\n  function dropChancePercent(uint maxBiome, uint maxNgLevel, uint heroNgLevel) internal pure returns (uint) {\\n    if (heroNgLevel == 0) return 1e18; // NG0 is special case - drop is NOT reduced\\n\\n    return heroNgLevel > maxNgLevel\\n      ? 0\\n      : totalProfitOnLevel(maxBiome, maxNgLevel, maxNgLevel - heroNgLevel + 1);\\n  }\\n\\n  /// @notice Calculate total percent of rewards in all biomes on the given {ngLevel}\\n  function totalProfitOnLevel(uint maxBiome, uint maxNgLevel, uint ngLevel) internal pure returns (uint percent) {\\n    for (uint8 biome = 1; biome <= maxBiome; ++biome) {\\n      percent += rewardPercent(maxBiome, maxNgLevel, biome, ngLevel);\\n    }\\n    return percent;\\n  }\\n  //endregion ------------------------ View\\n\\n  //region ------------------------ Gov actions\\n  function setBaseAmount(IController controller, address token, uint baseAmount_) internal {\\n    _onlyDeployer(controller);\\n\\n    emit IApplicationEvents.BaseAmountChanged(_S().baseAmounts[token], baseAmount_);\\n    _S().baseAmounts[token] = baseAmount_;\\n  }\\n\\n  function withdraw(IController controller, address token, uint amount, address receiver) internal {\\n    _onlyGovernance(controller);\\n\\n    IERC20(token).transfer(receiver, amount);\\n  }\\n  //endregion ------------------------ Gov actions\\n\\n  //region ------------------------ Logic\\n  /// @notice Send {amount} of the {token} to the {dungeon}\\n  /// @dev Assume here that all calculations and checks are made on dungeonFactory-side\\n  function sendReward(IController controller, address token, uint rewardAmount_, address receiver) internal {\\n    onlyHeroController(controller);\\n\\n    uint balance = IERC20(token).balanceOf(address(this));\\n    if (balance >= rewardAmount_) {\\n      IERC20(token).transfer(receiver, rewardAmount_);\\n      emit IApplicationEvents.RewardSentToUser(receiver, token, rewardAmount_);\\n    } else {\\n      // there is not enough amount on reward pool balance\\n      // just register reward in events\\n      // assume that the reward should be paid to the receiver later manually\\n      emit IApplicationEvents.NotEnoughReward(receiver, token, rewardAmount_);\\n    }\\n  }\\n\\n  //endregion ------------------------ Logic\\n\\n}\\n\",\"keccak256\":\"0x7247419aeb0a36bc2bd0b51ccdadff8ba5eb3b78aa5e3260f8b5815cd602aa33\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ShelterLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IShelterController.sol\\\";\\nimport \\\"../interfaces/IShelterController.sol\\\";\\nimport \\\"../interfaces/IUserController.sol\\\";\\nimport \\\"../lib/StringLib.sol\\\";\\nimport \\\"../token/GuildBank.sol\\\";\\nimport \\\"./StatLib.sol\\\";\\nimport \\\"../interfaces/IShelterAuction.sol\\\";\\n\\nlibrary ShelterLib {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using EnumerableSet for EnumerableSet.UintSet;\\n\\n  //region ------------------------ Constants\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"shelter.controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant SHELTER_CONTROLLER_STORAGE_LOCATION = 0x5a293071b39954a4fcf98ae7184af7c6201e972e15842b884f1ad071e9bded00; // shelter.controller.main\\n\\n  uint8 internal constant MIN_SHELTER_LEVEL = 1;\\n  uint8 internal constant MAX_SHELTER_LEVEL = 3;\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Restrictions\\n  function _onlyDeployer(IController controller) internal view {\\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n\\n  function _onlyGuildController(address guildController) internal view {\\n    if (msg.sender != guildController) revert IAppErrors.ErrorNotGuildController();\\n  }\\n\\n  function _notPaused(IController controller) internal view {\\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\\n  }\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ Storage\\n\\n  function _S() internal pure returns (IShelterController.MainState storage s) {\\n    assembly {\\n      s.slot := SHELTER_CONTROLLER_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n  //endregion ------------------------ Storage\\n\\n  //region ------------------------ Shelter view\\n  /// @notice Get list of all registered shelters in the given {biome}\\n  function getShelters(uint8 biome) internal view returns (uint[] memory shelterIds) {\\n    return _S().shelters[biome].values();\\n  }\\n\\n  /// @notice Get initial price of the given shelter. The price is used if the shelter doesn't belong to any guild\\n  function getShelterPrice(uint shelterId) internal view returns (uint price) {\\n    return _S().shelterPrices[shelterId];\\n  }\\n\\n  /// @notice Get shelter which belongs to the given guild\\n  function guildToShelter(uint guildId) internal view returns (uint shelterId) {\\n    return _S().guildToShelter[guildId];\\n  }\\n\\n  /// @notice Get guild to which the given shelter belongs\\n  function shelterToGuild(uint shelterId) internal view returns (uint guildId) {\\n    return _S().shelterToGuild[shelterId];\\n  }\\n\\n  /// @notice Get shelter of the guild to which the user belongs\\n  function getShelterId(IGuildController guildController, address user) internal view returns (uint shelterId) {\\n    uint guildId = guildController.memberOf(user);\\n    return guildId == 0\\n      ? 0\\n      : _S().guildToShelter[guildId];\\n  }\\n\\n  /// @notice List of items that can be bought in the shelter of the given level in the given biome\\n  function getShelterItems(uint shelterId) internal view returns (address[] memory items) {\\n    return _S().shelterItems[shelterId].values();\\n  }\\n\\n  function getShelterItemData(uint shelterId, address item) internal view returns (\\n    uint64 priceInPvpPoints,\\n    uint128 priceInGameToken,\\n    uint16 maxItemsPerDayLimit\\n  ) {\\n    IShelterController.ShelterItemData memory data = _S().shelterItemData[shelterId][item];\\n    return (\\n      data.priceInPvpPoints,\\n      data.priceInGameToken,\\n      data.maxItemsPerDayLimit\\n    );\\n  }\\n\\n  /// @notice How many {item} instances were purchased per {epochDay} in the given {shelterId}\\n  /// @param epochDay TimestampInSeconds / 24 * 60 * 60\\n  function getCountPurchasedItems(address item, uint shelterId, uint32 epochDay) internal view returns (uint) {\\n    return _S().countPurchasedItems[shelterId][epochDay][item];\\n  }\\n\\n  //endregion ------------------------ Shelter view\\n\\n  //region ------------------------ Shelter config\\n  /// @notice Register new shelter or overwrite exist. Only registered shelters can be purchased.\\n  /// @param shelterId ID should be generated using {PackingLib.packShelterId}\\n  /// @param price Initial shelter price in game tokens\\n  function setShelter(IController controller, uint shelterId, uint price) internal {\\n    ShelterLib._onlyDeployer(controller);\\n\\n    (uint8 biome, uint8 shelterLevel, ) = PackingLib.unpackShelterId(shelterId);\\n\\n    if (biome == 0 || biome > StatLib.MAX_POSSIBLE_BIOME) revert IAppErrors.ErrorIncorrectBiome(biome);\\n    if (price == 0) revert IAppErrors.ZeroValueNotAllowed();\\n    if (shelterLevel < MIN_SHELTER_LEVEL || shelterLevel > MAX_SHELTER_LEVEL) revert IAppErrors.IncorrectShelterLevel(shelterLevel);\\n\\n    _S().shelterPrices[shelterId] = price;\\n    _S().shelters[biome].add(shelterId);\\n\\n    emit IApplicationEvents.RegisterShelter(shelterId, price);\\n  }\\n\\n  /// @notice Set items that can be purchases in the given shelter: remove previously stored items, add new items.\\n  /// @param shelterId ID should be generated using {PackingLib.packShelterId}\\n  /// @param items List of item tokens\\n  /// @param pricesInPvpPoints Prices in pvp-points. The points are taken from guild balance at the moment of purchasing\\n  /// @param pricesInGameTokens Additional prices in game tokens. Can contain zeros.\\n  /// @param maxItemsPerDayLimits Indicate how many item instances the users can purchase per day. 0 - no limitations\\n  function setShelterItems(\\n    IController controller,\\n    uint shelterId,\\n    address[] memory items,\\n    uint64[] memory pricesInPvpPoints,\\n    uint128[] memory pricesInGameTokens,\\n    uint16[] memory maxItemsPerDayLimits\\n  ) internal {\\n    ShelterLib._onlyDeployer(controller);\\n\\n    uint len = items.length;\\n    if (len != pricesInPvpPoints.length || len != pricesInGameTokens.length || len != maxItemsPerDayLimits.length) {\\n      revert IAppErrors.LengthsMismatch();\\n    }\\n\\n    EnumerableSet.AddressSet storage set = _S().shelterItems[shelterId];\\n\\n    // remove previously stored items\\n    address[] memory prevItems = set.values();\\n    uint prevItemsLen = prevItems.length;\\n    for (uint i; i < prevItemsLen; ++i) {\\n      set.remove(prevItems[i]);\\n      delete _S().shelterItemData[shelterId][prevItems[i]];\\n    }\\n\\n    // add new items\\n    for (uint i; i < len; ++i) {\\n      set.add(items[i]);\\n      if (pricesInPvpPoints[i] == 0 && pricesInGameTokens[i] == 0) revert IAppErrors.FreeShelterItemsAreNotAllowed(shelterId, items[i]);\\n      _S().shelterItemData[shelterId][items[i]] = IShelterController.ShelterItemData({\\n        priceInPvpPoints: pricesInPvpPoints[i],\\n        priceInGameToken: pricesInGameTokens[i],\\n        maxItemsPerDayLimit: maxItemsPerDayLimits[i]\\n      });\\n    }\\n\\n    emit IApplicationEvents.SetShelterItems(shelterId, items, pricesInPvpPoints, pricesInGameTokens, maxItemsPerDayLimits);\\n  }\\n  //endregion ------------------------ Shelter config\\n\\n  //region ------------------------ Shelter actions\\n\\n  /// @notice Guild buys a shelter that doesn't belong to any guild. It pays default prices and changes owner of the shelter.\\n  function buyShelter(IController controller, address msgSender, uint shelterId) internal {\\n    _notPaused(controller);\\n\\n    IGuildController guildController = IGuildController(controller.guildController());\\n    (uint guildId,) = guildController.checkPermissions(msgSender, uint(IGuildController.GuildRightBits.CHANGE_SHELTER_3));\\n\\n    // only registered shelter can be purchased\\n    (uint8 biome, , ) = PackingLib.unpackShelterId(shelterId);\\n    if (!_S().shelters[biome].contains(shelterId)) revert IAppErrors.ShelterIsNotRegistered();\\n\\n    // Each guild is able to have only 1 shelter. Exist shelter should be sold or left\\n    if (_S().guildToShelter[guildId] != 0) revert IAppErrors.GuildAlreadyHasShelter();\\n    if (_S().shelterToGuild[shelterId] != 0) revert IAppErrors.ShelterIsBusy();\\n\\n    { // Shelter can be bought only if there is no auction bid\\n      address shelterAuction = guildController.shelterAuctionController();\\n      if (shelterAuction != address(0)) {\\n        (uint positionId,) = IShelterAuction(shelterAuction).positionByBuyer(guildId);\\n        if (positionId != 0) revert IAppErrors.AuctionBidOpened(positionId);\\n      }\\n    }\\n\\n    // pay for the shelter from the guild bank\\n    uint shelterPrice = getShelterPrice(shelterId);\\n    guildController.payFromGuildBank(guildId, shelterPrice);\\n\\n    // register ownership\\n    _S().guildToShelter[guildId] = shelterId;\\n    _S().shelterToGuild[shelterId] = guildId;\\n\\n    emit IApplicationEvents.BuyShelter(guildId, shelterId);\\n  }\\n\\n  /// @notice Guild leaves the shelter. The shelter becomes free, it can be bought by any guild by default price\\n  function leaveShelter(IController controller, address msgSender, uint shelterId) internal {\\n    _notPaused(controller);\\n\\n    IGuildController guildController = IGuildController(controller.guildController());\\n    (uint guildId,) = guildController.checkPermissions(msgSender, uint(IGuildController.GuildRightBits.CHANGE_SHELTER_3));\\n\\n    if (_S().guildToShelter[guildId] != shelterId) revert IAppErrors.ShelterIsNotOwnedByTheGuild();\\n    if (shelterId == 0) revert IAppErrors.GuildHasNoShelter();\\n\\n    { // Shelter can be sold only if there is no opened auction position\\n      address shelterAuction = guildController.shelterAuctionController();\\n      if (shelterAuction != address(0)) {\\n        uint positionId = IShelterAuction(shelterAuction).positionBySeller(guildId);\\n        if (positionId != 0) revert IAppErrors.AuctionPositionOpened(positionId);\\n      }\\n    }\\n\\n    // unregister ownership\\n    delete _S().guildToShelter[guildId];\\n    delete _S().shelterToGuild[shelterId];\\n\\n    emit IApplicationEvents.LeaveShelter(guildId, shelterId);\\n  }\\n\\n  /// @notice Purchase the {item} in the shelter that belongs to the guild to which {msgSender} belongs\\n  function purchaseShelterItem(IController controller, address msgSender, address item, uint blockTimestamp) internal {\\n    _notPaused(controller);\\n\\n    IGuildController guildController = IGuildController(controller.guildController());\\n    // no permission are required - any guild member is able to purchase shelter item\\n    // but the member should either be owner or should have enough pvp-points capacity, see restriction below\\n    uint guildId = _getValidGuildId(guildController, msgSender);\\n\\n    uint shelterId = _S().guildToShelter[guildId];\\n    if (shelterId == 0) revert IAppErrors.GuildHasNoShelter();\\n\\n    if (! _S().shelterItems[shelterId].contains(item)) revert IAppErrors.ShelterHasNotItem(shelterId, item);\\n\\n    // total number of the item instances that can be minted per day CAN BE limited\\n    IShelterController.ShelterItemData memory itemData = _S().shelterItemData[shelterId][item];\\n    uint numSoldItems;\\n    {\\n      uint32 epochDay = uint32(blockTimestamp / 86400);\\n\\n      mapping(address => uint) storage countPurchasedItems = _S().countPurchasedItems[shelterId][epochDay];\\n      numSoldItems = countPurchasedItems[item];\\n\\n      if (itemData.maxItemsPerDayLimit != 0) {\\n        if (numSoldItems >= itemData.maxItemsPerDayLimit) revert IAppErrors.MaxNumberItemsSoldToday(numSoldItems, itemData.maxItemsPerDayLimit);\\n      }\\n      countPurchasedItems[item] = numSoldItems + 1;\\n    }\\n\\n    // user pays for the item by pvp-points and/or by game token (it depends on the item settings)\\n    if (itemData.priceInPvpPoints != 0) {\\n      guildController.usePvpPoints(guildId, msgSender, itemData.priceInPvpPoints);\\n    }\\n\\n    if (itemData.priceInGameToken != 0) {\\n      guildController.payFromBalance(itemData.priceInGameToken, msgSender);\\n      //_process(controller, itemData.priceInGameToken, msgSender);\\n    }\\n\\n    // mint the item\\n    IItemController(controller.itemController()).mint(item, msgSender);\\n\\n    emit IApplicationEvents.PurchaseShelterItem(msgSender, item, numSoldItems + 1, itemData.priceInPvpPoints, itemData.priceInGameToken);\\n  }\\n\\n  /// @notice clear necessary data to indicate that the guiles leaves the shelter\\n  function clearShelter(address guildController, uint guildId) internal {\\n    _onlyGuildController(guildController);\\n\\n    uint shelterId = _S().guildToShelter[guildId];\\n    if (shelterId != 0) {\\n      // assume, that msgSender shouldn't have permission CHANGE_SHELTER_3 here\\n\\n      // ensure that there is no open position for the shelter on auction\\n      address shelterAuction = IGuildController(guildController).shelterAuctionController();\\n      if (shelterAuction != address(0)) {\\n        uint positionId = IShelterAuction(shelterAuction).positionBySeller(guildId);\\n        if (positionId != 0) revert IAppErrors.AuctionPositionOpened(positionId);\\n      }\\n\\n      delete _S().guildToShelter[guildId];\\n      delete _S().shelterToGuild[shelterId];\\n\\n      emit IApplicationEvents.LeaveShelter(guildId, shelterId);\\n    }\\n\\n  }\\n  //endregion ------------------------ Shelter actions\\n\\n  //region ------------------------ Interaction with auctions\\n  function changeShelterOwner(IController controller, uint shelterId, uint newOwnerGuildId) internal {\\n    // we assume, that all checks are performed on ShelterAuction side, so we need min checks here\\n    address shelterAuction = IGuildController(controller.guildController()).shelterAuctionController();\\n    if (shelterAuction == address(0) || msg.sender != shelterAuction) revert IAppErrors.NotShelterAuction();\\n\\n    uint prevGuildId = _S().shelterToGuild[shelterId];\\n    delete _S().guildToShelter[prevGuildId];\\n    _S().shelterToGuild[shelterId] = newOwnerGuildId;\\n    _S().guildToShelter[newOwnerGuildId] = shelterId;\\n\\n    emit IApplicationEvents.ChangeShelterOwner(shelterId, prevGuildId, newOwnerGuildId);\\n  }\\n\\n  //endregion ------------------------ Interaction with auctions\\n\\n  //region ------------------------ Internal logic\\n  function _getValidGuildId(IGuildController guildController, address user) internal view returns (uint guildId) {\\n    guildId = guildController.memberOf(user);\\n    if (guildId == 0) revert IAppErrors.NotGuildMember();\\n  }\\n  //endregion ------------------------ Internal logic\\n\\n\\n}\\n\",\"keccak256\":\"0xcd3dc6a4f1cd3e8f9b6fd495b022db5d28a40095a069478b46d6d9f1378b9490\",\"license\":\"BUSL-1.1\"},\"contracts/lib/SlotsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\\n/// @author bogdoslav\\nlibrary SlotsLib {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant SLOT_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  // ************* GETTERS *******************\\n\\n  /// @dev Gets a slot as bytes32\\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as an address\\n  function getAddress(bytes32 slot) internal view returns (address result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as uint256\\n  function getUint(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  // ************* ARRAY GETTERS *******************\\n\\n  /// @dev Gets an array length\\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  // ************* SETTERS *******************\\n\\n  /// @dev Sets a slot with bytes32\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, bytes32 value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with address\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, address value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with uint\\n  function set(bytes32 slot, uint value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x52ede981a6bb509c0dce07a0373e3c073c24fd16ca4ca7fbaa24f6c8b747b45b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StatLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\n\\nlibrary StatLib {\\n  using PackingLib for bytes32[];\\n  using PackingLib for bytes32;\\n  using PackingLib for uint32[];\\n  using PackingLib for int32[];\\n  using CalcLib for int32;\\n\\n  //region --------------------------- Constants\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant STAT_LIB_VERSION = \\\"1.0.0\\\";\\n  uint32 public constant MAX_LEVEL = 99;\\n\\n  uint public constant BASE_EXPERIENCE = 100_000;\\n  uint public constant BIOME_LEVEL_STEP = 5;\\n  uint internal constant _MAX_AMPLIFIER = 1e18;\\n  uint private constant _PRECISION = 1e18;\\n  uint private constant VIRTUAL_LEVEL_GAP = 2;\\n\\n  /// @dev Assume MAX_BIOME * BIOME_LEVEL_STEP < MAX_LEVEL + 1, see dungeonTreasuryReward\\n  uint public constant MAX_POSSIBLE_BIOME = 19;\\n  //endregion --------------------------- Constants\\n\\n  //region --------------------------- Data types\\n\\n  struct BaseMultiplier {\\n    uint minDamage;\\n    uint maxDamage;\\n    uint attackRating;\\n    uint defense;\\n    uint blockRating;\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct LevelUp {\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct InitialHero {\\n    IStatController.CoreAttributes core;\\n    BaseMultiplier multiplier;\\n    LevelUp levelUp;\\n    int32 baseLifeChances;\\n  }\\n\\n  enum HeroClasses {\\n    UNKNOWN,\\n    THRALL,\\n    SAVAGE,\\n    MAGE,\\n    ASSASSIN,\\n    GHOST,\\n    HAMMERGINA,\\n    END_SLOT\\n  }\\n  //endregion --------------------------- Data types\\n\\n  //region --------------------------- BASE\\n\\n  function isNetworkWithOldSavage() public view returns (bool) {\\n    return block.chainid == uint(111188) || block.chainid == uint(250);\\n  }\\n\\n  // --- HERO 1 (Slave) ---\\n\\n  function initialHero1() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 15,\\n      vitality: 30,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 2e18,\\n      blockRating: 0.1e18,\\n      life: 1.5e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 2e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 2 (Spata) ---\\n\\n  function initialHero2() internal view returns (InitialHero memory) {\\n\\n    bool old = isNetworkWithOldSavage();\\n\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 30,\\n      dexterity: 5,\\n      vitality: 25,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: old ? 0.25e18 : 0.5e18,\\n      attackRating: old ? 2e18 : 3e18,\\n      defense: 1e18,\\n      blockRating: 0.08e18,\\n      life: 1.3e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.8e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 3 (Decidia) ---\\n\\n  function initialHero3() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 10,\\n      dexterity: 15,\\n      vitality: 20,\\n      energy: 25\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 1e18,\\n      blockRating: 0.1e18,\\n      life: 1e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.3e18,\\n      mana: 2e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 4 (Innatus) ---\\n\\n  function initialHero4() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 25,\\n      vitality: 15,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 4e18,\\n      defense: 3e18,\\n      blockRating: 0.2e18,\\n      life: 1.2e18,\\n      mana: 1e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 5 (F2P) ---\\n\\n  function initialHero5() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 20,\\n      dexterity: 20,\\n      vitality: 20,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: 0.25e18,\\n      attackRating: 3e18,\\n      defense: 2.5e18,\\n      blockRating: 0.15e18,\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // --- HERO 6 (F2P) HAMMERGINA ---\\n\\n  function initialHero6() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 50,\\n      dexterity: 30,\\n      vitality: 50,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.2e18,\\n      maxDamage: 0.3e18,\\n      attackRating: 5e18,\\n      defense: 3e18,\\n      blockRating: 0.15e18,\\n      life: 2e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // ------\\n\\n  function initialHero(uint heroClass) internal view returns (InitialHero memory) {\\n    if (heroClass == 1) {\\n      return initialHero1();\\n    } else if (heroClass == 2) {\\n      return initialHero2();\\n    } else if (heroClass == 3) {\\n      return initialHero3();\\n    } else if (heroClass == 4) {\\n      return initialHero4();\\n    } else if (heroClass == 5) {\\n      return initialHero5();\\n    } else if (heroClass == 6) {\\n      return initialHero6();\\n    } else {\\n      revert IAppErrors.UnknownHeroClass(heroClass);\\n    }\\n  }\\n  //endregion --------------------------- BASE\\n\\n  //region --------------------------- CALCULATIONS\\n\\n  function minDamage(int32 strength, uint heroClass) internal view returns (int32) {\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.minDamage / _PRECISION));\\n  }\\n\\n  function maxDamage(int32 strength, uint heroClass) internal view returns (int32){\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.maxDamage / _PRECISION));\\n  }\\n\\n  function attackRating(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.attackRating / _PRECISION));\\n  }\\n\\n  function defense(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.defense / _PRECISION));\\n  }\\n\\n  function blockRating(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(Math.min((dexterity.toUint() * initialHero(heroClass).multiplier.blockRating / _PRECISION), 75)));\\n  }\\n\\n  function life(int32 vitality, uint heroClass, uint32 level) internal view returns (int32){\\n    return int32(int(\\n      (vitality.toUint() * initialHero(heroClass).multiplier.life / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.life / _PRECISION)\\n    ));\\n  }\\n\\n  function mana(int32 energy, uint heroClass, uint32 level) internal view returns (int32){\\n    return int32(int(\\n      (energy.toUint() * initialHero(heroClass).multiplier.mana / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.mana / _PRECISION)\\n    ));\\n  }\\n\\n  function lifeChances(uint heroClass, uint32 /*level*/) internal view returns (int32){\\n    return initialHero(heroClass).baseLifeChances;\\n  }\\n\\n  function levelExperience(uint32 level) internal pure returns (uint32) {\\n    if (level == 0 || level >= MAX_LEVEL) {\\n      return 0;\\n    }\\n    return uint32(uint(level) * BASE_EXPERIENCE * (67e17 - CalcLib.log2((uint(MAX_LEVEL - level + 2)) * 1e18)) / 1e18);\\n  }\\n\\n  function chanceToHit(\\n    uint attackersAttackRating,\\n    uint defendersDefenceRating,\\n    uint attackersLevel,\\n    uint defendersLevel,\\n    uint arFactor\\n  ) internal pure returns (uint) {\\n    attackersAttackRating += attackersAttackRating * arFactor / 100;\\n    uint x = Math.max(attackersAttackRating, 1);\\n    uint y = Math.max(attackersAttackRating + defendersDefenceRating, 1);\\n    uint z = attackersLevel;\\n    uint k = defendersLevel / 2;\\n    uint xy = x * 1e18 / y;\\n    uint zk = z * 1e18 / (attackersLevel + k);\\n    uint base = 2 * xy * zk / 1e18;\\n    return Math.max(Math.min(base, 0.95e18), 0.2e18);\\n  }\\n\\n  function experienceToVirtualLevel(uint experience, uint startFromLevel) internal pure returns (uint level) {\\n    level = startFromLevel;\\n    for (; level < MAX_LEVEL;) {\\n      if (levelExperience(uint32(level)) >= (experience + 1)) {\\n        break;\\n      }\\n      unchecked{++level;}\\n    }\\n  }\\n\\n  function expPerMonster(uint32 monsterExp, uint monsterRarity, uint32 /*heroExp*/, uint32 /*heroCurrentLvl*/, uint /*monsterBiome*/) internal pure returns (uint32) {\\n    // do not reduce exp per level, it is no economical sense\\n    return uint32(uint(monsterExp) + uint(monsterExp) * monsterRarity / _MAX_AMPLIFIER);\\n  }\\n\\n  /// @notice Allow to calculate delta param for {mintDropChance}\\n  function mintDropChanceDelta(uint heroCurrentExp, uint heroCurrentLevel, uint monsterBiome) internal pure returns (uint) {\\n    uint heroBiome = getVirtualLevel(heroCurrentExp, heroCurrentLevel, true) / StatLib.BIOME_LEVEL_STEP + 1;\\n    return heroBiome > monsterBiome ? 2 ** (heroBiome - monsterBiome + 10) : 0;\\n  }\\n\\n  function getVirtualLevel(uint heroCurrentExp, uint heroCurrentLevel, bool withGap) internal pure returns (uint) {\\n    uint virtualLevel = StatLib.experienceToVirtualLevel(heroCurrentExp, heroCurrentLevel);\\n    if (withGap && (virtualLevel + 1) > VIRTUAL_LEVEL_GAP) {\\n      virtualLevel -= VIRTUAL_LEVEL_GAP;\\n    }\\n    return virtualLevel;\\n  }\\n\\n  function initAttributes(\\n    bytes32[] storage attributes,\\n    uint heroClass,\\n    uint32 level,\\n    IStatController.CoreAttributes memory base\\n  ) internal returns (uint32[] memory result) {\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.STRENGTH), base.strength);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEXTERITY), base.dexterity);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.VITALITY), base.vitality);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ENERGY), base.energy);\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN), minDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX), maxDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING), attackRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE), defense(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING), blockRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE), life(base.vitality, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA), mana(base.energy, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE_CHANCES), lifeChances(heroClass, level));\\n\\n    result = new uint32[](3);\\n    result[0] = uint32(life(base.vitality, heroClass, level).toUint());\\n    result[1] = uint32(mana(base.energy, heroClass, level).toUint());\\n    result[2] = uint32(lifeChances(heroClass, uint32(level)).toUint());\\n  }\\n\\n  function updateCoreDependAttributesInMemory(\\n    int32[] memory attributes,\\n    int32[] memory bonus,\\n    uint heroClass,\\n    uint32 level\\n  ) internal view returns (int32[] memory) {\\n    int32 strength = attributes[uint(IStatController.ATTRIBUTES.STRENGTH)];\\n    int32 dexterity = attributes[uint(IStatController.ATTRIBUTES.DEXTERITY)];\\n    int32 vitality = attributes[uint(IStatController.ATTRIBUTES.VITALITY)];\\n    int32 energy = attributes[uint(IStatController.ATTRIBUTES.ENERGY)];\\n\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] = minDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)];\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] = maxDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)];\\n    attributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] = attackRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.ATTACK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.DEFENSE)] = defense(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DEFENSE)];\\n    attributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] = blockRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.BLOCK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.LIFE)] = life(vitality, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.LIFE)];\\n    attributes[uint(IStatController.ATTRIBUTES.MANA)] = mana(energy, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.MANA)];\\n    return attributes;\\n  }\\n\\n  function updateCoreDependAttributes(\\n    IController controller,\\n    bytes32[] storage attributes,\\n    bytes32[] storage bonusMain,\\n    bytes32[] storage bonusExtra,\\n    IStatController.ChangeableStats memory _heroStats,\\n    uint index,\\n    address heroToken,\\n    int32 base\\n  ) internal {\\n    uint heroClass = IHeroController(controller.heroController()).heroClass(heroToken);\\n    if (index == uint(IStatController.ATTRIBUTES.STRENGTH)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN),\\n        StatLib.minDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n      );\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX),\\n        StatLib.maxDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.DEXTERITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING),\\n        StatLib.attackRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE),\\n        StatLib.defense(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING),\\n        StatLib.blockRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.VITALITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE),\\n        StatLib.life(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.ENERGY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA),\\n        StatLib.mana(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n      );\\n    }\\n  }\\n\\n  function attributesAdd(int32[] memory base, int32[] memory add) internal pure returns (int32[] memory) {\\n    unchecked{\\n      for (uint i; i < base.length; ++i) {\\n        base[i] += add[i];\\n      }\\n    }\\n    return base;\\n  }\\n\\n// Currently this function is not used\\n//  function attributesRemove(int32[] memory base, int32[] memory remove) internal pure returns (int32[] memory) {\\n//    unchecked{\\n//      for (uint i; i < base.length; ++i) {\\n//        base[i] = CalcLib.minusWithMinFloorI32(base[i], remove[i]);\\n//      }\\n//    }\\n//    return base;\\n//  }\\n\\n  function packChangeableStats(IStatController.ChangeableStats memory stats) internal pure returns (bytes32) {\\n    uint32[] memory cData = new uint32[](5);\\n    cData[0] = stats.level;\\n    cData[1] = stats.experience;\\n    cData[2] = stats.life;\\n    cData[3] = stats.mana;\\n    cData[4] = stats.lifeChances;\\n\\n    return cData.packUint32Array();\\n  }\\n\\n  function unpackChangeableStats(bytes32 data) internal pure returns (IStatController.ChangeableStats memory result) {\\n    uint32[] memory cData = data.unpackUint32Array();\\n    return IStatController.ChangeableStats({\\n      level: cData[0],\\n      experience: cData[1],\\n      life: cData[2],\\n      mana: cData[3],\\n      lifeChances: cData[4]\\n    });\\n  }\\n\\n  function bytesToFullAttributesArray(bytes32[] memory attributes) internal pure returns (int32[] memory result) {\\n    (int32[] memory values, uint8[] memory ids) = attributes.toInt32ArrayWithIds();\\n    return valuesToFullAttributesArray(values, ids);\\n  }\\n\\n  function valuesToFullAttributesArray(int32[] memory values, uint8[] memory ids) internal pure returns (int32[] memory result) {\\n    result = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < values.length; ++i) {\\n      int32 value = values[i];\\n      if (value != 0) {\\n        result[ids[i]] = value;\\n      }\\n    }\\n  }\\n  //endregion --------------------------- CALCULATIONS\\n\\n}\\n\",\"keccak256\":\"0x126da898025ed4460ae137e05192ecfb9ad76b7c8da8578d39da8278d4a75aa6\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StoryLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721Enumerable.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../lib/CalcLib.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\nimport \\\"../lib/ItemLib.sol\\\";\\nimport \\\"../lib/StringLib.sol\\\";\\n\\nlibrary StoryLib {\\n  using CalcLib for uint;\\n  using PackingLib for address;\\n  using PackingLib for uint16;\\n  using PackingLib for bytes32;\\n  using PackingLib for bytes32[];\\n\\n  //region ------------------------ Constants\\n  /// @notice Max number of items that can be minted per iteration in the stories\\n  uint internal constant MAX_MINTED_ITEMS_PER_ITERATION = 3;\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Story logic\\n\\n  /// @notice Make action, increment STORY_XXX hero custom data if the dungeon is completed / hero is killed\\n  function action(IGOC.ActionContext memory ctx, uint16 storyId) internal returns (IGOC.ActionResult memory result) {\\n    if (storyId == 0) revert IAppErrors.ZeroStoryIdAction();\\n\\n    result = IStoryController(ctx.controller.storyController()).storyAction(\\n      ctx.sender,\\n      ctx.dungeonId,\\n      ctx.objectId,\\n      ctx.stageId,\\n      ctx.heroToken,\\n      ctx.heroTokenId,\\n      ctx.biome,\\n      ctx.iteration,\\n      ctx.data\\n    );\\n\\n    if (result.completed || result.kill) {\\n      IStatController statController = IStatController(ctx.controller.statController());\\n      bytes32 index = _getStoryIndex(storyId);\\n      uint curValue = statController.heroCustomData(ctx.heroToken, ctx.heroTokenId, index);\\n      statController.setHeroCustomData(ctx.heroToken, ctx.heroTokenId, index, curValue + 1);\\n    }\\n  }\\n\\n  /// @notice Check if the story is available for the hero\\n  /// The story is available if hero level fits to requirements\\n  /// and if the hero/global custom data requirements are met (current value is inside of [min, max])\\n  function isStoryAvailableForHero(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address statController\\n  ) internal view returns (bool) {\\n    uint reqLvl = s.storyRequiredLevel[storyId];\\n    if (reqLvl != 0 && IStatController(statController).heroStats(heroToken, heroTokenId).level < reqLvl) {\\n      return false;\\n    }\\n\\n    IStoryController.CustomDataRequirementRangePacked[] storage allData = s.storyRequiredHeroData[storyId];\\n    uint len = allData.length;\\n    for (uint i; i < len; ++i) {\\n      IStoryController.CustomDataRequirementRangePacked memory data = allData[i];\\n\\n      if (data.index == bytes32(0)) continue;\\n\\n      (uint64 min, uint64 max, bool isHeroData) = data.data.unpackCustomDataRequirements();\\n\\n      uint value = isHeroData\\n        ? IStatController(statController).heroCustomData(heroToken, heroTokenId, data.index)\\n        : IStatController(statController).globalCustomData(data.index);\\n\\n      if (value < uint(min) || value > uint(max)) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Update bonus attributes, refresh hero states, initialize and return results\\n  /// @param mintItemsData Source for _mintRandomItems, random item (max 1, probably 0) is selected and put to results\\n  /// @param mintItems_ Function _mintRandomItems is passed here. Parameter is required to make unit tests.\\n  function handleResult(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32[] memory attributesChanges,\\n    bytes32 statsChanges,\\n    bytes32[] memory mintItemsData,\\n    function (IStoryController.StoryActionContext memory, bytes32[] memory) internal returns (address[] memory) mintItems_\\n  ) internal returns (IGOC.ActionResult memory result) {\\n    result.heroToken = context.heroToken;\\n    result.heroTokenId = context.heroTokenId;\\n    result.objectId = context.objectId;\\n\\n    int32[] memory attributes = _generateAttributes(attributesChanges);\\n\\n    if (attributes.length != 0) {\\n      context.statController.changeBonusAttributes(IStatController.ChangeAttributesInfo({\\n        heroToken: context.heroToken,\\n        heroTokenId: context.heroTokenId,\\n        changeAttributes: attributes,\\n        add: true,\\n        temporally: true\\n      }));\\n      // changeBonusAttributes can change life and mana, so we need to refresh hero stats. It's safer to do it always\\n      context.heroStats = context.statController.heroStats(context.heroToken, context.heroTokenId);\\n      emit IApplicationEvents.StoryChangeAttributes(\\n        context.objectId,\\n        context.heroToken,\\n        context.heroTokenId,\\n        context.dungeonId,\\n        context.storyId,\\n        context.stageId,\\n        context.iteration,\\n        attributes\\n      );\\n    }\\n\\n    IStoryController.StatsChange memory statsToChange = _generateStats(statsChanges);\\n\\n    if (statsToChange.heal != 0) {\\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.LIFE));\\n      result.heal = max * statsToChange.heal / 100;\\n    }\\n\\n    if (statsToChange.manaRegen != 0) {\\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.MANA));\\n      result.manaRegen = max * statsToChange.manaRegen / 100;\\n    }\\n\\n    if (statsToChange.damage != 0) {\\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.LIFE));\\n      result.damage = max * statsToChange.damage / 100;\\n\\n      if (int32(context.heroStats.life) <= result.damage) {\\n        result.kill = true;\\n      }\\n    }\\n\\n    if (statsToChange.manaConsumed != 0) {\\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.MANA));\\n      result.manaConsumed = CalcLib.minI32(max * statsToChange.manaConsumed / 100, int32(context.heroStats.mana));\\n    }\\n\\n    result.experience = statsToChange.experience;\\n    result.lifeChancesRecovered = statsToChange.lifeChancesRecovered;\\n\\n    if (mintItemsData.length != 0) {\\n      result.mintItems = mintItems_(context, mintItemsData);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Put data from {heroCustomDatas} and {globalCustomDatas} to {statController}\\n  function handleCustomDataResult(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32[] memory heroCustomDatas,\\n    bytes32[] memory globalCustomDatas\\n  ) internal {\\n    uint len = heroCustomDatas.length;\\n    for (uint i; i < len; ++i) {\\n\\n      (bytes32 customDataIndex, int16 value) = heroCustomDatas[i].unpackCustomDataChange();\\n\\n      if (customDataIndex != 0) {\\n        uint curValue = context.statController.heroCustomData(context.heroToken, context.heroTokenId, customDataIndex);\\n        context.statController.setHeroCustomData(\\n          context.heroToken,\\n          context.heroTokenId,\\n          customDataIndex,\\n          value == 0\\n            ? 0\\n            : value > 0\\n              ? curValue + uint(int(value))\\n              : curValue.minusWithZeroFloor(uint(int(- value)))\\n        );\\n      }\\n    }\\n\\n    len = globalCustomDatas.length;\\n    for (uint i; i < len; ++i) {\\n\\n      (bytes32 customDataIndex, int16 value) = globalCustomDatas[i].unpackCustomDataChange();\\n\\n      if (customDataIndex != 0) {\\n        uint curValue = context.statController.globalCustomData(customDataIndex);\\n        context.statController.setGlobalCustomData(\\n          customDataIndex,\\n          value == 0\\n            ? 0\\n            : value > 0\\n              ? curValue + uint(int(value))\\n              : curValue.minusWithZeroFloor(uint(int(- value)))\\n        );\\n      }\\n    }\\n  }\\n\\n  /// @notice SIP-003: Randomly select one or several items, break them and increase their fragility by 1%.\\n  function breakItem(IStoryController.StoryActionContext memory context, IStoryController.MainState storage s) internal {\\n    bytes32[] storage breakInfos = s.burnItem[context.answerIdHash];\\n    uint length = breakInfos.length;\\n\\n    for (uint i; i < length; ++i) {\\n      (uint8 slot, uint64 chance, bool stopIfBroken) = breakInfos[i].unpackBreakInfo();\\n      uint8[2] memory slots = _adjustSlotToBreak(slot, context.oracle);\\n      // Normally, {slots} contains two similar items and we need to check only first item.\\n      // But \\\"hands\\\" is a special case: TWO_HAND and RIGHT_HAND should be checked both independently => + cycle by k\\n      uint countSlots = slots[0] == slots[1] ? 1 : 2;\\n\\n      for (uint k = 0; k < countSlots; ++k) {\\n        if (chance != 0 && context.oracle.getRandomNumberInRange(0, 100, 0) <= uint(chance)) {\\n          uint8[] memory busySlots = context.statController.heroItemSlots(context.heroToken, context.heroTokenId);\\n\\n          uint lenBusySlots = busySlots.length;\\n          if (lenBusySlots != 0) {\\n            uint busySlotIndex;\\n            bool itemExist;\\n            if (slot == 0) {\\n              busySlotIndex = context.oracle.getRandomNumberInRange(0, lenBusySlots - 1, 0);\\n              itemExist = true;\\n            } else {\\n              for (uint j; j < lenBusySlots; ++j) {\\n                if (busySlots[j] == slots[k]) {\\n                  busySlotIndex = j;\\n                  itemExist = true;\\n                  break;\\n                }\\n              }\\n            }\\n\\n            if (itemExist) {\\n              // SIP-003: don't burn item but break it\\n              _breakItemInHeroSlot(context, busySlots[busySlotIndex]);\\n              if (stopIfBroken) {\\n                return; // go out of two cycles\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice SCB-1016. There are some slots with equal meaning:\\n  /// 1) weapon can be RIGHT-HAND, TWO-HAND (LEFT-HAND is not considered here)\\n  /// 2) ring can be LEFT, RIGHT\\n  /// 3) skill can be SKILL_1, SKILL_2, SKILL_3\\n  /// Story-writer is able to specify only one slot to break.\\n  /// 1) if ONE/TWO-HAND slot is specified then any available weapon (ONE or TWO hands) should be broken\\n  /// 2) if LEFT right is specified then random(LEFT or RIGHT) slot should be broken\\n  /// 3) skills - there is same rule as for the rings\\n  /// @return slots Slots that should be checked. Normally {slots} contains same item twice.\\n  /// The items are different in one case only: [RIGHT_HAND, TWO_HAND]\\n  function _adjustSlotToBreak(uint8 slot, IOracle oracle) internal returns (uint8[2] memory slots) {\\n    if (slot == uint8(IStatController.ItemSlots.RIGHT_HAND) || slot == uint8(IStatController.ItemSlots.TWO_HAND)) {\\n      return [uint8(IStatController.ItemSlots.RIGHT_HAND), uint8(IStatController.ItemSlots.TWO_HAND)];\\n    } else if (slot == uint8(IStatController.ItemSlots.RIGHT_RING) || slot == uint8(IStatController.ItemSlots.LEFT_RING)) {\\n      uint8 selectedSlot = (oracle.getRandomNumber(1, 0) == 0)\\n        ? uint8(IStatController.ItemSlots.RIGHT_RING)\\n        : uint8(IStatController.ItemSlots.LEFT_RING);\\n      return [selectedSlot, selectedSlot];\\n    } else if (\\n      slot == uint8(IStatController.ItemSlots.SKILL_1)\\n      || slot == uint8(IStatController.ItemSlots.SKILL_2)\\n      || slot == uint8(IStatController.ItemSlots.SKILL_3)\\n    ) {\\n      uint rnd = oracle.getRandomNumber(2, 0);\\n      uint8 selectedSlot = (rnd == 0)\\n        ? uint8(IStatController.ItemSlots.SKILL_1)\\n        : ((rnd == 1)\\n          ? uint8(IStatController.ItemSlots.SKILL_2)\\n          : uint8(IStatController.ItemSlots.SKILL_3));\\n      return [selectedSlot, selectedSlot];\\n    } else {\\n      return [slot, slot];\\n    }\\n  }\\n\\n  /// @notice Update internal hero state, generate {result}\\n  /// @param context We update some fields in place, so memory, not calldata here\\n  function handleAnswer(\\n    IStoryController.AnswerResultId answerResultId,\\n    IStoryController.MainState storage s,\\n    IStoryController.StoryActionContext memory context\\n  ) external returns (\\n    IGOC.ActionResult memory result,\\n    uint16 nextPage,\\n    uint16[] memory nextPages\\n  ) {\\n    return _handleAnswer(answerResultId, s, context, _mintRandomItems);\\n  }\\n\\n  /// @notice Update internal hero state, generate {result}\\n  /// @param context We update some fields in place, so memory, not calldata here\\n  /// @param mintItems_ Function _mintRandomItems is passed here. Parameter is required to make unit tests.\\n  function _handleAnswer(\\n    IStoryController.AnswerResultId answerResultId,\\n    IStoryController.MainState storage s,\\n    IStoryController.StoryActionContext memory context,\\n    function (IStoryController.StoryActionContext memory, bytes32[] memory) internal returns (address[] memory) mintItems_\\n  ) internal returns (\\n    IGOC.ActionResult memory result,\\n    uint16 nextPage,\\n    uint16[] memory nextPages\\n  ) {\\n    result.objectId = context.objectId;\\n    result.heroTokenId = context.heroTokenId;\\n    result.heroToken = context.heroToken;\\n\\n    nextPages = s.nextPageIds[context.storyId.packStoryNextPagesId(\\n      context.pageId,\\n      context.heroClassFromAnswerHash,\\n      context.answerNumber,\\n      uint8(answerResultId)\\n    )];\\n    nextPage = _getNextPage(context.oracle, nextPages);\\n\\n    // number of items that can be minted inside single iteration in the story is limited\\n    // if the max is reached the minting is silently skipped\\n    // we assume here, that mintItems_ mints only 1 item so it's not necessary to limit number of minted items inside mintItems_\\n    uint mintedInIteration = _getMintedInIteration(s, context);\\n\\n    if (answerResultId == IStoryController.AnswerResultId.SUCCESS) {\\n      result = handleResult(\\n        context,\\n        s.successInfoAttributes[context.answerIdHash],\\n        s.successInfoStats[context.answerIdHash],\\n        mintedInIteration < MAX_MINTED_ITEMS_PER_ITERATION ? s.successInfoMintItems[context.answerIdHash] : new bytes32[](0),\\n        mintItems_\\n      );\\n\\n      handleCustomDataResult(\\n        context,\\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\\n          context.pageId,\\n          context.heroClassFromAnswerHash,\\n          context.answerNumber,\\n          uint8(IStoryController.CustomDataResult.HERO_SUCCESS)\\n        )],\\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\\n          context.pageId,\\n          context.heroClassFromAnswerHash,\\n          context.answerNumber,\\n          uint8(IStoryController.CustomDataResult.GLOBAL_SUCCESS)\\n        )]\\n      );\\n    } else {\\n      result = handleResult(\\n        context,\\n        s.failInfoAttributes[context.answerIdHash],\\n        s.failInfoStats[context.answerIdHash],\\n        mintedInIteration < MAX_MINTED_ITEMS_PER_ITERATION ? s.failInfoMintItems[context.answerIdHash] : new bytes32[](0),\\n        mintItems_\\n      );\\n\\n      handleCustomDataResult(\\n        context,\\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\\n          context.pageId,\\n          context.heroClassFromAnswerHash,\\n          context.answerNumber,\\n          uint8(IStoryController.CustomDataResult.HERO_FAIL)\\n        )],\\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\\n          context.pageId,\\n          context.heroClassFromAnswerHash,\\n          context.answerNumber,\\n          uint8(IStoryController.CustomDataResult.GLOBAL_FAIL)\\n        )]\\n      );\\n    }\\n\\n    if (result.mintItems.length != 0) {\\n      _setMintedInIteration(s, context, mintedInIteration + result.mintItems.length);\\n    }\\n  }\\n\\n  /// @notice Check if the user has already minted an item within the current iteration of the story.\\n  /// if the item is already minted any additional minting should be skipped without revert\\n  function _getMintedInIteration(IStoryController.MainState storage s, IStoryController.StoryActionContext memory context)\\n  internal view returns (uint countMintedItems) {\\n    return s.mintedInIteration[context.heroToken.packStoryHeroStateId(context.heroTokenId, context.storyId)][context.iteration];\\n  }\\n\\n  /// @notice Mark that the user has already minted an item within the current iteration of the story\\n  /// Only minting of the single item is allowed per iteration\\n  function _setMintedInIteration(\\n    IStoryController.MainState storage s,\\n    IStoryController.StoryActionContext memory context,\\n    uint newCountMintedItems\\n  ) internal {\\n    s.mintedInIteration[context.heroToken.packStoryHeroStateId(context.heroTokenId, context.storyId)][context.iteration] = newCountMintedItems;\\n  }\\n\\n  /// @notice Revert if {heroAnswers} doesn't contain {answerIdHash}\\n  function checkAnswerIndexValid(bytes32[] memory heroAnswers, bytes32 answerIdHash) internal pure {\\n    uint len = heroAnswers.length;\\n    for (uint i; i < len; ++i) {\\n      if (heroAnswers[i] == answerIdHash) return;\\n    }\\n    revert IAppErrors.NotAnswer();\\n  }\\n\\n  /// @notice Clear heroState for the current story\\n  /// @return nextObjs Default nextObjectsRewrite for the current page (values for 0 hero class)\\n  function finishStory(IStoryController.StoryActionContext memory ctx, IStoryController.MainState storage s) internal returns (\\n    uint32[] memory nextObjs\\n  ) {\\n    delete s.heroState[ctx.heroToken.packStoryHeroStateId(ctx.heroTokenId, ctx.storyId)];\\n    // It's not necessary to clear mintedInIteration because for each hero each object has a sequence of iterations\\n    // that is not reset on changing dungeons\\n\\n    return s.nextObjectsRewrite[ctx.storyId.packStoryPageId(ctx.pageId, 0)];\\n  }\\n\\n  //endregion ------------------------ Story logic\\n\\n  //region ------------------------ Internal utils for story logic\\n\\n  /// @dev This function is made separate to simplify unit testing\\n  function _mintRandomItems(IStoryController.StoryActionContext memory context, bytes32[] memory mintItemsData) internal returns (\\n    address[] memory\\n  ) {\\n    uint len = mintItemsData.length;\\n    address[] memory mintItems = new address[](len);\\n    uint32[] memory mintItemsChances = new uint32[](len);\\n    for (uint i; i < len; ++i) {\\n      (mintItems[i], mintItemsChances[i]) = mintItemsData[i].unpackItemMintInfo();\\n    }\\n\\n    return ItemLib.mintRandomItems(ItemLib.MintItemInfo({\\n      mintItems: mintItems,\\n      mintItemsChances: mintItemsChances,\\n      amplifier: 0,\\n      seed: 0,\\n      oracle: context.oracle,\\n      magicFind: 0,\\n      destroyItems: 0,\\n      maxItems: 1, // MINT ONLY 1 ITEM!\\n      mintDropChanceDelta: StatLib.mintDropChanceDelta(context.heroStats.experience, uint8(context.heroStats.level), context.biome),\\n      mintDropChanceNgLevelMultiplier: 1e18\\n    }));\\n  }\\n\\n  /// @param attributesChanges Values+ids packed using toBytes32ArrayWithIds\\n  function _generateAttributes(bytes32[] memory attributesChanges) internal pure returns (int32[] memory attributes) {\\n    if (attributesChanges.length != 0) {\\n      (int32[] memory values, uint8[] memory ids) = attributesChanges.toInt32ArrayWithIds();\\n      uint len = ids.length;\\n      if (len != 0) {\\n        attributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n        for (uint i; i < len; ++i) {\\n          int32 value = values[i];\\n          attributes[ids[i]] = value;\\n        }\\n      }\\n    }\\n\\n    return attributes;\\n  }\\n\\n  function _generateStats(bytes32 statsChanges) internal pure returns (IStoryController.StatsChange memory change) {\\n    (\\n      change.experience,\\n      change.heal,\\n      change.manaRegen,\\n      change.lifeChancesRecovered,\\n      change.damage,\\n      change.manaConsumed\\n    ) = statsChanges.unpackStatsChange();\\n\\n    return change;\\n  }\\n\\n  /// @notice Break the item from the given {slot} (i.e. reduce item's durability to 0) and take it off\\n  /// Broken item is taken off also.\\n  function _breakItemInHeroSlot(IStoryController.StoryActionContext memory ctx, uint8 slot) internal {\\n    (address itemAdr, uint itemId) = ctx.statController.heroItemSlot(ctx.heroToken, uint64(ctx.heroTokenId), slot).unpackNftId();\\n\\n    // take off the broken item and mark it as broken\\n    ctx.itemController.takeOffDirectly(itemAdr, itemId, ctx.heroToken, ctx.heroTokenId, slot, ctx.sender, true);\\n\\n    // add 1% of fragility, deprecated\\n    // ctx.itemController.incBrokenItemFragility(itemAdr, itemId);\\n\\n    emit IApplicationEvents.ItemBroken(\\n      ctx.heroToken,\\n      ctx.heroTokenId,\\n      ctx.dungeonId,\\n      ctx.objectId,\\n      itemAdr,\\n      itemId,\\n      ctx.stageId,\\n      ctx.iteration\\n    );\\n  }\\n\\n  function _getNextPage(IOracle oracle, uint16[] memory pages) internal returns (uint16) {\\n    if (pages.length == 0) {\\n      return 0;\\n    }\\n    if (pages.length == 1) {\\n      return pages[0];\\n    }\\n    return pages[oracle.getRandomNumberInRange(0, pages.length - 1, 0)];\\n  }\\n\\n  function _getStoryIndex(uint16 storyId) internal pure returns (bytes32) {\\n    return bytes32(abi.encodePacked(\\\"STORY_\\\", StringLib._toString(storyId)));\\n  }\\n  //endregion ------------------------ Internal utils for story logic\\n\\n  //region ------------------------ Check answers\\n\\n  function checkAnswer(\\n    IStoryController.StoryActionContext memory context,\\n    IStoryController.MainState storage s\\n  ) external returns (IStoryController.AnswerResultId result) {\\n    result = checkAnswerAttributes(context, context.answerIdHash, s);\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerItems(context, context.answerIdHash, s);\\n    }\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerTokens(context, context.answerIdHash, s);\\n    }\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerDelay(context);\\n    }\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerHeroCustomData(context, context.answerIdHash, s);\\n    }\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerGlobalCustomData(context, context.answerIdHash, s);\\n    }\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerRandom(context);\\n    }\\n  }\\n\\n  /// @notice Check if hero attribute values meet attribute requirements for the given answer\\n  function checkAnswerAttributes(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32 answerIndex,\\n    IStoryController.MainState storage s\\n  ) internal view returns (IStoryController.AnswerResultId) {\\n    bytes32[] storage reqs = s.attributeRequirements[answerIndex];\\n    uint length = reqs.length;\\n\\n    for (uint i; i < length; ++i) {\\n      (uint8 attributeIndex, int32 value, bool isCore) = reqs[i].unpackStoryAttributeRequirement();\\n      if (isCore) {\\n        IStatController.CoreAttributes memory base = context.statController.heroBaseAttributes(context.heroToken, context.heroTokenId);\\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.STRENGTH) && base.strength < value) {\\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\\n        }\\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.DEXTERITY) && base.dexterity < value) {\\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\\n        }\\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.VITALITY) && base.vitality < value) {\\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\\n        }\\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.ENERGY) && base.energy < value) {\\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\\n        }\\n      } else {\\n        int32 attr = context.statController.heroAttribute(context.heroToken, context.heroTokenId, attributeIndex);\\n        if (attr < value) {\\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\\n        }\\n      }\\n    }\\n\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  /// @notice Check item requirements for the given answer, check following issues:\\n  /// 1) For equipped item: check if it is on balance\\n  /// 2) For not equipped item: burn first owned item if requireItemBurn OR check that not equipped item is on balance\\n  function checkAnswerItems(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32 answerIndex,\\n    IStoryController.MainState storage s\\n  ) internal returns (IStoryController.AnswerResultId) {\\n\\n    bytes32[] storage reqs = s.itemRequirements[answerIndex];\\n    uint length = reqs.length;\\n\\n    for (uint i; i < length; ++i) {\\n      (address item, bool requireItemBurn, bool requireItemEquipped) = reqs[i].unpackStoryItemRequirement();\\n\\n      // equipped item is on balance of the heroToken, not on balance of the sender\\n      if (requireItemEquipped && IERC721Enumerable(item).balanceOf(context.heroToken) == 0) {\\n        revert IAppErrors.NotItem1();\\n      }\\n\\n      if (requireItemBurn) {\\n        _burnFirstOwnedItem(context, item);\\n      }\\n\\n      if (!requireItemEquipped && !requireItemBurn) {\\n        if (IERC721Enumerable(item).balanceOf(context.sender) == 0) revert IAppErrors.NotItem2();\\n      }\\n\\n    }\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  /// @notice burn first owned item and generate event\\n  /// @dev Use separate function to workaround stack too deep\\n  function _burnFirstOwnedItem(IStoryController.StoryActionContext memory context, address item) internal {\\n    uint itemId = IERC721Enumerable(item).tokenOfOwnerByIndex(context.sender, 0);\\n    context.itemController.destroy(item, itemId); // destroy reverts if the item is equipped\\n\\n    emit IApplicationEvents.NotEquippedItemBurned(\\n      context.heroToken,\\n      context.heroTokenId,\\n      context.dungeonId,\\n      context.storyId,\\n      item,\\n      itemId,\\n      context.stageId,\\n      context.iteration\\n    );\\n  }\\n\\n  /// @notice Ensure that the sender has enough amounts of the required tokens, send fees to the treasury\\n  function checkAnswerTokens(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32 answerIndex,\\n    IStoryController.MainState storage s\\n  ) internal returns (IStoryController.AnswerResultId) {\\n    bytes32[] memory reqs = s.tokenRequirements[answerIndex];\\n    uint length = reqs.length;\\n    for (uint i; i < length; ++i) {\\n      (address token, uint88 amount, bool requireTransfer) = reqs[i].unpackStoryTokenRequirement();\\n      amount = uint88(adjustTokenAmountToGameToken(uint(amount), context.controller));\\n\\n      if (amount != 0) {\\n        uint balance = IERC20(token).balanceOf(context.sender);\\n        if (balance < uint(amount)) revert IAppErrors.NotEnoughAmount(balance, uint(amount));\\n\\n        if (requireTransfer) {\\n          context.controller.process(token, amount, context.sender);\\n        }\\n      }\\n    }\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  function adjustTokenAmountToGameToken(uint amount, IController controller) internal view returns(uint) {\\n    return amount * controller.gameTokenPrice() / 1e18;\\n  }\\n\\n  /// @notice Generate error randomly\\n  function checkAnswerRandom(IStoryController.StoryActionContext memory context) internal returns (IStoryController.AnswerResultId) {\\n    (uint32 random,,) = context.answerAttributes.unpackStorySimpleRequirement();\\n\\n    if (random != 0 && random < 100) {\\n      if (context.oracle.getRandomNumber(100, 0) > uint(random)) {\\n        return IStoryController.AnswerResultId.RANDOM_FAIL;\\n      }\\n    } else if (random > 100) {\\n      revert IAppErrors.NotRandom(random);\\n    }\\n\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  /// @notice Ensure that the answer was given fast enough\\n  function checkAnswerDelay(IStoryController.StoryActionContext memory context) internal view returns (IStoryController.AnswerResultId) {\\n\\n    (,uint32 delay,) = context.answerAttributes.unpackStorySimpleRequirement();\\n\\n    if (delay != 0) {\\n      uint lastCall = uint(context.heroLastActionTS);\\n      if (lastCall != 0 && lastCall < block.timestamp && block.timestamp - lastCall > uint(delay)) {\\n        return IStoryController.AnswerResultId.DELAY_FAIL;\\n      }\\n    }\\n\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  function checkAnswerHeroCustomData(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32 answerIndex,\\n    IStoryController.MainState storage s\\n  ) internal view returns (IStoryController.AnswerResultId) {\\n    return _checkAnswerCustomData(context, s.heroCustomDataRequirement[answerIndex], true);\\n  }\\n\\n  function checkAnswerGlobalCustomData(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32 answerIndex,\\n    IStoryController.MainState storage s\\n  ) internal view returns (IStoryController.AnswerResultId) {\\n    return _checkAnswerCustomData(context, s.globalCustomDataRequirement[answerIndex], false);\\n  }\\n\\n  function _checkAnswerCustomData(\\n    IStoryController.StoryActionContext memory context,\\n    IStoryController.CustomDataRequirementPacked[] memory datas,\\n    bool heroCustomData\\n  ) internal view returns (IStoryController.AnswerResultId) {\\n    uint len = datas.length;\\n    for (uint i; i < len; ++i) {\\n      IStoryController.CustomDataRequirementPacked memory data = datas[i];\\n\\n      if (data.index != 0) {\\n        (uint valueMin, uint valueMax, bool mandatory) = data.data.unpackCustomDataRequirements();\\n        uint heroValue = heroCustomData\\n          ? context.statController.heroCustomData(context.heroToken, context.heroTokenId, data.index)\\n          : context.statController.globalCustomData(data.index);\\n\\n        if (heroValue < valueMin || heroValue > valueMax) {\\n          if (mandatory) {\\n            if (heroCustomData) {\\n              revert IAppErrors.NotHeroData();\\n            } else {\\n              revert IAppErrors.NotGlobalData();\\n            }\\n          } else {\\n            return heroCustomData\\n              ? IStoryController.AnswerResultId.HERO_CUSTOM_DATA_FAIL\\n              : IStoryController.AnswerResultId.GLOBAL_CUSTOM_DATA_FAIL;\\n          }\\n        }\\n      }\\n    }\\n\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  //endregion ------------------------ Check answers\\n}\\n\",\"keccak256\":\"0x2658e61e6aefd53978997b9b314a1ec5e16601658b3aee4cbedb278ef08e6fcd\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StringLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n\\nlibrary StringLib {\\n\\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n  function toString(uint value) external pure returns (string memory) {\\n    return _toString(value);\\n  }\\n\\n  function _toString(uint value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint temp = value;\\n    uint digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  function toAsciiString(address x) external pure returns (string memory) {\\n    return _toAsciiString(x);\\n  }\\n\\n  function _toAsciiString(address x) internal pure returns (string memory) {\\n    bytes memory s = new bytes(40);\\n    for (uint i = 0; i < 20; i++) {\\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n      bytes1 hi = bytes1(uint8(b) / 16);\\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n      s[2 * i] = _char(hi);\\n      s[2 * i + 1] = _char(lo);\\n    }\\n    return string(s);\\n  }\\n\\n  function char(bytes1 b) external pure returns (bytes1 c) {\\n    return _char(b);\\n  }\\n\\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n    else return bytes1(uint8(b) + 0x57);\\n  }\\n\\n  function concat(string memory a, string memory b) internal pure returns (string memory) {\\n    return string(abi.encodePacked(a, b));\\n  }\\n\\n  function isASCIILettersOnly(string memory str) internal pure returns (bool) {\\n    bytes memory b = bytes(str);\\n    for (uint i = 0; i < b.length; i++) {\\n      if (uint8(b[i]) < 32 || uint8(b[i]) > 127) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\",\"keccak256\":\"0xcf94b1e6e63466d0100f5181a080968017995f5019a2cfdb35f1ae4a3b7dab3b\",\"license\":\"BUSL-1.1\"},\"contracts/openzeppelin/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  // To implement this library for multiple types with as little code repetition as possible, we write it in\\n  // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\\n  // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\\n  // This means that we can only create new EnumerableMaps for types that fit in bytes32.\\n\\n  /**\\n   * @dev Query for a nonexistent map key.\\n     */\\n  error EnumerableMapNonexistentKey(bytes32 key);\\n\\n  struct Bytes32ToBytes32Map {\\n    // Storage of keys\\n    EnumerableSet.Bytes32Set _keys;\\n    mapping(bytes32 key => bytes32) _values;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n    map._values[key] = value;\\n    return map._keys.add(key);\\n  }\\n\\n  /**\\n   * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n    delete map._values[key];\\n    return map._keys.remove(key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n    return map._keys.contains(key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n    return map._keys.length();\\n  }\\n\\n  /**\\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n    bytes32 key = map._keys.at(index);\\n    return (key, map._values[key]);\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == bytes32(0)) {\\n      return (contains(map, key), bytes32(0));\\n    } else {\\n      return (true, value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == 0 && !contains(map, key)) {\\n      revert EnumerableMapNonexistentKey(key);\\n    }\\n    return value;\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n    return map._keys.values();\\n  }\\n\\n  // UintToUintMap\\n\\n  struct UintToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key)));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintToAddressMap\\n\\n  struct UintToAddressMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressToUintMap\\n\\n  struct AddressToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n    return remove(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (address(uint160(uint256(key))), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // Bytes32ToUintMap\\n\\n  struct Bytes32ToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, key, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n    return remove(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n    return contains(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (key, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, key);\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, key));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x5052395b3d57e4347a977f96eba69188b4a952594afae411910995ecab5c1d05\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position is the index of the value in the `values` array plus 1.\\n    // Position 0 is used to mean a value is not in the set.\\n    mapping(bytes32 value => uint256) _positions;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._positions[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We cache the value's position to prevent multiple reads from the same storage slot\\n    uint256 position = set._positions[value];\\n\\n    if (position != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 valueIndex = position - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (valueIndex != lastIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the lastValue to the index where the value to delete is\\n        set._values[valueIndex] = lastValue;\\n        // Update the tracked position of the lastValue (that was just moved)\\n        set._positions[lastValue] = position;\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the tracked position for the deleted slot\\n      delete set._positions[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._positions[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n     */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xd5483249a7bac53a40791ade8d640831cdec526eea6b42a4db68f2ce13c008fa\",\"license\":\"MIT\"},\"contracts/openzeppelin/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n  struct InitializableStorage {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n         */\\n    uint64 _initialized;\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n    bool _initializing;\\n  }\\n\\n  // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n  /**\\n   * @dev The contract is already initialized.\\n     */\\n  error InvalidInitialization();\\n\\n  /**\\n   * @dev The contract is not initializing.\\n     */\\n  error NotInitializing();\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n  event Initialized(uint64 version);\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier initializer() {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    // Cache values to avoid duplicated sloads\\n    bool isTopLevelCall = !$._initializing;\\n    uint64 initialized = $._initialized;\\n\\n    // Allowed calls:\\n    // - initialSetup: the contract is not in the initializing state and no previous version was\\n    //                 initialized\\n    // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n    //                 current contract is just being deployed\\n    bool initialSetup = initialized == 0 && isTopLevelCall;\\n    bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n    if (!initialSetup && !construction) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = 1;\\n    if (isTopLevelCall) {\\n      $._initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      $._initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier reinitializer(uint64 version) {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing || $._initialized >= version) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = version;\\n    $._initializing = true;\\n    _;\\n    $._initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n  modifier onlyInitializing() {\\n    _checkInitializing();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n  function _checkInitializing() internal view virtual {\\n    if (!_isInitializing()) {\\n      revert NotInitializing();\\n    }\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n  function _disableInitializers() internal virtual {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing) {\\n      revert InvalidInitialization();\\n    }\\n    if ($._initialized != type(uint64).max) {\\n      $._initialized = type(uint64).max;\\n      emit Initialized(type(uint64).max);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n  function _getInitializedVersion() internal view returns (uint64) {\\n    return _getInitializableStorage()._initialized;\\n  }\\n\\n  /**\\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n  function _isInitializing() internal view returns (bool) {\\n    return _getInitializableStorage()._initializing;\\n  }\\n\\n  /**\\n   * @dev Returns a pointer to the storage namespace.\\n     */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n    assembly {\\n      $.slot := INITIALIZABLE_STORAGE\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x80aa3fc0fc9afdf84bd1a51716150cd13041f42d920a9afa8020ea41cf673809\",\"license\":\"MIT\"},\"contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n\\n  /**\\n    * @dev Muldiv operation overflow.\\n   */\\n  error MathOverflowedMulDiv();\\n\\n  enum Rounding {\\n    Floor, // Toward negative infinity\\n    Ceil, // Toward positive infinity\\n    Trunc, // Toward zero\\n    Expand // Away from zero\\n  }\\n\\n  /**\\n   * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      uint256 c = a + b;\\n      if (c < a) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b > a) return (false, 0);\\n      return (true, a - b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n      if (a == 0) return (true, 0);\\n      uint256 c = a * b;\\n      if (c / a != b) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a / b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a % b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (b == 0) {\\n      // Guarantee the same behavior as in a regular Solidity division.\\n      return a / b;\\n    }\\n\\n    // The following calculation ensures accurate ceiling division without overflow.\\n    // Since a is non-zero, (a - 1) / b will not overflow.\\n    // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n    // but the largest value we can obtain is type(uint256).max - 1, which happens\\n    // when a = type(uint256).max and b = 1.\\n    unchecked {\\n      return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n    unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n      uint256 prod0 = x * y; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n      if (prod1 == 0) {\\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n        // The surrounding unchecked block does not change this fact.\\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n        return prod0 / denominator;\\n      }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n      if (denominator <= prod1) {\\n        revert MathOverflowedMulDiv();\\n      }\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n      uint256 remainder;\\n      assembly {\\n      // Compute remainder using mulmod.\\n        remainder := mulmod(x, y, denominator)\\n\\n      // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n    // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n      uint256 twos = denominator & (0 - denominator);\\n      assembly {\\n      // Divide denominator by twos.\\n        denominator := div(denominator, twos)\\n\\n      // Divide [prod1 prod0] by twos.\\n        prod0 := div(prod0, twos)\\n\\n      // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n\\n    // Shift in bits from prod1 into prod0.\\n      prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n      uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n    // works in modular arithmetic, doubling the correct bits in each step.\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n      result = prod0 * inverse;\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n    unchecked {\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      return min(result, a / result);\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = sqrt(a);\\n      return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 128;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 64;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 32;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 16;\\n      }\\n      if (value >> 8 > 0) {\\n        value >>= 8;\\n        result += 8;\\n      }\\n      if (value >> 4 > 0) {\\n        value >>= 4;\\n        result += 4;\\n      }\\n      if (value >> 2 > 0) {\\n        value >>= 2;\\n        result += 2;\\n      }\\n      if (value >> 1 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log2(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >= 10 ** 64) {\\n        value /= 10 ** 64;\\n        result += 64;\\n      }\\n      if (value >= 10 ** 32) {\\n        value /= 10 ** 32;\\n        result += 32;\\n      }\\n      if (value >= 10 ** 16) {\\n        value /= 10 ** 16;\\n        result += 16;\\n      }\\n      if (value >= 10 ** 8) {\\n        value /= 10 ** 8;\\n        result += 8;\\n      }\\n      if (value >= 10 ** 4) {\\n        value /= 10 ** 4;\\n        result += 4;\\n      }\\n      if (value >= 10 ** 2) {\\n        value /= 10 ** 2;\\n        result += 2;\\n      }\\n      if (value >= 10 ** 1) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log10(value);\\n      return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 16;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 8;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 4;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 2;\\n      }\\n      if (value >> 8 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log256(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n  function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n    return uint8(rounding) % 2 == 1;\\n  }\\n\\n}\\n\",\"keccak256\":\"0x4d972e3e1d79f693b6cb42007d23c27256cb6f087392edea24b93585a822572c\",\"license\":\"MIT\"},\"contracts/proxy/Controllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Initializable.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../lib/SlotsLib.sol\\\";\\n\\n/// @title Implement basic functionality for any contract that require strict control\\n/// @dev Can be used with upgradeable pattern.\\n///      Require call __Controllable_init() in any case.\\n/// @author belbix\\nabstract contract Controllable is Initializable, IControllable {\\n  using SlotsLib for bytes32;\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant CONTROLLABLE_VERSION = \\\"1.0.0\\\";\\n\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.revision\\\")) - 1);\\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.prev_logic\\\")) - 1);\\n\\n  event ContractInitialized(address controller, uint ts, uint block);\\n  event RevisionIncreased(uint value, address oldLogic);\\n\\n  // init implementation contract\\n  constructor() initializer {}\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\n  /// @dev Use it only once after first logic setup\\n  /// @param controller_ Controller address\\n  function __Controllable_init(address controller_) internal onlyInitializing {\\n    _init(controller_);\\n  }\\n\\n  function _init(address controller_) private {\\n    require(controller_ != address(0), \\\"Zero controller\\\");\\n    _CONTROLLER_SLOT.set(controller_);\\n    _CREATED_SLOT.set(block.timestamp);\\n    _CREATED_BLOCK_SLOT.set(block.number);\\n    emit ContractInitialized(controller_, block.timestamp, block.number);\\n  }\\n\\n  /// @dev Return true if given address is controller\\n  function isController(address value_) public override view returns (bool) {\\n    return value_ == controller();\\n  }\\n\\n  /// @notice Return true if given address is setup as governance in Controller\\n  function isGovernance(address value_) public override view returns (bool) {\\n    return IController(controller()).governance() == value_;\\n  }\\n\\n  /// @dev Contract upgrade counter\\n  function revision() external view override returns (uint) {\\n    return _REVISION_SLOT.getUint();\\n  }\\n\\n  /// @dev Previous logic implementation\\n  function previousImplementation() external view override returns (address) {\\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\\n  }\\n\\n  // ************* SETTERS/GETTERS *******************\\n\\n  /// @notice Return controller address saved in the contract slot\\n  function controller() public view override returns (address) {\\n    return _CONTROLLER_SLOT.getAddress();\\n  }\\n\\n  /// @notice Return creation timestamp\\n  /// @return Creation timestamp\\n  function created() external view override returns (uint256) {\\n    return _CREATED_SLOT.getUint();\\n  }\\n\\n  /// @notice Return creation block number\\n  /// @return Creation block number\\n  function createdBlock() external override view returns (uint256) {\\n    return _CREATED_BLOCK_SLOT.getUint();\\n  }\\n\\n  /// @dev Revision should be increased on each contract upgrade\\n  function increaseRevision(address oldLogic) external override {\\n    require(msg.sender == address(this), \\\"Increase revision forbidden\\\");\\n    uint r = _REVISION_SLOT.getUint() + 1;\\n    _REVISION_SLOT.set(r);\\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\\n    emit RevisionIncreased(r, oldLogic);\\n  }\\n\\n}\\n\",\"keccak256\":\"0x1edc53f0d11834bebf4485746d04112ed10db9d4cb19b4945362c593ebf97daf\",\"license\":\"BUSL-1.1\"},\"contracts/solady/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error FactorialOverflow();\\n\\n    /// @dev The operation failed, due to an overflow.\\n    error RPowOverflow();\\n\\n    /// @dev The mantissa is too big to fit.\\n    error MantissaOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error SMulWadFailed();\\n\\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\\n    error DivWadFailed();\\n\\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\\n    error SDivWadFailed();\\n\\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\\n    error MulDivFailed();\\n\\n    /// @dev The division failed, as the denominator is zero.\\n    error DivFailed();\\n\\n    /// @dev The full precision multiply-divide operation failed, either due\\n    /// to the result being larger than 256 bits, or a division by a zero.\\n    error FullMulDivFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /// @dev The input outside the acceptable domain.\\n    error OutOfDomain();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(x, y)\\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := sdiv(z, WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(x, WAD)\\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\\n            if iszero(and(iszero(iszero(y)), eq(sdiv(z, WAD), x))) {\\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := sdiv(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `x` to the power of `y`.\\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Using `ln(x)` means `x` must be greater than 0.\\n        return expWad((lnWad(x) * y) / int256(WAD));\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/22/exp-ln\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is less than 0.5 we return zero.\\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\\n            if (x <= -41446531673892822313) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) \\u2248 135`.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // `k` is in the range `[-61, 195]`.\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // `p` is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already `2**96` too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range `(0.09, 0.25) * 2**96`.\\n\\n            // We now need to multiply r by:\\n            // - The scale factor `s \\u2248 6.031367120`.\\n            // - The `2**k` factor from the range reduction.\\n            // - The `1e18 / 2**96` factor for base conversion.\\n            // We do this all at once, with an intermediate result in `2**213`\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256(\\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\\n            );\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/22/exp-ln\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\\n            // We do this by multiplying by `2**96 / 10**18`. But since\\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\\n            // and add `ln(2**96 / 10**18)` at the end.\\n\\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // We place the check here for more optimal stack operations.\\n            if iszero(sgt(x, 0)) {\\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // forgefmt: disable-next-item\\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x := shr(159, shl(r, x))\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // `p` is made monic, we will multiply by a scale factor later.\\n            // forgefmt: disable-next-item\\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\\n                sar(96, mul(add(43456485725739037958740375743393,\\n                sar(96, mul(add(24828157081833163892658089445524,\\n                sar(96, mul(add(3273285459638523848632254066296,\\n                    x), x))), x))), x)), 11111509109440967052023855526967)\\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\\n\\n            // `q` is monic by convention.\\n            let q := add(5573035233440673466300451813936, x)\\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\\n\\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\\n\\n            // Finalization, we need to:\\n            // - Multiply by the scale factor `s = 5.549\\u2026`.\\n            // - Add `ln(2**96 / 10**18)`.\\n            // - Add `k * ln(2)`.\\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\\n\\n            // The q polynomial is known not to have zeros in the domain.\\n            // No scaling required because p is already `2**96` too large.\\n            p := sdiv(p, q)\\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\\n            p := mul(1677202110996718588342820967067443963516166, p)\\n            // Add `ln(2) * k * 5**18 * 2**192`.\\n            // forgefmt: disable-next-item\\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\\n            // Base conversion: mul `2**18 / 2**192`.\\n            r := sar(174, p)\\n        }\\n    }\\n\\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\\n        // forgefmt: disable-next-item\\n        unchecked {\\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\\n            int256 wad = int256(WAD);\\n            int256 p = x;\\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\\n            uint256 i = 4; // Number of iterations.\\n            if (w <= 0x1ffffffffffff) {\\n                if (-0x4000000000000 <= w) {\\n                    i = 1; // Inputs near zero only take one step to converge.\\n                } else if (w <= -0x3ffffffffffffff) {\\n                    i = 32; // Inputs near `-1/e` take very long to converge.\\n                }\\n            } else if (w >> 63 == 0) {\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    // Inline log2 for more performance, since the range is small.\\n                    let v := shr(49, w)\\n                    let l := shl(3, lt(0xff, v))\\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\\n                    c := gt(l, 60)\\n                    i := add(2, add(gt(l, 53), c))\\n                }\\n            } else {\\n                int256 ll = lnWad(w = lnWad(w));\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\\n                    i := add(3, iszero(shr(68, x)))\\n                    c := iszero(shr(143, x))\\n                }\\n                if (c == 0) {\\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\\n                        int256 e = expWad(w);\\n                        /// @solidity memory-safe-assembly\\n                        assembly {\\n                            let t := mul(w, div(e, wad))\\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\\n                        }\\n                        if (p <= w) break;\\n                        p = w;\\n                    } while (--i != 0);\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        w := sub(w, sgt(w, 2))\\n                    }\\n                    return w;\\n                }\\n            }\\n            do { // Otherwise, use Halley's for faster convergence.\\n                int256 e = expWad(w);\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let t := add(w, wad)\\n                    let s := sub(mul(w, e), mul(x, wad))\\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\\n                }\\n                if (p <= w) break;\\n                p = w;\\n            } while (--i != c);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                w := sub(w, sgt(w, 2))\\n            }\\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\\n            if (c != 0) {\\n                int256 t = w | 1;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    x := sdiv(mul(x, wad), t)\\n                }\\n                x = (t * (wad + lnWad(x)));\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    w := sdiv(x, add(wad, t))\\n                }\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  GENERAL NUMBER UTILITIES                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/21/muldiv\\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                // 512-bit multiply `[p1 p0] = x * y`.\\n                // Compute the product mod `2**256` and mod `2**256 - 1`\\n                // then use the Chinese Remainder Theorem to reconstruct\\n                // the 512 bit result. The result is stored in two 256\\n                // variables such that `product = p1 * 2**256 + p0`.\\n\\n                // Least significant 256 bits of the product.\\n                result := mul(x, y) // Temporarily use `result` as `p0` to save gas.\\n                let mm := mulmod(x, y, not(0))\\n                // Most significant 256 bits of the product.\\n                let p1 := sub(mm, add(result, lt(mm, result)))\\n\\n                // Handle non-overflow cases, 256 by 256 division.\\n                if iszero(p1) {\\n                    if iszero(d) {\\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    result := div(result, d)\\n                    break\\n                }\\n\\n                // Make sure the result is less than `2**256`. Also prevents `d == 0`.\\n                if iszero(gt(d, p1)) {\\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n\\n                /*------------------- 512 by 256 division --------------------*/\\n\\n                // Make division exact by subtracting the remainder from `[p1 p0]`.\\n                // Compute remainder using mulmod.\\n                let r := mulmod(x, y, d)\\n                // `t` is the least significant bit of `d`.\\n                // Always greater or equal to 1.\\n                let t := and(d, sub(0, d))\\n                // Divide `d` by `t`, which is a power of two.\\n                d := div(d, t)\\n                // Invert `d mod 2**256`\\n                // Now that `d` is an odd number, it has an inverse\\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\\n                // Compute the inverse by starting with a seed that is correct\\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\\n                let inv := xor(2, mul(3, d))\\n                // Now use Newton-Raphson iteration to improve the precision.\\n                // Thanks to Hensel's lifting lemma, this also works in modular\\n                // arithmetic, doubling the correct bits in each step.\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\\n                result :=\\n                    mul(\\n                        // Divide [p1 p0] by the factors of two.\\n                        // Shift in bits from `p1` into `p0`. For this we need\\n                        // to flip `t` such that it is `2**256 / t`.\\n                        or(\\n                            mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)),\\n                            div(sub(result, r), t)\\n                        ),\\n                        // inverse mod 2**256\\n                        mul(inv, sub(2, mul(d, inv)))\\n                    )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Uniswap-v3-core under MIT license:\\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        result = fullMulDiv(x, y, d);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mulmod(x, y, d) {\\n                result := add(result, 1)\\n                if iszero(result) {\\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `floor(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), d)\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x / d)`.\\n    /// Reverts if `d` is zero.\\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(d) {\\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\\n    /// Reverts if the computation overflows.\\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\\n            if x {\\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\\n                let half := shr(1, b) // Divide `b` by 2.\\n                // Divide `y` by 2 every iteration.\\n                for { y := shr(1, y) } y { y := shr(1, y) } {\\n                    let xx := mul(x, x) // Store x squared.\\n                    let xxRound := add(xx, half) // Round to the nearest number.\\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\\n                    if or(lt(xxRound, xx), shr(128, x)) {\\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\\n                    // If `y` is odd:\\n                    if and(y, 1) {\\n                        let zx := mul(z, x) // Compute `z * x`.\\n                        let zxRound := add(zx, half) // Round to the nearest number.\\n                        // If `z * x` overflowed or `zx + half` overflowed:\\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\\n                            // Revert if `x` is non-zero.\\n                            if iszero(iszero(x)) {\\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\\n                                revert(0x1c, 0x04)\\n                            }\\n                        }\\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`.\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\\n            z := shl(shr(1, r), z)\\n\\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\\n\\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\\n\\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\\n\\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\\n            // Then we can estimate `sqrt(y)` using\\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\\n\\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If `x+1` is a perfect square, the Babylonian method cycles between\\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    /// @dev Returns the cube root of `x`.\\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n\\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\\n\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n\\n            z := sub(z, lt(div(x, mul(z, z)), z))\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`, denominated in `WAD`.\\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = 10 ** 9;\\n            if (x <= type(uint256).max / 10 ** 36 - 1) {\\n                x *= 10 ** 18;\\n                z = 1;\\n            }\\n            z *= sqrt(x);\\n        }\\n    }\\n\\n    /// @dev Returns the cube root of `x`, denominated in `WAD`.\\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = 10 ** 12;\\n            if (x <= (type(uint256).max / 10 ** 36) * 10 ** 18 - 1) {\\n                if (x >= type(uint256).max / 10 ** 36) {\\n                    x *= 10 ** 18;\\n                    z = 10 ** 6;\\n                } else {\\n                    x *= 10 ** 36;\\n                    z = 1;\\n                }\\n            }\\n            z *= cbrt(x);\\n        }\\n    }\\n\\n    /// @dev Returns the factorial of `x`.\\n    function factorial(uint256 x) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, 58)) {\\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            for { result := 1 } x { x := sub(x, 1) } { result := mul(result, x) }\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`.\\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\\n    /// Returns 0 if `x` is zero.\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0x0706060506020504060203020504030106050205030304010505030400000000))\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`, rounded up.\\n    /// Returns 0 if `x` is zero.\\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\\n        r = log2(x);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := add(r, lt(shl(r, 1), x))\\n        }\\n    }\\n\\n    /// @dev Returns the log10 of `x`.\\n    /// Returns 0 if `x` is zero.\\n    function log10(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\\n                x := div(x, 100000000000000000000000000000000000000)\\n                r := 38\\n            }\\n            if iszero(lt(x, 100000000000000000000)) {\\n                x := div(x, 100000000000000000000)\\n                r := add(r, 20)\\n            }\\n            if iszero(lt(x, 10000000000)) {\\n                x := div(x, 10000000000)\\n                r := add(r, 10)\\n            }\\n            if iszero(lt(x, 100000)) {\\n                x := div(x, 100000)\\n                r := add(r, 5)\\n            }\\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\\n        }\\n    }\\n\\n    /// @dev Returns the log10 of `x`, rounded up.\\n    /// Returns 0 if `x` is zero.\\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\\n        r = log10(x);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := add(r, lt(exp(10, r), x))\\n        }\\n    }\\n\\n    /// @dev Returns the log256 of `x`.\\n    /// Returns 0 if `x` is zero.\\n    function log256(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the log256 of `x`, rounded up.\\n    /// Returns 0 if `x` is zero.\\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\\n        r = log256(x);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := add(r, lt(shl(shl(3, r), 1), x))\\n        }\\n    }\\n\\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mantissa := x\\n            if mantissa {\\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\\n                    exponent := 33\\n                }\\n                if iszero(mod(mantissa, 10000000000000000000)) {\\n                    mantissa := div(mantissa, 10000000000000000000)\\n                    exponent := add(exponent, 19)\\n                }\\n                if iszero(mod(mantissa, 1000000000000)) {\\n                    mantissa := div(mantissa, 1000000000000)\\n                    exponent := add(exponent, 12)\\n                }\\n                if iszero(mod(mantissa, 1000000)) {\\n                    mantissa := div(mantissa, 1000000)\\n                    exponent := add(exponent, 6)\\n                }\\n                if iszero(mod(mantissa, 10000)) {\\n                    mantissa := div(mantissa, 10000)\\n                    exponent := add(exponent, 4)\\n                }\\n                if iszero(mod(mantissa, 100)) {\\n                    mantissa := div(mantissa, 100)\\n                    exponent := add(exponent, 2)\\n                }\\n                if iszero(mod(mantissa, 10)) {\\n                    mantissa := div(mantissa, 10)\\n                    exponent := add(exponent, 1)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\\n    /// enough to fit in the desired unsigned integer type:\\n    /// ```\\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\\n    /// ```\\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if shr(249, x) {\\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            packed := or(shl(7, x), packed)\\n        }\\n    }\\n\\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\\n        unchecked {\\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = (x & y) + ((x ^ y) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\\n        }\\n    }\\n\\n    /// @dev Returns the absolute value of `x`.\\n    function abs(int256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(sar(255, x), add(sar(255, x), x))\\n        }\\n    }\\n\\n    /// @dev Returns the absolute distance between `x` and `y`.\\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(mul(xor(sub(y, x), sub(x, y)), sgt(x, y)), sub(y, x))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\\n        }\\n    }\\n\\n    /// @dev Returns greatest common divisor of `x` and `y`.\\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { z := x } y {} {\\n                let t := y\\n                y := mod(z, y)\\n                z := t\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RAW NUMBER OPERATIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := smod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := addmod(x, y, d)\\n        }\\n    }\\n\\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mulmod(x, y, d)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf147bc4008b46ef438b2dd77a7a2dbf6ba9f13049f9a13c82a9cdf03923516ab\",\"license\":\"MIT\"},\"contracts/solady/LibPRNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for generating pseudorandom numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\\n/// @author LazyShuffler based on NextShuffler by aschlosberg (divergencearran)\\n/// (https://github.com/divergencetech/ethier/blob/main/contracts/random/NextShuffler.sol)\\nlibrary LibPRNG {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The initial length must be greater than zero and less than `2**32 - 1`.\\n    error InvalidInitialLazyShufflerLength();\\n\\n    /// @dev The new length must not be less than the current length.\\n    error InvalidNewLazyShufflerLength();\\n\\n    /// @dev The lazy shuffler has not been initialized.\\n    error LazyShufflerNotInitialized();\\n\\n    /// @dev Cannot double initialize the lazy shuffler.\\n    error LazyShufflerAlreadyInitialized();\\n\\n    /// @dev The lazy shuffle has finished.\\n    error LazyShuffleFinished();\\n\\n    /// @dev The queried index is out of bounds.\\n    error LazyShufflerGetOutOfBounds();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pseudorandom number state in memory.\\n    struct PRNG {\\n        uint256 state;\\n    }\\n\\n    /// @dev A lazy Fisher-Yates shuffler for a range `[0..n)` in storage.\\n    struct LazyShuffler {\\n        // Bits Layout:\\n        // - [0..31]    `numShuffled`\\n        // - [32..223]  `permutationSlot`\\n        // - [224..255] `length`\\n        uint256 _state;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Seeds the `prng` with `state`.\\n    function seed(PRNG memory prng, uint256 state) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(prng, state)\\n        }\\n    }\\n\\n    /// @dev Returns the next pseudorandom uint256.\\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\\n        // We simply use `keccak256` for a great balance between\\n        // runtime gas costs, bytecode size, and statistical properties.\\n        //\\n        // A high-quality LCG with a 32-byte state\\n        // is only about 30% more gas efficient during runtime,\\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\\n        // when this function is inlined.\\n        //\\n        // Using this method is about 2x more efficient than\\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n        }\\n    }\\n\\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\\n    /// between 0 (inclusive) and `upper` (exclusive).\\n    /// If your modulus is big, this method is recommended\\n    /// for uniform sampling to avoid modulo bias.\\n    /// For uniform sampling across all uint256 values,\\n    /// or for small enough moduli such that the bias is neligible,\\n    /// use {next} instead.\\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := keccak256(prng, 0x20)\\n                mstore(prng, result)\\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\\n            }\\n            result := mod(result, upper)\\n        }\\n    }\\n\\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n\\n                    {\\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                let b := add(a, 0x01)\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let o := mod(shr(128, r), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n\\n                    {\\n                        let o := mod(and(r, mask), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the standard normal distribution denominated in `WAD`.\\n    function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\\n            // The chance of drawing a sample outside 10 \\u03c3 from the standard normal distribution\\n            // is \\u2248 0.000000000000000000000015, which is insignificant for most practical purposes.\\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\\n            let s := 0x1000000000000000100000000000000010000000000000001\\n            let r1 := mulmod(result, a, n)\\n            let r2 := mulmod(r1, a, n)\\n            let r3 := mulmod(r2, a, n)\\n            // forgefmt: disable-next-item\\n            result := sub(sar(96, mul(26614938895861601847173011183,\\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the unit exponential distribution denominated in `WAD`.\\n    function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\\n            // Gas usage varies, starting from about 172+ gas.\\n            let r := keccak256(prng, 0x20)\\n            mstore(prng, r)\\n            let p := shl(129, r)\\n            let w := shl(1, r)\\n            if iszero(gt(w, p)) {\\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n                for {} 1 {} {\\n                    r := mulmod(r, a, n)\\n                    if iszero(lt(shl(129, r), w)) {\\n                        r := mulmod(r, a, n)\\n                        result := add(1000000000000000000, result)\\n                        w := shl(1, r)\\n                        p := shl(129, r)\\n                        if iszero(lt(w, p)) { break }\\n                        continue\\n                    }\\n                    w := shl(1, r)\\n                    if iszero(lt(w, shl(129, r))) { break }\\n                }\\n            }\\n            result := add(div(p, shl(129, 170141183460469231732)), result)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*       STORAGE-BASED RANGE LAZY SHUFFLING OPERATIONS        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Initializes the state for lazy-shuffling the range `[0..n)`.\\n    /// Reverts if `n == 0 || n >= 2**32 - 1`.\\n    /// Reverts if `$` has already been initialized.\\n    /// If you need to reduce the length after initialization, just use a fresh new `$`.\\n    function initialize(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sload($.slot) {\\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, $.slot)\\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Increases the length of `$`.\\n    /// Reverts if `$` has not been initialized.\\n    function grow(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            // If the new length is smaller than the old length, revert.\\n            if lt(n, shr(224, state)) {\\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\\n        }\\n    }\\n\\n    /// @dev Restarts the shuffler by setting `numShuffled` to zero,\\n    /// such that all elements can be drawn again.\\n    /// Restarting does NOT clear the internal permutation, nor changes the length.\\n    /// Even with the same sequence of randomness, reshuffling can yield different results.\\n    function restart(LazyShuffler storage $) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot)\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, shl(32, shr(32, state)))\\n        }\\n    }\\n\\n    /// @dev Returns the number of elements that have been shuffled.\\n    function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := and(0xffffffff, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns the length of `$`.\\n    /// Returns zero if `$` is not initialized, else a non-zero value less than `2**32 - 1`.\\n    function length(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := shr(224, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns if `$` has been initialized.\\n    function initialized(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(iszero(sload($.slot)))\\n        }\\n    }\\n\\n    /// @dev Returns if there are any more elements left to shuffle.\\n    /// Reverts if `$` is not initialized.\\n    function finished(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := eq(shr(224, state), and(0xffffffff, state))\\n        }\\n    }\\n\\n    /// @dev Returns the current value stored at `index`, accounting for all historical shuffling.\\n    /// Reverts if `index` is greater than or equal to the `length` of `$`.\\n    function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            let n := shr(224, state) // Length of `$`.\\n            if iszero(lt(index, n)) {\\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let u32 := gt(n, 0xfffe)\\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\\n            result := and(m, shr(o, sload(s)))\\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\\n        }\\n    }\\n\\n    /// @dev Does a single Fisher-Yates shuffle step, increments the `numShuffled` in `$`,\\n    /// and returns the next value in the shuffled range.\\n    /// `randomness` can be taken from a good-enough source, or a higher quality source like VRF.\\n    /// Reverts if there are no more values to shuffle, which includes the case if `$` is not initialized.\\n    function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function _get(u32_, state_, i_) -> _value {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                _value := and(m_, shr(o_, sload(s_)))\\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\\n            }\\n            function _set(u32_, state_, i_, value_) {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                let v_ := sload(s_) // Bucket slot value.\\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\\n            }\\n            let state := sload($.slot) // The packed value at `$`.\\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\\n            let n := shr(224, state) // Length of `$`.\\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\\n            if iszero(remainder) {\\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\\n            chosen := _get(gt(n, 0xfffe), state, index)\\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdcb71f8dc72bb7384776154ca24d34c23e3c9bcf124bc75f0d2e379f9ebd021d\",\"license\":\"MIT\"},\"contracts/token/GuildBank.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n/**\\n            \\u2592\\u2593\\u2592  \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2593\\n             \\u2592\\u2588\\u2588\\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593  \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n              \\u2592\\u2588\\u2588\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592 \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n               \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592                   \\u2592\\u2588\\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                     \\u2592\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592     \\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                   \\u2592\\u2592\\u2592\\u2592\\u2592   \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                         \\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                       \\u2592\\u2588\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\n                        \\u2592\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592       \\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\n                          \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593   \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                           \\u2592\\u2592\\u2593\\u2593\\u2592   \\u2592\\u2588\\u2588\\u2593\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                  \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                                 \\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                                \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n      \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593                  \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                      \\u2592\\u2593\\u2593\\n    \\u2592\\u2593\\u2588\\u2592   \\u2592\\u2592\\u2588\\u2592\\u2592                   \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2592\\u2593\\u2593\\u2592\\n   \\u2592\\u2592\\u2588\\u2592       \\u2593\\u2592                    \\u2592\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2588\\u2593\\u2592\\n   \\u2593\\u2592\\u2588\\u2588\\u2593\\u2592                             \\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2592\\n    \\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2593\\u2592        \\u2592\\u2592\\u2592         \\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592\\u2592\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2592 \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n     \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2592\\u2592\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2593\\u2593     \\u2593\\u2593  \\u2593\\u2593\\u2588\\u2593   \\u2592\\u2592\\u2593\\u2593   \\u2592\\u2592\\u2588\\u2592   \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n            \\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592  \\u2592\\u2593\\u2593\\u2593\\u2592\\u2588\\u2592   \\u2592\\u2592\\u2592\\u2588\\u2592          \\u2592\\u2592\\u2588\\u2593\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592   \\u2593\\u2588\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\n \\u2592            \\u2592\\u2593\\u2593\\u2588\\u2593  \\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2593  \\u2592\\u2588\\u2593\\u2593\\u2592          \\u2593\\u2593\\u2588\\u2593\\u2592\\u2593\\u2588\\u2593\\u2592\\u2592   \\u2593\\u2588\\u2593        \\u2593\\u2588\\u2588\\u2588\\u2593\\n\\u2593\\u2593\\u2592         \\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592\\u2592\\u2593\\u2588\\u2592   \\u2592\\u2593\\u2588\\u2588\\u2593  \\u2593\\u2588\\u2588\\u2593\\u2592     \\u2592\\u2588\\u2593 \\u2593\\u2593\\u2588\\u2588   \\u2592\\u2593\\u2593\\u2593\\u2592\\u2592\\u2593\\u2588\\u2593        \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2592\\n \\u2588\\u2588\\u2593\\u2593\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592\\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592     \\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592\\n*/\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IGuildBank.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport {IApplicationEvents} from \\\"../interfaces/IApplicationEvents.sol\\\";\\n\\ncontract GuildBank is IGuildBank {\\n\\n  //region ------------------------ CONSTANTS\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant VERSION = \\\"1.0.1\\\";\\n  //endregion ------------------------ CONSTANTS\\n\\n  //region ------------------------ Members\\n  IGuildController immutable public guildController;\\n  uint immutable public guildId;\\n  //endregion ------------------------ Members\\n\\n  //region ------------------------ Restrictions and constructor\\n  function _onlyGuildController(address msgSender) internal view {\\n    if (msgSender != address(guildController)) revert IAppErrors.GuildControllerOnly();\\n  }\\n\\n  constructor (address guildController_, uint guildId_) {\\n    guildController = IGuildController(guildController_);\\n    guildId = guildId_;\\n  }\\n  //endregion ------------------------ Restrictions and constructor\\n\\n  //region ------------------------ ERC20\\n  function transfer(address token, address recipient, uint amount) external {\\n    _onlyGuildController(msg.sender);\\n\\n    IERC20(token).transfer(recipient, amount);\\n    emit IApplicationEvents.GuildBankTransfer(token, recipient, amount);\\n  }\\n\\n  function approve(address token, address spender, uint256 amount) external returns (bool) {\\n    _onlyGuildController(msg.sender);\\n\\n    return IERC20(token).approve(spender, amount);\\n  }\\n  //endregion ------------------------ ERC20\\n\\n  //region ------------------------ ERC721\\n  function transferNft(address to, address nft, uint256 tokenId) external {\\n    _onlyGuildController(msg.sender);\\n\\n    IERC721(nft).transferFrom(address(this), to, tokenId);\\n    emit IApplicationEvents.GuildBankTransferNft(to, nft, tokenId);\\n  }\\n\\n  function transferNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external {\\n    _onlyGuildController(msg.sender);\\n\\n    uint len = nfts.length;\\n    if (len != tokenIds.length) revert IAppErrors.LengthsMismatch();\\n\\n    for (uint i; i < len; ++i) {\\n      IERC721(nfts[i]).transferFrom(address(this), to, tokenIds[i]);\\n    }\\n    emit IApplicationEvents.GuildBankTransferNftMulti(to, nfts, tokenIds);\\n  }\\n\\n  function approveNft(address to, address nft, uint256 tokenId) external {\\n    _onlyGuildController(msg.sender);\\n\\n    IERC721(nft).approve(to, tokenId);\\n  }\\n\\n  function approveNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external {\\n    _onlyGuildController(msg.sender);\\n\\n    uint len = nfts.length;\\n    if (len != tokenIds.length) revert IAppErrors.LengthsMismatch();\\n\\n    for (uint i; i < len; ++i) {\\n      IERC721(nfts[i]).approve(to, tokenIds[i]);\\n    }\\n  }\\n  //endregion ------------------------ ERC721\\n}\",\"keccak256\":\"0x77ea45574a58f8c58baa1e4b966c2d022889ae6f408fe80f982487757d3c8ad4\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b507ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00805468010000000000000000810460ff1615906001600160401b03166000811580156200005d5750825b90506000826001600160401b031660011480156200007a5750303b155b90508115801562000089575080155b15620000a85760405163f92ee8a960e01b815260040160405180910390fd5b84546001600160401b03191660011785558315620000d757845460ff60401b1916680100000000000000001785555b83156200011e57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505061583580620001336000396000f3fe608060405234801561001057600080fd5b506004361061017a5760003560e01c80637cc96380116100d45780637cc96380146102f05780638154916e146102f8578063909aa53914610318578063936725ec146103385780639d0bcca014610369578063a8ca89ff1461037e578063b414c55314610391578063b429afeb146103a4578063d447d4df146103b7578063d5e46dcd146103ca578063dee1f0e4146103f7578063f2c6c6fb1461040a578063f3deb3911461041d578063f77c479114610430578063ffa1ad741461043857600080fd5b806306efb7851461017f5780630e2ecde2146101a55780630e91f15e146101cb578063172ae49a146101eb57806319ab453c146102005780631c10968c14610213578063325a19f11461021b5780634593144c146102235780634675bfff1461022b5780634fac6ccd1461023e5780635f1d20a1146102515780636742e2d61461026457806369c3d472146102875780636f383c0f146102a857806375a8e7da146102d0575b600080fd5b61019261018d366004613e0a565b61045c565b6040519081526020015b60405180910390f35b6101b86101b3366004613e53565b610471565b60405161ffff909116815260200161019c565b6101de6101d9366004613e99565b61047c565b60405161019c9190613ece565b6101fe6101f9366004613e53565b610488565b005b6101fe61020e366004613f12565b61049c565b610192610596565b6101926105a5565b6101926105d9565b6101fe610239366004614226565b610609565b6101fe61024c366004613f12565b61061a565b61019261025f3660046143b3565b61072b565b6102776102723660046143d0565b610736565b604051901515815260200161019c565b61029a6102953660046143d0565b610755565b60405161019c929190614651565b6102bb6102b63660046146a0565b61077c565b60405163ffffffff909116815260200161019c565b6102e36102de366004613e53565b61079f565b60405161019c9190614761565b6101926107b0565b61030b610306366004613e53565b6107ce565b60405161019c91906147e3565b61032b610326366004614808565b6107d9565b60405161019c9190614a0e565b61035c604051806040016040528060058152602001640312e302e360dc1b81525081565b60405161019c9190614a71565b610371610804565b60405161019c9190614a84565b6101fe61038c366004614a98565b610834565b6101fe61039f366004614add565b61084c565b6102776103b2366004613f12565b61085d565b6102776103c5366004613e53565b610882565b6103dd6103d8366004613e53565b61088d565b6040805160ff93841681529290911660208301520161019c565b610277610405366004613f12565b6108a2565b6101926104183660046143d0565b610927565b61019261042b3660046143d0565b61093c565b610371610949565b61035c60405180604001604052806005815260200164312e312e3560d81b81525081565b60006104688383610979565b90505b92915050565b600061046b826109b2565b606061046883836109df565b610499610493610949565b82610a1f565b50565b60006104a6610ad1565b805490915060ff600160401b82041615906001600160401b03166000811580156104cd5750825b90506000826001600160401b031660011480156104e95750303b155b9050811580156104f7575080155b156105155760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff19166001178555831561053f57845460ff60401b1916600160401b1785555b61054886610af5565b831561058e57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b60006105a0610b06565b905090565b60006105a06105d560017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b614c25565b5490565b60006105a06105d560017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1614c25565b610499610614610949565b82610b19565b33301461066c5760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b600061068a6105d560016000805160206157e0833981519152614c25565b610695906001614c38565b90506106b7816106b460016000805160206157e0833981519152614c25565b55565b6106e6826106b460017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4614c25565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c8910160405180910390a15050565b600061046b82610c0d565b600061074b610743610949565b858585610c20565b90505b9392505050565b61075d613c30565b610765613ca2565b610770858585610ca7565b91509150935093915050565b6000610793610789610949565b8787878787610d87565b90505b95945050505050565b6107a7613cc9565b61046b82610e14565b60006105a06105d560016000805160206157e0833981519152614c25565b600061046b82610f67565b6107e1613cf6565b6107f86107ec610949565b89898989898989610fb5565b98975050505050505050565b60006105a06105d560017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4614c25565b61084761083f610949565b8484846114bf565b505050565b610499610857610949565b8261154e565b6000610867610949565b6001600160a01b0316826001600160a01b0316149050919050565b600061046b8261162f565b60008061089983611674565b91509150915091565b6000816001600160a01b03166108b6610949565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109179190614c56565b6001600160a01b03161492915050565b600061074b610934610949565b858585611682565b600061074b848484611835565b60006105a06105d560017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618614c25565b6000610983611867565b600701600061099b6001600160a01b0386168561188b565b815260200190815260200160002054905092915050565b60006109bc611867565b63ffffffff909216600090815260059290920160205250604090205461ffff1690565b60606104686109ec611867565b6001016000610a0c86866024811115610a0757610a07614412565b6118da565b81526020019081526020016000206118ef565b610a28826118fc565b6000610a32611867565b63ffffffff8316600090815260209190915260409020549050610a53611867565b63ffffffff831660008181526020929092526040822091909155610a9190610a79611867565b60008481526001919091016020526040902090611988565b5060405163ffffffff831681527f93afafd4d79cc89e4afba48bcd8cac7b8a35b45dfb55afe60cccae721124cd0f906020015b60405180910390a1505050565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b610afd611994565b610499816119bb565b6000610b10611867565b60080154905090565b610b22826118fc565b610b36816101800151826101a00151611ace565b6000610b4f826000015183604001518460200151611c07565b90507345D129F2E7F8A7b2b526F80365Ada7f25Ba7eF7F6330f53b2c83610b74611867565b63ffffffff85166000908152600491820160205260409081902090516001600160e01b031960e086901b168152610bac939201614cf3565b60006040518083038186803b158015610bc457600080fd5b505af4158015610bd8573d6000803e3d6000fd5b505050507f8ee0b45ff34ecba58a4014e0e0a9ebb97960cbfcae1e413072685b6b56b724fe8183604051610ac4929190614e87565b600061046b60ff8316633b9aca00614fe8565b600080610c2c83611674565b915050610c9d866001600160a01b031663524a562f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c70573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c949190614c56565b84838888611c88565b9695505050505050565b610caf613c30565b610cb7613ca2565b6000610cc1611867565b6003016000610cda6001600160a01b0389168888611da7565b8152602001908152602001600020549050610d14610cf6611867565b63ffffffff8616600090815260069190910160205260409020611dda565b9250610d7c610d21611867565b63ffffffff8087166000908152600692909201602052604082206004019190610d57906001600160a01b038b16908a9061188b16565b8152602001908152602001600020600083815260200190815260200160002054611ffb565b915050935093915050565b6000610d9287612049565b610e09610d9d611867565b886001600160a01b031663524a562f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ddb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dff9190614c56565b88888888886120de565b979650505050505050565b610e1c613cc9565b610e24611867565b63ffffffff80841660009081526004929092016020908152604092839020835160a081018552815490931683526001810180548551818502810185019096528086529394919385840193830182828015610e9d57602002820191906000526020600020905b815481526020019060010190808311610e89575b5050505050815260200160028201805480602002602001604051908101604052809291908181526020018280548015610ef557602002820191906000526020600020905b815481526020019060010190808311610ee1575b505050505081526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020018280548015610f5757602002820191906000526020600020905b815481526020019060010190808311610f43575b5050505050815250509050919050565b600080610f95610f75611867565b63ffffffff85166000908152602091909152604090205490600882901c90565b91505061074e8160ff166024811115610fb057610fb0614412565b612211565b610fbd613cf6565b610fc689612049565b604080516101a0810182526000918101829052606081018290526080810182905260c081018290526101008101829052610140810182905261016081019190915263ffffffff871660e08201526001600160a01b03898116825286166020820152610120810185905260ff841660a0820152610180810183905261104987611674565b60ff90811660808401521660608201526040805163016dff5d60e01b815290516001600160a01b038c169163016dff5d9160048083019260209291908290030181865afa15801561109e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110c29190614c56565b6001600160a01b031663bcd418b087876040518363ffffffff1660e01b81526004016110ef929190614fff565b60a060405180830381865afa15801561110c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111309190615028565b6020015160ff1660c08201526001600160401b038816610100820152611154611867565b600301600061116488888b612613565b815260208101919091526040908101600020546101608301526001600160a01b038b1690820152611193613cf6565b60006111b1836080015160ff166024811115610fb057610fb0614412565b60048111156111c2576111c2614412565b4361014085015290506201b2531946016112405760646001600160a01b031663a3b1b31d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611215573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061123991906150cb565b6101408401525b60001960ff8216016112f3577345D129F2E7F8A7b2b526F80365Ada7f25Ba7eF7F63bd9fe9db8461126f611867565b63ffffffff8d166000908152600491820160205260409081902090516001600160e01b031960e086901b1681526112a79392016151d4565b600060405180830381865af41580156112c4573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526112ec919081019061541a565b9150611417565b60011960ff8216016113be576113098888612629565b73Bb611DaA59d2D0EEd9B6e73e88526745a672D72463307800a28461132c611867565b60060160008d63ffffffff1663ffffffff1681526020019081526020016000206040518363ffffffff1660e01b81526004016113699291906151d4565b600060405180830381865af4158015611386573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526113ae919081019061544e565b60ff166101408501529150611417565b60021960ff8216016113f9576112ec836113d6611867565b63ffffffff8c166000908152600591909101602052604090205461ffff166126a6565b604051634d07af3360e01b815260ff82166004820152602401610663565b60e083015163ffffffff166101208301526001600160a01b03881660408301526101608083018890528301516101808301527f67af56937d4d46082b2327381733f95fd39ed3df103ec0f3761eb315b463f5648a8a60ff8416600481111561148157611481614412565b8b8b8b8961016001518c8a8c61014001516040516114a89a9998979695949392919061549f565b60405180910390a1509a9950505050505050505050565b6114c8846118fc565b60006114d5838386611c07565b9050836114e0611867565b63ffffffff831660008181526005929092016020908152604092839020805461ffff191661ffff9586161790558251918252928716928101929092527f9df2729723fcb63a4f46ffc16905a683f7eb0e8dd3ec260515e66b4d4cd8c0ad910160405180910390a15050505050565b611557826118fc565b61156b816101800151826101a00151611ace565b6000611584826020015183604001518460000151611c07565b905061158e611867565b63ffffffff8216600090815260069190910160205260408120906115b28282613d6c565b600182016000905560028201600090556003820160006115d29190613d6c565b50506115fe826115e0611867565b63ffffffff8416600090815260069190910160205260409020612988565b7fe9039f79f66d71725ba719a022b5729bbfce163887322d74e690772fe247fa4b8183604051610ac4929190615530565b60008061163d610f75611867565b91506002905061165b8260ff166024811115610fb057610fb0614412565b600481111561166c5761166c614412565b149392505050565b600080610899610f75611867565b600061168d85612049565b611698848484612b2c565b905060006116a583611674565b9150506000866001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156116e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061170c9190614c56565b6001600160a01b031663bcd418b087876040518363ffffffff1660e01b8152600401611739929190614fff565b60a060405180830381865afa158015611756573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061177a9190615028565b905060006117968360ff166024811115610fb057610fb0614412565b60048111156117a7576117a7614412565b905060001960ff8216011561182a5760011960ff8216016117ff576117fa6117cd611867565b60060160008763ffffffff1663ffffffff1681526020019081526020016000208888878660200151612b81565b61182a565b60021960ff8216011561182a5760405163cafe050760e01b815260ff82166004820152602401610663565b505050949350505050565b600061183f611867565b600301600061184f868686612613565b81526020019081526020016000205490509392505050565b7ffa9e067a92ca4a9057b7b4465a8f29d633e1758238bd3a4a8ec5d0f904f6b90090565b60006001600160401b038211156118b857604051633995b34160e01b815260048101839052602401610663565b50600160a01b600160e01b0360a09190911b166001600160a01b039091161790565b600060ff8316600883901b61ff001617610468565b6060600061074e83612b91565b604051631430d62960e21b81526001600160a01b038216906350c358a490611928903390600401614a84565b602060405180830381865afa158015611945573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611969919061554f565b610499573360405163451cea1760e11b81526004016106639190614a84565b60006104688383612bed565b61199c612ce7565b6119b957604051631afcd79f60e31b815260040160405180910390fd5b565b6001600160a01b038116611a035760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b6044820152606401610663565b611a32816106b460017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618614c25565b611a61426106b460017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b614c25565b611a90436106b460017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1614c25565b7f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe236713426814243604051611ac39392919061556a565b60405180910390a150565b815181518114611af15760405163586cb9e160e01b815260040160405180910390fd5b60005b81811015611c015760006001600160a01b0316848281518110611b1957611b1961558b565b60200260200101516001600160a01b031603611b485760405163d92e233d60e01b815260040160405180910390fd5b828181518110611b5a57611b5a61558b565b602002602001015163ffffffff16600003611b885760405163eb79f4eb60e01b815260040160405180910390fd5b633b9aca0063ffffffff16838281518110611ba557611ba561558b565b602002602001015163ffffffff161115611bf957828181518110611bcb57611bcb61558b565b60200260200101516040516304470bfd60e21b8152600401610663919063ffffffff91909116815260200190565b600101611af4565b50505050565b600080611c12611867565b9050611c3085856024811115611c2a57611c2a614412565b85612d01565b91506000611c4a86866024811115610a0757610a07614412565b63ffffffff808516600081815260208681526040808320869055858352600188019091529020929350611c7e9291612df616565b5050509392505050565b600080611ca38560ff166024811115610fb057610fb0614412565b90506001816004811115611cb957611cb9614412565b03611cc8576001915050610796565b6002816004811115611cdc57611cdc614412565b03611ceb576001915050610796565b6003816004811115611cff57611cff614412565b03611d8957604051630152f74f60e41b815263ffffffff871660048201526001600160a01b0385811660248301526044820185905288169063152f74f090606401602060405180830381865afa158015611d5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d81919061554f565b915050610796565b604051630dad26cb60e31b815260ff86166004820152602401610663565b6001600160a01b039290921660a09190911b600160a01b600160e01b03161760e09190911b6001600160e01b0319161790565b611de2613c30565b611dea613c30565b611e4583600001805480602002602001604051908101604052809291908181526020018280548015611e3b57602002820191906000526020600020905b815481526020019060010190808311611e27575b5050505050612e02565b606083015260808201526001830154600881901c601082901c603083901c60ff90811661010086015263ffffffff90911660e085015290811660c08401521660a08201526002830154611e9f60a082901c9060e083901c90565b60ff166101608401526001600160401b039081166101408401526001600160a01b039091166101208301526003840154908190811115611ee157611ee1613f2f565b604051908082528060200260200182016040528015611f0a578160200160208202803683370190505b50610180830152806001600160401b03811115611f2957611f29613f2f565b604051908082528060200260200182016040528015611f52578160200160208202803683370190505b506101a083015260005b81811015611ff257611f90856003018281548110611f7c57611f7c61558b565b90600052602060002001549060a082901c90565b8461018001518381518110611fa757611fa761558b565b60200260200101856101a001518481518110611fc557611fc561558b565b63ffffffff909316602093840291909101909201919091526001600160a01b039091169052600101611f5c565b50909392505050565b612003613ca2565b506040805160808101825260ff8381166001148252604884901c166020820152602883901c60030b9181019190915263ffffffff60089290921c91909116606082015290565b336001600160a01b0316816001600160a01b031663683fedf76040518163ffffffff1660e01b8152600401602060405180830381865afa158015612091573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120b59190614c56565b6001600160a01b031614610499573360405163cf219bef60e01b81526004016106639190614a84565b6000806120ee87876130f361319c565b9050600089600101600061210288856118da565b81526020019081526020016000209050600061211d826133a5565b9050806000036121405760405163296a76c760e21b815260040160405180910390fd5b6000816001146121625761215d612158600184614c25565b6130f3565b612165565b60005b9050600060028d018160ff60e81b60e88c901b1660ff60e01b60e089901b16600160a01b600160e01b0360a08c901b166001600160a01b038d16171717815260200190815260200160002090506121c48c8486848660008e8e8d6133af565b95508563ffffffff166000036121ed57604051639cb04d5d60e01b815260040160405180910390fd5b6122008163ffffffff80891690612df616565b505050505050979650505050505050565b6000600482602481111561222757612227614412565b14806122445750600582602481111561224257612242614412565b145b806122605750600882602481111561225e5761225e614412565b145b1561226d57506001919050565b600182602481111561228157612281614412565b148061229e5750600282602481111561229c5761229c614412565b145b806122ba575060038260248111156122b8576122b8614412565b145b806122d65750600a8260248111156122d4576122d4614412565b145b806122f2575060208260248111156122f0576122f0614412565b145b8061230e5750602182602481111561230c5761230c614412565b145b8061232a5750602282602481111561232857612328614412565b145b806123465750602382602481111561234457612344614412565b145b1561235357506002919050565b600682602481111561236757612367614412565b14806123845750600782602481111561238257612382614412565b145b806123a05750600b82602481111561239e5761239e614412565b145b806123bc5750600c8260248111156123ba576123ba614412565b145b806123d85750600d8260248111156123d6576123d6614412565b145b806123f45750600e8260248111156123f2576123f2614412565b145b806124105750600f82602481111561240e5761240e614412565b145b8061242c5750601082602481111561242a5761242a614412565b145b806124485750601182602481111561244657612446614412565b145b806124645750601282602481111561246257612462614412565b145b806124805750601382602481111561247e5761247e614412565b145b8061249c5750601482602481111561249a5761249a614412565b145b806124b8575060158260248111156124b6576124b6614412565b145b806124d4575060168260248111156124d2576124d2614412565b145b806124f0575060178260248111156124ee576124ee614412565b145b8061250c5750601882602481111561250a5761250a614412565b145b806125285750601982602481111561252657612526614412565b145b806125445750601a82602481111561254257612542614412565b145b806125605750601b82602481111561255e5761255e614412565b145b8061257c5750601c82602481111561257a5761257a614412565b145b806125985750601d82602481111561259657612596614412565b145b806125b45750601e8260248111156125b2576125b2614412565b145b806125d05750601f8260248111156125ce576125ce614412565b145b156125dd57506003919050565b8160248111156125ef576125ef614412565b6040516302f13cad60e41b815260ff9091166004820152602401610663565b919050565b600061074b6001600160a01b0385168484611da7565b6000612633611867565b9050600061264a6001600160a01b0385168461188b565b60088301546000828152600785016020526040902054919250429161266f9190614c38565b111561268e5760405163051211b760e11b815260040160405180910390fd5b60009081526007909101602052604090204290555050565b6126ae613cf6565b8161ffff166000036126d357604051635c5e6bb360e11b815260040160405180910390fd5b82604001516001600160a01b031663524a562f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612715573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127399190614c56565b6001600160a01b0316631c1b0daa84600001518561010001518660e001518760a0015188602001518961012001518a606001518b61016001518c61018001516040518a63ffffffff1660e01b815260040161279c999897969594939291906155a1565b6000604051808303816000875af11580156127bb573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526127e3919081019061541a565b90508060200151806127f3575080515b1561046b57600083604001516001600160a01b0316628e96916040518163ffffffff1660e01b8152600401602060405180830381865afa15801561283b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061285f9190614c56565b9050600061286c8461347e565b6020860151610120870151604051631c2aafe760e01b81529293506000926001600160a01b03861692631c2aafe7926128a992879060040161556a565b602060405180830381865afa1580156128c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128ea91906150cb565b9050826001600160a01b031663184f61438760200151886101200151858560016129149190614c38565b6040516001600160e01b031960e087901b1681526001600160a01b039094166004850152602484019290925260448301526064820152608401600060405180830381600087803b15801561296757600080fd5b505af115801561297b573d6000803e3d6000fd5b5050505050505092915050565b6060820151608083015161299b916134b5565b80516129ae918391602090910190613d8a565b5060a082015160c083015160e084015161010085015160ff90931660089290921b61ff00169190911760109190911b65ffffffff0000161760309190911b60ff60301b161760018201556101208201516101408301516101608401516001600160a01b0390921660a09190911b600160a01b600160e01b03161760e09190911b60ff60e01b16176002820155610180820151516000816001600160401b03811115612a5b57612a5b613f2f565b604051908082528060200260200182016040528015612a84578160200160208202803683370190505b50905060005b82811015612b0f57612aea856101a001518281518110612aac57612aac61558b565b60200260200101518661018001518381518110612acb57612acb61558b565b60200260200101516001600160a01b031661371390919063ffffffff16565b828281518110612afc57612afc61558b565b6020908102919091010152600101612a8a565b508051612b259060038501906020840190613d8a565b5050505050565b600080612b37611867565b90506000612b46868686612613565b6000818152600384016020526040902054909150612b65906001614c38565b6000918252600390920160205260409020819055949350505050565b612b25858585856137318661373c565b606081600001805480602002602001604051908101604052809291908181526020018280548015612be157602002820191906000526020600020905b815481526020019060010190808311612bcd575b50505050509050919050565b60008181526001830160205260408120548015612cd6576000612c11600183614c25565b8554909150600090612c2590600190614c25565b9050808214612c8a576000866000018281548110612c4557612c4561558b565b9060005260206000200154905080876000018481548110612c6857612c6861558b565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080612c9b57612c9b61561a565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061046b565b600091505061046b565b5092915050565b6000612cf1610ad1565b54600160401b900460ff16919050565b600060ff84161580612d14575060ff8316155b80612d21575061ffff8216155b15612d3f5760405163273e150360e21b815260040160405180910390fd5b60648460ff1610612d68576040516340eff0e560e01b815260ff85166004820152602401610663565b60648360ff1610612d915760405163017c4c5960e01b815260ff84166004820152602401610663565b6127108261ffff161115612dbe57604051637dc12d1d60e01b815261ffff83166004820152602401610663565b61ffff8216612dd260ff8516612710615630565b612de260ff8716620f4240615630565b612dec9190615658565b61074b9190615658565b60006104688383613825565b805160609081906000612e16826008614fe8565b90506000816001600160401b03811115612e3257612e32613f2f565b604051908082528060200260200182016040528015612e5b578160200160208202803683370190505b5090506000826001600160401b03811115612e7857612e78613f2f565b604051908082528060200260200182016040528015612ea1578160200160208202803683370190505b5090506000805b85811015612fce5760005b6008811015612fc557600081612eca846008614fe8565b612ed49190614c38565b9050612ee1826020614fe8565b8b8481518110612ef357612ef361558b565b602002602001015160001c901c60020b868281518110612f1557612f1561558b565b60039290920b602092830291909101820152612f32908390614fe8565b612f3d906018614c38565b8b8481518110612f4f57612f4f61558b565b602002602001015160001c901c858281518110612f6e57612f6e61558b565b602002602001019060ff16908160ff1681525050858181518110612f9457612f9461558b565b602002602001015160030b600003612fac5750612fc5565b83612fb681615675565b94505050806001019050612eb3565b50600101612ea8565b50806001600160401b03811115612fe757612fe7613f2f565b604051908082528060200260200182016040528015613010578160200160208202803683370190505b509650806001600160401b0381111561302b5761302b613f2f565b604051908082528060200260200182016040528015613054578160200160208202803683370190505b50955060005b818110156130e8578381815181106130745761307461558b565b602002602001015188828151811061308e5761308e61558b565b602002602001019060030b908160030b815250508281815181106130b4576130b461558b565b60200260200101518782815181106130ce576130ce61558b565b60ff9092166020928302919091019091015260010161305a565b505050505050915091565b60008160000361310557506000919050565b600061310f613874565b905061311c836001614c38565b4340414443423a5a8860405160200161317998979695949392919097885260609690961b6001600160601b0319166020880152603487019490945260548601929092526074850152609484015260b483015260d482015260f40190565b6040516020818303038152906040528051906020012060001c61074e91906156a4565b82516000908015806131af575083518114155b156131cd5760405163360ee06360e21b815260040160405180910390fd5b806001036131f757846000815181106131e8576131e861558b565b60200260200101519150613376565b600061320a633b9aca0063ffffffff8616565b9050600061321d633b9aca006001615658565b63ffffffff16905060005b83811015613372578781815181106132425761324261558b565b602002602001015160ff166000031561336a57633b9aca0063ffffffff168782815181106132725761327261558b565b602002602001015163ffffffff1611156132cf578681815181106132985761329861558b565b6020908102919091010151604051631b4fdad960e11b815263ffffffff9091166004820152633b9aca006024820152604401610663565b828782815181106132e2576132e261558b565b6020026020010151633b9aca006132f991906156b8565b63ffffffff161161336a57818782815181106133175761331761558b565b602002602001015163ffffffff16101561336a5786818151811061333d5761333d61558b565b602002602001015163ffffffff16915087818151811061335f5761335f61558b565b602002602001015194505b600101613228565b5050505b8160ff1660000361339d5760405163b3cea44d60e01b815260006004820152602401610663565b509392505050565b600061046b825490565b6000886133bb886133a5565b106133cd57600194506133cd876138ac565b6000805b8a811015613440578a88106133e557600097505b60006133f18b8a6138fa565b90506134008d82878a8a611c88565b80156134235750878061342357506134218a63ffffffff8084169061390616565b155b1561343357925060019150613440565b50600197880197016133d1565b508015801561344d575085155b156134705761345b886138ac565b61346d8b8b8b8b8b60018b8b8b6133af565b91505b509998505050505050505050565b600061348d8261ffff1661391e565b60405160200161349d91906156d5565b60405160208183030381529060405261046b90615703565b606081518351146134d95760405163586cb9e160e01b815260040160405180910390fd5b6000600884516134e9919061572a565b6134f4906001614c38565b90506000816001600160401b0381111561351057613510613f2f565b604051908082528060200260200182016040528015613539578160200160208202803683370190505b50905060005b8281101561370a5760005b600881101561370157600081613561846008614fe8565b61356b9190614c38565b90508751811061357b5750613701565b627fffff60020b8882815181106135945761359461558b565b602002602001015160030b13806135cd5750627fffff1960020b8882815181106135c0576135c061558b565b602002602001015160030b125b1561360b578781815181106135e4576135e461558b565b602002602001015160030b604051632eb1d06960e01b815260040161066391815260200190565b87818151811061361d5761361d61558b565b602002602001015160030b60000361364857604051637c946ed760e01b815260040160405180910390fd5b613653826020614fe8565b8882815181106136655761366561558b565b602002602001015162ffffff1660001b901b8484815181106136895761368961558b565b6020026020010181815117915081815250508160206136a89190614fe8565b6136b3906018614c38565b8782815181106136c5576136c561558b565b602002602001015160ff1660001b901b8484815181106136e7576136e761558b565b60209081029190910101805190911790525060010161354a565b5060010161353f565b50949350505050565b63ffffffff60a01b60a09190911b166001600160a01b039091161790565b600061046b826130f3565b60408051608081018252600181526000602082018190529181018290526060810161376e633b9aca0063ffffffff8716565b63ffffffff1690529050600061378388611dda565b905060006137ac8260600151836080015185606001516137a288610c0d565b8660e00151613a26565b509050806009815181106137c2576137c261558b565b602090810291909101015160030b60408401526137de83613aec565b60048a0160006137f76001600160a01b038c168b61188b565b8152602001908152602001600020600088815260200190815260200160002081905550505050505050505050565b600081815260018301602052604081205461386c5750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561046b565b50600061046b565b60006350877ed646148061388b5750630235ddd046145b156138a9576040518060208160008060185afa6138a457fe5b505190505b90565b60006138b7826118ef565b905060005b8151811015610847576138f18282815181106138da576138da61558b565b60200260200101518461198890919063ffffffff16565b506001016138bc565b60006104688383613b0a565b60008181526001830160205260408120541515610468565b6060816000036139455750506040805180820190915260018152600360fc1b602082015290565b8160005b811561396f578061395981615675565b91506139689050600a8361572a565b9150613949565b6000816001600160401b0381111561398957613989613f2f565b6040519080825280601f01601f1916602001820160405280156139b3576020820181803683370190505b5090505b8415613a1e576139c8600183614c25565b91506139d5600a866156a4565b6139e0906030614c38565b60f81b8183815181106139f5576139f561558b565b60200101906001600160f81b031916908160001a905350613a17600a8661572a565b94506139b7565b949350505050565b60606000613a3560048661573e565b60408051602b8082526105808201909252919650602082016105608036833701905050915060005b8751811015613ad357613a8a878281518110613a7b57613a7b61558b565b60200260200101518787613b34565b83898381518110613a9d57613a9d61558b565b602002602001015160ff1681518110613ab857613ab861558b565b60039290920b60209283029190910190910152600101613a5d565b50613ae083866000613b34565b90509550959350505050565b600061046b8260000151836060015184604001518560200151613bdc565b6000826000018281548110613b2157613b2161558b565b9060005260206000200154905092915050565b60008360030b600003613b495750600061074e565b6000633b9aca00613b5e84600388900b615761565b613b689190615791565b633b9aca00613b8163ffffffff8716600389900b615761565b613b8b9190615791565b8660030b613b9991906157bf565b613ba391906157bf565b9050637fffffff811380613bbb5750637fffffff1981125b1561074b576040516344dc334160e01b815260048101829052602401610663565b600084613bea576000613bed565b60015b60ff1660001b905060088463ffffffff1660001b901b8117905060288363ffffffff1660001b901b8117905060488260ff1660001b901b81179050949350505050565b604080516101c081018252600080825260208201819052909182019081526060602082018190526040820181905260008183018190526080830181905260a0830181905260c0830181905260e08301819052610100830181905261012083015261014082018190526101609091015290565b60408051608081018252600080825260208201819052918101829052606081019190915290565b6040805160a081018252600080825260606020830181905292820183905282820152608081019190915290565b604080516101c08101825260008082526020820181905291810182905260608082018190526080820183905260a0820183905260c0820183905260e0820183905261010082018390526101208201839052610140820183905261016082018390526101808201929092526101a081019190915290565b50805460008255906000526020600020908101906104999190613dd5565b828054828255906000526020600020908101928215613dc5579160200282015b82811115613dc5578251825591602001919060010190613daa565b50613dd1929150613dd5565b5090565b5b80821115613dd15760008155600101613dd6565b6001600160a01b038116811461049957600080fd5b803561260e81613dea565b60008060408385031215613e1d57600080fd5b8235613e2881613dea565b946020939093013593505050565b63ffffffff8116811461049957600080fd5b803561260e81613e36565b600060208284031215613e6557600080fd5b813561074e81613e36565b60ff8116811461049957600080fd5b803561260e81613e70565b80356025811061260e57600080fd5b60008060408385031215613eac57600080fd5b8235613eb781613e70565b9150613ec560208401613e8a565b90509250929050565b6020808252825182820181905260009190848201906040850190845b81811015613f0657835183529284019291840191600101613eea565b50909695505050505050565b600060208284031215613f2457600080fd5b813561074e81613dea565b634e487b7160e01b600052604160045260246000fd5b6040516101c081016001600160401b0381118282101715613f6857613f68613f2f565b60405290565b604051601f8201601f191681016001600160401b0381118282101715613f9657613f96613f2f565b604052919050565b803561ffff8116811461260e57600080fd5b60006001600160401b03821115613fc957613fc9613f2f565b5060051b60200190565b600082601f830112613fe457600080fd5b81356020613ff9613ff483613fb0565b613f6e565b8083825260208201915060208460051b87010193508684111561401b57600080fd5b602086015b8481101561404057803561403381613e70565b8352918301918301614020565b509695505050505050565b8060030b811461049957600080fd5b803561260e8161404b565b600082601f83011261407657600080fd5b81356020614086613ff483613fb0565b8083825260208201915060208460051b8701019350868411156140a857600080fd5b602086015b848110156140405780356140c08161404b565b83529183019183016140ad565b6000604082840312156140df57600080fd5b604051604081016001600160401b03828210818311171561410257614102613f2f565b81604052829350843591508082111561411a57600080fd5b61412686838701613fd3565b8352602085013591508082111561413c57600080fd5b5061414985828601614065565b6020830152505092915050565b600082601f83011261416757600080fd5b81356020614177613ff483613fb0565b8083825260208201915060208460051b87010193508684111561419957600080fd5b602086015b848110156140405780356141b181613dea565b835291830191830161419e565b600082601f8301126141cf57600080fd5b813560206141df613ff483613fb0565b8083825260208201915060208460051b87010193508684111561420157600080fd5b602086015b8481101561404057803561421981613e36565b8352918301918301614206565b60006020828403121561423857600080fd5b81356001600160401b038082111561424f57600080fd5b908301906101c0828603121561426457600080fd5b61426c613f45565b61427583613e7f565b815261428360208401613f9e565b602082015261429460408401613e8a565b60408201526142a560608401613e48565b60608201526080830135828111156142bc57600080fd5b6142c8878286016140cd565b60808301525060a0830135828111156142e057600080fd5b6142ec878286016140cd565b60a0830152506142fe60c08401613e48565b60c082015261430f60e0840161405a565b60e082015261010061432281850161405a565b9082015261012061433484820161405a565b9082015261014061434684820161405a565b9082015261016061435884820161405a565b90820152610180838101358381111561437057600080fd5b61437c88828701614156565b8284015250506101a0808401358381111561439657600080fd5b6143a2888287016141be565b918301919091525095945050505050565b6000602082840312156143c557600080fd5b813561074e81613e70565b6000806000606084860312156143e557600080fd5b83356143f081613dea565b925060208401359150604084013561440781613e36565b809150509250925092565b634e487b7160e01b600052602160045260246000fd5b6025811061443857614438614412565b9052565b60008151808452602080850194506020840160005b8381101561447057815160ff1687529582019590820190600101614451565b509495945050505050565b60008151808452602080850194506020840160005b8381101561447057815160030b87529582019590820190600101614490565b6001600160a01b03169052565b60008151808452602080850194506020840160005b838110156144705781516001600160a01b0316875295820195908201906001016144d1565b60008151808452602080850194506020840160005b8381101561447057815163ffffffff168752958201959082019060010161450b565b805161ffff16825260006101c0602083015161454e602086018260ff169052565b5060408301516145616040860182614428565b5060608301518160608601526145798286018261443c565b91505060808301518482036080860152614593828261447b565b91505060a08301516145aa60a086018260ff169052565b5060c08301516145bf60c086018260ff169052565b5060e08301516145d760e086018263ffffffff169052565b506101008381015160ff1690850152610120808401516145f9828701826144af565b5050610140838101516001600160401b0316908501526101608084015160ff1690850152610180808401518583038287015261463583826144bc565b925050506101a08084015185830382870152610c9d83826144f6565b60a08152600061466460a083018561452d565b905082511515602083015260ff6020840151166040830152604083015160030b606083015263ffffffff60608401511660808301529392505050565b600080600080600060a086880312156146b857600080fd5b85356001600160401b03808211156146cf57600080fd5b6146db89838a01613fd3565b965060208801359150808211156146f157600080fd5b506146fe888289016141be565b945050604086013561470f81613e70565b9250606086013561471f81613dea565b949793965091946080013592915050565b60008151808452602080850194506020840160005b8381101561447057815187529582019590820190600101614745565b6020815263ffffffff82511660208201526000602083015160a0604084015261478d60c0840182614730565b90506040840151601f19808584030160608601526147ab8383614730565b92506060860151608086015260808601519150808584030160a0860152506107968282614730565b6005811061443857614438614412565b6020810161046b82846147d3565b80356001600160401b038116811461260e57600080fd5b600080600080600080600060e0888a03121561482357600080fd5b873561482e81613dea565b9650602061483d8982016147f1565b9650604089013561484d81613e36565b9550606089013561485d81613dea565b94506080890135935060a089013561487481613e70565b925060c08901356001600160401b038082111561489057600080fd5b818b0191508b601f8301126148a457600080fd5b8135818111156148b6576148b6613f2f565b6148c8601f8201601f19168501613f6e565b91508082528c848285010111156148de57600080fd5b808484018584013760008482840101525080935050505092959891949750929550565b80511515825260006101c0602083015161491f602086018215159052565b50604083015161493260408601826144af565b50606083015181606086015261494a828601826144bc565b9150506080830151614961608086018260030b9052565b5060a083015161497660a086018260030b9052565b5060c083015161498b60c086018260030b9052565b5060e08301516149a060e086018260030b9052565b50610100808401516149b68287018260030b9052565b50506101208381015163ffffffff81168683015250506101408381015163ffffffff8116868301525050610160838101519085015261018080840151908501526101a08084015185830382870152610c9d83826144f6565b6020815260006104686020830184614901565b60005b83811015614a3c578181015183820152602001614a24565b50506000910152565b60008151808452614a5d816020860160208601614a21565b601f01601f19169290920160200192915050565b6020815260006104686020830184614a45565b6001600160a01b0391909116815260200190565b600080600060608486031215614aad57600080fd5b614ab684613f9e565b92506020840135614ac681613e70565b9150614ad460408501613e8a565b90509250925092565b600060208284031215614aef57600080fd5b81356001600160401b0380821115614b0657600080fd5b908301906101c08286031215614b1b57600080fd5b614b23613f45565b614b2c83613f9e565b8152614b3a60208401613e7f565b6020820152614b4b60408401613e8a565b6040820152606083013582811115614b6257600080fd5b614b6e87828601613fd3565b606083015250608083013582811115614b8657600080fd5b614b9287828601614065565b608083015250614ba460a08401613e7f565b60a0820152614bb560c08401613e7f565b60c0820152614bc660e08401613e48565b60e0820152610100614bd9818501613e7f565b90820152610120614beb848201613dff565b90820152610140614bfd8482016147f1565b90820152610160614358848201613e7f565b634e487b7160e01b600052601160045260246000fd5b8181038181111561046b5761046b614c0f565b8082018082111561046b5761046b614c0f565b805161260e81613dea565b600060208284031215614c6857600080fd5b815161074e81613dea565b805160408084528151908401819052600091602091908201906060860190845b81811015614cb257835160ff1683529284019291840191600101614c93565b50508483015186820387850152805180835290840192506000918401905b8083101561404057835160030b8252928401926001929092019190840190614cd0565b60408152614d0760408201845160ff169052565b60006020840151614d1e606084018261ffff169052565b506040840151614d316080840182614428565b50606084015163ffffffff1660a083015260808401516101c060c08401819052614d5f610200850183614c73565b915060a0860151603f19808685030160e0870152614d7d8483614c73565b935060c08801519150610100614d9a8188018463ffffffff169052565b60e08901519250610120614db28189018560030b9052565b90890151925061014090614dca8883018560030b9052565b8901519250610160614de08882018560030b9052565b90890151925061018090614df88883018560030b9052565b89015192506101a0614e0e8882018560030b9052565b818a01519350828887030185890152614e2786856144bc565b9550808a01519450505080868503016101e08701525050614e4882826144f6565b925050508260208301529392505050565b6000815160408452614e6e604085018261443c565b905060208301518482036020860152610796828261447b565b63ffffffff8316815260406020820152614ea760408201835160ff169052565b60006020830151614ebe606084018261ffff169052565b506040830151614ed16080840182614428565b50606083015163ffffffff1660a083015260808301516101c060c08401819052614eff610200850183614e59565b915060a0850151603f19808685030160e0870152614f1d8483614e59565b935060c08701519150610100614f3a8188018463ffffffff169052565b60e08801519250610120614f528189018560030b9052565b90880151925061014090614f6a8883018560030b9052565b8801519250610160614f808882018560030b9052565b90880151925061018090614f988883018560030b9052565b88015192506101a0614fae8882018560030b9052565b818901519350828887030185890152614fc786856144bc565b9550808901519450505080868503016101e08701525050610c9d82826144f6565b808202811582820484141761046b5761046b614c0f565b6001600160a01b03929092168252602082015260400190565b8051801515811461260e57600080fd5b600060a0828403121561503a57600080fd5b60405160a081018181106001600160401b038211171561505c5761505c613f2f565b604052825161506a81613e70565b8152602083015161507a81613e70565b602082015261508b60408401615018565b6040820152606083015168ffffffffffffffffff811681146150ac57600080fd5b606082015260808301516150bf81613dea565b60808201529392505050565b6000602082840312156150dd57600080fd5b5051919050565b60006101a06150f48484516144af565b602083015161510660208601826144af565b50604083015161511960408601826144af565b50606083015161512e606086018260ff169052565b506080830151615143608086018260ff169052565b5060a083015161515860a086018260ff169052565b5060c083015161516d60c086018260ff169052565b5060e083015161518560e086018263ffffffff169052565b50610100838101516001600160401b03169085015261012080840151908501526101408084015190850152610160808401519085015261018080840151818601839052610c9d83870182614a45565b6040815260006151e760408301856150e4565b90508260208301529392505050565b600082601f83011261520757600080fd5b81516020615217613ff483613fb0565b8083825260208201915060208460051b87010193508684111561523957600080fd5b602086015b8481101561404057805161525181613dea565b835291830191830161523e565b805161260e8161404b565b805161260e81613e36565b600082601f83011261528557600080fd5b81516020615295613ff483613fb0565b8083825260208201915060208460051b8701019350868411156152b757600080fd5b602086015b848110156140405780516152cf81613e36565b83529183019183016152bc565b60006101c082840312156152ef57600080fd5b6152f7613f45565b905061530282615018565b815261531060208301615018565b602082015261532160408301614c4b565b604082015260608201516001600160401b038082111561534057600080fd5b61534c858386016151f6565b606084015261535d6080850161525e565b608084015261536e60a0850161525e565b60a084015261537f60c0850161525e565b60c084015261539060e0850161525e565b60e084015261010091506153a582850161525e565b8284015261012091506153b9828501615269565b8284015261014091506153cd828501615269565b8284015261016091508184015182840152610180915081840151828401526101a09150818401518181111561540157600080fd5b61540d86828701615274565b8385015250505092915050565b60006020828403121561542c57600080fd5b81516001600160401b0381111561544257600080fd5b613a1e848285016152dc565b6000806040838503121561546157600080fd5b82516001600160401b0381111561547757600080fd5b615483858286016152dc565b925050602083015161549481613e70565b809150509250929050565b60006101406001600160401b038d16835263ffffffff8c1660208401526154c9604084018c6147d3565b6001600160a01b038a1660608401526080830189905260ff881660a084015260c0830187905260e0830181905261550281840187614a45565b90508281036101008401526155178186614901565b915050826101208301529b9a5050505050505050505050565b63ffffffff8316815260406020820152600061074b604083018461452d565b60006020828403121561556157600080fd5b61046882615018565b6001600160a01b039390931683526020830191909152604082015260600190565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b038a811682526001600160401b038a16602083015263ffffffff8916604083015260ff8881166060840152908716608083015260a08201869052841660c082015260e08101839052610120610100820181905260009061560a83820185614a45565b9c9b505050505050505050505050565b634e487b7160e01b600052603160045260246000fd5b63ffffffff81811683821602808216919082811461565057615650614c0f565b505092915050565b63ffffffff818116838216019080821115612ce057612ce0614c0f565b60006001820161568757615687614c0f565b5060010190565b634e487b7160e01b600052601260045260246000fd5b6000826156b3576156b361568e565b500690565b63ffffffff828116828216039080821115612ce057612ce0614c0f565b6553544f52595f60d01b8152600082516156f6816006850160208701614a21565b9190910160060192915050565b80516020808301519190811015615724576000198160200360031b1b821691505b50919050565b6000826157395761573961568e565b500490565b600063ffffffff808416806157555761575561568e565b92169190910492915050565b80820260008212600160ff1b8414161561577d5761577d614c0f565b818105831482151761046b5761046b614c0f565b6000826157a0576157a061568e565b600160ff1b8214600019841416156157ba576157ba614c0f565b500590565b808201828112600083128015821682158216171561565057615650614c0f56fe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda26469706673582212204bb3ece109dd8a9ae3d08192ff59a86deb282fd9fc1bf4e786f6778a52e9950a64736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061017a5760003560e01c80637cc96380116100d45780637cc96380146102f05780638154916e146102f8578063909aa53914610318578063936725ec146103385780639d0bcca014610369578063a8ca89ff1461037e578063b414c55314610391578063b429afeb146103a4578063d447d4df146103b7578063d5e46dcd146103ca578063dee1f0e4146103f7578063f2c6c6fb1461040a578063f3deb3911461041d578063f77c479114610430578063ffa1ad741461043857600080fd5b806306efb7851461017f5780630e2ecde2146101a55780630e91f15e146101cb578063172ae49a146101eb57806319ab453c146102005780631c10968c14610213578063325a19f11461021b5780634593144c146102235780634675bfff1461022b5780634fac6ccd1461023e5780635f1d20a1146102515780636742e2d61461026457806369c3d472146102875780636f383c0f146102a857806375a8e7da146102d0575b600080fd5b61019261018d366004613e0a565b61045c565b6040519081526020015b60405180910390f35b6101b86101b3366004613e53565b610471565b60405161ffff909116815260200161019c565b6101de6101d9366004613e99565b61047c565b60405161019c9190613ece565b6101fe6101f9366004613e53565b610488565b005b6101fe61020e366004613f12565b61049c565b610192610596565b6101926105a5565b6101926105d9565b6101fe610239366004614226565b610609565b6101fe61024c366004613f12565b61061a565b61019261025f3660046143b3565b61072b565b6102776102723660046143d0565b610736565b604051901515815260200161019c565b61029a6102953660046143d0565b610755565b60405161019c929190614651565b6102bb6102b63660046146a0565b61077c565b60405163ffffffff909116815260200161019c565b6102e36102de366004613e53565b61079f565b60405161019c9190614761565b6101926107b0565b61030b610306366004613e53565b6107ce565b60405161019c91906147e3565b61032b610326366004614808565b6107d9565b60405161019c9190614a0e565b61035c604051806040016040528060058152602001640312e302e360dc1b81525081565b60405161019c9190614a71565b610371610804565b60405161019c9190614a84565b6101fe61038c366004614a98565b610834565b6101fe61039f366004614add565b61084c565b6102776103b2366004613f12565b61085d565b6102776103c5366004613e53565b610882565b6103dd6103d8366004613e53565b61088d565b6040805160ff93841681529290911660208301520161019c565b610277610405366004613f12565b6108a2565b6101926104183660046143d0565b610927565b61019261042b3660046143d0565b61093c565b610371610949565b61035c60405180604001604052806005815260200164312e312e3560d81b81525081565b60006104688383610979565b90505b92915050565b600061046b826109b2565b606061046883836109df565b610499610493610949565b82610a1f565b50565b60006104a6610ad1565b805490915060ff600160401b82041615906001600160401b03166000811580156104cd5750825b90506000826001600160401b031660011480156104e95750303b155b9050811580156104f7575080155b156105155760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff19166001178555831561053f57845460ff60401b1916600160401b1785555b61054886610af5565b831561058e57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b60006105a0610b06565b905090565b60006105a06105d560017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b614c25565b5490565b60006105a06105d560017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1614c25565b610499610614610949565b82610b19565b33301461066c5760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b600061068a6105d560016000805160206157e0833981519152614c25565b610695906001614c38565b90506106b7816106b460016000805160206157e0833981519152614c25565b55565b6106e6826106b460017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4614c25565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c8910160405180910390a15050565b600061046b82610c0d565b600061074b610743610949565b858585610c20565b90505b9392505050565b61075d613c30565b610765613ca2565b610770858585610ca7565b91509150935093915050565b6000610793610789610949565b8787878787610d87565b90505b95945050505050565b6107a7613cc9565b61046b82610e14565b60006105a06105d560016000805160206157e0833981519152614c25565b600061046b82610f67565b6107e1613cf6565b6107f86107ec610949565b89898989898989610fb5565b98975050505050505050565b60006105a06105d560017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4614c25565b61084761083f610949565b8484846114bf565b505050565b610499610857610949565b8261154e565b6000610867610949565b6001600160a01b0316826001600160a01b0316149050919050565b600061046b8261162f565b60008061089983611674565b91509150915091565b6000816001600160a01b03166108b6610949565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109179190614c56565b6001600160a01b03161492915050565b600061074b610934610949565b858585611682565b600061074b848484611835565b60006105a06105d560017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618614c25565b6000610983611867565b600701600061099b6001600160a01b0386168561188b565b815260200190815260200160002054905092915050565b60006109bc611867565b63ffffffff909216600090815260059290920160205250604090205461ffff1690565b60606104686109ec611867565b6001016000610a0c86866024811115610a0757610a07614412565b6118da565b81526020019081526020016000206118ef565b610a28826118fc565b6000610a32611867565b63ffffffff8316600090815260209190915260409020549050610a53611867565b63ffffffff831660008181526020929092526040822091909155610a9190610a79611867565b60008481526001919091016020526040902090611988565b5060405163ffffffff831681527f93afafd4d79cc89e4afba48bcd8cac7b8a35b45dfb55afe60cccae721124cd0f906020015b60405180910390a1505050565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b610afd611994565b610499816119bb565b6000610b10611867565b60080154905090565b610b22826118fc565b610b36816101800151826101a00151611ace565b6000610b4f826000015183604001518460200151611c07565b905073__$a0fcfc253474aa5cdb2dbfa020c220d358$__6330f53b2c83610b74611867565b63ffffffff85166000908152600491820160205260409081902090516001600160e01b031960e086901b168152610bac939201614cf3565b60006040518083038186803b158015610bc457600080fd5b505af4158015610bd8573d6000803e3d6000fd5b505050507f8ee0b45ff34ecba58a4014e0e0a9ebb97960cbfcae1e413072685b6b56b724fe8183604051610ac4929190614e87565b600061046b60ff8316633b9aca00614fe8565b600080610c2c83611674565b915050610c9d866001600160a01b031663524a562f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c70573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c949190614c56565b84838888611c88565b9695505050505050565b610caf613c30565b610cb7613ca2565b6000610cc1611867565b6003016000610cda6001600160a01b0389168888611da7565b8152602001908152602001600020549050610d14610cf6611867565b63ffffffff8616600090815260069190910160205260409020611dda565b9250610d7c610d21611867565b63ffffffff8087166000908152600692909201602052604082206004019190610d57906001600160a01b038b16908a9061188b16565b8152602001908152602001600020600083815260200190815260200160002054611ffb565b915050935093915050565b6000610d9287612049565b610e09610d9d611867565b886001600160a01b031663524a562f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ddb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dff9190614c56565b88888888886120de565b979650505050505050565b610e1c613cc9565b610e24611867565b63ffffffff80841660009081526004929092016020908152604092839020835160a081018552815490931683526001810180548551818502810185019096528086529394919385840193830182828015610e9d57602002820191906000526020600020905b815481526020019060010190808311610e89575b5050505050815260200160028201805480602002602001604051908101604052809291908181526020018280548015610ef557602002820191906000526020600020905b815481526020019060010190808311610ee1575b505050505081526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020018280548015610f5757602002820191906000526020600020905b815481526020019060010190808311610f43575b5050505050815250509050919050565b600080610f95610f75611867565b63ffffffff85166000908152602091909152604090205490600882901c90565b91505061074e8160ff166024811115610fb057610fb0614412565b612211565b610fbd613cf6565b610fc689612049565b604080516101a0810182526000918101829052606081018290526080810182905260c081018290526101008101829052610140810182905261016081019190915263ffffffff871660e08201526001600160a01b03898116825286166020820152610120810185905260ff841660a0820152610180810183905261104987611674565b60ff90811660808401521660608201526040805163016dff5d60e01b815290516001600160a01b038c169163016dff5d9160048083019260209291908290030181865afa15801561109e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110c29190614c56565b6001600160a01b031663bcd418b087876040518363ffffffff1660e01b81526004016110ef929190614fff565b60a060405180830381865afa15801561110c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111309190615028565b6020015160ff1660c08201526001600160401b038816610100820152611154611867565b600301600061116488888b612613565b815260208101919091526040908101600020546101608301526001600160a01b038b1690820152611193613cf6565b60006111b1836080015160ff166024811115610fb057610fb0614412565b60048111156111c2576111c2614412565b4361014085015290506201b2531946016112405760646001600160a01b031663a3b1b31d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611215573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061123991906150cb565b6101408401525b60001960ff8216016112f35773__$a0fcfc253474aa5cdb2dbfa020c220d358$__63bd9fe9db8461126f611867565b63ffffffff8d166000908152600491820160205260409081902090516001600160e01b031960e086901b1681526112a79392016151d4565b600060405180830381865af41580156112c4573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526112ec919081019061541a565b9150611417565b60011960ff8216016113be576113098888612629565b73__$201d0d5baf5bd2c94d39dac94ac4e46c3c$__63307800a28461132c611867565b60060160008d63ffffffff1663ffffffff1681526020019081526020016000206040518363ffffffff1660e01b81526004016113699291906151d4565b600060405180830381865af4158015611386573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526113ae919081019061544e565b60ff166101408501529150611417565b60021960ff8216016113f9576112ec836113d6611867565b63ffffffff8c166000908152600591909101602052604090205461ffff166126a6565b604051634d07af3360e01b815260ff82166004820152602401610663565b60e083015163ffffffff166101208301526001600160a01b03881660408301526101608083018890528301516101808301527f67af56937d4d46082b2327381733f95fd39ed3df103ec0f3761eb315b463f5648a8a60ff8416600481111561148157611481614412565b8b8b8b8961016001518c8a8c61014001516040516114a89a9998979695949392919061549f565b60405180910390a1509a9950505050505050505050565b6114c8846118fc565b60006114d5838386611c07565b9050836114e0611867565b63ffffffff831660008181526005929092016020908152604092839020805461ffff191661ffff9586161790558251918252928716928101929092527f9df2729723fcb63a4f46ffc16905a683f7eb0e8dd3ec260515e66b4d4cd8c0ad910160405180910390a15050505050565b611557826118fc565b61156b816101800151826101a00151611ace565b6000611584826020015183604001518460000151611c07565b905061158e611867565b63ffffffff8216600090815260069190910160205260408120906115b28282613d6c565b600182016000905560028201600090556003820160006115d29190613d6c565b50506115fe826115e0611867565b63ffffffff8416600090815260069190910160205260409020612988565b7fe9039f79f66d71725ba719a022b5729bbfce163887322d74e690772fe247fa4b8183604051610ac4929190615530565b60008061163d610f75611867565b91506002905061165b8260ff166024811115610fb057610fb0614412565b600481111561166c5761166c614412565b149392505050565b600080610899610f75611867565b600061168d85612049565b611698848484612b2c565b905060006116a583611674565b9150506000866001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156116e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061170c9190614c56565b6001600160a01b031663bcd418b087876040518363ffffffff1660e01b8152600401611739929190614fff565b60a060405180830381865afa158015611756573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061177a9190615028565b905060006117968360ff166024811115610fb057610fb0614412565b60048111156117a7576117a7614412565b905060001960ff8216011561182a5760011960ff8216016117ff576117fa6117cd611867565b60060160008763ffffffff1663ffffffff1681526020019081526020016000208888878660200151612b81565b61182a565b60021960ff8216011561182a5760405163cafe050760e01b815260ff82166004820152602401610663565b505050949350505050565b600061183f611867565b600301600061184f868686612613565b81526020019081526020016000205490509392505050565b7ffa9e067a92ca4a9057b7b4465a8f29d633e1758238bd3a4a8ec5d0f904f6b90090565b60006001600160401b038211156118b857604051633995b34160e01b815260048101839052602401610663565b50600160a01b600160e01b0360a09190911b166001600160a01b039091161790565b600060ff8316600883901b61ff001617610468565b6060600061074e83612b91565b604051631430d62960e21b81526001600160a01b038216906350c358a490611928903390600401614a84565b602060405180830381865afa158015611945573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611969919061554f565b610499573360405163451cea1760e11b81526004016106639190614a84565b60006104688383612bed565b61199c612ce7565b6119b957604051631afcd79f60e31b815260040160405180910390fd5b565b6001600160a01b038116611a035760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b6044820152606401610663565b611a32816106b460017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618614c25565b611a61426106b460017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b614c25565b611a90436106b460017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1614c25565b7f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe236713426814243604051611ac39392919061556a565b60405180910390a150565b815181518114611af15760405163586cb9e160e01b815260040160405180910390fd5b60005b81811015611c015760006001600160a01b0316848281518110611b1957611b1961558b565b60200260200101516001600160a01b031603611b485760405163d92e233d60e01b815260040160405180910390fd5b828181518110611b5a57611b5a61558b565b602002602001015163ffffffff16600003611b885760405163eb79f4eb60e01b815260040160405180910390fd5b633b9aca0063ffffffff16838281518110611ba557611ba561558b565b602002602001015163ffffffff161115611bf957828181518110611bcb57611bcb61558b565b60200260200101516040516304470bfd60e21b8152600401610663919063ffffffff91909116815260200190565b600101611af4565b50505050565b600080611c12611867565b9050611c3085856024811115611c2a57611c2a614412565b85612d01565b91506000611c4a86866024811115610a0757610a07614412565b63ffffffff808516600081815260208681526040808320869055858352600188019091529020929350611c7e9291612df616565b5050509392505050565b600080611ca38560ff166024811115610fb057610fb0614412565b90506001816004811115611cb957611cb9614412565b03611cc8576001915050610796565b6002816004811115611cdc57611cdc614412565b03611ceb576001915050610796565b6003816004811115611cff57611cff614412565b03611d8957604051630152f74f60e41b815263ffffffff871660048201526001600160a01b0385811660248301526044820185905288169063152f74f090606401602060405180830381865afa158015611d5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d81919061554f565b915050610796565b604051630dad26cb60e31b815260ff86166004820152602401610663565b6001600160a01b039290921660a09190911b600160a01b600160e01b03161760e09190911b6001600160e01b0319161790565b611de2613c30565b611dea613c30565b611e4583600001805480602002602001604051908101604052809291908181526020018280548015611e3b57602002820191906000526020600020905b815481526020019060010190808311611e27575b5050505050612e02565b606083015260808201526001830154600881901c601082901c603083901c60ff90811661010086015263ffffffff90911660e085015290811660c08401521660a08201526002830154611e9f60a082901c9060e083901c90565b60ff166101608401526001600160401b039081166101408401526001600160a01b039091166101208301526003840154908190811115611ee157611ee1613f2f565b604051908082528060200260200182016040528015611f0a578160200160208202803683370190505b50610180830152806001600160401b03811115611f2957611f29613f2f565b604051908082528060200260200182016040528015611f52578160200160208202803683370190505b506101a083015260005b81811015611ff257611f90856003018281548110611f7c57611f7c61558b565b90600052602060002001549060a082901c90565b8461018001518381518110611fa757611fa761558b565b60200260200101856101a001518481518110611fc557611fc561558b565b63ffffffff909316602093840291909101909201919091526001600160a01b039091169052600101611f5c565b50909392505050565b612003613ca2565b506040805160808101825260ff8381166001148252604884901c166020820152602883901c60030b9181019190915263ffffffff60089290921c91909116606082015290565b336001600160a01b0316816001600160a01b031663683fedf76040518163ffffffff1660e01b8152600401602060405180830381865afa158015612091573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120b59190614c56565b6001600160a01b031614610499573360405163cf219bef60e01b81526004016106639190614a84565b6000806120ee87876130f361319c565b9050600089600101600061210288856118da565b81526020019081526020016000209050600061211d826133a5565b9050806000036121405760405163296a76c760e21b815260040160405180910390fd5b6000816001146121625761215d612158600184614c25565b6130f3565b612165565b60005b9050600060028d018160ff60e81b60e88c901b1660ff60e01b60e089901b16600160a01b600160e01b0360a08c901b166001600160a01b038d16171717815260200190815260200160002090506121c48c8486848660008e8e8d6133af565b95508563ffffffff166000036121ed57604051639cb04d5d60e01b815260040160405180910390fd5b6122008163ffffffff80891690612df616565b505050505050979650505050505050565b6000600482602481111561222757612227614412565b14806122445750600582602481111561224257612242614412565b145b806122605750600882602481111561225e5761225e614412565b145b1561226d57506001919050565b600182602481111561228157612281614412565b148061229e5750600282602481111561229c5761229c614412565b145b806122ba575060038260248111156122b8576122b8614412565b145b806122d65750600a8260248111156122d4576122d4614412565b145b806122f2575060208260248111156122f0576122f0614412565b145b8061230e5750602182602481111561230c5761230c614412565b145b8061232a5750602282602481111561232857612328614412565b145b806123465750602382602481111561234457612344614412565b145b1561235357506002919050565b600682602481111561236757612367614412565b14806123845750600782602481111561238257612382614412565b145b806123a05750600b82602481111561239e5761239e614412565b145b806123bc5750600c8260248111156123ba576123ba614412565b145b806123d85750600d8260248111156123d6576123d6614412565b145b806123f45750600e8260248111156123f2576123f2614412565b145b806124105750600f82602481111561240e5761240e614412565b145b8061242c5750601082602481111561242a5761242a614412565b145b806124485750601182602481111561244657612446614412565b145b806124645750601282602481111561246257612462614412565b145b806124805750601382602481111561247e5761247e614412565b145b8061249c5750601482602481111561249a5761249a614412565b145b806124b8575060158260248111156124b6576124b6614412565b145b806124d4575060168260248111156124d2576124d2614412565b145b806124f0575060178260248111156124ee576124ee614412565b145b8061250c5750601882602481111561250a5761250a614412565b145b806125285750601982602481111561252657612526614412565b145b806125445750601a82602481111561254257612542614412565b145b806125605750601b82602481111561255e5761255e614412565b145b8061257c5750601c82602481111561257a5761257a614412565b145b806125985750601d82602481111561259657612596614412565b145b806125b45750601e8260248111156125b2576125b2614412565b145b806125d05750601f8260248111156125ce576125ce614412565b145b156125dd57506003919050565b8160248111156125ef576125ef614412565b6040516302f13cad60e41b815260ff9091166004820152602401610663565b919050565b600061074b6001600160a01b0385168484611da7565b6000612633611867565b9050600061264a6001600160a01b0385168461188b565b60088301546000828152600785016020526040902054919250429161266f9190614c38565b111561268e5760405163051211b760e11b815260040160405180910390fd5b60009081526007909101602052604090204290555050565b6126ae613cf6565b8161ffff166000036126d357604051635c5e6bb360e11b815260040160405180910390fd5b82604001516001600160a01b031663524a562f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612715573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127399190614c56565b6001600160a01b0316631c1b0daa84600001518561010001518660e001518760a0015188602001518961012001518a606001518b61016001518c61018001516040518a63ffffffff1660e01b815260040161279c999897969594939291906155a1565b6000604051808303816000875af11580156127bb573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526127e3919081019061541a565b90508060200151806127f3575080515b1561046b57600083604001516001600160a01b0316628e96916040518163ffffffff1660e01b8152600401602060405180830381865afa15801561283b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061285f9190614c56565b9050600061286c8461347e565b6020860151610120870151604051631c2aafe760e01b81529293506000926001600160a01b03861692631c2aafe7926128a992879060040161556a565b602060405180830381865afa1580156128c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128ea91906150cb565b9050826001600160a01b031663184f61438760200151886101200151858560016129149190614c38565b6040516001600160e01b031960e087901b1681526001600160a01b039094166004850152602484019290925260448301526064820152608401600060405180830381600087803b15801561296757600080fd5b505af115801561297b573d6000803e3d6000fd5b5050505050505092915050565b6060820151608083015161299b916134b5565b80516129ae918391602090910190613d8a565b5060a082015160c083015160e084015161010085015160ff90931660089290921b61ff00169190911760109190911b65ffffffff0000161760309190911b60ff60301b161760018201556101208201516101408301516101608401516001600160a01b0390921660a09190911b600160a01b600160e01b03161760e09190911b60ff60e01b16176002820155610180820151516000816001600160401b03811115612a5b57612a5b613f2f565b604051908082528060200260200182016040528015612a84578160200160208202803683370190505b50905060005b82811015612b0f57612aea856101a001518281518110612aac57612aac61558b565b60200260200101518661018001518381518110612acb57612acb61558b565b60200260200101516001600160a01b031661371390919063ffffffff16565b828281518110612afc57612afc61558b565b6020908102919091010152600101612a8a565b508051612b259060038501906020840190613d8a565b5050505050565b600080612b37611867565b90506000612b46868686612613565b6000818152600384016020526040902054909150612b65906001614c38565b6000918252600390920160205260409020819055949350505050565b612b25858585856137318661373c565b606081600001805480602002602001604051908101604052809291908181526020018280548015612be157602002820191906000526020600020905b815481526020019060010190808311612bcd575b50505050509050919050565b60008181526001830160205260408120548015612cd6576000612c11600183614c25565b8554909150600090612c2590600190614c25565b9050808214612c8a576000866000018281548110612c4557612c4561558b565b9060005260206000200154905080876000018481548110612c6857612c6861558b565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080612c9b57612c9b61561a565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061046b565b600091505061046b565b5092915050565b6000612cf1610ad1565b54600160401b900460ff16919050565b600060ff84161580612d14575060ff8316155b80612d21575061ffff8216155b15612d3f5760405163273e150360e21b815260040160405180910390fd5b60648460ff1610612d68576040516340eff0e560e01b815260ff85166004820152602401610663565b60648360ff1610612d915760405163017c4c5960e01b815260ff84166004820152602401610663565b6127108261ffff161115612dbe57604051637dc12d1d60e01b815261ffff83166004820152602401610663565b61ffff8216612dd260ff8516612710615630565b612de260ff8716620f4240615630565b612dec9190615658565b61074b9190615658565b60006104688383613825565b805160609081906000612e16826008614fe8565b90506000816001600160401b03811115612e3257612e32613f2f565b604051908082528060200260200182016040528015612e5b578160200160208202803683370190505b5090506000826001600160401b03811115612e7857612e78613f2f565b604051908082528060200260200182016040528015612ea1578160200160208202803683370190505b5090506000805b85811015612fce5760005b6008811015612fc557600081612eca846008614fe8565b612ed49190614c38565b9050612ee1826020614fe8565b8b8481518110612ef357612ef361558b565b602002602001015160001c901c60020b868281518110612f1557612f1561558b565b60039290920b602092830291909101820152612f32908390614fe8565b612f3d906018614c38565b8b8481518110612f4f57612f4f61558b565b602002602001015160001c901c858281518110612f6e57612f6e61558b565b602002602001019060ff16908160ff1681525050858181518110612f9457612f9461558b565b602002602001015160030b600003612fac5750612fc5565b83612fb681615675565b94505050806001019050612eb3565b50600101612ea8565b50806001600160401b03811115612fe757612fe7613f2f565b604051908082528060200260200182016040528015613010578160200160208202803683370190505b509650806001600160401b0381111561302b5761302b613f2f565b604051908082528060200260200182016040528015613054578160200160208202803683370190505b50955060005b818110156130e8578381815181106130745761307461558b565b602002602001015188828151811061308e5761308e61558b565b602002602001019060030b908160030b815250508281815181106130b4576130b461558b565b60200260200101518782815181106130ce576130ce61558b565b60ff9092166020928302919091019091015260010161305a565b505050505050915091565b60008160000361310557506000919050565b600061310f613874565b905061311c836001614c38565b4340414443423a5a8860405160200161317998979695949392919097885260609690961b6001600160601b0319166020880152603487019490945260548601929092526074850152609484015260b483015260d482015260f40190565b6040516020818303038152906040528051906020012060001c61074e91906156a4565b82516000908015806131af575083518114155b156131cd5760405163360ee06360e21b815260040160405180910390fd5b806001036131f757846000815181106131e8576131e861558b565b60200260200101519150613376565b600061320a633b9aca0063ffffffff8616565b9050600061321d633b9aca006001615658565b63ffffffff16905060005b83811015613372578781815181106132425761324261558b565b602002602001015160ff166000031561336a57633b9aca0063ffffffff168782815181106132725761327261558b565b602002602001015163ffffffff1611156132cf578681815181106132985761329861558b565b6020908102919091010151604051631b4fdad960e11b815263ffffffff9091166004820152633b9aca006024820152604401610663565b828782815181106132e2576132e261558b565b6020026020010151633b9aca006132f991906156b8565b63ffffffff161161336a57818782815181106133175761331761558b565b602002602001015163ffffffff16101561336a5786818151811061333d5761333d61558b565b602002602001015163ffffffff16915087818151811061335f5761335f61558b565b602002602001015194505b600101613228565b5050505b8160ff1660000361339d5760405163b3cea44d60e01b815260006004820152602401610663565b509392505050565b600061046b825490565b6000886133bb886133a5565b106133cd57600194506133cd876138ac565b6000805b8a811015613440578a88106133e557600097505b60006133f18b8a6138fa565b90506134008d82878a8a611c88565b80156134235750878061342357506134218a63ffffffff8084169061390616565b155b1561343357925060019150613440565b50600197880197016133d1565b508015801561344d575085155b156134705761345b886138ac565b61346d8b8b8b8b8b60018b8b8b6133af565b91505b509998505050505050505050565b600061348d8261ffff1661391e565b60405160200161349d91906156d5565b60405160208183030381529060405261046b90615703565b606081518351146134d95760405163586cb9e160e01b815260040160405180910390fd5b6000600884516134e9919061572a565b6134f4906001614c38565b90506000816001600160401b0381111561351057613510613f2f565b604051908082528060200260200182016040528015613539578160200160208202803683370190505b50905060005b8281101561370a5760005b600881101561370157600081613561846008614fe8565b61356b9190614c38565b90508751811061357b5750613701565b627fffff60020b8882815181106135945761359461558b565b602002602001015160030b13806135cd5750627fffff1960020b8882815181106135c0576135c061558b565b602002602001015160030b125b1561360b578781815181106135e4576135e461558b565b602002602001015160030b604051632eb1d06960e01b815260040161066391815260200190565b87818151811061361d5761361d61558b565b602002602001015160030b60000361364857604051637c946ed760e01b815260040160405180910390fd5b613653826020614fe8565b8882815181106136655761366561558b565b602002602001015162ffffff1660001b901b8484815181106136895761368961558b565b6020026020010181815117915081815250508160206136a89190614fe8565b6136b3906018614c38565b8782815181106136c5576136c561558b565b602002602001015160ff1660001b901b8484815181106136e7576136e761558b565b60209081029190910101805190911790525060010161354a565b5060010161353f565b50949350505050565b63ffffffff60a01b60a09190911b166001600160a01b039091161790565b600061046b826130f3565b60408051608081018252600181526000602082018190529181018290526060810161376e633b9aca0063ffffffff8716565b63ffffffff1690529050600061378388611dda565b905060006137ac8260600151836080015185606001516137a288610c0d565b8660e00151613a26565b509050806009815181106137c2576137c261558b565b602090810291909101015160030b60408401526137de83613aec565b60048a0160006137f76001600160a01b038c168b61188b565b8152602001908152602001600020600088815260200190815260200160002081905550505050505050505050565b600081815260018301602052604081205461386c5750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561046b565b50600061046b565b60006350877ed646148061388b5750630235ddd046145b156138a9576040518060208160008060185afa6138a457fe5b505190505b90565b60006138b7826118ef565b905060005b8151811015610847576138f18282815181106138da576138da61558b565b60200260200101518461198890919063ffffffff16565b506001016138bc565b60006104688383613b0a565b60008181526001830160205260408120541515610468565b6060816000036139455750506040805180820190915260018152600360fc1b602082015290565b8160005b811561396f578061395981615675565b91506139689050600a8361572a565b9150613949565b6000816001600160401b0381111561398957613989613f2f565b6040519080825280601f01601f1916602001820160405280156139b3576020820181803683370190505b5090505b8415613a1e576139c8600183614c25565b91506139d5600a866156a4565b6139e0906030614c38565b60f81b8183815181106139f5576139f561558b565b60200101906001600160f81b031916908160001a905350613a17600a8661572a565b94506139b7565b949350505050565b60606000613a3560048661573e565b60408051602b8082526105808201909252919650602082016105608036833701905050915060005b8751811015613ad357613a8a878281518110613a7b57613a7b61558b565b60200260200101518787613b34565b83898381518110613a9d57613a9d61558b565b602002602001015160ff1681518110613ab857613ab861558b565b60039290920b60209283029190910190910152600101613a5d565b50613ae083866000613b34565b90509550959350505050565b600061046b8260000151836060015184604001518560200151613bdc565b6000826000018281548110613b2157613b2161558b565b9060005260206000200154905092915050565b60008360030b600003613b495750600061074e565b6000633b9aca00613b5e84600388900b615761565b613b689190615791565b633b9aca00613b8163ffffffff8716600389900b615761565b613b8b9190615791565b8660030b613b9991906157bf565b613ba391906157bf565b9050637fffffff811380613bbb5750637fffffff1981125b1561074b576040516344dc334160e01b815260048101829052602401610663565b600084613bea576000613bed565b60015b60ff1660001b905060088463ffffffff1660001b901b8117905060288363ffffffff1660001b901b8117905060488260ff1660001b901b81179050949350505050565b604080516101c081018252600080825260208201819052909182019081526060602082018190526040820181905260008183018190526080830181905260a0830181905260c0830181905260e08301819052610100830181905261012083015261014082018190526101609091015290565b60408051608081018252600080825260208201819052918101829052606081019190915290565b6040805160a081018252600080825260606020830181905292820183905282820152608081019190915290565b604080516101c08101825260008082526020820181905291810182905260608082018190526080820183905260a0820183905260c0820183905260e0820183905261010082018390526101208201839052610140820183905261016082018390526101808201929092526101a081019190915290565b50805460008255906000526020600020908101906104999190613dd5565b828054828255906000526020600020908101928215613dc5579160200282015b82811115613dc5578251825591602001919060010190613daa565b50613dd1929150613dd5565b5090565b5b80821115613dd15760008155600101613dd6565b6001600160a01b038116811461049957600080fd5b803561260e81613dea565b60008060408385031215613e1d57600080fd5b8235613e2881613dea565b946020939093013593505050565b63ffffffff8116811461049957600080fd5b803561260e81613e36565b600060208284031215613e6557600080fd5b813561074e81613e36565b60ff8116811461049957600080fd5b803561260e81613e70565b80356025811061260e57600080fd5b60008060408385031215613eac57600080fd5b8235613eb781613e70565b9150613ec560208401613e8a565b90509250929050565b6020808252825182820181905260009190848201906040850190845b81811015613f0657835183529284019291840191600101613eea565b50909695505050505050565b600060208284031215613f2457600080fd5b813561074e81613dea565b634e487b7160e01b600052604160045260246000fd5b6040516101c081016001600160401b0381118282101715613f6857613f68613f2f565b60405290565b604051601f8201601f191681016001600160401b0381118282101715613f9657613f96613f2f565b604052919050565b803561ffff8116811461260e57600080fd5b60006001600160401b03821115613fc957613fc9613f2f565b5060051b60200190565b600082601f830112613fe457600080fd5b81356020613ff9613ff483613fb0565b613f6e565b8083825260208201915060208460051b87010193508684111561401b57600080fd5b602086015b8481101561404057803561403381613e70565b8352918301918301614020565b509695505050505050565b8060030b811461049957600080fd5b803561260e8161404b565b600082601f83011261407657600080fd5b81356020614086613ff483613fb0565b8083825260208201915060208460051b8701019350868411156140a857600080fd5b602086015b848110156140405780356140c08161404b565b83529183019183016140ad565b6000604082840312156140df57600080fd5b604051604081016001600160401b03828210818311171561410257614102613f2f565b81604052829350843591508082111561411a57600080fd5b61412686838701613fd3565b8352602085013591508082111561413c57600080fd5b5061414985828601614065565b6020830152505092915050565b600082601f83011261416757600080fd5b81356020614177613ff483613fb0565b8083825260208201915060208460051b87010193508684111561419957600080fd5b602086015b848110156140405780356141b181613dea565b835291830191830161419e565b600082601f8301126141cf57600080fd5b813560206141df613ff483613fb0565b8083825260208201915060208460051b87010193508684111561420157600080fd5b602086015b8481101561404057803561421981613e36565b8352918301918301614206565b60006020828403121561423857600080fd5b81356001600160401b038082111561424f57600080fd5b908301906101c0828603121561426457600080fd5b61426c613f45565b61427583613e7f565b815261428360208401613f9e565b602082015261429460408401613e8a565b60408201526142a560608401613e48565b60608201526080830135828111156142bc57600080fd5b6142c8878286016140cd565b60808301525060a0830135828111156142e057600080fd5b6142ec878286016140cd565b60a0830152506142fe60c08401613e48565b60c082015261430f60e0840161405a565b60e082015261010061432281850161405a565b9082015261012061433484820161405a565b9082015261014061434684820161405a565b9082015261016061435884820161405a565b90820152610180838101358381111561437057600080fd5b61437c88828701614156565b8284015250506101a0808401358381111561439657600080fd5b6143a2888287016141be565b918301919091525095945050505050565b6000602082840312156143c557600080fd5b813561074e81613e70565b6000806000606084860312156143e557600080fd5b83356143f081613dea565b925060208401359150604084013561440781613e36565b809150509250925092565b634e487b7160e01b600052602160045260246000fd5b6025811061443857614438614412565b9052565b60008151808452602080850194506020840160005b8381101561447057815160ff1687529582019590820190600101614451565b509495945050505050565b60008151808452602080850194506020840160005b8381101561447057815160030b87529582019590820190600101614490565b6001600160a01b03169052565b60008151808452602080850194506020840160005b838110156144705781516001600160a01b0316875295820195908201906001016144d1565b60008151808452602080850194506020840160005b8381101561447057815163ffffffff168752958201959082019060010161450b565b805161ffff16825260006101c0602083015161454e602086018260ff169052565b5060408301516145616040860182614428565b5060608301518160608601526145798286018261443c565b91505060808301518482036080860152614593828261447b565b91505060a08301516145aa60a086018260ff169052565b5060c08301516145bf60c086018260ff169052565b5060e08301516145d760e086018263ffffffff169052565b506101008381015160ff1690850152610120808401516145f9828701826144af565b5050610140838101516001600160401b0316908501526101608084015160ff1690850152610180808401518583038287015261463583826144bc565b925050506101a08084015185830382870152610c9d83826144f6565b60a08152600061466460a083018561452d565b905082511515602083015260ff6020840151166040830152604083015160030b606083015263ffffffff60608401511660808301529392505050565b600080600080600060a086880312156146b857600080fd5b85356001600160401b03808211156146cf57600080fd5b6146db89838a01613fd3565b965060208801359150808211156146f157600080fd5b506146fe888289016141be565b945050604086013561470f81613e70565b9250606086013561471f81613dea565b949793965091946080013592915050565b60008151808452602080850194506020840160005b8381101561447057815187529582019590820190600101614745565b6020815263ffffffff82511660208201526000602083015160a0604084015261478d60c0840182614730565b90506040840151601f19808584030160608601526147ab8383614730565b92506060860151608086015260808601519150808584030160a0860152506107968282614730565b6005811061443857614438614412565b6020810161046b82846147d3565b80356001600160401b038116811461260e57600080fd5b600080600080600080600060e0888a03121561482357600080fd5b873561482e81613dea565b9650602061483d8982016147f1565b9650604089013561484d81613e36565b9550606089013561485d81613dea565b94506080890135935060a089013561487481613e70565b925060c08901356001600160401b038082111561489057600080fd5b818b0191508b601f8301126148a457600080fd5b8135818111156148b6576148b6613f2f565b6148c8601f8201601f19168501613f6e565b91508082528c848285010111156148de57600080fd5b808484018584013760008482840101525080935050505092959891949750929550565b80511515825260006101c0602083015161491f602086018215159052565b50604083015161493260408601826144af565b50606083015181606086015261494a828601826144bc565b9150506080830151614961608086018260030b9052565b5060a083015161497660a086018260030b9052565b5060c083015161498b60c086018260030b9052565b5060e08301516149a060e086018260030b9052565b50610100808401516149b68287018260030b9052565b50506101208381015163ffffffff81168683015250506101408381015163ffffffff8116868301525050610160838101519085015261018080840151908501526101a08084015185830382870152610c9d83826144f6565b6020815260006104686020830184614901565b60005b83811015614a3c578181015183820152602001614a24565b50506000910152565b60008151808452614a5d816020860160208601614a21565b601f01601f19169290920160200192915050565b6020815260006104686020830184614a45565b6001600160a01b0391909116815260200190565b600080600060608486031215614aad57600080fd5b614ab684613f9e565b92506020840135614ac681613e70565b9150614ad460408501613e8a565b90509250925092565b600060208284031215614aef57600080fd5b81356001600160401b0380821115614b0657600080fd5b908301906101c08286031215614b1b57600080fd5b614b23613f45565b614b2c83613f9e565b8152614b3a60208401613e7f565b6020820152614b4b60408401613e8a565b6040820152606083013582811115614b6257600080fd5b614b6e87828601613fd3565b606083015250608083013582811115614b8657600080fd5b614b9287828601614065565b608083015250614ba460a08401613e7f565b60a0820152614bb560c08401613e7f565b60c0820152614bc660e08401613e48565b60e0820152610100614bd9818501613e7f565b90820152610120614beb848201613dff565b90820152610140614bfd8482016147f1565b90820152610160614358848201613e7f565b634e487b7160e01b600052601160045260246000fd5b8181038181111561046b5761046b614c0f565b8082018082111561046b5761046b614c0f565b805161260e81613dea565b600060208284031215614c6857600080fd5b815161074e81613dea565b805160408084528151908401819052600091602091908201906060860190845b81811015614cb257835160ff1683529284019291840191600101614c93565b50508483015186820387850152805180835290840192506000918401905b8083101561404057835160030b8252928401926001929092019190840190614cd0565b60408152614d0760408201845160ff169052565b60006020840151614d1e606084018261ffff169052565b506040840151614d316080840182614428565b50606084015163ffffffff1660a083015260808401516101c060c08401819052614d5f610200850183614c73565b915060a0860151603f19808685030160e0870152614d7d8483614c73565b935060c08801519150610100614d9a8188018463ffffffff169052565b60e08901519250610120614db28189018560030b9052565b90890151925061014090614dca8883018560030b9052565b8901519250610160614de08882018560030b9052565b90890151925061018090614df88883018560030b9052565b89015192506101a0614e0e8882018560030b9052565b818a01519350828887030185890152614e2786856144bc565b9550808a01519450505080868503016101e08701525050614e4882826144f6565b925050508260208301529392505050565b6000815160408452614e6e604085018261443c565b905060208301518482036020860152610796828261447b565b63ffffffff8316815260406020820152614ea760408201835160ff169052565b60006020830151614ebe606084018261ffff169052565b506040830151614ed16080840182614428565b50606083015163ffffffff1660a083015260808301516101c060c08401819052614eff610200850183614e59565b915060a0850151603f19808685030160e0870152614f1d8483614e59565b935060c08701519150610100614f3a8188018463ffffffff169052565b60e08801519250610120614f528189018560030b9052565b90880151925061014090614f6a8883018560030b9052565b8801519250610160614f808882018560030b9052565b90880151925061018090614f988883018560030b9052565b88015192506101a0614fae8882018560030b9052565b818901519350828887030185890152614fc786856144bc565b9550808901519450505080868503016101e08701525050610c9d82826144f6565b808202811582820484141761046b5761046b614c0f565b6001600160a01b03929092168252602082015260400190565b8051801515811461260e57600080fd5b600060a0828403121561503a57600080fd5b60405160a081018181106001600160401b038211171561505c5761505c613f2f565b604052825161506a81613e70565b8152602083015161507a81613e70565b602082015261508b60408401615018565b6040820152606083015168ffffffffffffffffff811681146150ac57600080fd5b606082015260808301516150bf81613dea565b60808201529392505050565b6000602082840312156150dd57600080fd5b5051919050565b60006101a06150f48484516144af565b602083015161510660208601826144af565b50604083015161511960408601826144af565b50606083015161512e606086018260ff169052565b506080830151615143608086018260ff169052565b5060a083015161515860a086018260ff169052565b5060c083015161516d60c086018260ff169052565b5060e083015161518560e086018263ffffffff169052565b50610100838101516001600160401b03169085015261012080840151908501526101408084015190850152610160808401519085015261018080840151818601839052610c9d83870182614a45565b6040815260006151e760408301856150e4565b90508260208301529392505050565b600082601f83011261520757600080fd5b81516020615217613ff483613fb0565b8083825260208201915060208460051b87010193508684111561523957600080fd5b602086015b8481101561404057805161525181613dea565b835291830191830161523e565b805161260e8161404b565b805161260e81613e36565b600082601f83011261528557600080fd5b81516020615295613ff483613fb0565b8083825260208201915060208460051b8701019350868411156152b757600080fd5b602086015b848110156140405780516152cf81613e36565b83529183019183016152bc565b60006101c082840312156152ef57600080fd5b6152f7613f45565b905061530282615018565b815261531060208301615018565b602082015261532160408301614c4b565b604082015260608201516001600160401b038082111561534057600080fd5b61534c858386016151f6565b606084015261535d6080850161525e565b608084015261536e60a0850161525e565b60a084015261537f60c0850161525e565b60c084015261539060e0850161525e565b60e084015261010091506153a582850161525e565b8284015261012091506153b9828501615269565b8284015261014091506153cd828501615269565b8284015261016091508184015182840152610180915081840151828401526101a09150818401518181111561540157600080fd5b61540d86828701615274565b8385015250505092915050565b60006020828403121561542c57600080fd5b81516001600160401b0381111561544257600080fd5b613a1e848285016152dc565b6000806040838503121561546157600080fd5b82516001600160401b0381111561547757600080fd5b615483858286016152dc565b925050602083015161549481613e70565b809150509250929050565b60006101406001600160401b038d16835263ffffffff8c1660208401526154c9604084018c6147d3565b6001600160a01b038a1660608401526080830189905260ff881660a084015260c0830187905260e0830181905261550281840187614a45565b90508281036101008401526155178186614901565b915050826101208301529b9a5050505050505050505050565b63ffffffff8316815260406020820152600061074b604083018461452d565b60006020828403121561556157600080fd5b61046882615018565b6001600160a01b039390931683526020830191909152604082015260600190565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b038a811682526001600160401b038a16602083015263ffffffff8916604083015260ff8881166060840152908716608083015260a08201869052841660c082015260e08101839052610120610100820181905260009061560a83820185614a45565b9c9b505050505050505050505050565b634e487b7160e01b600052603160045260246000fd5b63ffffffff81811683821602808216919082811461565057615650614c0f565b505092915050565b63ffffffff818116838216019080821115612ce057612ce0614c0f565b60006001820161568757615687614c0f565b5060010190565b634e487b7160e01b600052601260045260246000fd5b6000826156b3576156b361568e565b500690565b63ffffffff828116828216039080821115612ce057612ce0614c0f565b6553544f52595f60d01b8152600082516156f6816006850160208701614a21565b9190910160060192915050565b80516020808301519190811015615724576000198160200360031b1b821691505b50919050565b6000826157395761573961568e565b500490565b600063ffffffff808416806157555761575561568e565b92169190910492915050565b80820260008212600160ff1b8414161561577d5761577d614c0f565b818105831482151761046b5761046b614c0f565b6000826157a0576157a061568e565b600160ff1b8214600019841416156157ba576157ba614c0f565b500590565b808201828112600083128015821682158216171561565057615650614c0f56fe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda26469706673582212204bb3ece109dd8a9ae3d08192ff59a86deb282fd9fc1bf4e786f6778a52e9950a64736f6c63430008170033",
  "libraries": {
    "EventLib": "0x45D129F2E7F8A7b2b526F80365Ada7f25Ba7eF7F",
    "StoryLib": "0x0bDDE3236D22B33bF09CdE2c576Be6a54e2C1F71",
    "MonsterLib": "0xBb611DaA59d2D0EEd9B6e73e88526745a672D724",
    "GOCLib": "0x7D2c213e7AdEEEeDF16A173BAe33000AFE4F419A"
  },
  "devdoc": {
    "errors": {
      "InvalidInitialization()": [
        {
          "details": "The contract is already initialized."
        }
      ],
      "NotInitializing()": [
        {
          "details": "The contract is not initializing."
        }
      ]
    },
    "events": {
      "Initialized(uint64)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      }
    },
    "kind": "dev",
    "methods": {
      "created()": {
        "returns": {
          "_0": "Creation timestamp"
        }
      },
      "createdBlock()": {
        "returns": {
          "_0": "Creation block number"
        }
      },
      "getObjectMeta(uint32)": {
        "details": "represent object registration if non zero values"
      },
      "getRandomObject(uint8[],uint32[],uint8,address,uint256)": {
        "details": "Chances in range 0-1e9"
      },
      "increaseRevision(address)": {
        "details": "Revision should be increased on each contract upgrade"
      },
      "isController(address)": {
        "details": "Return true if given address is controller"
      },
      "previousImplementation()": {
        "details": "Previous logic implementation"
      },
      "revision()": {
        "details": "Contract upgrade counter"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "CONTROLLABLE_VERSION()": {
        "notice": "Version of the contract"
      },
      "VERSION()": {
        "notice": "Version of the contract"
      },
      "controller()": {
        "notice": "Return controller address saved in the contract slot"
      },
      "created()": {
        "notice": "Return creation timestamp"
      },
      "createdBlock()": {
        "notice": "Return creation block number"
      },
      "isGovernance(address)": {
        "notice": "Return true if given address is setup as governance in Controller"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}