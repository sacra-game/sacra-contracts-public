{
  "address": "0x6a6A99D3E1838b39D5E766fFCd7A09461F08E279",
  "abi": [
    {
      "inputs": [],
      "name": "AlreadyGuildMember",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CannotRemoveGuildOwnerFromNotEmptyGuild",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EmptyNameNotAllowed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorOnlyEoa",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "right",
          "type": "uint256"
        }
      ],
      "name": "GuildActionForbidden",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "level",
          "type": "uint256"
        }
      ],
      "name": "GuildHasMaxLevel",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "guildSize",
          "type": "uint256"
        }
      ],
      "name": "GuildHasMaxSize",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidInitialization",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "fee",
          "type": "uint8"
        }
      ],
      "name": "MaxFee",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "fee",
          "type": "uint8"
        }
      ],
      "name": "MinFee",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NameTaken",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "NotGovernance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotGuildMember",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotInitializing",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SecondGuildAdminIsNotAllowed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TooBigName",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TooLongUrl",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "WrongSymbolsInTheName",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroValueNotAllowed",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newUser",
          "type": "address"
        }
      ],
      "name": "AddToGuild",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rights",
          "type": "uint256"
        }
      ],
      "name": "ChangeGuildRights",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ts",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "block",
          "type": "uint256"
        }
      ],
      "name": "ContractInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "guildBank",
          "type": "address"
        }
      ],
      "name": "GuildBankDeployed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "urlLogo",
          "type": "string"
        }
      ],
      "name": "GuildCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "name": "GuildDeleted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "newLevel",
          "type": "uint8"
        }
      ],
      "name": "GuildLevelUp",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "newLogoUrl",
          "type": "string"
        }
      ],
      "name": "GuildLogoChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "newName",
          "type": "string"
        }
      ],
      "name": "GuildRename",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "version",
          "type": "uint64"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "RemoveFromGuild",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "RevisionIncreased",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId1",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId2",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "peace",
          "type": "bool"
        }
      ],
      "name": "SetGuildRelation",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "TransferFromGuildBank",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "nfts",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "tokenIds",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "TransferNftFromGuildBank",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CONTROLLABLE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newUser",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "maskRights",
          "type": "uint256"
        }
      ],
      "name": "addGuildMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "newLogoUrl",
          "type": "string"
        }
      ],
      "name": "changeLogo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "maskRights",
          "type": "uint256"
        }
      ],
      "name": "changeRoles",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "counterGuildIds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "urlLogo",
          "type": "string"
        },
        {
          "internalType": "uint8",
          "name": "toHelperRatio",
          "type": "uint8"
        }
      ],
      "name": "createGuild",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "created",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "createdBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBaseFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "name": "getGuildBank",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        }
      ],
      "name": "getGuildByName",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "name": "getGuildData",
      "outputs": [
        {
          "internalType": "string",
          "name": "guildName",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "urlLogo",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "guildLevel",
          "type": "uint8"
        },
        {
          "internalType": "uint64",
          "name": "pvpCounter",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "toHelperRatio",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "getRights",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "guildLevelUp",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "name": "guildMembers",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "increaseRevision",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "controller_",
          "type": "address"
        }
      ],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isController",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isGovernance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "guildId2",
          "type": "uint256"
        }
      ],
      "name": "isPeacefulRelation",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "forwarder",
          "type": "address"
        }
      ],
      "name": "isTrustedForwarder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "memberOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "previousImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "userToRemove",
          "type": "address"
        }
      ],
      "name": "removeGuildMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "newGuildName",
          "type": "string"
        }
      ],
      "name": "rename",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "revision",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "fee",
          "type": "uint256"
        }
      ],
      "name": "setBaseFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "otherGuildId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "peace",
          "type": "bool"
        }
      ],
      "name": "setRelation",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "value",
          "type": "uint8"
        }
      ],
      "name": "setToHelperRatio",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "address[]",
          "name": "nfts",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "tokenIds",
          "type": "uint256[]"
        }
      ],
      "name": "transferNftMulti",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x45578d91e059f09ed970fab08a7ec39f96ee89b9ca201fa131c6f77b287f2c65",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0x6a6A99D3E1838b39D5E766fFCd7A09461F08E279",
    "transactionIndex": 1,
    "gasUsed": "3876207",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000800000000000000000000000080000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000010000000000000000000000000000000000000000000000000000",
    "blockHash": "0x00008f8700001ffd2d425349b8dae610c9fadf18d49fe91aede4e50881f599d2",
    "transactionHash": "0x45578d91e059f09ed970fab08a7ec39f96ee89b9ca201fa131c6f77b287f2c65",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 68282938,
        "transactionHash": "0x45578d91e059f09ed970fab08a7ec39f96ee89b9ca201fa131c6f77b287f2c65",
        "address": "0x6a6A99D3E1838b39D5E766fFCd7A09461F08E279",
        "topics": [
          "0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 0,
        "blockHash": "0x00008f8700001ffd2d425349b8dae610c9fadf18d49fe91aede4e50881f599d2"
      }
    ],
    "blockNumber": 68282938,
    "cumulativeGasUsed": "3897207",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 5,
  "solcInputHash": "26aa46af27336d196c04997c06413167",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AlreadyGuildMember\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotRemoveGuildOwnerFromNotEmptyGuild\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyNameNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorOnlyEoa\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"right\",\"type\":\"uint256\"}],\"name\":\"GuildActionForbidden\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"GuildHasMaxLevel\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"guildSize\",\"type\":\"uint256\"}],\"name\":\"GuildHasMaxSize\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fee\",\"type\":\"uint8\"}],\"name\":\"MaxFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fee\",\"type\":\"uint8\"}],\"name\":\"MinFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NameTaken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotGovernance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotGuildMember\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SecondGuildAdminIsNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooBigName\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooLongUrl\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongSymbolsInTheName\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroValueNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newUser\",\"type\":\"address\"}],\"name\":\"AddToGuild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rights\",\"type\":\"uint256\"}],\"name\":\"ChangeGuildRights\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"ContractInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guildBank\",\"type\":\"address\"}],\"name\":\"GuildBankDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"urlLogo\",\"type\":\"string\"}],\"name\":\"GuildCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"name\":\"GuildDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newLevel\",\"type\":\"uint8\"}],\"name\":\"GuildLevelUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newLogoUrl\",\"type\":\"string\"}],\"name\":\"GuildLogoChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"GuildRename\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RemoveFromGuild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"RevisionIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"peace\",\"type\":\"bool\"}],\"name\":\"SetGuildRelation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"TransferFromGuildBank\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"nfts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"TransferNftFromGuildBank\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTROLLABLE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maskRights\",\"type\":\"uint256\"}],\"name\":\"addGuildMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newLogoUrl\",\"type\":\"string\"}],\"name\":\"changeLogo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maskRights\",\"type\":\"uint256\"}],\"name\":\"changeRoles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"counterGuildIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"urlLogo\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"toHelperRatio\",\"type\":\"uint8\"}],\"name\":\"createGuild\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"name\":\"getGuildBank\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"getGuildByName\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"name\":\"getGuildData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"guildName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"urlLogo\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"guildLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"pvpCounter\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"toHelperRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guildLevelUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"name\":\"guildMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"increaseRevision\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"guildId2\",\"type\":\"uint256\"}],\"name\":\"isPeacefulRelation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"memberOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userToRemove\",\"type\":\"address\"}],\"name\":\"removeGuildMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newGuildName\",\"type\":\"string\"}],\"name\":\"rename\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setBaseFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"otherGuildId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"peace\",\"type\":\"bool\"}],\"name\":\"setRelation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"value\",\"type\":\"uint8\"}],\"name\":\"setToHelperRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"nfts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"transferNftMulti\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidInitialization()\":[{\"details\":\"The contract is already initialized.\"}],\"NotInitializing()\":[{\"details\":\"The contract is not initializing.\"}]},\"events\":{\"Initialized(uint64)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"}},\"kind\":\"dev\",\"methods\":{\"created()\":{\"returns\":{\"_0\":\"Creation timestamp\"}},\"createdBlock()\":{\"returns\":{\"_0\":\"Creation block number\"}},\"increaseRevision(address)\":{\"details\":\"Revision should be increased on each contract upgrade\"},\"isController(address)\":{\"details\":\"Return true if given address is controller\"},\"previousImplementation()\":{\"details\":\"Previous logic implementation\"},\"removeGuildMember(address)\":{\"details\":\"To delete the guild the owner should remove all members and remove himself at the end\"},\"revision()\":{\"details\":\"Contract upgrade counter\"},\"setBaseFee(uint256)\":{\"params\":{\"fee\":\"Base fee value in terms of game token\"}}},\"stateVariables\":{\"VERSION\":{\"details\":\"Should be incremented when contract changed\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"CONTROLLABLE_VERSION()\":{\"notice\":\"Version of the contract\"},\"VERSION()\":{\"notice\":\"Version of the contract\"},\"addGuildMember(address,uint256)\":{\"notice\":\"Add new member to the guild to which msgSender belongs\"},\"changeRoles(address,uint256)\":{\"notice\":\"Edit roles of the given member of the guild to which msgSender belongs\"},\"controller()\":{\"notice\":\"Return controller address saved in the contract slot\"},\"createGuild(string,string,uint8)\":{\"notice\":\"Create new guild, return ID of the new guild\"},\"created()\":{\"notice\":\"Return creation timestamp\"},\"createdBlock()\":{\"notice\":\"Return creation block number\"},\"guildLevelUp()\":{\"notice\":\"Increment level of the guild, pay BASE_FEE * new level\"},\"isGovernance(address)\":{\"notice\":\"Return true if given address is setup as governance in Controller\"},\"removeGuildMember(address)\":{\"notice\":\"Remove given member from the guild to which msgSender belongs\"},\"rename(string)\":{\"notice\":\"Rename the guild, pay BASE_FEE\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/GuildController.sol\":\"GuildController\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":50},\"remappings\":[]},\"sources\":{\"contracts/core/GuildController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n/**\\n            \\u2592\\u2593\\u2592  \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2593\\n             \\u2592\\u2588\\u2588\\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593  \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n              \\u2592\\u2588\\u2588\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592 \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n               \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592                   \\u2592\\u2588\\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                     \\u2592\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592     \\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                   \\u2592\\u2592\\u2592\\u2592\\u2592   \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                         \\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                       \\u2592\\u2588\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\n                        \\u2592\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592       \\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\n                          \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593   \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                           \\u2592\\u2592\\u2593\\u2593\\u2592   \\u2592\\u2588\\u2588\\u2593\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                  \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                                 \\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                                \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n      \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593                  \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                      \\u2592\\u2593\\u2593\\n    \\u2592\\u2593\\u2588\\u2592   \\u2592\\u2592\\u2588\\u2592\\u2592                   \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2592\\u2593\\u2593\\u2592\\n   \\u2592\\u2592\\u2588\\u2592       \\u2593\\u2592                    \\u2592\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2588\\u2593\\u2592\\n   \\u2593\\u2592\\u2588\\u2588\\u2593\\u2592                             \\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2592\\n    \\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2593\\u2592        \\u2592\\u2592\\u2592         \\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592\\u2592\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2592 \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n     \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2592\\u2592\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2593\\u2593     \\u2593\\u2593  \\u2593\\u2593\\u2588\\u2593   \\u2592\\u2592\\u2593\\u2593   \\u2592\\u2592\\u2588\\u2592   \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n            \\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592  \\u2592\\u2593\\u2593\\u2593\\u2592\\u2588\\u2592   \\u2592\\u2592\\u2592\\u2588\\u2592          \\u2592\\u2592\\u2588\\u2593\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592   \\u2593\\u2588\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\n \\u2592            \\u2592\\u2593\\u2593\\u2588\\u2593  \\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2593  \\u2592\\u2588\\u2593\\u2593\\u2592          \\u2593\\u2593\\u2588\\u2593\\u2592\\u2593\\u2588\\u2593\\u2592\\u2592   \\u2593\\u2588\\u2593        \\u2593\\u2588\\u2588\\u2588\\u2593\\n\\u2593\\u2593\\u2592         \\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592\\u2592\\u2593\\u2588\\u2592   \\u2592\\u2593\\u2588\\u2588\\u2593  \\u2593\\u2588\\u2588\\u2593\\u2592     \\u2592\\u2588\\u2593 \\u2593\\u2593\\u2588\\u2588   \\u2592\\u2593\\u2593\\u2593\\u2592\\u2592\\u2593\\u2588\\u2593        \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2592\\n \\u2588\\u2588\\u2593\\u2593\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592\\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592     \\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592\\n*/\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../lib/GuildLib.sol\\\";\\nimport \\\"../lib/GuildControllerLib.sol\\\";\\nimport \\\"../proxy/Controllable.sol\\\";\\nimport \\\"../relay/ERC2771Context.sol\\\";\\n\\ncontract GuildController is Initializable, Controllable, ERC2771Context, IGuildController {\\n  //region ------------------------ CONSTANTS\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant override VERSION = \\\"1.0.0\\\";\\n  //endregion ------------------------ CONSTANTS\\n\\n  //region ------------------------ INITIALIZER\\n\\n  function init(address controller_) external initializer {\\n    __Controllable_init(controller_);\\n    GuildLib._S().guildsParam[IGuildController.GuildsParams.BASE_FEE_2] = GuildLib.DEFAULT_BASE_FEE;\\n  }\\n  //endregion ------------------------ INITIALIZER\\n\\n  //region ------------------------ VIEWS\\n  function counterGuildIds() external view returns (uint) {\\n    return GuildLib.counterGuildIds();\\n  }\\n\\n  function getGuildData(uint guildId) external view returns (\\n    string memory guildName,\\n    string memory urlLogo,\\n    address owner,\\n    uint8 guildLevel,\\n    uint64 pvpCounter,\\n    uint toHelperRatio\\n  ) {\\n    GuildData memory data = GuildLib.getGuildData(guildId);\\n    return (data.guildName, data.urlLogo, data.owner, data.guildLevel, data.pvpCounter, data.toHelperRatio);\\n  }\\n\\n  function getGuildByName(string memory name) external view returns (uint guildId) {\\n    return GuildLib.getGuildByName(name);\\n  }\\n\\n  function memberOf(address user) external view returns (uint guildId) {\\n    return GuildLib.memberOf(user);\\n  }\\n\\n  function guildMembers(uint guildId) external view returns (address[] memory) {\\n    return GuildLib.guildMembers(guildId);\\n  }\\n\\n  function getRights(address user) external view returns (uint) {\\n    return GuildLib.getRights(user);\\n  }\\n\\n  function isPeacefulRelation(uint guildId, uint guildId2) external view returns (bool) {\\n    return GuildLib.isPeacefulRelation(guildId, guildId2);\\n  }\\n\\n  function getBaseFee() external view returns (uint) {\\n    return GuildLib.getBaseFee();\\n  }\\n\\n  function getGuildBank(uint guildId) external view returns (address) {\\n    return GuildLib.getGuildBank(guildId);\\n  }\\n\\n// todo\\n//  function getBiomeOwner(uint8 biome) external view returns (uint guildId) {\\n//    return GuildLib.getBiomeOwner(biome);\\n\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ Gov actions\\n\\n  /// @param fee Base fee value in terms of game token\\n  function setBaseFee(uint fee) external {\\n    GuildLib.setBaseFee(IController(controller()), fee);\\n  }\\n\\n  //endregion ------------------------ Gov actions\\n\\n  //region ------------------------ ACTIONS\\n\\n  /// @notice Create new guild, return ID of the new guild\\n  function createGuild(string memory name, string memory urlLogo, uint8 toHelperRatio) external returns (uint) {\\n    return GuildLib.createGuild(_isNotSmartContract(), IController(controller()), _msgSender(), name, urlLogo, toHelperRatio);\\n  }\\n\\n  /// @notice Add new member to the guild to which msgSender belongs\\n  function addGuildMember(address newUser, uint maskRights) external {\\n    GuildLib.addGuildMember(_msgSender(), newUser, maskRights);\\n  }\\n\\n  /// @notice Edit roles of the given member of the guild to which msgSender belongs\\n  function changeRoles(address user, uint maskRights) external {\\n    GuildLib.changeRoles(_msgSender(), user, maskRights);\\n  }\\n\\n  /// @notice Remove given member from the guild to which msgSender belongs\\n  /// @dev To delete the guild the owner should remove all members and remove himself at the end\\n  function removeGuildMember(address userToRemove) external {\\n    GuildLib.removeGuildMember(_msgSender(), userToRemove);\\n  }\\n\\n  /// @notice Increment level of the guild, pay BASE_FEE * new level\\n  function guildLevelUp() external {\\n    GuildLib.guildLevelUp(IController(controller()), _msgSender());\\n  }\\n\\n  /// @notice Rename the guild, pay BASE_FEE\\n  function rename(string memory newGuildName) external {\\n    GuildLib.rename(IController(controller()), _msgSender(), newGuildName);\\n  }\\n\\n  function changeLogo(string memory newLogoUrl) external {\\n    GuildLib.changeLogo(_msgSender(), newLogoUrl);\\n  }\\n\\n  function setRelation(uint otherGuildId, bool peace) external {\\n    GuildLib.setRelation(_msgSender(), otherGuildId, peace);\\n  }\\n\\n  function setToHelperRatio(uint8 value) external {\\n    GuildLib.setToHelperRatio(_msgSender(), value);\\n  }\\n\\n  //endregion ------------------------ ACTIONS\\n\\n  //region ------------------------ Guild bank\\n  function transfer(address token, address recipient, uint amount) external {\\n    GuildLib.transfer(_msgSender(), token, recipient, amount);\\n  }\\n\\n  function transferNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external {\\n    GuildLib.transferNftMulti(_msgSender(), to, nfts, tokenIds);\\n  }\\n  //endregion ------------------------ Guild bank\\n}\",\"keccak256\":\"0xdce590e84a190627c8155bde822257ba9fc83b21664782bba3b112ca468c1cc8\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IAppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\n/// @notice All errors of the app\\ninterface IAppErrors {\\n  error ZeroAddress();\\n  error ZeroValueNotAllowed();\\n  error LengthsMismatch();\\n  error NotEnoughBalance();\\n  error EmptyNameNotAllowed();\\n  error NotInitialized();\\n  error AlreadyInitialized();\\n\\n  //region Restrictions\\n  error ErrorNotDeployer(address sender);\\n  error ErrorNotGoc();\\n  error NotGovernance(address sender);\\n  error ErrorOnlyEoa();\\n  error NotEOA(address sender);\\n  error ErrorForbidden(address sender);\\n  error ErrorNotItemController(address sender);\\n  error ErrorNotHeroController(address sender);\\n  error ErrorNotDungeonFactory(address sender);\\n  error ErrorNotObjectController(address sender);\\n  error ErrorNotStoryController();\\n  error ErrorNotAllowedSender();\\n  error MintNotAllowed();\\n  //endregion Restrictions\\n\\n  //region Hero\\n  error ErrorHeroIsNotRegistered(address heroToken);\\n  error ErrorHeroIsDead(address heroToken, uint heroTokenId);\\n  error ErrorHeroNotInDungeon();\\n  error HeroInDungeon();\\n  error ErrorNotHeroOwner(address heroToken, address msgSender);\\n  error Staked(address heroToken, uint heroId);\\n  error HeroTokensVaultAlreadySet();\\n  error NameTaken();\\n  error TooBigName();\\n  error WrongSymbolsInTheName();\\n  error NoPayToken(address token, uint payTokenAmount);\\n  error AlreadyHaveReinforcement();\\n  /// @notice SIP-001 - Reinforcement requires 3 skills\\n  error ErrorReinforcementRequiresThreeSkills();\\n  //endregion Hero\\n\\n  //region Dungeon\\n  error ErrorDungeonIsFreeAlready();\\n  error ErrorNoEligibleDungeons();\\n  error ErrorDungeonBusy();\\n  error ErrorNoDungeonsForBiome(uint8 heroBiome);\\n  error ErrorDungeonCompleted();\\n  error ErrorAlreadyInDungeon();\\n  error NotEnoughTokens(uint balance, uint expectedBalance);\\n  error DungeonAlreadySpecific(uint16 dungNum);\\n  error DungeonAlreadySpecific2(uint16 dungNum);\\n  error WrongSpecificDungeon();\\n  //endregion Dungeon\\n\\n  //region Items\\n  error ErrorItemNotEligibleForTheSlot(uint itemType, uint8 itemSlot);\\n  error ErrorItemSlotBusyHand(uint8 slot);\\n  error ErrorItemSlotBusy();\\n  error ErrorItemNotInSlot();\\n  error ErrorConsumableItemIsUsed(address item);\\n  error ErrorCannotRemoveItemFromMap();\\n  error ItemEquipped();\\n  error ZeroItemMetaType();\\n  error ZeroLevel();\\n  error ItemTypeChanged();\\n  error ItemMetaTypeChanged();\\n  error UnknownItem(address item);\\n  error ItemIsAlreadyEquipped(address item);\\n  error ErrorEquipForbidden();\\n  error EquipForbiddenInDungeon();\\n  error TakeOffForbiddenInDungeon();\\n  error Consumable(address item);\\n  error NotConsumable(address item);\\n  error Broken(address item);\\n  error ZeroLife();\\n  error RequirementsToItemAttributes();\\n  error NotEquipped(address item);\\n  error ZeroDurability();\\n  error ZeroAugmentation();\\n  error TooHighAgLevel(uint8 augmentationLevel);\\n  error UseForbiddenZeroPayToken();\\n  error IncorrectMinMaxAttributeRange(int32 min, int32 max);\\n  error SameIdsNotAllowed();\\n  //endregion Items\\n\\n  //region Stages\\n  error ErrorWrongStage(uint stage);\\n  error ErrorNotStages();\\n  //endregion Stages\\n\\n  //region Level\\n  error ErrorWrongLevel(uint heroLevel);\\n  error ErrorLevelTooLow(uint heroLevel);\\n  error ErrorHeroLevelStartFrom1();\\n  error ErrorWrongLevelUpSum();\\n  error ErrorMaxLevel();\\n  //endregion Level\\n\\n  //region Treasure\\n  error ErrorNotValidTreasureToken(address treasureToken);\\n  //endregion Treasure\\n\\n  //region State\\n  error ErrorPaused();\\n  error ErrorNotReady();\\n  error ErrorNotObject1();\\n  error ErrorNotObject2();\\n  error ErrorNotCompleted();\\n  //endregion State\\n\\n  //region Biome\\n  error ErrorNotBiome();\\n  error ErrorIncorrectBiome(uint biome);\\n  error TooHighBiome(uint biome);\\n  //endregion Biome\\n\\n  //region Misc\\n  error ErrorWrongMultiplier(uint multiplier);\\n  error ErrorNotEnoughMana(uint32 mana, uint requiredMana);\\n  error ErrorExperienceMustNotDecrease();\\n  error ErrorNotEnoughExperience();\\n  error ErrorNotChances();\\n  error ErrorNotEligible(address heroToken, uint16 dungNum);\\n  error ErrorZeroKarmaNotAllowed();\\n  //endregion Misc\\n\\n  //region GOC\\n  error GenObjectIdBiomeOverflow(uint8 biome);\\n  error GenObjectIdSubTypeOverflow(uint subType);\\n  error GenObjectIdIdOverflow(uint id);\\n  error UnknownObjectTypeGoc1(uint8 objectType);\\n  error UnknownObjectTypeGoc2(uint8 objectType);\\n  error UnknownObjectTypeGocLib1(uint8 objectType);\\n  error UnknownObjectTypeGocLib2(uint8 objectType);\\n  error UnknownObjectTypeForSubtype(uint8 objectSubType);\\n  error FightDelay();\\n  error ZeroChance();\\n  error TooHighChance(uint32 chance);\\n  error TooHighRandom(uint random);\\n  error EmptyObjects();\\n  error ObjectNotFound();\\n  error WrongGetObjectTypeInput();\\n  error WrongChances(uint32 chances, uint32 maxChances);\\n  //endregion GOC\\n\\n  //region Story\\n  error PageNotRemovedError(uint pageId);\\n  error NotItem1();\\n  error NotItem2();\\n  error NotRandom(uint32 random);\\n  error NotHeroData();\\n  error NotGlobalData();\\n  error ZeroStoryIdRemoveStory();\\n  error ZeroStoryIdStoryAction();\\n  error ZeroStoryIdAction();\\n  error NotEnoughAmount(uint balance, uint requiredAmount);\\n  error NotAnswer();\\n  error AnswerStoryIdMismatch(uint16 storyId, uint16 storyIdFromAnswerHash);\\n  error AnswerPageIdMismatch(uint16 pageId, uint16 pageIdFromAnswerHash);\\n  //endregion Story\\n\\n  //region FightLib\\n  error NotMagic();\\n  error NotAType(uint atype);\\n  //endregion FightLib\\n\\n  //region MonsterLib\\n  error NotYourDebuffItem();\\n  error UnknownAttackType(uint attackType);\\n  error NotYourAttackItem();\\n  /// @notice The skill item cannot be used because it doesn't belong either to the hero or to the hero's helper\\n  error NotYourBuffItem();\\n  //endregion MonsterLib\\n\\n  //region GameToken\\n  error ApproveToZeroAddress();\\n  error MintToZeroAddress();\\n  error TransferToZeroAddress();\\n  error TransferAmountExceedsBalance(uint balance, uint value);\\n  error InsufficientAllowance();\\n  error BurnAmountExceedsBalance();\\n  error NotMinter(address sender);\\n  //endregion GameToken\\n\\n  //region NFT\\n  error TokenTransferNotAllowed();\\n  error IdOverflow(uint id);\\n  error NotExistToken(uint tokenId);\\n  error EquippedItemIsNotAllowedToTransfer(uint tokenId);\\n  //endregion NFT\\n\\n  //region CalcLib\\n  error TooLowX(uint x);\\n  //endregion CalcLib\\n\\n  //region Controller\\n  error NotFutureGovernance(address sender);\\n  //endregion Controller\\n\\n  //region Oracle\\n  error OracleWrongInput();\\n  //region Oracle\\n\\n  //region ReinforcementController\\n  error AlreadyStaked();\\n  error MaxFee(uint8 fee);\\n  error MinFee(uint8 fee);\\n  error StakeHeroNotStats();\\n  error NotStaked();\\n  error NoStakedHeroes();\\n  //region ReinforcementController\\n\\n  //region SponsoredHero\\n  error InvalidHeroClass();\\n  error ZeroAmount();\\n  error InvalidProof();\\n  error NoHeroesAvailable();\\n  error AlreadyRegistered();\\n  //endregion SponsoredHero\\n\\n  //region SacraRelay\\n  error SacraRelayNotOwner();\\n  error SacraRelayNotDelegator();\\n  error SacraRelayNotOperator();\\n  error SacraRelayInvalidChainId(uint callChainId, uint blockChainId);\\n  error SacraRelayInvalidNonce(uint callNonce, uint txNonce);\\n  error SacraRelayDeadline();\\n  error SacraRelayDelegationExpired();\\n  error SacraRelayNotAllowed();\\n  error SacraRelayInvalidSignature();\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error by selector, see tests\\n  error SacraRelayNoErrorSelector(bytes4 selector, string tracingInfo);\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error manually from {errorBytes} as following:\\n  /// if (keccak256(abi.encodeWithSignature(\\\"MyError()\\\")) == keccak256(errorBytes)) { ... }\\n  error SacraRelayUnexpectedReturnData(bytes errorBytes, string tracingInfo);\\n  error SacraRelayCallToNotContract(address notContract, string tracingInfo);\\n  //endregion SacraRelay\\n\\n  //region Misc\\n  error UnknownHeroClass(uint heroClass);\\n  error AbsDiff(int32 a, int32 b);\\n  //region Misc\\n\\n  //region ------------------------ Guilds\\n  error NoAvailableLootBox(address msgSender, uint lootBoxKind);\\n  error AlreadyGuildMember();\\n  error NotGuildMember();\\n  error GuildActionForbidden(uint right);\\n  error GuildHasMaxSize(uint guildSize);\\n  error GuildHasMaxLevel(uint level);\\n  error TooLongUrl();\\n  error CannotRemoveGuildOwnerFromNotEmptyGuild();\\n  error GuildControllerOnly();\\n  error GuildAlreadyHasShelter();\\n  error ShelterIsBusy();\\n  error ShelterIsNotRegistered();\\n  error ShelterIsNotOwnedByTheGuild();\\n  error ShelterIsInUse();\\n  error GuildHasNoShelter();\\n  error ShelterBidIsNotAllowedToBeUsed();\\n  error ShelterHasHeroesInside();\\n  error SecondGuildAdminIsNotAllowed();\\n  error UserTokensVaultAlreadySet();\\n  //endregion ------------------------ Guilds\\n}\\n\\n\",\"keccak256\":\"0xbdbf8438240913322c15ce377f44d6a61e1c5909735d8a4f4d3413d1c73d75b0\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IApplicationEvents.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IDungeonFactory.sol\\\";\\nimport \\\"./IStoryController.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\n\\n/// @notice All events of the app\\ninterface IApplicationEvents {\\n\\n  //region ------------------ StatController\\n  event HeroItemSlotChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint itemType,\\n    uint itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip,\\n    address caller\\n  );\\n  event CurrentStatsChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats change,\\n    bool increase,\\n    address caller\\n  );\\n  event BonusAttributesChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    bool add,\\n    bool temporally,\\n    address caller\\n  );\\n  event TemporallyAttributesCleared(address heroToken, uint heroTokenId, address caller);\\n  event NewHeroInited(address heroToken, uint heroTokenId, IStatController.ChangeableStats stats);\\n  event LevelUp(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes change\\n  );\\n  event ConsumableUsed(address heroToken, uint heroTokenId, address item);\\n  event RemoveConsumableUsage(address heroToken, uint heroTokenId, address item);\\n  event HeroCustomDataChanged(address token, uint tokenId, bytes32 index, uint value);\\n  event GlobalCustomDataChanged(bytes32 index, uint value);\\n  //endregion ------------------ StatController\\n\\n  //region ------------------ DungeonFactoryController\\n  event DungeonLaunched(\\n    uint16 dungeonLogicNum,\\n    uint64 dungeonId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken,\\n    uint treasuryAmount\\n  );\\n\\n  event BossCompleted(uint32 objectId, uint biome, address hero, uint heroId);\\n  event FreeDungeonAdded(uint8 biome, uint64 dungeonId);\\n\\n  event ObjectOpened(uint64 dungId, address hero, uint id, uint32 objId, uint iteration, uint currentStage);\\n  event Clear(uint64 dungId);\\n\\n  event DungeonLogicRegistered(uint16 dungLogicId, IDungeonFactory.DungeonGenerateInfo info);\\n  event DungeonLogicRemoved(uint16 dungLogicId);\\n  event DungeonSpecificLogicRegistered(uint16 dungLogicId, uint biome, uint heroCls);\\n  event DungeonSpecificLogicRemoved(uint16 dungLogicId, uint heroLvl, uint heroCls);\\n  event DungeonRegistered(uint16 dungLogicId, uint64 dungeonId);\\n  event DungeonRemoved(uint16 dungLogicId, uint64 dungeonId);\\n  event MinLevelForTreasuryChanged(address token, uint level);\\n\\n  event ObjectAction(\\n    uint64 dungId,\\n    IGOC.ActionResult result,\\n    uint currentStage,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint newStage\\n  );\\n  /// @notice On add the item to the dungeon\\n  event AddTreasuryItem(uint64 dungId, address itemAdr, uint itemId);\\n  event AddTreasuryToken(uint64 dungId, address token, uint amount);\\n  event ClaimToken(uint64 dungId, address token, uint amount);\\n  event ClaimItem(uint64 dungId, address token, uint id);\\n\\n  event Entered(uint64 dungId, address hero, uint id);\\n  event DungeonCompleted(uint16 dungLogicNum, uint64 dungId, address hero, uint heroId);\\n  event Exit(uint64 dungId, bool claim);\\n  event FreeDungeonRemoved(uint8 biome, uint64 dungeonId);\\n  event HeroCurrentDungeonChanged(address hero, uint heroId, uint64 dungeonId);\\n  //endregion ------------------ DungeonFactoryController\\n\\n  //region ------------------ GameObjectController\\n  event EventRegistered(uint32 objectId, IGOC.EventRegInfo eventRegInfo);\\n  event StoryRegistered(uint32 objectId, uint16 storyId);\\n  event MonsterRegistered(uint32 objectId, IGOC.MonsterGenInfo monsterGenInfo);\\n  event ObjectRemoved(uint32 objectId);\\n  event ObjectResultEvent(\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    IGOC.ObjectType objectType,\\n    address hero,\\n    uint heroId,\\n    uint8 stageId,\\n    uint iteration,\\n    bytes data,\\n    IGOC.ActionResult result,\\n    uint salt\\n  );\\n  //endregion ------------------ GameObjectController\\n\\n  //region ------------------ StoryController\\n  event SetBurnItemsMeta(uint storyId, IStoryController.AnswerBurnRandomItemMeta meta);\\n  event SetNextObjRewriteMeta(uint storyId, IStoryController.NextObjRewriteMeta meta);\\n  event SetAnswersMeta(uint storyId, uint16[] answerPageIds, uint8[] answerHeroClasses, uint16[] answerIds);\\n  event SetAnswerNextPageMeta(uint storyId, IStoryController.AnswerNextPageMeta meta);\\n  event SetAnswerAttributeRequirements(uint storyId, IStoryController.AnswerAttributeRequirementsMeta meta);\\n  event SetAnswerItemRequirements(uint storyId, IStoryController.AnswerItemRequirementsMeta meta);\\n  event SetAnswerTokenRequirementsMeta(uint storyId, IStoryController.AnswerTokenRequirementsMeta meta);\\n  event SetAnswerAttributes(uint storyId, IStoryController.AnswerAttributesMeta meta);\\n  event SetAnswerHeroCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetAnswerGlobalCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetSuccessInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetFailInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetCustomDataResult(uint storyId, IStoryController.AnswerCustomDataResultMeta meta, IStoryController.CustomDataResult _type);\\n  event StoryCustomDataRequirements(uint storyId, bytes32 requiredCustomDataIndex, uint requiredCustomDataMinValue, uint requiredCustomDataMaxValue, bool requiredCustomDataIsHero);\\n  event StoryRequiredLevel(uint storyId, uint requiredLevel);\\n  event StoryFinalized(uint32 objectId, uint storyId);\\n  event StoryRemoved(uint32 objectId, uint storyId);\\n\\n  event ItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  /// @notice Durability of the item was reduced to 0\\n  event ItemBroken(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n\\n  event NotEquippedItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event StoryChangeAttributes(\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    uint stageId,\\n    uint iteration,\\n    int32[] attributes\\n  );\\n  //endregion ------------------ StoryController\\n\\n  //region ------------------------ HeroController\\n  event HeroTokensVaultSet(address value);\\n  event HeroRegistered(address hero, uint8 heroClass, address payToken, uint payAmount);\\n  event HeroCreated(address hero, uint heroId, string name, address owner, string refCode);\\n  event BiomeChanged(address hero, uint heroId, uint8 biome);\\n  event LevelUp(address hero, uint heroId, address owner, IStatController.CoreAttributes change);\\n  event ReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event ReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event Killed(address hero, uint heroId, address killer, bytes32[] dropItems, uint dropTokenAmount);\\n  //endregion ------------------------ HeroController\\n\\n  //region ------------------------ FightLib\\n  event FightResultProcessed(\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    IFightCalculator.FightCall callData,\\n    uint iteration\\n  );\\n  //endregion ------------------------ FightLib\\n\\n  //region ------------------------ Oracle\\n  event Random(uint number, uint max);\\n  //endregion ------------------------ Oracle\\n\\n  //region ------------------------ Controller\\n  event OfferGovernance(address newGov);\\n  event GovernanceAccepted(address gov);\\n  event StatControllerChanged(address value);\\n  event StoryControllerChanged(address value);\\n  event GameObjectControllerChanged(address value);\\n  event ReinforcementControllerChanged(address value);\\n  event OracleChanged(address value);\\n  event TreasuryChanged(address value);\\n  event ItemControllerChanged(address value);\\n  event HeroControllerChanged(address value);\\n  event GameTokenChanged(address value);\\n  event DungeonFactoryChanged(address value);\\n  event ProxyUpdated(address proxy, address logic);\\n  event Claimed(address token, uint amount);\\n  event TokenStatusChanged(address token, bool status);\\n  event UserControllerChanged(address value);\\n  event GuildControllerChanged(address value);\\n  //endregion ------------------------ Controller\\n\\n  //region ------------------------ HeroTokensVault\\n  event Process(address token, uint amount, address from, uint toBurn, uint toTreasury, uint toGov);\\n  //endregion ------------------------ HeroTokensVault\\n\\n  //region ------------------------ ReinforcementController\\n  event HeroStaked(address heroToken, uint heroId, uint biome, uint score);\\n  event HeroWithdraw(address heroToken, uint heroId);\\n  event HeroAsk(address heroToken, uint heroId);\\n  event TokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint totalAmount);\\n  event NftRewardRegistered(address heroToken, uint heroId, address token, uint id);\\n  event ToHelperRatioChanged(uint value);\\n  event ClaimedToken(address heroToken, uint heroId, address token, uint amount, address recipient);\\n  event ClaimedItem(address heroToken, uint heroId, address item, uint itemId, address recipient);\\n  event MinLevelChanged(uint8 value);\\n  event MinLifeChancesChanged(uint value);\\n  //endregion ------------------------ ReinforcementController\\n\\n  //region ------------------------ Treasury\\n  event AssetsSentToDungeon(address dungeon, address token, uint amount);\\n  //endregion ------------------------ Treasury\\n\\n  //region ------------------------ EventLib\\n  event EventResult(uint64 dungeonId, address heroToken, uint heroTokenId, uint8 stageId, IStatController.ActionInternalInfo gen, uint iteration);\\n  //endregion ------------------------ EventLib\\n\\n  //region ------------------------ ItemStatsLib\\n  event ItemRegistered(address item, IItemController.RegisterItemParams info);\\n  event ItemRemoved(address item);\\n  event NewItemMinted(address item, uint itemId, IItemController.MintInfo info);\\n  event Equipped(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot);\\n  event TakenOff(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot, address destination);\\n  event ItemRepaired(address item, uint itemId, uint consumedItemId, uint16 baseDurability);\\n  event FailedToRepairItem(address item, uint itemId, uint consumedItemId, uint16 itemDurability);\\n  event Augmented(address item, uint itemId, uint consumedItemId, uint8 augLevel, IItemController.AugmentInfo info);\\n  event NotAugmented(address item, uint itemId, uint consumedItemId, uint8 augLevel);\\n  event ReduceDurability(address item, uint itemId, uint newDurability);\\n  event Used(address item, uint tokenId, address heroToken, uint heroTokenId);\\n  event Destroyed(address item, uint itemId);\\n  //endregion ------------------------ ItemStatsLib\\n\\n  //region ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n  event ChangePauseStatus(bool value);\\n  event MinterChanged(address value);\\n\\n  event UniqueUriChanged(uint id, string uri);\\n  event BaseUriChanged(string uri);\\n\\n  event HeroMinted(uint heroId);\\n  event HeroBurned(uint heroId);\\n  event HeroUriByStatusChanged(string uri, uint statusLvl);\\n\\n  event ItemMinted(uint tokenId);\\n  event ItemBurned(uint tokenId);\\n  event UriByRarityChanged(string uri, uint rarity);\\n  event SponsoredHeroCreated(address msgSender, address heroAddress, uint heroId, string heroName);\\n  //endregion ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n\\n  //region ------------------------ Guild\\n  event SetUserName(address user, string name);\\n  event LootBoxOpened(address user, uint lootBoxKind, address[] itemTokens, uint[] itemTokenIds);\\n  event LootBoxConfigChanged(uint lootBoxKind, address[] mintItems, uint32[] mintItemsChances, uint maxDropItems);\\n  event SetFeeRenaming(uint feeRenaming);\\n  event ActivityCompleted(address user, bool daily, bool weekly);\\n\\n  event GuildCreated(address owner, uint guildId, string name, string urlLogo);\\n  event AddToGuild(uint guildId, address newUser);\\n  event ChangeGuildRights(uint guildId, address user, uint rights);\\n  event RemoveFromGuild(uint guildId, address user);\\n  event GuildDeleted(uint guildId);\\n  event GuildLevelUp(uint guildId, uint8 newLevel);\\n  event GuildRename(uint guildId, string newName);\\n  event GuildLogoChanged(uint guildId, string newLogoUrl);\\n  event SetGuildRelation(uint guildId1, uint guildId2, bool peace);\\n  event TransferFromGuildBank(address user, address token, uint amount, address recipient);\\n  event TransferNftFromGuildBank(address user, address[] nfts, uint[] tokenIds, address recipient);\\n  event GuildBankDeployed(uint guildId, address guildBank);\\n\\n  event UserTokensVaultSet(address value);\\n  //endregion ------------------------ Guild\\n}\\n\",\"keccak256\":\"0xc56437df0734dccf5677bda430a487aff34eaada52031f3c86ddcd115a06a3ae\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IControllable {\\n\\n  function VERSION() external pure returns (string memory);\\n\\n  function revision() external view returns (uint);\\n\\n  function previousImplementation() external view returns (address);\\n\\n  function isController(address contract_) external view returns (bool);\\n\\n  function isGovernance(address contract_) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0x296b634c46b5d178b2408523fcf569ed370e20a719b7b3f2183b278631b94f65\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IController {\\n\\n  function governance() external view returns (address);\\n\\n  function statController() external view returns (address);\\n\\n  function storyController() external view returns (address);\\n\\n  function gameObjectController() external view returns (address);\\n\\n  function reinforcementController() external view returns (address);\\n\\n  function oracle() external view returns (address);\\n\\n  function treasury() external view returns (address);\\n\\n  function itemController() external view returns (address);\\n\\n  function heroController() external view returns (address);\\n\\n  function dungeonFactory() external view returns (address);\\n\\n  function gameToken() external view returns (address);\\n\\n  function validTreasuryTokens(address token) external view returns (bool);\\n\\n  function isDeployer(address adr) external view returns (bool);\\n\\n  function onPause() external view returns (bool);\\n\\n  function userController() external view returns (address);\\n\\n  function guildController() external view returns (address);\\n}\\n\",\"keccak256\":\"0xae4746df4915fbe35e8f0a582097b4c8cc3ee4da249d403c89a990648177b3ee\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDungeonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IDungeonFactory {\\n\\n  /// @custom:storage-location erc7201:dungeon.factory.main\\n  struct MainState {\\n    /// @dev biome => dungeonLaunchedId\\n    mapping(uint => EnumerableSet.UintSet) freeDungeons;\\n    /// @dev hero + heroId + biome (packMapObject) -> completed\\n    mapping(bytes32 => bool) bossCompleted;\\n    /// @dev hero + heroId + dungNum (packDungeonKey) -> completed\\n    mapping(bytes32 => bool) specificDungeonCompleted;\\n    /// @notice Max biome completed by the hero\\n    /// @dev hero + heroId (nftPacked) -> max biome completed\\n    mapping(bytes32 => uint8) maxBiomeCompleted;\\n    /// @notice which dungeon the hero is currently in\\n    /// @dev hero+id => current DungeonId\\n    mapping(bytes32 => uint64) heroCurrentDungeon;\\n\\n    // ---\\n\\n    /// @notice Specific dungeon for the given pair of hero level + hero class\\n    ///         ALl specific dungeons are listed also in allSpecificDungeons\\n    /// @dev packUint8Array(specReqBiome, specReqHeroClass) => dungNum\\n    mapping(bytes32 => uint16) dungeonSpecific;\\n    /// @dev contains all specific dungNum for easy management\\n    EnumerableSet.UintSet allSpecificDungeons;\\n    /// @dev biome => dungNum\\n    mapping(uint8 => EnumerableSet.UintSet) dungeonsLogicByBiome;\\n\\n    // ---\\n\\n    /// @dev max available biome. auto-increment with new dung deploy\\n    uint8 maxBiome;\\n\\n    /// @notice Address of treasure token => min hero level required\\n    /// @dev manual threshold for treasury\\n    mapping(address => uint) minLevelForTreasury;\\n\\n    /// @notice Contains arrays for SKILL_1, SKILL_2, SKILL_3 with 0 or 1\\n    /// i.e. [0, 1, 0] means that durability of SKILL_2 should be reduced\\n    /// @dev hero + heroId => uint8[] array where idx = slotNum\\n    mapping(bytes32 => bytes32) skillSlotsForDurabilityReduction;\\n\\n    /// @notice Counter of dungeons, it's incremented on launch of a new dungeon\\n    uint64 dungeonCounter;\\n\\n    /// @dev dungNum = init attributes\\n    mapping(uint16 => DungeonAttributes) dungeonAttributes;\\n    /// @dev dungeonId => status\\n    mapping(uint64 => DungeonStatus) dungeonStatuses;\\n  }\\n\\n  struct ObjectGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    /// @dev uint8 types, packed using PackingLib.packUint8Array\\n    bytes32[] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    /// @dev uint64 chances\\n    uint32[][] objChancesByStages;\\n  }\\n\\n  struct DungeonGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    uint8[][] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    uint32[][] objChancesByStages;\\n\\n    uint32[] uniqObjects;\\n\\n    uint8 minLevel;\\n    uint8 maxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n  }\\n\\n  /// @notice Attributes of the given dungeon logic\\n  struct DungeonAttributes {\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    uint8 stages;\\n    uint8 biome;\\n\\n    /// @notice Default list of objects that should be passed in the dungeon\\n    uint32[] uniqObjects;\\n\\n    /// @dev min+max (packUint8Array)\\n    bytes32 minMaxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    /// @notice Packed DungeonGenerateInfo.requiredCustomData: MinValue, MaxValue, IsHero\\n    /// @dev min+max+isHero(packStoryCustomDataRequirements)\\n    bytes32[] requiredCustomDataValue;\\n\\n    ObjectGenerateInfo info;\\n  }\\n\\n  /// @notice Current status of the given dungeon\\n  struct DungeonStatus {\\n    uint64 dungeonId;\\n    /// @notice Dungeon logic id\\n    uint16 dungNum;\\n\\n    /// @notice True if the dungeon is completed by the hero\\n    bool isCompleted;\\n\\n    /// @notice Hero in the dungeon or 0\\n    address heroToken;\\n    uint heroTokenId;\\n    /// @notice Current object that should be passed by the hero. 0 - new object is not opened\\n    uint32 currentObject;\\n    /// @notice Current stage in the dungeon that should be passed by the hero.\\n    uint8 currentStage;\\n\\n    EnumerableMap.AddressToUintMap treasuryTokens;\\n    /// @notice All items that were minted on result of made actions\\n    bytes32[] treasuryItems;\\n\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    /// This value can be bigger than length of uniqObjects\\n    uint8 stages;\\n    /// @notice List of objects to be passed in the stage. The list can be dynamically changed during passing the stages\\n    uint32[] uniqObjects;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n\\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external returns (uint64 dungeonId);\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8);\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64);\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result);\\n\\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external;\\n\\n}\\n\",\"keccak256\":\"0x2f24028d35a06e44dc9bd096d8a1807cfa64518ebd73692a1cc479736814b741\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbca9de297214bb9c30daefda5ecaedd0af2c3e8e0440403ad543fb33528c5ef8\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xa365c0e17de806f6262765ef6236512674ac8563a6ee3436e81cec7b1d87468e\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  /**\\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n   */\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n   */\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of tokens in ``owner``'s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\n   *\\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n   * The approval is cleared when the token is transferred.\\n   *\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n   *\\n   * Requirements:\\n   *\\n   * - The caller must own the token or be an approved operator.\\n   * - `tokenId` must exist.\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address to, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Returns the account approved for `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  /**\\n   * @dev Approve or remove `operator` as an operator for the caller.\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n   *\\n   * Requirements:\\n   *\\n   * - The `operator` cannot be the caller.\\n   *\\n   * Emits an {ApprovalForAll} event.\\n   */\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  /**\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n   *\\n   * See {setApprovalForAll}\\n   */\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0xe7d89e4cdfc41317d90bf469428b6ef17cec6eb6fccab0080bdf0378129d2708\",\"license\":\"MIT\"},\"contracts/interfaces/IFightCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface IFightCalculator {\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    MELEE, // 1\\n    MAGIC, // 2\\n    SLOT_3,\\n    SLOT_4,\\n    SLOT_5,\\n    SLOT_6,\\n    SLOT_7,\\n    SLOT_8,\\n    SLOT_9,\\n    SLOT_10\\n  }\\n\\n  /// @notice Attacker info: suitable both for hero and monsters\\n  struct AttackInfo {\\n    /// @notice Type of the attack\\n    /// by default, if attack token presents, it's magic attack and not-magic otherwise\\n    /// but this logic can become more complicated after introducing new attack types\\n    AttackType attackType;\\n    /// @notice NFT selected by hero for attack, it should be equip on.\\n    /// If attacker is a monster, this is a special case (stub NFT with zero ID is used)\\n    address attackToken;\\n    uint attackTokenId;\\n    address[] skillTokens;\\n    uint[] skillTokenIds;\\n  }\\n\\n  struct FighterInfo {\\n    int32[] fighterAttributes;\\n    IStatController.ChangeableStats fighterStats;\\n    AttackType attackType;\\n    address attackToken;\\n    uint attackTokenId;\\n    uint race;\\n  }\\n\\n  struct Statuses {\\n    bool stun;\\n    bool burn;\\n    bool freeze;\\n    bool confuse;\\n    bool curse;\\n    bool poison;\\n    bool gotCriticalHit;\\n    bool missed;\\n    bool hitBlocked;\\n  }\\n\\n  struct FightResult {\\n    int32 healthA;\\n    int32 healthB;\\n    int32 manaConsumedA;\\n    int32 manaConsumedB;\\n  }\\n\\n  struct FightCall {\\n    FighterInfo fighterA;\\n    FighterInfo fighterB;\\n    uint64 dungeonId;\\n    uint32 objectId;\\n    address heroAdr;\\n    uint heroId;\\n    uint8 stageId;\\n    uint iteration;\\n    uint8 turn;\\n  }\\n\\n  struct SkillSlots {\\n    bool slot1;\\n    bool slot2;\\n    bool slot3;\\n  }\\n\\n  //region ------------------------ FightLib-internal (FightInfoInternal is required by IApplicationEvents..)\\n  struct FightInfoInternal {\\n    Fighter fighterA;\\n    Fighter fighterB;\\n  }\\n\\n  struct Fighter {\\n    IFightCalculator.FighterInfo info;\\n    IItemController.AttackInfo magicAttack;\\n    int32 health;\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 damagePoison;\\n    int32 damageReflect;\\n    IFightCalculator.Statuses statuses;\\n  }\\n  //endregion ------------------------ FightLib-internal\\n\\n  function fight(FightCall memory callData) external returns (FightResult memory);\\n}\\n\",\"keccak256\":\"0xdf9ba809ea21a35a24eed12bf80e53452b0d772623d59211a35498b518eb604b\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGOC.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\n\\ninterface IGOC {\\n\\n  enum ObjectType {\\n    UNKNOWN, // 0\\n    EVENT, // 1\\n    MONSTER, // 2\\n    STORY, // 3\\n    END_SLOT\\n  }\\n\\n  enum ObjectSubType {\\n    UNKNOWN_0, // 0\\n    ENEMY_NPC_1, // 1\\n    ENEMY_NPC_SUPER_RARE_2, // 2\\n    BOSS_3, // 3\\n    SHRINE_4, // 4\\n    CHEST_5, // 5\\n    STORY_6, // 6\\n    STORY_UNIQUE_7, // 7\\n    SHRINE_UNIQUE_8, // 8\\n    CHEST_UNIQUE_9, // 9\\n    ENEMY_NPC_UNIQUE_10, // 10\\n    STORY_ON_ROAD_11, // 11\\n    STORY_UNDERGROUND_12, // 12\\n    STORY_NIGHT_CAMP_13, // 13\\n    STORY_MOUNTAIN_14, // 14\\n    STORY_WATER_15, // 15\\n    STORY_CASTLE_16, // 16\\n    STORY_HELL_17, // 17\\n    STORY_SPACE_18, // 18\\n    STORY_WOOD_19, // 19\\n    STORY_CATACOMBS_20, // 20\\n    STORY_BAD_HOUSE_21, // 21\\n    STORY_GOOD_TOWN_22, // 22\\n    STORY_BAD_TOWN_23, // 23\\n    STORY_BANDIT_CAMP_24, // 24\\n    STORY_BEAST_LAIR_25, // 25\\n    STORY_PRISON_26, // 26\\n    STORY_SWAMP_27, // 27\\n    STORY_INSIDE_28, // 28\\n    STORY_OUTSIDE_29, // 29\\n    STORY_INSIDE_RARE_30,\\n    STORY_OUTSIDE_RARE_31,\\n    ENEMY_NPC_INSIDE_32,\\n    ENEMY_NPC_INSIDE_RARE_33,\\n    ENEMY_NPC_OUTSIDE_34,\\n    ENEMY_NPC_OUTSIDE_RARE_35,\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:game.object.controller.main\\n  struct MainState {\\n\\n    /// @dev objId = biome(00) type(00) id(0000) => biome(uint8) + objType(uint8)\\n    /// Id is id of the event, story or monster.\\n    mapping(uint32 => bytes32) objectMeta;\\n\\n    /// @dev biome(uint8) + objType(uint8) => set of object id\\n    mapping(bytes32 => EnumerableSet.UintSet) objectIds;\\n\\n    /// @dev heroAdr180 + heroId64 + cType8 + biome8 => set of already played objects. Should be cleared periodically\\n    mapping(bytes32 => EnumerableSet.UintSet) playedObjects;\\n\\n    /// @dev HeroAdr(160) + heroId(uint64) + objId(uint32) => iteration count. It needs for properly emit events for every new entrance.\\n    mapping(bytes32 => uint) iterations;\\n\\n    /// @dev objId(uint32) => EventInfo\\n    mapping(uint32 => EventInfo) eventInfos;\\n\\n    /// @dev objId(uint32) => storyId\\n    mapping(uint32 => uint16) storyIds;\\n\\n    /// @dev objId(uint32) => MonsterInfo\\n    mapping(uint32 => MonsterInfo) monsterInfos;\\n\\n    /// @dev hero+id => last fight action timestamp\\n    mapping(bytes32 => uint) lastHeroFightTs;\\n\\n    /// @dev delay for user actions in fight (suppose to prevent bot actions)\\n    uint fightDelay;\\n  }\\n\\n  struct ActionResult {\\n    bool kill;\\n    bool completed;\\n    address heroToken;\\n    address[] mintItems;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n    uint32 objectId;\\n    uint32 experience;\\n    uint heroTokenId;\\n    uint iteration;\\n    uint32[] rewriteNextObject;\\n  }\\n\\n  struct EventInfo {\\n    /// @dev chance to use good or bad attributes/stats\\n    uint32 goodChance;\\n\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] goodAttributes;\\n    bytes32[] badAttributes;\\n\\n    /// @dev experience(uint32) + heal(int32) + manaRegen(int32) + lifeChancesRecovered(int32) + damage(int32) + manaConsume(int32) packStatsChange\\n    bytes32 statsChange;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n  }\\n\\n  struct MonsterInfo {\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] attributes;\\n    /// @dev level(uint8) + race(uint8) + experience(uint32) + maxDropItems(uint8) packMonsterStats\\n    bytes32 stats;\\n    /// @dev attackToken(160) + attackTokenId(uint64) + attackType(uint8) packAttackInfo\\n    bytes32 attackInfo;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n\\n    /// @dev heroAdr(160) + heroId(uint64) => iteration => GeneratedMonster packed\\n    mapping(bytes32 => mapping(uint => bytes32)) _generatedMonsters;\\n  }\\n\\n  struct MultiplierInfo {\\n    uint8 biome;\\n    uint totalSupply;\\n  }\\n\\n  struct GeneratedMonster {\\n    bool generated;\\n    uint8 turnCounter;\\n    int32 hp;\\n    uint32 amplifier;\\n  }\\n\\n  struct MonsterGenInfo {\\n    uint16 monsterId;\\n    uint8 biome;\\n    ObjectSubType subType;\\n\\n    uint8[] attributeIds;\\n    int32[] attributeValues;\\n\\n    uint8 level;\\n    uint8 race;\\n    uint32 experience;\\n    uint8 maxDropItems;\\n\\n    address attackToken;\\n    uint64 attackTokenId;\\n    uint8 attackType;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct ActionContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    uint8 biome;\\n    uint8 objectSubType;\\n    uint8 stageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint heroTokenId;\\n    uint salt;\\n    uint iteration;\\n    bytes data;\\n  }\\n\\n  struct EventRegInfo {\\n    uint8 biome;\\n    uint16 eventId;\\n    ObjectSubType subType;\\n\\n    uint32 goodChance;\\n\\n    AttributeGenerateInfo goodAttributes;\\n    AttributeGenerateInfo badAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct AttributeGenerateInfo {\\n    uint8[] ids;\\n    int32[] values;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev represent object registration if non zero values\\n  function getObjectMeta(uint32 objectId) external view returns (uint8 biome, uint8 objectSubType);\\n\\n  function isBattleObject(uint32 objectId) external view returns (bool);\\n\\n  function getRandomObject(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biomeLevel,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external returns (uint32 objectId);\\n\\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint iteration);\\n\\n  function action(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) external returns (ActionResult memory);\\n\\n}\\n\",\"keccak256\":\"0x6493b091bb99b51586b94064eea3eb60f5fa921c5a6f7e061b3c491a73b89a9e\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGuildBank.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\n\\ninterface IGuildBank {\\n  function transfer(address token, address recipient, uint amount) external;\\n\\n  function approve(address token, address spender, uint256 amount) external returns (bool);\\n\\n  function transferNft(address to, address nft, uint256 tokenId) external;\\n\\n  function transferNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external;\\n\\n  function approveNft(address to, address nft, uint256 tokenId) external;\\n\\n  function approveNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external;\\n}\",\"keccak256\":\"0x89143aa04e65d7668b2668a36825c7b1d5203a34dbe6a6ececaa71b5d67a2895\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGuildController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IGuildController {\\n  enum GuildRightBits {\\n    ADMIN_0,\\n    RENAME_1,\\n    CHANGE_LOGO_2,\\n    CHANGE_SHELTER_3,\\n    ADD_MEMBER_4,\\n    REMOVE_MEMBER_5,\\n    BANK_TOKENS_OPERATION_6,\\n    CHANGE_ROLES_7,\\n    LEVEL_UP_8,\\n    SET_RELATION_KIND_9,\\n    BANK_ITEMS_OPERATION_10,\\n    SET_TO_HELPER_RATIO_11\\n  }\\n\\n  enum GuildsParams {\\n    NONE_0,\\n    COUNTER_GUILD_IDS_1,\\n    BASE_FEE_2\\n  }\\n\\n  /// @custom:storage-location erc7201:guild.controller.main\\n  struct MainState {\\n    /// @notice Mapping to store various guilds params (with global values for all guilds)\\n    mapping(GuildsParams param => uint value) guildsParam;\\n\\n    /// @notice guildId => address of instance of GuildBank contract\\n    mapping(uint guildId => address) guildBanks;\\n\\n    /// @notice guild id => guild data (owner, name, logo, etc)\\n    mapping(uint guildId => GuildData) guildData;\\n\\n    /// @notice name => guild id\\n    mapping(string guildName => uint guildId) nameToGuild;\\n\\n    /// @notice EOA => guild id, EOA can be a member of a single guild only\\n    mapping(address member => uint guildId) memberToGuild;\\n\\n    /// @notice List of participants of guilds\\n    /// @dev Allowed number of members is 20 + 5 * guildLevel\\n    mapping(uint guildId => EnumerableSet.AddressSet listEoa) members;\\n\\n    /// @notice Rights of the member in the guild, mask of GuildRightBits\\n    mapping(address member => uint maskRights) rights;\\n\\n    /// @notice _getGuildsPairKey(guild1, guild2) => status (false - war, true - peace)\\n    mapping(bytes32 guildsPairKey => bool) relationsPeaceful;\\n\\n//    // ---------------------------- Domination\\n//\\n//    /// @notice The guild that is currently dominated at the given biome\\n//    mapping(uint8 biome => uint guildId) biomeOwner;\\n//\\n//    /// @notice Each user can participate in single PvP battle per week only\\n//    mapping(address user => mapping(uint epochWeek => uint countBattles)) countPvP;\\n//\\n//    /// @notice Weekly request of the guild to dominate at the given biome starting from the next week\\n//    mapping(uint guildId => mapping(uint epochWeek => DominationRequest)) biomeRequest;\\n//\\n//    /// @notice List of guilds that has domination request for the given biome at the given week.\\n//    mapping(uint8 biome => mapping(uint epochWeek => EnumerableSet.UintSet guildIds)) dominationParticipants;\\n//\\n//    /// @notice Hom many times the given guild had domination at the given biome (to calculate penalty points)\\n//    mapping(uint guildId => mapping(uint8 biome => uint dominationCounter)) dominationCounter;\\n\\n\\n//    // ---------------------------- Shelters\\n//\\n//    /// @notice Registered shelters\\n//    mapping(uint shelterId => ShelterData) shelterData;\\n//\\n//    /// @notice Shelters belong to a specific guild (not the player)\\n//    /// Shelters can be free (don't belong to any guild)\\n//    mapping(uint shelterId => uint guildId) shelterToGuild;\\n//\\n//    /// @notice Each guild can own 0 or 1 shelter\\n//    mapping(uint guildId => uint shelterId) guildToShelter;\\n//\\n//    /// @notice Owner of the shelter is able to sell the shelter to an other guild\\n//    /// The owner saves here bid data (buyer id and amount of the selling)\\n//    /// After that the buyer is able to buy the guild\\n//    mapping(uint shelterId => ShelterBid) shelterBid;\\n\\n    // ---------------------------- Guild reinforcement\\n\\n  }\\n\\n  struct GuildData {\\n    /// @notice Not empty unique guild name\\n    string guildName;\\n\\n    /// @notice URL of guild logo (empty is allowed)\\n    string urlLogo;\\n\\n    /// @notice Creator (owner) of the guild\\n    address owner;\\n\\n    /// @notice Guild level [1...10]\\n    uint8 guildLevel;\\n\\n    /// @notice Percent of guild reinforcement fee Value in range [_FEE_MIN ... _TO_HELPER_RATIO_MAX], i.e. [10..50]\\n    uint8 toHelperRatio;\\n\\n    /// @notice Global guild points counter, it's incremented on each victory in php-fight.\\n    /// @dev Assume here, that uint64 is enough to store any sums of scores\\n    uint64 pvpCounter;\\n  }\\n\\n  /// @notice Request of the guild to dominate at the given biome\\n  struct DominationRequest {\\n    /// @notice Biome where the guild is going to dominate\\n    uint8 biome;\\n    /// @notice Number of points scored\\n    uint32 points;\\n  }\\n\\n  struct ShelterData {\\n    uint8 shelterLevel;\\n    string shelterName;\\n\\n    /// @notice List of items allowed to be purchased inside the shelter\\n    address[] itemTokens;\\n  }\\n\\n  struct ShelterBid {\\n    uint buyerGuildId;\\n    uint amount;\\n  }\\n\\n}\",\"keccak256\":\"0x4d57c708721578a1d30b92b7a481b0f80420eb89b877225e95161e8d943ea480\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IHeroController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IHeroController {\\n\\n  /// @custom:storage-location erc7201:hero.controller.main\\n  struct MainState {\\n\\n    /// @dev A central place for all hero tokens\\n    address heroTokensVault;\\n\\n    /// @dev heroAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) payToken;\\n\\n    /// @dev heroAdr => heroCls8\\n    mapping(address => uint8) heroClass;\\n\\n    // ---\\n\\n    /// @dev hero+id => individual hero name\\n    mapping(bytes32 => string) heroName;\\n\\n    /// @dev name => hero+id, needs for checking uniq names\\n    mapping(string => bytes32) nameToHero;\\n\\n    // ---\\n\\n    /// @dev hero+id => biome\\n    mapping(bytes32 => uint8) heroBiome;\\n\\n    /// @dev hero+id => rein hero+id\\n    mapping(bytes32 => bytes32) reinforcementHero;\\n\\n    /// @dev hero+id => rein packed attributes\\n    mapping(bytes32 => bytes32[]) reinforcementHeroAttributes;\\n  }\\n\\n  function heroClass(address hero) external view returns (uint8);\\n\\n  function heroBiome(address hero, uint heroId) external view returns (uint8);\\n\\n  function payTokenInfo(address hero) external view returns (address token, uint amount);\\n\\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (address helperHeroToken, uint helperHeroId);\\n\\n  function score(address hero, uint heroId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool);\\n\\n  function heroTokensVault() external view returns (address);\\n\\n  // ---\\n\\n  function create(address hero, string memory heroName_, bool enter) external returns (uint);\\n\\n  function kill(address hero, uint heroId) external returns (bytes32[] memory dropItems);\\n\\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId);\\n\\n}\\n\",\"keccak256\":\"0x670ab48074f47c954a571035fb9abf04b193d524768b779047838e0990d39ef1\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IHeroTokensVault.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IHeroTokensVault {\\n\\n  function process(\\n    address token,\\n    uint amount,\\n    address from\\n  ) external;\\n\\n}\\n\",\"keccak256\":\"0x8e2f21294323d10964ca5aa923deaa71c143b875e2c4129c6990fadacb67bb2c\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IItemController {\\n\\n  /// @custom:storage-location erc7201:item.controlbler.main\\n  struct MainState {\\n\\n    ////////////////// GENERATE //////////////////\\n\\n    EnumerableSet.AddressSet items;\\n\\n    /// @dev itemAdr => itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n    mapping(address => bytes32) itemMeta;\\n\\n    /// @dev itemAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) augmentInfo;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoAttributes;\\n\\n    // --- consumable ---\\n\\n    /// @dev itemAdr => ids+values (toBytes32ArrayWithIds)\\n    mapping(address => bytes32[]) _itemConsumableAttributes;\\n\\n    /// @dev itemAdr => IStatController.ChangeableStats packed int32[]\\n    mapping(address => bytes32) itemConsumableStats;\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoCasterAttributes;\\n\\n    /// @dev itemAdr => id8 + minDmg(int32) + maxDmg(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(address => bytes32) generateInfoAttack;\\n\\n    ////////////////// ITEMS INFO //////////////////\\n\\n    /// @dev itemAdr+id => itemRarity8 + augmentationLevel8 + itemDurability16\\n    mapping(bytes32 => bytes32) itemInfo;\\n\\n    /// @dev itemAdr+id => heroAdr+id\\n    mapping(bytes32 => bytes32) equippedOn;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemAttributes;\\n\\n    // --- consumable ---\\n\\n    // consumable stats unchangeable, get them by address\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemCasterAttributes;\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr+Id => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(bytes32 => bytes32) _itemAttackInfo;\\n\\n    ////////////////// Additional generate info //////////////////\\n\\n    /// @notice (itemAdr) => Bitmask of ConsumableActionBits\\n    mapping(address => uint) _consumableActionMask;\\n\\n\\n    /// --------------------------------- SIP-003: Item fragility\\n    /// @notice itemAdr + id => item fragility counter that displays the chance of an unsuccessful repair\\n    mapping(bytes32 packedItem => uint fragility) itemFragility;\\n  }\\n\\n  struct RegisterItemParams {\\n    ItemMeta itemMeta;\\n    address augmentToken;\\n    uint augmentAmount;\\n    ItemGenerateInfo commonAttributes;\\n\\n    IGOC.AttributeGenerateInfo consumableAttributes;\\n    IStatController.ChangeableStats consumableStats;\\n\\n    ItemGenerateInfo casterAttributes;\\n    ItemGenerateInfo targetAttributes;\\n\\n    AttackInfo genAttackInfo;\\n    /// @notice Bit mask of ConsumableActionBits\\n    uint consumableActionMask;\\n  }\\n\\n  /// @notice Possible actions that can be triggered by using the consumable item\\n  enum ConsumableActionBits {\\n    CLEAR_TEMPORARY_ATTRIBUTES_0,\\n    EXIT_FROM_DUNGEON_1,\\n    USE_GUILD_REINFORCEMENT_2,\\n    RECREATION_IN_GUILD_HOUSE_3\\n  }\\n\\n  struct ItemGenerateInfo {\\n    /// @notice Attribute ids\\n    uint8[] ids;\\n    /// @notice Min value of the attribute, != 0\\n    int32[] mins;\\n    /// @notice Max value of the attribute, != 0\\n    int32[] maxs;\\n    /// @notice Chance of the selection [0..MAX_CHANCES]\\n    uint32[] chances;\\n  }\\n\\n  struct ItemMeta {\\n    uint8 itemMetaType;\\n    // Level in range 1-99. Reducing durability in low level dungeons. lvl/5+1 = biome\\n    uint8 itemLevel;\\n    IItemController.ItemType itemType;\\n    uint16 baseDurability;\\n    uint8 defaultRarity;\\n    uint32 manaCost;\\n\\n    // it doesn't include positions with 100% chance\\n    uint8 minRandomAttributes;\\n    uint8 maxRandomAttributes;\\n\\n    IStatController.CoreAttributes requirements;\\n  }\\n\\n  enum FeeType {\\n    UNKNOWN,\\n    REPAIR,\\n    AUGMENT,\\n    STORY,\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemRarity {\\n    UNKNOWN, // 0\\n    NORMAL, // 1\\n    MAGIC, // 2\\n    RARE, // 3\\n    SET, // 4\\n    UNIQUE, // 5\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemType {\\n    NO_SLOT, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    RING, // 6\\n    OFF_HAND, // 7\\n    BOOTS, // 8\\n    ONE_HAND, // 9\\n    TWO_HAND, // 10\\n    SKILL, // 11\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemMetaType {\\n    UNKNOWN, // 0\\n    COMMON, // 1\\n    ATTACK, // 2\\n    BUFF, // 3\\n    CONSUMABLE, // 4\\n\\n    END_SLOT\\n  }\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    FIRE, // 1\\n    COLD, // 2\\n    LIGHTNING, // 3\\n    CHAOS, // 4\\n\\n    END_SLOT\\n  }\\n\\n  struct AttackInfo {\\n    AttackType aType;\\n    int32 min;\\n    int32 max;\\n    // if not zero - activate attribute factor for the attribute\\n    IStatController.CoreAttributes attributeFactors;\\n  }\\n\\n  struct ItemInfo {\\n    ItemRarity rarity;\\n    uint8 augmentationLevel;\\n    uint16 durability;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct MintInfo {\\n    IItemController.ItemMeta meta;\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.ItemRarity itemRarity;\\n\\n    IItemController.AttackInfo attackInfo;\\n\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct AugmentInfo {\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.AttackInfo attackInfo;\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function itemMeta(address item) external view returns (ItemMeta memory meta);\\n\\n  function augmentInfo(address item) external view returns (address token, uint amount);\\n\\n  function genAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genCasterAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genTargetAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genAttackInfo(address item) external view returns (AttackInfo memory info);\\n\\n  function itemInfo(address item, uint itemId) external view returns (ItemInfo memory info);\\n\\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId);\\n\\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats);\\n\\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function itemAttackInfo(address item, uint itemId) external view returns (AttackInfo memory info);\\n\\n  function score(address item, uint tokenId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address item, uint tokenId) external view returns (bool);\\n\\n  // ---\\n\\n  function mint(address item, address recipient) external returns (uint itemId);\\n\\n  function reduceDurability(address hero, uint heroId, uint8 biome) external;\\n\\n  function destroy(address item, uint tokenId) external;\\n\\n  function takeOffDirectly(\\n    address item,\\n    uint itemId,\\n    address hero,\\n    uint heroId,\\n    uint8 itemSlot,\\n    address destination,\\n    bool broken\\n  ) external;\\n\\n  /// @notice SIP-003: item fragility counter that displays the chance of an unsuccessful repair.\\n  /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n  function itemFragility(address item, uint itemId) external view returns (uint);\\n\\n  /// @notice SIP-003: The quest mechanic that previously burned the item will increase its fragility by 1%\\n  function incBrokenItemFragility(address item, uint itemId) external;\\n}\\n\",\"keccak256\":\"0x50b0c0da23481b6b88cc7fcc9c70d92e98a680700b634ff7be5843c16cc947aa\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IOracle {\\n\\n  function getRandomNumber(uint max, uint seed) external returns (uint);\\n\\n  function getRandomNumberInRange(uint min, uint max, uint seed) external returns (uint);\\n\\n}\\n\",\"keccak256\":\"0x75a2bed27cbd9be6c76b6f3e941ee5f6f55380f61cd867254a0c766fc3b71976\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IReinforcementController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IReinforcementController {\\n\\n  /// @custom:storage-location erc7201:reinforcement.controller.main\\n  struct MainState {\\n\\n    /// @dev minLvl8 + minLifeChances8\\n    bytes32 config;\\n\\n    /// @dev hero token + hero id => heroInfo(biome8 + score128 + fee8 + stakeTs64)\\n    mapping(bytes32 => bytes32) _stakedHeroes;\\n    /// @dev biome => helperAdr+id\\n    mapping(uint => EnumerableSet.Bytes32Set) _internalIdsByBiomes;\\n    /// @dev biome => score  // The field is deprecated and not updated any more\\n    mapping(uint => uint) maxScore;\\n    /// @dev heroAdr+id => itemAdr+id\\n    mapping(bytes32 => bytes32[]) _heroNftRewards;\\n    /// @dev heroAdr+id => tokenAdr and amount map\\n    mapping(bytes32 => EnumerableMap.AddressToUintMap) _heroTokenRewards;\\n\\n  }\\n\\n  struct HeroInfo {\\n    uint8 biome;\\n    uint score; // stored in 128 but easy to use 256\\n    /// @notice To helper ratio\\n    uint8 fee;\\n    uint64 stakeTs;\\n  }\\n\\n  function toHelperRatio(address heroToken, uint heroId) external view returns (uint);\\n\\n  function isStaked(address heroToken, uint heroId) external view returns (bool);\\n\\n  function askHero(uint biome) external returns (address heroToken, uint heroId, int32[] memory attributes);\\n\\n  function registerTokenReward(address heroToken, uint heroId, address token, uint amount) external;\\n\\n  function registerNftReward(address heroToken, uint heroId, address token, uint tokenId) external;\\n\\n}\\n\",\"keccak256\":\"0xdf6cc5349b5078222f25464e70fbc10e55759d67b37b995c3b7af30d2b1c3dde\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStatController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStatController {\\n\\n  /// @custom:storage-location erc7201:stat.controller.main\\n  struct MainState {\\n    mapping(bytes32 => bytes32[]) heroTotalAttributes;\\n    /// @dev heroAdr+heroId => int32 packed strength, dexterity, vitality, energy\\n    mapping(bytes32 => bytes32) _heroCore;\\n    mapping(bytes32 => bytes32[]) heroBonusAttributes;\\n    mapping(bytes32 => bytes32[]) heroTemporallyAttributes;\\n    /// @dev heroAdr+heroId => uint32 packed level, experience, life, mana, lifeChances\\n    mapping(bytes32 => bytes32) heroStats;\\n    /// @dev heroAdr+heroId+itemSlot => itemAdr + itemId\\n    mapping(bytes32 => bytes32) heroSlots;\\n    /// @dev heroAdr+heroId => busy slots uint8[] packed\\n    mapping(bytes32 => bytes32) heroBusySlots;\\n    mapping(bytes32 => EnumerableSet.AddressSet) usedConsumables;\\n    mapping(bytes32 => mapping(bytes32 => uint)) heroCustomData;\\n    mapping(bytes32 => uint) globalCustomData;\\n  }\\n\\n\\n  enum ATTRIBUTES {\\n    // core\\n    STRENGTH, // 0\\n    DEXTERITY, // 1\\n    VITALITY, // 2\\n    ENERGY, // 3\\n    // attributes\\n    DAMAGE_MIN, // 4\\n    DAMAGE_MAX, // 5\\n    ATTACK_RATING, // 6\\n    DEFENSE, // 7\\n    BLOCK_RATING, // 8\\n    LIFE, // 9\\n    MANA, // 10\\n    // resistance\\n    FIRE_RESISTANCE, // 11\\n    COLD_RESISTANCE, // 12\\n    LIGHTNING_RESISTANCE, // 13\\n    // dmg against\\n    DMG_AGAINST_HUMAN, // 14\\n    DMG_AGAINST_UNDEAD, // 15\\n    DMG_AGAINST_DAEMON, // 16\\n    DMG_AGAINST_BEAST, // 17\\n\\n    // defence against\\n    DEF_AGAINST_HUMAN, // 18\\n    DEF_AGAINST_UNDEAD, // 19\\n    DEF_AGAINST_DAEMON, // 20\\n    DEF_AGAINST_BEAST, // 21\\n\\n    // --- unique, not augmentable\\n    // hero will not die until have positive chances\\n    LIFE_CHANCES, // 22\\n    // increase chance to get an item\\n    MAGIC_FIND, // 23\\n    // decrease chance to get an item\\n    DESTROY_ITEMS, // 24\\n    // percent of chance x2 dmg\\n    CRITICAL_HIT, // 25\\n    // dmg factors\\n    MELEE_DMG_FACTOR, // 26\\n    FIRE_DMG_FACTOR, // 27\\n    COLD_DMG_FACTOR, // 28\\n    LIGHTNING_DMG_FACTOR, // 29\\n    // increase attack rating on given percent\\n    AR_FACTOR, // 30\\n    // percent of damage will be converted to HP\\n    LIFE_STOLEN_PER_HIT, // 31\\n    // amount of mana restored after each battle\\n    MANA_AFTER_KILL, // 32\\n    // reduce all damage on percent after all other reductions\\n    DAMAGE_REDUCTION, // 33\\n\\n    // -- statuses\\n    // chance to stun an enemy, stunned enemy skip next hit\\n    STUN, // 34\\n    // chance burn an enemy, burned enemy will loss 50% of defence\\n    BURN, // 35\\n    // chance freeze an enemy, frozen enemy will loss 50% of MELEE damage\\n    FREEZE, // 36\\n    // chance to reduce enemy's attack rating on 50%\\n    CONFUSE, // 37\\n    // chance curse an enemy, cursed enemy will loss 50% of resistance\\n    CURSE, // 38\\n    // percent of dmg return to attacker\\n    REFLECT_DAMAGE_MELEE, // 39\\n    REFLECT_DAMAGE_MAGIC, // 40\\n    // chance to poison enemy, poisoned enemy will loss 10% of the current health\\n    POISON, // 41\\n    // reduce chance get any of uniq statuses\\n    RESIST_TO_STATUSES, // 42\\n\\n    END_SLOT // 46\\n  }\\n\\n  // possible\\n  // HEAL_FACTOR\\n\\n  struct CoreAttributes {\\n    int32 strength;\\n    int32 dexterity;\\n    int32 vitality;\\n    int32 energy;\\n  }\\n\\n  struct ChangeableStats {\\n    uint32 level;\\n    uint32 experience;\\n    uint32 life;\\n    uint32 mana;\\n    uint32 lifeChances;\\n  }\\n\\n  enum ItemSlots {\\n    UNKNOWN, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    BOOTS, // 6\\n    RIGHT_RING, // 7\\n    LEFT_RING, // 8\\n    RIGHT_HAND, // 9\\n    LEFT_HAND, // 10\\n    TWO_HAND, // 11\\n    SKILL_1, // 12\\n    SKILL_2, // 13\\n    SKILL_3, // 14\\n    END_SLOT // 15\\n  }\\n\\n  struct NftItem {\\n    address token;\\n    uint tokenId;\\n  }\\n\\n  enum Race {\\n    UNKNOWN, // 0\\n    HUMAN, // 1\\n    UNDEAD, // 2\\n    DAEMON, // 3\\n    BEAST, // 4\\n    END_SLOT // 5\\n  }\\n\\n  struct ChangeAttributesInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    int32[] changeAttributes;\\n    bool add;\\n    bool temporally;\\n  }\\n\\n  struct BuffInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    uint32 heroLevel;\\n    address[] buffTokens;\\n    uint[] buffTokenIds;\\n  }\\n\\n  /// @dev This struct is used inside event, so it's moved here from lib\\n  struct ActionInternalInfo {\\n    int32[] posAttributes;\\n    int32[] negAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintedItems;\\n  }\\n\\n  function initNewHero(address token, uint tokenId, uint heroClass) external;\\n\\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory);\\n\\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32);\\n\\n  function heroAttributesLength(address token, uint tokenId) external view returns (uint);\\n\\n  function heroBaseAttributes(address token, uint tokenId) external view returns (CoreAttributes memory);\\n\\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint);\\n\\n  function globalCustomData(bytes32 index) external view returns (uint);\\n\\n  function heroStats(address token, uint tokenId) external view returns (ChangeableStats memory);\\n\\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked);\\n\\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory);\\n\\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function levelUp(address token, uint tokenId, uint heroClass, CoreAttributes memory change) external returns (uint newLvl);\\n\\n  function changeHeroItemSlot(\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) external;\\n\\n  function changeCurrentStats(\\n    address token,\\n    uint tokenId,\\n    ChangeableStats memory change,\\n    bool increase\\n  ) external;\\n\\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external;\\n\\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external;\\n\\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external;\\n\\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external;\\n\\n  function buffHero(BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed);\\n\\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external;\\n\\n  function setGlobalCustomData(bytes32 index, uint value) external;\\n\\n  /// @notice Restore life and mana during reinforcement\\n  /// @param prevAttributes Hero attributes before reinforcement\\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external;\\n}\\n\",\"keccak256\":\"0xb6e25f1fae300c03cacdba3b8b0e56b7e8c46a8cb3abb168ddada2375aaf1f3c\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStoryController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"./IController.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./IHeroController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStoryController {\\n\\n  enum AnswerResultId {\\n    UNKNOWN, // 0\\n    SUCCESS, // 1\\n    ATTRIBUTE_FAIL, // 2\\n    RANDOM_FAIL, // 3\\n    DELAY_FAIL, // 4\\n    HERO_CUSTOM_DATA_FAIL, // 5\\n    GLOBAL_CUSTOM_DATA_FAIL, // 6\\n\\n    END_SLOT\\n  }\\n\\n  enum CustomDataResult {\\n    UNKNOWN, // 0\\n    HERO_SUCCESS, // 1\\n    HERO_FAIL, // 2\\n    GLOBAL_SUCCESS, // 3\\n    GLOBAL_FAIL, // 4\\n\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:story.controller.main\\n  struct MainState {\\n\\n    // --- STORY REG INFO ---\\n\\n    /// @dev Uniq story identification.\\n    mapping(uint32 => uint16) storyIds;\\n    /// @dev Revers mapping for stories for using in the next object rewrite logic.\\n    mapping(uint16 => uint32) idToStory;\\n    /// @dev Store used ids for stories.\\n    mapping(uint16 => bool) _usedStoryIds;\\n    /// @dev Prevent register the story twice\\n    mapping(uint32 => bool) registeredStories;\\n\\n    // --- ANSWER MAPPING ---\\n\\n    /// @dev storyId => all story pages. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.UintSet) allStoryPages;\\n\\n    /// @dev storyId => all possible answers. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.Bytes32Set) allStoryAnswers;\\n\\n    /// @dev storyId + pageId + heroClass (zero is default answers) => storyId + pageId + heroClass (zero is default answers) + answerId\\n    mapping(bytes32 => bytes32[]) answers;\\n    /// @dev answerUnPackedId + answerResultId => nextPageIds (will be chosen randomly from this array)\\n    ///      where answerResultId is:\\n    ///      0 - unknown,\\n    ///      1 - success,\\n    ///      2 - attr fail\\n    ///      3 - random fail\\n    ///      4 - delay fail\\n    ///      5 - hero custom data fail\\n    ///      6 - global custom data fail\\n    ///      see COUNT_ANSWER_RESULT_IDS\\n    mapping(bytes32 => uint16[]) nextPageIds;\\n    /// @dev story + pageId + heroClass (zero is default answers) => random nextObjs (adr + id, like packed nft id)\\n    mapping(bytes32 => uint32[]) nextObjectsRewrite;\\n\\n    /// @dev answerPackedId => packed array of uint32[]\\n    ///      0 - random requirement(uint32, 1 - 99% success of this action, zero means no check)\\n    ///      1 - delay requirement(uint32, if time since the last call more than this value the check is fail, zero means no check)\\n    ///      2 - isFinalAnswer(uint8)\\n    mapping(bytes32 => bytes32) answerAttributes;\\n\\n    // --- ANSWER REQUIREMENTS ---\\n\\n    /// @dev answerPackedId => array of AttributeRequirementsPacked\\n    mapping(bytes32 => bytes32[]) attributeRequirements;\\n    /// @dev answerPackedId=> array of ItemRequirementsPacked\\n    mapping(bytes32 => bytes32[]) itemRequirements;\\n    /// @dev answerPackedId => array of TokenRequirementsPacked\\n    mapping(bytes32 => bytes32[]) tokenRequirements;\\n    /// @dev answerPackedId => custom data for hero\\n    mapping(bytes32 => CustomDataRequirementPacked[]) heroCustomDataRequirement;\\n    /// @dev answerPackedId => global custom data\\n    mapping(bytes32 => CustomDataRequirementPacked[]) globalCustomDataRequirement;\\n\\n    // --- ANSWER RESULTS ---\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) successInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) successInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) successInfoMintItems;\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) failInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) failInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) failInfoMintItems;\\n\\n    /// @dev answerUnPackedId + CustomDataResult => custom data array change\\n    ///      where CustomDataResult is\\n    ///      1 - hero success\\n    ///      2 - hero fail\\n    ///      3 - global success\\n    ///      4 - global fail\\n    ///      see COUNT_CUSTOM_DATA_RESULT_IDS\\n    mapping(bytes32 => bytes32[]) customDataResult;\\n\\n    /// @notice answerPackedId => slot+chance+stopIfBurnt\\n    /// @dev Since SIP-003 the items are not burn but broke\\n    mapping(bytes32 => bytes32[]) burnItem;\\n\\n    // --- GENERAL STORY REQUIREMENTS ---\\n\\n    /// @dev story => Custom hero data requirements for a story. If exist and hero is not eligible should be not chose in a dungeon.\\n    mapping(uint => CustomDataRequirementRangePacked[]) storyRequiredHeroData;\\n    /// @dev story => Minimal level for the history. 0 means no requirements.\\n    mapping(uint => uint) storyRequiredLevel;\\n\\n    // --- HERO STATES ---\\n\\n    /// @dev hero + heroId + storyId => pageId + heroLastActionTS\\n    mapping(bytes32 => bytes32) heroState;\\n\\n    // --- OTHER ---\\n\\n    /// @dev storyId => build hash for the last update\\n    mapping(uint16 => uint) storyBuildHash;\\n\\n    /// @notice Number of already minted items by the user within the given iteration of the story.\\n    /// Only minting of the given number of items is allowed per iteration (see MAX_MINTED_ITEMS_PER_ITERATION).\\n    /// @dev hero, heroId, story => mintedInIteration\\n    /// This map is not cleared: storyId:objectId is 1:1, each object has own sequence of iterations without duplicates\\n    mapping(bytes32 => mapping(uint iteration => uint countMintedItems)) mintedInIteration;\\n  }\\n\\n  /// @dev We need to have flat structure coz Solidity can not handle arrays of structs properly\\n  struct StoryMetaInfo {\\n    uint16 storyId;\\n\\n    // --- story reqs\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n    uint minLevel;\\n\\n    // --- answer reqs\\n\\n    AnswersMeta answersMeta;\\n    AnswerNextPageMeta answerNextPage;\\n    AnswerAttributeRequirementsMeta answerAttributeRequirements;\\n    AnswerItemRequirementsMeta answerItemRequirements;\\n    AnswerTokenRequirementsMeta answerTokenRequirements;\\n    AnswerAttributesMeta answerAttributes;\\n    AnswerCustomDataMeta answerHeroCustomDataRequirement;\\n    AnswerCustomDataMeta answerGlobalCustomDataRequirement;\\n\\n    // --- answer results\\n\\n    AnswerBurnRandomItemMeta answerBurnRandomItemMeta;\\n    NextObjRewriteMeta nextObjRewriteMeta;\\n\\n    // --- story results\\n\\n    AnswerResultMeta successInfo;\\n    AnswerResultMeta failInfo;\\n\\n    AnswerCustomDataResultMeta successHeroCustomData;\\n    AnswerCustomDataResultMeta failHeroCustomData;\\n    AnswerCustomDataResultMeta successGlobalCustomData;\\n    AnswerCustomDataResultMeta failGlobalCustomData;\\n  }\\n\\n  struct NextObjRewriteMeta {\\n    uint16[] nextObjPageIds;\\n    uint8[] nextObjHeroClasses;\\n    uint32[][] nextObjIds;\\n  }\\n\\n  struct AnswersMeta {\\n    uint16[] answerPageIds;\\n    uint8[] answerHeroClasses;\\n    uint16[] answerIds;\\n  }\\n\\n  struct AnswerNextPageMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint8[] answerResultIds;\\n    uint16[][] answerNextPageIds;\\n  }\\n\\n  struct AnswerAttributeRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    bool[][] cores;\\n    uint8[][] ids;\\n    int32[][] values;\\n  }\\n\\n  struct AnswerItemRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireItems;\\n    bool[][] requireItemBurn;\\n    bool[][] requireItemEquipped;\\n  }\\n\\n  struct AnswerTokenRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireToken;\\n    uint88[][] requireAmount;\\n    bool[][] requireTransfer;\\n  }\\n\\n  struct AnswerAttributesMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint32[] randomRequirements;\\n    uint32[] delayRequirements;\\n    bool[] isFinalAnswer;\\n  }\\n\\n  struct AnswerCustomDataMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    bool[][] mandatory;\\n    uint64[][] dataValuesMin;\\n    uint64[][] dataValuesMax;\\n  }\\n\\n  struct AnswerResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    uint8[][] attributeIds;\\n    /// @dev Max value is limitied by int24, see toBytes32ArrayWithIds impl\\n    int32[][] attributeValues;\\n\\n    uint32[] experience;\\n    int32[] heal;\\n    int32[] manaRegen;\\n    int32[] lifeChancesRecovered;\\n    int32[] damage;\\n    int32[] manaConsumed;\\n\\n    address[][] mintItems;\\n    uint32[][] mintItemsChances;\\n  }\\n\\n  struct AnswerCustomDataResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    int16[][] dataValues;\\n  }\\n\\n  struct AnswerBurnRandomItemMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    /// @notice 0 - random slot\\n    uint8[][] slots;\\n    /// @notice typical chances are [0..100] (no decimals here)\\n    uint64[][] chances;\\n    /// @notice Since SIP-003 the burning is replaced by breaking bu the name is kept as is\\n    bool[][] isStopIfBurnt;\\n  }\\n\\n  struct CustomDataRequirementPacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + mandatory(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct CustomDataRequirementRangePacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + isHeroData(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct StatsChange {\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n  }\\n\\n  struct StoryActionContext {\\n    uint stageId;\\n    uint iteration;\\n    bytes32 answerIdHash;\\n    bytes32 answerAttributes;\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IStatController statController;\\n    IHeroController heroController;\\n    IOracle oracle;\\n    IItemController itemController;\\n    uint8 heroClass;\\n    uint8 heroClassFromAnswerHash;\\n    uint8 biome;\\n    uint16 storyId;\\n    uint16 storyIdFromAnswerHash;\\n    uint16 pageIdFromAnswerHash;\\n    uint16 answerNumber;\\n    uint16 pageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint40 heroLastActionTS;\\n    uint80 heroTokenId;\\n    IStatController.ChangeableStats heroStats;\\n  }\\n\\n  // --- WRITE ---\\n\\n  function storyAction(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) external returns (IGOC.ActionResult memory);\\n\\n  // --- READ ---\\n\\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function idToStory(uint16 id) external view returns (uint32 objectId);\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId);\\n\\n  function storyIds(uint32 objectId) external view returns (uint16);\\n\\n  function registeredStories(uint32 objectId) external view returns (bool);\\n\\n}\\n\",\"keccak256\":\"0x7822f79d53590b18455c5d54d91f5b38fabc1330f24ae41db546a785c151e61d\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IUserController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IUserController {\\n\\n  //region ------------------------ Data types\\n\\n  enum LootBoxKind {\\n    /// @notice small loot box - reward for the daily activity\\n    DAILY_0,\\n    /// @notice large loot box - reward for the weekly activity (daily activity is passed each ot of the 7 days)\\n    WEEKLY_1,\\n\\n    END_SLOT\\n  }\\n\\n  /// @dev registerPassedDungeon assumes that the whole struct takes single slot only, not more\\n  struct UserActivity {\\n    /// @notice A day for which the daily activity is calculated (see counterXXX below)\\n    /// The number of days since 1970-01-01\\n    uint32 epochDay;\\n\\n    /// @notice A week for which total count of daily activities were calculated\\n    /// The number of weeks since (1970-01-01 Thursday) - 3 days = (1969-12-29 Monday)\\n    uint32 epochWeek;\\n\\n    /// @notice Count of dungeons passed during the day\\n    uint32 counterPassedDungeons;\\n    /// @notice Count of PvP during the day\\n    uint32 counterPvp;\\n\\n    /// @notice Count of daily activities completed per the week\\n    uint16 dailyActivities;\\n\\n    /// @notice Daily activity is completed and small loot box is added to the earned loot boxes\\n    bool dailyLootBoxReceived;\\n    /// @notice Weekly activity is completed and large loot box is added to the earned loot boxes\\n    bool weeklyLootBoxReceived;\\n  }\\n\\n  struct EarnedLootBoxes {\\n    /// @notice Count of loot boxes earned by daily activity\\n    uint32 dailyCounter;\\n    /// @notice Count of loot boxes earned by weekly activity\\n    uint32 weeklyCounter;\\n  }\\n\\n  struct LootBoxConfig {\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n    uint maxDropItems;\\n  }\\n\\n  /// @custom:storage-location erc7201:user.controller.main\\n  struct MainState {\\n    /// @notice Amount of sacra required to rename user account\\n    uint feeRenaming;\\n\\n    /// @dev user EOA => account name\\n    mapping(address => string) userAccountName;\\n\\n    /// @dev name => user EOA, needs for checking uniq names\\n    mapping(string => address) nameToUserAccount;\\n\\n    /// @notice user => daily activity info\\n    mapping(address => UserActivity) userActivity;\\n\\n    /// @notice user => earned loot boxes\\n    mapping(address => EarnedLootBoxes) counterLootBoxes;\\n\\n    /// @notice Configs of loot boxes of various kinds\\n    mapping(LootBoxKind => LootBoxConfig) lootBoxConfig;\\n\\n    address userTokensVault;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  /// @notice Register daily activity - a dungeon was passed\\n  /// @param user Owner of the hero who has passed the dungeon\\n  function registerPassedDungeon(address user) external;\\n\\n  /// @notice Register daily activity - PvP was made\\n  /// @param user Owner of the hero who has taken participation in the PvP\\n  function registerPvP(address user, bool isWinner) external;\\n\\n  function userTokensVault() external view returns (address);\\n}\",\"keccak256\":\"0x9920c788e029b35b17fe1690c918e1760dc2bd2ca68ce6b5930a795ad153e71b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/CalcLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\n\\nlibrary CalcLib {\\n\\n  uint32 public constant MAX_CHANCE = 1e9;\\n\\n  function minI32(int32 a, int32 b) internal pure returns (int32) {\\n    return a < b ? a : b;\\n  }\\n\\n  function max32(int32 a, int32 b) internal pure returns (int32) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function absDiff(int32 a, int32 b) internal pure returns (uint32) {\\n    if (!((a >= 0 && b >= 0) || (a <= 0 && b <= 0))) revert IAppErrors.AbsDiff(a, b);\\n    if (a < 0) {\\n      a = - a;\\n    }\\n    if (b < 0) {\\n      b = - b;\\n    }\\n    return uint32(uint(int(a >= b ? a - b : b - a)));\\n  }\\n\\n  function toUint(int32 n) internal pure returns (uint) {\\n    if (n < 0) {\\n      return 0;\\n    }\\n    if (n <= 0) {\\n      return 0;\\n    }\\n    return uint(int(n));\\n  }\\n\\n  function toInt32(uint a) internal pure returns (int32){\\n    if (a >= uint(int(type(int32).max))) {\\n      return type(int32).max;\\n    }\\n    return int32(int(a));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandom(uint maxValue) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft()))) % (maxValue + 1));\\n  }\\n\\n  function pseudoRandomUint32(uint32 maxValue) internal view returns (uint32) {\\n    return uint32(pseudoRandom(uint(maxValue)));\\n  }\\n\\n  /// @notice Generate pseudo-random uint in the range [0..maxValue) using Solady pseudo-random function\\n  function nextPrng(LibPRNG.PRNG memory prng, uint maxValue) internal pure returns (uint) {\\n    return LibPRNG.next(prng) % maxValue;\\n  }\\n\\n  /// @notice pseudoRandomUint32 with customizable pseudoRandom()\\n  function pseudoRandomUint32Flex(\\n    uint32 maxValue,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint32) {\\n    return uint32(random_(uint(maxValue)));\\n  }\\n\\n  function pseudoRandomInt32(int32 maxValue) internal view returns (int32) {\\n    bool neg;\\n    if (maxValue < 0) {\\n      neg = true;\\n      maxValue = - maxValue;\\n    }\\n    uint32 v = uint32(pseudoRandom(uint(int(maxValue))));\\n    return neg\\n      ? - int32(int(uint(v)))\\n      : int32(int(uint(v)));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandomWithSeed(uint maxValue, uint seed) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), seed))) % (maxValue + 1));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  function pseudoRandomInRange(uint min, uint max) internal view returns (uint) {\\n    if (min >= max) {\\n      return max;\\n    }\\n    uint r = pseudoRandom(max - min);\\n    return min + r;\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  ///      Equal to pseudoRandomInRange(min, max, pseudoRandom)\\n  function pseudoRandomInRangeFlex(\\n    uint min,\\n    uint max,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint) {\\n    return min >= max ? max : min + random_(max - min);\\n  }\\n\\n  function minusWithZeroFloor(uint a, uint b) internal pure returns (uint){\\n    if (a <= b) {\\n      return 0;\\n    }\\n    return a - b;\\n  }\\n\\n  function minusWithMinFloorI32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) - int(b) < type(int32).min) {\\n      return type(int32).min;\\n    }\\n    return a - b;\\n  }\\n\\n  function plusWithMaxFloor32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) + int(b) >= type(int32).max) {\\n      return type(int32).max;\\n    }\\n    return a + b;\\n  }\\n\\n  function sqrt(uint x) internal pure returns (uint z) {\\n    assembly {\\n    // Start off with z at 1.\\n      z := 1\\n\\n    // Used below to help find a nearby power of 2.\\n      let y := x\\n\\n    // Find the lowest power of 2 that is at least sqrt(x).\\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n        y := shr(128, y) // Like dividing by 2 ** 128.\\n        z := shl(64, z) // Like multiplying by 2 ** 64.\\n      }\\n      if iszero(lt(y, 0x10000000000000000)) {\\n        y := shr(64, y) // Like dividing by 2 ** 64.\\n        z := shl(32, z) // Like multiplying by 2 ** 32.\\n      }\\n      if iszero(lt(y, 0x100000000)) {\\n        y := shr(32, y) // Like dividing by 2 ** 32.\\n        z := shl(16, z) // Like multiplying by 2 ** 16.\\n      }\\n      if iszero(lt(y, 0x10000)) {\\n        y := shr(16, y) // Like dividing by 2 ** 16.\\n        z := shl(8, z) // Like multiplying by 2 ** 8.\\n      }\\n      if iszero(lt(y, 0x100)) {\\n        y := shr(8, y) // Like dividing by 2 ** 8.\\n        z := shl(4, z) // Like multiplying by 2 ** 4.\\n      }\\n      if iszero(lt(y, 0x10)) {\\n        y := shr(4, y) // Like dividing by 2 ** 4.\\n        z := shl(2, z) // Like multiplying by 2 ** 2.\\n      }\\n      if iszero(lt(y, 0x8)) {\\n      // Equivalent to 2 ** z.\\n        z := shl(1, z)\\n      }\\n\\n    // Shifting right by 1 is like dividing by 2.\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n\\n    // Compute a rounded down version of z.\\n      let zRoundDown := div(x, z)\\n\\n    // If zRoundDown is smaller, use it.\\n      if lt(zRoundDown, z) {\\n        z := zRoundDown\\n      }\\n    }\\n  }\\n\\n  /*********************************************\\n *              PRB-MATH                      *\\n *   https://github.com/hifi-finance/prb-math *\\n **********************************************/\\n  /// @notice Calculates the binary logarithm of x.\\n  ///\\n  /// @dev Based on the iterative approximation algorithm.\\n  /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n  ///\\n  /// Requirements:\\n  /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n  ///\\n  /// Caveats:\\n  /// - The results are nor perfectly accurate to the last decimal,\\n  ///   due to the lossy precision of the iterative approximation.\\n  ///\\n  /// @param x The unsigned 60.18-decimal fixed-point number for which\\n  ///           to calculate the binary logarithm.\\n  /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n  function log2(uint256 x) internal pure returns (uint256 result) {\\n    if (x < 1e18) revert IAppErrors.TooLowX(x);\\n\\n    // Calculate the integer part of the logarithm\\n    // and add it to the result and finally calculate y = x * 2^(-n).\\n    uint256 n = mostSignificantBit(x / 1e18);\\n\\n    // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number.\\n    // The operation can't overflow because n is maximum 255 and SCALE is 1e18.\\n    uint256 rValue = n * 1e18;\\n\\n    // This is y = x * 2^(-n).\\n    uint256 y = x >> n;\\n\\n    // If y = 1, the fractional part is zero.\\n    if (y == 1e18) {\\n      return rValue;\\n    }\\n\\n    // Calculate the fractional part via the iterative approximation.\\n    // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n    for (uint256 delta = 5e17; delta > 0; delta >>= 1) {\\n      y = (y * y) / 1e18;\\n\\n      // Is y^2 > 2 and so in the range [2,4)?\\n      if (y >= 2 * 1e18) {\\n        // Add the 2^(-m) factor to the logarithm.\\n        rValue += delta;\\n\\n        // Corresponds to z/2 on Wikipedia.\\n        y >>= 1;\\n      }\\n    }\\n    return rValue;\\n  }\\n\\n  /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n  /// @dev See the note on msb in the \\\"Find First Set\\\"\\n  ///      Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n  /// @param x The uint256 number for which to find the index of the most significant bit.\\n  /// @return msb The index of the most significant bit as an uint256.\\n  //noinspection NoReturn\\n  function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n    if (x >= 2 ** 128) {\\n      x >>= 128;\\n      msb += 128;\\n    }\\n    if (x >= 2 ** 64) {\\n      x >>= 64;\\n      msb += 64;\\n    }\\n    if (x >= 2 ** 32) {\\n      x >>= 32;\\n      msb += 32;\\n    }\\n    if (x >= 2 ** 16) {\\n      x >>= 16;\\n      msb += 16;\\n    }\\n    if (x >= 2 ** 8) {\\n      x >>= 8;\\n      msb += 8;\\n    }\\n    if (x >= 2 ** 4) {\\n      x >>= 4;\\n      msb += 4;\\n    }\\n    if (x >= 2 ** 2) {\\n      x >>= 2;\\n      msb += 2;\\n    }\\n    if (x >= 2 ** 1) {\\n      // No need to shift x any more.\\n      msb += 1;\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0xd5178ce117e26987cd3cb3496e13bd2c6e7d220557ec25f771444dd2f4d2db5b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/GuildControllerLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"./GuildLib.sol\\\";\\n\\nlibrary GuildControllerLib {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n\\n  //region ------------------------ Constants\\n  /// @notice Fee for buying shelter in sacra, decimals 18\\n  uint internal constant SHELTER_FEE = 1e18;\\n\\n  /// @notice Each biome has 10 shelters: 5 shelters of level 1, 3 shelters of level 2 and 2 shelters of level 3\\n  /// indices = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\n  /// levels  = [1, 1, 1, 1, 1, 2, 2, 2, 3, 3]\\n  uint internal constant MAX_COUNT_SHELTERS_PER_BIOME = 10;\\n  //endregion ------------------------ Constants\\n\\n//  //region ------------------------ Shelter view\\n//  function packShelterId(uint8 biome, uint8 shelterIndex) internal pure returns (uint32) {\\n//    return shelterIndex | (biome << 8);\\n//  }\\n//\\n//  function unpackShelterId(uint shelterId) internal pure returns (uint8 biome, uint8 shelterIndex) {\\n//    return (uint8(shelterId), uint8(shelterId >> 8));\\n//  }\\n//\\n//  /// @notice Price of the shelter with given ID. The price depends on the shelter's level: Price = fee * level\\n//  function getShelterDefaultPrice(uint8 shelterLevel) internal pure returns (uint) {\\n//    return shelterLevel * SHELTER_FEE;\\n//  }\\n//\\n//  function getShelterData(uint shelterId) internal view returns (IGuildController.ShelterData memory) {\\n//    return GuildLib._S().shelterData[shelterId];\\n//  }\\n//\\n//  function getShelterBid(uint shelterId) internal view returns (uint buyerGuildId, uint amount) {\\n//    IGuildController.ShelterBid memory bid = GuildLib._S().shelterBid[shelterId];\\n//    return (bid.buyerGuildId, bid.amount);\\n//  }\\n//\\n//  //endregion ------------------------ Shelter view\\n//\\n//  //region ------------------------ Shelter actions\\n//\\n//  /// @notice Guild buys a shelter that doesn't belong to any guild. It pays default prices and changes owner of the shelter.\\n//  function buyShelter(IController controller, address msgSender, uint shelterId) internal {\\n//    (uint guildId,) = GuildLib._checkPermissions(msgSender, IGuildController.GuildRightBits.CHANGE_SHELTER_3);\\n//\\n//    // only registered shelter can be purchased\\n//    uint8 shelterLevel = GuildLib._S().shelterData[shelterId].shelterLevel;\\n//    if (shelterLevel == 0) revert IAppErrors.ShelterIsNotRegistered();\\n//\\n//    // Each guild is able to have only 1 shelter. Exist shelter should be sold or left\\n//    if (GuildLib._S().guildToShelter[guildId] != 0) revert IAppErrors.GuildAlreadyHasShelter();\\n//    if (GuildLib._S().shelterToGuild[shelterId] != 0) revert IAppErrors.ShelterIsBusy();\\n//\\n//    // pay for the shelter\\n//    uint fee = getShelterDefaultPrice(shelterLevel);\\n//    IHeroTokensVault(IHeroController(controller.heroController()).heroTokensVault()).process(controller.gameToken(), fee, msgSender);\\n//\\n//    // register ownership\\n//    GuildLib._S().guildToShelter[guildId] = shelterId;\\n//    GuildLib._S().shelterToGuild[shelterId] = guildId;\\n//  }\\n//\\n//  /// @notice Guild leaves the shelter. The shelter becomes free, it can be bought by any guild by default price\\n//  function leaveShelter(address msgSender, uint shelterId) internal {\\n//    (uint guildId,) = GuildLib._checkPermissions(msgSender, IGuildController.GuildRightBits.CHANGE_SHELTER_3);\\n//\\n//    if (GuildLib._S().guildToShelter[guildId] != shelterId) revert IAppErrors.ShelterIsNotOwnedByTheGuild();\\n//\\n//    // shelter cannot be left if any heroes are inside\\n//    if (GuildLib._S().shelterToHeroes[shelterId].length() != 0) revert IAppErrors.ShelterHasHeroesInside();\\n//\\n//    // unregister ownership\\n//    delete GuildLib._S().guildToShelter[guildId];\\n//    delete GuildLib._S().shelterToGuild[shelterId];\\n//  }\\n//\\n//  /// @notice Register shelter. Only registered shelters can be purchased.\\n//  /// Assume that shelterId is correct (shelterIndex is in the range [0..10) )\\n//  function setShelterData(IController controller, address msgSender, uint shelterId, IGuildController.ShelterData memory shelterData) internal {\\n//    GuildLib._onlyGovernance(controller, msgSender);\\n//    if (shelterData.shelterLevel == 0 && GuildLib._S().shelterToGuild[shelterId] != 0) revert IAppErrors.ShelterIsInUse();\\n//\\n//    GuildLib._S().shelterData[shelterId] = shelterData;\\n//  }\\n//\\n//  /// @notice Set or clear a bid.\\n//  /// The bid allows to purchase the shelter to other guild.\\n//  function setBid(address msgSender, uint buyerGuildId, uint amount) internal {\\n//    (uint sellerGuildId,) = GuildLib._checkPermissions(msgSender, IGuildController.GuildRightBits.CHANGE_SHELTER_3);\\n//\\n//    uint shelterId = GuildLib._S().shelterToGuild[sellerGuildId];\\n//    if (shelterId == 0) revert IAppErrors.GuildHasNoShelter();\\n//\\n//    GuildLib._S().shelterBid[shelterId] = IGuildController.ShelterBid({\\n//      amount: amount,\\n//      buyerGuildId: buyerGuildId\\n//    });\\n//  }\\n//\\n//  /// @notice One guild sells its shelter to another guild\\n//  function useBid(IController controller, address msgSender, uint shelterId) internal {\\n//    (uint buyerGuildId,) = GuildLib._checkPermissions(msgSender, IGuildController.GuildRightBits.CHANGE_SHELTER_3);\\n//\\n//    // check bid\\n//    IGuildController.ShelterBid memory bid = GuildLib._S().shelterBid[shelterId];\\n//    if (buyerGuildId != bid.buyerGuildId) revert IAppErrors.ShelterBidIsNotAllowedToBeUsed();\\n//\\n//    // check shelter state\\n//    if (GuildLib._S().shelterToHeroes[shelterId].length() != 0) revert IAppErrors.ShelterHasHeroesInside();\\n//\\n//    // check buyer state\\n//    if (GuildLib._S().guildToShelter[buyerGuildId] != 0) revert IAppErrors.GuildAlreadyHasShelter();\\n//\\n//    uint sellerGuildId = GuildLib._S().shelterToGuild[shelterId];\\n//\\n//    if (bid.amount != 0) {\\n//      address sellerGuildBank = GuildLib._S().guildBanks[sellerGuildId];\\n//      address buyerGuildBank = GuildLib._S().guildBanks[buyerGuildId];\\n//\\n//      IGuildBank(sellerGuildBank).transfer(controller.gameToken(), buyerGuildBank, bid.amount);\\n//    }\\n//\\n//    GuildLib._S().shelterToGuild[shelterId] = buyerGuildId;\\n//    GuildLib._S().guildToShelter[buyerGuildId] = shelterId;\\n//    delete GuildLib._S().guildToShelter[sellerGuildId];\\n//    delete GuildLib._S().shelterBid[shelterId];\\n//\\n//  }\\n//  //endregion ------------------------ Shelter actions\\n\\n  //region ------------------------ Domination\\n\\n  //endregion ------------------------ Domination\\n\\n  //region ------------------------ Guild reinforcement\\n\\n  //endregion ------------------------ Guild reinforcement\\n\\n  //region ------------------------ PvP\\n\\n  //endregion ------------------------ PvP\\n}\\n\",\"keccak256\":\"0x8db06e40f54ae28340a5eaae7fed9dbda29e270db731f2ec3e3ffef91d46eb85\",\"license\":\"BUSL-1.1\"},\"contracts/lib/GuildLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IHeroTokensVault.sol\\\";\\nimport \\\"../interfaces/IUserController.sol\\\";\\nimport \\\"../lib/StringLib.sol\\\";\\nimport \\\"../token/GuildBank.sol\\\";\\nimport \\\"./ReinforcementControllerLib.sol\\\";\\n\\nlibrary GuildLib {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  //region ------------------------ Constants\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"guild.controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 private constant GUILD_CONTROLLER_STORAGE_LOCATION = 0x1c4340ff8478a236ed13a5ce46f8e8b8a6037975df340a04c54725978699d100;\\n  uint8 internal constant FIRST_LEVEL = 1;\\n  uint8 internal constant MAX_LEVEL = 10;\\n  /// @notice Default fee for creation guild, renaming, etc. in terms of game token\\n  uint internal constant DEFAULT_BASE_FEE = 1e18; // todo set real value\\n  uint internal constant MAX_LOGO_URL_LENGTH = 150;\\n  uint internal constant MAX_GUILD_NAME_LENGTH = 20;\\n  uint internal constant MAX_GUILD_MEMBERS_ON_LEVEL_1 = 25;\\n  uint internal constant MAX_GUILD_MEMBERS_INC_PER_LEVEL = 5;\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Restrictions\\n  function _onlyEoa(bool isEoa) internal pure {\\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\\n  }\\n\\n  function _onlyGovernance(IController controller) internal view {\\n    if (controller.governance() != msg.sender) revert IAppErrors.NotGovernance(msg.sender);\\n  }\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ Storage\\n\\n  function _S() internal pure returns (IGuildController.MainState storage s) {\\n    assembly {\\n      s.slot := GUILD_CONTROLLER_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n  //endregion ------------------------ Storage\\n\\n  //region ------------------------ VIEWS\\n  function counterGuildIds() internal view returns (uint) {\\n    return _S().guildsParam[IGuildController.GuildsParams.COUNTER_GUILD_IDS_1];\\n  }\\n\\n  function getGuildData(uint guildId) internal view returns (IGuildController.GuildData memory) {\\n    return _S().guildData[guildId];\\n  }\\n\\n  function getGuildByName(string memory name) internal view returns (uint guildId) {\\n    return _S().nameToGuild[name];\\n  }\\n\\n  function memberOf(address user) internal view returns (uint guildId) {\\n    return _S().memberToGuild[user];\\n  }\\n\\n  function guildMembers(uint guildId) internal view returns (address[] memory) {\\n    return _S().members[guildId].values();\\n  }\\n\\n  function getRights(address user) internal view returns (uint) {\\n    return _S().rights[user];\\n  }\\n\\n  function isPeacefulRelation(uint guildId, uint guildId2) internal view returns (bool) {\\n    return _S().relationsPeaceful[_getGuildsPairKey(guildId, guildId2)];\\n  }\\n\\n  function getGuildBank(uint guildId) internal view returns (address) {\\n    return _S().guildBanks[guildId];\\n  }\\n\\n  function getBaseFee() internal view returns (uint) {\\n    return _S().guildsParam[IGuildController.GuildsParams.BASE_FEE_2];\\n  }\\n\\n// todo\\n//  function getBiomeOwner(uint8 biome) internal view returns (uint guildId) {\\n//    return _S().biomeOwner[biome];\\n//  }\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ Gov actions\\n\\n  /// @param fee Base fee value in terms of game token\\n  function setBaseFee(IController controller, uint fee) internal {\\n    _onlyGovernance(controller);\\n\\n    if (fee == 0) revert IAppErrors.ZeroValueNotAllowed();\\n\\n    _S().guildsParam[IGuildController.GuildsParams.BASE_FEE_2] = fee;\\n  }\\n\\n  //endregion ------------------------ Gov actions\\n\\n  //region ------------------------ ACTIONS\\n\\n  /// @notice Generate id for new guild, increment id-counter\\n  function _generateGuildId() internal returns (uint uid) {\\n    uid = _S().guildsParam[IGuildController.GuildsParams.COUNTER_GUILD_IDS_1] + 1;\\n    _S().guildsParam[IGuildController.GuildsParams.COUNTER_GUILD_IDS_1] = uid;\\n  }\\n\\n  /// @notice Create new guild, return ID of the new guild\\n  /// @param toHelperRatio Percent of fee for guild reinforcement. Value in range [_FEE_MIN ... _TO_HELPER_RATIO_MAX]\\n  function createGuild(\\n    bool isEoa,\\n    IController controller,\\n    address msgSender,\\n    string memory name,\\n    string memory urlLogo,\\n    uint8 toHelperRatio\\n  ) internal returns (uint) {\\n    _onlyEoa(isEoa);\\n\\n    // user can be a member of a single guild only\\n    if (_S().memberToGuild[msgSender] != 0) revert IAppErrors.AlreadyGuildMember();\\n\\n    // check guild name\\n    if (_S().nameToGuild[name] != 0) revert IAppErrors.NameTaken();\\n    if (bytes(name).length >= MAX_GUILD_NAME_LENGTH) revert IAppErrors.TooBigName();\\n    if (!StringLib.isASCIILettersOnly(name)) revert IAppErrors.WrongSymbolsInTheName();\\n    if (bytes(name).length == 0) revert IAppErrors.EmptyNameNotAllowed();\\n\\n    validateToHelperRatio(toHelperRatio);\\n\\n    // check logo url, empty logo and duplicates are allowed\\n    if (bytes(urlLogo).length >= MAX_LOGO_URL_LENGTH) revert IAppErrors.TooLongUrl();\\n\\n    uint guildId = _generateGuildId();\\n    IGuildController.GuildData memory guildData = IGuildController.GuildData({\\n      owner: msgSender,\\n      urlLogo: urlLogo,\\n      guildName: name,\\n      guildLevel: FIRST_LEVEL,\\n      pvpCounter: 0,\\n      toHelperRatio: toHelperRatio\\n    });\\n\\n    _S().guildData[guildId] = guildData;\\n    _S().nameToGuild[name] = guildId;\\n\\n    _S().members[guildId].add(msgSender);\\n    _S().memberToGuild[msgSender] = guildId;\\n    _S().rights[msgSender] = _getMaskRights(IGuildController.GuildRightBits.ADMIN_0);\\n\\n    _S().guildBanks[guildId] = _deployNewGuildBank(controller.guildController(), guildId);\\n\\n    // pay base fee for guild creation\\n    IHeroTokensVault(IUserController(controller.userController()).userTokensVault()).process(controller.gameToken(), getBaseFee(), msgSender);\\n\\n    emit IApplicationEvents.GuildCreated(guildData.owner, guildId, guildData.guildName, guildData.urlLogo);\\n\\n    return guildId;\\n  }\\n\\n  /// @notice Add new member to the guild to which msgSender belongs\\n  function addGuildMember(address msgSender, address newUser, uint maskRights) internal {\\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.ADD_MEMBER_4);\\n    IGuildController.GuildData memory guildData = _S().guildData[guildId];\\n\\n    if (_S().memberToGuild[newUser] != 0) revert IAppErrors.AlreadyGuildMember();\\n    if (newUser == address(0)) revert IAppErrors.ZeroAddress();\\n    if ((maskRights & _getMaskRights(IGuildController.GuildRightBits.ADMIN_0)) != 0) revert IAppErrors.SecondGuildAdminIsNotAllowed();\\n\\n    uint guildSize = _S().members[guildId].length();\\n    if (guildSize == _getMaxMembersNumber(guildData.guildLevel)) revert IAppErrors.GuildHasMaxSize(guildSize);\\n\\n    _S().members[guildId].add(newUser);\\n    _S().memberToGuild[newUser] = guildId;\\n    _S().rights[newUser] = maskRights;\\n\\n    emit IApplicationEvents.AddToGuild(guildId, newUser);\\n  }\\n\\n  /// @notice Edit roles of the given member of the guild to which msgSender belongs\\n  function changeRoles(address msgSender, address user, uint maskRights) internal {\\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.CHANGE_ROLES_7);\\n\\n    if (!_S().members[guildId].contains(user)) revert IAppErrors.NotGuildMember();\\n\\n    // don't allow to change admin rights\\n    IGuildController.GuildData memory guildData = _S().guildData[guildId];\\n    if (guildData.owner == user) {\\n      maskRights |= _getMaskRights(IGuildController.GuildRightBits.ADMIN_0);\\n    } else if ((maskRights & _getMaskRights(IGuildController.GuildRightBits.ADMIN_0)) != 0) {\\n      maskRights ^= _getMaskRights(IGuildController.GuildRightBits.ADMIN_0);\\n    }\\n\\n    _S().rights[user] = maskRights;\\n\\n    emit IApplicationEvents.ChangeGuildRights(guildId, user, maskRights);\\n  }\\n\\n  /// @notice Remove given member from the guild to which msgSender belongs\\n  /// @dev To delete the guild the owner should remove all members and remove himself at the end\\n  function removeGuildMember(address msgSender, address userToRemove) internal {\\n    uint guildId;\\n    if (msgSender == userToRemove) {\\n      guildId = _S().memberToGuild[msgSender]; // user is always able to remove himself from a guild\\n      if (guildId == 0) revert IAppErrors.NotGuildMember();\\n    } else {\\n      (guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.REMOVE_MEMBER_5);\\n      if (userToRemove == address(0)) revert IAppErrors.ZeroAddress();\\n    }\\n\\n    IGuildController.GuildData memory guildData = _S().guildData[guildId];\\n    if (guildData.owner == userToRemove) {\\n      // owner can be removed by the last one only\\n      if (_S().members[guildId].length() > 1) revert IAppErrors.CannotRemoveGuildOwnerFromNotEmptyGuild();\\n    }\\n\\n    _S().members[guildId].remove(userToRemove);\\n    delete _S().memberToGuild[userToRemove];\\n    delete _S().rights[userToRemove];\\n\\n    emit IApplicationEvents.RemoveFromGuild(guildId, userToRemove);\\n\\n    uint guildSize = _S().members[guildId].length();\\n    if (guildSize == 0) {\\n      // Last member has left the guild, delete the guild\\n\\n      delete _S().nameToGuild[guildData.guildName];\\n      delete _S().guildData[guildId];\\n\\n      // guild bank is not cleared, guildId is never reused\\n\\n      // todo free shelter if any\\n      emit IApplicationEvents.GuildDeleted(guildId);\\n    }\\n  }\\n\\n  /// @notice Increment level of the guild, pay base_fee * new level\\n  function guildLevelUp(IController controller, address msgSender) internal {\\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.LEVEL_UP_8);\\n\\n    uint8 oldGuildLevel = _S().guildData[guildId].guildLevel;\\n    if (oldGuildLevel == MAX_LEVEL) revert IAppErrors.GuildHasMaxLevel(oldGuildLevel);\\n\\n    // level up\\n    uint8 guildLevel = oldGuildLevel + 1;\\n    _S().guildData[guildId].guildLevel = guildLevel;\\n\\n    // pay for level up\\n    uint fee = getBaseFee() * guildLevel;\\n    IHeroTokensVault(IUserController(controller.userController()).userTokensVault()).process(controller.gameToken(), fee, msgSender);\\n\\n    emit IApplicationEvents.GuildLevelUp(guildId, guildLevel);\\n  }\\n\\n  /// @notice Rename the guild, pay base_fee\\n  function rename(IController controller, address msgSender, string memory newGuildName) internal {\\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.RENAME_1);\\n\\n    // check guild name\\n    if (_S().nameToGuild[newGuildName] != 0) revert IAppErrors.NameTaken();\\n    if (bytes(newGuildName).length >= MAX_GUILD_NAME_LENGTH) revert IAppErrors.TooBigName();\\n    if (!StringLib.isASCIILettersOnly(newGuildName)) revert IAppErrors.WrongSymbolsInTheName();\\n    if (bytes(newGuildName).length == 0) revert IAppErrors.EmptyNameNotAllowed();\\n\\n    // rename\\n    string memory oldGuildName = _S().guildData[guildId].guildName;\\n    delete _S().nameToGuild[oldGuildName]; // old name is free to use now\\n\\n    _S().guildData[guildId].guildName = newGuildName;\\n    _S().nameToGuild[newGuildName] = guildId;\\n\\n    // pay for renaming\\n    IHeroTokensVault(IUserController(controller.userController()).userTokensVault()).process(controller.gameToken(), getBaseFee(), msgSender);\\n\\n    emit IApplicationEvents.GuildRename(guildId, newGuildName);\\n  }\\n\\n  /// @notice Free change of the guild logo\\n  function changeLogo(address msgSender, string memory newLogoUrl) internal {\\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.CHANGE_LOGO_2);\\n\\n    // check logo url, empty logo and duplicates are allowed\\n    if (bytes(newLogoUrl).length >= MAX_LOGO_URL_LENGTH) revert IAppErrors.TooLongUrl();\\n\\n    // free change (no payment)\\n    _S().guildData[guildId].urlLogo = newLogoUrl;\\n\\n    emit IApplicationEvents.GuildLogoChanged(guildId, newLogoUrl);\\n  }\\n\\n  /// @notice Set relation between two guilds\\n  function setRelation(address msgSender, uint otherGuildId, bool peace) internal {\\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.SET_RELATION_KIND_9);\\n\\n    // todo check alliances: it's not allowed to set war-relation to the co-member of the alliance\\n\\n    _S().relationsPeaceful[_getGuildsPairKey(guildId, otherGuildId)] = peace;\\n\\n    emit IApplicationEvents.SetGuildRelation(guildId, otherGuildId, peace);\\n  }\\n\\n  function setToHelperRatio(address msgSender, uint8 value) internal {\\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.SET_TO_HELPER_RATIO_11);\\n    validateToHelperRatio(value);\\n\\n    _S().guildData[guildId].toHelperRatio = value;\\n  }\\n  //endregion ------------------------ ACTIONS\\n\\n  //region ------------------------ Guild bank\\n  /// @notice Deploy guild bank contract instance\\n  function _deployNewGuildBank(address guildController, uint guildId) internal returns (address deployed) {\\n    // Assume that this internal function can be called by GuildController only, so there are no restriction checks here\\n    deployed = address(new GuildBank(guildController, guildId));\\n\\n    emit IApplicationEvents.GuildBankDeployed(guildId, deployed);\\n  }\\n\\n  /// @notice Transfer given {amount} of {token} from guild bank to {recipient}\\n  function transfer(address msgSender, address token, address recipient, uint amount) internal {\\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.BANK_TOKENS_OPERATION_6);\\n\\n    IGuildBank guildBank = IGuildBank(_S().guildBanks[guildId]);\\n    guildBank.transfer(token, recipient, amount);\\n\\n    emit IApplicationEvents.TransferFromGuildBank(msgSender, token, amount, recipient);\\n  }\\n\\n  /// @notice Transfer given {nfts} from guild bank to {recipient}\\n  function transferNftMulti(address msgSender, address recipient, address[] memory nfts, uint256[] memory tokenIds) internal {\\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.BANK_ITEMS_OPERATION_10);\\n\\n    IGuildBank guildBank = IGuildBank(_S().guildBanks[guildId]);\\n    guildBank.transferNftMulti(recipient, nfts, tokenIds);\\n\\n    emit IApplicationEvents.TransferNftFromGuildBank(msgSender, nfts, tokenIds, recipient);\\n  }\\n\\n  //endregion ------------------------ Guild bank\\n\\n  //region ------------------------ Internal logic\\n  /// @notice Check if the {user} has given permission in the guild. Permissions are specified by bitmask {rights}.\\n  /// Admin is marked by zero bit, he has all permissions always.\\n  function _checkPermissions(address user, IGuildController.GuildRightBits right) internal view returns (uint guildId, uint rights) {\\n    guildId = _S().memberToGuild[user];\\n    rights = _S().rights[user];\\n\\n    if (guildId == 0) revert IAppErrors.NotGuildMember();\\n\\n    if (!(\\n      (rights & (2**uint(IGuildController.GuildRightBits.ADMIN_0))) != 0\\n      || (rights & (2**uint(right))) != 0\\n    )) {\\n      revert IAppErrors.GuildActionForbidden(uint(right));\\n    }\\n  }\\n\\n  /// @notice Max number of guild members depends on guildLevel as 25 + 5 * level\\n  function _getMaxMembersNumber(uint8 guildLevel) internal pure returns (uint) {\\n    return MAX_GUILD_MEMBERS_ON_LEVEL_1 + (guildLevel - 1) * MAX_GUILD_MEMBERS_INC_PER_LEVEL;\\n  }\\n\\n  /// @notice Generate unique pair key for (G1, G2). Guarantee that F(G1, G2) == F(G2, G1)\\n  function _getGuildsPairKey(uint guildId1, uint guildId2) internal pure returns (bytes32) {\\n    return guildId1 < guildId2\\n      ? keccak256(abi.encodePacked(guildId1, guildId2))\\n      : keccak256(abi.encodePacked(guildId2, guildId1));\\n  }\\n\\n  /// @notice Generate mask-rights with given permission\\n  function _getMaskRights(IGuildController.GuildRightBits right) internal pure returns (uint) {\\n    return 2 ** uint(right);\\n  }\\n\\n  function validateToHelperRatio(uint8 toHelperRatio) internal pure {\\n    if (toHelperRatio > ReinforcementControllerLib._TO_HELPER_RATIO_MAX) revert IAppErrors.MaxFee(toHelperRatio);\\n    if (toHelperRatio < ReinforcementControllerLib._FEE_MIN) revert IAppErrors.MinFee(toHelperRatio);\\n  }\\n\\n  //endregion ------------------------ Internal logic\\n}\\n\",\"keccak256\":\"0x78f4cb227bf6257eaf4568273a5d794057c20b1e8934d8dfbe8d666f61e8bf44\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PackingLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\n\\nlibrary PackingLib {\\n\\n  error TooHighValue(uint value);\\n  error OutOfBounds(uint index, uint length);\\n  error UnexpectedValue(uint expected, uint actual);\\n  error WrongValue(uint newValue, uint actual);\\n  error LengthsMismatch();\\n  error IntOutOfRange(int value);\\n  error ZeroValue();\\n  /// @notice packCustomDataChange requires an input string with two zero bytes at the beginning\\n  ///         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// This error happens if these bytes are not zero\\n  error IncompatibleInputString();\\n\\n  //////////////////////////\\n  // ---- PACKING LOGIC ----\\n  //////////////////////////\\n\\n  //region ------------------------------------ COMMON\\n\\n  function packNftId(address token, uint id) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n  }\\n\\n  function unpackNftId(bytes32 data) internal pure returns (address token, uint id) {\\n    token = address(uint160(uint(data)));\\n    id = uint(data) >> 160;\\n  }\\n\\n  function packAddressWithAmount(address token, uint amount) internal pure returns (bytes32 data) {\\n    if (amount > uint(type(uint96).max)) revert TooHighValue(amount);\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(uint96(amount))) << 160;\\n  }\\n\\n  function unpackAddressWithAmount(bytes32 data) internal pure returns (address token, uint amount) {\\n    token = address(uint160(uint(data)));\\n    amount = uint(data) >> 160;\\n  }\\n\\n  function packItemMintInfo(address item, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(chance)) << 160;\\n  }\\n\\n  function unpackItemMintInfo(bytes32 data) internal pure returns (address item, uint32 chance) {\\n    item = address(uint160(uint(data)));\\n    chance = uint32(uint(data) >> 160);\\n  }\\n\\n  /// @param customDataIndex We assume, that two lowest bytes of this string are always zero\\n  /// So, the string looks like following: 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// Last 2 bytes will be used to encode {value}\\n  function packCustomDataChange(bytes32 customDataIndex, int16 value) internal pure returns (bytes32 data) {\\n    if (uint(customDataIndex) != (uint(customDataIndex) >> 16) << 16) revert IncompatibleInputString();\\n    data = bytes32(uint(customDataIndex));\\n    data |= bytes32(uint(uint16(value)));\\n  }\\n\\n  function unpackCustomDataChange(bytes32 data) internal pure returns (bytes32 customDataIndex, int16 value) {\\n    customDataIndex = bytes32((uint(data) >> 16) << 16);\\n    value = int16(int(uint(uint16(uint(data)))));\\n  }\\n\\n  /// @dev min(uint64) + max(uint64) + isHeroData/isMandatory(uint8)\\n  function packCustomDataRequirements(uint64 min, uint64 max, bool key) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(min));\\n    data |= bytes32(uint(max)) << 64;\\n    data |= bytes32(uint(key ? uint8(1) : uint8(0))) << (64 + 64);\\n  }\\n\\n  function unpackCustomDataRequirements(bytes32 data) internal pure returns (uint64 min, uint64 max, bool key) {\\n    min = uint64(uint(data));\\n    max = uint64(uint(data) >> 64);\\n    key = uint8(uint(data) >> (64 + 64)) == uint8(1);\\n  }\\n\\n  function packStatsChange(\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(experience));\\n    data |= bytes32(uint(uint32(heal))) << 32;\\n    data |= bytes32(uint(uint32(manaRegen))) << (32 + 32);\\n    data |= bytes32(uint(uint32(lifeChancesRecovered))) << (32 + 32 + 32);\\n    data |= bytes32(uint(uint32(damage))) << (32 + 32 + 32 + 32);\\n    data |= bytes32(uint(uint32(manaConsumed))) << (32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackStatsChange(bytes32 data) internal pure returns (\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) {\\n    experience = uint32(uint(data));\\n    heal = int32(int(uint(data) >> 32));\\n    manaRegen = int32(int(uint(data) >> (32 + 32)));\\n    lifeChancesRecovered = int32(int(uint(data) >> (32 + 32 + 32)));\\n    damage = int32(int(uint(data) >> (32 + 32 + 32 + 32)));\\n    manaConsumed = int32(int(uint(data) >> (32 + 32 + 32 + 32 + 32)));\\n  }\\n  //endregion ------------------------------------ COMMON\\n\\n  //region ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(bytes20(objectAddress));\\n    packedData |= bytes32(uint(objectId) << 32);\\n    packedData |= bytes32(uint(objectType) << 24);\\n  }\\n\\n  function unpackMapObject(bytes32 packedData) internal pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\\n    objectAddress = address(bytes20(packedData));\\n    objectId = uint64(uint(packedData) >> 32);\\n    objectType = uint8(uint(packedData) >> 24);\\n  }\\n\\n  function packCoordinate(uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(x));\\n    packedData |= bytes32(uint(y) << 128);\\n  }\\n\\n  function unpackCoordinate(bytes32 packedData) internal pure returns (uint128 x, uint128 y) {\\n    x = uint128(uint(packedData));\\n    y = uint128(uint(packedData) >> 128);\\n  }\\n\\n  /// @param x Assume x <= max uint64\\n  /// @param y Assume y <= max uint64\\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    // 256 => 128 + 128;\\n    // 1) 128 is used for biomeMapFieldId, territoryNumber and probably other fields in the future\\n    // 2) 128 is used to store x, y as uint64, uint64\\n\\n    // we will use uint64 for coordinates assuming it is more than enough for biome map\\n    packedData = bytes32(uint(biomeMapFieldId));\\n    packedData |= bytes32(uint(territoryNumber) << (8));\\n    packedData |= bytes32(uint(uint64(x)) << 128);\\n    packedData |= bytes32(uint(uint64(y)) << (64 + 128));\\n  }\\n\\n  function unpackBattlefieldId(bytes32 packedData) internal pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\\n    biomeMapFieldId = uint8(uint(packedData));\\n    territoryNumber = uint8(uint(packedData) >> (8));\\n    x = uint128(uint64(uint(packedData) >> (128)));\\n    y = uint128(uint64(uint(packedData) >> (64 + 128)));\\n  }\\n  //endregion ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  //region ------------------------------------ REINFORCEMENT\\n\\n  function packReinforcementHeroInfo(uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(biome));\\n    packedData |= bytes32(uint(score) << 8);\\n    packedData |= bytes32(uint(fee) << (8 + 128));\\n    packedData |= bytes32(uint(stakeTs) << (8 + 128 + 8));\\n  }\\n\\n  function unpackReinforcementHeroInfo(bytes32 packedData) internal pure returns (uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) {\\n    biome = uint8(uint(packedData));\\n    score = uint128(uint(packedData) >> 8);\\n    fee = uint8(uint(packedData) >> (8 + 128));\\n    stakeTs = uint64(uint(packedData) >> (8 + 128 + 8));\\n  }\\n  //endregion ------------------------------------ REINFORCEMENT\\n\\n  //region ------------------------------------ DUNGEON\\n\\n  function packDungeonKey(address heroAdr, uint80 heroId, uint16 dungLogicNum) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(dungLogicNum)) << (160 + 80);\\n  }\\n\\n  function unpackDungeonKey(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 dungLogicNum) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    dungLogicNum = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  // --- GAME OBJECTS ---\\n\\n  function packIterationKey(address heroAdr, uint64 heroId, uint32 objId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(objId)) << (160 + 64);\\n  }\\n\\n  function unpackIterationKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint32 objId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    objId = uint32(uint(data) >> (160 + 64));\\n  }\\n\\n  function packMonsterStats(\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(level));\\n    data |= bytes32(uint(race)) << 8;\\n    data |= bytes32(uint(experience)) << (8 + 8);\\n    data |= bytes32(uint(maxDropItems)) << (8 + 8 + 32);\\n  }\\n\\n  function unpackMonsterStats(bytes32 data) internal pure returns (\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) {\\n    level = uint8(uint(data));\\n    race = uint8(uint(data) >> 8);\\n    experience = uint32(uint(data) >> (8 + 8));\\n    maxDropItems = uint8(uint(data) >> (8 + 8 + 32));\\n  }\\n\\n  function packAttackInfo(\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(attackToken)));\\n    data |= bytes32(uint(attackTokenId)) << 160;\\n    data |= bytes32(uint(attackType)) << (160 + 64);\\n  }\\n\\n  function unpackAttackInfo(bytes32 data) internal pure returns (\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) {\\n    attackToken = address(uint160(uint(data)));\\n    attackTokenId = uint64(uint(data) >> 160);\\n    attackType = uint8(uint(data) >> (160 + 64));\\n  }\\n\\n  function packPlayedObjKey(address heroAdr, uint64 heroId, uint8 oType, uint8 biome) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(oType)) << (160 + 64);\\n    data |= bytes32(uint(biome)) << (160 + 64 + 8);\\n  }\\n\\n  function unpackPlayedObjKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint8 oType, uint8 biome) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    oType = uint8(uint(data) >> (160 + 64));\\n    biome = uint8(uint(data) >> (160 + 64 + 8));\\n  }\\n\\n  function packGeneratedMonster(bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint8(generated ? 1 : 0)));\\n    data |= bytes32(uint(amplifier)) << 8;\\n    data |= bytes32(uint(uint32(hp))) << (8 + 32);\\n    data |= bytes32(uint(turnCounter)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 data) internal pure returns (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) {\\n    generated = uint8(uint(data)) == uint8(1);\\n    amplifier = uint32(uint(data) >> 8);\\n    hp = int32(int(uint(data) >> (8 + 32)));\\n    turnCounter = uint8(uint(data) >> (8 + 32 + 32));\\n  }\\n  //endregion ------------------------------------ DUNGEON\\n\\n  //region ------------------------------------ ITEMS\\n\\n  /// @notice itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n  /// @param itemType This is ItemType enum\\n  function packItemMeta(\\n    uint8 itemMetaType,\\n    uint8 itemLvl,\\n    uint8 itemType,\\n    uint16 baseDurability,\\n    uint8 defaultRarity,\\n    uint8 minAttr,\\n    uint8 maxAttr,\\n    uint32 manaCost,\\n    IStatController.CoreAttributes memory req\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(itemMetaType));\\n    data |= bytes32(uint(itemLvl)) << 8;\\n    data |= bytes32(uint(itemType)) << (8 + 8);\\n    data |= bytes32(uint(baseDurability)) << (8 + 8 + 8);\\n    data |= bytes32(uint(defaultRarity)) << (8 + 8 + 8 + 16);\\n    data |= bytes32(uint(minAttr)) << (8 + 8 + 8 + 16 + 8);\\n    data |= bytes32(uint(maxAttr)) << (8 + 8 + 8 + 16 + 8 + 8);\\n    data |= bytes32(uint(manaCost)) << (8 + 8 + 8 + 16 + 8 + 8 + 8);\\n    data |= bytes32(uint(int(req.strength))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32);\\n    data |= bytes32(uint(int(req.dexterity))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32);\\n    data |= bytes32(uint(int(req.vitality))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(req.energy))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemMeta(bytes32 data) internal pure returns (IItemController.ItemMeta memory) {\\n    IItemController.ItemMeta memory result;\\n\\n    result.itemMetaType = uint8(uint(data));\\n    result.itemLevel = uint8(uint(data) >> 8);\\n    result.itemType = IItemController.ItemType(uint8(uint(data) >> (8 + 8)));\\n    result.baseDurability = uint16(uint(data) >> (8 + 8 + 8));\\n    result.defaultRarity = uint8(uint(data) >> (8 + 8 + 8 + 16));\\n    result.minRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8));\\n    result.maxRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8));\\n    result.manaCost = uint32(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8));\\n    result.requirements.strength = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32)));\\n    result.requirements.dexterity = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32)));\\n    result.requirements.vitality = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32)));\\n    result.requirements.energy = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32)));\\n\\n    return result;\\n  }\\n\\n  function packItemGenerateInfo(uint8 id, int32 min, int32 max, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(id));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(chance)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32 data) internal pure returns (uint8 id, int32 min, int32 max, uint32 chance) {\\n    id = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    chance = uint32(uint(data) >> (8 + 32 + 32));\\n  }\\n\\n  function packItemAttackInfo(\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attackType));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(int(factorStr))) << (8 + 32 + 32);\\n    data |= bytes32(uint(int(factorDex))) << (8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorVit))) << (8 + 32 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorEng))) << (8 + 32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 data) internal pure returns (\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) {\\n    attackType = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    factorStr = int32(int(uint(data) >> (8 + 32 + 32)));\\n    factorDex = int32(int(uint(data) >> (8 + 32 + 32 + 32)));\\n    factorVit = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32)));\\n    factorEng = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packItemInfo(uint8 rarity, uint8 augmentationLevel, uint16 durability) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(rarity));\\n    data |= bytes32(uint(augmentationLevel)) << 8;\\n    data |= bytes32(uint(durability)) << (8 + 8);\\n  }\\n\\n  function unpackItemInfo(bytes32 data) internal pure returns (uint8 rarity, uint8 augmentationLevel, uint16 durability) {\\n    rarity = uint8(uint(data));\\n    augmentationLevel = uint8(uint(data) >> 8);\\n    durability = uint16(uint(data) >> (8 + 8));\\n  }\\n  //endregion ------------------------------------ ITEMS\\n\\n  //region ------------------------------------ STORIES\\n\\n  function packStoryPageId(uint16 storyId, uint16 pageId, uint8 heroClass) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n  }\\n\\n  function unpackStoryPageId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n  }\\n\\n  function packStoryAnswerId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n  }\\n\\n  function unpackStoryAnswerId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n  }\\n\\n  function packStoryNextPagesId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(resultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryNextPagesId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    resultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryAttributeRequirement(uint8 attributeIndex, int32 value, bool isCore) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attributeIndex));\\n    data |= bytes32(uint(uint32(value))) << 8;\\n    data |= bytes32(uint(isCore ? uint8(1) : uint8(0))) << (8 + 32);\\n  }\\n\\n  function unpackStoryAttributeRequirement(bytes32 data) internal pure returns (uint8 attributeIndex, int32 value, bool isCore) {\\n    attributeIndex = uint8(uint(data));\\n    value = int32(int(uint(data) >> 8));\\n    isCore = uint8(uint(data) >> (8 + 32)) == uint8(1);\\n  }\\n\\n  function packStoryItemRequirement(address item, bool requireItemBurn, bool requireItemEquipped) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(requireItemBurn ? uint8(1) : uint8(0))) << 160;\\n    data |= bytes32(uint(requireItemEquipped ? uint8(1) : uint8(0))) << (160 + 8);\\n  }\\n\\n  function unpackStoryItemRequirement(bytes32 data) internal pure returns (address item, bool requireItemBurn, bool requireItemEquipped) {\\n    item = address(uint160(uint(data)));\\n    requireItemBurn = uint8(uint(data) >> 160) == uint8(1);\\n    requireItemEquipped = uint8(uint(data) >> (160 + 8)) == uint8(1);\\n  }\\n\\n  /// @dev max amount is 309,485,009 for token with 18 decimals\\n  function packStoryTokenRequirement(address token, uint88 amount, bool requireTransfer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(amount)) << 160;\\n    data |= bytes32(uint(requireTransfer ? uint8(1) : uint8(0))) << (160 + 88);\\n  }\\n\\n  function unpackStoryTokenRequirement(bytes32 data) internal pure returns (address token, uint88 amount, bool requireTransfer) {\\n    token = address(uint160(uint(data)));\\n    amount = uint88(uint(data) >> 160);\\n    requireTransfer = uint8(uint(data) >> (160 + 88)) == uint8(1);\\n  }\\n\\n  function packStoryCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(customDataResultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryCustomDataResult(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    customDataResultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryHeroState(uint16 pageId, uint40 heroLastActionTS) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(pageId));\\n    data |= bytes32(uint(heroLastActionTS)) << 16;\\n  }\\n\\n  function unpackStoryHeroState(bytes32 data) internal pure returns (uint16 pageId, uint40 heroLastActionTS) {\\n    pageId = uint16(uint(data));\\n    heroLastActionTS = uint40(uint(data) >> 16);\\n  }\\n\\n  function packStoryHeroStateId(address heroAdr, uint80 heroId, uint16 storyId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(storyId)) << (160 + 80);\\n  }\\n\\n  function unpackStoryHeroStateId(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 storyId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    storyId = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  function packStorySimpleRequirement(uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(randomRequirement));\\n    data |= bytes32(uint(delayRequirement)) << 32;\\n    data |= bytes32(uint(isFinalAnswer ? uint8(1) : uint8(0))) << (32 + 32);\\n  }\\n\\n  function unpackStorySimpleRequirement(bytes32 data) internal pure returns (uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) {\\n    randomRequirement = uint32(uint(data));\\n    delayRequirement = uint32(uint(data) >> 32);\\n    isFinalAnswer = uint8(uint(data) >> (32 + 32)) == uint8(1);\\n  }\\n\\n  function packBreakInfo(uint8 slot, uint64 chance, bool stopIfBroken) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(slot));\\n    data |= bytes32(uint(chance)) << 8;\\n    data |= bytes32(uint(stopIfBroken ? uint8(1) : uint8(0))) << (8 + 64);\\n  }\\n\\n  function unpackBreakInfo(bytes32 data) internal pure returns (uint8 slot, uint64 chance, bool stopIfBurned) {\\n    slot = uint8(uint(data));\\n    chance = uint64(uint(data) >> 8);\\n    stopIfBurned = uint8(uint(data) >> (8 + 64)) == uint8(1);\\n  }\\n  //endregion ------------------------------------ STORIES\\n\\n  ////////////////////////////////////////////////////////////////////////////////////\\n  // ---- ARRAYS LOGIC ----\\n  ////////////////////////////////////////////////////////////////////////////////////\\n\\n  //region ------------------------------------ SIMPLE ARRAYS\\n\\n\\n  function packUint8Array(uint8[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 32) revert OutOfBounds(len, 32);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 8);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {packUint8Array} for small number of items\\n  ///         It allows to exclude dynamic array creation.\\n  function packUint8Array3(uint8 a, uint8 b, uint8 c) internal pure returns (bytes32) {\\n    bytes32 result = bytes32(uint(a));\\n    result |= bytes32(uint(b)) << (1 * 8);\\n    result |= bytes32(uint(c)) << (2 * 8);\\n    return result;\\n  }\\n\\n\\n  function unpackUint8Array(bytes32 data) internal pure returns (uint8[] memory) {\\n    uint8[] memory result = new uint8[](32);\\n    for (uint i = 0; i < 32; i++) {\\n      result[i] = uint8(uint(data) >> (i * 8));\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {unpackUint8Array} for small number of items\\n  ///         It allows to exclude only first 3 values\\n  function unpackUint8Array3(bytes32 data) internal pure returns (uint8 a, uint8 b, uint8 c) {\\n    a = uint8(uint(data));\\n    b = uint8(uint(data) >> (1 * 8));\\n    c = uint8(uint(data) >> (2 * 8));\\n  }\\n\\n  function changeUnit8ArrayWithCheck(bytes32 data, uint index, uint8 value, uint8 expectedPrevValue) internal pure returns (bytes32 newData) {\\n    uint8[] memory arr = unpackUint8Array(data);\\n    if (arr[index] != expectedPrevValue) revert UnexpectedValue(uint(expectedPrevValue), uint(arr[index]));\\n    arr[index] = value;\\n    return packUint8Array(arr);\\n  }\\n\\n  function packInt32Array(int32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i; i < len; i++) {\\n      result |= bytes32(uint(uint32(data[i]))) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackInt32Array(bytes32 data) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = int32(int(uint(data) >> (i * 32)));\\n    }\\n    return result;\\n  }\\n\\n  function packUint32Array(uint32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackUint32Array(bytes32 data) internal pure returns (uint32[] memory) {\\n    uint32[] memory result = new uint32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = uint32(uint(data) >> (i * 32));\\n    }\\n    return result;\\n  }\\n  //endregion ------------------------------------ SIMPLE ARRAYS\\n\\n  //region ------------------------------------ COMPLEX ARRAYS\\n\\n  // We should represent arrays without concrete size.\\n  // For this reason we must not revert on out of bounds but return zero value instead.\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getInt32AsInt24(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n//    if (idx / 8 >= arr.length) {\\n//      return int32(0);\\n//    }\\n//    return int32(int24(int(uint(arr[idx / 8]) >> ((idx % 8) * 32))));\\n//  }\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getUnit8From32Step(bytes32[] memory arr, uint idx) internal pure returns (uint8) {\\n//    if (idx / 8 >= arr.length) {\\n//      return uint8(0);\\n//    }\\n//    return uint8(uint(arr[idx / 8]) >> ((idx % 8) * 32 + 24));\\n//  }\\n\\n  function getInt32Memory(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function getInt32(bytes32[] storage arr, uint idx) internal view returns (int32) {\\n    // additional gas usage, but we should not revert on out of bounds\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function setInt32(bytes32[] storage arr, uint idx, int32 value) internal {\\n    uint pos = idx / 8;\\n    uint shift = (idx % 8) * 32;\\n\\n    uint curLength = arr.length;\\n    if (pos >= curLength) {\\n      arr.push(0);\\n      for (uint i = curLength; i < pos; ++i) {\\n        arr.push(0);\\n      }\\n    }\\n\\n    arr[pos] = bytes32(uint(arr[pos]) & ~(uint(0xffffffff) << shift) | (uint(uint32(value)) & 0xffffffff) << shift);\\n  }\\n\\n  /// @notice Increment {idx}-th item on {value}\\n  function changeInt32(bytes32[] storage arr, uint idx, int32 value) internal returns (int32 newValue, int32 change) {\\n    int32 cur = int32(int(getInt32(arr, idx)));\\n    int newValueI = int(cur) + int(value);\\n    newValue = int32(newValueI);\\n    change = int32(newValueI - int(cur));\\n\\n    setInt32(arr, idx, newValue);\\n  }\\n\\n  function toInt32Array(bytes32[] memory arr, uint size) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](size);\\n    for (uint i = 0; i < arr.length; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= size) break;\\n        result[idx] = getInt32Memory(arr, idx);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array\\n  function toBytes32Array(int32[] memory arr) internal pure returns (bytes32[] memory) {\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n        result[i] |= bytes32(uint(uint32(arr[idx]))) << (j * 32);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array using last 8bytes for ids\\n  ///      we can not use zero values coz will not able to properly unpack it later\\n  function toBytes32ArrayWithIds(int32[] memory arr, uint8[] memory ids) internal pure returns (bytes32[] memory) {\\n    if (arr.length != ids.length) revert LengthsMismatch();\\n\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n\\n//        console.log(\\\"toBytes32ArrayWithIds id: %s, value: %s%s\\\", ids[idx], arr[idx] >= 0 ? '' : '-', arr[idx] >= 0 ? uint(int(arr[idx])) : uint(int(-arr[idx])));\\n\\n        if (arr[idx] > type(int24).max || arr[idx] < type(int24).min) revert IntOutOfRange(int(arr[idx]));\\n        if (arr[idx] == 0) revert ZeroValue();\\n        result[i] |= bytes32(uint(uint24(int24(arr[idx])))) << (j * 32);\\n        result[i] |= bytes32(uint(ids[idx])) << (j * 32 + 24);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev we do not know exact size of array, assume zero values is not acceptable for this array\\n  function toInt32ArrayWithIds(bytes32[] memory arr) internal pure returns (int32[] memory values, uint8[] memory ids) {\\n    uint len = arr.length;\\n    uint size = len * 8;\\n    int32[] memory valuesTmp = new int32[](size);\\n    uint8[] memory idsTmp = new uint8[](size);\\n    uint counter;\\n    for (uint i = 0; i < len; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        // if (idx >= size) break;  // it looks like a useless check\\n        valuesTmp[idx] = int32(int24(int(uint(arr[i]) >> (j * 32)))); // getInt32AsInt24(arr, idx);\\n        idsTmp[idx] = uint8(uint(arr[i]) >> (j * 32 + 24)); // getUnit8From32Step(arr, idx);\\n        if (valuesTmp[idx] == 0) {\\n          break;\\n        }\\n        counter++;\\n      }\\n    }\\n\\n    values = new int32[](counter);\\n    ids = new uint8[](counter);\\n    for (uint i; i < counter; ++i) {\\n      values[i] = valuesTmp[i];\\n      ids[i] = idsTmp[i];\\n    }\\n  }\\n  //endregion ------------------------------------ COMPLEX ARRAYS\\n\\n}\\n\",\"keccak256\":\"0x5cd23c28a36e25e667e6a01b8cc483c2dd47be9abfd0f2d54e6c59d1a1d01884\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ReinforcementControllerLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IDungeonFactory.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IReinforcementController.sol\\\";\\nimport \\\"../lib/CalcLib.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\n\\nlibrary ReinforcementControllerLib {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\\n  using PackingLib for bytes32;\\n  using PackingLib for address;\\n  using PackingLib for uint8[];\\n\\n  //region ------------------------ CONSTANTS\\n\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"reinforcement.controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0x5a053c541e08c6bd7dfc3042a100e83af246544a23ecda1a47bf22b441b00c00;\\n  uint internal constant _SEARCH_WINDOW = 100;\\n  int32 internal constant _ATTRIBUTES_RATIO = 20;\\n  uint internal constant _FEE_MIN = 10;\\n  uint internal constant _TO_HELPER_RATIO_MAX = 50;\\n  uint internal constant _STAKE_REDUCE_DELAY = 7 days;\\n  uint internal constant _DELAY_FACTOR = 2;\\n  uint internal constant _SIP001_COUNT_REQUIRED_SKILLS = 3;\\n  //endregion ------------------------ CONSTANTS\\n\\n  //region ------------------------ VIEWS\\n\\n  function _S() internal pure returns (IReinforcementController.MainState storage s) {\\n    assembly {\\n      s.slot := MAIN_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n\\n  function minLevel() internal view returns (uint8 _minLevel) {\\n    (_minLevel,) = unpackConfig(_S().config);\\n    return _minLevel;\\n  }\\n\\n  function minLifeChances() internal view returns (uint8 _minLifeChances) {\\n    (, _minLifeChances) = unpackConfig(_S().config);\\n    return _minLifeChances;\\n  }\\n\\n  function toHelperRatio(address heroToken, uint heroId) internal view returns (uint) {\\n    return heroInfo(heroToken, heroId).fee;\\n  }\\n\\n  function heroInfo(address heroToken, uint heroId) internal view returns (IReinforcementController.HeroInfo memory) {\\n    return unpackHeroInfo(_S()._stakedHeroes[heroToken.packNftId(heroId)]);\\n  }\\n\\n  function isStaked(address heroToken, uint heroId) internal view returns (bool) {\\n    return heroInfo(heroToken, heroId).biome != 0;\\n  }\\n\\n  function maxScore(uint biome) internal view returns (uint) {\\n    return _S().maxScore[biome];\\n  }\\n\\n  function earned(address heroToken, uint heroId) internal view returns (\\n    address[] memory tokens,\\n    uint[] memory amounts,\\n    address[] memory nfts,\\n    uint[] memory ids\\n  ){\\n    EnumerableMap.AddressToUintMap storage erc20Rewards = _S()._heroTokenRewards[heroToken.packNftId(heroId)];\\n    uint length = erc20Rewards.length();\\n    tokens = new address[](length);\\n    amounts = new uint[](length);\\n    for (uint i; i < length; ++i) {\\n      (tokens[i], amounts[i]) = erc20Rewards.at(i);\\n    }\\n\\n    bytes32[] storage nftRewards = _S()._heroNftRewards[heroToken.packNftId(heroId)];\\n    length = nftRewards.length;\\n    nfts = new address[](length);\\n    ids = new uint[](length);\\n    for (uint i; i < length; ++i) {\\n      (nfts[i], ids[i]) = PackingLib.unpackNftId(nftRewards[i]);\\n    }\\n  }\\n\\n  function heroScoreAdjusted(address heroToken, uint heroId) internal view returns (uint) {\\n    IReinforcementController.HeroInfo memory info = unpackHeroInfo(_S()._stakedHeroes[heroToken.packNftId(heroId)]);\\n    if (info.stakeTs > block.timestamp) {\\n      return 0;\\n    }\\n    uint time = block.timestamp - info.stakeTs;\\n    if (time > _STAKE_REDUCE_DELAY) {\\n      time -= _STAKE_REDUCE_DELAY;\\n    } else {\\n      // if staked less then delay ago hero has 100% scores\\n      return info.score;\\n    }\\n    if (time > _STAKE_REDUCE_DELAY * _DELAY_FACTOR) {\\n      // if hero staked more than delay*2 days return zero\\n      return 0;\\n    }\\n\\n    return info.score * (_STAKE_REDUCE_DELAY * _DELAY_FACTOR - time) / (_STAKE_REDUCE_DELAY * _DELAY_FACTOR);\\n  }\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ GOV ACTIONS\\n\\n  function setMinLevel(bool isGovernance, uint8 value) internal {\\n    if (!isGovernance) revert IAppErrors.NotGovernance(msg.sender);\\n\\n    (, uint8 _minLifeChances) = unpackConfig(_S().config);\\n    _S().config = packConfig(value, _minLifeChances);\\n\\n    emit IApplicationEvents.MinLevelChanged(value);\\n  }\\n\\n  function setMinLifeChances(bool isGovernance, uint8 value) internal {\\n    if (!isGovernance) revert IAppErrors.NotGovernance(msg.sender);\\n\\n    (uint8 _minLevel,) = unpackConfig(_S().config);\\n    _S().config = packConfig(_minLevel, value);\\n\\n    emit IApplicationEvents.MinLifeChancesChanged(value);\\n  }\\n\\n  //endregion ------------------------ GOV ACTIONS\\n\\n  //region ------------------------ USER ACTIONS\\n\\n  /// @notice Mark the hero as staked in _stakedHeroes and _internalIdsByBiomes\\n  /// @param fee [0..._TO_HELPER_RATIO_MAX], higher fee => less score\\n  function stakeHero(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId, uint8 fee) internal {\\n    IReinforcementController.MainState storage s = _S();\\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\\n    if (IERC721(heroToken).ownerOf(heroId) != msgSender) revert IAppErrors.ErrorNotHeroOwner(heroToken, msgSender);\\n\\n    IHeroController hc = IHeroController(controller.heroController());\\n    if (hc.heroClass(heroToken) == 0) revert IAppErrors.ErrorHeroIsNotRegistered(heroToken);\\n\\n    if (IDungeonFactory(controller.dungeonFactory()).currentDungeon(heroToken, heroId) != 0) revert IAppErrors.HeroInDungeon();\\n    if (isStaked(heroToken, heroId)) revert IAppErrors.AlreadyStaked();\\n    if (fee > _TO_HELPER_RATIO_MAX) revert IAppErrors.MaxFee(fee);\\n    if (fee < _FEE_MIN) revert IAppErrors.MinFee(fee);\\n\\n    IStatController statController = IStatController(controller.statController());\\n\\n    {\\n      IStatController.ChangeableStats memory stats = statController.heroStats(heroToken, heroId);\\n      (uint8 _minLevel, uint8 _minLifeChances) = unpackConfig(s.config);\\n      if (stats.level < _minLevel || stats.lifeChances < _minLifeChances) revert IAppErrors.StakeHeroNotStats();\\n      if (stats.lifeChances == 0) revert IAppErrors.ErrorHeroIsDead(heroToken, heroId); // for the case _minLifeChances == 0\\n    }\\n\\n    { // Reinforcement requires 3 skills, see https://discord.com/channels/1134537718039318608/1236334562024620092\\n      uint8[] memory busySlots = statController.heroItemSlots(heroToken, heroId);\\n      uint counter = 0;\\n      if (busySlots.length >= _SIP001_COUNT_REQUIRED_SKILLS) {\\n        for (uint i; i < busySlots.length; ++i) {\\n          if (\\n            (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_1))\\n            || (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_2))\\n            || (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_3))\\n          ) counter++;\\n        }\\n      }\\n      if (counter < _SIP001_COUNT_REQUIRED_SKILLS) revert IAppErrors.ErrorReinforcementRequiresThreeSkills();\\n    }\\n\\n    uint8 biome = hc.heroBiome(heroToken, heroId);\\n    uint score = hc.score(heroToken, heroId);\\n\\n    // score bonus for discount\\n    score += score * (_TO_HELPER_RATIO_MAX - fee) / 10;\\n    EnumerableSet.Bytes32Set storage internalIds = s._internalIdsByBiomes[biome];\\n\\n    internalIds.add(heroToken.packNftId(heroId));\\n\\n    s._stakedHeroes[heroToken.packNftId(heroId)] = packHeroInfo(IReinforcementController.HeroInfo({\\n      biome: biome,\\n      score: score,\\n      fee: fee,\\n      stakeTs: uint64(block.timestamp)\\n    }));\\n\\n    emit IApplicationEvents.HeroStaked(heroToken, heroId, biome, score);\\n  }\\n\\n  /// @notice Reverse operation for {stakeHero}\\n  function withdrawHero(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId) internal {\\n    IReinforcementController.MainState storage s = _S();\\n\\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\\n    if (IERC721(heroToken).ownerOf(heroId) != msgSender) revert IAppErrors.ErrorNotHeroOwner(heroToken, msgSender);\\n    if (IHeroController(controller.heroController()).heroClass(heroToken) == 0) revert IAppErrors.ErrorHeroIsNotRegistered(heroToken);\\n\\n    IReinforcementController.HeroInfo memory _heroInfo = unpackHeroInfo(s._stakedHeroes[heroToken.packNftId(heroId)]);\\n    if (_heroInfo.biome == 0) revert IAppErrors.NotStaked();\\n\\n    s._internalIdsByBiomes[_heroInfo.biome].remove(heroToken.packNftId(heroId));\\n    delete s._stakedHeroes[heroToken.packNftId(heroId)];\\n\\n    emit IApplicationEvents.HeroWithdraw(heroToken, heroId);\\n  }\\n\\n  struct AskHeroContext {\\n    address heroToken;\\n    uint heroId;\\n    uint length;\\n    uint random;\\n    uint floor;\\n    uint idx;\\n    uint loops;\\n    uint i;\\n  }\\n\\n  /// @dev It's view like function but we need to touch slots in oracle function.\\n  function askHero(IController controller, uint biome) internal returns (\\n    address heroToken,\\n    uint heroId,\\n    int32[] memory attributes\\n  ) {\\n    AskHeroContext memory c;\\n    {\\n      IOracle oracle = IOracle(controller.oracle());\\n      EnumerableSet.Bytes32Set storage internalIds = _S()._internalIdsByBiomes[biome];\\n      c.length = internalIds.length();\\n      if (c.length == 0) revert IAppErrors.NoStakedHeroes();\\n\\n      // oracle doesn't allow to pass maxValue = 0, so length == 1 is the special case below\\n      c.idx = c.length == 1 ? 0 : oracle.getRandomNumber(c.length - 1, 0);\\n\\n      c.loops = Math.min(_SEARCH_WINDOW, c.length);\\n\\n      address[] memory heroes = new address[](c.loops);\\n      uint[] memory heroIds = new uint[](c.loops);\\n      uint[] memory heroScores = new uint[](c.loops);\\n      uint totalWeight;\\n\\n      for (; c.i < c.loops; ++c.i) {\\n        if (c.idx >= c.length) {\\n          c.idx = 0;\\n        }\\n        (c.heroToken, c.heroId) = internalIds.at(c.idx).unpackNftId();\\n\\n        uint s = heroScoreAdjusted(c.heroToken, c.heroId);\\n\\n        // make a snapshot from staked heroes\\n        heroes[c.i] = c.heroToken;\\n        heroIds[c.i] = c.heroId;\\n        // increase chance to be called for heroes with higher scores\\n        heroScores[c.i] = s ** 3;\\n        totalWeight += heroScores[c.i];\\n\\n        c.idx++;\\n      }\\n\\n      c.random = oracle.getRandomNumber(1e18, 0);\\n      c.floor = Math.min(totalWeight, c.random % totalWeight);\\n\\n      // roulette wheel selection\\n      for(c.i = 0; c.i < c.loops; ++c.i) {\\n        if (c.floor < heroScores[c.i]) {\\n          c.heroToken = heroes[c.i];\\n          c.heroId = heroIds[c.i];\\n          break;\\n        } else {\\n          c.floor -= heroScores[c.i];\\n        }\\n      }\\n\\n\\n      if (c.heroToken == address(0) || c.heroId == 0) revert IAppErrors.NoStakedHeroes();\\n    }\\n    {\\n      IStatController sc = IStatController(controller.statController());\\n      uint[] memory indexes = new uint[](12);\\n\\n      indexes[0] = uint(IStatController.ATTRIBUTES.STRENGTH);\\n      indexes[1] = uint(IStatController.ATTRIBUTES.DEXTERITY);\\n      indexes[2] = uint(IStatController.ATTRIBUTES.VITALITY);\\n      indexes[3] = uint(IStatController.ATTRIBUTES.ENERGY);\\n      indexes[4] = uint(IStatController.ATTRIBUTES.DAMAGE_MIN);\\n      indexes[5] = uint(IStatController.ATTRIBUTES.DAMAGE_MAX);\\n      indexes[6] = uint(IStatController.ATTRIBUTES.ATTACK_RATING);\\n      indexes[7] = uint(IStatController.ATTRIBUTES.DEFENSE);\\n      indexes[8] = uint(IStatController.ATTRIBUTES.BLOCK_RATING);\\n      indexes[9] = uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE);\\n      indexes[10] = uint(IStatController.ATTRIBUTES.COLD_RESISTANCE);\\n      indexes[11] = uint(IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE);\\n\\n      attributes = _generateReinforcementAttributes(sc, indexes, c.heroToken, c.heroId);\\n    }\\n    emit IApplicationEvents.HeroAsk(c.heroToken, c.heroId);\\n\\n    return (c.heroToken, c.heroId, attributes);\\n  }\\n\\n  /// @dev Only for dungeon. Assume the tokens already sent to this contract.\\n  function registerTokenReward(IController controller, address heroToken, uint heroId, address token, uint amount) internal {\\n    if (controller.dungeonFactory() != msg.sender) revert IAppErrors.ErrorNotDungeonFactory(msg.sender);\\n\\n    EnumerableMap.AddressToUintMap storage rewards = _S()._heroTokenRewards[heroToken.packNftId(heroId)];\\n\\n    (,uint existAmount) = rewards.tryGet(token);\\n    rewards.set(token, existAmount + amount);\\n\\n    emit IApplicationEvents.TokenRewardRegistered(heroToken, heroId, token, amount, existAmount + amount);\\n  }\\n\\n  /// @dev Only for dungeon. Assume the NFT already sent to this contract.\\n  function registerNftReward(IController controller, address heroToken, uint heroId, address token, uint tokenId) internal {\\n    if (controller.dungeonFactory() != msg.sender) revert IAppErrors.ErrorNotDungeonFactory(msg.sender);\\n\\n    _S()._heroNftRewards[heroToken.packNftId(heroId)].push(token.packNftId(tokenId));\\n\\n    emit IApplicationEvents.NftRewardRegistered(heroToken, heroId, token, tokenId);\\n  }\\n\\n  function claimAll(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId) internal {\\n    if (IERC721(heroToken).ownerOf(heroId) != msgSender) revert IAppErrors.ErrorNotHeroOwner(heroToken, msgSender);\\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\\n\\n    _claimAllTokenRewards(heroToken, heroId, msgSender);\\n    _claimAllNftRewards(heroToken, heroId, msgSender);\\n  }\\n\\n  function claimNft(\\n    bool isEoa,\\n    IController controller,\\n    address msgSender,\\n    address heroToken,\\n    uint heroId,\\n    uint countNft\\n  ) internal {\\n    if (IERC721(heroToken).ownerOf(heroId) != msgSender) revert IAppErrors.ErrorNotHeroOwner(heroToken, msgSender);\\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\\n\\n    _claimNftRewards(heroToken, heroId, msgSender, countNft);\\n  }\\n  //endregion ------------------------ USER ACTIONS\\n\\n  //region ------------------------ Internal logic\\n  /// @notice Claim all rewards from {_heroTokenRewards} to {recipient}, remove data from {_heroTokenRewards}\\n  function _claimAllTokenRewards(address heroToken, uint heroId, address recipient) internal {\\n    EnumerableMap.AddressToUintMap storage rewards = _S()._heroTokenRewards[heroToken.packNftId(heroId)];\\n    uint length = rewards.length();\\n    address[] memory tokens = new address[](length);\\n    for (uint i; i < length; ++i) {\\n      (address token, uint amount) = rewards.at(i);\\n      IERC20(token).transfer(recipient, amount);\\n      emit IApplicationEvents.ClaimedToken(heroToken, heroId, token, amount, recipient);\\n\\n      tokens[i] = token;\\n    }\\n\\n    // need to remove after the ordered reading for handle all elements, just remove the struct will not work coz contains mapping inside\\n    for (uint i; i < length; ++i) {\\n      rewards.remove(tokens[i]);\\n    }\\n  }\\n\\n  function _claimAllNftRewards(address heroToken, uint heroId, address recipient) internal {\\n    bytes32[] storage rewards = _S()._heroNftRewards[heroToken.packNftId(heroId)];\\n    uint length = rewards.length;\\n    for (uint i; i < length; ++i) {\\n      (address token, uint id) = rewards[i].unpackNftId();\\n      IERC721(token).safeTransferFrom(address(this), recipient, id);\\n      emit IApplicationEvents.ClaimedItem(heroToken, heroId, token, id, recipient);\\n    }\\n    // a simple array can be just deleted\\n    delete _S()._heroNftRewards[heroToken.packNftId(heroId)];\\n  }\\n\\n  /// @notice Claim last {countNft} NFTs and remove them from {_heroNftRewards}\\n  function _claimNftRewards(address heroToken, uint heroId, address recipient, uint countNft) internal {\\n    bytes32[] storage rewards = _S()._heroNftRewards[heroToken.packNftId(heroId)];\\n\\n    uint length = rewards.length;\\n    uint indexLastToDelete = countNft >= length\\n      ? 0\\n      : length - countNft;\\n\\n    while (length != indexLastToDelete) {\\n      (address token, uint id) = rewards[length - 1].unpackNftId();\\n      IERC721(token).safeTransferFrom(address(this), recipient, id);\\n      emit IApplicationEvents.ClaimedItem(heroToken, heroId, token, id, recipient);\\n      length--;\\n\\n      // if we are going to remove all items we can just delete all items at the end\\n      // otherwise we should pop the items one by one\\n      if (indexLastToDelete != 0) {\\n        rewards.pop();\\n      }\\n    }\\n\\n    if (length == 0) {\\n      delete _S()._heroNftRewards[heroToken.packNftId(heroId)];\\n    }\\n  }\\n\\n  function _generateReinforcementAttributes(IStatController sc, uint[] memory indexes, address heroToken, uint heroId)\\n  internal view returns (int32[] memory attributes) {\\n    attributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < indexes.length; ++i) {\\n      attributes[indexes[i]] = CalcLib.max32(sc.heroAttribute(heroToken, heroId, indexes[i]) * _ATTRIBUTES_RATIO / 100, 1);\\n    }\\n  }\\n  //endregion ------------------------ Internal logic\\n\\n  //region ------------------------ Packing utils\\n\\n  function packHeroInfo(IReinforcementController.HeroInfo memory info) internal pure returns (bytes32) {\\n    return PackingLib.packReinforcementHeroInfo(info.biome, uint128(info.score), info.fee, info.stakeTs);\\n  }\\n\\n  function unpackHeroInfo(bytes32 packed) internal pure returns (IReinforcementController.HeroInfo memory info) {\\n    (info.biome, info.score, info.fee, info.stakeTs) = PackingLib.unpackReinforcementHeroInfo(packed);\\n    return info;\\n  }\\n\\n  function packConfig(uint8 minLevel_, uint8 minLifeChances_) internal pure returns (bytes32) {\\n    return PackingLib.packUint8Array3(minLevel_, minLifeChances_, 0);\\n  }\\n\\n  function unpackConfig(bytes32 packed) internal pure returns (uint8 minLevel_, uint8 minLifeChances_) {\\n    (minLevel_, minLifeChances_,) = PackingLib.unpackUint8Array3(packed);\\n  }\\n\\n  //endregion ------------------------ Packing utils\\n\\n}\\n\",\"keccak256\":\"0x43b691d9c75124bf9f8b498a39cd127ef6c59b85edb01907b9a7e236fe628359\",\"license\":\"BUSL-1.1\"},\"contracts/lib/SlotsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\\n/// @author bogdoslav\\nlibrary SlotsLib {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant SLOT_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  // ************* GETTERS *******************\\n\\n  /// @dev Gets a slot as bytes32\\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as an address\\n  function getAddress(bytes32 slot) internal view returns (address result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as uint256\\n  function getUint(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  // ************* ARRAY GETTERS *******************\\n\\n  /// @dev Gets an array length\\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  // ************* SETTERS *******************\\n\\n  /// @dev Sets a slot with bytes32\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, bytes32 value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with address\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, address value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with uint\\n  function set(bytes32 slot, uint value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x52ede981a6bb509c0dce07a0373e3c073c24fd16ca4ca7fbaa24f6c8b747b45b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StringLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n\\nlibrary StringLib {\\n\\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n  function toString(uint value) external pure returns (string memory) {\\n    return _toString(value);\\n  }\\n\\n  function _toString(uint value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint temp = value;\\n    uint digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  function toAsciiString(address x) external pure returns (string memory) {\\n    return _toAsciiString(x);\\n  }\\n\\n  function _toAsciiString(address x) internal pure returns (string memory) {\\n    bytes memory s = new bytes(40);\\n    for (uint i = 0; i < 20; i++) {\\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n      bytes1 hi = bytes1(uint8(b) / 16);\\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n      s[2 * i] = _char(hi);\\n      s[2 * i + 1] = _char(lo);\\n    }\\n    return string(s);\\n  }\\n\\n  function char(bytes1 b) external pure returns (bytes1 c) {\\n    return _char(b);\\n  }\\n\\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n    else return bytes1(uint8(b) + 0x57);\\n  }\\n\\n  function concat(string memory a, string memory b) internal pure returns (string memory) {\\n    return string(abi.encodePacked(a, b));\\n  }\\n\\n  function isASCIILettersOnly(string memory str) internal pure returns (bool) {\\n    bytes memory b = bytes(str);\\n    for (uint i = 0; i < b.length; i++) {\\n      if (uint8(b[i]) < 32 || uint8(b[i]) > 127) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\",\"keccak256\":\"0xcf94b1e6e63466d0100f5181a080968017995f5019a2cfdb35f1ae4a3b7dab3b\",\"license\":\"BUSL-1.1\"},\"contracts/openzeppelin/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  // To implement this library for multiple types with as little code repetition as possible, we write it in\\n  // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\\n  // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\\n  // This means that we can only create new EnumerableMaps for types that fit in bytes32.\\n\\n  /**\\n   * @dev Query for a nonexistent map key.\\n     */\\n  error EnumerableMapNonexistentKey(bytes32 key);\\n\\n  struct Bytes32ToBytes32Map {\\n    // Storage of keys\\n    EnumerableSet.Bytes32Set _keys;\\n    mapping(bytes32 key => bytes32) _values;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n    map._values[key] = value;\\n    return map._keys.add(key);\\n  }\\n\\n  /**\\n   * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n    delete map._values[key];\\n    return map._keys.remove(key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n    return map._keys.contains(key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n    return map._keys.length();\\n  }\\n\\n  /**\\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n    bytes32 key = map._keys.at(index);\\n    return (key, map._values[key]);\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == bytes32(0)) {\\n      return (contains(map, key), bytes32(0));\\n    } else {\\n      return (true, value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == 0 && !contains(map, key)) {\\n      revert EnumerableMapNonexistentKey(key);\\n    }\\n    return value;\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n    return map._keys.values();\\n  }\\n\\n  // UintToUintMap\\n\\n  struct UintToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key)));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintToAddressMap\\n\\n  struct UintToAddressMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressToUintMap\\n\\n  struct AddressToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n    return remove(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (address(uint160(uint256(key))), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // Bytes32ToUintMap\\n\\n  struct Bytes32ToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, key, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n    return remove(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n    return contains(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (key, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, key);\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, key));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x5052395b3d57e4347a977f96eba69188b4a952594afae411910995ecab5c1d05\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position is the index of the value in the `values` array plus 1.\\n    // Position 0 is used to mean a value is not in the set.\\n    mapping(bytes32 value => uint256) _positions;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._positions[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We cache the value's position to prevent multiple reads from the same storage slot\\n    uint256 position = set._positions[value];\\n\\n    if (position != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 valueIndex = position - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (valueIndex != lastIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the lastValue to the index where the value to delete is\\n        set._values[valueIndex] = lastValue;\\n        // Update the tracked position of the lastValue (that was just moved)\\n        set._positions[lastValue] = position;\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the tracked position for the deleted slot\\n      delete set._positions[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._positions[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n     */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xd5483249a7bac53a40791ade8d640831cdec526eea6b42a4db68f2ce13c008fa\",\"license\":\"MIT\"},\"contracts/openzeppelin/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n  struct InitializableStorage {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n         */\\n    uint64 _initialized;\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n    bool _initializing;\\n  }\\n\\n  // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n  /**\\n   * @dev The contract is already initialized.\\n     */\\n  error InvalidInitialization();\\n\\n  /**\\n   * @dev The contract is not initializing.\\n     */\\n  error NotInitializing();\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n  event Initialized(uint64 version);\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier initializer() {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    // Cache values to avoid duplicated sloads\\n    bool isTopLevelCall = !$._initializing;\\n    uint64 initialized = $._initialized;\\n\\n    // Allowed calls:\\n    // - initialSetup: the contract is not in the initializing state and no previous version was\\n    //                 initialized\\n    // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n    //                 current contract is just being deployed\\n    bool initialSetup = initialized == 0 && isTopLevelCall;\\n    bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n    if (!initialSetup && !construction) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = 1;\\n    if (isTopLevelCall) {\\n      $._initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      $._initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier reinitializer(uint64 version) {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing || $._initialized >= version) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = version;\\n    $._initializing = true;\\n    _;\\n    $._initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n  modifier onlyInitializing() {\\n    _checkInitializing();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n  function _checkInitializing() internal view virtual {\\n    if (!_isInitializing()) {\\n      revert NotInitializing();\\n    }\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n  function _disableInitializers() internal virtual {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing) {\\n      revert InvalidInitialization();\\n    }\\n    if ($._initialized != type(uint64).max) {\\n      $._initialized = type(uint64).max;\\n      emit Initialized(type(uint64).max);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n  function _getInitializedVersion() internal view returns (uint64) {\\n    return _getInitializableStorage()._initialized;\\n  }\\n\\n  /**\\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n  function _isInitializing() internal view returns (bool) {\\n    return _getInitializableStorage()._initializing;\\n  }\\n\\n  /**\\n   * @dev Returns a pointer to the storage namespace.\\n     */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n    assembly {\\n      $.slot := INITIALIZABLE_STORAGE\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x80aa3fc0fc9afdf84bd1a51716150cd13041f42d920a9afa8020ea41cf673809\",\"license\":\"MIT\"},\"contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n\\n  /**\\n    * @dev Muldiv operation overflow.\\n   */\\n  error MathOverflowedMulDiv();\\n\\n  enum Rounding {\\n    Floor, // Toward negative infinity\\n    Ceil, // Toward positive infinity\\n    Trunc, // Toward zero\\n    Expand // Away from zero\\n  }\\n\\n  /**\\n   * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      uint256 c = a + b;\\n      if (c < a) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b > a) return (false, 0);\\n      return (true, a - b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n      if (a == 0) return (true, 0);\\n      uint256 c = a * b;\\n      if (c / a != b) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a / b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a % b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (b == 0) {\\n      // Guarantee the same behavior as in a regular Solidity division.\\n      return a / b;\\n    }\\n\\n    // The following calculation ensures accurate ceiling division without overflow.\\n    // Since a is non-zero, (a - 1) / b will not overflow.\\n    // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n    // but the largest value we can obtain is type(uint256).max - 1, which happens\\n    // when a = type(uint256).max and b = 1.\\n    unchecked {\\n      return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n    unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n      uint256 prod0 = x * y; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n      if (prod1 == 0) {\\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n        // The surrounding unchecked block does not change this fact.\\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n        return prod0 / denominator;\\n      }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n      if (denominator <= prod1) {\\n        revert MathOverflowedMulDiv();\\n      }\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n      uint256 remainder;\\n      assembly {\\n      // Compute remainder using mulmod.\\n        remainder := mulmod(x, y, denominator)\\n\\n      // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n    // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n      uint256 twos = denominator & (0 - denominator);\\n      assembly {\\n      // Divide denominator by twos.\\n        denominator := div(denominator, twos)\\n\\n      // Divide [prod1 prod0] by twos.\\n        prod0 := div(prod0, twos)\\n\\n      // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n\\n    // Shift in bits from prod1 into prod0.\\n      prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n      uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n    // works in modular arithmetic, doubling the correct bits in each step.\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n      result = prod0 * inverse;\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n    unchecked {\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      return min(result, a / result);\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = sqrt(a);\\n      return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 128;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 64;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 32;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 16;\\n      }\\n      if (value >> 8 > 0) {\\n        value >>= 8;\\n        result += 8;\\n      }\\n      if (value >> 4 > 0) {\\n        value >>= 4;\\n        result += 4;\\n      }\\n      if (value >> 2 > 0) {\\n        value >>= 2;\\n        result += 2;\\n      }\\n      if (value >> 1 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log2(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >= 10 ** 64) {\\n        value /= 10 ** 64;\\n        result += 64;\\n      }\\n      if (value >= 10 ** 32) {\\n        value /= 10 ** 32;\\n        result += 32;\\n      }\\n      if (value >= 10 ** 16) {\\n        value /= 10 ** 16;\\n        result += 16;\\n      }\\n      if (value >= 10 ** 8) {\\n        value /= 10 ** 8;\\n        result += 8;\\n      }\\n      if (value >= 10 ** 4) {\\n        value /= 10 ** 4;\\n        result += 4;\\n      }\\n      if (value >= 10 ** 2) {\\n        value /= 10 ** 2;\\n        result += 2;\\n      }\\n      if (value >= 10 ** 1) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log10(value);\\n      return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 16;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 8;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 4;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 2;\\n      }\\n      if (value >> 8 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log256(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n  function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n    return uint8(rounding) % 2 == 1;\\n  }\\n\\n}\\n\",\"keccak256\":\"0x4d972e3e1d79f693b6cb42007d23c27256cb6f087392edea24b93585a822572c\",\"license\":\"MIT\"},\"contracts/proxy/Controllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Initializable.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../lib/SlotsLib.sol\\\";\\n\\n/// @title Implement basic functionality for any contract that require strict control\\n/// @dev Can be used with upgradeable pattern.\\n///      Require call __Controllable_init() in any case.\\n/// @author belbix\\nabstract contract Controllable is Initializable, IControllable {\\n  using SlotsLib for bytes32;\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant CONTROLLABLE_VERSION = \\\"1.0.0\\\";\\n\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.revision\\\")) - 1);\\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.prev_logic\\\")) - 1);\\n\\n  event ContractInitialized(address controller, uint ts, uint block);\\n  event RevisionIncreased(uint value, address oldLogic);\\n\\n  // init implementation contract\\n  constructor() initializer {}\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\n  /// @dev Use it only once after first logic setup\\n  /// @param controller_ Controller address\\n  function __Controllable_init(address controller_) internal onlyInitializing {\\n    _init(controller_);\\n  }\\n\\n  function _init(address controller_) private {\\n    require(controller_ != address(0), \\\"Zero controller\\\");\\n    _CONTROLLER_SLOT.set(controller_);\\n    _CREATED_SLOT.set(block.timestamp);\\n    _CREATED_BLOCK_SLOT.set(block.number);\\n    emit ContractInitialized(controller_, block.timestamp, block.number);\\n  }\\n\\n  /// @dev Return true if given address is controller\\n  function isController(address value_) public override view returns (bool) {\\n    return value_ == controller();\\n  }\\n\\n  /// @notice Return true if given address is setup as governance in Controller\\n  function isGovernance(address value_) public override view returns (bool) {\\n    return IController(controller()).governance() == value_;\\n  }\\n\\n  /// @dev Contract upgrade counter\\n  function revision() external view override returns (uint) {\\n    return _REVISION_SLOT.getUint();\\n  }\\n\\n  /// @dev Previous logic implementation\\n  function previousImplementation() external view override returns (address) {\\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\\n  }\\n\\n  // ************* SETTERS/GETTERS *******************\\n\\n  /// @notice Return controller address saved in the contract slot\\n  function controller() public view override returns (address) {\\n    return _CONTROLLER_SLOT.getAddress();\\n  }\\n\\n  /// @notice Return creation timestamp\\n  /// @return Creation timestamp\\n  function created() external view override returns (uint256) {\\n    return _CREATED_SLOT.getUint();\\n  }\\n\\n  /// @notice Return creation block number\\n  /// @return Creation block number\\n  function createdBlock() external override view returns (uint256) {\\n    return _CREATED_BLOCK_SLOT.getUint();\\n  }\\n\\n  /// @dev Revision should be increased on each contract upgrade\\n  function increaseRevision(address oldLogic) external override {\\n    require(msg.sender == address(this), \\\"Increase revision forbidden\\\");\\n    uint r = _REVISION_SLOT.getUint() + 1;\\n    _REVISION_SLOT.set(r);\\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\\n    emit RevisionIncreased(r, oldLogic);\\n  }\\n\\n}\\n\",\"keccak256\":\"0x1edc53f0d11834bebf4485746d04112ed10db9d4cb19b4945362c593ebf97daf\",\"license\":\"BUSL-1.1\"},\"contracts/relay/ERC2771Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.1;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\n// based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol\\nabstract contract ERC2771Context {\\n  // for whitelist new relayers need to add new constants and update proxies\\n  address private constant GELATO_RELAY_1_BALANCE_ERC_2771 = 0xd8253782c45a12053594b9deB72d8e8aB2Fca54c;\\n  address private constant SACRA_RELAY = 0x52CEba41Da235Af367bFC0b0cCd3314cb901bB5F;\\n\\n  function isTrustedForwarder(address forwarder) public view virtual returns (bool){\\n    return forwarder == GELATO_RELAY_1_BALANCE_ERC_2771 || forwarder == SACRA_RELAY;\\n  }\\n\\n  function _msgSender() internal view virtual returns (address sender) {\\n    if (isTrustedForwarder(msg.sender)) {\\n      // The assembly code is more direct than the Solidity version using `abi.decode`.\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n      }\\n      return sender;\\n    } else {\\n      return msg.sender;\\n    }\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    if (isTrustedForwarder(msg.sender)) {\\n      return msg.data[: msg.data.length - 20];\\n    } else {\\n      return msg.data;\\n    }\\n  }\\n\\n  /// @notice Return true if given address is not a smart contract but a wallet address.\\n  /// @dev It is not 100% guarantee after EIP-3074 implementation, use it as an additional check.\\n  /// @return true if the address is a wallet.\\n  function _isNotSmartContract() internal view returns (bool) {\\n    return isTrustedForwarder(msg.sender) || msg.sender == tx.origin;\\n  }\\n\\n  function onlyEOA() internal view {\\n    if (!_isNotSmartContract()) {\\n      revert IAppErrors.NotEOA(msg.sender);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x1ca981a603a741a635268b53ecde2ea35fa994a4a809e1a4947e47ba8cc565ee\",\"license\":\"MIT\"},\"contracts/solady/LibPRNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for generating pseudorandom numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\\n/// @author LazyShuffler based on NextShuffler by aschlosberg (divergencearran)\\n/// (https://github.com/divergencetech/ethier/blob/main/contracts/random/NextShuffler.sol)\\nlibrary LibPRNG {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The initial length must be greater than zero and less than `2**32 - 1`.\\n    error InvalidInitialLazyShufflerLength();\\n\\n    /// @dev The new length must not be less than the current length.\\n    error InvalidNewLazyShufflerLength();\\n\\n    /// @dev The lazy shuffler has not been initialized.\\n    error LazyShufflerNotInitialized();\\n\\n    /// @dev Cannot double initialize the lazy shuffler.\\n    error LazyShufflerAlreadyInitialized();\\n\\n    /// @dev The lazy shuffle has finished.\\n    error LazyShuffleFinished();\\n\\n    /// @dev The queried index is out of bounds.\\n    error LazyShufflerGetOutOfBounds();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pseudorandom number state in memory.\\n    struct PRNG {\\n        uint256 state;\\n    }\\n\\n    /// @dev A lazy Fisher-Yates shuffler for a range `[0..n)` in storage.\\n    struct LazyShuffler {\\n        // Bits Layout:\\n        // - [0..31]    `numShuffled`\\n        // - [32..223]  `permutationSlot`\\n        // - [224..255] `length`\\n        uint256 _state;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Seeds the `prng` with `state`.\\n    function seed(PRNG memory prng, uint256 state) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(prng, state)\\n        }\\n    }\\n\\n    /// @dev Returns the next pseudorandom uint256.\\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\\n        // We simply use `keccak256` for a great balance between\\n        // runtime gas costs, bytecode size, and statistical properties.\\n        //\\n        // A high-quality LCG with a 32-byte state\\n        // is only about 30% more gas efficient during runtime,\\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\\n        // when this function is inlined.\\n        //\\n        // Using this method is about 2x more efficient than\\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n        }\\n    }\\n\\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\\n    /// between 0 (inclusive) and `upper` (exclusive).\\n    /// If your modulus is big, this method is recommended\\n    /// for uniform sampling to avoid modulo bias.\\n    /// For uniform sampling across all uint256 values,\\n    /// or for small enough moduli such that the bias is neligible,\\n    /// use {next} instead.\\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := keccak256(prng, 0x20)\\n                mstore(prng, result)\\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\\n            }\\n            result := mod(result, upper)\\n        }\\n    }\\n\\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n\\n                    {\\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                let b := add(a, 0x01)\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let o := mod(shr(128, r), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n\\n                    {\\n                        let o := mod(and(r, mask), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the standard normal distribution denominated in `WAD`.\\n    function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\\n            // The chance of drawing a sample outside 10 \\u03c3 from the standard normal distribution\\n            // is \\u2248 0.000000000000000000000015, which is insignificant for most practical purposes.\\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\\n            let s := 0x1000000000000000100000000000000010000000000000001\\n            let r1 := mulmod(result, a, n)\\n            let r2 := mulmod(r1, a, n)\\n            let r3 := mulmod(r2, a, n)\\n            // forgefmt: disable-next-item\\n            result := sub(sar(96, mul(26614938895861601847173011183,\\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the unit exponential distribution denominated in `WAD`.\\n    function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\\n            // Gas usage varies, starting from about 172+ gas.\\n            let r := keccak256(prng, 0x20)\\n            mstore(prng, r)\\n            let p := shl(129, r)\\n            let w := shl(1, r)\\n            if iszero(gt(w, p)) {\\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n                for {} 1 {} {\\n                    r := mulmod(r, a, n)\\n                    if iszero(lt(shl(129, r), w)) {\\n                        r := mulmod(r, a, n)\\n                        result := add(1000000000000000000, result)\\n                        w := shl(1, r)\\n                        p := shl(129, r)\\n                        if iszero(lt(w, p)) { break }\\n                        continue\\n                    }\\n                    w := shl(1, r)\\n                    if iszero(lt(w, shl(129, r))) { break }\\n                }\\n            }\\n            result := add(div(p, shl(129, 170141183460469231732)), result)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*       STORAGE-BASED RANGE LAZY SHUFFLING OPERATIONS        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Initializes the state for lazy-shuffling the range `[0..n)`.\\n    /// Reverts if `n == 0 || n >= 2**32 - 1`.\\n    /// Reverts if `$` has already been initialized.\\n    /// If you need to reduce the length after initialization, just use a fresh new `$`.\\n    function initialize(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sload($.slot) {\\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, $.slot)\\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Increases the length of `$`.\\n    /// Reverts if `$` has not been initialized.\\n    function grow(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            // If the new length is smaller than the old length, revert.\\n            if lt(n, shr(224, state)) {\\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\\n        }\\n    }\\n\\n    /// @dev Restarts the shuffler by setting `numShuffled` to zero,\\n    /// such that all elements can be drawn again.\\n    /// Restarting does NOT clear the internal permutation, nor changes the length.\\n    /// Even with the same sequence of randomness, reshuffling can yield different results.\\n    function restart(LazyShuffler storage $) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot)\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, shl(32, shr(32, state)))\\n        }\\n    }\\n\\n    /// @dev Returns the number of elements that have been shuffled.\\n    function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := and(0xffffffff, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns the length of `$`.\\n    /// Returns zero if `$` is not initialized, else a non-zero value less than `2**32 - 1`.\\n    function length(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := shr(224, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns if `$` has been initialized.\\n    function initialized(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(iszero(sload($.slot)))\\n        }\\n    }\\n\\n    /// @dev Returns if there are any more elements left to shuffle.\\n    /// Reverts if `$` is not initialized.\\n    function finished(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := eq(shr(224, state), and(0xffffffff, state))\\n        }\\n    }\\n\\n    /// @dev Returns the current value stored at `index`, accounting for all historical shuffling.\\n    /// Reverts if `index` is greater than or equal to the `length` of `$`.\\n    function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            let n := shr(224, state) // Length of `$`.\\n            if iszero(lt(index, n)) {\\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let u32 := gt(n, 0xfffe)\\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\\n            result := and(m, shr(o, sload(s)))\\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\\n        }\\n    }\\n\\n    /// @dev Does a single Fisher-Yates shuffle step, increments the `numShuffled` in `$`,\\n    /// and returns the next value in the shuffled range.\\n    /// `randomness` can be taken from a good-enough source, or a higher quality source like VRF.\\n    /// Reverts if there are no more values to shuffle, which includes the case if `$` is not initialized.\\n    function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function _get(u32_, state_, i_) -> _value {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                _value := and(m_, shr(o_, sload(s_)))\\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\\n            }\\n            function _set(u32_, state_, i_, value_) {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                let v_ := sload(s_) // Bucket slot value.\\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\\n            }\\n            let state := sload($.slot) // The packed value at `$`.\\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\\n            let n := shr(224, state) // Length of `$`.\\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\\n            if iszero(remainder) {\\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\\n            chosen := _get(gt(n, 0xfffe), state, index)\\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdcb71f8dc72bb7384776154ca24d34c23e3c9bcf124bc75f0d2e379f9ebd021d\",\"license\":\"MIT\"},\"contracts/token/GuildBank.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n/**\\n            \\u2592\\u2593\\u2592  \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2593\\n             \\u2592\\u2588\\u2588\\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593  \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n              \\u2592\\u2588\\u2588\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592 \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n               \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592                   \\u2592\\u2588\\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                     \\u2592\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592     \\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                   \\u2592\\u2592\\u2592\\u2592\\u2592   \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                         \\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                       \\u2592\\u2588\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\n                        \\u2592\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592       \\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\n                          \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593   \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                           \\u2592\\u2592\\u2593\\u2593\\u2592   \\u2592\\u2588\\u2588\\u2593\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                  \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                                 \\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                                \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n      \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593                  \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                      \\u2592\\u2593\\u2593\\n    \\u2592\\u2593\\u2588\\u2592   \\u2592\\u2592\\u2588\\u2592\\u2592                   \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2592\\u2593\\u2593\\u2592\\n   \\u2592\\u2592\\u2588\\u2592       \\u2593\\u2592                    \\u2592\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2588\\u2593\\u2592\\n   \\u2593\\u2592\\u2588\\u2588\\u2593\\u2592                             \\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2592\\n    \\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2593\\u2592        \\u2592\\u2592\\u2592         \\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592\\u2592\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2592 \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n     \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2592\\u2592\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2593\\u2593     \\u2593\\u2593  \\u2593\\u2593\\u2588\\u2593   \\u2592\\u2592\\u2593\\u2593   \\u2592\\u2592\\u2588\\u2592   \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n            \\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592  \\u2592\\u2593\\u2593\\u2593\\u2592\\u2588\\u2592   \\u2592\\u2592\\u2592\\u2588\\u2592          \\u2592\\u2592\\u2588\\u2593\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592   \\u2593\\u2588\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\n \\u2592            \\u2592\\u2593\\u2593\\u2588\\u2593  \\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2593  \\u2592\\u2588\\u2593\\u2593\\u2592          \\u2593\\u2593\\u2588\\u2593\\u2592\\u2593\\u2588\\u2593\\u2592\\u2592   \\u2593\\u2588\\u2593        \\u2593\\u2588\\u2588\\u2588\\u2593\\n\\u2593\\u2593\\u2592         \\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592\\u2592\\u2593\\u2588\\u2592   \\u2592\\u2593\\u2588\\u2588\\u2593  \\u2593\\u2588\\u2588\\u2593\\u2592     \\u2592\\u2588\\u2593 \\u2593\\u2593\\u2588\\u2588   \\u2592\\u2593\\u2593\\u2593\\u2592\\u2592\\u2593\\u2588\\u2593        \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2592\\n \\u2588\\u2588\\u2593\\u2593\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592\\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592     \\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592\\n*/\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IGuildBank.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\n\\ncontract GuildBank is IGuildBank {\\n\\n  //region ------------------------ CONSTANTS\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant VERSION = \\\"1.0.0\\\";\\n  //endregion ------------------------ CONSTANTS\\n\\n  //region ------------------------ Members\\n  IGuildController immutable public guildController;\\n  uint immutable public guildId;\\n  //endregion ------------------------ Members\\n\\n  //region ------------------------ Restrictions and constructor\\n  function _onlyGuildController(address msgSender) internal view {\\n    if (msgSender != address(guildController)) revert IAppErrors.GuildControllerOnly();\\n  }\\n\\n  constructor (address guildController_, uint guildId_) {\\n    guildController = IGuildController(guildController_);\\n    guildId = guildId_;\\n  }\\n  //endregion ------------------------ Restrictions and constructor\\n\\n  //region ------------------------ ERC20\\n  function transfer(address token, address recipient, uint amount) external {\\n    _onlyGuildController(msg.sender);\\n\\n    IERC20(token).transfer(recipient, amount);\\n  }\\n\\n  function approve(address token, address spender, uint256 amount) external returns (bool) {\\n    _onlyGuildController(msg.sender);\\n\\n    return IERC20(token).approve(spender, amount);\\n  }\\n  //endregion ------------------------ ERC20\\n\\n  //region ------------------------ ERC721\\n  function transferNft(address to, address nft, uint256 tokenId) external {\\n    _onlyGuildController(msg.sender);\\n\\n    IERC721(nft).transferFrom(address(this), to, tokenId);\\n  }\\n\\n  function transferNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external {\\n    _onlyGuildController(msg.sender);\\n\\n    uint len = nfts.length;\\n    if (len != tokenIds.length) revert IAppErrors.LengthsMismatch();\\n\\n    for (uint i; i < len; ++i) {\\n      IERC721(nfts[i]).transferFrom(address(this), to, tokenIds[i]);\\n    }\\n  }\\n\\n  function approveNft(address to, address nft, uint256 tokenId) external {\\n    _onlyGuildController(msg.sender);\\n\\n    IERC721(nft).approve(to, tokenId);\\n  }\\n\\n  function approveNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external {\\n    _onlyGuildController(msg.sender);\\n\\n    uint len = nfts.length;\\n    if (len != tokenIds.length) revert IAppErrors.LengthsMismatch();\\n\\n    for (uint i; i < len; ++i) {\\n      IERC721(nfts[i]).approve(to, tokenIds[i]);\\n    }\\n  }\\n  //endregion ------------------------ ERC721\\n}\",\"keccak256\":\"0x5680f034d6343a830755b351587c791fefec0b38f64a048ebd3b46a37c6f2d68\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b507ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00805468010000000000000000810460ff1615906001600160401b03166000811580156200005d5750825b90506000826001600160401b031660011480156200007a5750303b155b90508115801562000089575080155b15620000a85760405163f92ee8a960e01b815260040160405180910390fd5b84546001600160401b03191660011785558315620000d757845460ff60401b1916680100000000000000001785555b83156200011e57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b50505050506144e080620001336000396000f3fe60806040523480156200001157600080fd5b5060043610620001e15760003560e01c806399f9e252116200010f578063cca9079411620000aa578063cca907941462000421578063d3f489791462000438578063dee1f0e4146200044f578063df1dd9761462000466578063e68a8bf01462000491578063e79f0e96146200049b578063f2e0023d14620004b2578063f77c479114620004c9578063ffa1ad74146200033157600080fd5b806399f9e25214620003655780639d0bcca0146200037c578063ad1036861462000395578063b429afeb14620003ac578063b648063f14620003c3578063beabacc814620003cd578063c3a9934214620003e4578063c6d5774314620003fb57600080fd5b806346860698116200018057806346860698146200029d5780634fac6ccd14620002b4578063572b6c0514620002cb5780635b7249a714620002e257806366605ba414620002f957806371fb4f0514620003105780637cc963801462000327578063936725ec146200033157600080fd5b806311bc2ca214620001e6578063158914ac14620001ff57806315e812ad146200022b57806319ab453c146200024457806321b741de146200025b578063325a19f114620002725780633b4c9891146200027c5780634593144c1462000293575b600080fd5b620001fd620001f7366004620031da565b620004d3565b005b620002166200021036600462003212565b620004eb565b60405190151581526020015b60405180910390f35b6200023562000502565b60405190815260200162000222565b620001fd620002553660046200324b565b62000513565b620001fd6200026c3660046200324b565b6200063d565b6200023562000652565b620002356200028d3660046200324b565b62000689565b6200023562000696565b620001fd620002ae3660046200326b565b620006c9565b620001fd620002c53660046200324b565b620006de565b62000216620002dc3660046200324b565b620007f7565b620001fd620002f336600462003285565b62000846565b620001fd6200030a366004620031da565b62000860565b6200023562000321366004620031da565b6200087f565b620002356200088c565b62000356604051806040016040528060058152602001640312e302e360dc1b81525081565b60405162000222919062003308565b620001fd620003763660046200331d565b620008ae565b62000386620008c4565b60405162000222919062003354565b620001fd620003a63660046200337f565b620008f7565b62000216620003bd3660046200324b565b6200090c565b620001fd62000933565b620001fd620003de3660046200339d565b62000953565b620001fd620003f536600462003480565b6200096f565b620004126200040c3660046200326b565b62000986565b604051620002229190620035ac565b620001fd6200043236600462003285565b62000993565b6200023562000449366004620035c1565b620009a9565b62000216620004603660046200324b565b620009de565b6200047d620004773660046200326b565b62000a68565b60405162000222969594939291906200363d565b6200023562000ab2565b62000235620004ac3660046200324b565b62000abe565b62000386620004c33660046200326b565b62000acb565b6200038662000ad8565b620004e8620004e162000b0b565b8262000b30565b50565b6000620004f9838362000bd3565b90505b92915050565b60006200050e62000c0b565b905090565b60006200051f62000c44565b805490915060ff600160401b82041615906001600160401b0316600081158015620005475750825b90506000826001600160401b03166001148015620005645750303b155b90508115801562000573575080155b15620005925760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff191660011785558315620005bd57845460ff60401b1916600160401b1785555b620005c88662000c68565b670de0b6b3a7640000620005db62000c7d565b60026000908152602091909152604090205583156200063557845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2906020015b60405180910390a15b505050505050565b620004e86200064b62000b0b565b8262000ca1565b60006200050e6200068560017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b620036cd565b5490565b6000620004fc82620010e5565b60006200050e6200068560017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1620036cd565b620004e8620006d762000ad8565b8262001113565b333014620007315760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b6000620007536200068560016000805160206200448b833981519152620036cd565b62000760906001620036e3565b905062000786816200078360016000805160206200448b833981519152620036cd565b55565b620007b8826200078360017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4620036cd565b7ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c88183604051620007eb929190620036f9565b60405180910390a15050565b60006001600160a01b03821673d8253782c45a12053594b9deb72d8e8ab2fca54c1480620004fc57506001600160a01b0382167352ceba41da235af367bfc0b0ccd3314cb901bb5f1492915050565b6200085c6200085462000b0b565b838362001161565b5050565b620004e86200086e62000ad8565b6200087862000b0b565b8362001420565b6000620004fc82620017f7565b60006200050e6200068560016000805160206200448b833981519152620036cd565b6200085c620008bc62000b0b565b83836200182c565b60006200050e6200068560017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4620036cd565b620004e86200090562000b0b565b82620018c2565b60006200091862000ad8565b6001600160a01b0316826001600160a01b0316149050919050565b620009516200094162000ad8565b6200094b62000b0b565b62001920565b565b6200096a6200096162000b0b565b84848462001bb4565b505050565b6200096a6200097d62000b0b565b84848462001ca9565b6060620004fc8262001d7c565b6200085c620009a162000b0b565b838362001da4565b6000620009d6620009b9620020f9565b620009c362000ad8565b620009cd62000b0b565b87878762002114565b949350505050565b6000816001600160a01b0316620009f462000ad8565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000a32573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000a58919062003710565b6001600160a01b03161492915050565b606080600080600080600062000a7e88620026c8565b805160208201516040830151606084015160a0850151608090950151939d929c50909a50985091965060ff16945092505050565b60006200050e620028a6565b6000620004fc82620028bc565b6000620004fc82620028ea565b60006200050e6200068560017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618620036cd565b600062000b1833620007f7565b1562000b2b575060131936013560601c90565b503390565b600062000b3f83600262002913565b509050609682511062000b6557604051630595c1cb60e01b815260040160405180910390fd5b8162000b7062000c7d565b6000838152600291909101602052604090206001019062000b929082620037b8565b507f6b7abe944ce1beac4e645644ff5549a6f5280e2688588c1156e296f1b02a361f818360405162000bc692919062003884565b60405180910390a1505050565b600062000bdf62000c7d565b600701600062000bf0858562002a07565b815260208101919091526040016000205460ff169392505050565b600062000c1762000c7d565b600060025b600281111562000c305762000c30620036a1565b815260200190815260200160002054905090565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b62000c7262002a6e565b620004e88162002a96565b7f1c4340ff8478a236ed13a5ce46f8e8b8a6037975df340a04c54725978699d10090565b6000816001600160a01b0316836001600160a01b03160362000d0d5762000cc762000c7d565b6001600160a01b03841660009081526004919091016020526040812054915081900362000d0757604051632f6c853960e11b815260040160405180910390fd5b62000d45565b62000d1a83600562002913565b5090506001600160a01b03821662000d455760405163d92e233d60e01b815260040160405180910390fd5b600062000d5162000c7d565b60020160008381526020019081526020016000206040518060c001604052908160008201805462000d829062003730565b80601f016020809104026020016040519081016040528092919081815260200182805462000db09062003730565b801562000e015780601f1062000dd55761010080835404028352916020019162000e01565b820191906000526020600020905b81548152906001019060200180831162000de357829003601f168201915b5050505050815260200160018201805462000e1c9062003730565b80601f016020809104026020016040519081016040528092919081815260200182805462000e4a9062003730565b801562000e9b5780601f1062000e6f5761010080835404028352916020019162000e9b565b820191906000526020600020905b81548152906001019060200180831162000e7d57829003601f168201915b5050509183525050600291909101546001600160a01b038082166020840152600160a01b820460ff908116604080860191909152600160a81b84049091166060850152600160b01b9092046001600160401b031660809093019290925282015191925084811691160362000f5157600162000f3162000f1962000c7d565b60008581526005919091016020526040902062002bc0565b111562000f5157604051630ad25aaf60e21b815260040160405180910390fd5b62000f798362000f6062000c7d565b6000858152600591909101602052604090209062002bcb565b5062000f8462000c7d565b6001600160a01b0384166000908152600491909101602052604081205562000fab62000c7d565b6006016000846001600160a01b03166001600160a01b03168152602001908152602001600020600090557fc1a2a88b40ad3868bcda984d463d13c8a5ae7b0b3c3f56cb17ab7c34b7ad0928828460405162001008929190620036f9565b60405180910390a160006200102062000f1962000c7d565b905080600003620010de576200103562000c7d565b60030182600001516040516200104c91906200389f565b9081526020016040518091039020600090556200106862000c7d565b60008481526002919091016020526040812090620010878282620030b3565b62001097600183016000620030b3565b5060020180546001600160f01b03191690556040518381527fbdb3d45d74febd27a49d5ee308393b18fc559fcb577ecd0892ed9c2a761e8258906020015b60405180910390a15b5050505050565b6000620010f162000c7d565b6001600160a01b03909216600090815260049290920160205250604090205490565b6200111e8262002be2565b80600003620011405760405163273e150360e21b815260040160405180910390fd5b806200114b62000c7d565b6002600090815260209190915260409020555050565b60006200117084600762002913565b5090506200119b836200118262000c7d565b6000848152600591909101602052604090209062002c7d565b620011b957604051632f6c853960e11b815260040160405180910390fd5b6000620011c562000c7d565b60020160008381526020019081526020016000206040518060c0016040529081600082018054620011f69062003730565b80601f0160208091040260200160405190810160405280929190818152602001828054620012249062003730565b8015620012755780601f10620012495761010080835404028352916020019162001275565b820191906000526020600020905b8154815290600101906020018083116200125757829003601f168201915b50505050508152602001600182018054620012909062003730565b80601f0160208091040260200160405190810160405280929190818152602001828054620012be9062003730565b80156200130f5780601f10620012e3576101008083540402835291602001916200130f565b820191906000526020600020905b815481529060010190602001808311620012f157829003601f168201915b5050509183525050600291909101546001600160a01b038082166020840152600160a01b820460ff908116604080860191909152600160a81b84049091166060850152600160b01b9092046001600160401b0316608090930192909252820151919250858116911603620013935762001389600062002ca0565b83179250620013b8565b6200139f600062002ca0565b831615620013b857620013b3600062002ca0565b831892505b82620013c362000c7d565b6001600160a01b038616600081815260069290920160209081526040928390209390935581518581529283015281018490527fb0304e71a23f4e80fbe603bfffc79b824920fec23be1ef0767f676ba3b22077a90606001620010d5565b60006200142f83600162002913565b5090506200143c62000c7d565b600301826040516200144f91906200389f565b9081526020016040518091039020546000146200147f57604051639e4b268560e01b815260040160405180910390fd5b6014825110620014a2576040516370ab3a0360e11b815260040160405180910390fd5b620014ad8262002cc4565b620014cb576040516389974bd960e01b815260040160405180910390fd5b8151600003620014ee5760405163b6f63d6560e01b815260040160405180910390fd5b6000620014fa62000c7d565b6000838152600291909101602052604090208054620015199062003730565b80601f0160208091040260200160405190810160405280929190818152602001828054620015479062003730565b8015620015985780601f106200156c5761010080835404028352916020019162001598565b820191906000526020600020905b8154815290600101906020018083116200157a57829003601f168201915b50505050509050620015a962000c7d565b60030181604051620015bc91906200389f565b90815260200160405180910390206000905582620015d962000c7d565b60008481526002919091016020526040902090620015f89082620037b8565b50816200160462000c7d565b600301846040516200161791906200389f565b908152602001604051809103902081905550846001600160a01b031663490fb76a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001668573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200168e919062003710565b6001600160a01b0316638c1717546040518163ffffffff1660e01b8152600401602060405180830381865afa158015620016cc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620016f2919062003710565b6001600160a01b0316633c8f1bbe866001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200173f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001765919062003710565b6200176f62000c0b565b876040518463ffffffff1660e01b81526004016200179093929190620038bd565b600060405180830381600087803b158015620017ab57600080fd5b505af1158015620017c0573d6000803e3d6000fd5b505050507f957c37926a13c72eb069ef4bc862852a20cd897a1445c25acef64c285a3e3f878284604051620010d592919062003884565b60006200180362000c7d565b600301826040516200181691906200389f565b9081526020016040518091039020549050919050565b60006200183b84600962002913565b509050816200184962000c7d565b60070160006200185a848762002a07565b81526020808201929092526040908101600020805460ff19169315159390931790925581518381529081018590528315158183015290517fa38f02cb01028fc56d5a1c55764e771a6da2ec8205696148f0655ebcf322d8d6916060908290030190a150505050565b6000620018d183600b62002913565b509050620018df8262002d3e565b81620018ea62000c7d565b600092835260029081016020526040909220909101805460ff92909216600160a81b0260ff60a81b199092169190911790555050565b60006200192f82600862002913565b50905060006200193e62000c7d565b60008381526002918201602052604090200154600160a01b900460ff169050600919810162001986576040516302dc77b560e31b815260ff8216600482015260240162000728565b600062001995826001620038e0565b905080620019a262000c7d565b6000858152600291820160205260408120909101805460ff60a01b1916600160a01b60ff94851602179055908216620019da62000c0b565b620019e69190620038fc565b9050856001600160a01b031663490fb76a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001a27573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001a4d919062003710565b6001600160a01b0316638c1717546040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001a8b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001ab1919062003710565b6001600160a01b0316633c8f1bbe876001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001afe573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001b24919062003710565b83886040518463ffffffff1660e01b815260040162001b4693929190620038bd565b600060405180830381600087803b15801562001b6157600080fd5b505af115801562001b76573d6000803e3d6000fd5b50506040805187815260ff861660208201527ff59393d3d727f52fd7d452c581b5b52711e6e44063d1ddf9368817b75fb2c21593500190506200062c565b600062001bc385600662002913565b509050600062001bd262000c7d565b60008381526001919091016020526040908190205490516317d5759960e31b81526001600160a01b0387811660048301528681166024830152604482018690529091169150819063beabacc890606401600060405180830381600087803b15801562001c3d57600080fd5b505af115801562001c52573d6000803e3d6000fd5b5050604080516001600160a01b03808b168252808a16602083015291810187905290871660608201527f3421522a397fda51b3adedf86b5f00270b3cf25e34ae836db9e28a78b198d29f925060800190506200062c565b600062001cb885600a62002913565b509050600062001cc762000c7d565b60008381526001919091016020526040908190205490516361d4c9a160e11b81526001600160a01b039091169150819063c3a993429062001d119088908890889060040162003949565b600060405180830381600087803b15801562001d2c57600080fd5b505af115801562001d41573d6000803e3d6000fd5b505050507f510bbc3f8229fd79dd4d20101e3a636ac34562b81999bc3287c0140d5e610f37868585886040516200062c94939291906200398d565b6060620004fc62001d8c62000c7d565b60008481526005919091016020526040902062002d96565b600062001db384600462002913565b509050600062001dc262000c7d565b60020160008381526020019081526020016000206040518060c001604052908160008201805462001df39062003730565b80601f016020809104026020016040519081016040528092919081815260200182805462001e219062003730565b801562001e725780601f1062001e465761010080835404028352916020019162001e72565b820191906000526020600020905b81548152906001019060200180831162001e5457829003601f168201915b5050505050815260200160018201805462001e8d9062003730565b80601f016020809104026020016040519081016040528092919081815260200182805462001ebb9062003730565b801562001f0c5780601f1062001ee05761010080835404028352916020019162001f0c565b820191906000526020600020905b81548152906001019060200180831162001eee57829003601f168201915b5050509183525050600291909101546001600160a01b038116602083015260ff600160a01b820481166040840152600160a81b82041660608301526001600160401b03600160b01b90910416608090910152905062001f6a62000c7d565b6001600160a01b038516600090815260049190910160205260409020541562001fa657604051630653bdf560e01b815260040160405180910390fd5b6001600160a01b03841662001fce5760405163d92e233d60e01b815260040160405180910390fd5b62001fda600062002ca0565b83161562001ffb57604051630c8c5a2b60e11b815260040160405180910390fd5b60006200200b62000f1962000c7d565b90506200201c826060015162002dac565b810362002040576040516323e919eb60e21b81526004810182905260240162000728565b62002068856200204f62000c7d565b6000868152600591909101602052604090209062002dd9565b50826200207462000c7d565b6001600160a01b03871660009081526004919091016020526040902055836200209c62000c7d565b6006016000876001600160a01b03166001600160a01b03168152602001908152602001600020819055507fedf63ee99110a1075b654570237238201693bfe9ac063acb6eef59041880a7d883866040516200062c929190620036f9565b60006200210633620007f7565b806200050e57505032331490565b6000620021218762002df0565b6200212b62000c7d565b6001600160a01b03861660009081526004919091016020526040902054156200216757604051630653bdf560e01b815260040160405180910390fd5b6200217162000c7d565b600301846040516200218491906200389f565b908152602001604051809103902054600014620021b457604051639e4b268560e01b815260040160405180910390fd5b6014845110620021d7576040516370ab3a0360e11b815260040160405180910390fd5b620021e28462002cc4565b62002200576040516389974bd960e01b815260040160405180910390fd5b8351600003620022235760405163b6f63d6560e01b815260040160405180910390fd5b6200222e8262002d3e565b60968351106200225157604051630595c1cb60e01b815260040160405180910390fd5b60006200225d62002e0f565b6040805160c081018252878152602081018790526001600160a01b038916918101919091526001606082015260ff85166080820152600060a082015290915080620022a762000c7d565b60008481526002919091016020526040902081518190620022c99082620037b8565b5060208201516001820190620022e09082620037b8565b506040820151600290910180546060840151608085015160a0909501516001600160401b0316600160b01b0267ffffffffffffffff60b01b1960ff968716600160a81b021668ffffffffffffffffff60a81b1996909216600160a01b026001600160a81b03199093166001600160a01b0390951694909417919091179390931692909217179055816200237262000c7d565b600301876040516200238591906200389f565b90815260405190819003602001902055620023bd87620023a462000c7d565b6000858152600591909101602052604090209062002dd9565b5081620023c962000c7d565b6001600160a01b03891660009081526004919091016020526040812091909155620023f49062002ca0565b620023fe62000c7d565b6006016000896001600160a01b03166001600160a01b031681526020019081526020016000208190555062002498886001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200246b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062002491919062003710565b8362002e5b565b620024a262000c7d565b600101600084815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b03160217905550876001600160a01b031663490fb76a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801562002519573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200253f919062003710565b6001600160a01b0316638c1717546040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200257d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620025a3919062003710565b6001600160a01b0316633c8f1bbe896001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa158015620025f0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062002616919062003710565b6200262062000c0b565b8a6040518463ffffffff1660e01b81526004016200264193929190620038bd565b600060405180830381600087803b1580156200265c57600080fd5b505af115801562002671573d6000803e3d6000fd5b5050506040808301518351602085015192517f2d1a6a0246120b48ff69503752990307de08cdefea86af0ba0e15bb6111761c29450620026b493879291620039da565b60405180910390a150979650505050505050565b6040805160c081018252606080825260208201819052600092820183905281018290526080810182905260a08101919091526200270462000c7d565b60020160008381526020019081526020016000206040518060c0016040529081600082018054620027359062003730565b80601f0160208091040260200160405190810160405280929190818152602001828054620027639062003730565b8015620027b45780601f106200278857610100808354040283529160200191620027b4565b820191906000526020600020905b8154815290600101906020018083116200279657829003601f168201915b50505050508152602001600182018054620027cf9062003730565b80601f0160208091040260200160405190810160405280929190818152602001828054620027fd9062003730565b80156200284e5780601f1062002822576101008083540402835291602001916200284e565b820191906000526020600020905b8154815290600101906020018083116200283057829003601f168201915b5050509183525050600291909101546001600160a01b038116602083015260ff600160a01b820481166040840152600160a81b82041660608301526001600160401b03600160b01b9091041660809091015292915050565b6000620028b262000c7d565b6000600162000c1c565b6000620028c862000c7d565b6001600160a01b03909216600090815260069290920160205250604090205490565b6000620028f662000c7d565b60009283526001016020525060409020546001600160a01b031690565b6000806200292062000c7d565b6001600160a01b0385166000908152600491909101602052604090205491506200294962000c7d565b6001600160a01b0385166000908152600691909101602052604081205491508290036200298957604051632f6c853960e11b815260040160405180910390fd5b620029976000600262003b1f565b8116151580620029c9575082600b811115620029b757620029b7620036a1565b620029c490600262003b1f565b811615155b62002a005782600b811115620029e357620029e3620036a1565b604051630d816ed160e01b81526004016200072891815260200190565b9250929050565b600081831062002a4157604080516020810184905290810184905260600160405160208183030381529060405280519060200120620004f9565b50604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b62002a7862002ee3565b6200095157604051631afcd79f60e31b815260040160405180910390fd5b6001600160a01b03811662002ae05760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b604482015260640162000728565b62002b12816200078360017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618620036cd565b62002b44426200078360017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b620036cd565b62002b76436200078360017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1620036cd565b604080516001600160a01b0383168152426020820152438183015290517f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe2367134269181900360600190a150565b6000620004fc825490565b6000620004f9836001600160a01b03841662002eff565b336001600160a01b0316816001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa15801562002c2b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062002c51919062003710565b6001600160a01b031614620004e8573360405163988d1f0360e01b815260040162000728919062003354565b6001600160a01b03811660009081526001830160205260408120541515620004f9565b600081600b81111562002cb75762002cb7620036a1565b620004fc90600262003b1f565b600081815b815181101562002d3457602082828151811062002cea5762002cea62003b2d565b016020015160f81c108062002d1b5750607f82828151811062002d115762002d1162003b2d565b016020015160f81c115b1562002d2b575060009392505050565b60010162002cc9565b5060019392505050565b60328160ff16111562002d6a576040516391866ccb60e01b815260ff8216600482015260240162000728565b600a8160ff161015620004e8576040516361aa824960e01b815260ff8216600482015260240162000728565b6060600062002da58362003003565b9392505050565b6000600562002dbd60018462003b43565b60ff1662002dcc9190620038fc565b620004fc906019620036e3565b6000620004f9836001600160a01b03841662003061565b80620004e857604051636221cab960e01b815260040160405180910390fd5b600062002e1b62000c7d565b6001600081815260209290925260409091205462002e3991620036e3565b90508062002e4662000c7d565b60016000908152602091909152604090205590565b6000828260405162002e6d90620030f2565b6001600160a01b0390921682526020820152604001604051809103906000f08015801562002e9f573d6000803e3d6000fd5b5090507fd8e93ad095135e43388f8c58b0d322a6edf452a4afd51e8a512d5f9d10576f2e828260405162002ed5929190620036f9565b60405180910390a192915050565b600062002eef62000c44565b54600160401b900460ff16919050565b6000818152600183016020526040812054801562002ff857600062002f26600183620036cd565b855490915060009062002f3c90600190620036cd565b905080821462002fa857600086600001828154811062002f605762002f6062003b2d565b906000526020600020015490508087600001848154811062002f865762002f8662003b2d565b6000918252602080832090910192909255918252600188019052604090208390555b855486908062002fbc5762002fbc62003b5f565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050620004fc565b6000915050620004fc565b6060816000018054806020026020016040519081016040528092919081815260200182805480156200305557602002820191906000526020600020905b81548152602001906001019080831162003040575b50505050509050919050565b6000818152600183016020526040812054620030aa57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155620004fc565b506000620004fc565b508054620030c19062003730565b6000825580601f10620030d2575050565b601f016020900490600052602060002090810190620004e8919062003100565b6109158062003b7683390190565b5b8082111562003117576000815560010162003101565b5090565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156200315c576200315c6200311b565b604052919050565b600082601f8301126200317657600080fd5b81356001600160401b038111156200319257620031926200311b565b620031a7601f8201601f191660200162003131565b818152846020838601011115620031bd57600080fd5b816020850160208301376000918101602001919091529392505050565b600060208284031215620031ed57600080fd5b81356001600160401b038111156200320457600080fd5b620009d68482850162003164565b600080604083850312156200322657600080fd5b50508035926020909101359150565b6001600160a01b0381168114620004e857600080fd5b6000602082840312156200325e57600080fd5b813562002da58162003235565b6000602082840312156200327e57600080fd5b5035919050565b600080604083850312156200329957600080fd5b8235620032a68162003235565b946020939093013593505050565b60005b83811015620032d1578181015183820152602001620032b7565b50506000910152565b60008151808452620032f4816020860160208601620032b4565b601f01601f19169290920160200192915050565b602081526000620004f96020830184620032da565b600080604083850312156200333157600080fd5b82359150602083013580151581146200334957600080fd5b809150509250929050565b6001600160a01b0391909116815260200190565b803560ff811681146200337a57600080fd5b919050565b6000602082840312156200339257600080fd5b620004f98262003368565b600080600060608486031215620033b357600080fd5b8335620033c08162003235565b92506020840135620033d28162003235565b929592945050506040919091013590565b60006001600160401b03821115620033ff57620033ff6200311b565b5060051b60200190565b600082601f8301126200341b57600080fd5b81356020620034346200342e83620033e3565b62003131565b8083825260208201915060208460051b8701019350868411156200345757600080fd5b602086015b848110156200347557803583529183019183016200345c565b509695505050505050565b6000806000606084860312156200349657600080fd5b8335620034a38162003235565b92506020848101356001600160401b0380821115620034c157600080fd5b818701915087601f830112620034d657600080fd5b8135620034e76200342e82620033e3565b81815260059190911b8301840190848101908a8311156200350757600080fd5b938501935b8285101562003532578435620035228162003235565b825293850193908501906200350c565b9650505060408701359250808311156200354b57600080fd5b50506200355b8682870162003409565b9150509250925092565b60008151808452602080850194506020840160005b83811015620035a15781516001600160a01b0316875295820195908201906001016200357a565b509495945050505050565b602081526000620004f9602083018462003565565b600080600060608486031215620035d757600080fd5b83356001600160401b0380821115620035ef57600080fd5b620035fd8783880162003164565b945060208601359150808211156200361457600080fd5b50620036238682870162003164565b925050620036346040850162003368565b90509250925092565b60c0815260006200365260c0830189620032da565b8281036020840152620036668189620032da565b6001600160a01b03979097166040840152505060ff9390931660608401526001600160401b0391909116608083015260a09091015292915050565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b81810381811115620004fc57620004fc620036b7565b80820180821115620004fc57620004fc620036b7565b9182526001600160a01b0316602082015260400190565b6000602082840312156200372357600080fd5b815162002da58162003235565b600181811c908216806200374557607f821691505b6020821081036200376657634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156200096a576000816000526020600020601f850160051c81016020861015620037975750805b601f850160051c820191505b818110156200063557828155600101620037a3565b81516001600160401b03811115620037d457620037d46200311b565b620037ec81620037e5845462003730565b846200376c565b602080601f8311600181146200382457600084156200380b5750858301515b600019600386901b1c1916600185901b17855562000635565b600085815260208120601f198616915b82811015620038555788860151825594840194600190910190840162003834565b5085821015620038745787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b828152604060208201526000620009d66040830184620032da565b60008251620038b3818460208701620032b4565b9190910192915050565b6001600160a01b0393841681526020810192909252909116604082015260600190565b60ff8181168382160190811115620004fc57620004fc620036b7565b8082028115828204841417620004fc57620004fc620036b7565b60008151808452602080850194506020840160005b83811015620035a1578151875295820195908201906001016200392b565b6001600160a01b03841681526060602082018190526000906200396f9083018562003565565b828103604084015262003983818562003916565b9695505050505050565b600060018060a01b03808716835260806020840152620039b1608084018762003565565b8381036040850152620039c5818762003916565b92505080841660608401525095945050505050565b60018060a01b038516815283602082015260806040820152600062003a036080830185620032da565b828103606084015262003a178185620032da565b979650505050505050565b600181815b8085111562003a6357816000190482111562003a475762003a47620036b7565b8085161562003a5557918102915b93841c939080029062003a27565b509250929050565b60008262003a7c57506001620004fc565b8162003a8b57506000620004fc565b816001811462003aa4576002811462003aaf5762003acf565b6001915050620004fc565b60ff84111562003ac35762003ac3620036b7565b50506001821b620004fc565b5060208310610133831016604e8410600b841016171562003af4575081810a620004fc565b62003b00838362003a22565b806000190482111562003b175762003b17620036b7565b029392505050565b6000620004f9838362003a6b565b634e487b7160e01b600052603260045260246000fd5b60ff8281168282160390811115620004fc57620004fc620036b7565b634e487b7160e01b600052603160045260246000fdfe60c060405234801561001057600080fd5b5060405161091538038061091583398101604081905261002f91610045565b6001600160a01b0390911660805260a05261007f565b6000806040838503121561005857600080fd5b82516001600160a01b038116811461006f57600080fd5b6020939093015192949293505050565b60805160a05161086c6100a9600039600060d1015260008181608d0152610514015261086c6000f3fe608060405234801561001057600080fd5b50600436106100835760003560e01c806325eb1c8714610088578063990db1fc146100cc578063beabacc814610101578063c3a9934214610116578063d11eccd614610129578063d742fa751461013c578063e1f21c671461014f578063e415c88d14610172578063ffa1ad7414610185575b600080fd5b6100af7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6100f37f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016100c3565b61011461010f366004610583565b6101b6565b005b610114610124366004610699565b610236565b610114610137366004610583565b610313565b61011461014a366004610699565b610383565b61016261015d366004610583565b610457565b60405190151581526020016100c3565b610114610180366004610583565b6104db565b6101a9604051806040016040528060058152602001640312e302e360dc1b81525081565b6040516100c3919061076b565b6101bf33610512565b60405163a9059cbb60e01b81526001600160a01b0384169063a9059cbb906101ed90859085906004016107ba565b6020604051808303816000875af115801561020c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061023091906107d3565b50505050565b61023f33610512565b8151815181146102625760405163586cb9e160e01b815260040160405180910390fd5b60005b8181101561030c5783818151811061027f5761027f6107fc565b60200260200101516001600160a01b03166323b872dd30878685815181106102a9576102a96107fc565b60200260200101516040518463ffffffff1660e01b81526004016102cf93929190610812565b600060405180830381600087803b1580156102e957600080fd5b505af11580156102fd573d6000803e3d6000fd5b50505050806001019050610265565b5050505050565b61031c33610512565b6040516323b872dd60e01b81526001600160a01b038316906323b872dd9061034c90309087908690600401610812565b600060405180830381600087803b15801561036657600080fd5b505af115801561037a573d6000803e3d6000fd5b50505050505050565b61038c33610512565b8151815181146103af5760405163586cb9e160e01b815260040160405180910390fd5b60005b8181101561030c578381815181106103cc576103cc6107fc565b60200260200101516001600160a01b031663095ea7b3868584815181106103f5576103f56107fc565b60200260200101516040518363ffffffff1660e01b815260040161041a9291906107ba565b600060405180830381600087803b15801561043457600080fd5b505af1158015610448573d6000803e3d6000fd5b505050508060010190506103b2565b600061046233610512565b60405163095ea7b360e01b81526001600160a01b0385169063095ea7b39061049090869086906004016107ba565b6020604051808303816000875af11580156104af573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104d391906107d3565b949350505050565b6104e433610512565b60405163095ea7b360e01b81526001600160a01b0383169063095ea7b39061034c90869085906004016107ba565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316816001600160a01b03161461056457604051639d6ebf3160e01b815260040160405180910390fd5b50565b80356001600160a01b038116811461057e57600080fd5b919050565b60008060006060848603121561059857600080fd5b6105a184610567565b92506105af60208501610567565b9150604084013590509250925092565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156105fe576105fe6105bf565b604052919050565b600067ffffffffffffffff821115610620576106206105bf565b5060051b60200190565b600082601f83011261063b57600080fd5b8135602061065061064b83610606565b6105d5565b8083825260208201915060208460051b87010193508684111561067257600080fd5b602086015b8481101561068e5780358352918301918301610677565b509695505050505050565b6000806000606084860312156106ae57600080fd5b6106b784610567565b925060208085013567ffffffffffffffff808211156106d557600080fd5b818701915087601f8301126106e957600080fd5b81356106f761064b82610606565b81815260059190911b8301840190848101908a83111561071657600080fd5b938501935b8285101561073b5761072c85610567565b8252938501939085019061071b565b96505050604087013592508083111561075357600080fd5b50506107618682870161062a565b9150509250925092565b60006020808352835180602085015260005b818110156107995785810183015185820160400152820161077d565b506000604082860101526040601f19601f8301168501019250505092915050565b6001600160a01b03929092168252602082015260400190565b6000602082840312156107e557600080fd5b815180151581146107f557600080fd5b9392505050565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b03938416815291909216602082015260408101919091526060019056fea2646970667358221220e0a97d3d66f5296aac7b3dabddebc979577acf3caadd596eeb8aba3b87c1382c64736f6c6343000817003322573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda264697066735822122078bd8f45d4f2fc4e6ab3aa6703f3b2d045980837d453edacc9f166134085a04a64736f6c63430008170033",
  "deployedBytecode": "0x60806040523480156200001157600080fd5b5060043610620001e15760003560e01c806399f9e252116200010f578063cca9079411620000aa578063cca907941462000421578063d3f489791462000438578063dee1f0e4146200044f578063df1dd9761462000466578063e68a8bf01462000491578063e79f0e96146200049b578063f2e0023d14620004b2578063f77c479114620004c9578063ffa1ad74146200033157600080fd5b806399f9e25214620003655780639d0bcca0146200037c578063ad1036861462000395578063b429afeb14620003ac578063b648063f14620003c3578063beabacc814620003cd578063c3a9934214620003e4578063c6d5774314620003fb57600080fd5b806346860698116200018057806346860698146200029d5780634fac6ccd14620002b4578063572b6c0514620002cb5780635b7249a714620002e257806366605ba414620002f957806371fb4f0514620003105780637cc963801462000327578063936725ec146200033157600080fd5b806311bc2ca214620001e6578063158914ac14620001ff57806315e812ad146200022b57806319ab453c146200024457806321b741de146200025b578063325a19f114620002725780633b4c9891146200027c5780634593144c1462000293575b600080fd5b620001fd620001f7366004620031da565b620004d3565b005b620002166200021036600462003212565b620004eb565b60405190151581526020015b60405180910390f35b6200023562000502565b60405190815260200162000222565b620001fd620002553660046200324b565b62000513565b620001fd6200026c3660046200324b565b6200063d565b6200023562000652565b620002356200028d3660046200324b565b62000689565b6200023562000696565b620001fd620002ae3660046200326b565b620006c9565b620001fd620002c53660046200324b565b620006de565b62000216620002dc3660046200324b565b620007f7565b620001fd620002f336600462003285565b62000846565b620001fd6200030a366004620031da565b62000860565b6200023562000321366004620031da565b6200087f565b620002356200088c565b62000356604051806040016040528060058152602001640312e302e360dc1b81525081565b60405162000222919062003308565b620001fd620003763660046200331d565b620008ae565b62000386620008c4565b60405162000222919062003354565b620001fd620003a63660046200337f565b620008f7565b62000216620003bd3660046200324b565b6200090c565b620001fd62000933565b620001fd620003de3660046200339d565b62000953565b620001fd620003f536600462003480565b6200096f565b620004126200040c3660046200326b565b62000986565b604051620002229190620035ac565b620001fd6200043236600462003285565b62000993565b6200023562000449366004620035c1565b620009a9565b62000216620004603660046200324b565b620009de565b6200047d620004773660046200326b565b62000a68565b60405162000222969594939291906200363d565b6200023562000ab2565b62000235620004ac3660046200324b565b62000abe565b62000386620004c33660046200326b565b62000acb565b6200038662000ad8565b620004e8620004e162000b0b565b8262000b30565b50565b6000620004f9838362000bd3565b90505b92915050565b60006200050e62000c0b565b905090565b60006200051f62000c44565b805490915060ff600160401b82041615906001600160401b0316600081158015620005475750825b90506000826001600160401b03166001148015620005645750303b155b90508115801562000573575080155b15620005925760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff191660011785558315620005bd57845460ff60401b1916600160401b1785555b620005c88662000c68565b670de0b6b3a7640000620005db62000c7d565b60026000908152602091909152604090205583156200063557845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2906020015b60405180910390a15b505050505050565b620004e86200064b62000b0b565b8262000ca1565b60006200050e6200068560017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b620036cd565b5490565b6000620004fc82620010e5565b60006200050e6200068560017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1620036cd565b620004e8620006d762000ad8565b8262001113565b333014620007315760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b6000620007536200068560016000805160206200448b833981519152620036cd565b62000760906001620036e3565b905062000786816200078360016000805160206200448b833981519152620036cd565b55565b620007b8826200078360017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4620036cd565b7ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c88183604051620007eb929190620036f9565b60405180910390a15050565b60006001600160a01b03821673d8253782c45a12053594b9deb72d8e8ab2fca54c1480620004fc57506001600160a01b0382167352ceba41da235af367bfc0b0ccd3314cb901bb5f1492915050565b6200085c6200085462000b0b565b838362001161565b5050565b620004e86200086e62000ad8565b6200087862000b0b565b8362001420565b6000620004fc82620017f7565b60006200050e6200068560016000805160206200448b833981519152620036cd565b6200085c620008bc62000b0b565b83836200182c565b60006200050e6200068560017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4620036cd565b620004e86200090562000b0b565b82620018c2565b60006200091862000ad8565b6001600160a01b0316826001600160a01b0316149050919050565b620009516200094162000ad8565b6200094b62000b0b565b62001920565b565b6200096a6200096162000b0b565b84848462001bb4565b505050565b6200096a6200097d62000b0b565b84848462001ca9565b6060620004fc8262001d7c565b6200085c620009a162000b0b565b838362001da4565b6000620009d6620009b9620020f9565b620009c362000ad8565b620009cd62000b0b565b87878762002114565b949350505050565b6000816001600160a01b0316620009f462000ad8565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000a32573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000a58919062003710565b6001600160a01b03161492915050565b606080600080600080600062000a7e88620026c8565b805160208201516040830151606084015160a0850151608090950151939d929c50909a50985091965060ff16945092505050565b60006200050e620028a6565b6000620004fc82620028bc565b6000620004fc82620028ea565b60006200050e6200068560017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618620036cd565b600062000b1833620007f7565b1562000b2b575060131936013560601c90565b503390565b600062000b3f83600262002913565b509050609682511062000b6557604051630595c1cb60e01b815260040160405180910390fd5b8162000b7062000c7d565b6000838152600291909101602052604090206001019062000b929082620037b8565b507f6b7abe944ce1beac4e645644ff5549a6f5280e2688588c1156e296f1b02a361f818360405162000bc692919062003884565b60405180910390a1505050565b600062000bdf62000c7d565b600701600062000bf0858562002a07565b815260208101919091526040016000205460ff169392505050565b600062000c1762000c7d565b600060025b600281111562000c305762000c30620036a1565b815260200190815260200160002054905090565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b62000c7262002a6e565b620004e88162002a96565b7f1c4340ff8478a236ed13a5ce46f8e8b8a6037975df340a04c54725978699d10090565b6000816001600160a01b0316836001600160a01b03160362000d0d5762000cc762000c7d565b6001600160a01b03841660009081526004919091016020526040812054915081900362000d0757604051632f6c853960e11b815260040160405180910390fd5b62000d45565b62000d1a83600562002913565b5090506001600160a01b03821662000d455760405163d92e233d60e01b815260040160405180910390fd5b600062000d5162000c7d565b60020160008381526020019081526020016000206040518060c001604052908160008201805462000d829062003730565b80601f016020809104026020016040519081016040528092919081815260200182805462000db09062003730565b801562000e015780601f1062000dd55761010080835404028352916020019162000e01565b820191906000526020600020905b81548152906001019060200180831162000de357829003601f168201915b5050505050815260200160018201805462000e1c9062003730565b80601f016020809104026020016040519081016040528092919081815260200182805462000e4a9062003730565b801562000e9b5780601f1062000e6f5761010080835404028352916020019162000e9b565b820191906000526020600020905b81548152906001019060200180831162000e7d57829003601f168201915b5050509183525050600291909101546001600160a01b038082166020840152600160a01b820460ff908116604080860191909152600160a81b84049091166060850152600160b01b9092046001600160401b031660809093019290925282015191925084811691160362000f5157600162000f3162000f1962000c7d565b60008581526005919091016020526040902062002bc0565b111562000f5157604051630ad25aaf60e21b815260040160405180910390fd5b62000f798362000f6062000c7d565b6000858152600591909101602052604090209062002bcb565b5062000f8462000c7d565b6001600160a01b0384166000908152600491909101602052604081205562000fab62000c7d565b6006016000846001600160a01b03166001600160a01b03168152602001908152602001600020600090557fc1a2a88b40ad3868bcda984d463d13c8a5ae7b0b3c3f56cb17ab7c34b7ad0928828460405162001008929190620036f9565b60405180910390a160006200102062000f1962000c7d565b905080600003620010de576200103562000c7d565b60030182600001516040516200104c91906200389f565b9081526020016040518091039020600090556200106862000c7d565b60008481526002919091016020526040812090620010878282620030b3565b62001097600183016000620030b3565b5060020180546001600160f01b03191690556040518381527fbdb3d45d74febd27a49d5ee308393b18fc559fcb577ecd0892ed9c2a761e8258906020015b60405180910390a15b5050505050565b6000620010f162000c7d565b6001600160a01b03909216600090815260049290920160205250604090205490565b6200111e8262002be2565b80600003620011405760405163273e150360e21b815260040160405180910390fd5b806200114b62000c7d565b6002600090815260209190915260409020555050565b60006200117084600762002913565b5090506200119b836200118262000c7d565b6000848152600591909101602052604090209062002c7d565b620011b957604051632f6c853960e11b815260040160405180910390fd5b6000620011c562000c7d565b60020160008381526020019081526020016000206040518060c0016040529081600082018054620011f69062003730565b80601f0160208091040260200160405190810160405280929190818152602001828054620012249062003730565b8015620012755780601f10620012495761010080835404028352916020019162001275565b820191906000526020600020905b8154815290600101906020018083116200125757829003601f168201915b50505050508152602001600182018054620012909062003730565b80601f0160208091040260200160405190810160405280929190818152602001828054620012be9062003730565b80156200130f5780601f10620012e3576101008083540402835291602001916200130f565b820191906000526020600020905b815481529060010190602001808311620012f157829003601f168201915b5050509183525050600291909101546001600160a01b038082166020840152600160a01b820460ff908116604080860191909152600160a81b84049091166060850152600160b01b9092046001600160401b0316608090930192909252820151919250858116911603620013935762001389600062002ca0565b83179250620013b8565b6200139f600062002ca0565b831615620013b857620013b3600062002ca0565b831892505b82620013c362000c7d565b6001600160a01b038616600081815260069290920160209081526040928390209390935581518581529283015281018490527fb0304e71a23f4e80fbe603bfffc79b824920fec23be1ef0767f676ba3b22077a90606001620010d5565b60006200142f83600162002913565b5090506200143c62000c7d565b600301826040516200144f91906200389f565b9081526020016040518091039020546000146200147f57604051639e4b268560e01b815260040160405180910390fd5b6014825110620014a2576040516370ab3a0360e11b815260040160405180910390fd5b620014ad8262002cc4565b620014cb576040516389974bd960e01b815260040160405180910390fd5b8151600003620014ee5760405163b6f63d6560e01b815260040160405180910390fd5b6000620014fa62000c7d565b6000838152600291909101602052604090208054620015199062003730565b80601f0160208091040260200160405190810160405280929190818152602001828054620015479062003730565b8015620015985780601f106200156c5761010080835404028352916020019162001598565b820191906000526020600020905b8154815290600101906020018083116200157a57829003601f168201915b50505050509050620015a962000c7d565b60030181604051620015bc91906200389f565b90815260200160405180910390206000905582620015d962000c7d565b60008481526002919091016020526040902090620015f89082620037b8565b50816200160462000c7d565b600301846040516200161791906200389f565b908152602001604051809103902081905550846001600160a01b031663490fb76a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001668573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200168e919062003710565b6001600160a01b0316638c1717546040518163ffffffff1660e01b8152600401602060405180830381865afa158015620016cc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620016f2919062003710565b6001600160a01b0316633c8f1bbe866001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200173f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001765919062003710565b6200176f62000c0b565b876040518463ffffffff1660e01b81526004016200179093929190620038bd565b600060405180830381600087803b158015620017ab57600080fd5b505af1158015620017c0573d6000803e3d6000fd5b505050507f957c37926a13c72eb069ef4bc862852a20cd897a1445c25acef64c285a3e3f878284604051620010d592919062003884565b60006200180362000c7d565b600301826040516200181691906200389f565b9081526020016040518091039020549050919050565b60006200183b84600962002913565b509050816200184962000c7d565b60070160006200185a848762002a07565b81526020808201929092526040908101600020805460ff19169315159390931790925581518381529081018590528315158183015290517fa38f02cb01028fc56d5a1c55764e771a6da2ec8205696148f0655ebcf322d8d6916060908290030190a150505050565b6000620018d183600b62002913565b509050620018df8262002d3e565b81620018ea62000c7d565b600092835260029081016020526040909220909101805460ff92909216600160a81b0260ff60a81b199092169190911790555050565b60006200192f82600862002913565b50905060006200193e62000c7d565b60008381526002918201602052604090200154600160a01b900460ff169050600919810162001986576040516302dc77b560e31b815260ff8216600482015260240162000728565b600062001995826001620038e0565b905080620019a262000c7d565b6000858152600291820160205260408120909101805460ff60a01b1916600160a01b60ff94851602179055908216620019da62000c0b565b620019e69190620038fc565b9050856001600160a01b031663490fb76a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001a27573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001a4d919062003710565b6001600160a01b0316638c1717546040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001a8b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001ab1919062003710565b6001600160a01b0316633c8f1bbe876001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001afe573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062001b24919062003710565b83886040518463ffffffff1660e01b815260040162001b4693929190620038bd565b600060405180830381600087803b15801562001b6157600080fd5b505af115801562001b76573d6000803e3d6000fd5b50506040805187815260ff861660208201527ff59393d3d727f52fd7d452c581b5b52711e6e44063d1ddf9368817b75fb2c21593500190506200062c565b600062001bc385600662002913565b509050600062001bd262000c7d565b60008381526001919091016020526040908190205490516317d5759960e31b81526001600160a01b0387811660048301528681166024830152604482018690529091169150819063beabacc890606401600060405180830381600087803b15801562001c3d57600080fd5b505af115801562001c52573d6000803e3d6000fd5b5050604080516001600160a01b03808b168252808a16602083015291810187905290871660608201527f3421522a397fda51b3adedf86b5f00270b3cf25e34ae836db9e28a78b198d29f925060800190506200062c565b600062001cb885600a62002913565b509050600062001cc762000c7d565b60008381526001919091016020526040908190205490516361d4c9a160e11b81526001600160a01b039091169150819063c3a993429062001d119088908890889060040162003949565b600060405180830381600087803b15801562001d2c57600080fd5b505af115801562001d41573d6000803e3d6000fd5b505050507f510bbc3f8229fd79dd4d20101e3a636ac34562b81999bc3287c0140d5e610f37868585886040516200062c94939291906200398d565b6060620004fc62001d8c62000c7d565b60008481526005919091016020526040902062002d96565b600062001db384600462002913565b509050600062001dc262000c7d565b60020160008381526020019081526020016000206040518060c001604052908160008201805462001df39062003730565b80601f016020809104026020016040519081016040528092919081815260200182805462001e219062003730565b801562001e725780601f1062001e465761010080835404028352916020019162001e72565b820191906000526020600020905b81548152906001019060200180831162001e5457829003601f168201915b5050505050815260200160018201805462001e8d9062003730565b80601f016020809104026020016040519081016040528092919081815260200182805462001ebb9062003730565b801562001f0c5780601f1062001ee05761010080835404028352916020019162001f0c565b820191906000526020600020905b81548152906001019060200180831162001eee57829003601f168201915b5050509183525050600291909101546001600160a01b038116602083015260ff600160a01b820481166040840152600160a81b82041660608301526001600160401b03600160b01b90910416608090910152905062001f6a62000c7d565b6001600160a01b038516600090815260049190910160205260409020541562001fa657604051630653bdf560e01b815260040160405180910390fd5b6001600160a01b03841662001fce5760405163d92e233d60e01b815260040160405180910390fd5b62001fda600062002ca0565b83161562001ffb57604051630c8c5a2b60e11b815260040160405180910390fd5b60006200200b62000f1962000c7d565b90506200201c826060015162002dac565b810362002040576040516323e919eb60e21b81526004810182905260240162000728565b62002068856200204f62000c7d565b6000868152600591909101602052604090209062002dd9565b50826200207462000c7d565b6001600160a01b03871660009081526004919091016020526040902055836200209c62000c7d565b6006016000876001600160a01b03166001600160a01b03168152602001908152602001600020819055507fedf63ee99110a1075b654570237238201693bfe9ac063acb6eef59041880a7d883866040516200062c929190620036f9565b60006200210633620007f7565b806200050e57505032331490565b6000620021218762002df0565b6200212b62000c7d565b6001600160a01b03861660009081526004919091016020526040902054156200216757604051630653bdf560e01b815260040160405180910390fd5b6200217162000c7d565b600301846040516200218491906200389f565b908152602001604051809103902054600014620021b457604051639e4b268560e01b815260040160405180910390fd5b6014845110620021d7576040516370ab3a0360e11b815260040160405180910390fd5b620021e28462002cc4565b62002200576040516389974bd960e01b815260040160405180910390fd5b8351600003620022235760405163b6f63d6560e01b815260040160405180910390fd5b6200222e8262002d3e565b60968351106200225157604051630595c1cb60e01b815260040160405180910390fd5b60006200225d62002e0f565b6040805160c081018252878152602081018790526001600160a01b038916918101919091526001606082015260ff85166080820152600060a082015290915080620022a762000c7d565b60008481526002919091016020526040902081518190620022c99082620037b8565b5060208201516001820190620022e09082620037b8565b506040820151600290910180546060840151608085015160a0909501516001600160401b0316600160b01b0267ffffffffffffffff60b01b1960ff968716600160a81b021668ffffffffffffffffff60a81b1996909216600160a01b026001600160a81b03199093166001600160a01b0390951694909417919091179390931692909217179055816200237262000c7d565b600301876040516200238591906200389f565b90815260405190819003602001902055620023bd87620023a462000c7d565b6000858152600591909101602052604090209062002dd9565b5081620023c962000c7d565b6001600160a01b03891660009081526004919091016020526040812091909155620023f49062002ca0565b620023fe62000c7d565b6006016000896001600160a01b03166001600160a01b031681526020019081526020016000208190555062002498886001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200246b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062002491919062003710565b8362002e5b565b620024a262000c7d565b600101600084815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b03160217905550876001600160a01b031663490fb76a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801562002519573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200253f919062003710565b6001600160a01b0316638c1717546040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200257d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620025a3919062003710565b6001600160a01b0316633c8f1bbe896001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa158015620025f0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062002616919062003710565b6200262062000c0b565b8a6040518463ffffffff1660e01b81526004016200264193929190620038bd565b600060405180830381600087803b1580156200265c57600080fd5b505af115801562002671573d6000803e3d6000fd5b5050506040808301518351602085015192517f2d1a6a0246120b48ff69503752990307de08cdefea86af0ba0e15bb6111761c29450620026b493879291620039da565b60405180910390a150979650505050505050565b6040805160c081018252606080825260208201819052600092820183905281018290526080810182905260a08101919091526200270462000c7d565b60020160008381526020019081526020016000206040518060c0016040529081600082018054620027359062003730565b80601f0160208091040260200160405190810160405280929190818152602001828054620027639062003730565b8015620027b45780601f106200278857610100808354040283529160200191620027b4565b820191906000526020600020905b8154815290600101906020018083116200279657829003601f168201915b50505050508152602001600182018054620027cf9062003730565b80601f0160208091040260200160405190810160405280929190818152602001828054620027fd9062003730565b80156200284e5780601f1062002822576101008083540402835291602001916200284e565b820191906000526020600020905b8154815290600101906020018083116200283057829003601f168201915b5050509183525050600291909101546001600160a01b038116602083015260ff600160a01b820481166040840152600160a81b82041660608301526001600160401b03600160b01b9091041660809091015292915050565b6000620028b262000c7d565b6000600162000c1c565b6000620028c862000c7d565b6001600160a01b03909216600090815260069290920160205250604090205490565b6000620028f662000c7d565b60009283526001016020525060409020546001600160a01b031690565b6000806200292062000c7d565b6001600160a01b0385166000908152600491909101602052604090205491506200294962000c7d565b6001600160a01b0385166000908152600691909101602052604081205491508290036200298957604051632f6c853960e11b815260040160405180910390fd5b620029976000600262003b1f565b8116151580620029c9575082600b811115620029b757620029b7620036a1565b620029c490600262003b1f565b811615155b62002a005782600b811115620029e357620029e3620036a1565b604051630d816ed160e01b81526004016200072891815260200190565b9250929050565b600081831062002a4157604080516020810184905290810184905260600160405160208183030381529060405280519060200120620004f9565b50604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b62002a7862002ee3565b6200095157604051631afcd79f60e31b815260040160405180910390fd5b6001600160a01b03811662002ae05760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b604482015260640162000728565b62002b12816200078360017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618620036cd565b62002b44426200078360017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b620036cd565b62002b76436200078360017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1620036cd565b604080516001600160a01b0383168152426020820152438183015290517f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe2367134269181900360600190a150565b6000620004fc825490565b6000620004f9836001600160a01b03841662002eff565b336001600160a01b0316816001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa15801562002c2b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062002c51919062003710565b6001600160a01b031614620004e8573360405163988d1f0360e01b815260040162000728919062003354565b6001600160a01b03811660009081526001830160205260408120541515620004f9565b600081600b81111562002cb75762002cb7620036a1565b620004fc90600262003b1f565b600081815b815181101562002d3457602082828151811062002cea5762002cea62003b2d565b016020015160f81c108062002d1b5750607f82828151811062002d115762002d1162003b2d565b016020015160f81c115b1562002d2b575060009392505050565b60010162002cc9565b5060019392505050565b60328160ff16111562002d6a576040516391866ccb60e01b815260ff8216600482015260240162000728565b600a8160ff161015620004e8576040516361aa824960e01b815260ff8216600482015260240162000728565b6060600062002da58362003003565b9392505050565b6000600562002dbd60018462003b43565b60ff1662002dcc9190620038fc565b620004fc906019620036e3565b6000620004f9836001600160a01b03841662003061565b80620004e857604051636221cab960e01b815260040160405180910390fd5b600062002e1b62000c7d565b6001600081815260209290925260409091205462002e3991620036e3565b90508062002e4662000c7d565b60016000908152602091909152604090205590565b6000828260405162002e6d90620030f2565b6001600160a01b0390921682526020820152604001604051809103906000f08015801562002e9f573d6000803e3d6000fd5b5090507fd8e93ad095135e43388f8c58b0d322a6edf452a4afd51e8a512d5f9d10576f2e828260405162002ed5929190620036f9565b60405180910390a192915050565b600062002eef62000c44565b54600160401b900460ff16919050565b6000818152600183016020526040812054801562002ff857600062002f26600183620036cd565b855490915060009062002f3c90600190620036cd565b905080821462002fa857600086600001828154811062002f605762002f6062003b2d565b906000526020600020015490508087600001848154811062002f865762002f8662003b2d565b6000918252602080832090910192909255918252600188019052604090208390555b855486908062002fbc5762002fbc62003b5f565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050620004fc565b6000915050620004fc565b6060816000018054806020026020016040519081016040528092919081815260200182805480156200305557602002820191906000526020600020905b81548152602001906001019080831162003040575b50505050509050919050565b6000818152600183016020526040812054620030aa57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155620004fc565b506000620004fc565b508054620030c19062003730565b6000825580601f10620030d2575050565b601f016020900490600052602060002090810190620004e8919062003100565b6109158062003b7683390190565b5b8082111562003117576000815560010162003101565b5090565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156200315c576200315c6200311b565b604052919050565b600082601f8301126200317657600080fd5b81356001600160401b038111156200319257620031926200311b565b620031a7601f8201601f191660200162003131565b818152846020838601011115620031bd57600080fd5b816020850160208301376000918101602001919091529392505050565b600060208284031215620031ed57600080fd5b81356001600160401b038111156200320457600080fd5b620009d68482850162003164565b600080604083850312156200322657600080fd5b50508035926020909101359150565b6001600160a01b0381168114620004e857600080fd5b6000602082840312156200325e57600080fd5b813562002da58162003235565b6000602082840312156200327e57600080fd5b5035919050565b600080604083850312156200329957600080fd5b8235620032a68162003235565b946020939093013593505050565b60005b83811015620032d1578181015183820152602001620032b7565b50506000910152565b60008151808452620032f4816020860160208601620032b4565b601f01601f19169290920160200192915050565b602081526000620004f96020830184620032da565b600080604083850312156200333157600080fd5b82359150602083013580151581146200334957600080fd5b809150509250929050565b6001600160a01b0391909116815260200190565b803560ff811681146200337a57600080fd5b919050565b6000602082840312156200339257600080fd5b620004f98262003368565b600080600060608486031215620033b357600080fd5b8335620033c08162003235565b92506020840135620033d28162003235565b929592945050506040919091013590565b60006001600160401b03821115620033ff57620033ff6200311b565b5060051b60200190565b600082601f8301126200341b57600080fd5b81356020620034346200342e83620033e3565b62003131565b8083825260208201915060208460051b8701019350868411156200345757600080fd5b602086015b848110156200347557803583529183019183016200345c565b509695505050505050565b6000806000606084860312156200349657600080fd5b8335620034a38162003235565b92506020848101356001600160401b0380821115620034c157600080fd5b818701915087601f830112620034d657600080fd5b8135620034e76200342e82620033e3565b81815260059190911b8301840190848101908a8311156200350757600080fd5b938501935b8285101562003532578435620035228162003235565b825293850193908501906200350c565b9650505060408701359250808311156200354b57600080fd5b50506200355b8682870162003409565b9150509250925092565b60008151808452602080850194506020840160005b83811015620035a15781516001600160a01b0316875295820195908201906001016200357a565b509495945050505050565b602081526000620004f9602083018462003565565b600080600060608486031215620035d757600080fd5b83356001600160401b0380821115620035ef57600080fd5b620035fd8783880162003164565b945060208601359150808211156200361457600080fd5b50620036238682870162003164565b925050620036346040850162003368565b90509250925092565b60c0815260006200365260c0830189620032da565b8281036020840152620036668189620032da565b6001600160a01b03979097166040840152505060ff9390931660608401526001600160401b0391909116608083015260a09091015292915050565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b81810381811115620004fc57620004fc620036b7565b80820180821115620004fc57620004fc620036b7565b9182526001600160a01b0316602082015260400190565b6000602082840312156200372357600080fd5b815162002da58162003235565b600181811c908216806200374557607f821691505b6020821081036200376657634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156200096a576000816000526020600020601f850160051c81016020861015620037975750805b601f850160051c820191505b818110156200063557828155600101620037a3565b81516001600160401b03811115620037d457620037d46200311b565b620037ec81620037e5845462003730565b846200376c565b602080601f8311600181146200382457600084156200380b5750858301515b600019600386901b1c1916600185901b17855562000635565b600085815260208120601f198616915b82811015620038555788860151825594840194600190910190840162003834565b5085821015620038745787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b828152604060208201526000620009d66040830184620032da565b60008251620038b3818460208701620032b4565b9190910192915050565b6001600160a01b0393841681526020810192909252909116604082015260600190565b60ff8181168382160190811115620004fc57620004fc620036b7565b8082028115828204841417620004fc57620004fc620036b7565b60008151808452602080850194506020840160005b83811015620035a1578151875295820195908201906001016200392b565b6001600160a01b03841681526060602082018190526000906200396f9083018562003565565b828103604084015262003983818562003916565b9695505050505050565b600060018060a01b03808716835260806020840152620039b1608084018762003565565b8381036040850152620039c5818762003916565b92505080841660608401525095945050505050565b60018060a01b038516815283602082015260806040820152600062003a036080830185620032da565b828103606084015262003a178185620032da565b979650505050505050565b600181815b8085111562003a6357816000190482111562003a475762003a47620036b7565b8085161562003a5557918102915b93841c939080029062003a27565b509250929050565b60008262003a7c57506001620004fc565b8162003a8b57506000620004fc565b816001811462003aa4576002811462003aaf5762003acf565b6001915050620004fc565b60ff84111562003ac35762003ac3620036b7565b50506001821b620004fc565b5060208310610133831016604e8410600b841016171562003af4575081810a620004fc565b62003b00838362003a22565b806000190482111562003b175762003b17620036b7565b029392505050565b6000620004f9838362003a6b565b634e487b7160e01b600052603260045260246000fd5b60ff8281168282160390811115620004fc57620004fc620036b7565b634e487b7160e01b600052603160045260246000fdfe60c060405234801561001057600080fd5b5060405161091538038061091583398101604081905261002f91610045565b6001600160a01b0390911660805260a05261007f565b6000806040838503121561005857600080fd5b82516001600160a01b038116811461006f57600080fd5b6020939093015192949293505050565b60805160a05161086c6100a9600039600060d1015260008181608d0152610514015261086c6000f3fe608060405234801561001057600080fd5b50600436106100835760003560e01c806325eb1c8714610088578063990db1fc146100cc578063beabacc814610101578063c3a9934214610116578063d11eccd614610129578063d742fa751461013c578063e1f21c671461014f578063e415c88d14610172578063ffa1ad7414610185575b600080fd5b6100af7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b6100f37f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016100c3565b61011461010f366004610583565b6101b6565b005b610114610124366004610699565b610236565b610114610137366004610583565b610313565b61011461014a366004610699565b610383565b61016261015d366004610583565b610457565b60405190151581526020016100c3565b610114610180366004610583565b6104db565b6101a9604051806040016040528060058152602001640312e302e360dc1b81525081565b6040516100c3919061076b565b6101bf33610512565b60405163a9059cbb60e01b81526001600160a01b0384169063a9059cbb906101ed90859085906004016107ba565b6020604051808303816000875af115801561020c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061023091906107d3565b50505050565b61023f33610512565b8151815181146102625760405163586cb9e160e01b815260040160405180910390fd5b60005b8181101561030c5783818151811061027f5761027f6107fc565b60200260200101516001600160a01b03166323b872dd30878685815181106102a9576102a96107fc565b60200260200101516040518463ffffffff1660e01b81526004016102cf93929190610812565b600060405180830381600087803b1580156102e957600080fd5b505af11580156102fd573d6000803e3d6000fd5b50505050806001019050610265565b5050505050565b61031c33610512565b6040516323b872dd60e01b81526001600160a01b038316906323b872dd9061034c90309087908690600401610812565b600060405180830381600087803b15801561036657600080fd5b505af115801561037a573d6000803e3d6000fd5b50505050505050565b61038c33610512565b8151815181146103af5760405163586cb9e160e01b815260040160405180910390fd5b60005b8181101561030c578381815181106103cc576103cc6107fc565b60200260200101516001600160a01b031663095ea7b3868584815181106103f5576103f56107fc565b60200260200101516040518363ffffffff1660e01b815260040161041a9291906107ba565b600060405180830381600087803b15801561043457600080fd5b505af1158015610448573d6000803e3d6000fd5b505050508060010190506103b2565b600061046233610512565b60405163095ea7b360e01b81526001600160a01b0385169063095ea7b39061049090869086906004016107ba565b6020604051808303816000875af11580156104af573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104d391906107d3565b949350505050565b6104e433610512565b60405163095ea7b360e01b81526001600160a01b0383169063095ea7b39061034c90869085906004016107ba565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316816001600160a01b03161461056457604051639d6ebf3160e01b815260040160405180910390fd5b50565b80356001600160a01b038116811461057e57600080fd5b919050565b60008060006060848603121561059857600080fd5b6105a184610567565b92506105af60208501610567565b9150604084013590509250925092565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156105fe576105fe6105bf565b604052919050565b600067ffffffffffffffff821115610620576106206105bf565b5060051b60200190565b600082601f83011261063b57600080fd5b8135602061065061064b83610606565b6105d5565b8083825260208201915060208460051b87010193508684111561067257600080fd5b602086015b8481101561068e5780358352918301918301610677565b509695505050505050565b6000806000606084860312156106ae57600080fd5b6106b784610567565b925060208085013567ffffffffffffffff808211156106d557600080fd5b818701915087601f8301126106e957600080fd5b81356106f761064b82610606565b81815260059190911b8301840190848101908a83111561071657600080fd5b938501935b8285101561073b5761072c85610567565b8252938501939085019061071b565b96505050604087013592508083111561075357600080fd5b50506107618682870161062a565b9150509250925092565b60006020808352835180602085015260005b818110156107995785810183015185820160400152820161077d565b506000604082860101526040601f19601f8301168501019250505092915050565b6001600160a01b03929092168252602082015260400190565b6000602082840312156107e557600080fd5b815180151581146107f557600080fd5b9392505050565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b03938416815291909216602082015260408101919091526060019056fea2646970667358221220e0a97d3d66f5296aac7b3dabddebc979577acf3caadd596eeb8aba3b87c1382c64736f6c6343000817003322573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda264697066735822122078bd8f45d4f2fc4e6ab3aa6703f3b2d045980837d453edacc9f166134085a04a64736f6c63430008170033",
  "libraries": {},
  "devdoc": {
    "errors": {
      "InvalidInitialization()": [
        {
          "details": "The contract is already initialized."
        }
      ],
      "NotInitializing()": [
        {
          "details": "The contract is not initializing."
        }
      ]
    },
    "events": {
      "Initialized(uint64)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      }
    },
    "kind": "dev",
    "methods": {
      "created()": {
        "returns": {
          "_0": "Creation timestamp"
        }
      },
      "createdBlock()": {
        "returns": {
          "_0": "Creation block number"
        }
      },
      "increaseRevision(address)": {
        "details": "Revision should be increased on each contract upgrade"
      },
      "isController(address)": {
        "details": "Return true if given address is controller"
      },
      "previousImplementation()": {
        "details": "Previous logic implementation"
      },
      "removeGuildMember(address)": {
        "details": "To delete the guild the owner should remove all members and remove himself at the end"
      },
      "revision()": {
        "details": "Contract upgrade counter"
      },
      "setBaseFee(uint256)": {
        "params": {
          "fee": "Base fee value in terms of game token"
        }
      }
    },
    "stateVariables": {
      "VERSION": {
        "details": "Should be incremented when contract changed"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "CONTROLLABLE_VERSION()": {
        "notice": "Version of the contract"
      },
      "VERSION()": {
        "notice": "Version of the contract"
      },
      "addGuildMember(address,uint256)": {
        "notice": "Add new member to the guild to which msgSender belongs"
      },
      "changeRoles(address,uint256)": {
        "notice": "Edit roles of the given member of the guild to which msgSender belongs"
      },
      "controller()": {
        "notice": "Return controller address saved in the contract slot"
      },
      "createGuild(string,string,uint8)": {
        "notice": "Create new guild, return ID of the new guild"
      },
      "created()": {
        "notice": "Return creation timestamp"
      },
      "createdBlock()": {
        "notice": "Return creation block number"
      },
      "guildLevelUp()": {
        "notice": "Increment level of the guild, pay BASE_FEE * new level"
      },
      "isGovernance(address)": {
        "notice": "Return true if given address is setup as governance in Controller"
      },
      "removeGuildMember(address)": {
        "notice": "Remove given member from the guild to which msgSender belongs"
      },
      "rename(string)": {
        "notice": "Rename the guild, pay BASE_FEE"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}