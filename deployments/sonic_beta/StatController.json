{
  "address": "0x998d30114CeAde8934AF17A3D87d5AbDEc75F1FD",
  "abi": [
    {
      "inputs": [],
      "name": "ErrorCannotRemoveItemFromMap",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "item",
          "type": "address"
        }
      ],
      "name": "ErrorConsumableItemIsUsed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorExperienceMustNotDecrease",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ErrorForbidden",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "itemType",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "itemSlot",
          "type": "uint8"
        }
      ],
      "name": "ErrorItemNotEligibleForTheSlot",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorItemNotInSlot",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorItemSlotBusy",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "slot",
          "type": "uint8"
        }
      ],
      "name": "ErrorItemSlotBusyHand",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorMaxLevel",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorNotEnoughExperience",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ErrorNotHeroController",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ErrorNotItemController",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorWrongLevelUpSum",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorZeroKarmaNotAllowed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidInitialization",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotInitializing",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "OutOfBounds",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "TooHighValue",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        }
      ],
      "name": "TooLowX",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "expected",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "actual",
          "type": "uint256"
        }
      ],
      "name": "UnexpectedValue",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "heroClass",
          "type": "uint256"
        }
      ],
      "name": "UnknownHeroClass",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "add",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "temporally",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "BonusAttributesChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "item",
          "type": "address"
        }
      ],
      "name": "ConsumableUsed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ts",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "block",
          "type": "uint256"
        }
      ],
      "name": "ContractInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "level",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "life",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "mana",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "lifeChances",
              "type": "uint32"
            }
          ],
          "indexed": false,
          "internalType": "struct IStatController.ChangeableStats",
          "name": "change",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "increase",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "CurrentStatsChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "index",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "GlobalCustomDataChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "index",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "HeroCustomDataChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "itemType",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "itemSlot",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "itemToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "itemTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "equip",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "HeroItemSlotChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "version",
          "type": "uint64"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroClass",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "int32",
              "name": "strength",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "dexterity",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "vitality",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "energy",
              "type": "int32"
            }
          ],
          "indexed": false,
          "internalType": "struct IStatController.CoreAttributes",
          "name": "change",
          "type": "tuple"
        }
      ],
      "name": "LevelUp",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "level",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "life",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "mana",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "lifeChances",
              "type": "uint32"
            }
          ],
          "indexed": false,
          "internalType": "struct IStatController.ChangeableStats",
          "name": "stats",
          "type": "tuple"
        }
      ],
      "name": "NewHeroInited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "item",
          "type": "address"
        }
      ],
      "name": "RemoveConsumableUsage",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "RevisionIncreased",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "TemporallyAttributesCleared",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CONTROLLABLE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "heroToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "heroTokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "heroLevel",
              "type": "uint32"
            },
            {
              "internalType": "address[]",
              "name": "buffTokens",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "buffTokenIds",
              "type": "uint256[]"
            }
          ],
          "internalType": "struct IStatController.BuffInfo",
          "name": "info",
          "type": "tuple"
        }
      ],
      "name": "buffHero",
      "outputs": [
        {
          "internalType": "int32[]",
          "name": "",
          "type": "int32[]"
        },
        {
          "internalType": "int32",
          "name": "",
          "type": "int32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "heroToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "heroTokenId",
              "type": "uint256"
            },
            {
              "internalType": "int32[]",
              "name": "changeAttributes",
              "type": "int32[]"
            },
            {
              "internalType": "bool",
              "name": "add",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "temporally",
              "type": "bool"
            }
          ],
          "internalType": "struct IStatController.ChangeAttributesInfo",
          "name": "info",
          "type": "tuple"
        }
      ],
      "name": "changeBonusAttributes",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "level",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "life",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "mana",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "lifeChances",
              "type": "uint32"
            }
          ],
          "internalType": "struct IStatController.ChangeableStats",
          "name": "change",
          "type": "tuple"
        },
        {
          "internalType": "bool",
          "name": "increase",
          "type": "bool"
        }
      ],
      "name": "changeCurrentStats",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "heroTokenId",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "itemType",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "itemSlot",
          "type": "uint8"
        },
        {
          "internalType": "address",
          "name": "itemToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "itemTokenId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "equip",
          "type": "bool"
        }
      ],
      "name": "changeHeroItemSlot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "clearTemporallyAttributes",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "clearUsedConsumables",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "created",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "createdBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "index",
          "type": "bytes32"
        }
      ],
      "name": "globalCustomData",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "heroAttribute",
      "outputs": [
        {
          "internalType": "int32",
          "name": "",
          "type": "int32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "heroAttributes",
      "outputs": [
        {
          "internalType": "int32[]",
          "name": "",
          "type": "int32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "heroAttributesLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "heroBaseAttributes",
      "outputs": [
        {
          "components": [
            {
              "internalType": "int32",
              "name": "strength",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "dexterity",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "vitality",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "energy",
              "type": "int32"
            }
          ],
          "internalType": "struct IStatController.CoreAttributes",
          "name": "core",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "heroBonusAttributes",
      "outputs": [
        {
          "internalType": "int32[]",
          "name": "",
          "type": "int32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "index",
          "type": "bytes32"
        }
      ],
      "name": "heroCustomData",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "heroClass",
          "type": "uint256"
        }
      ],
      "name": "heroInitialAttributes",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "int32",
                  "name": "strength",
                  "type": "int32"
                },
                {
                  "internalType": "int32",
                  "name": "dexterity",
                  "type": "int32"
                },
                {
                  "internalType": "int32",
                  "name": "vitality",
                  "type": "int32"
                },
                {
                  "internalType": "int32",
                  "name": "energy",
                  "type": "int32"
                }
              ],
              "internalType": "struct IStatController.CoreAttributes",
              "name": "core",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "minDamage",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxDamage",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "attackRating",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "defense",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "blockRating",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "life",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "mana",
                  "type": "uint256"
                }
              ],
              "internalType": "struct StatLib.BaseMultiplier",
              "name": "multiplier",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "life",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "mana",
                  "type": "uint256"
                }
              ],
              "internalType": "struct StatLib.LevelUp",
              "name": "levelUp",
              "type": "tuple"
            },
            {
              "internalType": "int32",
              "name": "baseLifeChances",
              "type": "int32"
            }
          ],
          "internalType": "struct StatLib.InitialHero",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "heroTokenId",
          "type": "uint64"
        },
        {
          "internalType": "uint8",
          "name": "itemSlot",
          "type": "uint8"
        }
      ],
      "name": "heroItemSlot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "nftPacked",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "heroItemSlots",
      "outputs": [
        {
          "internalType": "uint8[]",
          "name": "",
          "type": "uint8[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "heroStats",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "level",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "life",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "mana",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "lifeChances",
              "type": "uint32"
            }
          ],
          "internalType": "struct IStatController.ChangeableStats",
          "name": "result",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "heroTemporallyAttributes",
      "outputs": [
        {
          "internalType": "int32[]",
          "name": "",
          "type": "int32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "increaseRevision",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "controller_",
          "type": "address"
        }
      ],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "heroClass",
          "type": "uint256"
        }
      ],
      "name": "initNewHero",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "item",
          "type": "address"
        }
      ],
      "name": "isConsumableUsed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isController",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isGovernance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "isHeroAlive",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "level",
          "type": "uint32"
        }
      ],
      "name": "levelExperience",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "heroClass",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "int32",
              "name": "strength",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "dexterity",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "vitality",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "energy",
              "type": "int32"
            }
          ],
          "internalType": "struct IStatController.CoreAttributes",
          "name": "change",
          "type": "tuple"
        }
      ],
      "name": "levelUp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "newLvl",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "level",
          "type": "uint32"
        }
      ],
      "name": "levelUpExperienceRequired",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "previousImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "item",
          "type": "address"
        }
      ],
      "name": "registerConsumableUsage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "int32[]",
          "name": "prevAttributes",
          "type": "int32[]"
        }
      ],
      "name": "restoreLifeAndMana",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "revision",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "index",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "setGlobalCustomData",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "index",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "setHeroCustomData",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xfa3ae71a7e5906dd5eecae96506c61f4d74ae934e98174310accfdee3964226a",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0x998d30114CeAde8934AF17A3D87d5AbDEc75F1FD",
    "transactionIndex": 4,
    "gasUsed": "5313155",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000080001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x00008f8700001db6bc03aa67350f0b29e000bfb15a51af7f7b33f2ed9ecfdc8e",
    "transactionHash": "0xfa3ae71a7e5906dd5eecae96506c61f4d74ae934e98174310accfdee3964226a",
    "logs": [
      {
        "transactionIndex": 4,
        "blockNumber": 68282844,
        "transactionHash": "0xfa3ae71a7e5906dd5eecae96506c61f4d74ae934e98174310accfdee3964226a",
        "address": "0x998d30114CeAde8934AF17A3D87d5AbDEc75F1FD",
        "topics": [
          "0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 1,
        "blockHash": "0x00008f8700001db6bc03aa67350f0b29e000bfb15a51af7f7b33f2ed9ecfdc8e"
      }
    ],
    "blockNumber": 68282844,
    "cumulativeGasUsed": "5413491",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 27,
  "solcInputHash": "26aa46af27336d196c04997c06413167",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ErrorCannotRemoveItemFromMap\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"item\",\"type\":\"address\"}],\"name\":\"ErrorConsumableItemIsUsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorExperienceMustNotDecrease\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ErrorForbidden\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemType\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"itemSlot\",\"type\":\"uint8\"}],\"name\":\"ErrorItemNotEligibleForTheSlot\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorItemNotInSlot\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorItemSlotBusy\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"}],\"name\":\"ErrorItemSlotBusyHand\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMaxLevel\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorNotEnoughExperience\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ErrorNotHeroController\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ErrorNotItemController\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorWrongLevelUpSum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorZeroKarmaNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"OutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TooHighValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"TooLowX\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"UnexpectedValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroClass\",\"type\":\"uint256\"}],\"name\":\"UnknownHeroClass\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"temporally\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"BonusAttributesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"item\",\"type\":\"address\"}],\"name\":\"ConsumableUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"ContractInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"life\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"mana\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lifeChances\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct IStatController.ChangeableStats\",\"name\":\"change\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"increase\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CurrentStatsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"index\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"GlobalCustomDataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"index\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"HeroCustomDataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemSlot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"itemToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"equip\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"HeroItemSlotChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroClass\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int32\",\"name\":\"strength\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"dexterity\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"vitality\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"energy\",\"type\":\"int32\"}],\"indexed\":false,\"internalType\":\"struct IStatController.CoreAttributes\",\"name\":\"change\",\"type\":\"tuple\"}],\"name\":\"LevelUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"life\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"mana\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lifeChances\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct IStatController.ChangeableStats\",\"name\":\"stats\",\"type\":\"tuple\"}],\"name\":\"NewHeroInited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"item\",\"type\":\"address\"}],\"name\":\"RemoveConsumableUsage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"RevisionIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"TemporallyAttributesCleared\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTROLLABLE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"heroLevel\",\"type\":\"uint32\"},{\"internalType\":\"address[]\",\"name\":\"buffTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"buffTokenIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IStatController.BuffInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"name\":\"buffHero\",\"outputs\":[{\"internalType\":\"int32[]\",\"name\":\"\",\"type\":\"int32[]\"},{\"internalType\":\"int32\",\"name\":\"\",\"type\":\"int32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"int32[]\",\"name\":\"changeAttributes\",\"type\":\"int32[]\"},{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"temporally\",\"type\":\"bool\"}],\"internalType\":\"struct IStatController.ChangeAttributesInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"name\":\"changeBonusAttributes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"life\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"mana\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lifeChances\",\"type\":\"uint32\"}],\"internalType\":\"struct IStatController.ChangeableStats\",\"name\":\"change\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"increase\",\"type\":\"bool\"}],\"name\":\"changeCurrentStats\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"heroTokenId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"itemType\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"itemSlot\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"itemToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"equip\",\"type\":\"bool\"}],\"name\":\"changeHeroItemSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"clearTemporallyAttributes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"clearUsedConsumables\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"index\",\"type\":\"bytes32\"}],\"name\":\"globalCustomData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"heroAttribute\",\"outputs\":[{\"internalType\":\"int32\",\"name\":\"\",\"type\":\"int32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"heroAttributes\",\"outputs\":[{\"internalType\":\"int32[]\",\"name\":\"\",\"type\":\"int32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"heroAttributesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"heroBaseAttributes\",\"outputs\":[{\"components\":[{\"internalType\":\"int32\",\"name\":\"strength\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"dexterity\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"vitality\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"energy\",\"type\":\"int32\"}],\"internalType\":\"struct IStatController.CoreAttributes\",\"name\":\"core\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"heroBonusAttributes\",\"outputs\":[{\"internalType\":\"int32[]\",\"name\":\"\",\"type\":\"int32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"index\",\"type\":\"bytes32\"}],\"name\":\"heroCustomData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroClass\",\"type\":\"uint256\"}],\"name\":\"heroInitialAttributes\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"int32\",\"name\":\"strength\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"dexterity\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"vitality\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"energy\",\"type\":\"int32\"}],\"internalType\":\"struct IStatController.CoreAttributes\",\"name\":\"core\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minDamage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDamage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"attackRating\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"defense\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockRating\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"life\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mana\",\"type\":\"uint256\"}],\"internalType\":\"struct StatLib.BaseMultiplier\",\"name\":\"multiplier\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"life\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mana\",\"type\":\"uint256\"}],\"internalType\":\"struct StatLib.LevelUp\",\"name\":\"levelUp\",\"type\":\"tuple\"},{\"internalType\":\"int32\",\"name\":\"baseLifeChances\",\"type\":\"int32\"}],\"internalType\":\"struct StatLib.InitialHero\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"heroTokenId\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"itemSlot\",\"type\":\"uint8\"}],\"name\":\"heroItemSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"nftPacked\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"heroItemSlots\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"heroStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"life\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"mana\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lifeChances\",\"type\":\"uint32\"}],\"internalType\":\"struct IStatController.ChangeableStats\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"heroTemporallyAttributes\",\"outputs\":[{\"internalType\":\"int32[]\",\"name\":\"\",\"type\":\"int32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"increaseRevision\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"heroClass\",\"type\":\"uint256\"}],\"name\":\"initNewHero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"item\",\"type\":\"address\"}],\"name\":\"isConsumableUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"isHeroAlive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"}],\"name\":\"levelExperience\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"heroClass\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int32\",\"name\":\"strength\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"dexterity\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"vitality\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"energy\",\"type\":\"int32\"}],\"internalType\":\"struct IStatController.CoreAttributes\",\"name\":\"change\",\"type\":\"tuple\"}],\"name\":\"levelUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newLvl\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"}],\"name\":\"levelUpExperienceRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"item\",\"type\":\"address\"}],\"name\":\"registerConsumableUsage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"int32[]\",\"name\":\"prevAttributes\",\"type\":\"int32[]\"}],\"name\":\"restoreLifeAndMana\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"index\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setGlobalCustomData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"index\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setHeroCustomData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidInitialization()\":[{\"details\":\"The contract is already initialized.\"}],\"NotInitializing()\":[{\"details\":\"The contract is not initializing.\"}]},\"events\":{\"Initialized(uint64)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"}},\"kind\":\"dev\",\"methods\":{\"created()\":{\"returns\":{\"_0\":\"Creation timestamp\"}},\"createdBlock()\":{\"returns\":{\"_0\":\"Creation block number\"}},\"increaseRevision(address)\":{\"details\":\"Revision should be increased on each contract upgrade\"},\"isController(address)\":{\"details\":\"Return true if given address is controller\"},\"previousImplementation()\":{\"details\":\"Previous logic implementation\"},\"restoreLifeAndMana(address,uint256,int32[])\":{\"params\":{\"prevAttributes\":\"Hero attributes before reinforcement\"}},\"revision()\":{\"details\":\"Contract upgrade counter\"}},\"stateVariables\":{\"VERSION\":{\"details\":\"Should be incremented when contract changed\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"CONTROLLABLE_VERSION()\":{\"notice\":\"Version of the contract\"},\"VERSION()\":{\"notice\":\"Version of the contract\"},\"controller()\":{\"notice\":\"Return controller address saved in the contract slot\"},\"created()\":{\"notice\":\"Return creation timestamp\"},\"createdBlock()\":{\"notice\":\"Return creation block number\"},\"isGovernance(address)\":{\"notice\":\"Return true if given address is setup as governance in Controller\"},\"restoreLifeAndMana(address,uint256,int32[])\":{\"notice\":\"Restore life and mana during reinforcement\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/StatController.sol\":\"StatController\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":50},\"remappings\":[]},\"sources\":{\"contracts/core/StatController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n/**\\n            \\u2592\\u2593\\u2592  \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2593\\n             \\u2592\\u2588\\u2588\\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593  \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n              \\u2592\\u2588\\u2588\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592 \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n               \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592                   \\u2592\\u2588\\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                     \\u2592\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592     \\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                   \\u2592\\u2592\\u2592\\u2592\\u2592   \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                         \\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                       \\u2592\\u2588\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\n                        \\u2592\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592       \\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\n                          \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593   \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                           \\u2592\\u2592\\u2593\\u2593\\u2592   \\u2592\\u2588\\u2588\\u2593\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                  \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                                 \\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                                \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n      \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593                  \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                      \\u2592\\u2593\\u2593\\n    \\u2592\\u2593\\u2588\\u2592   \\u2592\\u2592\\u2588\\u2592\\u2592                   \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2592\\u2593\\u2593\\u2592\\n   \\u2592\\u2592\\u2588\\u2592       \\u2593\\u2592                    \\u2592\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2588\\u2593\\u2592\\n   \\u2593\\u2592\\u2588\\u2588\\u2593\\u2592                             \\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2592\\n    \\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2593\\u2592        \\u2592\\u2592\\u2592         \\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592\\u2592\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2592 \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n     \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2592\\u2592\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2593\\u2593     \\u2593\\u2593  \\u2593\\u2593\\u2588\\u2593   \\u2592\\u2592\\u2593\\u2593   \\u2592\\u2592\\u2588\\u2592   \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n            \\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592  \\u2592\\u2593\\u2593\\u2593\\u2592\\u2588\\u2592   \\u2592\\u2592\\u2592\\u2588\\u2592          \\u2592\\u2592\\u2588\\u2593\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592   \\u2593\\u2588\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\n \\u2592            \\u2592\\u2593\\u2593\\u2588\\u2593  \\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2593  \\u2592\\u2588\\u2593\\u2593\\u2592          \\u2593\\u2593\\u2588\\u2593\\u2592\\u2593\\u2588\\u2593\\u2592\\u2592   \\u2593\\u2588\\u2593        \\u2593\\u2588\\u2588\\u2588\\u2593\\n\\u2593\\u2593\\u2592         \\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592\\u2592\\u2593\\u2588\\u2592   \\u2592\\u2593\\u2588\\u2588\\u2593  \\u2593\\u2588\\u2588\\u2593\\u2592     \\u2592\\u2588\\u2593 \\u2593\\u2593\\u2588\\u2588   \\u2592\\u2593\\u2593\\u2593\\u2592\\u2592\\u2593\\u2588\\u2593        \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2592\\n \\u2588\\u2588\\u2593\\u2593\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592\\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592     \\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592\\n*/\\npragma solidity 0.8.23;\\nimport \\\"../proxy/Controllable.sol\\\";\\nimport \\\"../lib/StatControllerLib.sol\\\";\\n\\ncontract StatController is Controllable, IStatController {\\n\\n  //region ------------------------ CONSTANTS\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant override VERSION = \\\"2.1.2\\\";\\n  //endregion ------------------------ CONSTANTS\\n\\n  //region ------------------------ INITIALIZER\\n\\n  function init(address controller_) external initializer {\\n    __Controllable_init(controller_);\\n  }\\n  //endregion ------------------------ INITIALIZER\\n\\n  //region ------------------------ VIEWS\\n\\n  function heroInitialAttributes(uint heroClass) external pure returns (StatLib.InitialHero memory) {\\n    return StatLib.initialHero(heroClass);\\n  }\\n\\n  function heroAttributes(address token, uint tokenId) public view override returns (int32[] memory) {\\n    return StatControllerLib.heroAttributes(StatControllerLib._S(), token, tokenId);\\n  }\\n\\n  function heroBonusAttributes(address token, uint tokenId) public view returns (int32[] memory) {\\n    return StatControllerLib.heroBonusAttributes(StatControllerLib._S(), token, tokenId);\\n  }\\n\\n  function heroTemporallyAttributes(address token, uint tokenId) public view returns (int32[] memory) {\\n    return StatControllerLib.heroTemporallyAttributes(StatControllerLib._S(), token, tokenId);\\n  }\\n\\n  function heroAttributesLength(address token, uint tokenId) external pure override returns (uint) {\\n    return StatControllerLib.heroAttributesLength(token, tokenId);\\n  }\\n\\n  function heroAttribute(address token, uint tokenId, uint index) external view override returns (int32) {\\n    return StatControllerLib.heroAttribute(StatControllerLib._S(), token, tokenId, index);\\n  }\\n\\n  function heroBaseAttributes(address token, uint tokenId) public view override returns (CoreAttributes memory core) {\\n    return StatControllerLib.heroBaseAttributes(StatControllerLib._S(), token, tokenId);\\n  }\\n\\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view override returns (uint) {\\n    return StatControllerLib.heroCustomData(StatControllerLib._S(), token, tokenId, index);\\n  }\\n\\n  function globalCustomData(bytes32 index) external view override returns (uint) {\\n    return StatControllerLib.globalCustomData(StatControllerLib._S(), index);\\n  }\\n\\n  function heroStats(address token, uint tokenId) public view override returns (ChangeableStats memory result) {\\n    return StatControllerLib.heroStats(StatControllerLib._S(), token, tokenId);\\n  }\\n\\n  function heroItemSlot(address heroToken, uint64 heroTokenId, uint8 itemSlot) public view override returns (bytes32 nftPacked) {\\n    return StatControllerLib.heroItemSlot(StatControllerLib._S(), heroToken, heroTokenId, itemSlot);\\n  }\\n\\n  function heroItemSlots(address heroToken, uint heroTokenId) external view override returns (uint8[] memory) {\\n    return StatControllerLib.heroItemSlots(StatControllerLib._S(), heroToken, heroTokenId);\\n  }\\n\\n  function isHeroAlive(address heroToken, uint heroTokenId) external view override returns (bool) {\\n    return StatControllerLib.isHeroAlive(StatControllerLib._S(), heroToken, heroTokenId);\\n  }\\n\\n  function isConsumableUsed(address heroToken, uint heroTokenId, address item) external view returns (bool) {\\n    return StatControllerLib.isConsumableUsed(StatControllerLib._S(), heroToken, heroTokenId, item);\\n  }\\n\\n  function buffHero(BuffInfo memory info) external view override returns (int32[] memory, int32) {\\n    return StatControllerLib.buffHero(StatControllerLib._S(), IController(controller()), info);\\n  }\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ PURE\\n\\n  function levelUpExperienceRequired(uint32 level) external pure returns (uint) {\\n    return StatControllerLib.levelUpExperienceRequired(level);\\n  }\\n\\n  function levelExperience(uint32 level) external pure returns (uint) {\\n    return StatLib.levelExperience(level);\\n  }\\n  //endregion ------------------------ PURE\\n\\n  //region ------------------------ ACTIONS\\n\\n  function initNewHero(address heroToken, uint heroTokenId, uint heroClass) external override {\\n    return StatControllerLib.initNewHero(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId, heroClass);\\n  }\\n\\n  function changeHeroItemSlot(\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) external override {\\n    return StatControllerLib.changeHeroItemSlot(\\n      StatControllerLib._S(),\\n      IController(controller()),\\n      heroToken,\\n      heroTokenId,\\n      itemType,\\n      itemSlot,\\n      itemToken,\\n      itemTokenId,\\n      equip\\n    );\\n  }\\n\\n  function changeCurrentStats(address heroToken, uint heroTokenId, ChangeableStats memory change, bool increase) external override {\\n    return StatControllerLib.changeCurrentStats(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId, change, increase);\\n  }\\n\\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external override {\\n    return StatControllerLib.registerConsumableUsage(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId, item);\\n  }\\n\\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external override {\\n    return StatControllerLib.clearUsedConsumables(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId);\\n  }\\n\\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external override {\\n    return StatControllerLib.changeBonusAttributes(StatControllerLib._S(), IController(controller()), info);\\n  }\\n\\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external override {\\n    return StatControllerLib.clearTemporallyAttributes(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId);\\n  }\\n\\n  function levelUp(address heroToken, uint heroTokenId, uint heroClass, CoreAttributes memory change)\\n  external override returns (uint newLvl) {\\n    return StatControllerLib.levelUp(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId, heroClass, change);\\n  }\\n\\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external override {\\n    return StatControllerLib.setHeroCustomData(StatControllerLib._S(), IController(controller()), token, tokenId, index, value);\\n  }\\n\\n  function setGlobalCustomData(bytes32 index, uint value) external override {\\n    return StatControllerLib.setGlobalCustomData(StatControllerLib._S(), IController(controller()), index, value);\\n  }\\n\\n  /// @notice Restore life and mana during reinforcement\\n  /// @param prevAttributes Hero attributes before reinforcement\\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external override {\\n    return StatControllerLib.restoreLifeAndMana(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId, prevAttributes);\\n  }\\n  //endregion ------------------------ ACTIONS\\n\\n}\\n\",\"keccak256\":\"0x3e410984d1474374ebcde48ce1da7c8925cc5804dfc45f70a1e31dff8dd039d6\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IAppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\n/// @notice All errors of the app\\ninterface IAppErrors {\\n  error ZeroAddress();\\n  error ZeroValueNotAllowed();\\n  error LengthsMismatch();\\n  error NotEnoughBalance();\\n  error EmptyNameNotAllowed();\\n  error NotInitialized();\\n  error AlreadyInitialized();\\n\\n  //region Restrictions\\n  error ErrorNotDeployer(address sender);\\n  error ErrorNotGoc();\\n  error NotGovernance(address sender);\\n  error ErrorOnlyEoa();\\n  error NotEOA(address sender);\\n  error ErrorForbidden(address sender);\\n  error ErrorNotItemController(address sender);\\n  error ErrorNotHeroController(address sender);\\n  error ErrorNotDungeonFactory(address sender);\\n  error ErrorNotObjectController(address sender);\\n  error ErrorNotStoryController();\\n  error ErrorNotAllowedSender();\\n  error MintNotAllowed();\\n  //endregion Restrictions\\n\\n  //region Hero\\n  error ErrorHeroIsNotRegistered(address heroToken);\\n  error ErrorHeroIsDead(address heroToken, uint heroTokenId);\\n  error ErrorHeroNotInDungeon();\\n  error HeroInDungeon();\\n  error ErrorNotHeroOwner(address heroToken, address msgSender);\\n  error Staked(address heroToken, uint heroId);\\n  error HeroTokensVaultAlreadySet();\\n  error NameTaken();\\n  error TooBigName();\\n  error WrongSymbolsInTheName();\\n  error NoPayToken(address token, uint payTokenAmount);\\n  error AlreadyHaveReinforcement();\\n  /// @notice SIP-001 - Reinforcement requires 3 skills\\n  error ErrorReinforcementRequiresThreeSkills();\\n  //endregion Hero\\n\\n  //region Dungeon\\n  error ErrorDungeonIsFreeAlready();\\n  error ErrorNoEligibleDungeons();\\n  error ErrorDungeonBusy();\\n  error ErrorNoDungeonsForBiome(uint8 heroBiome);\\n  error ErrorDungeonCompleted();\\n  error ErrorAlreadyInDungeon();\\n  error NotEnoughTokens(uint balance, uint expectedBalance);\\n  error DungeonAlreadySpecific(uint16 dungNum);\\n  error DungeonAlreadySpecific2(uint16 dungNum);\\n  error WrongSpecificDungeon();\\n  //endregion Dungeon\\n\\n  //region Items\\n  error ErrorItemNotEligibleForTheSlot(uint itemType, uint8 itemSlot);\\n  error ErrorItemSlotBusyHand(uint8 slot);\\n  error ErrorItemSlotBusy();\\n  error ErrorItemNotInSlot();\\n  error ErrorConsumableItemIsUsed(address item);\\n  error ErrorCannotRemoveItemFromMap();\\n  error ItemEquipped();\\n  error ZeroItemMetaType();\\n  error ZeroLevel();\\n  error ItemTypeChanged();\\n  error ItemMetaTypeChanged();\\n  error UnknownItem(address item);\\n  error ItemIsAlreadyEquipped(address item);\\n  error ErrorEquipForbidden();\\n  error EquipForbiddenInDungeon();\\n  error TakeOffForbiddenInDungeon();\\n  error Consumable(address item);\\n  error NotConsumable(address item);\\n  error Broken(address item);\\n  error ZeroLife();\\n  error RequirementsToItemAttributes();\\n  error NotEquipped(address item);\\n  error ZeroDurability();\\n  error ZeroAugmentation();\\n  error TooHighAgLevel(uint8 augmentationLevel);\\n  error UseForbiddenZeroPayToken();\\n  error IncorrectMinMaxAttributeRange(int32 min, int32 max);\\n  error SameIdsNotAllowed();\\n  //endregion Items\\n\\n  //region Stages\\n  error ErrorWrongStage(uint stage);\\n  error ErrorNotStages();\\n  //endregion Stages\\n\\n  //region Level\\n  error ErrorWrongLevel(uint heroLevel);\\n  error ErrorLevelTooLow(uint heroLevel);\\n  error ErrorHeroLevelStartFrom1();\\n  error ErrorWrongLevelUpSum();\\n  error ErrorMaxLevel();\\n  //endregion Level\\n\\n  //region Treasure\\n  error ErrorNotValidTreasureToken(address treasureToken);\\n  //endregion Treasure\\n\\n  //region State\\n  error ErrorPaused();\\n  error ErrorNotReady();\\n  error ErrorNotObject1();\\n  error ErrorNotObject2();\\n  error ErrorNotCompleted();\\n  //endregion State\\n\\n  //region Biome\\n  error ErrorNotBiome();\\n  error ErrorIncorrectBiome(uint biome);\\n  error TooHighBiome(uint biome);\\n  //endregion Biome\\n\\n  //region Misc\\n  error ErrorWrongMultiplier(uint multiplier);\\n  error ErrorNotEnoughMana(uint32 mana, uint requiredMana);\\n  error ErrorExperienceMustNotDecrease();\\n  error ErrorNotEnoughExperience();\\n  error ErrorNotChances();\\n  error ErrorNotEligible(address heroToken, uint16 dungNum);\\n  error ErrorZeroKarmaNotAllowed();\\n  //endregion Misc\\n\\n  //region GOC\\n  error GenObjectIdBiomeOverflow(uint8 biome);\\n  error GenObjectIdSubTypeOverflow(uint subType);\\n  error GenObjectIdIdOverflow(uint id);\\n  error UnknownObjectTypeGoc1(uint8 objectType);\\n  error UnknownObjectTypeGoc2(uint8 objectType);\\n  error UnknownObjectTypeGocLib1(uint8 objectType);\\n  error UnknownObjectTypeGocLib2(uint8 objectType);\\n  error UnknownObjectTypeForSubtype(uint8 objectSubType);\\n  error FightDelay();\\n  error ZeroChance();\\n  error TooHighChance(uint32 chance);\\n  error TooHighRandom(uint random);\\n  error EmptyObjects();\\n  error ObjectNotFound();\\n  error WrongGetObjectTypeInput();\\n  error WrongChances(uint32 chances, uint32 maxChances);\\n  //endregion GOC\\n\\n  //region Story\\n  error PageNotRemovedError(uint pageId);\\n  error NotItem1();\\n  error NotItem2();\\n  error NotRandom(uint32 random);\\n  error NotHeroData();\\n  error NotGlobalData();\\n  error ZeroStoryIdRemoveStory();\\n  error ZeroStoryIdStoryAction();\\n  error ZeroStoryIdAction();\\n  error NotEnoughAmount(uint balance, uint requiredAmount);\\n  error NotAnswer();\\n  error AnswerStoryIdMismatch(uint16 storyId, uint16 storyIdFromAnswerHash);\\n  error AnswerPageIdMismatch(uint16 pageId, uint16 pageIdFromAnswerHash);\\n  //endregion Story\\n\\n  //region FightLib\\n  error NotMagic();\\n  error NotAType(uint atype);\\n  //endregion FightLib\\n\\n  //region MonsterLib\\n  error NotYourDebuffItem();\\n  error UnknownAttackType(uint attackType);\\n  error NotYourAttackItem();\\n  /// @notice The skill item cannot be used because it doesn't belong either to the hero or to the hero's helper\\n  error NotYourBuffItem();\\n  //endregion MonsterLib\\n\\n  //region GameToken\\n  error ApproveToZeroAddress();\\n  error MintToZeroAddress();\\n  error TransferToZeroAddress();\\n  error TransferAmountExceedsBalance(uint balance, uint value);\\n  error InsufficientAllowance();\\n  error BurnAmountExceedsBalance();\\n  error NotMinter(address sender);\\n  //endregion GameToken\\n\\n  //region NFT\\n  error TokenTransferNotAllowed();\\n  error IdOverflow(uint id);\\n  error NotExistToken(uint tokenId);\\n  error EquippedItemIsNotAllowedToTransfer(uint tokenId);\\n  //endregion NFT\\n\\n  //region CalcLib\\n  error TooLowX(uint x);\\n  //endregion CalcLib\\n\\n  //region Controller\\n  error NotFutureGovernance(address sender);\\n  //endregion Controller\\n\\n  //region Oracle\\n  error OracleWrongInput();\\n  //region Oracle\\n\\n  //region ReinforcementController\\n  error AlreadyStaked();\\n  error MaxFee(uint8 fee);\\n  error MinFee(uint8 fee);\\n  error StakeHeroNotStats();\\n  error NotStaked();\\n  error NoStakedHeroes();\\n  //region ReinforcementController\\n\\n  //region SponsoredHero\\n  error InvalidHeroClass();\\n  error ZeroAmount();\\n  error InvalidProof();\\n  error NoHeroesAvailable();\\n  error AlreadyRegistered();\\n  //endregion SponsoredHero\\n\\n  //region SacraRelay\\n  error SacraRelayNotOwner();\\n  error SacraRelayNotDelegator();\\n  error SacraRelayNotOperator();\\n  error SacraRelayInvalidChainId(uint callChainId, uint blockChainId);\\n  error SacraRelayInvalidNonce(uint callNonce, uint txNonce);\\n  error SacraRelayDeadline();\\n  error SacraRelayDelegationExpired();\\n  error SacraRelayNotAllowed();\\n  error SacraRelayInvalidSignature();\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error by selector, see tests\\n  error SacraRelayNoErrorSelector(bytes4 selector, string tracingInfo);\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error manually from {errorBytes} as following:\\n  /// if (keccak256(abi.encodeWithSignature(\\\"MyError()\\\")) == keccak256(errorBytes)) { ... }\\n  error SacraRelayUnexpectedReturnData(bytes errorBytes, string tracingInfo);\\n  error SacraRelayCallToNotContract(address notContract, string tracingInfo);\\n  //endregion SacraRelay\\n\\n  //region Misc\\n  error UnknownHeroClass(uint heroClass);\\n  error AbsDiff(int32 a, int32 b);\\n  //region Misc\\n\\n  //region ------------------------ Guilds\\n  error NoAvailableLootBox(address msgSender, uint lootBoxKind);\\n  error AlreadyGuildMember();\\n  error NotGuildMember();\\n  error GuildActionForbidden(uint right);\\n  error GuildHasMaxSize(uint guildSize);\\n  error GuildHasMaxLevel(uint level);\\n  error TooLongUrl();\\n  error CannotRemoveGuildOwnerFromNotEmptyGuild();\\n  error GuildControllerOnly();\\n  error GuildAlreadyHasShelter();\\n  error ShelterIsBusy();\\n  error ShelterIsNotRegistered();\\n  error ShelterIsNotOwnedByTheGuild();\\n  error ShelterIsInUse();\\n  error GuildHasNoShelter();\\n  error ShelterBidIsNotAllowedToBeUsed();\\n  error ShelterHasHeroesInside();\\n  error SecondGuildAdminIsNotAllowed();\\n  error UserTokensVaultAlreadySet();\\n  //endregion ------------------------ Guilds\\n}\\n\\n\",\"keccak256\":\"0xbdbf8438240913322c15ce377f44d6a61e1c5909735d8a4f4d3413d1c73d75b0\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IApplicationEvents.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IDungeonFactory.sol\\\";\\nimport \\\"./IStoryController.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\n\\n/// @notice All events of the app\\ninterface IApplicationEvents {\\n\\n  //region ------------------ StatController\\n  event HeroItemSlotChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint itemType,\\n    uint itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip,\\n    address caller\\n  );\\n  event CurrentStatsChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats change,\\n    bool increase,\\n    address caller\\n  );\\n  event BonusAttributesChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    bool add,\\n    bool temporally,\\n    address caller\\n  );\\n  event TemporallyAttributesCleared(address heroToken, uint heroTokenId, address caller);\\n  event NewHeroInited(address heroToken, uint heroTokenId, IStatController.ChangeableStats stats);\\n  event LevelUp(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes change\\n  );\\n  event ConsumableUsed(address heroToken, uint heroTokenId, address item);\\n  event RemoveConsumableUsage(address heroToken, uint heroTokenId, address item);\\n  event HeroCustomDataChanged(address token, uint tokenId, bytes32 index, uint value);\\n  event GlobalCustomDataChanged(bytes32 index, uint value);\\n  //endregion ------------------ StatController\\n\\n  //region ------------------ DungeonFactoryController\\n  event DungeonLaunched(\\n    uint16 dungeonLogicNum,\\n    uint64 dungeonId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken,\\n    uint treasuryAmount\\n  );\\n\\n  event BossCompleted(uint32 objectId, uint biome, address hero, uint heroId);\\n  event FreeDungeonAdded(uint8 biome, uint64 dungeonId);\\n\\n  event ObjectOpened(uint64 dungId, address hero, uint id, uint32 objId, uint iteration, uint currentStage);\\n  event Clear(uint64 dungId);\\n\\n  event DungeonLogicRegistered(uint16 dungLogicId, IDungeonFactory.DungeonGenerateInfo info);\\n  event DungeonLogicRemoved(uint16 dungLogicId);\\n  event DungeonSpecificLogicRegistered(uint16 dungLogicId, uint biome, uint heroCls);\\n  event DungeonSpecificLogicRemoved(uint16 dungLogicId, uint heroLvl, uint heroCls);\\n  event DungeonRegistered(uint16 dungLogicId, uint64 dungeonId);\\n  event DungeonRemoved(uint16 dungLogicId, uint64 dungeonId);\\n  event MinLevelForTreasuryChanged(address token, uint level);\\n\\n  event ObjectAction(\\n    uint64 dungId,\\n    IGOC.ActionResult result,\\n    uint currentStage,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint newStage\\n  );\\n  /// @notice On add the item to the dungeon\\n  event AddTreasuryItem(uint64 dungId, address itemAdr, uint itemId);\\n  event AddTreasuryToken(uint64 dungId, address token, uint amount);\\n  event ClaimToken(uint64 dungId, address token, uint amount);\\n  event ClaimItem(uint64 dungId, address token, uint id);\\n\\n  event Entered(uint64 dungId, address hero, uint id);\\n  event DungeonCompleted(uint16 dungLogicNum, uint64 dungId, address hero, uint heroId);\\n  event Exit(uint64 dungId, bool claim);\\n  event FreeDungeonRemoved(uint8 biome, uint64 dungeonId);\\n  event HeroCurrentDungeonChanged(address hero, uint heroId, uint64 dungeonId);\\n  //endregion ------------------ DungeonFactoryController\\n\\n  //region ------------------ GameObjectController\\n  event EventRegistered(uint32 objectId, IGOC.EventRegInfo eventRegInfo);\\n  event StoryRegistered(uint32 objectId, uint16 storyId);\\n  event MonsterRegistered(uint32 objectId, IGOC.MonsterGenInfo monsterGenInfo);\\n  event ObjectRemoved(uint32 objectId);\\n  event ObjectResultEvent(\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    IGOC.ObjectType objectType,\\n    address hero,\\n    uint heroId,\\n    uint8 stageId,\\n    uint iteration,\\n    bytes data,\\n    IGOC.ActionResult result,\\n    uint salt\\n  );\\n  //endregion ------------------ GameObjectController\\n\\n  //region ------------------ StoryController\\n  event SetBurnItemsMeta(uint storyId, IStoryController.AnswerBurnRandomItemMeta meta);\\n  event SetNextObjRewriteMeta(uint storyId, IStoryController.NextObjRewriteMeta meta);\\n  event SetAnswersMeta(uint storyId, uint16[] answerPageIds, uint8[] answerHeroClasses, uint16[] answerIds);\\n  event SetAnswerNextPageMeta(uint storyId, IStoryController.AnswerNextPageMeta meta);\\n  event SetAnswerAttributeRequirements(uint storyId, IStoryController.AnswerAttributeRequirementsMeta meta);\\n  event SetAnswerItemRequirements(uint storyId, IStoryController.AnswerItemRequirementsMeta meta);\\n  event SetAnswerTokenRequirementsMeta(uint storyId, IStoryController.AnswerTokenRequirementsMeta meta);\\n  event SetAnswerAttributes(uint storyId, IStoryController.AnswerAttributesMeta meta);\\n  event SetAnswerHeroCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetAnswerGlobalCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetSuccessInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetFailInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetCustomDataResult(uint storyId, IStoryController.AnswerCustomDataResultMeta meta, IStoryController.CustomDataResult _type);\\n  event StoryCustomDataRequirements(uint storyId, bytes32 requiredCustomDataIndex, uint requiredCustomDataMinValue, uint requiredCustomDataMaxValue, bool requiredCustomDataIsHero);\\n  event StoryRequiredLevel(uint storyId, uint requiredLevel);\\n  event StoryFinalized(uint32 objectId, uint storyId);\\n  event StoryRemoved(uint32 objectId, uint storyId);\\n\\n  event ItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  /// @notice Durability of the item was reduced to 0\\n  event ItemBroken(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n\\n  event NotEquippedItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event StoryChangeAttributes(\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    uint stageId,\\n    uint iteration,\\n    int32[] attributes\\n  );\\n  //endregion ------------------ StoryController\\n\\n  //region ------------------------ HeroController\\n  event HeroTokensVaultSet(address value);\\n  event HeroRegistered(address hero, uint8 heroClass, address payToken, uint payAmount);\\n  event HeroCreated(address hero, uint heroId, string name, address owner, string refCode);\\n  event BiomeChanged(address hero, uint heroId, uint8 biome);\\n  event LevelUp(address hero, uint heroId, address owner, IStatController.CoreAttributes change);\\n  event ReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event ReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event Killed(address hero, uint heroId, address killer, bytes32[] dropItems, uint dropTokenAmount);\\n  //endregion ------------------------ HeroController\\n\\n  //region ------------------------ FightLib\\n  event FightResultProcessed(\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    IFightCalculator.FightCall callData,\\n    uint iteration\\n  );\\n  //endregion ------------------------ FightLib\\n\\n  //region ------------------------ Oracle\\n  event Random(uint number, uint max);\\n  //endregion ------------------------ Oracle\\n\\n  //region ------------------------ Controller\\n  event OfferGovernance(address newGov);\\n  event GovernanceAccepted(address gov);\\n  event StatControllerChanged(address value);\\n  event StoryControllerChanged(address value);\\n  event GameObjectControllerChanged(address value);\\n  event ReinforcementControllerChanged(address value);\\n  event OracleChanged(address value);\\n  event TreasuryChanged(address value);\\n  event ItemControllerChanged(address value);\\n  event HeroControllerChanged(address value);\\n  event GameTokenChanged(address value);\\n  event DungeonFactoryChanged(address value);\\n  event ProxyUpdated(address proxy, address logic);\\n  event Claimed(address token, uint amount);\\n  event TokenStatusChanged(address token, bool status);\\n  event UserControllerChanged(address value);\\n  event GuildControllerChanged(address value);\\n  //endregion ------------------------ Controller\\n\\n  //region ------------------------ HeroTokensVault\\n  event Process(address token, uint amount, address from, uint toBurn, uint toTreasury, uint toGov);\\n  //endregion ------------------------ HeroTokensVault\\n\\n  //region ------------------------ ReinforcementController\\n  event HeroStaked(address heroToken, uint heroId, uint biome, uint score);\\n  event HeroWithdraw(address heroToken, uint heroId);\\n  event HeroAsk(address heroToken, uint heroId);\\n  event TokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint totalAmount);\\n  event NftRewardRegistered(address heroToken, uint heroId, address token, uint id);\\n  event ToHelperRatioChanged(uint value);\\n  event ClaimedToken(address heroToken, uint heroId, address token, uint amount, address recipient);\\n  event ClaimedItem(address heroToken, uint heroId, address item, uint itemId, address recipient);\\n  event MinLevelChanged(uint8 value);\\n  event MinLifeChancesChanged(uint value);\\n  //endregion ------------------------ ReinforcementController\\n\\n  //region ------------------------ Treasury\\n  event AssetsSentToDungeon(address dungeon, address token, uint amount);\\n  //endregion ------------------------ Treasury\\n\\n  //region ------------------------ EventLib\\n  event EventResult(uint64 dungeonId, address heroToken, uint heroTokenId, uint8 stageId, IStatController.ActionInternalInfo gen, uint iteration);\\n  //endregion ------------------------ EventLib\\n\\n  //region ------------------------ ItemStatsLib\\n  event ItemRegistered(address item, IItemController.RegisterItemParams info);\\n  event ItemRemoved(address item);\\n  event NewItemMinted(address item, uint itemId, IItemController.MintInfo info);\\n  event Equipped(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot);\\n  event TakenOff(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot, address destination);\\n  event ItemRepaired(address item, uint itemId, uint consumedItemId, uint16 baseDurability);\\n  event FailedToRepairItem(address item, uint itemId, uint consumedItemId, uint16 itemDurability);\\n  event Augmented(address item, uint itemId, uint consumedItemId, uint8 augLevel, IItemController.AugmentInfo info);\\n  event NotAugmented(address item, uint itemId, uint consumedItemId, uint8 augLevel);\\n  event ReduceDurability(address item, uint itemId, uint newDurability);\\n  event Used(address item, uint tokenId, address heroToken, uint heroTokenId);\\n  event Destroyed(address item, uint itemId);\\n  //endregion ------------------------ ItemStatsLib\\n\\n  //region ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n  event ChangePauseStatus(bool value);\\n  event MinterChanged(address value);\\n\\n  event UniqueUriChanged(uint id, string uri);\\n  event BaseUriChanged(string uri);\\n\\n  event HeroMinted(uint heroId);\\n  event HeroBurned(uint heroId);\\n  event HeroUriByStatusChanged(string uri, uint statusLvl);\\n\\n  event ItemMinted(uint tokenId);\\n  event ItemBurned(uint tokenId);\\n  event UriByRarityChanged(string uri, uint rarity);\\n  event SponsoredHeroCreated(address msgSender, address heroAddress, uint heroId, string heroName);\\n  //endregion ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n\\n  //region ------------------------ Guild\\n  event SetUserName(address user, string name);\\n  event LootBoxOpened(address user, uint lootBoxKind, address[] itemTokens, uint[] itemTokenIds);\\n  event LootBoxConfigChanged(uint lootBoxKind, address[] mintItems, uint32[] mintItemsChances, uint maxDropItems);\\n  event SetFeeRenaming(uint feeRenaming);\\n  event ActivityCompleted(address user, bool daily, bool weekly);\\n\\n  event GuildCreated(address owner, uint guildId, string name, string urlLogo);\\n  event AddToGuild(uint guildId, address newUser);\\n  event ChangeGuildRights(uint guildId, address user, uint rights);\\n  event RemoveFromGuild(uint guildId, address user);\\n  event GuildDeleted(uint guildId);\\n  event GuildLevelUp(uint guildId, uint8 newLevel);\\n  event GuildRename(uint guildId, string newName);\\n  event GuildLogoChanged(uint guildId, string newLogoUrl);\\n  event SetGuildRelation(uint guildId1, uint guildId2, bool peace);\\n  event TransferFromGuildBank(address user, address token, uint amount, address recipient);\\n  event TransferNftFromGuildBank(address user, address[] nfts, uint[] tokenIds, address recipient);\\n  event GuildBankDeployed(uint guildId, address guildBank);\\n\\n  event UserTokensVaultSet(address value);\\n  //endregion ------------------------ Guild\\n}\\n\",\"keccak256\":\"0xc56437df0734dccf5677bda430a487aff34eaada52031f3c86ddcd115a06a3ae\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IControllable {\\n\\n  function VERSION() external pure returns (string memory);\\n\\n  function revision() external view returns (uint);\\n\\n  function previousImplementation() external view returns (address);\\n\\n  function isController(address contract_) external view returns (bool);\\n\\n  function isGovernance(address contract_) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0x296b634c46b5d178b2408523fcf569ed370e20a719b7b3f2183b278631b94f65\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IController {\\n\\n  function governance() external view returns (address);\\n\\n  function statController() external view returns (address);\\n\\n  function storyController() external view returns (address);\\n\\n  function gameObjectController() external view returns (address);\\n\\n  function reinforcementController() external view returns (address);\\n\\n  function oracle() external view returns (address);\\n\\n  function treasury() external view returns (address);\\n\\n  function itemController() external view returns (address);\\n\\n  function heroController() external view returns (address);\\n\\n  function dungeonFactory() external view returns (address);\\n\\n  function gameToken() external view returns (address);\\n\\n  function validTreasuryTokens(address token) external view returns (bool);\\n\\n  function isDeployer(address adr) external view returns (bool);\\n\\n  function onPause() external view returns (bool);\\n\\n  function userController() external view returns (address);\\n\\n  function guildController() external view returns (address);\\n}\\n\",\"keccak256\":\"0xae4746df4915fbe35e8f0a582097b4c8cc3ee4da249d403c89a990648177b3ee\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDungeonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IDungeonFactory {\\n\\n  /// @custom:storage-location erc7201:dungeon.factory.main\\n  struct MainState {\\n    /// @dev biome => dungeonLaunchedId\\n    mapping(uint => EnumerableSet.UintSet) freeDungeons;\\n    /// @dev hero + heroId + biome (packMapObject) -> completed\\n    mapping(bytes32 => bool) bossCompleted;\\n    /// @dev hero + heroId + dungNum (packDungeonKey) -> completed\\n    mapping(bytes32 => bool) specificDungeonCompleted;\\n    /// @notice Max biome completed by the hero\\n    /// @dev hero + heroId (nftPacked) -> max biome completed\\n    mapping(bytes32 => uint8) maxBiomeCompleted;\\n    /// @notice which dungeon the hero is currently in\\n    /// @dev hero+id => current DungeonId\\n    mapping(bytes32 => uint64) heroCurrentDungeon;\\n\\n    // ---\\n\\n    /// @notice Specific dungeon for the given pair of hero level + hero class\\n    ///         ALl specific dungeons are listed also in allSpecificDungeons\\n    /// @dev packUint8Array(specReqBiome, specReqHeroClass) => dungNum\\n    mapping(bytes32 => uint16) dungeonSpecific;\\n    /// @dev contains all specific dungNum for easy management\\n    EnumerableSet.UintSet allSpecificDungeons;\\n    /// @dev biome => dungNum\\n    mapping(uint8 => EnumerableSet.UintSet) dungeonsLogicByBiome;\\n\\n    // ---\\n\\n    /// @dev max available biome. auto-increment with new dung deploy\\n    uint8 maxBiome;\\n\\n    /// @notice Address of treasure token => min hero level required\\n    /// @dev manual threshold for treasury\\n    mapping(address => uint) minLevelForTreasury;\\n\\n    /// @notice Contains arrays for SKILL_1, SKILL_2, SKILL_3 with 0 or 1\\n    /// i.e. [0, 1, 0] means that durability of SKILL_2 should be reduced\\n    /// @dev hero + heroId => uint8[] array where idx = slotNum\\n    mapping(bytes32 => bytes32) skillSlotsForDurabilityReduction;\\n\\n    /// @notice Counter of dungeons, it's incremented on launch of a new dungeon\\n    uint64 dungeonCounter;\\n\\n    /// @dev dungNum = init attributes\\n    mapping(uint16 => DungeonAttributes) dungeonAttributes;\\n    /// @dev dungeonId => status\\n    mapping(uint64 => DungeonStatus) dungeonStatuses;\\n  }\\n\\n  struct ObjectGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    /// @dev uint8 types, packed using PackingLib.packUint8Array\\n    bytes32[] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    /// @dev uint64 chances\\n    uint32[][] objChancesByStages;\\n  }\\n\\n  struct DungeonGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    uint8[][] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    uint32[][] objChancesByStages;\\n\\n    uint32[] uniqObjects;\\n\\n    uint8 minLevel;\\n    uint8 maxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n  }\\n\\n  /// @notice Attributes of the given dungeon logic\\n  struct DungeonAttributes {\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    uint8 stages;\\n    uint8 biome;\\n\\n    /// @notice Default list of objects that should be passed in the dungeon\\n    uint32[] uniqObjects;\\n\\n    /// @dev min+max (packUint8Array)\\n    bytes32 minMaxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    /// @notice Packed DungeonGenerateInfo.requiredCustomData: MinValue, MaxValue, IsHero\\n    /// @dev min+max+isHero(packStoryCustomDataRequirements)\\n    bytes32[] requiredCustomDataValue;\\n\\n    ObjectGenerateInfo info;\\n  }\\n\\n  /// @notice Current status of the given dungeon\\n  struct DungeonStatus {\\n    uint64 dungeonId;\\n    /// @notice Dungeon logic id\\n    uint16 dungNum;\\n\\n    /// @notice True if the dungeon is completed by the hero\\n    bool isCompleted;\\n\\n    /// @notice Hero in the dungeon or 0\\n    address heroToken;\\n    uint heroTokenId;\\n    /// @notice Current object that should be passed by the hero. 0 - new object is not opened\\n    uint32 currentObject;\\n    /// @notice Current stage in the dungeon that should be passed by the hero.\\n    uint8 currentStage;\\n\\n    EnumerableMap.AddressToUintMap treasuryTokens;\\n    /// @notice All items that were minted on result of made actions\\n    bytes32[] treasuryItems;\\n\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    /// This value can be bigger than length of uniqObjects\\n    uint8 stages;\\n    /// @notice List of objects to be passed in the stage. The list can be dynamically changed during passing the stages\\n    uint32[] uniqObjects;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n\\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external returns (uint64 dungeonId);\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8);\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64);\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result);\\n\\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external;\\n\\n}\\n\",\"keccak256\":\"0x2f24028d35a06e44dc9bd096d8a1807cfa64518ebd73692a1cc479736814b741\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IFightCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface IFightCalculator {\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    MELEE, // 1\\n    MAGIC, // 2\\n    SLOT_3,\\n    SLOT_4,\\n    SLOT_5,\\n    SLOT_6,\\n    SLOT_7,\\n    SLOT_8,\\n    SLOT_9,\\n    SLOT_10\\n  }\\n\\n  /// @notice Attacker info: suitable both for hero and monsters\\n  struct AttackInfo {\\n    /// @notice Type of the attack\\n    /// by default, if attack token presents, it's magic attack and not-magic otherwise\\n    /// but this logic can become more complicated after introducing new attack types\\n    AttackType attackType;\\n    /// @notice NFT selected by hero for attack, it should be equip on.\\n    /// If attacker is a monster, this is a special case (stub NFT with zero ID is used)\\n    address attackToken;\\n    uint attackTokenId;\\n    address[] skillTokens;\\n    uint[] skillTokenIds;\\n  }\\n\\n  struct FighterInfo {\\n    int32[] fighterAttributes;\\n    IStatController.ChangeableStats fighterStats;\\n    AttackType attackType;\\n    address attackToken;\\n    uint attackTokenId;\\n    uint race;\\n  }\\n\\n  struct Statuses {\\n    bool stun;\\n    bool burn;\\n    bool freeze;\\n    bool confuse;\\n    bool curse;\\n    bool poison;\\n    bool gotCriticalHit;\\n    bool missed;\\n    bool hitBlocked;\\n  }\\n\\n  struct FightResult {\\n    int32 healthA;\\n    int32 healthB;\\n    int32 manaConsumedA;\\n    int32 manaConsumedB;\\n  }\\n\\n  struct FightCall {\\n    FighterInfo fighterA;\\n    FighterInfo fighterB;\\n    uint64 dungeonId;\\n    uint32 objectId;\\n    address heroAdr;\\n    uint heroId;\\n    uint8 stageId;\\n    uint iteration;\\n    uint8 turn;\\n  }\\n\\n  struct SkillSlots {\\n    bool slot1;\\n    bool slot2;\\n    bool slot3;\\n  }\\n\\n  //region ------------------------ FightLib-internal (FightInfoInternal is required by IApplicationEvents..)\\n  struct FightInfoInternal {\\n    Fighter fighterA;\\n    Fighter fighterB;\\n  }\\n\\n  struct Fighter {\\n    IFightCalculator.FighterInfo info;\\n    IItemController.AttackInfo magicAttack;\\n    int32 health;\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 damagePoison;\\n    int32 damageReflect;\\n    IFightCalculator.Statuses statuses;\\n  }\\n  //endregion ------------------------ FightLib-internal\\n\\n  function fight(FightCall memory callData) external returns (FightResult memory);\\n}\\n\",\"keccak256\":\"0xdf9ba809ea21a35a24eed12bf80e53452b0d772623d59211a35498b518eb604b\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGOC.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\n\\ninterface IGOC {\\n\\n  enum ObjectType {\\n    UNKNOWN, // 0\\n    EVENT, // 1\\n    MONSTER, // 2\\n    STORY, // 3\\n    END_SLOT\\n  }\\n\\n  enum ObjectSubType {\\n    UNKNOWN_0, // 0\\n    ENEMY_NPC_1, // 1\\n    ENEMY_NPC_SUPER_RARE_2, // 2\\n    BOSS_3, // 3\\n    SHRINE_4, // 4\\n    CHEST_5, // 5\\n    STORY_6, // 6\\n    STORY_UNIQUE_7, // 7\\n    SHRINE_UNIQUE_8, // 8\\n    CHEST_UNIQUE_9, // 9\\n    ENEMY_NPC_UNIQUE_10, // 10\\n    STORY_ON_ROAD_11, // 11\\n    STORY_UNDERGROUND_12, // 12\\n    STORY_NIGHT_CAMP_13, // 13\\n    STORY_MOUNTAIN_14, // 14\\n    STORY_WATER_15, // 15\\n    STORY_CASTLE_16, // 16\\n    STORY_HELL_17, // 17\\n    STORY_SPACE_18, // 18\\n    STORY_WOOD_19, // 19\\n    STORY_CATACOMBS_20, // 20\\n    STORY_BAD_HOUSE_21, // 21\\n    STORY_GOOD_TOWN_22, // 22\\n    STORY_BAD_TOWN_23, // 23\\n    STORY_BANDIT_CAMP_24, // 24\\n    STORY_BEAST_LAIR_25, // 25\\n    STORY_PRISON_26, // 26\\n    STORY_SWAMP_27, // 27\\n    STORY_INSIDE_28, // 28\\n    STORY_OUTSIDE_29, // 29\\n    STORY_INSIDE_RARE_30,\\n    STORY_OUTSIDE_RARE_31,\\n    ENEMY_NPC_INSIDE_32,\\n    ENEMY_NPC_INSIDE_RARE_33,\\n    ENEMY_NPC_OUTSIDE_34,\\n    ENEMY_NPC_OUTSIDE_RARE_35,\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:game.object.controller.main\\n  struct MainState {\\n\\n    /// @dev objId = biome(00) type(00) id(0000) => biome(uint8) + objType(uint8)\\n    /// Id is id of the event, story or monster.\\n    mapping(uint32 => bytes32) objectMeta;\\n\\n    /// @dev biome(uint8) + objType(uint8) => set of object id\\n    mapping(bytes32 => EnumerableSet.UintSet) objectIds;\\n\\n    /// @dev heroAdr180 + heroId64 + cType8 + biome8 => set of already played objects. Should be cleared periodically\\n    mapping(bytes32 => EnumerableSet.UintSet) playedObjects;\\n\\n    /// @dev HeroAdr(160) + heroId(uint64) + objId(uint32) => iteration count. It needs for properly emit events for every new entrance.\\n    mapping(bytes32 => uint) iterations;\\n\\n    /// @dev objId(uint32) => EventInfo\\n    mapping(uint32 => EventInfo) eventInfos;\\n\\n    /// @dev objId(uint32) => storyId\\n    mapping(uint32 => uint16) storyIds;\\n\\n    /// @dev objId(uint32) => MonsterInfo\\n    mapping(uint32 => MonsterInfo) monsterInfos;\\n\\n    /// @dev hero+id => last fight action timestamp\\n    mapping(bytes32 => uint) lastHeroFightTs;\\n\\n    /// @dev delay for user actions in fight (suppose to prevent bot actions)\\n    uint fightDelay;\\n  }\\n\\n  struct ActionResult {\\n    bool kill;\\n    bool completed;\\n    address heroToken;\\n    address[] mintItems;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n    uint32 objectId;\\n    uint32 experience;\\n    uint heroTokenId;\\n    uint iteration;\\n    uint32[] rewriteNextObject;\\n  }\\n\\n  struct EventInfo {\\n    /// @dev chance to use good or bad attributes/stats\\n    uint32 goodChance;\\n\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] goodAttributes;\\n    bytes32[] badAttributes;\\n\\n    /// @dev experience(uint32) + heal(int32) + manaRegen(int32) + lifeChancesRecovered(int32) + damage(int32) + manaConsume(int32) packStatsChange\\n    bytes32 statsChange;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n  }\\n\\n  struct MonsterInfo {\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] attributes;\\n    /// @dev level(uint8) + race(uint8) + experience(uint32) + maxDropItems(uint8) packMonsterStats\\n    bytes32 stats;\\n    /// @dev attackToken(160) + attackTokenId(uint64) + attackType(uint8) packAttackInfo\\n    bytes32 attackInfo;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n\\n    /// @dev heroAdr(160) + heroId(uint64) => iteration => GeneratedMonster packed\\n    mapping(bytes32 => mapping(uint => bytes32)) _generatedMonsters;\\n  }\\n\\n  struct MultiplierInfo {\\n    uint8 biome;\\n    uint totalSupply;\\n  }\\n\\n  struct GeneratedMonster {\\n    bool generated;\\n    uint8 turnCounter;\\n    int32 hp;\\n    uint32 amplifier;\\n  }\\n\\n  struct MonsterGenInfo {\\n    uint16 monsterId;\\n    uint8 biome;\\n    ObjectSubType subType;\\n\\n    uint8[] attributeIds;\\n    int32[] attributeValues;\\n\\n    uint8 level;\\n    uint8 race;\\n    uint32 experience;\\n    uint8 maxDropItems;\\n\\n    address attackToken;\\n    uint64 attackTokenId;\\n    uint8 attackType;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct ActionContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    uint8 biome;\\n    uint8 objectSubType;\\n    uint8 stageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint heroTokenId;\\n    uint salt;\\n    uint iteration;\\n    bytes data;\\n  }\\n\\n  struct EventRegInfo {\\n    uint8 biome;\\n    uint16 eventId;\\n    ObjectSubType subType;\\n\\n    uint32 goodChance;\\n\\n    AttributeGenerateInfo goodAttributes;\\n    AttributeGenerateInfo badAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct AttributeGenerateInfo {\\n    uint8[] ids;\\n    int32[] values;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev represent object registration if non zero values\\n  function getObjectMeta(uint32 objectId) external view returns (uint8 biome, uint8 objectSubType);\\n\\n  function isBattleObject(uint32 objectId) external view returns (bool);\\n\\n  function getRandomObject(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biomeLevel,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external returns (uint32 objectId);\\n\\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint iteration);\\n\\n  function action(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) external returns (ActionResult memory);\\n\\n}\\n\",\"keccak256\":\"0x6493b091bb99b51586b94064eea3eb60f5fa921c5a6f7e061b3c491a73b89a9e\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IHeroController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IHeroController {\\n\\n  /// @custom:storage-location erc7201:hero.controller.main\\n  struct MainState {\\n\\n    /// @dev A central place for all hero tokens\\n    address heroTokensVault;\\n\\n    /// @dev heroAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) payToken;\\n\\n    /// @dev heroAdr => heroCls8\\n    mapping(address => uint8) heroClass;\\n\\n    // ---\\n\\n    /// @dev hero+id => individual hero name\\n    mapping(bytes32 => string) heroName;\\n\\n    /// @dev name => hero+id, needs for checking uniq names\\n    mapping(string => bytes32) nameToHero;\\n\\n    // ---\\n\\n    /// @dev hero+id => biome\\n    mapping(bytes32 => uint8) heroBiome;\\n\\n    /// @dev hero+id => rein hero+id\\n    mapping(bytes32 => bytes32) reinforcementHero;\\n\\n    /// @dev hero+id => rein packed attributes\\n    mapping(bytes32 => bytes32[]) reinforcementHeroAttributes;\\n  }\\n\\n  function heroClass(address hero) external view returns (uint8);\\n\\n  function heroBiome(address hero, uint heroId) external view returns (uint8);\\n\\n  function payTokenInfo(address hero) external view returns (address token, uint amount);\\n\\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (address helperHeroToken, uint helperHeroId);\\n\\n  function score(address hero, uint heroId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool);\\n\\n  function heroTokensVault() external view returns (address);\\n\\n  // ---\\n\\n  function create(address hero, string memory heroName_, bool enter) external returns (uint);\\n\\n  function kill(address hero, uint heroId) external returns (bytes32[] memory dropItems);\\n\\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId);\\n\\n}\\n\",\"keccak256\":\"0x670ab48074f47c954a571035fb9abf04b193d524768b779047838e0990d39ef1\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IItemController {\\n\\n  /// @custom:storage-location erc7201:item.controlbler.main\\n  struct MainState {\\n\\n    ////////////////// GENERATE //////////////////\\n\\n    EnumerableSet.AddressSet items;\\n\\n    /// @dev itemAdr => itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n    mapping(address => bytes32) itemMeta;\\n\\n    /// @dev itemAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) augmentInfo;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoAttributes;\\n\\n    // --- consumable ---\\n\\n    /// @dev itemAdr => ids+values (toBytes32ArrayWithIds)\\n    mapping(address => bytes32[]) _itemConsumableAttributes;\\n\\n    /// @dev itemAdr => IStatController.ChangeableStats packed int32[]\\n    mapping(address => bytes32) itemConsumableStats;\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoCasterAttributes;\\n\\n    /// @dev itemAdr => id8 + minDmg(int32) + maxDmg(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(address => bytes32) generateInfoAttack;\\n\\n    ////////////////// ITEMS INFO //////////////////\\n\\n    /// @dev itemAdr+id => itemRarity8 + augmentationLevel8 + itemDurability16\\n    mapping(bytes32 => bytes32) itemInfo;\\n\\n    /// @dev itemAdr+id => heroAdr+id\\n    mapping(bytes32 => bytes32) equippedOn;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemAttributes;\\n\\n    // --- consumable ---\\n\\n    // consumable stats unchangeable, get them by address\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemCasterAttributes;\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr+Id => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(bytes32 => bytes32) _itemAttackInfo;\\n\\n    ////////////////// Additional generate info //////////////////\\n\\n    /// @notice (itemAdr) => Bitmask of ConsumableActionBits\\n    mapping(address => uint) _consumableActionMask;\\n\\n\\n    /// --------------------------------- SIP-003: Item fragility\\n    /// @notice itemAdr + id => item fragility counter that displays the chance of an unsuccessful repair\\n    mapping(bytes32 packedItem => uint fragility) itemFragility;\\n  }\\n\\n  struct RegisterItemParams {\\n    ItemMeta itemMeta;\\n    address augmentToken;\\n    uint augmentAmount;\\n    ItemGenerateInfo commonAttributes;\\n\\n    IGOC.AttributeGenerateInfo consumableAttributes;\\n    IStatController.ChangeableStats consumableStats;\\n\\n    ItemGenerateInfo casterAttributes;\\n    ItemGenerateInfo targetAttributes;\\n\\n    AttackInfo genAttackInfo;\\n    /// @notice Bit mask of ConsumableActionBits\\n    uint consumableActionMask;\\n  }\\n\\n  /// @notice Possible actions that can be triggered by using the consumable item\\n  enum ConsumableActionBits {\\n    CLEAR_TEMPORARY_ATTRIBUTES_0,\\n    EXIT_FROM_DUNGEON_1,\\n    USE_GUILD_REINFORCEMENT_2,\\n    RECREATION_IN_GUILD_HOUSE_3\\n  }\\n\\n  struct ItemGenerateInfo {\\n    /// @notice Attribute ids\\n    uint8[] ids;\\n    /// @notice Min value of the attribute, != 0\\n    int32[] mins;\\n    /// @notice Max value of the attribute, != 0\\n    int32[] maxs;\\n    /// @notice Chance of the selection [0..MAX_CHANCES]\\n    uint32[] chances;\\n  }\\n\\n  struct ItemMeta {\\n    uint8 itemMetaType;\\n    // Level in range 1-99. Reducing durability in low level dungeons. lvl/5+1 = biome\\n    uint8 itemLevel;\\n    IItemController.ItemType itemType;\\n    uint16 baseDurability;\\n    uint8 defaultRarity;\\n    uint32 manaCost;\\n\\n    // it doesn't include positions with 100% chance\\n    uint8 minRandomAttributes;\\n    uint8 maxRandomAttributes;\\n\\n    IStatController.CoreAttributes requirements;\\n  }\\n\\n  enum FeeType {\\n    UNKNOWN,\\n    REPAIR,\\n    AUGMENT,\\n    STORY,\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemRarity {\\n    UNKNOWN, // 0\\n    NORMAL, // 1\\n    MAGIC, // 2\\n    RARE, // 3\\n    SET, // 4\\n    UNIQUE, // 5\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemType {\\n    NO_SLOT, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    RING, // 6\\n    OFF_HAND, // 7\\n    BOOTS, // 8\\n    ONE_HAND, // 9\\n    TWO_HAND, // 10\\n    SKILL, // 11\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemMetaType {\\n    UNKNOWN, // 0\\n    COMMON, // 1\\n    ATTACK, // 2\\n    BUFF, // 3\\n    CONSUMABLE, // 4\\n\\n    END_SLOT\\n  }\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    FIRE, // 1\\n    COLD, // 2\\n    LIGHTNING, // 3\\n    CHAOS, // 4\\n\\n    END_SLOT\\n  }\\n\\n  struct AttackInfo {\\n    AttackType aType;\\n    int32 min;\\n    int32 max;\\n    // if not zero - activate attribute factor for the attribute\\n    IStatController.CoreAttributes attributeFactors;\\n  }\\n\\n  struct ItemInfo {\\n    ItemRarity rarity;\\n    uint8 augmentationLevel;\\n    uint16 durability;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct MintInfo {\\n    IItemController.ItemMeta meta;\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.ItemRarity itemRarity;\\n\\n    IItemController.AttackInfo attackInfo;\\n\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct AugmentInfo {\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.AttackInfo attackInfo;\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function itemMeta(address item) external view returns (ItemMeta memory meta);\\n\\n  function augmentInfo(address item) external view returns (address token, uint amount);\\n\\n  function genAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genCasterAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genTargetAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genAttackInfo(address item) external view returns (AttackInfo memory info);\\n\\n  function itemInfo(address item, uint itemId) external view returns (ItemInfo memory info);\\n\\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId);\\n\\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats);\\n\\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function itemAttackInfo(address item, uint itemId) external view returns (AttackInfo memory info);\\n\\n  function score(address item, uint tokenId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address item, uint tokenId) external view returns (bool);\\n\\n  // ---\\n\\n  function mint(address item, address recipient) external returns (uint itemId);\\n\\n  function reduceDurability(address hero, uint heroId, uint8 biome) external;\\n\\n  function destroy(address item, uint tokenId) external;\\n\\n  function takeOffDirectly(\\n    address item,\\n    uint itemId,\\n    address hero,\\n    uint heroId,\\n    uint8 itemSlot,\\n    address destination,\\n    bool broken\\n  ) external;\\n\\n  /// @notice SIP-003: item fragility counter that displays the chance of an unsuccessful repair.\\n  /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n  function itemFragility(address item, uint itemId) external view returns (uint);\\n\\n  /// @notice SIP-003: The quest mechanic that previously burned the item will increase its fragility by 1%\\n  function incBrokenItemFragility(address item, uint itemId) external;\\n}\\n\",\"keccak256\":\"0x50b0c0da23481b6b88cc7fcc9c70d92e98a680700b634ff7be5843c16cc947aa\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IOracle {\\n\\n  function getRandomNumber(uint max, uint seed) external returns (uint);\\n\\n  function getRandomNumberInRange(uint min, uint max, uint seed) external returns (uint);\\n\\n}\\n\",\"keccak256\":\"0x75a2bed27cbd9be6c76b6f3e941ee5f6f55380f61cd867254a0c766fc3b71976\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStatController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStatController {\\n\\n  /// @custom:storage-location erc7201:stat.controller.main\\n  struct MainState {\\n    mapping(bytes32 => bytes32[]) heroTotalAttributes;\\n    /// @dev heroAdr+heroId => int32 packed strength, dexterity, vitality, energy\\n    mapping(bytes32 => bytes32) _heroCore;\\n    mapping(bytes32 => bytes32[]) heroBonusAttributes;\\n    mapping(bytes32 => bytes32[]) heroTemporallyAttributes;\\n    /// @dev heroAdr+heroId => uint32 packed level, experience, life, mana, lifeChances\\n    mapping(bytes32 => bytes32) heroStats;\\n    /// @dev heroAdr+heroId+itemSlot => itemAdr + itemId\\n    mapping(bytes32 => bytes32) heroSlots;\\n    /// @dev heroAdr+heroId => busy slots uint8[] packed\\n    mapping(bytes32 => bytes32) heroBusySlots;\\n    mapping(bytes32 => EnumerableSet.AddressSet) usedConsumables;\\n    mapping(bytes32 => mapping(bytes32 => uint)) heroCustomData;\\n    mapping(bytes32 => uint) globalCustomData;\\n  }\\n\\n\\n  enum ATTRIBUTES {\\n    // core\\n    STRENGTH, // 0\\n    DEXTERITY, // 1\\n    VITALITY, // 2\\n    ENERGY, // 3\\n    // attributes\\n    DAMAGE_MIN, // 4\\n    DAMAGE_MAX, // 5\\n    ATTACK_RATING, // 6\\n    DEFENSE, // 7\\n    BLOCK_RATING, // 8\\n    LIFE, // 9\\n    MANA, // 10\\n    // resistance\\n    FIRE_RESISTANCE, // 11\\n    COLD_RESISTANCE, // 12\\n    LIGHTNING_RESISTANCE, // 13\\n    // dmg against\\n    DMG_AGAINST_HUMAN, // 14\\n    DMG_AGAINST_UNDEAD, // 15\\n    DMG_AGAINST_DAEMON, // 16\\n    DMG_AGAINST_BEAST, // 17\\n\\n    // defence against\\n    DEF_AGAINST_HUMAN, // 18\\n    DEF_AGAINST_UNDEAD, // 19\\n    DEF_AGAINST_DAEMON, // 20\\n    DEF_AGAINST_BEAST, // 21\\n\\n    // --- unique, not augmentable\\n    // hero will not die until have positive chances\\n    LIFE_CHANCES, // 22\\n    // increase chance to get an item\\n    MAGIC_FIND, // 23\\n    // decrease chance to get an item\\n    DESTROY_ITEMS, // 24\\n    // percent of chance x2 dmg\\n    CRITICAL_HIT, // 25\\n    // dmg factors\\n    MELEE_DMG_FACTOR, // 26\\n    FIRE_DMG_FACTOR, // 27\\n    COLD_DMG_FACTOR, // 28\\n    LIGHTNING_DMG_FACTOR, // 29\\n    // increase attack rating on given percent\\n    AR_FACTOR, // 30\\n    // percent of damage will be converted to HP\\n    LIFE_STOLEN_PER_HIT, // 31\\n    // amount of mana restored after each battle\\n    MANA_AFTER_KILL, // 32\\n    // reduce all damage on percent after all other reductions\\n    DAMAGE_REDUCTION, // 33\\n\\n    // -- statuses\\n    // chance to stun an enemy, stunned enemy skip next hit\\n    STUN, // 34\\n    // chance burn an enemy, burned enemy will loss 50% of defence\\n    BURN, // 35\\n    // chance freeze an enemy, frozen enemy will loss 50% of MELEE damage\\n    FREEZE, // 36\\n    // chance to reduce enemy's attack rating on 50%\\n    CONFUSE, // 37\\n    // chance curse an enemy, cursed enemy will loss 50% of resistance\\n    CURSE, // 38\\n    // percent of dmg return to attacker\\n    REFLECT_DAMAGE_MELEE, // 39\\n    REFLECT_DAMAGE_MAGIC, // 40\\n    // chance to poison enemy, poisoned enemy will loss 10% of the current health\\n    POISON, // 41\\n    // reduce chance get any of uniq statuses\\n    RESIST_TO_STATUSES, // 42\\n\\n    END_SLOT // 46\\n  }\\n\\n  // possible\\n  // HEAL_FACTOR\\n\\n  struct CoreAttributes {\\n    int32 strength;\\n    int32 dexterity;\\n    int32 vitality;\\n    int32 energy;\\n  }\\n\\n  struct ChangeableStats {\\n    uint32 level;\\n    uint32 experience;\\n    uint32 life;\\n    uint32 mana;\\n    uint32 lifeChances;\\n  }\\n\\n  enum ItemSlots {\\n    UNKNOWN, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    BOOTS, // 6\\n    RIGHT_RING, // 7\\n    LEFT_RING, // 8\\n    RIGHT_HAND, // 9\\n    LEFT_HAND, // 10\\n    TWO_HAND, // 11\\n    SKILL_1, // 12\\n    SKILL_2, // 13\\n    SKILL_3, // 14\\n    END_SLOT // 15\\n  }\\n\\n  struct NftItem {\\n    address token;\\n    uint tokenId;\\n  }\\n\\n  enum Race {\\n    UNKNOWN, // 0\\n    HUMAN, // 1\\n    UNDEAD, // 2\\n    DAEMON, // 3\\n    BEAST, // 4\\n    END_SLOT // 5\\n  }\\n\\n  struct ChangeAttributesInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    int32[] changeAttributes;\\n    bool add;\\n    bool temporally;\\n  }\\n\\n  struct BuffInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    uint32 heroLevel;\\n    address[] buffTokens;\\n    uint[] buffTokenIds;\\n  }\\n\\n  /// @dev This struct is used inside event, so it's moved here from lib\\n  struct ActionInternalInfo {\\n    int32[] posAttributes;\\n    int32[] negAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintedItems;\\n  }\\n\\n  function initNewHero(address token, uint tokenId, uint heroClass) external;\\n\\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory);\\n\\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32);\\n\\n  function heroAttributesLength(address token, uint tokenId) external view returns (uint);\\n\\n  function heroBaseAttributes(address token, uint tokenId) external view returns (CoreAttributes memory);\\n\\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint);\\n\\n  function globalCustomData(bytes32 index) external view returns (uint);\\n\\n  function heroStats(address token, uint tokenId) external view returns (ChangeableStats memory);\\n\\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked);\\n\\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory);\\n\\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function levelUp(address token, uint tokenId, uint heroClass, CoreAttributes memory change) external returns (uint newLvl);\\n\\n  function changeHeroItemSlot(\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) external;\\n\\n  function changeCurrentStats(\\n    address token,\\n    uint tokenId,\\n    ChangeableStats memory change,\\n    bool increase\\n  ) external;\\n\\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external;\\n\\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external;\\n\\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external;\\n\\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external;\\n\\n  function buffHero(BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed);\\n\\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external;\\n\\n  function setGlobalCustomData(bytes32 index, uint value) external;\\n\\n  /// @notice Restore life and mana during reinforcement\\n  /// @param prevAttributes Hero attributes before reinforcement\\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external;\\n}\\n\",\"keccak256\":\"0xb6e25f1fae300c03cacdba3b8b0e56b7e8c46a8cb3abb168ddada2375aaf1f3c\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStoryController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"./IController.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./IHeroController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStoryController {\\n\\n  enum AnswerResultId {\\n    UNKNOWN, // 0\\n    SUCCESS, // 1\\n    ATTRIBUTE_FAIL, // 2\\n    RANDOM_FAIL, // 3\\n    DELAY_FAIL, // 4\\n    HERO_CUSTOM_DATA_FAIL, // 5\\n    GLOBAL_CUSTOM_DATA_FAIL, // 6\\n\\n    END_SLOT\\n  }\\n\\n  enum CustomDataResult {\\n    UNKNOWN, // 0\\n    HERO_SUCCESS, // 1\\n    HERO_FAIL, // 2\\n    GLOBAL_SUCCESS, // 3\\n    GLOBAL_FAIL, // 4\\n\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:story.controller.main\\n  struct MainState {\\n\\n    // --- STORY REG INFO ---\\n\\n    /// @dev Uniq story identification.\\n    mapping(uint32 => uint16) storyIds;\\n    /// @dev Revers mapping for stories for using in the next object rewrite logic.\\n    mapping(uint16 => uint32) idToStory;\\n    /// @dev Store used ids for stories.\\n    mapping(uint16 => bool) _usedStoryIds;\\n    /// @dev Prevent register the story twice\\n    mapping(uint32 => bool) registeredStories;\\n\\n    // --- ANSWER MAPPING ---\\n\\n    /// @dev storyId => all story pages. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.UintSet) allStoryPages;\\n\\n    /// @dev storyId => all possible answers. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.Bytes32Set) allStoryAnswers;\\n\\n    /// @dev storyId + pageId + heroClass (zero is default answers) => storyId + pageId + heroClass (zero is default answers) + answerId\\n    mapping(bytes32 => bytes32[]) answers;\\n    /// @dev answerUnPackedId + answerResultId => nextPageIds (will be chosen randomly from this array)\\n    ///      where answerResultId is:\\n    ///      0 - unknown,\\n    ///      1 - success,\\n    ///      2 - attr fail\\n    ///      3 - random fail\\n    ///      4 - delay fail\\n    ///      5 - hero custom data fail\\n    ///      6 - global custom data fail\\n    ///      see COUNT_ANSWER_RESULT_IDS\\n    mapping(bytes32 => uint16[]) nextPageIds;\\n    /// @dev story + pageId + heroClass (zero is default answers) => random nextObjs (adr + id, like packed nft id)\\n    mapping(bytes32 => uint32[]) nextObjectsRewrite;\\n\\n    /// @dev answerPackedId => packed array of uint32[]\\n    ///      0 - random requirement(uint32, 1 - 99% success of this action, zero means no check)\\n    ///      1 - delay requirement(uint32, if time since the last call more than this value the check is fail, zero means no check)\\n    ///      2 - isFinalAnswer(uint8)\\n    mapping(bytes32 => bytes32) answerAttributes;\\n\\n    // --- ANSWER REQUIREMENTS ---\\n\\n    /// @dev answerPackedId => array of AttributeRequirementsPacked\\n    mapping(bytes32 => bytes32[]) attributeRequirements;\\n    /// @dev answerPackedId=> array of ItemRequirementsPacked\\n    mapping(bytes32 => bytes32[]) itemRequirements;\\n    /// @dev answerPackedId => array of TokenRequirementsPacked\\n    mapping(bytes32 => bytes32[]) tokenRequirements;\\n    /// @dev answerPackedId => custom data for hero\\n    mapping(bytes32 => CustomDataRequirementPacked[]) heroCustomDataRequirement;\\n    /// @dev answerPackedId => global custom data\\n    mapping(bytes32 => CustomDataRequirementPacked[]) globalCustomDataRequirement;\\n\\n    // --- ANSWER RESULTS ---\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) successInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) successInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) successInfoMintItems;\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) failInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) failInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) failInfoMintItems;\\n\\n    /// @dev answerUnPackedId + CustomDataResult => custom data array change\\n    ///      where CustomDataResult is\\n    ///      1 - hero success\\n    ///      2 - hero fail\\n    ///      3 - global success\\n    ///      4 - global fail\\n    ///      see COUNT_CUSTOM_DATA_RESULT_IDS\\n    mapping(bytes32 => bytes32[]) customDataResult;\\n\\n    /// @notice answerPackedId => slot+chance+stopIfBurnt\\n    /// @dev Since SIP-003 the items are not burn but broke\\n    mapping(bytes32 => bytes32[]) burnItem;\\n\\n    // --- GENERAL STORY REQUIREMENTS ---\\n\\n    /// @dev story => Custom hero data requirements for a story. If exist and hero is not eligible should be not chose in a dungeon.\\n    mapping(uint => CustomDataRequirementRangePacked[]) storyRequiredHeroData;\\n    /// @dev story => Minimal level for the history. 0 means no requirements.\\n    mapping(uint => uint) storyRequiredLevel;\\n\\n    // --- HERO STATES ---\\n\\n    /// @dev hero + heroId + storyId => pageId + heroLastActionTS\\n    mapping(bytes32 => bytes32) heroState;\\n\\n    // --- OTHER ---\\n\\n    /// @dev storyId => build hash for the last update\\n    mapping(uint16 => uint) storyBuildHash;\\n\\n    /// @notice Number of already minted items by the user within the given iteration of the story.\\n    /// Only minting of the given number of items is allowed per iteration (see MAX_MINTED_ITEMS_PER_ITERATION).\\n    /// @dev hero, heroId, story => mintedInIteration\\n    /// This map is not cleared: storyId:objectId is 1:1, each object has own sequence of iterations without duplicates\\n    mapping(bytes32 => mapping(uint iteration => uint countMintedItems)) mintedInIteration;\\n  }\\n\\n  /// @dev We need to have flat structure coz Solidity can not handle arrays of structs properly\\n  struct StoryMetaInfo {\\n    uint16 storyId;\\n\\n    // --- story reqs\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n    uint minLevel;\\n\\n    // --- answer reqs\\n\\n    AnswersMeta answersMeta;\\n    AnswerNextPageMeta answerNextPage;\\n    AnswerAttributeRequirementsMeta answerAttributeRequirements;\\n    AnswerItemRequirementsMeta answerItemRequirements;\\n    AnswerTokenRequirementsMeta answerTokenRequirements;\\n    AnswerAttributesMeta answerAttributes;\\n    AnswerCustomDataMeta answerHeroCustomDataRequirement;\\n    AnswerCustomDataMeta answerGlobalCustomDataRequirement;\\n\\n    // --- answer results\\n\\n    AnswerBurnRandomItemMeta answerBurnRandomItemMeta;\\n    NextObjRewriteMeta nextObjRewriteMeta;\\n\\n    // --- story results\\n\\n    AnswerResultMeta successInfo;\\n    AnswerResultMeta failInfo;\\n\\n    AnswerCustomDataResultMeta successHeroCustomData;\\n    AnswerCustomDataResultMeta failHeroCustomData;\\n    AnswerCustomDataResultMeta successGlobalCustomData;\\n    AnswerCustomDataResultMeta failGlobalCustomData;\\n  }\\n\\n  struct NextObjRewriteMeta {\\n    uint16[] nextObjPageIds;\\n    uint8[] nextObjHeroClasses;\\n    uint32[][] nextObjIds;\\n  }\\n\\n  struct AnswersMeta {\\n    uint16[] answerPageIds;\\n    uint8[] answerHeroClasses;\\n    uint16[] answerIds;\\n  }\\n\\n  struct AnswerNextPageMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint8[] answerResultIds;\\n    uint16[][] answerNextPageIds;\\n  }\\n\\n  struct AnswerAttributeRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    bool[][] cores;\\n    uint8[][] ids;\\n    int32[][] values;\\n  }\\n\\n  struct AnswerItemRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireItems;\\n    bool[][] requireItemBurn;\\n    bool[][] requireItemEquipped;\\n  }\\n\\n  struct AnswerTokenRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireToken;\\n    uint88[][] requireAmount;\\n    bool[][] requireTransfer;\\n  }\\n\\n  struct AnswerAttributesMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint32[] randomRequirements;\\n    uint32[] delayRequirements;\\n    bool[] isFinalAnswer;\\n  }\\n\\n  struct AnswerCustomDataMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    bool[][] mandatory;\\n    uint64[][] dataValuesMin;\\n    uint64[][] dataValuesMax;\\n  }\\n\\n  struct AnswerResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    uint8[][] attributeIds;\\n    /// @dev Max value is limitied by int24, see toBytes32ArrayWithIds impl\\n    int32[][] attributeValues;\\n\\n    uint32[] experience;\\n    int32[] heal;\\n    int32[] manaRegen;\\n    int32[] lifeChancesRecovered;\\n    int32[] damage;\\n    int32[] manaConsumed;\\n\\n    address[][] mintItems;\\n    uint32[][] mintItemsChances;\\n  }\\n\\n  struct AnswerCustomDataResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    int16[][] dataValues;\\n  }\\n\\n  struct AnswerBurnRandomItemMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    /// @notice 0 - random slot\\n    uint8[][] slots;\\n    /// @notice typical chances are [0..100] (no decimals here)\\n    uint64[][] chances;\\n    /// @notice Since SIP-003 the burning is replaced by breaking bu the name is kept as is\\n    bool[][] isStopIfBurnt;\\n  }\\n\\n  struct CustomDataRequirementPacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + mandatory(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct CustomDataRequirementRangePacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + isHeroData(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct StatsChange {\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n  }\\n\\n  struct StoryActionContext {\\n    uint stageId;\\n    uint iteration;\\n    bytes32 answerIdHash;\\n    bytes32 answerAttributes;\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IStatController statController;\\n    IHeroController heroController;\\n    IOracle oracle;\\n    IItemController itemController;\\n    uint8 heroClass;\\n    uint8 heroClassFromAnswerHash;\\n    uint8 biome;\\n    uint16 storyId;\\n    uint16 storyIdFromAnswerHash;\\n    uint16 pageIdFromAnswerHash;\\n    uint16 answerNumber;\\n    uint16 pageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint40 heroLastActionTS;\\n    uint80 heroTokenId;\\n    IStatController.ChangeableStats heroStats;\\n  }\\n\\n  // --- WRITE ---\\n\\n  function storyAction(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) external returns (IGOC.ActionResult memory);\\n\\n  // --- READ ---\\n\\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function idToStory(uint16 id) external view returns (uint32 objectId);\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId);\\n\\n  function storyIds(uint32 objectId) external view returns (uint16);\\n\\n  function registeredStories(uint32 objectId) external view returns (bool);\\n\\n}\\n\",\"keccak256\":\"0x7822f79d53590b18455c5d54d91f5b38fabc1330f24ae41db546a785c151e61d\",\"license\":\"BUSL-1.1\"},\"contracts/lib/CalcLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\n\\nlibrary CalcLib {\\n\\n  uint32 public constant MAX_CHANCE = 1e9;\\n\\n  function minI32(int32 a, int32 b) internal pure returns (int32) {\\n    return a < b ? a : b;\\n  }\\n\\n  function max32(int32 a, int32 b) internal pure returns (int32) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function absDiff(int32 a, int32 b) internal pure returns (uint32) {\\n    if (!((a >= 0 && b >= 0) || (a <= 0 && b <= 0))) revert IAppErrors.AbsDiff(a, b);\\n    if (a < 0) {\\n      a = - a;\\n    }\\n    if (b < 0) {\\n      b = - b;\\n    }\\n    return uint32(uint(int(a >= b ? a - b : b - a)));\\n  }\\n\\n  function toUint(int32 n) internal pure returns (uint) {\\n    if (n < 0) {\\n      return 0;\\n    }\\n    if (n <= 0) {\\n      return 0;\\n    }\\n    return uint(int(n));\\n  }\\n\\n  function toInt32(uint a) internal pure returns (int32){\\n    if (a >= uint(int(type(int32).max))) {\\n      return type(int32).max;\\n    }\\n    return int32(int(a));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandom(uint maxValue) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft()))) % (maxValue + 1));\\n  }\\n\\n  function pseudoRandomUint32(uint32 maxValue) internal view returns (uint32) {\\n    return uint32(pseudoRandom(uint(maxValue)));\\n  }\\n\\n  /// @notice Generate pseudo-random uint in the range [0..maxValue) using Solady pseudo-random function\\n  function nextPrng(LibPRNG.PRNG memory prng, uint maxValue) internal pure returns (uint) {\\n    return LibPRNG.next(prng) % maxValue;\\n  }\\n\\n  /// @notice pseudoRandomUint32 with customizable pseudoRandom()\\n  function pseudoRandomUint32Flex(\\n    uint32 maxValue,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint32) {\\n    return uint32(random_(uint(maxValue)));\\n  }\\n\\n  function pseudoRandomInt32(int32 maxValue) internal view returns (int32) {\\n    bool neg;\\n    if (maxValue < 0) {\\n      neg = true;\\n      maxValue = - maxValue;\\n    }\\n    uint32 v = uint32(pseudoRandom(uint(int(maxValue))));\\n    return neg\\n      ? - int32(int(uint(v)))\\n      : int32(int(uint(v)));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandomWithSeed(uint maxValue, uint seed) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), seed))) % (maxValue + 1));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  function pseudoRandomInRange(uint min, uint max) internal view returns (uint) {\\n    if (min >= max) {\\n      return max;\\n    }\\n    uint r = pseudoRandom(max - min);\\n    return min + r;\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  ///      Equal to pseudoRandomInRange(min, max, pseudoRandom)\\n  function pseudoRandomInRangeFlex(\\n    uint min,\\n    uint max,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint) {\\n    return min >= max ? max : min + random_(max - min);\\n  }\\n\\n  function minusWithZeroFloor(uint a, uint b) internal pure returns (uint){\\n    if (a <= b) {\\n      return 0;\\n    }\\n    return a - b;\\n  }\\n\\n  function minusWithMinFloorI32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) - int(b) < type(int32).min) {\\n      return type(int32).min;\\n    }\\n    return a - b;\\n  }\\n\\n  function plusWithMaxFloor32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) + int(b) >= type(int32).max) {\\n      return type(int32).max;\\n    }\\n    return a + b;\\n  }\\n\\n  function sqrt(uint x) internal pure returns (uint z) {\\n    assembly {\\n    // Start off with z at 1.\\n      z := 1\\n\\n    // Used below to help find a nearby power of 2.\\n      let y := x\\n\\n    // Find the lowest power of 2 that is at least sqrt(x).\\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n        y := shr(128, y) // Like dividing by 2 ** 128.\\n        z := shl(64, z) // Like multiplying by 2 ** 64.\\n      }\\n      if iszero(lt(y, 0x10000000000000000)) {\\n        y := shr(64, y) // Like dividing by 2 ** 64.\\n        z := shl(32, z) // Like multiplying by 2 ** 32.\\n      }\\n      if iszero(lt(y, 0x100000000)) {\\n        y := shr(32, y) // Like dividing by 2 ** 32.\\n        z := shl(16, z) // Like multiplying by 2 ** 16.\\n      }\\n      if iszero(lt(y, 0x10000)) {\\n        y := shr(16, y) // Like dividing by 2 ** 16.\\n        z := shl(8, z) // Like multiplying by 2 ** 8.\\n      }\\n      if iszero(lt(y, 0x100)) {\\n        y := shr(8, y) // Like dividing by 2 ** 8.\\n        z := shl(4, z) // Like multiplying by 2 ** 4.\\n      }\\n      if iszero(lt(y, 0x10)) {\\n        y := shr(4, y) // Like dividing by 2 ** 4.\\n        z := shl(2, z) // Like multiplying by 2 ** 2.\\n      }\\n      if iszero(lt(y, 0x8)) {\\n      // Equivalent to 2 ** z.\\n        z := shl(1, z)\\n      }\\n\\n    // Shifting right by 1 is like dividing by 2.\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n\\n    // Compute a rounded down version of z.\\n      let zRoundDown := div(x, z)\\n\\n    // If zRoundDown is smaller, use it.\\n      if lt(zRoundDown, z) {\\n        z := zRoundDown\\n      }\\n    }\\n  }\\n\\n  /*********************************************\\n *              PRB-MATH                      *\\n *   https://github.com/hifi-finance/prb-math *\\n **********************************************/\\n  /// @notice Calculates the binary logarithm of x.\\n  ///\\n  /// @dev Based on the iterative approximation algorithm.\\n  /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n  ///\\n  /// Requirements:\\n  /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n  ///\\n  /// Caveats:\\n  /// - The results are nor perfectly accurate to the last decimal,\\n  ///   due to the lossy precision of the iterative approximation.\\n  ///\\n  /// @param x The unsigned 60.18-decimal fixed-point number for which\\n  ///           to calculate the binary logarithm.\\n  /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n  function log2(uint256 x) internal pure returns (uint256 result) {\\n    if (x < 1e18) revert IAppErrors.TooLowX(x);\\n\\n    // Calculate the integer part of the logarithm\\n    // and add it to the result and finally calculate y = x * 2^(-n).\\n    uint256 n = mostSignificantBit(x / 1e18);\\n\\n    // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number.\\n    // The operation can't overflow because n is maximum 255 and SCALE is 1e18.\\n    uint256 rValue = n * 1e18;\\n\\n    // This is y = x * 2^(-n).\\n    uint256 y = x >> n;\\n\\n    // If y = 1, the fractional part is zero.\\n    if (y == 1e18) {\\n      return rValue;\\n    }\\n\\n    // Calculate the fractional part via the iterative approximation.\\n    // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n    for (uint256 delta = 5e17; delta > 0; delta >>= 1) {\\n      y = (y * y) / 1e18;\\n\\n      // Is y^2 > 2 and so in the range [2,4)?\\n      if (y >= 2 * 1e18) {\\n        // Add the 2^(-m) factor to the logarithm.\\n        rValue += delta;\\n\\n        // Corresponds to z/2 on Wikipedia.\\n        y >>= 1;\\n      }\\n    }\\n    return rValue;\\n  }\\n\\n  /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n  /// @dev See the note on msb in the \\\"Find First Set\\\"\\n  ///      Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n  /// @param x The uint256 number for which to find the index of the most significant bit.\\n  /// @return msb The index of the most significant bit as an uint256.\\n  //noinspection NoReturn\\n  function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n    if (x >= 2 ** 128) {\\n      x >>= 128;\\n      msb += 128;\\n    }\\n    if (x >= 2 ** 64) {\\n      x >>= 64;\\n      msb += 64;\\n    }\\n    if (x >= 2 ** 32) {\\n      x >>= 32;\\n      msb += 32;\\n    }\\n    if (x >= 2 ** 16) {\\n      x >>= 16;\\n      msb += 16;\\n    }\\n    if (x >= 2 ** 8) {\\n      x >>= 8;\\n      msb += 8;\\n    }\\n    if (x >= 2 ** 4) {\\n      x >>= 4;\\n      msb += 4;\\n    }\\n    if (x >= 2 ** 2) {\\n      x >>= 2;\\n      msb += 2;\\n    }\\n    if (x >= 2 ** 1) {\\n      // No need to shift x any more.\\n      msb += 1;\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0xd5178ce117e26987cd3cb3496e13bd2c6e7d220557ec25f771444dd2f4d2db5b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PackingLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\n\\nlibrary PackingLib {\\n\\n  error TooHighValue(uint value);\\n  error OutOfBounds(uint index, uint length);\\n  error UnexpectedValue(uint expected, uint actual);\\n  error WrongValue(uint newValue, uint actual);\\n  error LengthsMismatch();\\n  error IntOutOfRange(int value);\\n  error ZeroValue();\\n  /// @notice packCustomDataChange requires an input string with two zero bytes at the beginning\\n  ///         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// This error happens if these bytes are not zero\\n  error IncompatibleInputString();\\n\\n  //////////////////////////\\n  // ---- PACKING LOGIC ----\\n  //////////////////////////\\n\\n  //region ------------------------------------ COMMON\\n\\n  function packNftId(address token, uint id) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n  }\\n\\n  function unpackNftId(bytes32 data) internal pure returns (address token, uint id) {\\n    token = address(uint160(uint(data)));\\n    id = uint(data) >> 160;\\n  }\\n\\n  function packAddressWithAmount(address token, uint amount) internal pure returns (bytes32 data) {\\n    if (amount > uint(type(uint96).max)) revert TooHighValue(amount);\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(uint96(amount))) << 160;\\n  }\\n\\n  function unpackAddressWithAmount(bytes32 data) internal pure returns (address token, uint amount) {\\n    token = address(uint160(uint(data)));\\n    amount = uint(data) >> 160;\\n  }\\n\\n  function packItemMintInfo(address item, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(chance)) << 160;\\n  }\\n\\n  function unpackItemMintInfo(bytes32 data) internal pure returns (address item, uint32 chance) {\\n    item = address(uint160(uint(data)));\\n    chance = uint32(uint(data) >> 160);\\n  }\\n\\n  /// @param customDataIndex We assume, that two lowest bytes of this string are always zero\\n  /// So, the string looks like following: 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// Last 2 bytes will be used to encode {value}\\n  function packCustomDataChange(bytes32 customDataIndex, int16 value) internal pure returns (bytes32 data) {\\n    if (uint(customDataIndex) != (uint(customDataIndex) >> 16) << 16) revert IncompatibleInputString();\\n    data = bytes32(uint(customDataIndex));\\n    data |= bytes32(uint(uint16(value)));\\n  }\\n\\n  function unpackCustomDataChange(bytes32 data) internal pure returns (bytes32 customDataIndex, int16 value) {\\n    customDataIndex = bytes32((uint(data) >> 16) << 16);\\n    value = int16(int(uint(uint16(uint(data)))));\\n  }\\n\\n  /// @dev min(uint64) + max(uint64) + isHeroData/isMandatory(uint8)\\n  function packCustomDataRequirements(uint64 min, uint64 max, bool key) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(min));\\n    data |= bytes32(uint(max)) << 64;\\n    data |= bytes32(uint(key ? uint8(1) : uint8(0))) << (64 + 64);\\n  }\\n\\n  function unpackCustomDataRequirements(bytes32 data) internal pure returns (uint64 min, uint64 max, bool key) {\\n    min = uint64(uint(data));\\n    max = uint64(uint(data) >> 64);\\n    key = uint8(uint(data) >> (64 + 64)) == uint8(1);\\n  }\\n\\n  function packStatsChange(\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(experience));\\n    data |= bytes32(uint(uint32(heal))) << 32;\\n    data |= bytes32(uint(uint32(manaRegen))) << (32 + 32);\\n    data |= bytes32(uint(uint32(lifeChancesRecovered))) << (32 + 32 + 32);\\n    data |= bytes32(uint(uint32(damage))) << (32 + 32 + 32 + 32);\\n    data |= bytes32(uint(uint32(manaConsumed))) << (32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackStatsChange(bytes32 data) internal pure returns (\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) {\\n    experience = uint32(uint(data));\\n    heal = int32(int(uint(data) >> 32));\\n    manaRegen = int32(int(uint(data) >> (32 + 32)));\\n    lifeChancesRecovered = int32(int(uint(data) >> (32 + 32 + 32)));\\n    damage = int32(int(uint(data) >> (32 + 32 + 32 + 32)));\\n    manaConsumed = int32(int(uint(data) >> (32 + 32 + 32 + 32 + 32)));\\n  }\\n  //endregion ------------------------------------ COMMON\\n\\n  //region ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(bytes20(objectAddress));\\n    packedData |= bytes32(uint(objectId) << 32);\\n    packedData |= bytes32(uint(objectType) << 24);\\n  }\\n\\n  function unpackMapObject(bytes32 packedData) internal pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\\n    objectAddress = address(bytes20(packedData));\\n    objectId = uint64(uint(packedData) >> 32);\\n    objectType = uint8(uint(packedData) >> 24);\\n  }\\n\\n  function packCoordinate(uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(x));\\n    packedData |= bytes32(uint(y) << 128);\\n  }\\n\\n  function unpackCoordinate(bytes32 packedData) internal pure returns (uint128 x, uint128 y) {\\n    x = uint128(uint(packedData));\\n    y = uint128(uint(packedData) >> 128);\\n  }\\n\\n  /// @param x Assume x <= max uint64\\n  /// @param y Assume y <= max uint64\\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    // 256 => 128 + 128;\\n    // 1) 128 is used for biomeMapFieldId, territoryNumber and probably other fields in the future\\n    // 2) 128 is used to store x, y as uint64, uint64\\n\\n    // we will use uint64 for coordinates assuming it is more than enough for biome map\\n    packedData = bytes32(uint(biomeMapFieldId));\\n    packedData |= bytes32(uint(territoryNumber) << (8));\\n    packedData |= bytes32(uint(uint64(x)) << 128);\\n    packedData |= bytes32(uint(uint64(y)) << (64 + 128));\\n  }\\n\\n  function unpackBattlefieldId(bytes32 packedData) internal pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\\n    biomeMapFieldId = uint8(uint(packedData));\\n    territoryNumber = uint8(uint(packedData) >> (8));\\n    x = uint128(uint64(uint(packedData) >> (128)));\\n    y = uint128(uint64(uint(packedData) >> (64 + 128)));\\n  }\\n  //endregion ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  //region ------------------------------------ REINFORCEMENT\\n\\n  function packReinforcementHeroInfo(uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(biome));\\n    packedData |= bytes32(uint(score) << 8);\\n    packedData |= bytes32(uint(fee) << (8 + 128));\\n    packedData |= bytes32(uint(stakeTs) << (8 + 128 + 8));\\n  }\\n\\n  function unpackReinforcementHeroInfo(bytes32 packedData) internal pure returns (uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) {\\n    biome = uint8(uint(packedData));\\n    score = uint128(uint(packedData) >> 8);\\n    fee = uint8(uint(packedData) >> (8 + 128));\\n    stakeTs = uint64(uint(packedData) >> (8 + 128 + 8));\\n  }\\n  //endregion ------------------------------------ REINFORCEMENT\\n\\n  //region ------------------------------------ DUNGEON\\n\\n  function packDungeonKey(address heroAdr, uint80 heroId, uint16 dungLogicNum) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(dungLogicNum)) << (160 + 80);\\n  }\\n\\n  function unpackDungeonKey(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 dungLogicNum) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    dungLogicNum = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  // --- GAME OBJECTS ---\\n\\n  function packIterationKey(address heroAdr, uint64 heroId, uint32 objId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(objId)) << (160 + 64);\\n  }\\n\\n  function unpackIterationKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint32 objId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    objId = uint32(uint(data) >> (160 + 64));\\n  }\\n\\n  function packMonsterStats(\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(level));\\n    data |= bytes32(uint(race)) << 8;\\n    data |= bytes32(uint(experience)) << (8 + 8);\\n    data |= bytes32(uint(maxDropItems)) << (8 + 8 + 32);\\n  }\\n\\n  function unpackMonsterStats(bytes32 data) internal pure returns (\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) {\\n    level = uint8(uint(data));\\n    race = uint8(uint(data) >> 8);\\n    experience = uint32(uint(data) >> (8 + 8));\\n    maxDropItems = uint8(uint(data) >> (8 + 8 + 32));\\n  }\\n\\n  function packAttackInfo(\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(attackToken)));\\n    data |= bytes32(uint(attackTokenId)) << 160;\\n    data |= bytes32(uint(attackType)) << (160 + 64);\\n  }\\n\\n  function unpackAttackInfo(bytes32 data) internal pure returns (\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) {\\n    attackToken = address(uint160(uint(data)));\\n    attackTokenId = uint64(uint(data) >> 160);\\n    attackType = uint8(uint(data) >> (160 + 64));\\n  }\\n\\n  function packPlayedObjKey(address heroAdr, uint64 heroId, uint8 oType, uint8 biome) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(oType)) << (160 + 64);\\n    data |= bytes32(uint(biome)) << (160 + 64 + 8);\\n  }\\n\\n  function unpackPlayedObjKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint8 oType, uint8 biome) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    oType = uint8(uint(data) >> (160 + 64));\\n    biome = uint8(uint(data) >> (160 + 64 + 8));\\n  }\\n\\n  function packGeneratedMonster(bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint8(generated ? 1 : 0)));\\n    data |= bytes32(uint(amplifier)) << 8;\\n    data |= bytes32(uint(uint32(hp))) << (8 + 32);\\n    data |= bytes32(uint(turnCounter)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 data) internal pure returns (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) {\\n    generated = uint8(uint(data)) == uint8(1);\\n    amplifier = uint32(uint(data) >> 8);\\n    hp = int32(int(uint(data) >> (8 + 32)));\\n    turnCounter = uint8(uint(data) >> (8 + 32 + 32));\\n  }\\n  //endregion ------------------------------------ DUNGEON\\n\\n  //region ------------------------------------ ITEMS\\n\\n  /// @notice itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n  /// @param itemType This is ItemType enum\\n  function packItemMeta(\\n    uint8 itemMetaType,\\n    uint8 itemLvl,\\n    uint8 itemType,\\n    uint16 baseDurability,\\n    uint8 defaultRarity,\\n    uint8 minAttr,\\n    uint8 maxAttr,\\n    uint32 manaCost,\\n    IStatController.CoreAttributes memory req\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(itemMetaType));\\n    data |= bytes32(uint(itemLvl)) << 8;\\n    data |= bytes32(uint(itemType)) << (8 + 8);\\n    data |= bytes32(uint(baseDurability)) << (8 + 8 + 8);\\n    data |= bytes32(uint(defaultRarity)) << (8 + 8 + 8 + 16);\\n    data |= bytes32(uint(minAttr)) << (8 + 8 + 8 + 16 + 8);\\n    data |= bytes32(uint(maxAttr)) << (8 + 8 + 8 + 16 + 8 + 8);\\n    data |= bytes32(uint(manaCost)) << (8 + 8 + 8 + 16 + 8 + 8 + 8);\\n    data |= bytes32(uint(int(req.strength))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32);\\n    data |= bytes32(uint(int(req.dexterity))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32);\\n    data |= bytes32(uint(int(req.vitality))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(req.energy))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemMeta(bytes32 data) internal pure returns (IItemController.ItemMeta memory) {\\n    IItemController.ItemMeta memory result;\\n\\n    result.itemMetaType = uint8(uint(data));\\n    result.itemLevel = uint8(uint(data) >> 8);\\n    result.itemType = IItemController.ItemType(uint8(uint(data) >> (8 + 8)));\\n    result.baseDurability = uint16(uint(data) >> (8 + 8 + 8));\\n    result.defaultRarity = uint8(uint(data) >> (8 + 8 + 8 + 16));\\n    result.minRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8));\\n    result.maxRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8));\\n    result.manaCost = uint32(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8));\\n    result.requirements.strength = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32)));\\n    result.requirements.dexterity = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32)));\\n    result.requirements.vitality = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32)));\\n    result.requirements.energy = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32)));\\n\\n    return result;\\n  }\\n\\n  function packItemGenerateInfo(uint8 id, int32 min, int32 max, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(id));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(chance)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32 data) internal pure returns (uint8 id, int32 min, int32 max, uint32 chance) {\\n    id = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    chance = uint32(uint(data) >> (8 + 32 + 32));\\n  }\\n\\n  function packItemAttackInfo(\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attackType));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(int(factorStr))) << (8 + 32 + 32);\\n    data |= bytes32(uint(int(factorDex))) << (8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorVit))) << (8 + 32 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorEng))) << (8 + 32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 data) internal pure returns (\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) {\\n    attackType = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    factorStr = int32(int(uint(data) >> (8 + 32 + 32)));\\n    factorDex = int32(int(uint(data) >> (8 + 32 + 32 + 32)));\\n    factorVit = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32)));\\n    factorEng = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packItemInfo(uint8 rarity, uint8 augmentationLevel, uint16 durability) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(rarity));\\n    data |= bytes32(uint(augmentationLevel)) << 8;\\n    data |= bytes32(uint(durability)) << (8 + 8);\\n  }\\n\\n  function unpackItemInfo(bytes32 data) internal pure returns (uint8 rarity, uint8 augmentationLevel, uint16 durability) {\\n    rarity = uint8(uint(data));\\n    augmentationLevel = uint8(uint(data) >> 8);\\n    durability = uint16(uint(data) >> (8 + 8));\\n  }\\n  //endregion ------------------------------------ ITEMS\\n\\n  //region ------------------------------------ STORIES\\n\\n  function packStoryPageId(uint16 storyId, uint16 pageId, uint8 heroClass) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n  }\\n\\n  function unpackStoryPageId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n  }\\n\\n  function packStoryAnswerId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n  }\\n\\n  function unpackStoryAnswerId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n  }\\n\\n  function packStoryNextPagesId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(resultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryNextPagesId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    resultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryAttributeRequirement(uint8 attributeIndex, int32 value, bool isCore) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attributeIndex));\\n    data |= bytes32(uint(uint32(value))) << 8;\\n    data |= bytes32(uint(isCore ? uint8(1) : uint8(0))) << (8 + 32);\\n  }\\n\\n  function unpackStoryAttributeRequirement(bytes32 data) internal pure returns (uint8 attributeIndex, int32 value, bool isCore) {\\n    attributeIndex = uint8(uint(data));\\n    value = int32(int(uint(data) >> 8));\\n    isCore = uint8(uint(data) >> (8 + 32)) == uint8(1);\\n  }\\n\\n  function packStoryItemRequirement(address item, bool requireItemBurn, bool requireItemEquipped) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(requireItemBurn ? uint8(1) : uint8(0))) << 160;\\n    data |= bytes32(uint(requireItemEquipped ? uint8(1) : uint8(0))) << (160 + 8);\\n  }\\n\\n  function unpackStoryItemRequirement(bytes32 data) internal pure returns (address item, bool requireItemBurn, bool requireItemEquipped) {\\n    item = address(uint160(uint(data)));\\n    requireItemBurn = uint8(uint(data) >> 160) == uint8(1);\\n    requireItemEquipped = uint8(uint(data) >> (160 + 8)) == uint8(1);\\n  }\\n\\n  /// @dev max amount is 309,485,009 for token with 18 decimals\\n  function packStoryTokenRequirement(address token, uint88 amount, bool requireTransfer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(amount)) << 160;\\n    data |= bytes32(uint(requireTransfer ? uint8(1) : uint8(0))) << (160 + 88);\\n  }\\n\\n  function unpackStoryTokenRequirement(bytes32 data) internal pure returns (address token, uint88 amount, bool requireTransfer) {\\n    token = address(uint160(uint(data)));\\n    amount = uint88(uint(data) >> 160);\\n    requireTransfer = uint8(uint(data) >> (160 + 88)) == uint8(1);\\n  }\\n\\n  function packStoryCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(customDataResultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryCustomDataResult(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    customDataResultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryHeroState(uint16 pageId, uint40 heroLastActionTS) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(pageId));\\n    data |= bytes32(uint(heroLastActionTS)) << 16;\\n  }\\n\\n  function unpackStoryHeroState(bytes32 data) internal pure returns (uint16 pageId, uint40 heroLastActionTS) {\\n    pageId = uint16(uint(data));\\n    heroLastActionTS = uint40(uint(data) >> 16);\\n  }\\n\\n  function packStoryHeroStateId(address heroAdr, uint80 heroId, uint16 storyId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(storyId)) << (160 + 80);\\n  }\\n\\n  function unpackStoryHeroStateId(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 storyId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    storyId = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  function packStorySimpleRequirement(uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(randomRequirement));\\n    data |= bytes32(uint(delayRequirement)) << 32;\\n    data |= bytes32(uint(isFinalAnswer ? uint8(1) : uint8(0))) << (32 + 32);\\n  }\\n\\n  function unpackStorySimpleRequirement(bytes32 data) internal pure returns (uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) {\\n    randomRequirement = uint32(uint(data));\\n    delayRequirement = uint32(uint(data) >> 32);\\n    isFinalAnswer = uint8(uint(data) >> (32 + 32)) == uint8(1);\\n  }\\n\\n  function packBreakInfo(uint8 slot, uint64 chance, bool stopIfBroken) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(slot));\\n    data |= bytes32(uint(chance)) << 8;\\n    data |= bytes32(uint(stopIfBroken ? uint8(1) : uint8(0))) << (8 + 64);\\n  }\\n\\n  function unpackBreakInfo(bytes32 data) internal pure returns (uint8 slot, uint64 chance, bool stopIfBurned) {\\n    slot = uint8(uint(data));\\n    chance = uint64(uint(data) >> 8);\\n    stopIfBurned = uint8(uint(data) >> (8 + 64)) == uint8(1);\\n  }\\n  //endregion ------------------------------------ STORIES\\n\\n  ////////////////////////////////////////////////////////////////////////////////////\\n  // ---- ARRAYS LOGIC ----\\n  ////////////////////////////////////////////////////////////////////////////////////\\n\\n  //region ------------------------------------ SIMPLE ARRAYS\\n\\n\\n  function packUint8Array(uint8[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 32) revert OutOfBounds(len, 32);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 8);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {packUint8Array} for small number of items\\n  ///         It allows to exclude dynamic array creation.\\n  function packUint8Array3(uint8 a, uint8 b, uint8 c) internal pure returns (bytes32) {\\n    bytes32 result = bytes32(uint(a));\\n    result |= bytes32(uint(b)) << (1 * 8);\\n    result |= bytes32(uint(c)) << (2 * 8);\\n    return result;\\n  }\\n\\n\\n  function unpackUint8Array(bytes32 data) internal pure returns (uint8[] memory) {\\n    uint8[] memory result = new uint8[](32);\\n    for (uint i = 0; i < 32; i++) {\\n      result[i] = uint8(uint(data) >> (i * 8));\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {unpackUint8Array} for small number of items\\n  ///         It allows to exclude only first 3 values\\n  function unpackUint8Array3(bytes32 data) internal pure returns (uint8 a, uint8 b, uint8 c) {\\n    a = uint8(uint(data));\\n    b = uint8(uint(data) >> (1 * 8));\\n    c = uint8(uint(data) >> (2 * 8));\\n  }\\n\\n  function changeUnit8ArrayWithCheck(bytes32 data, uint index, uint8 value, uint8 expectedPrevValue) internal pure returns (bytes32 newData) {\\n    uint8[] memory arr = unpackUint8Array(data);\\n    if (arr[index] != expectedPrevValue) revert UnexpectedValue(uint(expectedPrevValue), uint(arr[index]));\\n    arr[index] = value;\\n    return packUint8Array(arr);\\n  }\\n\\n  function packInt32Array(int32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i; i < len; i++) {\\n      result |= bytes32(uint(uint32(data[i]))) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackInt32Array(bytes32 data) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = int32(int(uint(data) >> (i * 32)));\\n    }\\n    return result;\\n  }\\n\\n  function packUint32Array(uint32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackUint32Array(bytes32 data) internal pure returns (uint32[] memory) {\\n    uint32[] memory result = new uint32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = uint32(uint(data) >> (i * 32));\\n    }\\n    return result;\\n  }\\n  //endregion ------------------------------------ SIMPLE ARRAYS\\n\\n  //region ------------------------------------ COMPLEX ARRAYS\\n\\n  // We should represent arrays without concrete size.\\n  // For this reason we must not revert on out of bounds but return zero value instead.\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getInt32AsInt24(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n//    if (idx / 8 >= arr.length) {\\n//      return int32(0);\\n//    }\\n//    return int32(int24(int(uint(arr[idx / 8]) >> ((idx % 8) * 32))));\\n//  }\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getUnit8From32Step(bytes32[] memory arr, uint idx) internal pure returns (uint8) {\\n//    if (idx / 8 >= arr.length) {\\n//      return uint8(0);\\n//    }\\n//    return uint8(uint(arr[idx / 8]) >> ((idx % 8) * 32 + 24));\\n//  }\\n\\n  function getInt32Memory(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function getInt32(bytes32[] storage arr, uint idx) internal view returns (int32) {\\n    // additional gas usage, but we should not revert on out of bounds\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function setInt32(bytes32[] storage arr, uint idx, int32 value) internal {\\n    uint pos = idx / 8;\\n    uint shift = (idx % 8) * 32;\\n\\n    uint curLength = arr.length;\\n    if (pos >= curLength) {\\n      arr.push(0);\\n      for (uint i = curLength; i < pos; ++i) {\\n        arr.push(0);\\n      }\\n    }\\n\\n    arr[pos] = bytes32(uint(arr[pos]) & ~(uint(0xffffffff) << shift) | (uint(uint32(value)) & 0xffffffff) << shift);\\n  }\\n\\n  /// @notice Increment {idx}-th item on {value}\\n  function changeInt32(bytes32[] storage arr, uint idx, int32 value) internal returns (int32 newValue, int32 change) {\\n    int32 cur = int32(int(getInt32(arr, idx)));\\n    int newValueI = int(cur) + int(value);\\n    newValue = int32(newValueI);\\n    change = int32(newValueI - int(cur));\\n\\n    setInt32(arr, idx, newValue);\\n  }\\n\\n  function toInt32Array(bytes32[] memory arr, uint size) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](size);\\n    for (uint i = 0; i < arr.length; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= size) break;\\n        result[idx] = getInt32Memory(arr, idx);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array\\n  function toBytes32Array(int32[] memory arr) internal pure returns (bytes32[] memory) {\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n        result[i] |= bytes32(uint(uint32(arr[idx]))) << (j * 32);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array using last 8bytes for ids\\n  ///      we can not use zero values coz will not able to properly unpack it later\\n  function toBytes32ArrayWithIds(int32[] memory arr, uint8[] memory ids) internal pure returns (bytes32[] memory) {\\n    if (arr.length != ids.length) revert LengthsMismatch();\\n\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n\\n//        console.log(\\\"toBytes32ArrayWithIds id: %s, value: %s%s\\\", ids[idx], arr[idx] >= 0 ? '' : '-', arr[idx] >= 0 ? uint(int(arr[idx])) : uint(int(-arr[idx])));\\n\\n        if (arr[idx] > type(int24).max || arr[idx] < type(int24).min) revert IntOutOfRange(int(arr[idx]));\\n        if (arr[idx] == 0) revert ZeroValue();\\n        result[i] |= bytes32(uint(uint24(int24(arr[idx])))) << (j * 32);\\n        result[i] |= bytes32(uint(ids[idx])) << (j * 32 + 24);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev we do not know exact size of array, assume zero values is not acceptable for this array\\n  function toInt32ArrayWithIds(bytes32[] memory arr) internal pure returns (int32[] memory values, uint8[] memory ids) {\\n    uint len = arr.length;\\n    uint size = len * 8;\\n    int32[] memory valuesTmp = new int32[](size);\\n    uint8[] memory idsTmp = new uint8[](size);\\n    uint counter;\\n    for (uint i = 0; i < len; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        // if (idx >= size) break;  // it looks like a useless check\\n        valuesTmp[idx] = int32(int24(int(uint(arr[i]) >> (j * 32)))); // getInt32AsInt24(arr, idx);\\n        idsTmp[idx] = uint8(uint(arr[i]) >> (j * 32 + 24)); // getUnit8From32Step(arr, idx);\\n        if (valuesTmp[idx] == 0) {\\n          break;\\n        }\\n        counter++;\\n      }\\n    }\\n\\n    values = new int32[](counter);\\n    ids = new uint8[](counter);\\n    for (uint i; i < counter; ++i) {\\n      values[i] = valuesTmp[i];\\n      ids[i] = idsTmp[i];\\n    }\\n  }\\n  //endregion ------------------------------------ COMPLEX ARRAYS\\n\\n}\\n\",\"keccak256\":\"0x5cd23c28a36e25e667e6a01b8cc483c2dd47be9abfd0f2d54e6c59d1a1d01884\",\"license\":\"BUSL-1.1\"},\"contracts/lib/SlotsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\\n/// @author bogdoslav\\nlibrary SlotsLib {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant SLOT_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  // ************* GETTERS *******************\\n\\n  /// @dev Gets a slot as bytes32\\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as an address\\n  function getAddress(bytes32 slot) internal view returns (address result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as uint256\\n  function getUint(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  // ************* ARRAY GETTERS *******************\\n\\n  /// @dev Gets an array length\\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  // ************* SETTERS *******************\\n\\n  /// @dev Sets a slot with bytes32\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, bytes32 value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with address\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, address value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with uint\\n  function set(bytes32 slot, uint value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x52ede981a6bb509c0dce07a0373e3c073c24fd16ca4ca7fbaa24f6c8b747b45b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StatControllerLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../lib/StatLib.sol\\\";\\n\\n/// @notice Implementation of StatController\\nlibrary StatControllerLib {\\n  using StatLib for uint;\\n  using StatLib for uint[];\\n  using StatLib for uint32;\\n  using StatLib for int32;\\n  using StatLib for int32;\\n  using CalcLib for uint;\\n  using CalcLib for int;\\n  using CalcLib for int32;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using PackingLib for bytes32[];\\n  using PackingLib for bytes32;\\n  using PackingLib for int32;\\n  using PackingLib for uint32;\\n\\n  //region ------------------------ Constants\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"stat.controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0xca9e8235a410bd2656fc43f888ab589425034944963c2881072ee821e700e600;\\n\\n  int32 public constant LEVEL_UP_SUM = 5;\\n  bytes32 public constant KARMA_HASH = bytes32(\\\"KARMA\\\");\\n  bytes32 public constant HERO_CLASS_HASH = bytes32(\\\"HERO_CLASS\\\");\\n\\n  /// @notice Custom data of the hero. Value is incremented on every life-chance lost\\n  bytes32 public constant DEATH_COUNT_HASH = bytes32(\\\"DEATH_COUNT\\\");\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ RESTRICTIONS\\n\\n  function onlyRegisteredContract(IController controller_) internal view {\\n    address sender = msg.sender;\\n    if (\\n      controller_.heroController() != sender\\n      && controller_.itemController() != sender\\n      && controller_.dungeonFactory() != sender\\n      && controller_.storyController() != sender\\n      && controller_.gameObjectController() != sender\\n    ) revert IAppErrors.ErrorForbidden(sender);\\n  }\\n\\n  function onlyItemController(IController controller_) internal view {\\n    if (controller_.itemController() != msg.sender) revert IAppErrors.ErrorNotItemController(msg.sender);\\n  }\\n\\n  function onlyHeroController(IController controller_) internal view {\\n    if (controller_.heroController() != msg.sender) revert IAppErrors.ErrorNotHeroController(msg.sender);\\n  }\\n  //endregion ------------------------ RESTRICTIONS\\n\\n  //region ------------------------ VIEWS\\n  function _S() internal pure returns (IStatController.MainState storage s) {\\n    assembly {\\n      s.slot := MAIN_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n\\n  function heroAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (int32[] memory) {\\n    return PackingLib.toInt32Array(s.heroTotalAttributes[PackingLib.packNftId(token, tokenId)], uint(IStatController.ATTRIBUTES.END_SLOT));\\n  }\\n\\n  function heroBonusAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (int32[] memory) {\\n    return PackingLib.toInt32Array(s.heroBonusAttributes[PackingLib.packNftId(token, tokenId)], uint(IStatController.ATTRIBUTES.END_SLOT));\\n  }\\n\\n  function heroTemporallyAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (int32[] memory) {\\n    return PackingLib.toInt32Array(s.heroTemporallyAttributes[PackingLib.packNftId(token, tokenId)], uint(IStatController.ATTRIBUTES.END_SLOT));\\n  }\\n\\n\\n  function heroAttributesLength(address /*token*/, uint /*tokenId*/) internal pure returns (uint) {\\n    return uint(IStatController.ATTRIBUTES.END_SLOT);\\n  }\\n\\n  function heroAttribute(IStatController.MainState storage s, address token, uint tokenId, uint index) internal view returns (int32) {\\n    return PackingLib.getInt32(s.heroTotalAttributes[PackingLib.packNftId(token, tokenId)], index);\\n  }\\n\\n  function heroBaseAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (\\n    IStatController.CoreAttributes memory core\\n  ) {\\n    int32[] memory data = PackingLib.unpackInt32Array(s._heroCore[PackingLib.packNftId(token, tokenId)]);\\n    core = IStatController.CoreAttributes({\\n      strength: int32(data[0]),\\n      dexterity: int32(data[1]),\\n      vitality: int32(data[2]),\\n      energy: int32(data[3])\\n    });\\n  }\\n\\n  function heroCustomData(IStatController.MainState storage s, address token, uint tokenId, bytes32 index) internal view returns (uint) {\\n    return s.heroCustomData[PackingLib.packNftId(token, tokenId)][index];\\n  }\\n\\n  function globalCustomData(IStatController.MainState storage s, bytes32 index) internal view returns (uint) {\\n    return s.globalCustomData[index];\\n  }\\n\\n  function heroStats(IStatController.MainState storage s, address token, uint tokenId) internal view returns (\\n    IStatController.ChangeableStats memory result\\n  ) {\\n    uint32[] memory data = PackingLib.unpackUint32Array(s.heroStats[PackingLib.packNftId(token, tokenId)]);\\n    result = IStatController.ChangeableStats({\\n      level: uint32(data[0]),\\n      experience: uint32(data[1]),\\n      life: uint32(data[2]),\\n      mana: uint32(data[3]),\\n      lifeChances: uint32(data[4])\\n    });\\n  }\\n\\n  function heroItemSlot(IStatController.MainState storage s, address heroToken, uint64 heroTokenId, uint8 itemSlot) internal view returns (\\n    bytes32 nftPacked\\n  ) {\\n    return s.heroSlots[PackingLib.packMapObject(heroToken, heroTokenId, itemSlot)];\\n  }\\n\\n  /// @return Return list of indices of the busy item slots for the given hero\\n  function heroItemSlots(IStatController.MainState storage s, address heroToken, uint heroTokenId) internal view returns (\\n    uint8[] memory\\n  ) {\\n    uint8[] memory slots = PackingLib.unpackUint8Array(s.heroBusySlots[PackingLib.packNftId(heroToken, heroTokenId)]);\\n\\n    uint8[] memory busySlotsNumbers = new uint8[](slots.length);\\n    uint counter;\\n\\n    for (uint8 i; i < uint8(slots.length); ++i) {\\n      if (slots[i] != 0) {\\n        busySlotsNumbers[counter] = i;\\n        counter++;\\n      }\\n    }\\n\\n    uint8[] memory result = new uint8[](counter);\\n\\n    for (uint i; i < counter; ++i) {\\n      result[i] = busySlotsNumbers[i];\\n    }\\n\\n    return result;\\n  }\\n\\n  function isHeroAlive(IStatController.MainState storage s, address heroToken, uint heroTokenId) internal view returns (bool) {\\n    return heroStats(s, heroToken, heroTokenId).lifeChances != 0;\\n  }\\n\\n  function isConsumableUsed(IStatController.MainState storage s, address heroToken, uint heroTokenId, address item) internal view returns (bool) {\\n    return s.usedConsumables[PackingLib.packNftId(heroToken, heroTokenId)].contains(item);\\n  }\\n\\n  /// @notice Calculate totalAttributes + all attributes of the items specified in {info}\\n  function buffHero(\\n    IStatController.MainState storage s,\\n    IController c,\\n    IStatController.BuffInfo memory info\\n  ) internal view returns (\\n    int32[] memory dest,\\n    int32 manaSum\\n  ) {\\n    uint length = info.buffTokens.length;\\n    if (length == 0) {\\n      return (heroAttributes(s, info.heroToken, info.heroTokenId), 0);\\n    }\\n\\n    IItemController ic = IItemController(c.itemController());\\n\\n    int32[] memory buffAttributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    address[] memory usedTokens = new address[](length);\\n\\n    for (uint i; i < length; ++i) {\\n\\n      // we should ignore the same skills\\n      bool used;\\n      for(uint j; j < i; ++j) {\\n        if (usedTokens[j] == info.buffTokens[i]) {\\n          used = true;\\n          break;\\n        }\\n      }\\n      if(used) {\\n        continue;\\n      }\\n\\n\\n      manaSum += int32(ic.itemMeta(info.buffTokens[i]).manaCost);\\n      (int32[] memory values, uint8[] memory ids) = ic.casterAttributes(info.buffTokens[i], info.buffTokenIds[i]);\\n      StatLib.attributesAdd(buffAttributes, StatLib.valuesToFullAttributesArray(values, ids));\\n      usedTokens[i] = info.buffTokens[i];\\n    }\\n\\n    int32[] memory totalAttributes = StatLib.attributesAdd(heroAttributes(s, info.heroToken, info.heroTokenId), buffAttributes);\\n\\n    StatLib.attributesAdd(buffAttributes, heroBonusAttributes(s, info.heroToken, info.heroTokenId));\\n    StatLib.attributesAdd(buffAttributes, heroTemporallyAttributes(s, info.heroToken, info.heroTokenId));\\n\\n    return (\\n      StatLib.updateCoreDependAttributesInMemory(\\n        totalAttributes,\\n        buffAttributes,\\n        IHeroController(c.heroController()).heroClass(info.heroToken),\\n        info.heroLevel\\n      ),\\n      manaSum\\n    );\\n  }\\n\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ PURE\\n\\n  function isItemTypeEligibleToItemSlot(uint itemType, uint itemSlot) internal pure returns (bool) {\\n    // Consumable items not eligible\\n    if (itemType == 0 || itemSlot == 0) {\\n      return false;\\n    }\\n    // items with type before 5 mapped 1 to 1\\n    if (itemType <= uint(IItemController.ItemType.AMULET)) {\\n      return itemSlot == itemType;\\n    }\\n    if (itemType == uint(IItemController.ItemType.RING)) {\\n      return itemSlot == uint(IStatController.ItemSlots.RIGHT_RING)\\n        || itemSlot == uint(IStatController.ItemSlots.LEFT_RING);\\n    }\\n    if (itemType == uint(IItemController.ItemType.BOOTS)) {\\n      return itemSlot == uint(IStatController.ItemSlots.BOOTS);\\n    }\\n    if (itemType == uint(IItemController.ItemType.ONE_HAND)) {\\n      return itemSlot == uint(IStatController.ItemSlots.RIGHT_HAND);\\n    }\\n    if (itemType == uint(IItemController.ItemType.OFF_HAND)) {\\n      return itemSlot == uint(IStatController.ItemSlots.LEFT_HAND);\\n    }\\n    if (itemType == uint(IItemController.ItemType.TWO_HAND)) {\\n      return itemSlot == uint(IStatController.ItemSlots.TWO_HAND);\\n    }\\n    if (itemType == uint(IItemController.ItemType.SKILL)) {\\n      return itemSlot == uint(IStatController.ItemSlots.SKILL_1)\\n      || itemSlot == uint(IStatController.ItemSlots.SKILL_2)\\n        || itemSlot == uint(IStatController.ItemSlots.SKILL_3);\\n    }\\n    // unknown types\\n    return false;\\n  }\\n\\n  /// @notice How much experience is required to go from the {level} to the next level\\n  function levelUpExperienceRequired(uint32 level) internal pure returns (uint) {\\n    if (level == 0 || level >= StatLib.MAX_LEVEL) return 0;\\n    return level == uint32(1)\\n      ? StatLib.levelExperience(level)\\n      : StatLib.levelExperience(level) - StatLib.levelExperience(level - uint32(1));\\n  }\\n\\n  //endregion ------------------------ PURE\\n\\n  //region ------------------------ ACTIONS\\n\\n  /// @notice Initialize new hero, set up custom data, core data, changeable stats by default value\\n  /// @param heroClass [1..6], see StatLib.initHeroXXX\\n  function initNewHero(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass\\n  ) internal {\\n    StatControllerLib.onlyHeroController(c);\\n\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n    _initNewHeroCore(s, heroPackedId, heroClass);\\n\\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\\n    uint32[] memory baseStats = StatLib.initAttributes(totalAttributes, heroClass, 1, heroClass.initialHero().core);\\n\\n    _initChangeableStats(s, heroPackedId, baseStats);\\n    emit IApplicationEvents.NewHeroInited(heroToken, heroTokenId, IStatController.ChangeableStats({\\n      level: 1,\\n      experience: 0,\\n      life: baseStats[0],\\n      mana: baseStats[1],\\n      lifeChances: baseStats[2]\\n    }));\\n\\n    // --- init predefined custom hero data\\n\\n    mapping(bytes32 => uint) storage customData = s.heroCustomData[heroPackedId];\\n\\n    // set initial karma\\n    customData[KARMA_HASH] = 1000;\\n    emit IApplicationEvents.HeroCustomDataChanged(heroToken, heroTokenId, KARMA_HASH, 1000);\\n\\n    // set hero class as parameter for stories\\n    customData[HERO_CLASS_HASH] = heroClass;\\n    emit IApplicationEvents.HeroCustomDataChanged(heroToken, heroTokenId, HERO_CLASS_HASH, heroClass);\\n\\n    // set death count value\\n    // customData[DEATH_COUNT_HASH] is initialized by 0 by default\\n    emit IApplicationEvents.HeroCustomDataChanged(heroToken, heroTokenId, DEATH_COUNT_HASH, 0);\\n  }\\n\\n  function _initNewHeroCore(IStatController.MainState storage s, bytes32 heroPackedId, uint heroClass) internal {\\n    IStatController.CoreAttributes memory initialCore = heroClass.initialHero().core;\\n    int32[] memory arr = new int32[](4);\\n\\n    arr[0] = int32(initialCore.strength);\\n    arr[1] = int32(initialCore.dexterity);\\n    arr[2] = int32(initialCore.vitality);\\n    arr[3] = int32(initialCore.energy);\\n\\n    s._heroCore[heroPackedId] = PackingLib.packInt32Array(arr);\\n  }\\n\\n  function _initChangeableStats(IStatController.MainState storage s, bytes32 heroPackedId, uint32[] memory baseStats) internal {\\n    _changeChangeableStats(s, heroPackedId, 1, 0, baseStats[0], baseStats[1], baseStats[2]);\\n  }\\n\\n  function _changeChangeableStats(\\n    IStatController.MainState storage s,\\n    bytes32 heroPackedId,\\n    uint32 level,\\n    uint32 experience,\\n    uint32 life,\\n    uint32 mana,\\n    uint32 lifeChances\\n  ) internal {\\n    if(lifeChances != 0 && life == 0) {\\n      life = 1;\\n    }\\n    uint32[] memory data = new uint32[](5);\\n    data[0] = level;\\n    data[1] = experience;\\n    data[2] = life;\\n    data[3] = mana;\\n    data[4] = lifeChances;\\n\\n    s.heroStats[heroPackedId] = PackingLib.packUint32Array(data);\\n  }\\n\\n  /// @notice Add/remove the item to/from the hero\\n  function changeHeroItemSlot(\\n    IStatController.MainState storage s,\\n    IController controller,\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) internal {\\n    StatControllerLib.onlyItemController(controller);\\n    if (!StatControllerLib.isItemTypeEligibleToItemSlot(itemType, itemSlot)) revert IAppErrors.ErrorItemNotEligibleForTheSlot(itemType, itemSlot);\\n\\n    // if we are going to take an item by two hands, we need both hands free.\\n    // if we are going to use only one hand, we shouldn't keep anything by two hands\\n    if (itemSlot == uint(IStatController.ItemSlots.TWO_HAND)) {\\n      if (heroItemSlot(s, heroToken, heroTokenId, uint8(IStatController.ItemSlots.RIGHT_HAND)) != bytes32(0)\\n        || heroItemSlot(s, heroToken, heroTokenId, uint8(IStatController.ItemSlots.LEFT_HAND)) != bytes32(0)) {\\n        revert IAppErrors.ErrorItemSlotBusyHand(itemSlot);\\n      }\\n    }\\n    if (itemSlot == uint(IStatController.ItemSlots.RIGHT_HAND) || itemSlot == uint(IStatController.ItemSlots.LEFT_HAND)) {\\n      if (heroItemSlot(s, heroToken, heroTokenId, uint8(IStatController.ItemSlots.TWO_HAND)) != bytes32(0)) {\\n        revert IAppErrors.ErrorItemSlotBusyHand(itemSlot);\\n      }\\n    }\\n\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n    (address equippedItem, uint equippedItemId) = PackingLib.unpackNftId(heroItemSlot(s, heroToken, heroTokenId, itemSlot));\\n    if (equip) {\\n      if (equippedItem != address(0)) revert IAppErrors.ErrorItemSlotBusy();\\n\\n      s.heroSlots[PackingLib.packMapObject(heroToken, uint64(heroTokenId), itemSlot)] = PackingLib.packNftId(itemToken, itemTokenId);\\n      s.heroBusySlots[heroPackedId] = PackingLib.changeUnit8ArrayWithCheck(s.heroBusySlots[heroPackedId], itemSlot, 1, 0);\\n    } else {\\n      if (equippedItem != itemToken || equippedItemId != itemTokenId) revert IAppErrors.ErrorItemNotInSlot();\\n\\n      delete s.heroSlots[PackingLib.packMapObject(heroToken, uint64(heroTokenId), itemSlot)];\\n      s.heroBusySlots[heroPackedId] = PackingLib.changeUnit8ArrayWithCheck(s.heroBusySlots[heroPackedId], itemSlot, 0, 1);\\n    }\\n\\n    emit IApplicationEvents.HeroItemSlotChanged(heroToken, heroTokenId, itemType, itemSlot, itemToken, itemTokenId, equip, msg.sender);\\n  }\\n\\n  /// @notice Increase or decrease stats (life, mana, lifeChances). Experience can be increased only.\\n  function changeCurrentStats(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats memory change,\\n    bool increase\\n  ) internal {\\n    StatControllerLib.onlyRegisteredContract(c);\\n\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n    IStatController.ChangeableStats memory currentStats = heroStats(s, heroToken, heroTokenId);\\n\\n    uint32 life = currentStats.life;\\n    uint32 mana = currentStats.mana;\\n    uint32 lifeChances = currentStats.lifeChances;\\n\\n    if (increase) {\\n      bytes32[] storage attrs = s.heroTotalAttributes[heroPackedId];\\n      int32 maxLife = attrs.getInt32(uint(IStatController.ATTRIBUTES.LIFE));\\n      int32 maxMana = attrs.getInt32(uint(IStatController.ATTRIBUTES.MANA));\\n      int32 maxLC = attrs.getInt32(uint(IStatController.ATTRIBUTES.LIFE_CHANCES));\\n\\n      currentStats.experience += change.experience;\\n      life = uint32(Math.min(maxLife.toUint(), uint(life + change.life)));\\n      mana = uint32(Math.min(maxMana.toUint(), uint(mana + change.mana)));\\n      lifeChances = uint32(Math.min(maxLC.toUint(), uint(lifeChances + change.lifeChances)));\\n    } else {\\n      if (change.experience != 0) revert IAppErrors.ErrorExperienceMustNotDecrease();\\n      life = life > change.life ? life - change.life : 0;\\n      lifeChances = lifeChances > change.lifeChances ? lifeChances - change.lifeChances : 0;\\n      mana = mana > change.mana ? mana - change.mana : 0;\\n    }\\n\\n    _changeChangeableStats(s, heroPackedId, currentStats.level, currentStats.experience, life, mana, lifeChances);\\n    emit IApplicationEvents.CurrentStatsChanged(heroToken, heroTokenId, change, increase, msg.sender);\\n  }\\n\\n  /// @notice Mark consumable {item} as used\\n  function registerConsumableUsage(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId,\\n    address item\\n  ) internal {\\n    StatControllerLib.onlyRegisteredContract(c);\\n\\n    if (!s.usedConsumables[PackingLib.packNftId(heroToken, heroTokenId)].add(item)) revert IAppErrors.ErrorConsumableItemIsUsed(item);\\n    emit IApplicationEvents.ConsumableUsed(heroToken, heroTokenId, item);\\n  }\\n\\n  /// @notice Clear all consumable items of the given hero\\n  function clearUsedConsumables(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId\\n  ) internal {\\n    StatControllerLib.onlyRegisteredContract(c);\\n\\n    EnumerableSet.AddressSet storage items = s.usedConsumables[PackingLib.packNftId(heroToken, heroTokenId)];\\n\\n    uint length = items.length();\\n\\n    for (uint i; i < length; ++i) {\\n      // we are removing the first element, so it's safe to use in cycle\\n      address item = items.at(0);\\n      if (!items.remove(item)) revert IAppErrors.ErrorCannotRemoveItemFromMap();\\n      emit IApplicationEvents.RemoveConsumableUsage(heroToken, heroTokenId, item);\\n    }\\n  }\\n\\n  /// @notice Increase or decrease values of the given attributes, any attributes are allowed.\\n  /// @dev If a core attribute is changed than depended attributes are recalculated\\n  function changeBonusAttributes(\\n    IStatController.MainState storage s,\\n    IController c,\\n    IStatController.ChangeAttributesInfo memory info\\n  ) internal {\\n    StatControllerLib.onlyRegisteredContract(c);\\n    bytes32 heroPackedId = PackingLib.packNftId(info.heroToken, info.heroTokenId);\\n\\n    IStatController.ChangeableStats memory stats = heroStats(s, info.heroToken, info.heroTokenId);\\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\\n    (bytes32[] storage bonusMain, bytes32[] storage bonusExtra) = info.temporally\\n      ? (s.heroTemporallyAttributes[heroPackedId], s.heroBonusAttributes[heroPackedId])\\n      : (s.heroBonusAttributes[heroPackedId], s.heroTemporallyAttributes[heroPackedId]);\\n\\n    int32[] memory cachedTotalAttrChanged = new int32[](info.changeAttributes.length);\\n    for (uint i; i < info.changeAttributes.length; ++i) {\\n      int32 change = info.changeAttributes[i];\\n      if (change != 0) {\\n        int32 newTotalValue;\\n\\n        if (info.add) {\\n          bonusMain.changeInt32(i, change);\\n          newTotalValue = totalAttributes.getInt32(i) + change;\\n        } else {\\n          bonusMain.changeInt32(i, - change);\\n          newTotalValue = totalAttributes.getInt32(i) - change;\\n        }\\n\\n        // todo in some cases value stored here to totalAttributes will be overwritten below by updateCoreDependAttributes\\n        // it happens if core attribute is changed AND it's depend attribute is change too\\n        // values of the depend attribute will be overwritten by updateCoreDependAttributes\\n        // fix it together with PACKED WRITING\\n        totalAttributes.setInt32(i, newTotalValue);\\n        cachedTotalAttrChanged[i] = newTotalValue;\\n      }\\n    }\\n\\n    _updateCoreDependAttributes(c, totalAttributes, bonusMain, bonusExtra, stats, info.heroToken, cachedTotalAttrChanged, info.changeAttributes);\\n    _compareStatsWithAttributes(s, heroPackedId, totalAttributes, stats);\\n\\n    emit IApplicationEvents.BonusAttributesChanged(info.heroToken, info.heroTokenId, info.add, info.temporally, msg.sender);\\n  }\\n\\n  /// @dev Make sure we don't have life/mana more than total attributes after decreasing\\n  function _compareStatsWithAttributes(\\n    IStatController.MainState storage s,\\n    bytes32 heroPackedId,\\n    bytes32[] storage totalAttributes,\\n    IStatController.ChangeableStats memory curStats\\n  ) internal {\\n    uint life = totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.LIFE)).toUint();\\n    uint mana = totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.MANA)).toUint();\\n    bool changed;\\n    if (life < curStats.life) {\\n      curStats.life = uint32(Math.min(life, curStats.life));\\n      changed = true;\\n    }\\n    if (mana < curStats.mana) {\\n      curStats.mana = uint32(Math.min(mana, curStats.mana));\\n      changed = true;\\n    }\\n    if (changed) {\\n      _changeChangeableStats(s,\\n        heroPackedId,\\n        curStats.level,\\n        curStats.experience,\\n        curStats.life,\\n        curStats.mana,\\n        curStats.lifeChances\\n      );\\n    }\\n  }\\n\\n  function clearTemporallyAttributes(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId\\n  ) internal {\\n    StatControllerLib.onlyRegisteredContract(c);\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n\\n    bytes32[] memory tmpBonuses = s.heroTemporallyAttributes[heroPackedId];\\n\\n    IStatController.ChangeableStats memory stats = heroStats(s, heroToken, heroTokenId);\\n    bytes32[] storage bonus = s.heroBonusAttributes[heroPackedId];\\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\\n\\n    int32[] memory baseValues = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    int32[] memory tmpBonusesUnpacked = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < uint(IStatController.ATTRIBUTES.END_SLOT); ++i) {\\n      int32 value = tmpBonuses.getInt32Memory(i);\\n      if (value != int32(0)) {\\n        (baseValues[i],) = totalAttributes.changeInt32(i, - int32(uint32(value)));\\n        tmpBonusesUnpacked[i] = value;\\n      }\\n    }\\n\\n    delete s.heroTemporallyAttributes[heroPackedId];\\n\\n    bytes32[] storage tmpBonusesStorage = s.heroTemporallyAttributes[heroPackedId];\\n\\n    _updateCoreDependAttributes(c, totalAttributes, bonus, tmpBonusesStorage, stats, heroToken, baseValues, tmpBonusesUnpacked);\\n    _compareStatsWithAttributes(s, heroPackedId, totalAttributes, stats);\\n\\n    emit IApplicationEvents.TemporallyAttributesCleared(heroToken, heroTokenId, msg.sender);\\n  }\\n\\n  /// @dev Update depend-values for all changed attributes\\n  function _updateCoreDependAttributes(\\n    IController c,\\n    bytes32[] storage totalAttributes,\\n    bytes32[] storage bonusMain,\\n    bytes32[] storage bonusExtra,\\n    IStatController.ChangeableStats memory stats,\\n    address heroToken,\\n    int32[] memory baseValues,\\n    int32[] memory changed\\n  ) internal {\\n    // handle core depend attributes in the second loop, totalAttributes should be updated together\\n    uint len = changed.length;\\n    for (uint i; i < len; ++i) {\\n      // depend-values should be recalculated if corresponded core value is changed (even if it's equal to 0 now)\\n      if (changed[i] != 0) {\\n        StatLib.updateCoreDependAttributes(c, totalAttributes, bonusMain, bonusExtra, stats, i, heroToken, baseValues[i]);\\n      }\\n    }\\n  }\\n\\n  function levelUp(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes memory change\\n  ) internal returns (uint newLvl) {\\n    StatControllerLib.onlyHeroController(c);\\n\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n    if (change.strength + change.dexterity + change.vitality + change.energy != LEVEL_UP_SUM) revert IAppErrors.ErrorWrongLevelUpSum();\\n\\n    IStatController.ChangeableStats memory currentStats = heroStats(s, heroToken, heroTokenId);\\n\\n    if (currentStats.level >= StatLib.MAX_LEVEL) revert IAppErrors.ErrorMaxLevel();\\n    if (currentStats.level.levelExperience() > currentStats.experience) revert IAppErrors.ErrorNotEnoughExperience();\\n    currentStats.level++;\\n\\n    {\\n      int32[] memory data = PackingLib.unpackInt32Array(s._heroCore[heroPackedId]);\\n\\n      data[0] += change.strength;\\n      data[1] += change.dexterity;\\n      data[2] += change.vitality;\\n      data[3] += change.energy;\\n\\n      s._heroCore[heroPackedId] = PackingLib.packInt32Array(data);\\n    }\\n\\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\\n    {\\n      bytes32[] storage bonus = s.heroBonusAttributes[heroPackedId];\\n      bytes32[] storage bonusTmp = s.heroTemporallyAttributes[heroPackedId];\\n\\n      // update\\n      _addCoreToTotal(\\n        c,\\n        totalAttributes,\\n        bonus,\\n        bonusTmp,\\n        currentStats,\\n        heroToken,\\n        change.strength,\\n        uint(IStatController.ATTRIBUTES.STRENGTH)\\n      );\\n      _addCoreToTotal(\\n        c,\\n        totalAttributes,\\n        bonus,\\n        bonusTmp,\\n        currentStats,\\n        heroToken,\\n        change.dexterity,\\n        uint(IStatController.ATTRIBUTES.DEXTERITY)\\n      );\\n      _addCoreToTotal(\\n        c,\\n        totalAttributes,\\n        bonus,\\n        bonusTmp,\\n        currentStats,\\n        heroToken,\\n        change.vitality,\\n        uint(IStatController.ATTRIBUTES.VITALITY)\\n      );\\n      _addCoreToTotal(\\n        c,\\n        totalAttributes,\\n        bonus,\\n        bonusTmp,\\n        currentStats,\\n        heroToken,\\n        change.energy,\\n        uint(IStatController.ATTRIBUTES.ENERGY)\\n      );\\n    }\\n\\n    // setup new level and restore life/mana\\n    currentStats.life = uint32(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.LIFE)).toUint());\\n    currentStats.mana = uint32(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.MANA)).toUint());\\n\\n    _changeChangeableStats(\\n      s,\\n      heroPackedId,\\n      currentStats.level,\\n      currentStats.experience,\\n      currentStats.life,\\n      currentStats.mana,\\n      currentStats.lifeChances\\n    );\\n\\n    emit IApplicationEvents.LevelUp(heroToken, heroTokenId, heroClass, change);\\n\\n    return currentStats.level;\\n  }\\n\\n  /// @notice scb-1009: Update current values of Life and mana during reinforcement as following:\\n  /// Reinforcement increases max value of life/mana on DELTA, current value of life/mana is increased on DELTA too\\n  /// @param prevAttributes Hero attributes before reinforcement\\n  function restoreLifeAndMana(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId,\\n    int32[] memory prevAttributes\\n  ) internal {\\n    StatControllerLib.onlyHeroController(c);\\n\\n    IStatController.ChangeableStats memory currentStats = heroStats(s, heroToken, heroTokenId);\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n\\n    // assume here that totalAttributes were already updated during reinforcement\\n    // and so max values of life and mana were increased on delta1 and delta2\\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\\n\\n    // now increase current values of life and mana on delta1 and delta2 too\\n    currentStats.life += _getPositiveDelta(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.LIFE)), prevAttributes[uint(IStatController.ATTRIBUTES.LIFE)]);\\n    currentStats.mana += _getPositiveDelta(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.MANA)), prevAttributes[uint(IStatController.ATTRIBUTES.MANA)]);\\n\\n    _changeChangeableStats(\\n      s,\\n      heroPackedId,\\n      currentStats.level,\\n      currentStats.experience,\\n      currentStats.life,\\n      currentStats.mana,\\n      currentStats.lifeChances\\n    );\\n  }\\n\\n  function _getPositiveDelta(int32 a, int32 b) internal pure returns (uint32) {\\n    return a < b\\n      ? 0\\n      : uint32(uint(int(a - b)));\\n  }\\n\\n  function _addCoreToTotal(\\n    IController c,\\n    bytes32[] storage totalAttributes,\\n    bytes32[] storage bonus,\\n    bytes32[] storage bonusTmp,\\n    IStatController.ChangeableStats memory stats,\\n    address heroToken,\\n    int32 changeValue,\\n    uint attrIndex\\n  ) internal {\\n    if (changeValue != 0) {\\n      (int32 newValue,) = totalAttributes.changeInt32(attrIndex, int32(uint32(changeValue)));\\n      StatLib.updateCoreDependAttributes(c, totalAttributes, bonus, bonusTmp, stats, attrIndex, heroToken, newValue);\\n    }\\n  }\\n\\n  function setHeroCustomData(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address token,\\n    uint tokenId,\\n    bytes32 index,\\n    uint value\\n  ) internal {\\n    StatControllerLib.onlyRegisteredContract(c);\\n\\n    if (index == KARMA_HASH && value == 0) {\\n      revert IAppErrors.ErrorZeroKarmaNotAllowed();\\n    }\\n\\n    s.heroCustomData[PackingLib.packNftId(token, tokenId)][index] = value;\\n\\n    emit IApplicationEvents.HeroCustomDataChanged(token, tokenId, index, value);\\n  }\\n\\n  function setGlobalCustomData(\\n    IStatController.MainState storage s,\\n    IController c,\\n    bytes32 index,\\n    uint value\\n  ) internal {\\n    StatControllerLib.onlyRegisteredContract(c);\\n\\n    s.globalCustomData[index] = value;\\n\\n    emit IApplicationEvents.GlobalCustomDataChanged(index, value);\\n  }\\n  //endregion ------------------------ ACTIONS\\n}\\n\",\"keccak256\":\"0x74f096699c2f6c07bd483e13ff5d966e008dec0678ec8c77bb320d7cae4e428a\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StatLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\n\\nlibrary StatLib {\\n  using PackingLib for bytes32[];\\n  using PackingLib for bytes32;\\n  using PackingLib for uint32[];\\n  using PackingLib for int32[];\\n  using CalcLib for int32;\\n\\n  //region --------------------------- Constants\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant STAT_LIB_VERSION = \\\"1.0.0\\\";\\n  uint32 public constant MAX_LEVEL = 99;\\n\\n  uint public constant BASE_EXPERIENCE = 100_000;\\n  uint public constant BIOME_LEVEL_STEP = 5;\\n  uint internal constant _MAX_AMPLIFIER = 1e18;\\n  uint private constant _PRECISION = 1e18;\\n\\n  /// @dev Assume MAX_BIOME * BIOME_LEVEL_STEP < MAX_LEVEL + 1, see dungeonTreasuryReward\\n  uint public constant MAX_POSSIBLE_BIOME = 19;\\n  //endregion --------------------------- Constants\\n\\n  //region --------------------------- Data types\\n\\n  struct BaseMultiplier {\\n    uint minDamage;\\n    uint maxDamage;\\n    uint attackRating;\\n    uint defense;\\n    uint blockRating;\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct LevelUp {\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct InitialHero {\\n    IStatController.CoreAttributes core;\\n    BaseMultiplier multiplier;\\n    LevelUp levelUp;\\n    int32 baseLifeChances;\\n  }\\n\\n  enum HeroClasses {\\n    UNKNOWN,\\n    THRALL,\\n    SAVAGE,\\n    MAGE,\\n    ASSASSIN,\\n    GHOST,\\n    HAMMERGINA,\\n    END_SLOT\\n  }\\n  //endregion --------------------------- Data types\\n\\n  //region --------------------------- BASE\\n\\n  // --- HERO 1 (Slave) ---\\n\\n  function initialHero1() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 15,\\n      vitality: 30,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 2e18,\\n      blockRating: 0.1e18,\\n      life: 1.5e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 2e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 2 (Spata) ---\\n\\n  function initialHero2() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 30,\\n      dexterity: 5,\\n      vitality: 25,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: 0.25e18,\\n      attackRating: 2e18,\\n      defense: 1e18,\\n      blockRating: 0.08e18,\\n      life: 1.3e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.8e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 3 (Decidia) ---\\n\\n  function initialHero3() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 10,\\n      dexterity: 15,\\n      vitality: 20,\\n      energy: 25\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 1e18,\\n      blockRating: 0.1e18,\\n      life: 1e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.3e18,\\n      mana: 2e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 4 (Innatus) ---\\n\\n  function initialHero4() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 25,\\n      vitality: 15,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 4e18,\\n      defense: 3e18,\\n      blockRating: 0.2e18,\\n      life: 1.2e18,\\n      mana: 1e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 5 (F2P) ---\\n\\n  function initialHero5() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 20,\\n      dexterity: 20,\\n      vitality: 20,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: 0.25e18,\\n      attackRating: 3e18,\\n      defense: 2.5e18,\\n      blockRating: 0.15e18,\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // --- HERO 6 (F2P) HAMMERGINA ---\\n\\n  function initialHero6() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 50,\\n      dexterity: 30,\\n      vitality: 50,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.2e18,\\n      maxDamage: 0.3e18,\\n      attackRating: 5e18,\\n      defense: 3e18,\\n      blockRating: 0.15e18,\\n      life: 2e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // ------\\n\\n  function initialHero(uint heroClass) internal pure returns (InitialHero memory) {\\n    if (heroClass == 1) {\\n      return initialHero1();\\n    } else if (heroClass == 2) {\\n      return initialHero2();\\n    } else if (heroClass == 3) {\\n      return initialHero3();\\n    } else if (heroClass == 4) {\\n      return initialHero4();\\n    } else if (heroClass == 5) {\\n      return initialHero5();\\n    } else if (heroClass == 6) {\\n      return initialHero6();\\n    } else {\\n      revert IAppErrors.UnknownHeroClass(heroClass);\\n    }\\n  }\\n  //endregion --------------------------- BASE\\n\\n  //region --------------------------- CALCULATIONS\\n\\n  function minDamage(int32 strength, uint heroClass) internal pure returns (int32) {\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.minDamage / _PRECISION));\\n  }\\n\\n  function maxDamage(int32 strength, uint heroClass) internal pure returns (int32){\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.maxDamage / _PRECISION));\\n  }\\n\\n  function attackRating(int32 dexterity, uint heroClass) internal pure returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.attackRating / _PRECISION));\\n  }\\n\\n  function defense(int32 dexterity, uint heroClass) internal pure returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.defense / _PRECISION));\\n  }\\n\\n  function blockRating(int32 dexterity, uint heroClass) internal pure returns (int32){\\n    return int32(int(Math.min((dexterity.toUint() * initialHero(heroClass).multiplier.blockRating / _PRECISION), 75)));\\n  }\\n\\n  function life(int32 vitality, uint heroClass, uint32 level) internal pure returns (int32){\\n    return int32(int(\\n      (vitality.toUint() * initialHero(heroClass).multiplier.life / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.life / _PRECISION)\\n    ));\\n  }\\n\\n  function mana(int32 energy, uint heroClass, uint32 level) internal pure returns (int32){\\n    return int32(int(\\n      (energy.toUint() * initialHero(heroClass).multiplier.mana / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.mana / _PRECISION)\\n    ));\\n  }\\n\\n  function lifeChances(uint heroClass, uint32 /*level*/) internal pure returns (int32){\\n    return initialHero(heroClass).baseLifeChances;\\n  }\\n\\n  function levelExperience(uint32 level) internal pure returns (uint32) {\\n    if (level == 0 || level >= MAX_LEVEL) {\\n      return 0;\\n    }\\n    return uint32(uint(level) * BASE_EXPERIENCE * (67e17 - CalcLib.log2((uint(MAX_LEVEL - level + 2)) * 1e18)) / 1e18);\\n  }\\n\\n  function chanceToHit(\\n    uint attackersAttackRating,\\n    uint defendersDefenceRating,\\n    uint attackersLevel,\\n    uint defendersLevel,\\n    uint arFactor\\n  ) internal pure returns (uint) {\\n    attackersAttackRating += attackersAttackRating * arFactor / 100;\\n    uint x = Math.max(attackersAttackRating, 1);\\n    uint y = Math.max(attackersAttackRating + defendersDefenceRating, 1);\\n    uint z = attackersLevel;\\n    uint k = defendersLevel / 2;\\n    uint xy = x * 1e18 / y;\\n    uint zk = z * 1e18 / (attackersLevel + k);\\n    uint base = 2 * xy * zk / 1e18;\\n    return Math.max(Math.min(base, 0.95e18), 0.2e18);\\n  }\\n\\n  function experienceToLvl(uint experience, uint startFromLevel) internal pure returns (uint level) {\\n    level = startFromLevel;\\n    for (; level < MAX_LEVEL;) {\\n      if (levelExperience(uint32(level)) >= experience) {\\n        break;\\n      }\\n      unchecked{++level;}\\n    }\\n  }\\n\\n  function expPerMonster(uint32 monsterExp, uint monsterRarity, uint32 heroExp, uint32 heroCurrentLvl, uint monsterBiome) internal pure returns (uint32) {\\n    uint heroLvl = experienceToLvl(uint(heroExp), uint(heroCurrentLvl));\\n    uint heroBiome = heroLvl / StatLib.BIOME_LEVEL_STEP + 1;\\n    uint base = uint(monsterExp) + uint(monsterExp) * monsterRarity / _MAX_AMPLIFIER;\\n\\n    // reduce exp if hero not in his biome\\n    if (heroBiome > monsterBiome) {\\n      base = base / (2 ** (heroBiome - monsterBiome));\\n    }\\n    return uint32(base);\\n  }\\n\\n  /// @notice Allow to calculate delta param for {mintDropChance}\\n  function mintDropChanceDelta(uint experience, uint startFromLevel, uint monsterBiome) internal pure returns (uint) {\\n    uint heroBiome = StatLib.experienceToLvl(experience, startFromLevel) / StatLib.BIOME_LEVEL_STEP + 1;\\n    return heroBiome > monsterBiome ? 2**(heroBiome - monsterBiome) : 0;\\n  }\\n\\n  function initAttributes(\\n    bytes32[] storage attributes,\\n    uint heroClass,\\n    uint32 level,\\n    IStatController.CoreAttributes memory base\\n  ) internal returns (uint32[] memory result) {\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.STRENGTH), base.strength);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEXTERITY), base.dexterity);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.VITALITY), base.vitality);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ENERGY), base.energy);\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN), minDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX), maxDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING), attackRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE), defense(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING), blockRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE), life(base.vitality, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA), mana(base.energy, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE_CHANCES), lifeChances(heroClass, level));\\n\\n    result = new uint32[](3);\\n    result[0] = uint32(life(base.vitality, heroClass, level).toUint());\\n    result[1] = uint32(mana(base.energy, heroClass, level).toUint());\\n    result[2] = uint32(lifeChances(heroClass, uint32(level)).toUint());\\n  }\\n\\n  function updateCoreDependAttributesInMemory(\\n    int32[] memory attributes,\\n    int32[] memory bonus,\\n    uint heroClass,\\n    uint32 level\\n  ) internal pure returns (int32[] memory) {\\n    int32 strength = attributes[uint(IStatController.ATTRIBUTES.STRENGTH)];\\n    int32 dexterity = attributes[uint(IStatController.ATTRIBUTES.DEXTERITY)];\\n    int32 vitality = attributes[uint(IStatController.ATTRIBUTES.VITALITY)];\\n    int32 energy = attributes[uint(IStatController.ATTRIBUTES.ENERGY)];\\n\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] = minDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)];\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] = maxDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)];\\n    attributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] = attackRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.ATTACK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.DEFENSE)] = defense(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DEFENSE)];\\n    attributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] = blockRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.BLOCK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.LIFE)] = life(vitality, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.LIFE)];\\n    attributes[uint(IStatController.ATTRIBUTES.MANA)] = mana(energy, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.MANA)];\\n    return attributes;\\n  }\\n\\n  function updateCoreDependAttributes(\\n    IController controller,\\n    bytes32[] storage attributes,\\n    bytes32[] storage bonusMain,\\n    bytes32[] storage bonusExtra,\\n    IStatController.ChangeableStats memory _heroStats,\\n    uint index,\\n    address heroToken,\\n    int32 base\\n  ) internal {\\n    uint heroClass = IHeroController(controller.heroController()).heroClass(heroToken);\\n    if (index == uint(IStatController.ATTRIBUTES.STRENGTH)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN),\\n        StatLib.minDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n      );\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX),\\n        StatLib.maxDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.DEXTERITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING),\\n        StatLib.attackRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE),\\n        StatLib.defense(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING),\\n        StatLib.blockRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.VITALITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE),\\n        StatLib.life(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.ENERGY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA),\\n        StatLib.mana(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n      );\\n    }\\n  }\\n\\n  function attributesAdd(int32[] memory base, int32[] memory add) internal pure returns (int32[] memory) {\\n    unchecked{\\n      for (uint i; i < base.length; ++i) {\\n        base[i] += add[i];\\n      }\\n    }\\n    return base;\\n  }\\n\\n// Currently this function is not used\\n//  function attributesRemove(int32[] memory base, int32[] memory remove) internal pure returns (int32[] memory) {\\n//    unchecked{\\n//      for (uint i; i < base.length; ++i) {\\n//        base[i] = CalcLib.minusWithMinFloorI32(base[i], remove[i]);\\n//      }\\n//    }\\n//    return base;\\n//  }\\n\\n  function packChangeableStats(IStatController.ChangeableStats memory stats) internal pure returns (bytes32) {\\n    uint32[] memory cData = new uint32[](5);\\n    cData[0] = stats.level;\\n    cData[1] = stats.experience;\\n    cData[2] = stats.life;\\n    cData[3] = stats.mana;\\n    cData[4] = stats.lifeChances;\\n\\n    return cData.packUint32Array();\\n  }\\n\\n  function unpackChangeableStats(bytes32 data) internal pure returns (IStatController.ChangeableStats memory result) {\\n    uint32[] memory cData = data.unpackUint32Array();\\n    return IStatController.ChangeableStats({\\n      level: cData[0],\\n      experience: cData[1],\\n      life: cData[2],\\n      mana: cData[3],\\n      lifeChances: cData[4]\\n    });\\n  }\\n\\n  function bytesToFullAttributesArray(bytes32[] memory attributes) internal pure returns (int32[] memory result) {\\n    (int32[] memory values, uint8[] memory ids) = attributes.toInt32ArrayWithIds();\\n    return valuesToFullAttributesArray(values, ids);\\n  }\\n\\n  function valuesToFullAttributesArray(int32[] memory values, uint8[] memory ids) internal pure returns (int32[] memory result) {\\n    result = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < values.length; ++i) {\\n      int32 value = values[i];\\n      if (value != 0) {\\n        result[ids[i]] = value;\\n      }\\n    }\\n  }\\n  //endregion --------------------------- CALCULATIONS\\n\\n}\\n\",\"keccak256\":\"0x47c5ab6a3b59bad38850ea1e9bf51c4f318c26e7a21434a933e490445fbffb55\",\"license\":\"BUSL-1.1\"},\"contracts/openzeppelin/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  // To implement this library for multiple types with as little code repetition as possible, we write it in\\n  // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\\n  // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\\n  // This means that we can only create new EnumerableMaps for types that fit in bytes32.\\n\\n  /**\\n   * @dev Query for a nonexistent map key.\\n     */\\n  error EnumerableMapNonexistentKey(bytes32 key);\\n\\n  struct Bytes32ToBytes32Map {\\n    // Storage of keys\\n    EnumerableSet.Bytes32Set _keys;\\n    mapping(bytes32 key => bytes32) _values;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n    map._values[key] = value;\\n    return map._keys.add(key);\\n  }\\n\\n  /**\\n   * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n    delete map._values[key];\\n    return map._keys.remove(key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n    return map._keys.contains(key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n    return map._keys.length();\\n  }\\n\\n  /**\\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n    bytes32 key = map._keys.at(index);\\n    return (key, map._values[key]);\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == bytes32(0)) {\\n      return (contains(map, key), bytes32(0));\\n    } else {\\n      return (true, value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == 0 && !contains(map, key)) {\\n      revert EnumerableMapNonexistentKey(key);\\n    }\\n    return value;\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n    return map._keys.values();\\n  }\\n\\n  // UintToUintMap\\n\\n  struct UintToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key)));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintToAddressMap\\n\\n  struct UintToAddressMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressToUintMap\\n\\n  struct AddressToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n    return remove(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (address(uint160(uint256(key))), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // Bytes32ToUintMap\\n\\n  struct Bytes32ToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, key, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n    return remove(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n    return contains(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (key, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, key);\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, key));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x5052395b3d57e4347a977f96eba69188b4a952594afae411910995ecab5c1d05\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position is the index of the value in the `values` array plus 1.\\n    // Position 0 is used to mean a value is not in the set.\\n    mapping(bytes32 value => uint256) _positions;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._positions[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We cache the value's position to prevent multiple reads from the same storage slot\\n    uint256 position = set._positions[value];\\n\\n    if (position != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 valueIndex = position - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (valueIndex != lastIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the lastValue to the index where the value to delete is\\n        set._values[valueIndex] = lastValue;\\n        // Update the tracked position of the lastValue (that was just moved)\\n        set._positions[lastValue] = position;\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the tracked position for the deleted slot\\n      delete set._positions[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._positions[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n     */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xd5483249a7bac53a40791ade8d640831cdec526eea6b42a4db68f2ce13c008fa\",\"license\":\"MIT\"},\"contracts/openzeppelin/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n  struct InitializableStorage {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n         */\\n    uint64 _initialized;\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n    bool _initializing;\\n  }\\n\\n  // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n  /**\\n   * @dev The contract is already initialized.\\n     */\\n  error InvalidInitialization();\\n\\n  /**\\n   * @dev The contract is not initializing.\\n     */\\n  error NotInitializing();\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n  event Initialized(uint64 version);\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier initializer() {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    // Cache values to avoid duplicated sloads\\n    bool isTopLevelCall = !$._initializing;\\n    uint64 initialized = $._initialized;\\n\\n    // Allowed calls:\\n    // - initialSetup: the contract is not in the initializing state and no previous version was\\n    //                 initialized\\n    // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n    //                 current contract is just being deployed\\n    bool initialSetup = initialized == 0 && isTopLevelCall;\\n    bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n    if (!initialSetup && !construction) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = 1;\\n    if (isTopLevelCall) {\\n      $._initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      $._initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier reinitializer(uint64 version) {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing || $._initialized >= version) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = version;\\n    $._initializing = true;\\n    _;\\n    $._initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n  modifier onlyInitializing() {\\n    _checkInitializing();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n  function _checkInitializing() internal view virtual {\\n    if (!_isInitializing()) {\\n      revert NotInitializing();\\n    }\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n  function _disableInitializers() internal virtual {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing) {\\n      revert InvalidInitialization();\\n    }\\n    if ($._initialized != type(uint64).max) {\\n      $._initialized = type(uint64).max;\\n      emit Initialized(type(uint64).max);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n  function _getInitializedVersion() internal view returns (uint64) {\\n    return _getInitializableStorage()._initialized;\\n  }\\n\\n  /**\\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n  function _isInitializing() internal view returns (bool) {\\n    return _getInitializableStorage()._initializing;\\n  }\\n\\n  /**\\n   * @dev Returns a pointer to the storage namespace.\\n     */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n    assembly {\\n      $.slot := INITIALIZABLE_STORAGE\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x80aa3fc0fc9afdf84bd1a51716150cd13041f42d920a9afa8020ea41cf673809\",\"license\":\"MIT\"},\"contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n\\n  /**\\n    * @dev Muldiv operation overflow.\\n   */\\n  error MathOverflowedMulDiv();\\n\\n  enum Rounding {\\n    Floor, // Toward negative infinity\\n    Ceil, // Toward positive infinity\\n    Trunc, // Toward zero\\n    Expand // Away from zero\\n  }\\n\\n  /**\\n   * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      uint256 c = a + b;\\n      if (c < a) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b > a) return (false, 0);\\n      return (true, a - b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n      if (a == 0) return (true, 0);\\n      uint256 c = a * b;\\n      if (c / a != b) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a / b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a % b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (b == 0) {\\n      // Guarantee the same behavior as in a regular Solidity division.\\n      return a / b;\\n    }\\n\\n    // The following calculation ensures accurate ceiling division without overflow.\\n    // Since a is non-zero, (a - 1) / b will not overflow.\\n    // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n    // but the largest value we can obtain is type(uint256).max - 1, which happens\\n    // when a = type(uint256).max and b = 1.\\n    unchecked {\\n      return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n    unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n      uint256 prod0 = x * y; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n      if (prod1 == 0) {\\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n        // The surrounding unchecked block does not change this fact.\\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n        return prod0 / denominator;\\n      }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n      if (denominator <= prod1) {\\n        revert MathOverflowedMulDiv();\\n      }\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n      uint256 remainder;\\n      assembly {\\n      // Compute remainder using mulmod.\\n        remainder := mulmod(x, y, denominator)\\n\\n      // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n    // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n      uint256 twos = denominator & (0 - denominator);\\n      assembly {\\n      // Divide denominator by twos.\\n        denominator := div(denominator, twos)\\n\\n      // Divide [prod1 prod0] by twos.\\n        prod0 := div(prod0, twos)\\n\\n      // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n\\n    // Shift in bits from prod1 into prod0.\\n      prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n      uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n    // works in modular arithmetic, doubling the correct bits in each step.\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n      result = prod0 * inverse;\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n    unchecked {\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      return min(result, a / result);\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = sqrt(a);\\n      return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 128;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 64;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 32;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 16;\\n      }\\n      if (value >> 8 > 0) {\\n        value >>= 8;\\n        result += 8;\\n      }\\n      if (value >> 4 > 0) {\\n        value >>= 4;\\n        result += 4;\\n      }\\n      if (value >> 2 > 0) {\\n        value >>= 2;\\n        result += 2;\\n      }\\n      if (value >> 1 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log2(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >= 10 ** 64) {\\n        value /= 10 ** 64;\\n        result += 64;\\n      }\\n      if (value >= 10 ** 32) {\\n        value /= 10 ** 32;\\n        result += 32;\\n      }\\n      if (value >= 10 ** 16) {\\n        value /= 10 ** 16;\\n        result += 16;\\n      }\\n      if (value >= 10 ** 8) {\\n        value /= 10 ** 8;\\n        result += 8;\\n      }\\n      if (value >= 10 ** 4) {\\n        value /= 10 ** 4;\\n        result += 4;\\n      }\\n      if (value >= 10 ** 2) {\\n        value /= 10 ** 2;\\n        result += 2;\\n      }\\n      if (value >= 10 ** 1) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log10(value);\\n      return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 16;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 8;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 4;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 2;\\n      }\\n      if (value >> 8 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log256(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n  function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n    return uint8(rounding) % 2 == 1;\\n  }\\n\\n}\\n\",\"keccak256\":\"0x4d972e3e1d79f693b6cb42007d23c27256cb6f087392edea24b93585a822572c\",\"license\":\"MIT\"},\"contracts/proxy/Controllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Initializable.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../lib/SlotsLib.sol\\\";\\n\\n/// @title Implement basic functionality for any contract that require strict control\\n/// @dev Can be used with upgradeable pattern.\\n///      Require call __Controllable_init() in any case.\\n/// @author belbix\\nabstract contract Controllable is Initializable, IControllable {\\n  using SlotsLib for bytes32;\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant CONTROLLABLE_VERSION = \\\"1.0.0\\\";\\n\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.revision\\\")) - 1);\\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.prev_logic\\\")) - 1);\\n\\n  event ContractInitialized(address controller, uint ts, uint block);\\n  event RevisionIncreased(uint value, address oldLogic);\\n\\n  // init implementation contract\\n  constructor() initializer {}\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\n  /// @dev Use it only once after first logic setup\\n  /// @param controller_ Controller address\\n  function __Controllable_init(address controller_) internal onlyInitializing {\\n    _init(controller_);\\n  }\\n\\n  function _init(address controller_) private {\\n    require(controller_ != address(0), \\\"Zero controller\\\");\\n    _CONTROLLER_SLOT.set(controller_);\\n    _CREATED_SLOT.set(block.timestamp);\\n    _CREATED_BLOCK_SLOT.set(block.number);\\n    emit ContractInitialized(controller_, block.timestamp, block.number);\\n  }\\n\\n  /// @dev Return true if given address is controller\\n  function isController(address value_) public override view returns (bool) {\\n    return value_ == controller();\\n  }\\n\\n  /// @notice Return true if given address is setup as governance in Controller\\n  function isGovernance(address value_) public override view returns (bool) {\\n    return IController(controller()).governance() == value_;\\n  }\\n\\n  /// @dev Contract upgrade counter\\n  function revision() external view override returns (uint) {\\n    return _REVISION_SLOT.getUint();\\n  }\\n\\n  /// @dev Previous logic implementation\\n  function previousImplementation() external view override returns (address) {\\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\\n  }\\n\\n  // ************* SETTERS/GETTERS *******************\\n\\n  /// @notice Return controller address saved in the contract slot\\n  function controller() public view override returns (address) {\\n    return _CONTROLLER_SLOT.getAddress();\\n  }\\n\\n  /// @notice Return creation timestamp\\n  /// @return Creation timestamp\\n  function created() external view override returns (uint256) {\\n    return _CREATED_SLOT.getUint();\\n  }\\n\\n  /// @notice Return creation block number\\n  /// @return Creation block number\\n  function createdBlock() external override view returns (uint256) {\\n    return _CREATED_BLOCK_SLOT.getUint();\\n  }\\n\\n  /// @dev Revision should be increased on each contract upgrade\\n  function increaseRevision(address oldLogic) external override {\\n    require(msg.sender == address(this), \\\"Increase revision forbidden\\\");\\n    uint r = _REVISION_SLOT.getUint() + 1;\\n    _REVISION_SLOT.set(r);\\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\\n    emit RevisionIncreased(r, oldLogic);\\n  }\\n\\n}\\n\",\"keccak256\":\"0x1edc53f0d11834bebf4485746d04112ed10db9d4cb19b4945362c593ebf97daf\",\"license\":\"BUSL-1.1\"},\"contracts/solady/LibPRNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for generating pseudorandom numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\\n/// @author LazyShuffler based on NextShuffler by aschlosberg (divergencearran)\\n/// (https://github.com/divergencetech/ethier/blob/main/contracts/random/NextShuffler.sol)\\nlibrary LibPRNG {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The initial length must be greater than zero and less than `2**32 - 1`.\\n    error InvalidInitialLazyShufflerLength();\\n\\n    /// @dev The new length must not be less than the current length.\\n    error InvalidNewLazyShufflerLength();\\n\\n    /// @dev The lazy shuffler has not been initialized.\\n    error LazyShufflerNotInitialized();\\n\\n    /// @dev Cannot double initialize the lazy shuffler.\\n    error LazyShufflerAlreadyInitialized();\\n\\n    /// @dev The lazy shuffle has finished.\\n    error LazyShuffleFinished();\\n\\n    /// @dev The queried index is out of bounds.\\n    error LazyShufflerGetOutOfBounds();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pseudorandom number state in memory.\\n    struct PRNG {\\n        uint256 state;\\n    }\\n\\n    /// @dev A lazy Fisher-Yates shuffler for a range `[0..n)` in storage.\\n    struct LazyShuffler {\\n        // Bits Layout:\\n        // - [0..31]    `numShuffled`\\n        // - [32..223]  `permutationSlot`\\n        // - [224..255] `length`\\n        uint256 _state;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Seeds the `prng` with `state`.\\n    function seed(PRNG memory prng, uint256 state) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(prng, state)\\n        }\\n    }\\n\\n    /// @dev Returns the next pseudorandom uint256.\\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\\n        // We simply use `keccak256` for a great balance between\\n        // runtime gas costs, bytecode size, and statistical properties.\\n        //\\n        // A high-quality LCG with a 32-byte state\\n        // is only about 30% more gas efficient during runtime,\\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\\n        // when this function is inlined.\\n        //\\n        // Using this method is about 2x more efficient than\\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n        }\\n    }\\n\\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\\n    /// between 0 (inclusive) and `upper` (exclusive).\\n    /// If your modulus is big, this method is recommended\\n    /// for uniform sampling to avoid modulo bias.\\n    /// For uniform sampling across all uint256 values,\\n    /// or for small enough moduli such that the bias is neligible,\\n    /// use {next} instead.\\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := keccak256(prng, 0x20)\\n                mstore(prng, result)\\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\\n            }\\n            result := mod(result, upper)\\n        }\\n    }\\n\\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n\\n                    {\\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                let b := add(a, 0x01)\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let o := mod(shr(128, r), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n\\n                    {\\n                        let o := mod(and(r, mask), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the standard normal distribution denominated in `WAD`.\\n    function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\\n            // The chance of drawing a sample outside 10 \\u03c3 from the standard normal distribution\\n            // is \\u2248 0.000000000000000000000015, which is insignificant for most practical purposes.\\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\\n            let s := 0x1000000000000000100000000000000010000000000000001\\n            let r1 := mulmod(result, a, n)\\n            let r2 := mulmod(r1, a, n)\\n            let r3 := mulmod(r2, a, n)\\n            // forgefmt: disable-next-item\\n            result := sub(sar(96, mul(26614938895861601847173011183,\\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the unit exponential distribution denominated in `WAD`.\\n    function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\\n            // Gas usage varies, starting from about 172+ gas.\\n            let r := keccak256(prng, 0x20)\\n            mstore(prng, r)\\n            let p := shl(129, r)\\n            let w := shl(1, r)\\n            if iszero(gt(w, p)) {\\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n                for {} 1 {} {\\n                    r := mulmod(r, a, n)\\n                    if iszero(lt(shl(129, r), w)) {\\n                        r := mulmod(r, a, n)\\n                        result := add(1000000000000000000, result)\\n                        w := shl(1, r)\\n                        p := shl(129, r)\\n                        if iszero(lt(w, p)) { break }\\n                        continue\\n                    }\\n                    w := shl(1, r)\\n                    if iszero(lt(w, shl(129, r))) { break }\\n                }\\n            }\\n            result := add(div(p, shl(129, 170141183460469231732)), result)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*       STORAGE-BASED RANGE LAZY SHUFFLING OPERATIONS        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Initializes the state for lazy-shuffling the range `[0..n)`.\\n    /// Reverts if `n == 0 || n >= 2**32 - 1`.\\n    /// Reverts if `$` has already been initialized.\\n    /// If you need to reduce the length after initialization, just use a fresh new `$`.\\n    function initialize(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sload($.slot) {\\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, $.slot)\\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Increases the length of `$`.\\n    /// Reverts if `$` has not been initialized.\\n    function grow(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            // If the new length is smaller than the old length, revert.\\n            if lt(n, shr(224, state)) {\\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\\n        }\\n    }\\n\\n    /// @dev Restarts the shuffler by setting `numShuffled` to zero,\\n    /// such that all elements can be drawn again.\\n    /// Restarting does NOT clear the internal permutation, nor changes the length.\\n    /// Even with the same sequence of randomness, reshuffling can yield different results.\\n    function restart(LazyShuffler storage $) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot)\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, shl(32, shr(32, state)))\\n        }\\n    }\\n\\n    /// @dev Returns the number of elements that have been shuffled.\\n    function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := and(0xffffffff, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns the length of `$`.\\n    /// Returns zero if `$` is not initialized, else a non-zero value less than `2**32 - 1`.\\n    function length(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := shr(224, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns if `$` has been initialized.\\n    function initialized(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(iszero(sload($.slot)))\\n        }\\n    }\\n\\n    /// @dev Returns if there are any more elements left to shuffle.\\n    /// Reverts if `$` is not initialized.\\n    function finished(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := eq(shr(224, state), and(0xffffffff, state))\\n        }\\n    }\\n\\n    /// @dev Returns the current value stored at `index`, accounting for all historical shuffling.\\n    /// Reverts if `index` is greater than or equal to the `length` of `$`.\\n    function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            let n := shr(224, state) // Length of `$`.\\n            if iszero(lt(index, n)) {\\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let u32 := gt(n, 0xfffe)\\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\\n            result := and(m, shr(o, sload(s)))\\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\\n        }\\n    }\\n\\n    /// @dev Does a single Fisher-Yates shuffle step, increments the `numShuffled` in `$`,\\n    /// and returns the next value in the shuffled range.\\n    /// `randomness` can be taken from a good-enough source, or a higher quality source like VRF.\\n    /// Reverts if there are no more values to shuffle, which includes the case if `$` is not initialized.\\n    function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function _get(u32_, state_, i_) -> _value {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                _value := and(m_, shr(o_, sload(s_)))\\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\\n            }\\n            function _set(u32_, state_, i_, value_) {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                let v_ := sload(s_) // Bucket slot value.\\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\\n            }\\n            let state := sload($.slot) // The packed value at `$`.\\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\\n            let n := shr(224, state) // Length of `$`.\\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\\n            if iszero(remainder) {\\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\\n            chosen := _get(gt(n, 0xfffe), state, index)\\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdcb71f8dc72bb7384776154ca24d34c23e3c9bcf124bc75f0d2e379f9ebd021d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b507ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00805468010000000000000000810460ff1615906001600160401b03166000811580156200005d5750825b90506000826001600160401b031660011480156200007a5750303b155b90508115801562000089575080155b15620000a85760405163f92ee8a960e01b815260040160405180910390fd5b84546001600160401b03191660011785558315620000d757845460ff60401b1916680100000000000000001785555b83156200011e57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b5050505050615ea780620001336000396000f3fe608060405234801561001057600080fd5b50600436106101fd5760003560e01c80635d015a9a1161011b578063af6a5722116100a8578063af6a572214610495578063afb1a9ed146104a8578063b429afeb146104bb578063cf536690146104ce578063d4ac4848146104e1578063dee1f0e414610501578063f16a306614610514578063f77c479114610527578063fbed9ac51461052f578063ffa1ad741461054f57600080fd5b80635d015a9a146103c25780636bad2ebd146103d55780637527a8c0146103e85780637ac46f97146103fb5780637cc963801461040e578063906f0ced14610416578063936725ec1461042957806395e34c341461045a5780639d0bcca01461046d5780639ff45dbe1461048257600080fd5b8063236715f011610199578063236715f0146102ef578063271d229e1461030f578063325a19f11461032257806333237c091461032a5780633a6589511461033d5780633bdb788b146103605780633e4d93f6146103735780634593144c146103865780634fac6ccd1461038e57806357e9ee7b146103a157600080fd5b80630a82c861146102025780630f82ecaf1461022857806314e4105a1461023d578063184f61431461025057806319ab453c146102635780631c2aafe7146102765780631f051fa0146102895780631f74d4b2146102a957806320a7d299146102c9575b600080fd5b610215610210366004614ea6565b610573565b6040519081526020015b60405180910390f35b61023b610236366004614ebf565b61059c565b005b61023b61024b366004614ef6565b6105ba565b61023b61025e366004614f22565b6105d4565b61023b610271366004614f5d565b6105f6565b610215610284366004614f7a565b6106f1565b61029c610297366004614ef6565b61070e565b60405161021f9190614fee565b6102bc6102b7366004614ef6565b610729565b60405161021f9190615033565b6102dc6102d7366004614f7a565b610743565b60405160039190910b815260200161021f565b6103026102fd366004614ea6565b610758565b60405161021f9190615041565b61023b61031d3660046150d4565b610769565b610215610789565b61023b610338366004614f7a565b6107c2565b61035061034b3660046150d4565b6107dd565b604051901515815260200161021f565b61021561036e36600461513c565b6107f2565b61021561038136600461518c565b610807565b61021561081e565b61023b61039c366004614f5d565b61084e565b6103b46103af366004615356565b61095f565b60405161021f929190615416565b61023b6103d03660046154b2565b610985565b6102156103e3366004614ef6565b6109a0565b6102156103f636600461518c565b6109ac565b61023b610409366004614ef6565b6109b7565b6102156109d1565b61023b61042436600461551a565b6109ef565b61044d604051806040016040528060058152602001640312e302e360dc1b81525081565b60405161021f9190615598565b61029c610468366004614ef6565b610a17565b610475610a2b565b60405161021f91906155e7565b61023b6104903660046155fb565b610a5b565b6102156104a33660046156a6565b610a77565b61023b6104b6366004615747565b610a9e565b6103506104c9366004614f5d565b610aba565b61029c6104dc366004614ef6565b610adf565b6104f46104ef366004614ef6565b610af3565b60405161021f9190615843565b61035061050f366004614f5d565b610b0d565b610350610522366004614ef6565b610b92565b610475610ba6565b61054261053d366004614ef6565b610bd6565b60405161021f9190615851565b61044d60405180604001604052806005815260200164191718971960d91b81525081565b6000610596610580610bea565b6000848152600991909101602052604090205490565b92915050565b6105b66105a7610bea565b6105af610ba6565b8484610c0e565b5050565b6105b66105c5610bea565b6105cd610ba6565b8484610c6a565b6105f06105df610bea565b6105e7610ba6565b86868686610e74565b50505050565b6000610600610f07565b805490915060ff600160401b82041615906001600160401b03166000811580156106275750825b90506000826001600160401b031660011480156106435750303b155b905081158015610651575080155b1561066f5760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff19166001178555831561069957845460ff60401b1916600160401b1785555b6106a286610f2b565b83156106e957845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2906020015b60405180910390a15b505050505050565b60006107066106fe610bea565b858585610f3c565b949350505050565b606061072261071b610bea565b8484610f78565b9392505050565b610731614d98565b61072261073c610bea565b8484610ff5565b6000610706610750610bea565b8585856110c7565b610760614dbf565b610596826110ec565b610784610774610bea565b61077c610ba6565b858585611175565b505050565b60006107bd6107b960017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b6158ae565b5490565b905090565b6107846107cd610bea565b6107d5610ba6565b85858561120e565b60006107066107ea610bea565b858585611416565b60006107066107ff610bea565b858585611448565b600061081282611474565b63ffffffff1692915050565b60006107bd6107b960017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f16158ae565b3330146108a05760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b60006108be6107b96001600080516020615e328339815191526158ae565b6108c99060016158c1565b90506108eb816108e86001600080516020615e328339815191526158ae565b55565b61091a826108e860017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e46158ae565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c8910160405180910390a15050565b6060600061097c61096e610bea565b610976610ba6565b85611515565b91509150915091565b610784610990610bea565b610998610ba6565b8585856119b3565b60006107228383611a93565b600061059682611a9c565b6105b66109c2610bea565b6109ca610ba6565b8484611b07565b60006107bd6107b96001600080516020615e328339815191526158ae565b610a0e6109fa610bea565b610a02610ba6565b89898989898989611bc3565b50505050505050565b6060610722610a24610bea565b8484611e83565b60006107bd6107b960017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e46158ae565b610a74610a66610bea565b610a6e610ba6565b83611e98565b50565b6000610a95610a84610bea565b610a8c610ba6565b878787876120e9565b95945050505050565b6105f0610aa9610bea565b610ab1610ba6565b86868686612485565b6000610ac4610ba6565b6001600160a01b0316826001600160a01b0316149050919050565b6060610722610aec610bea565b84846126ac565b610afb614e46565b610722610b06610bea565b84846126c1565b6000816001600160a01b0316610b21610ba6565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b5e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b8291906158d4565b6001600160a01b03161492915050565b6000610722610b9f610bea565b84846127c5565b60006107bd6107b960017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c36186158ae565b6060610722610be3610bea565b84846127e6565b7fca9e8235a410bd2656fc43f888ab589425034944963c2881072ee821e700e60090565b610c1783612973565b600082815260098501602090815260409182902083905581518481529081018390527feacbaeebfddf6fe98883b2aebd3ab60c079050480c8e910625719e1f1c949fb2910160405180910390a150505050565b610c7383612973565b6000610c7f8383612c0b565b6000818152600387016020908152604080832080548251818502810185019093528083529495509293909291830182828015610cda57602002820191906000526020600020905b815481526020019060010190808311610cc6575b505050505090506000610cee8786866126c1565b600084815260028901602090815260408083208b83528184208251602b80825261058082019094529596509094909392909190820161056080368337505060408051602b80825261058082019092529293506000929150602082016105608036833701905050905060005b602b811015610de5576000610d6e8883612c5b565b9050600381900b15610ddc57610d8f82610d8783615907565b879190612cbf565b50848381518110610da257610da261592a565b602002602001018160030b60030b8152505080838381518110610dc757610dc761592a565b602002602001019060030b908160030b815250505b50600101610d59565b50600087815260038c0160205260408120610dff91614e74565b600087815260038c0160205260409020610e1f8b8587848a8f8989612d11565b610e2b8c898689612d7f565b7fe4463ace42a449d7bf063bb8fa11b72c776ab039ad1e72d287d73e47c8de0d218a8a33604051610e5e93929190615940565b60405180910390a1505050505050505050505050565b610e7d85612973565b644b41524d4160d81b82148015610e92575080155b15610eb057604051633757c0e960e21b815260040160405180910390fd5b80866008016000610ec18787612c0b565b8152602001908152602001600020600084815260200190815260200160002081905550600080516020615e52833981519152848484846040516106e09493929190615963565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b610f33612e37565b610a7481612e5e565b6000846008016000610f4e8686612c0b565b81526020019081526020016000206000838152602001908152602001600020549050949350505050565b6060610706846000610f8a8686612c0b565b8152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015610fe257602002820191906000526020600020905b815481526020019060010190808311610fce575b50602b9350610ff092505050565b612f7d565b610ffd614d98565b60006110268560010160006110128787612c0b565b81526020019081526020016000205461304d565b90506040518060800160405280826000815181106110465761104661592a565b602002602001015160030b8152602001826001815181106110695761106961592a565b602002602001015160030b81526020018260028151811061108c5761108c61592a565b602002602001015160030b8152602001826003815181106110af576110af61592a565b602002602001015160030b8152509150509392505050565b6000610a9585826110d88787612c0b565b8152602001908152602001600020836130c7565b6110f4614dbf565b816001036111045761059661312b565b816002036111145761059661321b565b816003036111245761059661330b565b81600403611134576105966133fb565b81600503611144576105966134eb565b81600603611154576105966135db565b604051635613365f60e11b815260048101839052602401610897565b919050565b61117e84612973565b6111ae818660070160006111928787612c0b565b81526020019081526020016000206136cb90919063ffffffff16565b6111cc578060405162f5d9b360e21b815260040161089791906155e7565b7fc6a0e07638c51d1c81ce988c90724173ebe207b85cd9b4563e34460940623e3d8383836040516111ff93929190615940565b60405180910390a15050505050565b611217846136e0565b60006112238484612c0b565b9050611230868284613775565b6000818152602087905260408120906112558285600161124f826110ec565b5161387c565b9050611262888483613a3e565b7f04bfc2c521fc80553ed48f0c6811371ee4c7f94f912eba0835d44c6e07b06f8586866040518060a00160405280600163ffffffff168152602001600063ffffffff168152602001856000815181106112bd576112bd61592a565b602002602001015163ffffffff168152602001856001815181106112e3576112e361592a565b602002602001015163ffffffff168152602001856002815181106113095761130961592a565b602002602001015163ffffffff1681525060405161132993929190615989565b60405180910390a160008381526008890160209081526040808320644b41524d4160d81b80855292819052928190206103e8908190559051600080516020615e5283398151915292611380928b928b929190615963565b60405180910390a1694845524f5f434c41535360b01b6000818152602083905260409081902087905551600080516020615e52833981519152916113c9918a918a918a90615963565b60405180910390a1600080516020615e5283398151915287876a111150551217d0d3d5539560aa1b60006040516114039493929190615963565b60405180910390a1505050505050505050565b6000610a958286600701600061142c8888612c0b565b8152602001908152602001600020613a9d90919063ffffffff16565b600084600501600061145b868686613abf565b8152602001908152602001600020549050949350505050565b600063ffffffff821615806114905750606363ffffffff831610155b1561149d57506000919050565b670de0b6b3a76400006114dc6114b48460636159ad565b6114bf9060026159ca565b6114d79063ffffffff16670de0b6b3a76400006159e7565b613af4565b6114ee90675cfb2e807b1e00006158ae565b611501620186a063ffffffff86166159e7565b61150b91906159e7565b6105969190615a14565b60608181015151600090808203611545576115398685600001518660200151610f78565b600092509250506119ab565b6000856001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa158015611585573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115a991906158d4565b60408051602b80825261058082019092529192506000919060208201610560803683370190505090506000836001600160401b038111156115ec576115ec6151a9565b604051908082528060200260200182016040528015611615578160200160208202803683370190505b50905060005b8481101561186f576000805b8281101561168f57896060015183815181106116455761164561592a565b60200260200101516001600160a01b03168482815181106116685761166861592a565b60200260200101516001600160a01b031603611687576001915061168f565b600101611627565b50801561169c5750611867565b846001600160a01b03166382b538de8a6060015184815181106116c1576116c161592a565b60200260200101516040518263ffffffff1660e01b81526004016116e591906155e7565b61018060405180830381865afa158015611703573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117279190615ac7565b60a001516117359088615b7e565b9650600080866001600160a01b031663010759758c60600151868151811061175f5761175f61592a565b60200260200101518d60800151878151811061177d5761177d61592a565b60200260200101516040518363ffffffff1660e01b81526004016117b69291906001600160a01b03929092168252602082015260400190565b600060405180830381865afa1580156117d3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526117fb9190810190615c0d565b915091506118128661180d8484613bd5565b613c7c565b508a6060015184815181106118295761182961592a565b60200260200101518585815181106118435761184361592a565b60200260200101906001600160a01b031690816001600160a01b0316815250505050505b60010161161b565b50600061188e6118888b8a600001518b60200151610f78565b84613c7c565b90506118a78361180d8c8b600001518c602001516126ac565b506118bf8361180d8c8b600001518c60200151611e83565b506119a381848b6001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061192791906158d4565b8b51604051631789b7b160e01b81526001600160a01b039290921691631789b7b191611955916004016155e7565b602060405180830381865afa158015611972573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119969190615cd1565b60ff168b60400151613cda565b965050505050505b935093915050565b6119bc846136e0565b60006119c98685856126c1565b905060006119d78585612c0b565b6000818152602089905260409020909150611a196119f860095b83906130c7565b8560095b81518110611a0c57611a0c61592a565b6020026020010151613ffd565b83604001818151611a2a91906159ca565b63ffffffff16905250611a48611a40600a6119f1565b85600a6119fc565b83606001818151611a5991906159ca565b63ffffffff1690525082516020840151604085015160608601516080870151611a89948d94889491939092614027565b5050505050505050565b6000602b610722565b600063ffffffff82161580611ab85750606363ffffffff831610155b15611ac557506000919050565b63ffffffff8216600114611afe57611ae6611ae16001846159ad565b611474565b611aef83611474565b611af991906159ad565b610812565b61081282611474565b611b1083612973565b6000846007016000611b228585612c0b565b815260200190815260200160002090506000611b3d8261417a565b905060005b81811015610a0e576000611b568482614184565b9050611b628482614190565b611b7f57604051630cd274c160e41b815260040160405180910390fd5b7f990d1d901983cf7739aa5466bcf829c3a1266cd06d92c460cc8bea285cddc800868683604051611bb293929190615940565b60405180910390a150600101611b42565b611bcc886141a5565b611bd9858560ff1661423a565b611c02576040516329c8542d60e11b81526004810186905260ff85166024820152604401610897565b600b8460ff1603611c59576000611c1c8a89896009611448565b141580611c3657506000611c338a8989600a611448565b14155b15611c595760405163160400f960e01b815260ff85166004820152602401610897565b60098460ff161480611c6e5750600a8460ff16145b15611ca5576000611c828a8989600b611448565b14611ca55760405163160400f960e01b815260ff85166004820152602401610897565b6000611cba88886001600160401b0316612c0b565b9050600080611cd7611cce8d8c8c8b611448565b9060a082901c90565b915091508315611d72576001600160a01b03821615611d0957604051637101e8f760e11b815260040160405180910390fd5b611d138686612c0b565b8c6005016000611d248d8d8c613abf565b815260200190815260200160002081905550611d5c8c6006016000858152602001908152602001600020548860ff16600160006142e4565b600084815260068e016020526040902055611e0c565b856001600160a01b0316826001600160a01b0316141580611d935750848114155b15611db157604051631d0507df60e21b815260040160405180910390fd5b8b6005016000611dc28c8c8b613abf565b815260200190815260200160002060009055611dfa8c6006016000858152602001908152602001600020548860ff16600060016142e4565b600084815260068e0160205260409020555b604080516001600160a01b03808d1682526001600160401b038c1660208301529181018a905260ff89166060820152908716608082015260a0810186905284151560c08201523360e08201527fc6cb8c2a2f03a3e6a43771211e58b1343cb739d7404d4130a938138f0fe24f149061010001610e5e565b6060610706846003016000610f8a8686612c0b565b611ea182612973565b6000611eb582600001518360200151612c0b565b90506000611ecc85846000015185602001516126c1565b60008381526020879052604081206080860151929350918190611f0b576000858152600289016020908152604080832060038c01909252909120611f29565b6000858152600389016020908152604080832060028c019092529091205b9150915060008660400151516001600160401b03811115611f4c57611f4c6151a9565b604051908082528060200260200182016040528015611f75578160200160208202803683370190505b50905060005b87604001515181101561205857600088604001518281518110611fa057611fa061592a565b602002602001015190508060030b60001461204f576000896060015115611feb57611fcc868484612cbf565b50829050611fda88856130c7565b611fe49190615b7e565b905061201b565b61200083611ff884615907565b889190612cbf565b5082905061200e88856130c7565b6120189190615cee565b90505b612026878483614397565b808484815181106120395761203961592a565b602002602001019060030b908160030b81525050505b50600101611f7b565b5061207188858585898c60000151878e60400151612d11565b61207d89878688612d7f565b86516020808901516060808b01516080808d0151604080516001600160a01b03909816885295870194909452901515938501939093529015159083015233908201527ffce07ece8fe77b8dd7f25ce471bb0c4b9bc4a78340b4bfa97827af2307b142409060a001611403565b60006120f4866136e0565b60006121008686612c0b565b60608401516040850151602086015186519394506005936121219190615b7e565b61212b9190615b7e565b6121359190615b7e565b60030b14612156576040516342fa645360e11b815260040160405180910390fd5b60006121638988886126c1565b9050606363ffffffff16816000015163ffffffff16106121965760405163094b8de560e31b815260040160405180910390fd5b806020015163ffffffff166121b4826000015163ffffffff16611474565b63ffffffff1611156121d9576040516311c7bf1f60e31b815260040160405180910390fd5b8051816121e582615d15565b63ffffffff16905250600082815260018a0160205260408120546122089061304d565b90508460000151816000815181106122225761222261592a565b602002602001018181516122369190615b7e565b60030b90525060208501518151829060019081106122565761225661592a565b6020026020010181815161226a9190615b7e565b60030b905250604085015181518290600290811061228a5761228a61592a565b6020026020010181815161229e9190615b7e565b600390810b9091526060870151835190925083919081106122c1576122c161592a565b602002602001018181516122d59190615b7e565b60030b9052506122e48161446e565b8a600101600085815260200190815260200160002081905550506000896000016000848152602001908152602001600020905060008a6002016000858152602001908152602001600020905060008b6003016000868152602001908152602001600020905061236f8b848484888f8d600001516000602b81111561236a5761236a6158f1565b6144e8565b6123908b848484888f8d602001516001602b81111561236a5761236a6158f1565b6123b18b848484888f8d604001516002602b81111561236a5761236a6158f1565b6123d28b848484888f8d606001516003602b81111561236a5761236a6158f1565b506123ea90506123e260096119f1565b60030b61451e565b63ffffffff1660408301526124026123e2600a6119f1565b63ffffffff16606083018190528251602084015160408501516080860151612434948f94899490939092909190614027565b7f084f827316fe91358fc5d55a0d078803e03592c8f0be5630e6b51b5feb08d7f0888888886040516124699493929190615d38565b60405180910390a1505163ffffffff1698975050505050505050565b61248e85612973565b600061249a8585612c0b565b905060006124a98887876126c1565b6040810151606082015160808301519293509091851561259257600085815260208c905260408120906124dc60096119f1565b905060006124eb83600a6130c7565b905060006124fc60165b85906130c7565b90508a602001518860200181815161251491906159ca565b63ffffffff1690525061254761252d600385900b61451e565b60408d015161253c908a6159ca565b63ffffffff1661454d565b96506125676125588360030b61451e565b60608d015161253c90896159ca565b95506125876125788260030b61451e565b60808d015161253c90886159ca565b945050505050612649565b602087015163ffffffff16156125bb5760405163ca9cdbef60e01b815260040160405180910390fd5b866040015163ffffffff168363ffffffff16116125d95760006125e8565b60408701516125e890846159ad565b9250866080015163ffffffff168163ffffffff1611612608576000612617565b608087015161261790826159ad565b9050866060015163ffffffff168263ffffffff1611612637576000612646565b606087015161264690836159ad565b91505b6126608b8686600001518760200151878787614027565b7ff92789f80d24dd48838ae6569cf1fe54ca007b75af463e061bd4732677002b2b8989898933604051612697959493929190615d63565b60405180910390a15050505050505050505050565b6060610706846002016000610f8a8686612c0b565b6126c9614e46565b60006126f28560040160006126de8787612c0b565b815260200190815260200160002054614563565b90506040518060a00160405280826000815181106127125761271261592a565b602002602001015163ffffffff168152602001826001815181106127385761273861592a565b602002602001015163ffffffff1681526020018260028151811061275e5761275e61592a565b602002602001015163ffffffff168152602001826003815181106127845761278461592a565b602002602001015163ffffffff168152602001826004815181106127aa576127aa61592a565b602002602001015163ffffffff168152509150509392505050565b60006127d28484846126c1565b6080015163ffffffff161515949350505050565b606060006128118560060160006127fd8787612c0b565b8152602001908152602001600020546145d8565b9050600081516001600160401b0381111561282e5761282e6151a9565b604051908082528060200260200182016040528015612857578160200160208202803683370190505b5090506000805b835160ff168160ff1610156128cf57838160ff16815181106128825761288261592a565b602002602001015160ff166000146128c757808383815181106128a7576128a761592a565b60ff90921660209283029190910190910152816128c381615da6565b9250505b60010161285e565b506000816001600160401b038111156128ea576128ea6151a9565b604051908082528060200260200182016040528015612913578160200160208202803683370190505b50905060005b82811015612967578381815181106129335761293361592a565b602002602001015182828151811061294d5761294d61592a565b60ff90921660209283029190910190910152600101612919565b50979650505050505050565b6000339050806001600160a01b0316826001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156129c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129e491906158d4565b6001600160a01b031614158015612a6e5750806001600160a01b0316826001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa158015612a3e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a6291906158d4565b6001600160a01b031614155b8015612aed5750806001600160a01b0316826001600160a01b031663683fedf76040518163ffffffff1660e01b8152600401602060405180830381865afa158015612abd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ae191906158d4565b6001600160a01b031614155b8015612b6c5750806001600160a01b0316826001600160a01b031663524a562f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612b3c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b6091906158d4565b6001600160a01b031614155b8015612beb5750806001600160a01b0316826001600160a01b03166389dd9f136040518163ffffffff1660e01b8152600401602060405180830381865afa158015612bbb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612bdf91906158d4565b6001600160a01b031614155b156105b6578060405163f652640360e01b815260040161089791906155e7565b60006001600160401b03821115612c3857604051633995b34160e01b815260048101839052602401610897565b5067ffffffffffffffff60a01b60a09190911b166001600160a01b039091161790565b8151600090612c6b600884615a14565b10612c7857506000610596565b612c83600883615dbf565b612c8e9060206159e7565b83612c9a600885615a14565b81518110612caa57612caa61592a565b602002602001015160001c901c905092915050565b6000806000612cce86866130c7565b60030b905060008460030b8260030b612ce79190615dd3565b9350839050612cfa600383900b82615dfb565b9250612d07878786614397565b5050935093915050565b805160005b81811015612d7357828181518110612d3057612d3061592a565b602002602001015160030b600014612d6b57612d6b8a8a8a8a8a868b8b8981518110612d5e57612d5e61592a565b6020026020010151614649565b600101612d16565b50505050505050505050565b6000612d8e6123e260096124f5565b90506000612da06123e285600a6130c7565b90506000836040015163ffffffff16831015612dd957612dca83856040015163ffffffff1661454d565b63ffffffff1660408501525060015b836060015163ffffffff16821015612e0e57612dff82856060015163ffffffff1661454d565b63ffffffff1660608501525060015b8015610a0e57610a0e878786600001518760200151886040015189606001518a60800151614027565b612e3f614861565b612e5c57604051631afcd79f60e31b815260040160405180910390fd5b565b6001600160a01b038116612ea65760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b6044820152606401610897565b612ed5816108e860017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c36186158ae565b612f04426108e860017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b6158ae565b612f33436108e860017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f16158ae565b604080516001600160a01b0383168152426020820152438183015290517f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe2367134269181900360600190a150565b60606000826001600160401b03811115612f9957612f996151a9565b604051908082528060200260200182016040528015612fc2578160200160208202803683370190505b50905060005b84518110156130455760005b600881101561303c57600081612feb8460086159e7565b612ff591906158c1565b9050858110613004575061303c565b61300e8782612c5b565b8482815181106130205761302061592a565b60039290920b6020928302919091019091015250600101612fd4565b50600101612fc8565b509392505050565b604080516008808252610120820190925260609160009190602082016101008036833701905050905060005b60088110156130c05761308d8160206159e7565b8460001c901c8282815181106130a5576130a561592a565b60039290920b60209283029190910190910152600101613079565b5092915050565b81546000906130d7600884615a14565b106130e457506000610596565b6130ef600883615dbf565b6130fa9060206159e7565b83613106600885615a14565b815481106131165761311661592a565b600091825260209091200154901c9392505050565b613133614dbf565b60405180608001604052806040518060800160405280600f60030b8152602001600f60030b8152602001601e60030b8152602001600a60030b81525081526020016040518060e0016040528067016345785d8a000081526020016702c68af0bb1400008152602001671bc16d674ec800008152602001671bc16d674ec80000815260200167016345785d8a000081526020016714d1120d7b16000081526020016706f05b59d3b2000081525081526020016040518060400160405280671bc16d674ec800008152602001670de0b6b3a76400008152508152602001600560030b815250905090565b613223614dbf565b60405180608001604052806040518060800160405280601e60030b8152602001600560030b8152602001601960030b8152602001600a60030b81525081526020016040518060e00160405280670214e8348c4f000081526020016703782dace9d900008152602001671bc16d674ec800008152602001670de0b6b3a7640000815260200167011c37937e080000815260200167120a871cc002000081526020016706f05b59d3b20000815250815260200160405180604001604052806718fae27693b400008152602001670de0b6b3a76400008152508152602001600560030b815250905090565b613313614dbf565b60405180608001604052806040518060800160405280600a60030b8152602001600f60030b8152602001601460030b8152602001601960030b81525081526020016040518060e0016040528067016345785d8a000081526020016702c68af0bb1400008152602001671bc16d674ec800008152602001670de0b6b3a7640000815260200167016345785d8a00008152602001670de0b6b3a76400008152602001671bc16d674ec800008152508152602001604051806040016040528067120a871cc00200008152602001671bc16d674ec800008152508152602001600560030b815250905090565b613403614dbf565b60405180608001604052806040518060800160405280600f60030b8152602001601960030b8152602001600f60030b8152602001600f60030b81525081526020016040518060e0016040528067016345785d8a000081526020016702c68af0bb1400008152602001673782dace9d90000081526020016729a2241af62c000081526020016702c68af0bb14000081526020016710a741a4627800008152602001670de0b6b3a7640000815250815260200160405180604001604052806717979cfe362a000081526020016714d1120d7b1600008152508152602001600560030b815250905090565b6134f3614dbf565b60405180608001604052806040518060800160405280601460030b8152602001601460030b8152602001601460030b8152602001600a60030b81525081526020016040518060e00160405280670214e8348c4f000081526020016703782dace9d9000081526020016729a2241af62c000081526020016722b1c8c1227a00008152602001670214e8348c4f000081526020016714d1120d7b16000081526020016714d1120d7b160000815250815260200160405180604001604052806714d1120d7b16000081526020016714d1120d7b1600008152508152602001600160030b815250905090565b6135e3614dbf565b60405180608001604052806040518060800160405280603260030b8152602001601e60030b8152602001603260030b8152602001600f60030b81525081526020016040518060e001604052806702c68af0bb1400008152602001670429d069189e00008152602001674563918244f4000081526020016729a2241af62c00008152602001670214e8348c4f00008152602001671bc16d674ec800008152602001671bc16d674ec80000815250815260200160405180604001604052806717979cfe362a000081526020016714d1120d7b1600008152508152602001600160030b815250905090565b6000610722836001600160a01b03841661487b565b336001600160a01b0316816001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613728573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061374c91906158d4565b6001600160a01b031614610a7457336040516303f2374960e01b815260040161089791906155e7565b6000613780826110ec565b5160408051600480825260a0820190925291925060009190602082016080803683370190505090508160000151816000815181106137c0576137c061592a565b602002602001019060030b908160030b815250508160200151816001815181106137ec576137ec61592a565b602002602001019060030b908160030b815250508160400151816002815181106138185761381861592a565b602002602001019060030b908160030b815250508160600151816003815181106138445761384461592a565b602002602001019060030b908160030b815250506138618161446e565b60009485526001909501602052505060409091209190915550565b606061388d60008351879190614397565b61389f60016020840151879190614397565b6138b160026040840151879190614397565b6138c360036060840151879190614397565b6138dc600483516138d490876148ca565b879190614397565b6138ed600583516138d49087614904565b61390060066138d484602001518761492c565b61391360076138d4846020015187614954565b61392660086138d484602001518761497c565b61393a60096138d4846040015187876149c2565b61394e600a6138d484606001518787614a39565b61395d60166138d48686614a95565b6040805160038082526080820190925290602082016060803683370190505090506139906123e2836040015186866149c2565b816000815181106139a3576139a361592a565b602002602001019063ffffffff16908163ffffffff16815250506139cf6123e283606001518686614a39565b816001815181106139e2576139e261592a565b602002602001019063ffffffff16908163ffffffff1681525050613a096123e28585614a95565b81600281518110613a1c57613a1c61592a565b602002602001019063ffffffff16908163ffffffff1681525050949350505050565b61078483836001600085600081518110613a5a57613a5a61592a565b602002602001015186600181518110613a7557613a7561592a565b602002602001015187600281518110613a9057613a9061592a565b6020026020010151614027565b6001600160a01b03811660009081526001830160205260408120541515610722565b60609290921b6001600160601b03191660209190911b6bffffffffffffffff00000000161760189190911b63ff000000161790565b6000670de0b6b3a7640000821015613b2257604051637046c4a960e01b815260048101839052602401610897565b6000613b3e613b39670de0b6b3a764000085615a14565b614aab565b90506000613b5482670de0b6b3a76400006159e7565b905083821c670de0b6b3a7640000819003613b7157509392505050565b6706f05b59d3b200005b8015613bcb57670de0b6b3a7640000613b9483806159e7565b613b9e9190615a14565b9150671bc16d674ec800008210613bc357613bb981846158c1565b9250600182901c91505b60011c613b7b565b5090949350505050565b60408051602b8082526105808201909252606091602082016105608036833701905050905060005b83518110156130c0576000848281518110613c1a57613c1a61592a565b602002602001015190508060030b600014613c73578083858481518110613c4357613c4361592a565b602002602001015160ff1681518110613c5e57613c5e61592a565b602002602001019060030b908160030b815250505b50600101613bfd565b606060005b8351811015613cd257828181518110613c9c57613c9c61592a565b6020026020010151848281518110613cb657613cb661592a565b60209081029190910101805190910160030b9052600101613c81565b509192915050565b60606000858181518110613cf057613cf061592a565b602002602001015190506000866001602b811115613d1057613d106158f1565b81518110613d2057613d2061592a565b602002602001015190506000876002602b811115613d4057613d406158f1565b81518110613d5057613d5061592a565b602002602001015190506000886003602b811115613d7057613d706158f1565b81518110613d8057613d8061592a565b60200260200101519050876004602b811115613d9e57613d9e6158f1565b81518110613dae57613dae61592a565b6020026020010151613dc085896148ca565b613dca9190615b7e565b89600481518110613ddd57613ddd61592a565b60039290920b6020928302919091019091015287600581518110613e0357613e0361592a565b6020026020010151613e158589614904565b613e1f9190615b7e565b89600581518110613e3257613e3261592a565b60039290920b6020928302919091019091015287600681518110613e5857613e5861592a565b6020026020010151613e6a848961492c565b613e749190615b7e565b89600681518110613e8757613e8761592a565b60039290920b6020928302919091019091015287600781518110613ead57613ead61592a565b6020026020010151613ebf8489614954565b613ec99190615b7e565b89600781518110613edc57613edc61592a565b60039290920b6020928302919091019091015287600881518110613f0257613f0261592a565b6020026020010151613f14848961497c565b613f1e9190615b7e565b89600881518110613f3157613f3161592a565b60039290920b6020928302919091019091015287600981518110613f5757613f5761592a565b6020026020010151613f6a8389896149c2565b613f749190615b7e565b89600981518110613f8757613f8761592a565b60039290920b6020928302919091019091015287600a81518110613fad57613fad61592a565b6020026020010151613fc0828989614a39565b613fca9190615b7e565b89600a81518110613fdd57613fdd61592a565b60039290920b602092830291909101909101525096979650505050505050565b60008160030b8360030b1261401e576140168284615cee565b60030b610722565b50600092915050565b63ffffffff811615801590614040575063ffffffff8316155b1561404a57600192505b60408051600580825260c082019092526000916020820160a08036833701905050905085816000815181106140815761408161592a565b602002602001019063ffffffff16908163ffffffff168152505084816001815181106140af576140af61592a565b602002602001019063ffffffff16908163ffffffff168152505083816002815181106140dd576140dd61592a565b602002602001019063ffffffff16908163ffffffff1681525050828160038151811061410b5761410b61592a565b602002602001019063ffffffff16908163ffffffff168152505081816004815181106141395761413961592a565b602002602001019063ffffffff16908163ffffffff168152505061415c81614b8a565b60009788526004909801602052505060409094209490945550505050565b6000610596825490565b60006107228383614c04565b6000610722836001600160a01b038416614c2e565b336001600160a01b0316816001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa1580156141ed573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061421191906158d4565b6001600160a01b031614610a74573360405163f6b9c4d960e01b815260040161089791906155e7565b6000821580614247575081155b1561425457506000610596565b600583116142655750808214610596565b6006830361428457600782148061427d575060085b82145b9050610596565b6008830361429357600661427a565b600983036142a257600961427a565b600783036142b157600a61427a565b600a83036142c057600b61427a565b600b830361401e57600c8214806142d75750600d82145b8061427d5750600e61427a565b6000806142f0866145d8565b90508260ff168186815181106143085761430861592a565b602002602001015160ff161461435d578260ff1681868151811061432e5761432e61592a565b602002602001015160ff1660405163c230690360e01b8152600401610897929190918252602082015260400190565b838186815181106143705761437061592a565b602002602001019060ff16908160ff168152505061438d81614d21565b9695505050505050565b60006143a4600884615a14565b905060006143b3600885615dbf565b6143be9060206159e7565b855490915080831061440a57855460018101875560008781526020812090910155805b838110156144085786546001818101895560008981526020812090920191909155016143e1565b505b818463ffffffff1663ffffffff16901b8263ffffffff901b198785815481106144355761443561592a565b906000526020600020015460001c161760001b86848154811061445a5761445a61592a565b600091825260209091200155505050505050565b8051600090600881111561449f57604051633d71388b60e21b81526004810182905260086024820152604401610897565b6000805b82811015613045576144b68160206159e7565b8582815181106144c8576144c861592a565b602090810291909101015163ffffffff16901b91909117906001016144a3565b8160030b600014611a89576000614500888385612cbf565b5090506145138989898989878a88614649565b505050505050505050565b6000808260030b121561453357506000919050565b60008260030b1361454657506000919050565b5060030b90565b600081831061455c5781610722565b5090919050565b604080516008808252610120820190925260609160009190602082016101008036833701905050905060005b60088110156130c0576145a38160206159e7565b8460001c901c8282815181106145bb576145bb61592a565b63ffffffff9092166020928302919091019091015260010161458f565b6040805160208082526104208201909252606091600091908082016104008036833701905050905060005b60208110156130c0576146178160086159e7565b8460001c901c82828151811061462f5761462f61592a565b60ff90921660209283029190910190910152600101614603565b6000886001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614689573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146ad91906158d4565b6001600160a01b0316631789b7b1846040518263ffffffff1660e01b81526004016146d891906155e7565b602060405180830381865afa1580156146f5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906147199190615cd1565b60ff1690508361479057614768600461473560045b89906130c7565b61474260045b8b906130c7565b61474c86866148ca565b6147569190615b7e565b6147609190615b7e565b8a9190614397565b61478b6005614777600561472e565b614781600561473b565b61474c8686614904565b614513565b60018403614801576147bb60066147a7600661472e565b6147b1600661473b565b61474c868661492c565b6147de60076147ca600761472e565b6147d4600761473b565b61474c8686614954565b61478b60086147ed600861472e565b6147f7600861473b565b61474c868661497c565b600284036148315761478b6009614818600961472e565b614822600961473b565b61474c86868b600001516149c2565b6003840361451357614513600a614848600a61472e565b614852600a61473b565b61474c86868b60000151614a39565b600061486b610f07565b54600160401b900460ff16919050565b60008181526001830160205260408120546148c257508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610596565b506000610596565b6000670de0b6b3a76400006148de836110ec565b60200151516148f0600386900b61451e565b6148fa91906159e7565b6107229190615a14565b6000670de0b6b3a7640000614918836110ec565b60200151602001516148f08560030b61451e565b6000670de0b6b3a7640000614940836110ec565b60200151604001516148f08560030b61451e565b6000670de0b6b3a7640000614968836110ec565b60200151606001516148f08560030b61451e565b6000610722670de0b6b3a7640000614993846110ec565b60200151608001516149a78660030b61451e565b6149b191906159e7565b6149bb9190615a14565b604b61454d565b6000670de0b6b3a76400006149d6846110ec565b60400151516149eb9063ffffffff85166159e7565b6149f59190615a14565b670de0b6b3a7640000614a07856110ec565b6020015160a00151614a1b8760030b61451e565b614a2591906159e7565b614a2f9190615a14565b61070691906158c1565b6000670de0b6b3a7640000614a4d846110ec565b6040015160200151614a659063ffffffff85166159e7565b614a6f9190615a14565b670de0b6b3a7640000614a81856110ec565b6020015160c00151614a1b8760030b61451e565b6000614aa0836110ec565b606001519392505050565b6000600160801b8210614acb57608091821c91614ac890826158c1565b90505b600160401b8210614ae957604091821c91614ae690826158c1565b90505b6401000000008210614b0857602091821c91614b0590826158c1565b90505b620100008210614b2557601091821c91614b2290826158c1565b90505b6101008210614b4157600891821c91614b3e90826158c1565b90505b60108210614b5c57600491821c91614b5990826158c1565b90505b60048210614b7757600291821c91614b7490826158c1565b90505b60028210611170576105966001826158c1565b80516000906008811115614bbb57604051633d71388b60e21b81526004810182905260086024820152604401610897565b6000805b8281101561304557614bd28160206159e7565b858281518110614be457614be461592a565b602090810291909101015163ffffffff16901b9190911790600101614bbf565b6000826000018281548110614c1b57614c1b61592a565b9060005260206000200154905092915050565b60008181526001830160205260408120548015614d17576000614c526001836158ae565b8554909150600090614c66906001906158ae565b9050808214614ccb576000866000018281548110614c8657614c8661592a565b9060005260206000200154905080876000018481548110614ca957614ca961592a565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080614cdc57614cdc615e1b565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610596565b6000915050610596565b80516000906020811115614d5257604051633d71388b60e21b81526004810182905260206024820152604401610897565b6000805b8281101561304557614d698160086159e7565b858281518110614d7b57614d7b61592a565b602090810291909101015160ff16901b9190911790600101614d56565b60408051608081018252600080825260208201819052918101829052606081019190915290565b6040518060800160405280614dd2614d98565b8152602001614e176040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b8152602001614e39604051806040016040528060008152602001600081525090565b8152600060209091015290565b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915290565b5080546000825590600052602060002090810190610a7491905b80821115614ea25760008155600101614e8e565b5090565b600060208284031215614eb857600080fd5b5035919050565b60008060408385031215614ed257600080fd5b50508035926020909101359150565b6001600160a01b0381168114610a7457600080fd5b60008060408385031215614f0957600080fd5b8235614f1481614ee1565b946020939093013593505050565b60008060008060808587031215614f3857600080fd5b8435614f4381614ee1565b966020860135965060408601359560600135945092505050565b600060208284031215614f6f57600080fd5b813561072281614ee1565b600080600060608486031215614f8f57600080fd5b8335614f9a81614ee1565b95602085013595506040909401359392505050565b60008151808452602080850194506020840160005b83811015614fe357815160030b87529582019590820190600101614fc4565b509495945050505050565b6020815260006107226020830184614faf565b805160030b8252602081015160030b6020830152604081015160030b6040830152606081015160030b60608301525050565b608081016105968284615001565b60006101c082019050615055828451615001565b602083015180516080840152602081015160a0840152604081015160c0840152606081015160e0840152608081015161010084015260a081015161012084015260c08101516101408401525060408301516150be61016084018280518252602090810151910152565b5060608301516130c06101a084018260030b9052565b6000806000606084860312156150e957600080fd5b83356150f481614ee1565b925060208401359150604084013561510b81614ee1565b809150509250925092565b80356001600160401b038116811461117057600080fd5b60ff81168114610a7457600080fd5b60008060006060848603121561515157600080fd5b833561515c81614ee1565b925061516a60208501615116565b9150604084013561510b8161512d565b63ffffffff81168114610a7457600080fd5b60006020828403121561519e57600080fd5b81356107228161517a565b634e487b7160e01b600052604160045260246000fd5b60405160a081016001600160401b03811182821017156151e1576151e16151a9565b60405290565b604051608081016001600160401b03811182821017156151e1576151e16151a9565b60405161012081016001600160401b03811182821017156151e1576151e16151a9565b604051601f8201601f191681016001600160401b0381118282101715615254576152546151a9565b604052919050565b60006001600160401b03821115615275576152756151a9565b5060051b60200190565b600082601f83011261529057600080fd5b813560206152a56152a08361525c565b61522c565b8083825260208201915060208460051b8701019350868411156152c757600080fd5b602086015b848110156152ec5780356152df81614ee1565b83529183019183016152cc565b509695505050505050565b600082601f83011261530857600080fd5b813560206153186152a08361525c565b8083825260208201915060208460051b87010193508684111561533a57600080fd5b602086015b848110156152ec578035835291830191830161533f565b60006020828403121561536857600080fd5b81356001600160401b038082111561537f57600080fd5b9083019060a0828603121561539357600080fd5b61539b6151bf565b82356153a681614ee1565b81526020838101359082015260408301356153c08161517a565b60408201526060830135828111156153d757600080fd5b6153e38782860161527f565b6060830152506080830135828111156153fb57600080fd5b615407878286016152f7565b60808301525095945050505050565b6040815260006154296040830185614faf565b90508260030b60208301529392505050565b8060030b8114610a7457600080fd5b600082601f83011261545b57600080fd5b8135602061546b6152a08361525c565b8083825260208201915060208460051b87010193508684111561548d57600080fd5b602086015b848110156152ec5780356154a58161543b565b8352918301918301615492565b6000806000606084860312156154c757600080fd5b83356154d281614ee1565b92506020840135915060408401356001600160401b038111156154f457600080fd5b6155008682870161544a565b9150509250925092565b8035801515811461117057600080fd5b600080600080600080600060e0888a03121561553557600080fd5b873561554081614ee1565b965061554e60208901615116565b95506040880135945060608801356155658161512d565b9350608088013561557581614ee1565b925060a0880135915061558a60c0890161550a565b905092959891949750929550565b60006020808352835180602085015260005b818110156155c6578581018301518582016040015282016155aa565b506000604082860101526040601f19601f8301168501019250505092915050565b6001600160a01b0391909116815260200190565b60006020828403121561560d57600080fd5b81356001600160401b038082111561562457600080fd5b9083019060a0828603121561563857600080fd5b6156406151bf565b823561564b81614ee1565b81526020838101359082015260408301358281111561566957600080fd5b6156758782860161544a565b6040830152506156876060840161550a565b60608201526156986080840161550a565b608082015295945050505050565b60008060008084860360e08112156156bd57600080fd5b85356156c881614ee1565b945060208601359350604086013592506080605f19820112156156ea57600080fd5b506156f36151e7565b60608601356157018161543b565b815260808601356157118161543b565b602082015260a08601356157248161543b565b604082015260c08601356157378161543b565b6060820152939692955090935050565b60008060008084860361010081121561575f57600080fd5b853561576a81614ee1565b94506020860135935060a0603f198201121561578557600080fd5b5061578e6151bf565b604086013561579c8161517a565b815260608601356157ac8161517a565b602082015260808601356157bf8161517a565b604082015260a08601356157d28161517a565b606082015260c08601356157e58161517a565b608082015291506157f860e0860161550a565b905092959194509250565b63ffffffff808251168352806020830151166020840152806040830151166040840152806060830151166060840152806080830151166080840152505050565b60a081016105968284615803565b6020808252825182820181905260009190848201906040850190845b8181101561588c57835160ff168352928401929184019160010161586d565b50909695505050505050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561059657610596615898565b8082018082111561059657610596615898565b6000602082840312156158e657600080fd5b815161072281614ee1565b634e487b7160e01b600052602160045260246000fd5b60008160030b637fffffff19810361592157615921615898565b60000392915050565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b0393841681526020810192909252909116604082015260600190565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b6001600160a01b03841681526020810183905260e081016107066040830184615803565b63ffffffff8281168282160390808211156130c0576130c0615898565b63ffffffff8181168382160190808211156130c0576130c0615898565b808202811582820484141761059657610596615898565b634e487b7160e01b600052601260045260246000fd5b600082615a2357615a236159fe565b500490565b80516111708161512d565b8051600d811061117057600080fd5b805161ffff8116811461117057600080fd5b80516111708161517a565b600060808284031215615a7157600080fd5b615a796151e7565b90508151615a868161543b565b81526020820151615a968161543b565b60208201526040820151615aa98161543b565b60408201526060820151615abc8161543b565b606082015292915050565b60006101808284031215615ada57600080fd5b615ae2615209565b615aeb83615a28565b8152615af960208401615a28565b6020820152615b0a60408401615a33565b6040820152615b1b60608401615a42565b6060820152615b2c60808401615a28565b6080820152615b3d60a08401615a54565b60a0820152615b4e60c08401615a28565b60c0820152615b5f60e08401615a28565b60e0820152610100615b7385828601615a5f565b908201529392505050565b600381810b9083900b01637fffffff8113637fffffff198212171561059657610596615898565b600082601f830112615bb657600080fd5b81516020615bc66152a08361525c565b8083825260208201915060208460051b870101935086841115615be857600080fd5b602086015b848110156152ec578051615c008161512d565b8352918301918301615bed565b60008060408385031215615c2057600080fd5b82516001600160401b0380821115615c3757600080fd5b818501915085601f830112615c4b57600080fd5b81516020615c5b6152a08361525c565b82815260059290921b84018101918181019089841115615c7a57600080fd5b948201945b83861015615ca1578551615c928161543b565b82529482019490820190615c7f565b91880151919650909350505080821115615cba57600080fd5b50615cc785828601615ba5565b9150509250929050565b600060208284031215615ce357600080fd5b81516107228161512d565b600382810b9082900b03637fffffff198112637fffffff8213171561059657610596615898565b600063ffffffff808316818103615d2e57615d2e615898565b6001019392505050565b6001600160a01b0385168152602081018490526040810183905260e08101610a956060830184615001565b6001600160a01b03868116825260208201869052610120820190615d8a6040840187615803565b84151560e0840152808416610100840152509695505050505050565b600060018201615db857615db8615898565b5060010190565b600082615dce57615dce6159fe565b500690565b8082018281126000831280158216821582161715615df357615df3615898565b505092915050565b81810360008312801583831316838312821617156130c0576130c0615898565b634e487b7160e01b600052603160045260246000fdfe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd944a3dd1d62bdf01982b7f6a998d66608c06e34399f68c67a575156ad74142bba26469706673582212203a3a95522303c1ba8f7e3a89b3a2df5ba500600257f23864cc5a03cb91b6d8b364736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101fd5760003560e01c80635d015a9a1161011b578063af6a5722116100a8578063af6a572214610495578063afb1a9ed146104a8578063b429afeb146104bb578063cf536690146104ce578063d4ac4848146104e1578063dee1f0e414610501578063f16a306614610514578063f77c479114610527578063fbed9ac51461052f578063ffa1ad741461054f57600080fd5b80635d015a9a146103c25780636bad2ebd146103d55780637527a8c0146103e85780637ac46f97146103fb5780637cc963801461040e578063906f0ced14610416578063936725ec1461042957806395e34c341461045a5780639d0bcca01461046d5780639ff45dbe1461048257600080fd5b8063236715f011610199578063236715f0146102ef578063271d229e1461030f578063325a19f11461032257806333237c091461032a5780633a6589511461033d5780633bdb788b146103605780633e4d93f6146103735780634593144c146103865780634fac6ccd1461038e57806357e9ee7b146103a157600080fd5b80630a82c861146102025780630f82ecaf1461022857806314e4105a1461023d578063184f61431461025057806319ab453c146102635780631c2aafe7146102765780631f051fa0146102895780631f74d4b2146102a957806320a7d299146102c9575b600080fd5b610215610210366004614ea6565b610573565b6040519081526020015b60405180910390f35b61023b610236366004614ebf565b61059c565b005b61023b61024b366004614ef6565b6105ba565b61023b61025e366004614f22565b6105d4565b61023b610271366004614f5d565b6105f6565b610215610284366004614f7a565b6106f1565b61029c610297366004614ef6565b61070e565b60405161021f9190614fee565b6102bc6102b7366004614ef6565b610729565b60405161021f9190615033565b6102dc6102d7366004614f7a565b610743565b60405160039190910b815260200161021f565b6103026102fd366004614ea6565b610758565b60405161021f9190615041565b61023b61031d3660046150d4565b610769565b610215610789565b61023b610338366004614f7a565b6107c2565b61035061034b3660046150d4565b6107dd565b604051901515815260200161021f565b61021561036e36600461513c565b6107f2565b61021561038136600461518c565b610807565b61021561081e565b61023b61039c366004614f5d565b61084e565b6103b46103af366004615356565b61095f565b60405161021f929190615416565b61023b6103d03660046154b2565b610985565b6102156103e3366004614ef6565b6109a0565b6102156103f636600461518c565b6109ac565b61023b610409366004614ef6565b6109b7565b6102156109d1565b61023b61042436600461551a565b6109ef565b61044d604051806040016040528060058152602001640312e302e360dc1b81525081565b60405161021f9190615598565b61029c610468366004614ef6565b610a17565b610475610a2b565b60405161021f91906155e7565b61023b6104903660046155fb565b610a5b565b6102156104a33660046156a6565b610a77565b61023b6104b6366004615747565b610a9e565b6103506104c9366004614f5d565b610aba565b61029c6104dc366004614ef6565b610adf565b6104f46104ef366004614ef6565b610af3565b60405161021f9190615843565b61035061050f366004614f5d565b610b0d565b610350610522366004614ef6565b610b92565b610475610ba6565b61054261053d366004614ef6565b610bd6565b60405161021f9190615851565b61044d60405180604001604052806005815260200164191718971960d91b81525081565b6000610596610580610bea565b6000848152600991909101602052604090205490565b92915050565b6105b66105a7610bea565b6105af610ba6565b8484610c0e565b5050565b6105b66105c5610bea565b6105cd610ba6565b8484610c6a565b6105f06105df610bea565b6105e7610ba6565b86868686610e74565b50505050565b6000610600610f07565b805490915060ff600160401b82041615906001600160401b03166000811580156106275750825b90506000826001600160401b031660011480156106435750303b155b905081158015610651575080155b1561066f5760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff19166001178555831561069957845460ff60401b1916600160401b1785555b6106a286610f2b565b83156106e957845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2906020015b60405180910390a15b505050505050565b60006107066106fe610bea565b858585610f3c565b949350505050565b606061072261071b610bea565b8484610f78565b9392505050565b610731614d98565b61072261073c610bea565b8484610ff5565b6000610706610750610bea565b8585856110c7565b610760614dbf565b610596826110ec565b610784610774610bea565b61077c610ba6565b858585611175565b505050565b60006107bd6107b960017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b6158ae565b5490565b905090565b6107846107cd610bea565b6107d5610ba6565b85858561120e565b60006107066107ea610bea565b858585611416565b60006107066107ff610bea565b858585611448565b600061081282611474565b63ffffffff1692915050565b60006107bd6107b960017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f16158ae565b3330146108a05760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b60006108be6107b96001600080516020615e328339815191526158ae565b6108c99060016158c1565b90506108eb816108e86001600080516020615e328339815191526158ae565b55565b61091a826108e860017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e46158ae565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c8910160405180910390a15050565b6060600061097c61096e610bea565b610976610ba6565b85611515565b91509150915091565b610784610990610bea565b610998610ba6565b8585856119b3565b60006107228383611a93565b600061059682611a9c565b6105b66109c2610bea565b6109ca610ba6565b8484611b07565b60006107bd6107b96001600080516020615e328339815191526158ae565b610a0e6109fa610bea565b610a02610ba6565b89898989898989611bc3565b50505050505050565b6060610722610a24610bea565b8484611e83565b60006107bd6107b960017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e46158ae565b610a74610a66610bea565b610a6e610ba6565b83611e98565b50565b6000610a95610a84610bea565b610a8c610ba6565b878787876120e9565b95945050505050565b6105f0610aa9610bea565b610ab1610ba6565b86868686612485565b6000610ac4610ba6565b6001600160a01b0316826001600160a01b0316149050919050565b6060610722610aec610bea565b84846126ac565b610afb614e46565b610722610b06610bea565b84846126c1565b6000816001600160a01b0316610b21610ba6565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b5e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b8291906158d4565b6001600160a01b03161492915050565b6000610722610b9f610bea565b84846127c5565b60006107bd6107b960017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c36186158ae565b6060610722610be3610bea565b84846127e6565b7fca9e8235a410bd2656fc43f888ab589425034944963c2881072ee821e700e60090565b610c1783612973565b600082815260098501602090815260409182902083905581518481529081018390527feacbaeebfddf6fe98883b2aebd3ab60c079050480c8e910625719e1f1c949fb2910160405180910390a150505050565b610c7383612973565b6000610c7f8383612c0b565b6000818152600387016020908152604080832080548251818502810185019093528083529495509293909291830182828015610cda57602002820191906000526020600020905b815481526020019060010190808311610cc6575b505050505090506000610cee8786866126c1565b600084815260028901602090815260408083208b83528184208251602b80825261058082019094529596509094909392909190820161056080368337505060408051602b80825261058082019092529293506000929150602082016105608036833701905050905060005b602b811015610de5576000610d6e8883612c5b565b9050600381900b15610ddc57610d8f82610d8783615907565b879190612cbf565b50848381518110610da257610da261592a565b602002602001018160030b60030b8152505080838381518110610dc757610dc761592a565b602002602001019060030b908160030b815250505b50600101610d59565b50600087815260038c0160205260408120610dff91614e74565b600087815260038c0160205260409020610e1f8b8587848a8f8989612d11565b610e2b8c898689612d7f565b7fe4463ace42a449d7bf063bb8fa11b72c776ab039ad1e72d287d73e47c8de0d218a8a33604051610e5e93929190615940565b60405180910390a1505050505050505050505050565b610e7d85612973565b644b41524d4160d81b82148015610e92575080155b15610eb057604051633757c0e960e21b815260040160405180910390fd5b80866008016000610ec18787612c0b565b8152602001908152602001600020600084815260200190815260200160002081905550600080516020615e52833981519152848484846040516106e09493929190615963565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b610f33612e37565b610a7481612e5e565b6000846008016000610f4e8686612c0b565b81526020019081526020016000206000838152602001908152602001600020549050949350505050565b6060610706846000610f8a8686612c0b565b8152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015610fe257602002820191906000526020600020905b815481526020019060010190808311610fce575b50602b9350610ff092505050565b612f7d565b610ffd614d98565b60006110268560010160006110128787612c0b565b81526020019081526020016000205461304d565b90506040518060800160405280826000815181106110465761104661592a565b602002602001015160030b8152602001826001815181106110695761106961592a565b602002602001015160030b81526020018260028151811061108c5761108c61592a565b602002602001015160030b8152602001826003815181106110af576110af61592a565b602002602001015160030b8152509150509392505050565b6000610a9585826110d88787612c0b565b8152602001908152602001600020836130c7565b6110f4614dbf565b816001036111045761059661312b565b816002036111145761059661321b565b816003036111245761059661330b565b81600403611134576105966133fb565b81600503611144576105966134eb565b81600603611154576105966135db565b604051635613365f60e11b815260048101839052602401610897565b919050565b61117e84612973565b6111ae818660070160006111928787612c0b565b81526020019081526020016000206136cb90919063ffffffff16565b6111cc578060405162f5d9b360e21b815260040161089791906155e7565b7fc6a0e07638c51d1c81ce988c90724173ebe207b85cd9b4563e34460940623e3d8383836040516111ff93929190615940565b60405180910390a15050505050565b611217846136e0565b60006112238484612c0b565b9050611230868284613775565b6000818152602087905260408120906112558285600161124f826110ec565b5161387c565b9050611262888483613a3e565b7f04bfc2c521fc80553ed48f0c6811371ee4c7f94f912eba0835d44c6e07b06f8586866040518060a00160405280600163ffffffff168152602001600063ffffffff168152602001856000815181106112bd576112bd61592a565b602002602001015163ffffffff168152602001856001815181106112e3576112e361592a565b602002602001015163ffffffff168152602001856002815181106113095761130961592a565b602002602001015163ffffffff1681525060405161132993929190615989565b60405180910390a160008381526008890160209081526040808320644b41524d4160d81b80855292819052928190206103e8908190559051600080516020615e5283398151915292611380928b928b929190615963565b60405180910390a1694845524f5f434c41535360b01b6000818152602083905260409081902087905551600080516020615e52833981519152916113c9918a918a918a90615963565b60405180910390a1600080516020615e5283398151915287876a111150551217d0d3d5539560aa1b60006040516114039493929190615963565b60405180910390a1505050505050505050565b6000610a958286600701600061142c8888612c0b565b8152602001908152602001600020613a9d90919063ffffffff16565b600084600501600061145b868686613abf565b8152602001908152602001600020549050949350505050565b600063ffffffff821615806114905750606363ffffffff831610155b1561149d57506000919050565b670de0b6b3a76400006114dc6114b48460636159ad565b6114bf9060026159ca565b6114d79063ffffffff16670de0b6b3a76400006159e7565b613af4565b6114ee90675cfb2e807b1e00006158ae565b611501620186a063ffffffff86166159e7565b61150b91906159e7565b6105969190615a14565b60608181015151600090808203611545576115398685600001518660200151610f78565b600092509250506119ab565b6000856001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa158015611585573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115a991906158d4565b60408051602b80825261058082019092529192506000919060208201610560803683370190505090506000836001600160401b038111156115ec576115ec6151a9565b604051908082528060200260200182016040528015611615578160200160208202803683370190505b50905060005b8481101561186f576000805b8281101561168f57896060015183815181106116455761164561592a565b60200260200101516001600160a01b03168482815181106116685761166861592a565b60200260200101516001600160a01b031603611687576001915061168f565b600101611627565b50801561169c5750611867565b846001600160a01b03166382b538de8a6060015184815181106116c1576116c161592a565b60200260200101516040518263ffffffff1660e01b81526004016116e591906155e7565b61018060405180830381865afa158015611703573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117279190615ac7565b60a001516117359088615b7e565b9650600080866001600160a01b031663010759758c60600151868151811061175f5761175f61592a565b60200260200101518d60800151878151811061177d5761177d61592a565b60200260200101516040518363ffffffff1660e01b81526004016117b69291906001600160a01b03929092168252602082015260400190565b600060405180830381865afa1580156117d3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526117fb9190810190615c0d565b915091506118128661180d8484613bd5565b613c7c565b508a6060015184815181106118295761182961592a565b60200260200101518585815181106118435761184361592a565b60200260200101906001600160a01b031690816001600160a01b0316815250505050505b60010161161b565b50600061188e6118888b8a600001518b60200151610f78565b84613c7c565b90506118a78361180d8c8b600001518c602001516126ac565b506118bf8361180d8c8b600001518c60200151611e83565b506119a381848b6001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061192791906158d4565b8b51604051631789b7b160e01b81526001600160a01b039290921691631789b7b191611955916004016155e7565b602060405180830381865afa158015611972573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119969190615cd1565b60ff168b60400151613cda565b965050505050505b935093915050565b6119bc846136e0565b60006119c98685856126c1565b905060006119d78585612c0b565b6000818152602089905260409020909150611a196119f860095b83906130c7565b8560095b81518110611a0c57611a0c61592a565b6020026020010151613ffd565b83604001818151611a2a91906159ca565b63ffffffff16905250611a48611a40600a6119f1565b85600a6119fc565b83606001818151611a5991906159ca565b63ffffffff1690525082516020840151604085015160608601516080870151611a89948d94889491939092614027565b5050505050505050565b6000602b610722565b600063ffffffff82161580611ab85750606363ffffffff831610155b15611ac557506000919050565b63ffffffff8216600114611afe57611ae6611ae16001846159ad565b611474565b611aef83611474565b611af991906159ad565b610812565b61081282611474565b611b1083612973565b6000846007016000611b228585612c0b565b815260200190815260200160002090506000611b3d8261417a565b905060005b81811015610a0e576000611b568482614184565b9050611b628482614190565b611b7f57604051630cd274c160e41b815260040160405180910390fd5b7f990d1d901983cf7739aa5466bcf829c3a1266cd06d92c460cc8bea285cddc800868683604051611bb293929190615940565b60405180910390a150600101611b42565b611bcc886141a5565b611bd9858560ff1661423a565b611c02576040516329c8542d60e11b81526004810186905260ff85166024820152604401610897565b600b8460ff1603611c59576000611c1c8a89896009611448565b141580611c3657506000611c338a8989600a611448565b14155b15611c595760405163160400f960e01b815260ff85166004820152602401610897565b60098460ff161480611c6e5750600a8460ff16145b15611ca5576000611c828a8989600b611448565b14611ca55760405163160400f960e01b815260ff85166004820152602401610897565b6000611cba88886001600160401b0316612c0b565b9050600080611cd7611cce8d8c8c8b611448565b9060a082901c90565b915091508315611d72576001600160a01b03821615611d0957604051637101e8f760e11b815260040160405180910390fd5b611d138686612c0b565b8c6005016000611d248d8d8c613abf565b815260200190815260200160002081905550611d5c8c6006016000858152602001908152602001600020548860ff16600160006142e4565b600084815260068e016020526040902055611e0c565b856001600160a01b0316826001600160a01b0316141580611d935750848114155b15611db157604051631d0507df60e21b815260040160405180910390fd5b8b6005016000611dc28c8c8b613abf565b815260200190815260200160002060009055611dfa8c6006016000858152602001908152602001600020548860ff16600060016142e4565b600084815260068e0160205260409020555b604080516001600160a01b03808d1682526001600160401b038c1660208301529181018a905260ff89166060820152908716608082015260a0810186905284151560c08201523360e08201527fc6cb8c2a2f03a3e6a43771211e58b1343cb739d7404d4130a938138f0fe24f149061010001610e5e565b6060610706846003016000610f8a8686612c0b565b611ea182612973565b6000611eb582600001518360200151612c0b565b90506000611ecc85846000015185602001516126c1565b60008381526020879052604081206080860151929350918190611f0b576000858152600289016020908152604080832060038c01909252909120611f29565b6000858152600389016020908152604080832060028c019092529091205b9150915060008660400151516001600160401b03811115611f4c57611f4c6151a9565b604051908082528060200260200182016040528015611f75578160200160208202803683370190505b50905060005b87604001515181101561205857600088604001518281518110611fa057611fa061592a565b602002602001015190508060030b60001461204f576000896060015115611feb57611fcc868484612cbf565b50829050611fda88856130c7565b611fe49190615b7e565b905061201b565b61200083611ff884615907565b889190612cbf565b5082905061200e88856130c7565b6120189190615cee565b90505b612026878483614397565b808484815181106120395761203961592a565b602002602001019060030b908160030b81525050505b50600101611f7b565b5061207188858585898c60000151878e60400151612d11565b61207d89878688612d7f565b86516020808901516060808b01516080808d0151604080516001600160a01b03909816885295870194909452901515938501939093529015159083015233908201527ffce07ece8fe77b8dd7f25ce471bb0c4b9bc4a78340b4bfa97827af2307b142409060a001611403565b60006120f4866136e0565b60006121008686612c0b565b60608401516040850151602086015186519394506005936121219190615b7e565b61212b9190615b7e565b6121359190615b7e565b60030b14612156576040516342fa645360e11b815260040160405180910390fd5b60006121638988886126c1565b9050606363ffffffff16816000015163ffffffff16106121965760405163094b8de560e31b815260040160405180910390fd5b806020015163ffffffff166121b4826000015163ffffffff16611474565b63ffffffff1611156121d9576040516311c7bf1f60e31b815260040160405180910390fd5b8051816121e582615d15565b63ffffffff16905250600082815260018a0160205260408120546122089061304d565b90508460000151816000815181106122225761222261592a565b602002602001018181516122369190615b7e565b60030b90525060208501518151829060019081106122565761225661592a565b6020026020010181815161226a9190615b7e565b60030b905250604085015181518290600290811061228a5761228a61592a565b6020026020010181815161229e9190615b7e565b600390810b9091526060870151835190925083919081106122c1576122c161592a565b602002602001018181516122d59190615b7e565b60030b9052506122e48161446e565b8a600101600085815260200190815260200160002081905550506000896000016000848152602001908152602001600020905060008a6002016000858152602001908152602001600020905060008b6003016000868152602001908152602001600020905061236f8b848484888f8d600001516000602b81111561236a5761236a6158f1565b6144e8565b6123908b848484888f8d602001516001602b81111561236a5761236a6158f1565b6123b18b848484888f8d604001516002602b81111561236a5761236a6158f1565b6123d28b848484888f8d606001516003602b81111561236a5761236a6158f1565b506123ea90506123e260096119f1565b60030b61451e565b63ffffffff1660408301526124026123e2600a6119f1565b63ffffffff16606083018190528251602084015160408501516080860151612434948f94899490939092909190614027565b7f084f827316fe91358fc5d55a0d078803e03592c8f0be5630e6b51b5feb08d7f0888888886040516124699493929190615d38565b60405180910390a1505163ffffffff1698975050505050505050565b61248e85612973565b600061249a8585612c0b565b905060006124a98887876126c1565b6040810151606082015160808301519293509091851561259257600085815260208c905260408120906124dc60096119f1565b905060006124eb83600a6130c7565b905060006124fc60165b85906130c7565b90508a602001518860200181815161251491906159ca565b63ffffffff1690525061254761252d600385900b61451e565b60408d015161253c908a6159ca565b63ffffffff1661454d565b96506125676125588360030b61451e565b60608d015161253c90896159ca565b95506125876125788260030b61451e565b60808d015161253c90886159ca565b945050505050612649565b602087015163ffffffff16156125bb5760405163ca9cdbef60e01b815260040160405180910390fd5b866040015163ffffffff168363ffffffff16116125d95760006125e8565b60408701516125e890846159ad565b9250866080015163ffffffff168163ffffffff1611612608576000612617565b608087015161261790826159ad565b9050866060015163ffffffff168263ffffffff1611612637576000612646565b606087015161264690836159ad565b91505b6126608b8686600001518760200151878787614027565b7ff92789f80d24dd48838ae6569cf1fe54ca007b75af463e061bd4732677002b2b8989898933604051612697959493929190615d63565b60405180910390a15050505050505050505050565b6060610706846002016000610f8a8686612c0b565b6126c9614e46565b60006126f28560040160006126de8787612c0b565b815260200190815260200160002054614563565b90506040518060a00160405280826000815181106127125761271261592a565b602002602001015163ffffffff168152602001826001815181106127385761273861592a565b602002602001015163ffffffff1681526020018260028151811061275e5761275e61592a565b602002602001015163ffffffff168152602001826003815181106127845761278461592a565b602002602001015163ffffffff168152602001826004815181106127aa576127aa61592a565b602002602001015163ffffffff168152509150509392505050565b60006127d28484846126c1565b6080015163ffffffff161515949350505050565b606060006128118560060160006127fd8787612c0b565b8152602001908152602001600020546145d8565b9050600081516001600160401b0381111561282e5761282e6151a9565b604051908082528060200260200182016040528015612857578160200160208202803683370190505b5090506000805b835160ff168160ff1610156128cf57838160ff16815181106128825761288261592a565b602002602001015160ff166000146128c757808383815181106128a7576128a761592a565b60ff90921660209283029190910190910152816128c381615da6565b9250505b60010161285e565b506000816001600160401b038111156128ea576128ea6151a9565b604051908082528060200260200182016040528015612913578160200160208202803683370190505b50905060005b82811015612967578381815181106129335761293361592a565b602002602001015182828151811061294d5761294d61592a565b60ff90921660209283029190910190910152600101612919565b50979650505050505050565b6000339050806001600160a01b0316826001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156129c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129e491906158d4565b6001600160a01b031614158015612a6e5750806001600160a01b0316826001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa158015612a3e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a6291906158d4565b6001600160a01b031614155b8015612aed5750806001600160a01b0316826001600160a01b031663683fedf76040518163ffffffff1660e01b8152600401602060405180830381865afa158015612abd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ae191906158d4565b6001600160a01b031614155b8015612b6c5750806001600160a01b0316826001600160a01b031663524a562f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612b3c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b6091906158d4565b6001600160a01b031614155b8015612beb5750806001600160a01b0316826001600160a01b03166389dd9f136040518163ffffffff1660e01b8152600401602060405180830381865afa158015612bbb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612bdf91906158d4565b6001600160a01b031614155b156105b6578060405163f652640360e01b815260040161089791906155e7565b60006001600160401b03821115612c3857604051633995b34160e01b815260048101839052602401610897565b5067ffffffffffffffff60a01b60a09190911b166001600160a01b039091161790565b8151600090612c6b600884615a14565b10612c7857506000610596565b612c83600883615dbf565b612c8e9060206159e7565b83612c9a600885615a14565b81518110612caa57612caa61592a565b602002602001015160001c901c905092915050565b6000806000612cce86866130c7565b60030b905060008460030b8260030b612ce79190615dd3565b9350839050612cfa600383900b82615dfb565b9250612d07878786614397565b5050935093915050565b805160005b81811015612d7357828181518110612d3057612d3061592a565b602002602001015160030b600014612d6b57612d6b8a8a8a8a8a868b8b8981518110612d5e57612d5e61592a565b6020026020010151614649565b600101612d16565b50505050505050505050565b6000612d8e6123e260096124f5565b90506000612da06123e285600a6130c7565b90506000836040015163ffffffff16831015612dd957612dca83856040015163ffffffff1661454d565b63ffffffff1660408501525060015b836060015163ffffffff16821015612e0e57612dff82856060015163ffffffff1661454d565b63ffffffff1660608501525060015b8015610a0e57610a0e878786600001518760200151886040015189606001518a60800151614027565b612e3f614861565b612e5c57604051631afcd79f60e31b815260040160405180910390fd5b565b6001600160a01b038116612ea65760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b6044820152606401610897565b612ed5816108e860017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c36186158ae565b612f04426108e860017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b6158ae565b612f33436108e860017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f16158ae565b604080516001600160a01b0383168152426020820152438183015290517f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe2367134269181900360600190a150565b60606000826001600160401b03811115612f9957612f996151a9565b604051908082528060200260200182016040528015612fc2578160200160208202803683370190505b50905060005b84518110156130455760005b600881101561303c57600081612feb8460086159e7565b612ff591906158c1565b9050858110613004575061303c565b61300e8782612c5b565b8482815181106130205761302061592a565b60039290920b6020928302919091019091015250600101612fd4565b50600101612fc8565b509392505050565b604080516008808252610120820190925260609160009190602082016101008036833701905050905060005b60088110156130c05761308d8160206159e7565b8460001c901c8282815181106130a5576130a561592a565b60039290920b60209283029190910190910152600101613079565b5092915050565b81546000906130d7600884615a14565b106130e457506000610596565b6130ef600883615dbf565b6130fa9060206159e7565b83613106600885615a14565b815481106131165761311661592a565b600091825260209091200154901c9392505050565b613133614dbf565b60405180608001604052806040518060800160405280600f60030b8152602001600f60030b8152602001601e60030b8152602001600a60030b81525081526020016040518060e0016040528067016345785d8a000081526020016702c68af0bb1400008152602001671bc16d674ec800008152602001671bc16d674ec80000815260200167016345785d8a000081526020016714d1120d7b16000081526020016706f05b59d3b2000081525081526020016040518060400160405280671bc16d674ec800008152602001670de0b6b3a76400008152508152602001600560030b815250905090565b613223614dbf565b60405180608001604052806040518060800160405280601e60030b8152602001600560030b8152602001601960030b8152602001600a60030b81525081526020016040518060e00160405280670214e8348c4f000081526020016703782dace9d900008152602001671bc16d674ec800008152602001670de0b6b3a7640000815260200167011c37937e080000815260200167120a871cc002000081526020016706f05b59d3b20000815250815260200160405180604001604052806718fae27693b400008152602001670de0b6b3a76400008152508152602001600560030b815250905090565b613313614dbf565b60405180608001604052806040518060800160405280600a60030b8152602001600f60030b8152602001601460030b8152602001601960030b81525081526020016040518060e0016040528067016345785d8a000081526020016702c68af0bb1400008152602001671bc16d674ec800008152602001670de0b6b3a7640000815260200167016345785d8a00008152602001670de0b6b3a76400008152602001671bc16d674ec800008152508152602001604051806040016040528067120a871cc00200008152602001671bc16d674ec800008152508152602001600560030b815250905090565b613403614dbf565b60405180608001604052806040518060800160405280600f60030b8152602001601960030b8152602001600f60030b8152602001600f60030b81525081526020016040518060e0016040528067016345785d8a000081526020016702c68af0bb1400008152602001673782dace9d90000081526020016729a2241af62c000081526020016702c68af0bb14000081526020016710a741a4627800008152602001670de0b6b3a7640000815250815260200160405180604001604052806717979cfe362a000081526020016714d1120d7b1600008152508152602001600560030b815250905090565b6134f3614dbf565b60405180608001604052806040518060800160405280601460030b8152602001601460030b8152602001601460030b8152602001600a60030b81525081526020016040518060e00160405280670214e8348c4f000081526020016703782dace9d9000081526020016729a2241af62c000081526020016722b1c8c1227a00008152602001670214e8348c4f000081526020016714d1120d7b16000081526020016714d1120d7b160000815250815260200160405180604001604052806714d1120d7b16000081526020016714d1120d7b1600008152508152602001600160030b815250905090565b6135e3614dbf565b60405180608001604052806040518060800160405280603260030b8152602001601e60030b8152602001603260030b8152602001600f60030b81525081526020016040518060e001604052806702c68af0bb1400008152602001670429d069189e00008152602001674563918244f4000081526020016729a2241af62c00008152602001670214e8348c4f00008152602001671bc16d674ec800008152602001671bc16d674ec80000815250815260200160405180604001604052806717979cfe362a000081526020016714d1120d7b1600008152508152602001600160030b815250905090565b6000610722836001600160a01b03841661487b565b336001600160a01b0316816001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613728573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061374c91906158d4565b6001600160a01b031614610a7457336040516303f2374960e01b815260040161089791906155e7565b6000613780826110ec565b5160408051600480825260a0820190925291925060009190602082016080803683370190505090508160000151816000815181106137c0576137c061592a565b602002602001019060030b908160030b815250508160200151816001815181106137ec576137ec61592a565b602002602001019060030b908160030b815250508160400151816002815181106138185761381861592a565b602002602001019060030b908160030b815250508160600151816003815181106138445761384461592a565b602002602001019060030b908160030b815250506138618161446e565b60009485526001909501602052505060409091209190915550565b606061388d60008351879190614397565b61389f60016020840151879190614397565b6138b160026040840151879190614397565b6138c360036060840151879190614397565b6138dc600483516138d490876148ca565b879190614397565b6138ed600583516138d49087614904565b61390060066138d484602001518761492c565b61391360076138d4846020015187614954565b61392660086138d484602001518761497c565b61393a60096138d4846040015187876149c2565b61394e600a6138d484606001518787614a39565b61395d60166138d48686614a95565b6040805160038082526080820190925290602082016060803683370190505090506139906123e2836040015186866149c2565b816000815181106139a3576139a361592a565b602002602001019063ffffffff16908163ffffffff16815250506139cf6123e283606001518686614a39565b816001815181106139e2576139e261592a565b602002602001019063ffffffff16908163ffffffff1681525050613a096123e28585614a95565b81600281518110613a1c57613a1c61592a565b602002602001019063ffffffff16908163ffffffff1681525050949350505050565b61078483836001600085600081518110613a5a57613a5a61592a565b602002602001015186600181518110613a7557613a7561592a565b602002602001015187600281518110613a9057613a9061592a565b6020026020010151614027565b6001600160a01b03811660009081526001830160205260408120541515610722565b60609290921b6001600160601b03191660209190911b6bffffffffffffffff00000000161760189190911b63ff000000161790565b6000670de0b6b3a7640000821015613b2257604051637046c4a960e01b815260048101839052602401610897565b6000613b3e613b39670de0b6b3a764000085615a14565b614aab565b90506000613b5482670de0b6b3a76400006159e7565b905083821c670de0b6b3a7640000819003613b7157509392505050565b6706f05b59d3b200005b8015613bcb57670de0b6b3a7640000613b9483806159e7565b613b9e9190615a14565b9150671bc16d674ec800008210613bc357613bb981846158c1565b9250600182901c91505b60011c613b7b565b5090949350505050565b60408051602b8082526105808201909252606091602082016105608036833701905050905060005b83518110156130c0576000848281518110613c1a57613c1a61592a565b602002602001015190508060030b600014613c73578083858481518110613c4357613c4361592a565b602002602001015160ff1681518110613c5e57613c5e61592a565b602002602001019060030b908160030b815250505b50600101613bfd565b606060005b8351811015613cd257828181518110613c9c57613c9c61592a565b6020026020010151848281518110613cb657613cb661592a565b60209081029190910101805190910160030b9052600101613c81565b509192915050565b60606000858181518110613cf057613cf061592a565b602002602001015190506000866001602b811115613d1057613d106158f1565b81518110613d2057613d2061592a565b602002602001015190506000876002602b811115613d4057613d406158f1565b81518110613d5057613d5061592a565b602002602001015190506000886003602b811115613d7057613d706158f1565b81518110613d8057613d8061592a565b60200260200101519050876004602b811115613d9e57613d9e6158f1565b81518110613dae57613dae61592a565b6020026020010151613dc085896148ca565b613dca9190615b7e565b89600481518110613ddd57613ddd61592a565b60039290920b6020928302919091019091015287600581518110613e0357613e0361592a565b6020026020010151613e158589614904565b613e1f9190615b7e565b89600581518110613e3257613e3261592a565b60039290920b6020928302919091019091015287600681518110613e5857613e5861592a565b6020026020010151613e6a848961492c565b613e749190615b7e565b89600681518110613e8757613e8761592a565b60039290920b6020928302919091019091015287600781518110613ead57613ead61592a565b6020026020010151613ebf8489614954565b613ec99190615b7e565b89600781518110613edc57613edc61592a565b60039290920b6020928302919091019091015287600881518110613f0257613f0261592a565b6020026020010151613f14848961497c565b613f1e9190615b7e565b89600881518110613f3157613f3161592a565b60039290920b6020928302919091019091015287600981518110613f5757613f5761592a565b6020026020010151613f6a8389896149c2565b613f749190615b7e565b89600981518110613f8757613f8761592a565b60039290920b6020928302919091019091015287600a81518110613fad57613fad61592a565b6020026020010151613fc0828989614a39565b613fca9190615b7e565b89600a81518110613fdd57613fdd61592a565b60039290920b602092830291909101909101525096979650505050505050565b60008160030b8360030b1261401e576140168284615cee565b60030b610722565b50600092915050565b63ffffffff811615801590614040575063ffffffff8316155b1561404a57600192505b60408051600580825260c082019092526000916020820160a08036833701905050905085816000815181106140815761408161592a565b602002602001019063ffffffff16908163ffffffff168152505084816001815181106140af576140af61592a565b602002602001019063ffffffff16908163ffffffff168152505083816002815181106140dd576140dd61592a565b602002602001019063ffffffff16908163ffffffff1681525050828160038151811061410b5761410b61592a565b602002602001019063ffffffff16908163ffffffff168152505081816004815181106141395761413961592a565b602002602001019063ffffffff16908163ffffffff168152505061415c81614b8a565b60009788526004909801602052505060409094209490945550505050565b6000610596825490565b60006107228383614c04565b6000610722836001600160a01b038416614c2e565b336001600160a01b0316816001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa1580156141ed573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061421191906158d4565b6001600160a01b031614610a74573360405163f6b9c4d960e01b815260040161089791906155e7565b6000821580614247575081155b1561425457506000610596565b600583116142655750808214610596565b6006830361428457600782148061427d575060085b82145b9050610596565b6008830361429357600661427a565b600983036142a257600961427a565b600783036142b157600a61427a565b600a83036142c057600b61427a565b600b830361401e57600c8214806142d75750600d82145b8061427d5750600e61427a565b6000806142f0866145d8565b90508260ff168186815181106143085761430861592a565b602002602001015160ff161461435d578260ff1681868151811061432e5761432e61592a565b602002602001015160ff1660405163c230690360e01b8152600401610897929190918252602082015260400190565b838186815181106143705761437061592a565b602002602001019060ff16908160ff168152505061438d81614d21565b9695505050505050565b60006143a4600884615a14565b905060006143b3600885615dbf565b6143be9060206159e7565b855490915080831061440a57855460018101875560008781526020812090910155805b838110156144085786546001818101895560008981526020812090920191909155016143e1565b505b818463ffffffff1663ffffffff16901b8263ffffffff901b198785815481106144355761443561592a565b906000526020600020015460001c161760001b86848154811061445a5761445a61592a565b600091825260209091200155505050505050565b8051600090600881111561449f57604051633d71388b60e21b81526004810182905260086024820152604401610897565b6000805b82811015613045576144b68160206159e7565b8582815181106144c8576144c861592a565b602090810291909101015163ffffffff16901b91909117906001016144a3565b8160030b600014611a89576000614500888385612cbf565b5090506145138989898989878a88614649565b505050505050505050565b6000808260030b121561453357506000919050565b60008260030b1361454657506000919050565b5060030b90565b600081831061455c5781610722565b5090919050565b604080516008808252610120820190925260609160009190602082016101008036833701905050905060005b60088110156130c0576145a38160206159e7565b8460001c901c8282815181106145bb576145bb61592a565b63ffffffff9092166020928302919091019091015260010161458f565b6040805160208082526104208201909252606091600091908082016104008036833701905050905060005b60208110156130c0576146178160086159e7565b8460001c901c82828151811061462f5761462f61592a565b60ff90921660209283029190910190910152600101614603565b6000886001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614689573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146ad91906158d4565b6001600160a01b0316631789b7b1846040518263ffffffff1660e01b81526004016146d891906155e7565b602060405180830381865afa1580156146f5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906147199190615cd1565b60ff1690508361479057614768600461473560045b89906130c7565b61474260045b8b906130c7565b61474c86866148ca565b6147569190615b7e565b6147609190615b7e565b8a9190614397565b61478b6005614777600561472e565b614781600561473b565b61474c8686614904565b614513565b60018403614801576147bb60066147a7600661472e565b6147b1600661473b565b61474c868661492c565b6147de60076147ca600761472e565b6147d4600761473b565b61474c8686614954565b61478b60086147ed600861472e565b6147f7600861473b565b61474c868661497c565b600284036148315761478b6009614818600961472e565b614822600961473b565b61474c86868b600001516149c2565b6003840361451357614513600a614848600a61472e565b614852600a61473b565b61474c86868b60000151614a39565b600061486b610f07565b54600160401b900460ff16919050565b60008181526001830160205260408120546148c257508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610596565b506000610596565b6000670de0b6b3a76400006148de836110ec565b60200151516148f0600386900b61451e565b6148fa91906159e7565b6107229190615a14565b6000670de0b6b3a7640000614918836110ec565b60200151602001516148f08560030b61451e565b6000670de0b6b3a7640000614940836110ec565b60200151604001516148f08560030b61451e565b6000670de0b6b3a7640000614968836110ec565b60200151606001516148f08560030b61451e565b6000610722670de0b6b3a7640000614993846110ec565b60200151608001516149a78660030b61451e565b6149b191906159e7565b6149bb9190615a14565b604b61454d565b6000670de0b6b3a76400006149d6846110ec565b60400151516149eb9063ffffffff85166159e7565b6149f59190615a14565b670de0b6b3a7640000614a07856110ec565b6020015160a00151614a1b8760030b61451e565b614a2591906159e7565b614a2f9190615a14565b61070691906158c1565b6000670de0b6b3a7640000614a4d846110ec565b6040015160200151614a659063ffffffff85166159e7565b614a6f9190615a14565b670de0b6b3a7640000614a81856110ec565b6020015160c00151614a1b8760030b61451e565b6000614aa0836110ec565b606001519392505050565b6000600160801b8210614acb57608091821c91614ac890826158c1565b90505b600160401b8210614ae957604091821c91614ae690826158c1565b90505b6401000000008210614b0857602091821c91614b0590826158c1565b90505b620100008210614b2557601091821c91614b2290826158c1565b90505b6101008210614b4157600891821c91614b3e90826158c1565b90505b60108210614b5c57600491821c91614b5990826158c1565b90505b60048210614b7757600291821c91614b7490826158c1565b90505b60028210611170576105966001826158c1565b80516000906008811115614bbb57604051633d71388b60e21b81526004810182905260086024820152604401610897565b6000805b8281101561304557614bd28160206159e7565b858281518110614be457614be461592a565b602090810291909101015163ffffffff16901b9190911790600101614bbf565b6000826000018281548110614c1b57614c1b61592a565b9060005260206000200154905092915050565b60008181526001830160205260408120548015614d17576000614c526001836158ae565b8554909150600090614c66906001906158ae565b9050808214614ccb576000866000018281548110614c8657614c8661592a565b9060005260206000200154905080876000018481548110614ca957614ca961592a565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080614cdc57614cdc615e1b565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610596565b6000915050610596565b80516000906020811115614d5257604051633d71388b60e21b81526004810182905260206024820152604401610897565b6000805b8281101561304557614d698160086159e7565b858281518110614d7b57614d7b61592a565b602090810291909101015160ff16901b9190911790600101614d56565b60408051608081018252600080825260208201819052918101829052606081019190915290565b6040518060800160405280614dd2614d98565b8152602001614e176040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b8152602001614e39604051806040016040528060008152602001600081525090565b8152600060209091015290565b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915290565b5080546000825590600052602060002090810190610a7491905b80821115614ea25760008155600101614e8e565b5090565b600060208284031215614eb857600080fd5b5035919050565b60008060408385031215614ed257600080fd5b50508035926020909101359150565b6001600160a01b0381168114610a7457600080fd5b60008060408385031215614f0957600080fd5b8235614f1481614ee1565b946020939093013593505050565b60008060008060808587031215614f3857600080fd5b8435614f4381614ee1565b966020860135965060408601359560600135945092505050565b600060208284031215614f6f57600080fd5b813561072281614ee1565b600080600060608486031215614f8f57600080fd5b8335614f9a81614ee1565b95602085013595506040909401359392505050565b60008151808452602080850194506020840160005b83811015614fe357815160030b87529582019590820190600101614fc4565b509495945050505050565b6020815260006107226020830184614faf565b805160030b8252602081015160030b6020830152604081015160030b6040830152606081015160030b60608301525050565b608081016105968284615001565b60006101c082019050615055828451615001565b602083015180516080840152602081015160a0840152604081015160c0840152606081015160e0840152608081015161010084015260a081015161012084015260c08101516101408401525060408301516150be61016084018280518252602090810151910152565b5060608301516130c06101a084018260030b9052565b6000806000606084860312156150e957600080fd5b83356150f481614ee1565b925060208401359150604084013561510b81614ee1565b809150509250925092565b80356001600160401b038116811461117057600080fd5b60ff81168114610a7457600080fd5b60008060006060848603121561515157600080fd5b833561515c81614ee1565b925061516a60208501615116565b9150604084013561510b8161512d565b63ffffffff81168114610a7457600080fd5b60006020828403121561519e57600080fd5b81356107228161517a565b634e487b7160e01b600052604160045260246000fd5b60405160a081016001600160401b03811182821017156151e1576151e16151a9565b60405290565b604051608081016001600160401b03811182821017156151e1576151e16151a9565b60405161012081016001600160401b03811182821017156151e1576151e16151a9565b604051601f8201601f191681016001600160401b0381118282101715615254576152546151a9565b604052919050565b60006001600160401b03821115615275576152756151a9565b5060051b60200190565b600082601f83011261529057600080fd5b813560206152a56152a08361525c565b61522c565b8083825260208201915060208460051b8701019350868411156152c757600080fd5b602086015b848110156152ec5780356152df81614ee1565b83529183019183016152cc565b509695505050505050565b600082601f83011261530857600080fd5b813560206153186152a08361525c565b8083825260208201915060208460051b87010193508684111561533a57600080fd5b602086015b848110156152ec578035835291830191830161533f565b60006020828403121561536857600080fd5b81356001600160401b038082111561537f57600080fd5b9083019060a0828603121561539357600080fd5b61539b6151bf565b82356153a681614ee1565b81526020838101359082015260408301356153c08161517a565b60408201526060830135828111156153d757600080fd5b6153e38782860161527f565b6060830152506080830135828111156153fb57600080fd5b615407878286016152f7565b60808301525095945050505050565b6040815260006154296040830185614faf565b90508260030b60208301529392505050565b8060030b8114610a7457600080fd5b600082601f83011261545b57600080fd5b8135602061546b6152a08361525c565b8083825260208201915060208460051b87010193508684111561548d57600080fd5b602086015b848110156152ec5780356154a58161543b565b8352918301918301615492565b6000806000606084860312156154c757600080fd5b83356154d281614ee1565b92506020840135915060408401356001600160401b038111156154f457600080fd5b6155008682870161544a565b9150509250925092565b8035801515811461117057600080fd5b600080600080600080600060e0888a03121561553557600080fd5b873561554081614ee1565b965061554e60208901615116565b95506040880135945060608801356155658161512d565b9350608088013561557581614ee1565b925060a0880135915061558a60c0890161550a565b905092959891949750929550565b60006020808352835180602085015260005b818110156155c6578581018301518582016040015282016155aa565b506000604082860101526040601f19601f8301168501019250505092915050565b6001600160a01b0391909116815260200190565b60006020828403121561560d57600080fd5b81356001600160401b038082111561562457600080fd5b9083019060a0828603121561563857600080fd5b6156406151bf565b823561564b81614ee1565b81526020838101359082015260408301358281111561566957600080fd5b6156758782860161544a565b6040830152506156876060840161550a565b60608201526156986080840161550a565b608082015295945050505050565b60008060008084860360e08112156156bd57600080fd5b85356156c881614ee1565b945060208601359350604086013592506080605f19820112156156ea57600080fd5b506156f36151e7565b60608601356157018161543b565b815260808601356157118161543b565b602082015260a08601356157248161543b565b604082015260c08601356157378161543b565b6060820152939692955090935050565b60008060008084860361010081121561575f57600080fd5b853561576a81614ee1565b94506020860135935060a0603f198201121561578557600080fd5b5061578e6151bf565b604086013561579c8161517a565b815260608601356157ac8161517a565b602082015260808601356157bf8161517a565b604082015260a08601356157d28161517a565b606082015260c08601356157e58161517a565b608082015291506157f860e0860161550a565b905092959194509250565b63ffffffff808251168352806020830151166020840152806040830151166040840152806060830151166060840152806080830151166080840152505050565b60a081016105968284615803565b6020808252825182820181905260009190848201906040850190845b8181101561588c57835160ff168352928401929184019160010161586d565b50909695505050505050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561059657610596615898565b8082018082111561059657610596615898565b6000602082840312156158e657600080fd5b815161072281614ee1565b634e487b7160e01b600052602160045260246000fd5b60008160030b637fffffff19810361592157615921615898565b60000392915050565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b0393841681526020810192909252909116604082015260600190565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b6001600160a01b03841681526020810183905260e081016107066040830184615803565b63ffffffff8281168282160390808211156130c0576130c0615898565b63ffffffff8181168382160190808211156130c0576130c0615898565b808202811582820484141761059657610596615898565b634e487b7160e01b600052601260045260246000fd5b600082615a2357615a236159fe565b500490565b80516111708161512d565b8051600d811061117057600080fd5b805161ffff8116811461117057600080fd5b80516111708161517a565b600060808284031215615a7157600080fd5b615a796151e7565b90508151615a868161543b565b81526020820151615a968161543b565b60208201526040820151615aa98161543b565b60408201526060820151615abc8161543b565b606082015292915050565b60006101808284031215615ada57600080fd5b615ae2615209565b615aeb83615a28565b8152615af960208401615a28565b6020820152615b0a60408401615a33565b6040820152615b1b60608401615a42565b6060820152615b2c60808401615a28565b6080820152615b3d60a08401615a54565b60a0820152615b4e60c08401615a28565b60c0820152615b5f60e08401615a28565b60e0820152610100615b7385828601615a5f565b908201529392505050565b600381810b9083900b01637fffffff8113637fffffff198212171561059657610596615898565b600082601f830112615bb657600080fd5b81516020615bc66152a08361525c565b8083825260208201915060208460051b870101935086841115615be857600080fd5b602086015b848110156152ec578051615c008161512d565b8352918301918301615bed565b60008060408385031215615c2057600080fd5b82516001600160401b0380821115615c3757600080fd5b818501915085601f830112615c4b57600080fd5b81516020615c5b6152a08361525c565b82815260059290921b84018101918181019089841115615c7a57600080fd5b948201945b83861015615ca1578551615c928161543b565b82529482019490820190615c7f565b91880151919650909350505080821115615cba57600080fd5b50615cc785828601615ba5565b9150509250929050565b600060208284031215615ce357600080fd5b81516107228161512d565b600382810b9082900b03637fffffff198112637fffffff8213171561059657610596615898565b600063ffffffff808316818103615d2e57615d2e615898565b6001019392505050565b6001600160a01b0385168152602081018490526040810183905260e08101610a956060830184615001565b6001600160a01b03868116825260208201869052610120820190615d8a6040840187615803565b84151560e0840152808416610100840152509695505050505050565b600060018201615db857615db8615898565b5060010190565b600082615dce57615dce6159fe565b500690565b8082018281126000831280158216821582161715615df357615df3615898565b505092915050565b81810360008312801583831316838312821617156130c0576130c0615898565b634e487b7160e01b600052603160045260246000fdfe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd944a3dd1d62bdf01982b7f6a998d66608c06e34399f68c67a575156ad74142bba26469706673582212203a3a95522303c1ba8f7e3a89b3a2df5ba500600257f23864cc5a03cb91b6d8b364736f6c63430008170033",
  "devdoc": {
    "errors": {
      "InvalidInitialization()": [
        {
          "details": "The contract is already initialized."
        }
      ],
      "NotInitializing()": [
        {
          "details": "The contract is not initializing."
        }
      ]
    },
    "events": {
      "Initialized(uint64)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      }
    },
    "kind": "dev",
    "methods": {
      "created()": {
        "returns": {
          "_0": "Creation timestamp"
        }
      },
      "createdBlock()": {
        "returns": {
          "_0": "Creation block number"
        }
      },
      "increaseRevision(address)": {
        "details": "Revision should be increased on each contract upgrade"
      },
      "isController(address)": {
        "details": "Return true if given address is controller"
      },
      "previousImplementation()": {
        "details": "Previous logic implementation"
      },
      "restoreLifeAndMana(address,uint256,int32[])": {
        "params": {
          "prevAttributes": "Hero attributes before reinforcement"
        }
      },
      "revision()": {
        "details": "Contract upgrade counter"
      }
    },
    "stateVariables": {
      "VERSION": {
        "details": "Should be incremented when contract changed"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "CONTROLLABLE_VERSION()": {
        "notice": "Version of the contract"
      },
      "VERSION()": {
        "notice": "Version of the contract"
      },
      "controller()": {
        "notice": "Return controller address saved in the contract slot"
      },
      "created()": {
        "notice": "Return creation timestamp"
      },
      "createdBlock()": {
        "notice": "Return creation block number"
      },
      "isGovernance(address)": {
        "notice": "Return true if given address is setup as governance in Controller"
      },
      "restoreLifeAndMana(address,uint256,int32[])": {
        "notice": "Restore life and mana during reinforcement"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}