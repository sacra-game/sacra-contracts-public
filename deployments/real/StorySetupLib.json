{
  "address": "0x18014b73713B7af35BA2c179Fcb095c512860472",
  "abi": [
    {
      "inputs": [],
      "name": "IncompatibleInputString",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "value",
          "type": "int256"
        }
      ],
      "name": "IntOutOfRange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LengthsMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "pageId",
          "type": "uint256"
        }
      ],
      "name": "PageNotRemovedError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroStoryIdRemoveStory",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroValue",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "bool[][]",
              "name": "cores",
              "type": "bool[][]"
            },
            {
              "internalType": "uint8[][]",
              "name": "ids",
              "type": "uint8[][]"
            },
            {
              "internalType": "int32[][]",
              "name": "values",
              "type": "int32[][]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.AnswerAttributeRequirementsMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "SetAnswerAttributeRequirements",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint32[]",
              "name": "randomRequirements",
              "type": "uint32[]"
            },
            {
              "internalType": "uint32[]",
              "name": "delayRequirements",
              "type": "uint32[]"
            },
            {
              "internalType": "bool[]",
              "name": "isFinalAnswer",
              "type": "bool[]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.AnswerAttributesMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "SetAnswerAttributes",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "bytes32[][]",
              "name": "dataIndexes",
              "type": "bytes32[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "mandatory",
              "type": "bool[][]"
            },
            {
              "internalType": "uint64[][]",
              "name": "dataValuesMin",
              "type": "uint64[][]"
            },
            {
              "internalType": "uint64[][]",
              "name": "dataValuesMax",
              "type": "uint64[][]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.AnswerCustomDataMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "SetAnswerGlobalCustomDataRequirementMeta",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "bytes32[][]",
              "name": "dataIndexes",
              "type": "bytes32[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "mandatory",
              "type": "bool[][]"
            },
            {
              "internalType": "uint64[][]",
              "name": "dataValuesMin",
              "type": "uint64[][]"
            },
            {
              "internalType": "uint64[][]",
              "name": "dataValuesMax",
              "type": "uint64[][]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.AnswerCustomDataMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "SetAnswerHeroCustomDataRequirementMeta",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "address[][]",
              "name": "requireItems",
              "type": "address[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "requireItemBurn",
              "type": "bool[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "requireItemEquipped",
              "type": "bool[][]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.AnswerItemRequirementsMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "SetAnswerItemRequirements",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "answerResultIds",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[][]",
              "name": "answerNextPageIds",
              "type": "uint16[][]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.AnswerNextPageMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "SetAnswerNextPageMeta",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "address[][]",
              "name": "requireToken",
              "type": "address[][]"
            },
            {
              "internalType": "uint88[][]",
              "name": "requireAmount",
              "type": "uint88[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "requireTransfer",
              "type": "bool[][]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.AnswerTokenRequirementsMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "SetAnswerTokenRequirementsMeta",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint16[]",
          "name": "answerPageIds",
          "type": "uint16[]"
        },
        {
          "indexed": false,
          "internalType": "uint8[]",
          "name": "answerHeroClasses",
          "type": "uint8[]"
        },
        {
          "indexed": false,
          "internalType": "uint16[]",
          "name": "answerIds",
          "type": "uint16[]"
        }
      ],
      "name": "SetAnswersMeta",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[][]",
              "name": "slots",
              "type": "uint8[][]"
            },
            {
              "internalType": "uint64[][]",
              "name": "chances",
              "type": "uint64[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "isStopIfBurnt",
              "type": "bool[][]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.AnswerBurnRandomItemMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "SetBurnItemsMeta",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "bytes32[][]",
              "name": "dataIndexes",
              "type": "bytes32[][]"
            },
            {
              "internalType": "int16[][]",
              "name": "dataValues",
              "type": "int16[][]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.AnswerCustomDataResultMeta",
          "name": "meta",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "enum IStoryController.CustomDataResult",
          "name": "_type",
          "type": "uint8"
        }
      ],
      "name": "SetCustomDataResult",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[][]",
              "name": "attributeIds",
              "type": "uint8[][]"
            },
            {
              "internalType": "int32[][]",
              "name": "attributeValues",
              "type": "int32[][]"
            },
            {
              "internalType": "uint32[]",
              "name": "experience",
              "type": "uint32[]"
            },
            {
              "internalType": "int32[]",
              "name": "heal",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "manaRegen",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "lifeChancesRecovered",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "damage",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "manaConsumed",
              "type": "int32[]"
            },
            {
              "internalType": "address[][]",
              "name": "mintItems",
              "type": "address[][]"
            },
            {
              "internalType": "uint32[][]",
              "name": "mintItemsChances",
              "type": "uint32[][]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.AnswerResultMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "SetFailInfo",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "nextObjPageIds",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "nextObjHeroClasses",
              "type": "uint8[]"
            },
            {
              "internalType": "uint32[][]",
              "name": "nextObjIds",
              "type": "uint32[][]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.NextObjRewriteMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "SetNextObjRewriteMeta",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[][]",
              "name": "attributeIds",
              "type": "uint8[][]"
            },
            {
              "internalType": "int32[][]",
              "name": "attributeValues",
              "type": "int32[][]"
            },
            {
              "internalType": "uint32[]",
              "name": "experience",
              "type": "uint32[]"
            },
            {
              "internalType": "int32[]",
              "name": "heal",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "manaRegen",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "lifeChancesRecovered",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "damage",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "manaConsumed",
              "type": "int32[]"
            },
            {
              "internalType": "address[][]",
              "name": "mintItems",
              "type": "address[][]"
            },
            {
              "internalType": "uint32[][]",
              "name": "mintItemsChances",
              "type": "uint32[][]"
            }
          ],
          "indexed": false,
          "internalType": "struct IStoryController.AnswerResultMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "SetSuccessInfo",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "requiredCustomDataIndex",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "requiredCustomDataMinValue",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "requiredCustomDataMaxValue",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "requiredCustomDataIsHero",
          "type": "bool"
        }
      ],
      "name": "StoryCustomDataRequirements",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        }
      ],
      "name": "StoryFinalized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        }
      ],
      "name": "StoryRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "storyId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "requiredLevel",
          "type": "uint256"
        }
      ],
      "name": "StoryRequiredLevel",
      "type": "event"
    }
  ],
  "transactionHash": "0x74b3681c1181a6527fc8d57a103a13b9ab47e813295e1471f9247747a0c85285",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0x18014b73713B7af35BA2c179Fcb095c512860472",
    "transactionIndex": 1,
    "gasUsed": "7578357",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x69960c0553e816c5374ac14fdc8f8333dd755569842f3f620bd10002697a56c2",
    "transactionHash": "0x74b3681c1181a6527fc8d57a103a13b9ab47e813295e1471f9247747a0c85285",
    "logs": [],
    "blockNumber": 1201266,
    "cumulativeGasUsed": "7578357",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 20,
  "solcInputHash": "1c5f5fd0b61f54e5cdb86891b80cc3ef",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"IncompatibleInputString\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"IntOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthsMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pageId\",\"type\":\"uint256\"}],\"name\":\"PageNotRemovedError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroStoryIdRemoveStory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroValue\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bool[][]\",\"name\":\"cores\",\"type\":\"bool[][]\"},{\"internalType\":\"uint8[][]\",\"name\":\"ids\",\"type\":\"uint8[][]\"},{\"internalType\":\"int32[][]\",\"name\":\"values\",\"type\":\"int32[][]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.AnswerAttributeRequirementsMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"SetAnswerAttributeRequirements\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint32[]\",\"name\":\"randomRequirements\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"delayRequirements\",\"type\":\"uint32[]\"},{\"internalType\":\"bool[]\",\"name\":\"isFinalAnswer\",\"type\":\"bool[]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.AnswerAttributesMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"SetAnswerAttributes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"mandatory\",\"type\":\"bool[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMin\",\"type\":\"uint64[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMax\",\"type\":\"uint64[][]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.AnswerCustomDataMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"SetAnswerGlobalCustomDataRequirementMeta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"mandatory\",\"type\":\"bool[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMin\",\"type\":\"uint64[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMax\",\"type\":\"uint64[][]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.AnswerCustomDataMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"SetAnswerHeroCustomDataRequirementMeta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"address[][]\",\"name\":\"requireItems\",\"type\":\"address[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"requireItemBurn\",\"type\":\"bool[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"requireItemEquipped\",\"type\":\"bool[][]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.AnswerItemRequirementsMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"SetAnswerItemRequirements\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"answerResultIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[][]\",\"name\":\"answerNextPageIds\",\"type\":\"uint16[][]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.AnswerNextPageMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"SetAnswerNextPageMeta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"address[][]\",\"name\":\"requireToken\",\"type\":\"address[][]\"},{\"internalType\":\"uint88[][]\",\"name\":\"requireAmount\",\"type\":\"uint88[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"requireTransfer\",\"type\":\"bool[][]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.AnswerTokenRequirementsMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"SetAnswerTokenRequirementsMeta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16[]\",\"name\":\"answerPageIds\",\"type\":\"uint16[]\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"answerHeroClasses\",\"type\":\"uint8[]\"},{\"indexed\":false,\"internalType\":\"uint16[]\",\"name\":\"answerIds\",\"type\":\"uint16[]\"}],\"name\":\"SetAnswersMeta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[][]\",\"name\":\"slots\",\"type\":\"uint8[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"chances\",\"type\":\"uint64[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"isStopIfBurnt\",\"type\":\"bool[][]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.AnswerBurnRandomItemMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"SetBurnItemsMeta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"int16[][]\",\"name\":\"dataValues\",\"type\":\"int16[][]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.AnswerCustomDataResultMeta\",\"name\":\"meta\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"enum IStoryController.CustomDataResult\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"SetCustomDataResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[][]\",\"name\":\"attributeIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"int32[][]\",\"name\":\"attributeValues\",\"type\":\"int32[][]\"},{\"internalType\":\"uint32[]\",\"name\":\"experience\",\"type\":\"uint32[]\"},{\"internalType\":\"int32[]\",\"name\":\"heal\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaRegen\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"lifeChancesRecovered\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"damage\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaConsumed\",\"type\":\"int32[]\"},{\"internalType\":\"address[][]\",\"name\":\"mintItems\",\"type\":\"address[][]\"},{\"internalType\":\"uint32[][]\",\"name\":\"mintItemsChances\",\"type\":\"uint32[][]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.AnswerResultMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"SetFailInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"nextObjPageIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"nextObjHeroClasses\",\"type\":\"uint8[]\"},{\"internalType\":\"uint32[][]\",\"name\":\"nextObjIds\",\"type\":\"uint32[][]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.NextObjRewriteMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"SetNextObjRewriteMeta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[][]\",\"name\":\"attributeIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"int32[][]\",\"name\":\"attributeValues\",\"type\":\"int32[][]\"},{\"internalType\":\"uint32[]\",\"name\":\"experience\",\"type\":\"uint32[]\"},{\"internalType\":\"int32[]\",\"name\":\"heal\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaRegen\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"lifeChancesRecovered\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"damage\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaConsumed\",\"type\":\"int32[]\"},{\"internalType\":\"address[][]\",\"name\":\"mintItems\",\"type\":\"address[][]\"},{\"internalType\":\"uint32[][]\",\"name\":\"mintItemsChances\",\"type\":\"uint32[][]\"}],\"indexed\":false,\"internalType\":\"struct IStoryController.AnswerResultMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"SetSuccessInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requiredCustomDataIndex\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredCustomDataMinValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredCustomDataMaxValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"requiredCustomDataIsHero\",\"type\":\"bool\"}],\"name\":\"StoryCustomDataRequirements\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"}],\"name\":\"StoryFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"}],\"name\":\"StoryRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"storyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredLevel\",\"type\":\"uint256\"}],\"name\":\"StoryRequiredLevel\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"setBurnItemsMeta(IStoryController.MainState storage,uint16,IStoryController.AnswerBurnRandomItemMeta)\":{\"details\":\"Since SIP-003 the burning is replaced by breaking\"}},\"version\":1},\"userdoc\":{\"errors\":{\"IncompatibleInputString()\":[{\"notice\":\"packCustomDataChange requires an input string with two zero bytes at the beginning         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000 This error happens if these bytes are not zero\"}]},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lib/StorySetupLib.sol\":\"StorySetupLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":50},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IAppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @notice All errors of the app\\ninterface IAppErrors {\\n\\n  //region ERC20Errors\\n  /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n  error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n  /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n  error ERC20InvalidSender(address sender);\\n\\n  /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n  error ERC20InvalidReceiver(address receiver);\\n\\n  /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n  error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n  /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n  error ERC20InvalidApprover(address approver);\\n\\n  /**\\n   * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n  error ERC20InvalidSpender(address spender);\\n\\n  //endregion ERC20Errors\\n\\n  //region ERC721Errors\\n\\n  /**\\n  * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n  error ERC721InvalidOwner(address owner);\\n\\n  /**\\n   * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n  error ERC721NonexistentToken(uint256 tokenId);\\n\\n  /**\\n   * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n  error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n  /**\\n   * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n  error ERC721InvalidSender(address sender);\\n\\n  /**\\n   * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n  error ERC721InvalidReceiver(address receiver);\\n\\n  /**\\n   * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n  error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n  /**\\n   * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n  error ERC721InvalidApprover(address approver);\\n\\n  /**\\n   * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n  error ERC721InvalidOperator(address operator);\\n\\n  //endregion ERC721Errors\\n\\n  error ZeroAddress();\\n  error ZeroValueNotAllowed();\\n  error ZeroToken();\\n  error LengthsMismatch();\\n  error NotEnoughBalance();\\n  error NotEnoughAllowance();\\n  error EmptyNameNotAllowed();\\n  error NotInitialized();\\n  error AlreadyInitialized();\\n  error ReentrancyGuardReentrantCall();\\n  error TooLongString();\\n  error AlreadyDeployed(address deployed);\\n\\n  //region Restrictions\\n  error ErrorNotDeployer(address sender);\\n  error ErrorNotGoc();\\n  error NotGovernance(address sender);\\n  error ErrorOnlyEoa();\\n  error NotEOA(address sender);\\n  error ErrorForbidden(address sender);\\n  error AdminOnly();\\n  error ErrorNotItemController(address sender);\\n  error ErrorNotHeroController(address sender);\\n  error ErrorNotDungeonFactory(address sender);\\n  error ErrorNotObjectController(address sender);\\n  error ErrorNotStoryController();\\n  error ErrorNotAllowedSender();\\n  error MintNotAllowed();\\n  //endregion Restrictions\\n\\n  //region PackingLib\\n  error TooHighValue(uint value);\\n  error IntValueOutOfRange(int value);\\n  error OutOfBounds(uint index, uint length);\\n  error UnexpectedValue(uint expected, uint actual);\\n  error WrongValue(uint newValue, uint actual);\\n  error IntOutOfRange(int value);\\n  error ZeroValue();\\n  /// @notice packCustomDataChange requires an input string with two zero bytes at the beginning\\n  ///         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// This error happens if these bytes are not zero\\n  error IncompatibleInputString();\\n  error IncorrectOtherItemTypeKind(uint8 kind);\\n  //endregion PackingLib\\n\\n  //region Hero\\n  error ErrorHeroIsNotRegistered(address heroToken);\\n  error ErrorHeroIsDead(address heroToken, uint heroTokenId);\\n  error ErrorHeroNotInDungeon();\\n  error HeroInDungeon();\\n  error ErrorNotOwner(address token, uint tokenId);\\n  error Staked(address heroToken, uint heroId);\\n  error NameTaken();\\n  error TooBigName();\\n  error WrongSymbolsInTheName();\\n  error NoPayToken(address token, uint payTokenAmount);\\n  error AlreadyHaveReinforcement();\\n  /// @notice SIP-001 - Reinforcement requires 3 skills\\n  error ErrorReinforcementRequiresThreeSkills();\\n  error WrongTier(uint tier);\\n  error NotEnoughNgLevel(uint8 ngLevel);\\n  error NgpNotActive(address hero);\\n  error RebornNotAllowed();\\n  error AlreadyPrePaidHero();\\n  //endregion Hero\\n\\n  //region Dungeon\\n  error ErrorDungeonIsFreeAlready();\\n  error ErrorNoEligibleDungeons();\\n  error ErrorDungeonBusy();\\n  error ErrorNoDungeonsForBiome(uint8 heroBiome);\\n  error ErrorDungeonCompleted();\\n  error ErrorAlreadyInDungeon();\\n  error NotEnoughTokens(uint balance, uint expectedBalance);\\n  error DungeonAlreadySpecific(uint16 dungNum);\\n  error DungeonAlreadySpecific2(uint16 dungNum);\\n  error WrongSpecificDungeon();\\n  //endregion Dungeon\\n\\n  //region Items\\n  error ErrorItemNotEligibleForTheSlot(uint itemType, uint8 itemSlot);\\n  error ErrorItemSlotBusyHand(uint8 slot);\\n  error ErrorItemSlotBusy();\\n  error ErrorItemNotInSlot();\\n  error ErrorConsumableItemIsUsed(address item);\\n  error ErrorCannotRemoveItemFromMap();\\n  error ErrorCannotRemoveDataFromMap();\\n  error EquippedItemsExist();\\n  error ItemEquipped(address item, uint itemId);\\n  error ZeroItemMetaType();\\n  error NotZeroOtherItemMetaType();\\n  error ZeroLevel();\\n  error ItemTypeChanged();\\n  error ItemMetaTypeChanged();\\n  error UnknownItem(address item);\\n  error ErrorEquipForbidden();\\n  error EquipForbiddenInDungeon();\\n  error TakeOffForbiddenInDungeon();\\n  error Consumable(address item);\\n  error NotConsumable(address item);\\n  error Broken(address item);\\n  error ZeroLife();\\n  error RequirementsToItemAttributes();\\n  error NotEquipped(address item);\\n  error ZeroDurability();\\n  error ZeroAugmentation();\\n  error TooHighAgLevel(uint8 augmentationLevel);\\n  error UseForbiddenZeroPayToken();\\n  error IncorrectMinMaxAttributeRange(int32 min, int32 max);\\n  error SameIdsNotAllowed();\\n  error ZeroFragility();\\n  error OtherTypeItemNotRepairable();\\n  error NotOther();\\n  error DoubleItemUsageForbidden(uint itemIndex, address[] items);\\n  error ItemAlreadyUsedInSlot(address item, uint8 equippedSlot);\\n  error WrongWayToRegisterItem();\\n  error UnionItemNotFound(address item);\\n  error WrongListUnionItemTokens(address item, uint countTokens, uint requiredCountTokens);\\n  error UnknownUnionConfig(uint unionConfigId);\\n  error UserHasNoKeyPass(address user, address keyPassItem);\\n  error MaxValue(uint value);\\n  error UnexpectedOtherItem(address item);\\n  error NotExist();\\n  //endregion Items\\n\\n  //region Stages\\n  error ErrorWrongStage(uint stage);\\n  error ErrorNotStages();\\n  //endregion Stages\\n\\n  //region Level\\n  error ErrorWrongLevel(uint heroLevel);\\n  error ErrorLevelTooLow(uint heroLevel);\\n  error ErrorHeroLevelStartFrom1();\\n  error ErrorWrongLevelUpSum();\\n  error ErrorMaxLevel();\\n  //endregion Level\\n\\n  //region Treasure\\n  error ErrorNotValidTreasureToken(address treasureToken);\\n  //endregion Treasure\\n\\n  //region State\\n  error ErrorPaused();\\n  error ErrorNotReady();\\n  error ErrorNotObject1();\\n  error ErrorNotObject2();\\n  error ErrorNotCompleted();\\n  //endregion State\\n\\n  //region Biome\\n  error ErrorNotBiome();\\n  error ErrorIncorrectBiome(uint biome);\\n  error TooHighBiome(uint biome);\\n  //endregion Biome\\n\\n  //region Misc\\n  error ErrorWrongMultiplier(uint multiplier);\\n  error ErrorNotEnoughMana(uint32 mana, uint requiredMana);\\n  error ErrorExperienceMustNotDecrease();\\n  error ErrorNotEnoughExperience();\\n  error ErrorNotChances();\\n  error ErrorNotEligible(address heroToken, uint16 dungNum);\\n  error ErrorZeroKarmaNotAllowed();\\n  //endregion Misc\\n\\n  //region GOC\\n  error GenObjectIdBiomeOverflow(uint8 biome);\\n  error GenObjectIdSubTypeOverflow(uint subType);\\n  error GenObjectIdIdOverflow(uint id);\\n  error UnknownObjectTypeGoc1(uint8 objectType);\\n  error UnknownObjectTypeGoc2(uint8 objectType);\\n  error UnknownObjectTypeGocLib1(uint8 objectType);\\n  error UnknownObjectTypeGocLib2(uint8 objectType);\\n  error UnknownObjectTypeForSubtype(uint8 objectSubType);\\n  error FightDelay();\\n  error ZeroChance();\\n  error TooHighChance(uint32 chance);\\n  error TooHighRandom(uint random);\\n  error EmptyObjects();\\n  error ObjectNotFound();\\n  error WrongGetObjectTypeInput();\\n  error WrongChances(uint32 chances, uint32 maxChances);\\n  //endregion GOC\\n\\n  //region Story\\n  error PageNotRemovedError(uint pageId);\\n  error NotItem1();\\n  error NotItem2();\\n  error NotRandom(uint32 random);\\n  error NotHeroData();\\n  error NotGlobalData();\\n  error ZeroStoryIdRemoveStory();\\n  error ZeroStoryIdStoryAction();\\n  error ZeroStoryIdAction();\\n  error NotEnoughAmount(uint balance, uint requiredAmount);\\n  error NotAnswer();\\n  error AnswerStoryIdMismatch(uint16 storyId, uint16 storyIdFromAnswerHash);\\n  error AnswerPageIdMismatch(uint16 pageId, uint16 pageIdFromAnswerHash);\\n  //endregion Story\\n\\n  //region FightLib\\n  error NotMagic();\\n  error NotAType(uint atype);\\n  //endregion FightLib\\n\\n  //region MonsterLib\\n  error NotYourDebuffItem();\\n  error UnknownAttackType(uint attackType);\\n  error NotYourAttackItem();\\n  /// @notice The skill item cannot be used because it doesn't belong either to the hero or to the hero's helper\\n  error NotYourBuffItem();\\n  //endregion MonsterLib\\n\\n  //region GameToken\\n  error ApproveToZeroAddress();\\n  error MintToZeroAddress();\\n  error TransferToZeroAddress();\\n  error TransferAmountExceedsBalance(uint balance, uint value);\\n  error InsufficientAllowance();\\n  error BurnAmountExceedsBalance();\\n  error NotMinter(address sender);\\n  //endregion GameToken\\n\\n  //region NFT\\n  error TokenTransferNotAllowed();\\n  error IdOverflow(uint id);\\n  error NotExistToken(uint tokenId);\\n  error EquippedItemIsNotAllowedToTransfer(uint tokenId);\\n  //endregion NFT\\n\\n  //region CalcLib\\n  error TooLowX(uint x);\\n  //endregion CalcLib\\n\\n  //region Controller\\n  error NotFutureGovernance(address sender);\\n  //endregion Controller\\n\\n  //region Oracle\\n  error OracleWrongInput();\\n  //endregion Oracle\\n\\n  //region ReinforcementController\\n  error AlreadyStaked();\\n  error MaxFee(uint8 fee);\\n  error MinFee(uint8 fee);\\n  error StakeHeroNotStats();\\n  error NotStaked();\\n  error NoStakedHeroes();\\n  error GuildHelperNotAvailable(uint guildId, address helper, uint helperId);\\n  error HelperNotAvailableInGivenBiome();\\n  //endregion ReinforcementController\\n\\n  //region SponsoredHero\\n  error InvalidHeroClass();\\n  error ZeroAmount();\\n  error InvalidProof();\\n  error NoHeroesAvailable();\\n  error AlreadyRegistered();\\n  //endregion SponsoredHero\\n\\n  //region SacraRelay\\n  error SacraRelayNotOwner();\\n  error SacraRelayNotDelegator();\\n  error SacraRelayNotOperator();\\n  error SacraRelayInvalidChainId(uint callChainId, uint blockChainId);\\n  error SacraRelayInvalidNonce(uint callNonce, uint txNonce);\\n  error SacraRelayDeadline();\\n  error SacraRelayDelegationExpired();\\n  error SacraRelayNotAllowed();\\n  error SacraRelayInvalidSignature();\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error by selector, see tests\\n  error SacraRelayNoErrorSelector(bytes4 selector, string tracingInfo);\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error manually from {errorBytes} as following:\\n  /// if (keccak256(abi.encodeWithSignature(\\\"MyError()\\\")) == keccak256(errorBytes)) { ... }\\n  error SacraRelayUnexpectedReturnData(bytes errorBytes, string tracingInfo);\\n  error SacraRelayCallToNotContract(address notContract, string tracingInfo);\\n  //endregion SacraRelay\\n\\n  //region Misc\\n  error UnknownHeroClass(uint heroClass);\\n  error AbsDiff(int32 a, int32 b);\\n  //region Misc\\n\\n  //region ------------------------ UserController\\n  error NoAvailableLootBox(address msgSender, uint lootBoxKind);\\n  error FameHallHeroAlreadyRegistered(uint8 openedNgLevel);\\n\\n  //endregion ------------------------ UserController\\n\\n  //region ------------------------ Guilds\\n  error AlreadyGuildMember();\\n  error NotGuildMember();\\n  error WrongGuild();\\n  error GuildActionForbidden(uint right);\\n  error GuildHasMaxSize(uint guildSize);\\n  error GuildHasMaxLevel(uint level);\\n  error TooLongUrl();\\n  error TooLongDescription();\\n  error CannotRemoveGuildOwnerFromNotEmptyGuild();\\n  error GuildControllerOnly();\\n  error GuildAlreadyHasShelter();\\n  error ShelterIsBusy();\\n  error ShelterIsNotRegistered();\\n  error ShelterIsNotOwnedByTheGuild();\\n  error ShelterIsInUse();\\n  error GuildHasNoShelter();\\n  error ShelterBidIsNotAllowedToBeUsed();\\n  error ShelterHasHeroesInside();\\n  error SecondGuildAdminIsNotAllowed();\\n  error NotEnoughGuildBankBalance(uint guildId);\\n\\n  error GuildReinforcementCooldownPeriod();\\n  error NoStakedGuildHeroes();\\n  error NotStakedInGuild();\\n  error ShelterHasNotEnoughLevelForReinforcement();\\n  error NotBusyGuildHelper();\\n\\n  error GuildRequestNotActive();\\n  error GuildRequestNotAvailable();\\n  error NotAdminCannotAddMemberWithNotZeroRights();\\n  //endregion ------------------------ Guilds\\n\\n  //region ------------------------ Shelters\\n  error ErrorNotShelterController();\\n  error ErrorNotGuildController();\\n  error ShelterHasNotItem(uint shelterId, address item);\\n  error MaxNumberItemsSoldToday(uint numSoldItems, uint limit);\\n  error GuildHasNotEnoughPvpPoints(uint64 pointsAvailable, uint pointRequired);\\n  error FreeShelterItemsAreNotAllowed(uint shelterId, address item);\\n  error TooLowShelterLevel(uint8 shelterLevel, uint8 allowedShelterLevel);\\n  error NotEnoughPvpPointsCapacity(address user, uint usedPoints, uint pricePvpPoints, uint64 capactiy);\\n  error IncorrectShelterLevel(uint8 shelterLevel);\\n  //endregion ------------------------ Shelters\\n\\n  //region ------------------------ Auction\\n  error WrongAuctionPosition();\\n  error AuctionPositionClosed();\\n  error AuctionBidOpened(uint positionId);\\n  error TooLowAmountToBid();\\n  error AuctionEnded();\\n  error TooLowAmountForNewBid();\\n  error AuctionSellerOnly();\\n  error AuctionBuyerOnly();\\n  error AuctionBidNotFound();\\n  error AuctionBidClosed();\\n  error OnlyShelterAuction();\\n  error CannotCloseLastBid();\\n  error AuctionNotEnded();\\n  error NotShelterAuction();\\n  error AuctionPositionOpened(uint positionId);\\n  error AuctionSellerCannotBid();\\n  error CannotApplyNotLastBid();\\n  error AuctionGuildWithShelterCannotBid();\\n  //endregion ------------------------ Auction\\n\\n  //region ------------------------ Pawnshop\\n  error AuctionPositionNotSupported(uint positionId);\\n  error PositionNotSupported(uint positionId);\\n  error NotNftPositionNotSupported(uint positionId);\\n  error CallFailed(bytes callResultData);\\n\\n  error PawnShopZeroOwner();\\n  error PawnShopZeroFeeRecipient();\\n  error PawnShopNotOwner();\\n  error PawnShopAlreadyAnnounced();\\n  error PawnShopTimeLock();\\n  error PawnShopWrongAddressValue();\\n  error PawnShopWrongUintValue();\\n  error PawnShopZeroAddress();\\n  error PawnShopTooHighValue();\\n  error PawnShopZeroAToken();\\n  error PawnShopZeroCToken();\\n  error PawnShopWrongAmounts();\\n  error PawnShopPosFeeForInstantDealForbidden();\\n  error PawnShopPosFeeAbsurdlyHigh();\\n  error PawnShopIncorrect();\\n  error PawnShopWrongId();\\n  error PawnShopNotBorrower();\\n  error PawnShopPositionClosed();\\n  error PawnShopPositionExecuted();\\n  error PawnShopWrongBidAmount();\\n  error PawnShopTooLowBid();\\n  error PawnShopNewBidTooLow();\\n  error PawnShopBidAlreadyExists();\\n  error PawnShopAuctionEnded();\\n  error PawnShopNotLender();\\n  error PawnShopTooEarlyToClaim();\\n  error PawnShopPositionNotExecuted();\\n  error PawnShopAlreadyClaimed();\\n  error PawnShopAuctionNotEnded();\\n  error PawnShopBidClosed();\\n  error PawnShopNoBids();\\n  error PawnShopAuctionBidNotFound();\\n  error PawnShopWrongBid();\\n  error PawnShopBidNotFound();\\n\\n  //endregion ------------------------ Pawnshop\\n}\\n\\n\",\"keccak256\":\"0x99ca976a36aded6991d48e7c8eed1585784957183cfd60003f86b37050178875\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IApplicationEvents.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IDungeonFactory.sol\\\";\\nimport \\\"./IStoryController.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\n\\n/// @notice All events of the app\\ninterface IApplicationEvents {\\n\\n  //region ------------------ StatController\\n  event HeroItemSlotChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint itemType,\\n    uint itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip,\\n    address caller\\n  );\\n  event CurrentStatsChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats change,\\n    bool increase,\\n    address caller\\n  );\\n  event BonusAttributesChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    bool add,\\n    bool temporally,\\n    address caller\\n  );\\n  event TemporallyAttributesCleared(address heroToken, uint heroTokenId, address caller);\\n  event NewHeroInited(address heroToken, uint heroTokenId, IStatController.ChangeableStats stats);\\n  event LevelUp(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes change\\n  );\\n  event ConsumableUsed(address heroToken, uint heroTokenId, address item);\\n  event RemoveConsumableUsage(address heroToken, uint heroTokenId, address item);\\n  event HeroCustomDataChanged(address token, uint tokenId, bytes32 index, uint value);\\n  event HeroCustomDataChangedNg(address token, uint tokenId, bytes32 index, uint value, uint8 ngLevel);\\n  event HeroCustomDataCleared(address token, uint tokenId);\\n  event GlobalCustomDataChanged(bytes32 index, uint value);\\n  //endregion ------------------ StatController\\n\\n  //region ------------------ DungeonFactoryController\\n  event DungeonLaunched(\\n    uint16 dungeonLogicNum,\\n    uint64 dungeonId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken,\\n    uint treasuryAmount\\n  );\\n\\n  event BossCompleted(uint32 objectId, uint biome, address hero, uint heroId);\\n  event FreeDungeonAdded(uint8 biome, uint64 dungeonId);\\n\\n  event ObjectOpened(uint64 dungId, address hero, uint id, uint32 objId, uint iteration, uint currentStage);\\n  event Clear(uint64 dungId);\\n\\n  event DungeonLogicRegistered(uint16 dungLogicId, IDungeonFactory.DungeonGenerateInfo info);\\n  event DungeonLogicRemoved(uint16 dungLogicId);\\n  event DungeonSpecificLogicRegistered(uint16 dungLogicId, uint biome, uint heroCls);\\n  event DungeonSpecificLogicRemoved(uint16 dungLogicId, uint heroLvl, uint heroCls);\\n  event DungeonRegistered(uint16 dungLogicId, uint64 dungeonId);\\n  event DungeonRemoved(uint16 dungLogicId, uint64 dungeonId);\\n  event MinLevelForTreasuryChanged(address token, uint level);\\n\\n  event ObjectAction(\\n    uint64 dungId,\\n    IGOC.ActionResult result,\\n    uint currentStage,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint newStage\\n  );\\n  /// @notice On add the item to the dungeon\\n  event AddTreasuryItem(uint64 dungId, address itemAdr, uint itemId);\\n  event AddTreasuryToken(uint64 dungId, address token, uint amount);\\n  event ClaimToken(uint64 dungId, address token, uint amount);\\n  event ClaimItem(uint64 dungId, address token, uint id);\\n\\n  event Entered(uint64 dungId, address hero, uint id);\\n  event DungeonCompleted(uint16 dungLogicNum, uint64 dungId, address hero, uint heroId);\\n  event Exit(uint64 dungId, bool claim);\\n  event ExitForcibly(uint64 dungId, address hero, uint heroId);\\n  event FreeDungeonRemoved(uint8 biome, uint64 dungeonId);\\n  event HeroCurrentDungeonChanged(address hero, uint heroId, uint64 dungeonId);\\n  //endregion ------------------ DungeonFactoryController\\n\\n  //region ------------------ GameObjectController\\n  event EventRegistered(uint32 objectId, IGOC.EventRegInfo eventRegInfo);\\n  event StoryRegistered(uint32 objectId, uint16 storyId);\\n  event MonsterRegistered(uint32 objectId, IGOC.MonsterGenInfo monsterGenInfo);\\n  event ObjectRemoved(uint32 objectId);\\n  event ObjectResultEvent(\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    IGOC.ObjectType objectType,\\n    address hero,\\n    uint heroId,\\n    uint8 stageId,\\n    uint iteration,\\n    bytes data,\\n    IGOC.ActionResult result,\\n    uint salt\\n  );\\n  //endregion ------------------ GameObjectController\\n\\n  //region ------------------ StoryController\\n  event SetBurnItemsMeta(uint storyId, IStoryController.AnswerBurnRandomItemMeta meta);\\n  event SetNextObjRewriteMeta(uint storyId, IStoryController.NextObjRewriteMeta meta);\\n  event SetAnswersMeta(uint storyId, uint16[] answerPageIds, uint8[] answerHeroClasses, uint16[] answerIds);\\n  event SetAnswerNextPageMeta(uint storyId, IStoryController.AnswerNextPageMeta meta);\\n  event SetAnswerAttributeRequirements(uint storyId, IStoryController.AnswerAttributeRequirementsMeta meta);\\n  event SetAnswerItemRequirements(uint storyId, IStoryController.AnswerItemRequirementsMeta meta);\\n  event SetAnswerTokenRequirementsMeta(uint storyId, IStoryController.AnswerTokenRequirementsMeta meta);\\n  event SetAnswerAttributes(uint storyId, IStoryController.AnswerAttributesMeta meta);\\n  event SetAnswerHeroCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetAnswerGlobalCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetSuccessInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetFailInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetCustomDataResult(uint storyId, IStoryController.AnswerCustomDataResultMeta meta, IStoryController.CustomDataResult _type);\\n  event StoryCustomDataRequirements(uint storyId, bytes32 requiredCustomDataIndex, uint requiredCustomDataMinValue, uint requiredCustomDataMaxValue, bool requiredCustomDataIsHero);\\n  event StoryRequiredLevel(uint storyId, uint requiredLevel);\\n  event StoryFinalized(uint32 objectId, uint storyId);\\n  event StoryRemoved(uint32 objectId, uint storyId);\\n\\n  event ItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  /// @notice Durability of the item was reduced to 0\\n  event ItemBroken(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n\\n  event NotEquippedItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event StoryChangeAttributes(\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    uint stageId,\\n    uint iteration,\\n    int32[] attributes\\n  );\\n  //endregion ------------------ StoryController\\n\\n  //region ------------------------ HeroController\\n  event HeroRegistered(address hero, uint8 heroClass, address payToken, uint payAmount);\\n  event HeroCreatedNgp(address hero, uint heroId, string name, address owner, string refCode, uint8 tier, uint8 ngLevel);\\n  event BiomeChanged(address hero, uint heroId, uint8 biome);\\n  event LevelUp(address hero, uint heroId, address owner, IStatController.CoreAttributes change);\\n  event ReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event GuildReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event OtherItemGuildReinforcement(address item, uint itemId, address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event ReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event GuildReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event Killed(address hero, uint heroId, address killer, bytes32[] dropItems, uint dropTokenAmount);\\n  event Reborn(address hero, uint heroId, uint8 newNgLevel);\\n  event BossKilled(address account, address hero, uint heroId, uint8 biome, uint8 newNgLevel, bool reborn, uint rewardAmount);\\n  event TierSetup(uint8 tier, address hero, uint72 payAmount, uint8[] slots, address[][] items);\\n  //endregion ------------------------ HeroController\\n\\n  //region ------------------------ FightLib\\n  event FightResultProcessed(\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    IFightCalculator.FightCall callData,\\n    uint iteration\\n  );\\n  //endregion ------------------------ FightLib\\n\\n  //region ------------------------ Oracle\\n  event Random(uint number, uint max);\\n  //endregion ------------------------ Oracle\\n\\n  //region ------------------------ Controller\\n  event OfferGovernance(address newGov);\\n  event GovernanceAccepted(address gov);\\n  event StatControllerChanged(address value);\\n  event StoryControllerChanged(address value);\\n  event GameObjectControllerChanged(address value);\\n  event ReinforcementControllerChanged(address value);\\n  event OracleChanged(address value);\\n  event TreasuryChanged(address value);\\n  event ItemControllerChanged(address value);\\n  event HeroControllerChanged(address value);\\n  event GameTokenChanged(address value);\\n  event DungeonFactoryChanged(address value);\\n  event ProxyUpdated(address proxy, address logic);\\n  event Claimed(address token, uint amount);\\n  event TokenStatusChanged(address token, bool status);\\n  event UserControllerChanged(address value);\\n  event GuildControllerChanged(address value);\\n  event GameTokenPriceChanged(uint value);\\n  event RewardsPoolChanged(address value);\\n  event Process(address token, uint amount, address from, uint toBurn, uint toTreasury, uint toGov);\\n  //endregion ------------------------ Controller\\n\\n\\n  //region ------------------------ ReinforcementController\\n  event HeroStaked(address heroToken, uint heroId, uint biome, uint score);\\n  event HeroStakedV2(address heroToken, uint heroId, uint biome, uint rewardAmount);\\n  event HeroWithdraw(address heroToken, uint heroId);\\n  event HeroAsk(address heroToken, uint heroId);\\n  event HeroAskV2(address heroToken, uint heroId, uint hitsLast24h, uint fixedFee, uint helperRewardAmount);\\n  event TokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint totalAmount);\\n  event GuildTokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint guildId);\\n  event NftRewardRegistered(address heroToken, uint heroId, address token, uint id);\\n  event GuildNftRewardRegistered(address heroToken, uint heroId, address token, uint id, uint guildId);\\n  event ToHelperRatioChanged(uint value);\\n  event ClaimedToken(address heroToken, uint heroId, address token, uint amount, address recipient);\\n  event ClaimedItem(address heroToken, uint heroId, address item, uint itemId, address recipient);\\n  event MinLevelChanged(uint8 value);\\n  event MinLifeChancesChanged(uint value);\\n  //endregion ------------------------ ReinforcementController\\n\\n  //region ------------------------ Treasury, reward pool\\n  event AssetsSentToDungeon(address dungeon, address token, uint amount);\\n  event RewardSentToUser(address receiver, address token, uint rewardAmount);\\n  event NotEnoughReward(address receiver, address token, uint rewardAmountToPay);\\n  event BaseAmountChanged(uint oldValue, uint newValue);\\n  //endregion ------------------------ Treasury, reward pool\\n\\n  //region ------------------------ EventLib\\n  event EventResult(uint64 dungeonId, address heroToken, uint heroTokenId, uint8 stageId, IStatController.ActionInternalInfo gen, uint iteration);\\n  //endregion ------------------------ EventLib\\n\\n  //region ------------------------ Item controller and helper contracts\\n  event ItemRegistered(address item, IItemController.RegisterItemParams info);\\n  event OtherItemRegistered(address item, IItemController.ItemMeta meta, bytes packedItemMetaData);\\n  event ItemRemoved(address item);\\n  event OtherItemRemoved(address item);\\n  event NewItemMinted(address item, uint itemId, IItemController.MintInfo info);\\n  event Equipped(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot);\\n  event TakenOff(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot, address destination);\\n  event ItemRepaired(address item, uint itemId, uint consumedItemId, uint16 baseDurability);\\n  event FailedToRepairItem(address item, uint itemId, uint consumedItemId, uint16 itemDurability);\\n  event Augmented(address item, uint itemId, uint consumedItemId, uint8 augLevel, IItemController.AugmentInfo info);\\n  event NotAugmented(address item, uint itemId, uint consumedItemId, uint8 augLevel);\\n  event ReduceDurability(address item, uint itemId, uint newDurability);\\n  event Used(address item, uint tokenId, address heroToken, uint heroTokenId);\\n  event Destroyed(address item, uint itemId);\\n  event FragilityReduced(address item, uint itemId, address consumedItem, uint consumedItemId, uint fragility);\\n  event ItemControllerHelper(address helper);\\n  event SetUnionConfig(uint configId, address[] items, uint[] count, address itemToMint);\\n  event RemoveUnionConfig(uint configId);\\n  event SetUnionKeyPass(address keyPassItem);\\n  event CombineItems(address msgSender, uint configId, address[] items, uint[][] itemIds, address mintedItem, uint mintedItemId);\\n  //endregion ------------------------ Item controller and helper contracts\\n\\n  //region ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n  event ChangePauseStatus(bool value);\\n  event MinterChanged(address value);\\n\\n  event UniqueUriChanged(uint id, string uri);\\n  event BaseUriChanged(string uri);\\n\\n  event HeroMinted(uint heroId);\\n  event HeroBurned(uint heroId);\\n  event HeroUriByStatusChanged(string uri, uint statusLvl);\\n\\n  event ItemMinted(uint tokenId);\\n  event ItemBurned(uint tokenId);\\n  event UriByRarityChanged(string uri, uint rarity);\\n  event SponsoredHeroCreated(address msgSender, address heroAddress, uint heroId, string heroName);\\n  //endregion ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n\\n  //region ------------------------ User controller\\n  event SetUserName(address user, string name);\\n  event SetUserAvatar(address user, string avatar);\\n  event LootBoxOpened(address user, uint lootBoxKind, address[] itemTokens, uint[] itemTokenIds);\\n  event LootBoxConfigChanged(uint lootBoxKind, address[] mintItems, uint32[] mintItemsChances, uint maxDropItems);\\n  event SetFeeRenaming(uint feeRenaming);\\n  event ActivityCompleted(address user, bool daily, bool weekly);\\n  event FameHallHeroRegistered(address hero, uint heroId, address heroOwner, uint8 openedNgLevel);\\n  //endregion ------------------------ User controller\\n\\n  //region ------------------------ Guild\\n\\n  event GuildCreated(address owner, uint guildId, string name, string urlLogo);\\n  event AddToGuild(uint guildId, address newUser);\\n  event ChangeGuildRights(uint guildId, address user, uint rights);\\n  event RemoveFromGuild(uint guildId, address user);\\n  event GuildDeleted(uint guildId);\\n  event GuildLevelUp(uint guildId, uint8 newLevel);\\n  event GuildRename(uint guildId, string newName);\\n  event GuildLogoChanged(uint guildId, string newLogoUrl);\\n  event GuildDescriptionChanged(uint guildId, string newDescription);\\n  event SetGuildRelation(uint guildId1, uint guildId2, bool peace);\\n  event TransferFromGuildBank(address user, address token, uint amount, address recipient);\\n  event TransferNftFromGuildBank(address user, address[] nfts, uint[] tokenIds, address recipient);\\n  event GuildBankDeployed(uint guildId, address guildBank);\\n\\n  event SetToHelperRatio(uint guildId, uint8 value, address user);\\n  event TopUpGuildBank(address msgSender, uint guildId, address guildBank, uint amount);\\n\\n  event GuildRequestRegistered(address msgSender, uint guildId, string userMessage, uint depositAmount);\\n  event GuildRequestStatusChanged(address msgSender, uint guildRequestId, uint8 newStatus, address user);\\n  event SetToHelperRatio(uint guildId, address msgSender, uint8 toHelperRatio);\\n  event SetGuildRequestDepositAmount(uint guildId, address msgSender, uint amount);\\n  event SetGuildBaseFee(uint fee);\\n  event SetPvpPointsCapacity(address msgSender, uint64 capacityPvpPoints, address[] users);\\n  event SetShelterController(address shelterController);\\n  event SetShelterAuction(address shelterAuction);\\n  event PayForBidFromGuildBank(uint guildId, uint amount, uint bid);\\n  //endregion ------------------------ Guild\\n\\n  //region ------------------------ Guild shelter\\n  event RegisterShelter(uint sheleterId, uint price);\\n  event SetShelterItems(\\n    uint shelterId,\\n    address[] items,\\n    uint64[] pricesInPvpPoints,\\n    uint128[] pricesInGameTokens,\\n    uint16[] maxItemsPerDayThresholds\\n  );\\n  event RemoveShelterItems(uint shelterId, address[] items);\\n  event BuyShelter(uint guidlId, uint shelterId);\\n  event LeaveShelter(uint guildId, uint shelterId);\\n  event NewShelterBid(uint shelterId, uint buyerGuildId, uint amount);\\n  event RevokeShelterBid(uint shelterId);\\n  event UseShelterBid(uint shelterId, uint sellerGuildId, uint buyerGuidId, uint amount);\\n  event PurchaseShelterItem(address msgSender, address item, uint numSoldItems, uint priceInPvpPoints, uint priceInGameToken);\\n  event ChangeShelterOwner(uint shelterId, uint fromGuildId, uint toGuildId);\\n  event RestInShelter(address msgSender, address heroToken, uint heroTokenId);\\n  //endregion ------------------------ Guild shelter\\n\\n  //region ------------------------ Guild reinforcement\\n  event GuildHeroStaked(address heroToken, uint heroId, uint guildId);\\n  event GuildHeroWithdrawn(address heroToken, uint heroId, uint guildId);\\n  event GuildHeroAsked(address heroToken, uint heroId, uint guildId, address user);\\n\\n  /// @param user Address can be 0 if heroId was already burnt at the moment of reinforcement releasing\\n  event GuildHeroReleased(address heroToken, uint heroId, uint guildId, address user);\\n  //endregion ------------------------ Guild reinforcement\\n\\n  //region ------------------------ Guild auction\\n  event AuctionPositionOpened(uint positionId, uint shelterId, uint sellerGuildId, address msgSender, uint minAuctionPrice);\\n  event AuctionPositionClosed(uint positionId, address msgSender);\\n  event AuctionBidOpened(uint bidId, uint positionId, uint amount, address msgSender);\\n  //endregion ------------------------ Guild auction\\n\\n  //region ------------------------ Guild bank\\n  event GuildBankTransfer(address token, address recipient, uint amount);\\n  event GuildBankTransferNft(address to, address nft, uint tokenId);\\n  event GuildBankTransferNftMulti(address to, address[] nfts, uint[] tokenIds);\\n  //endregion ------------------------ Guild bank\\n\\n  //region ------------------------ Pawnshop\\n  event PawnShopRouterDeployed(address pawnShop, address gameToken, address routerOwner, address deployed);\\n  event PawnShopRouterTransfer(address token, uint amount, address receiver);\\n  event PawnShopRouterBulkSell(address[] nfts, uint[] nftIds, uint[] prices, address nftOwner, uint[] positionIds);\\n  event PawnShopRouterClosePositions(uint[] positionIds, address receiver);\\n  event PawnShopRouterBulkBuy(uint[] positionIds, address receiver);\\n\\n  //endregion ------------------------ Pawnshop\\n}\\n\",\"keccak256\":\"0xf718b42b00e9d4b03e0b0ac43b403fe25baea08e10ccbd9f75ebc0ed40232318\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IController {\\n\\n  function governance() external view returns (address);\\n\\n  function statController() external view returns (address);\\n\\n  function storyController() external view returns (address);\\n\\n  function gameObjectController() external view returns (address);\\n\\n  function reinforcementController() external view returns (address);\\n\\n  function oracle() external view returns (address);\\n\\n  function treasury() external view returns (address);\\n\\n  function itemController() external view returns (address);\\n\\n  function heroController() external view returns (address);\\n\\n  function dungeonFactory() external view returns (address);\\n\\n  function gameToken() external view returns (address);\\n\\n  function validTreasuryTokens(address token) external view returns (bool);\\n\\n  function isDeployer(address adr) external view returns (bool);\\n\\n  function onPause() external view returns (bool);\\n\\n  function userController() external view returns (address);\\n\\n  function guildController() external view returns (address);\\n\\n  function rewardsPool() external view returns (address);\\n\\n  function gameTokenPrice() external view returns (uint);\\n\\n  function process(address token, uint amount, address from) external;\\n}\\n\",\"keccak256\":\"0xb10c5b5c21f1794f98ab2b46f559ad86ae909d9beba674e68a29ab85c8947d7f\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDungeonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IDungeonFactory {\\n\\n  /// @custom:storage-location erc7201:dungeon.factory.main\\n  struct MainState {\\n    /// @dev biome => dungeonLaunchedId\\n    mapping(uint => EnumerableSet.UintSet) freeDungeons;\\n    /// @dev hero + heroId + biome (packMapObject) -> completed\\n    mapping(bytes32 => bool) bossCompleted;\\n    /// @dev hero + heroId + dungNum (packDungeonKey) -> completed\\n    mapping(bytes32 => bool) specificDungeonCompleted;\\n    /// @notice Max biome completed by the hero\\n    /// @dev hero + heroId (nftPacked) -> max biome completed\\n    mapping(bytes32 => uint8) maxBiomeCompleted;\\n    /// @notice which dungeon the hero is currently in\\n    /// @dev hero+id => current DungeonId\\n    mapping(bytes32 => uint64) heroCurrentDungeon;\\n\\n    // ---\\n\\n    /// @notice Specific dungeon for the given pair of hero level + hero class\\n    ///         ALl specific dungeons are listed also in allSpecificDungeons\\n    /// @dev packUint8Array(specReqBiome, specReqHeroClass) => dungNum\\n    mapping(bytes32 => uint16) dungeonSpecific;\\n    /// @dev contains all specific dungNum for easy management\\n    EnumerableSet.UintSet allSpecificDungeons;\\n    /// @dev biome => dungNum\\n    mapping(uint8 => EnumerableSet.UintSet) dungeonsLogicByBiome;\\n\\n    // ---\\n\\n    /// @dev max available biome. auto-increment with new dung deploy\\n    uint8 maxBiome;\\n\\n    /// @notice Address of treasure token => min hero level required\\n    /// @dev manual threshold for treasury\\n    mapping(address => uint) minLevelForTreasury;\\n\\n    /// @notice Contains arrays for SKILL_1, SKILL_2, SKILL_3 with 0 or 1\\n    /// i.e. [0, 1, 0] means that durability of SKILL_2 should be reduced\\n    /// @dev hero + heroId => uint8[] array where idx = slotNum\\n    mapping(bytes32 => bytes32) skillSlotsForDurabilityReduction;\\n\\n    /// @notice Counter of dungeons, it's incremented on launch of a new dungeon\\n    uint64 dungeonCounter;\\n\\n    /// @dev dungNum = init attributes\\n    mapping(uint16 => DungeonAttributes) dungeonAttributes;\\n    /// @dev dungeonId => status\\n    mapping(uint64 => DungeonStatus) dungeonStatuses;\\n  }\\n\\n  struct ObjectGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    /// @dev uint8 types, packed using PackingLib.packUint8Array\\n    bytes32[] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    /// @dev uint64 chances\\n    uint32[][] objChancesByStages;\\n  }\\n\\n  struct DungeonGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    uint8[][] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    uint32[][] objChancesByStages;\\n\\n    uint32[] uniqObjects;\\n\\n    uint8 minLevel;\\n    uint8 maxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n  }\\n\\n  /// @notice Attributes of the given dungeon logic\\n  struct DungeonAttributes {\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    uint8 stages;\\n    uint8 biome;\\n\\n    /// @notice Default list of objects that should be passed in the dungeon\\n    uint32[] uniqObjects;\\n\\n    /// @dev min+max (packUint8Array)\\n    bytes32 minMaxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    /// @notice Packed DungeonGenerateInfo.requiredCustomData: MinValue, MaxValue, IsHero\\n    /// @dev min+max+isHero(packStoryCustomDataRequirements)\\n    bytes32[] requiredCustomDataValue;\\n\\n    ObjectGenerateInfo info;\\n  }\\n\\n  /// @notice Current status of the given dungeon\\n  struct DungeonStatus {\\n    uint64 dungeonId;\\n    /// @notice Dungeon logic id\\n    uint16 dungNum;\\n\\n    /// @notice True if the dungeon is completed by the hero\\n    bool isCompleted;\\n\\n    /// @notice Hero in the dungeon or 0\\n    address heroToken;\\n    uint heroTokenId;\\n    /// @notice Current object that should be passed by the hero. 0 - new object is not opened\\n    uint32 currentObject;\\n    /// @notice Current stage in the dungeon that should be passed by the hero.\\n    uint8 currentStage;\\n\\n    EnumerableMap.AddressToUintMap treasuryTokens;\\n    /// @notice All items that were minted on result of made actions\\n    bytes32[] treasuryItems;\\n\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    /// This value can be bigger than length of uniqObjects\\n    uint8 stages;\\n    /// @notice List of objects to be passed in the stage. The list can be dynamically changed during passing the stages\\n    uint32[] uniqObjects;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n\\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external returns (uint64 dungeonId);\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8);\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64);\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result);\\n\\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external;\\n\\n  /// @notice Hero exists current dungeon forcibly same as when dying but without loosing life chance\\n  function exitForcibly(address heroToken, uint heroTokenId, address msgSender) external;\\n\\n  function maxAvailableBiome() external view returns (uint8);\\n\\n  function reborn(address hero, uint heroId) external;\\n}\\n\",\"keccak256\":\"0xc3442984b7b3ff846bafe6dcddc090ee0393ea9cfff30cdf5550173307364540\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IFightCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface IFightCalculator {\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    MELEE, // 1\\n    MAGIC, // 2\\n    SLOT_3,\\n    SLOT_4,\\n    SLOT_5,\\n    SLOT_6,\\n    SLOT_7,\\n    SLOT_8,\\n    SLOT_9,\\n    SLOT_10\\n  }\\n\\n  /// @notice Attacker info: suitable both for hero and monsters\\n  struct AttackInfo {\\n    /// @notice Type of the attack\\n    /// by default, if attack token presents, it's magic attack and not-magic otherwise\\n    /// but this logic can become more complicated after introducing new attack types\\n    AttackType attackType;\\n    /// @notice NFT selected by hero for attack, it should be equip on.\\n    /// If attacker is a monster, this is a special case (stub NFT with zero ID is used)\\n    address attackToken;\\n    uint attackTokenId;\\n    address[] skillTokens;\\n    uint[] skillTokenIds;\\n  }\\n\\n  struct FighterInfo {\\n    int32[] fighterAttributes;\\n    IStatController.ChangeableStats fighterStats;\\n    AttackType attackType;\\n    address attackToken;\\n    uint attackTokenId;\\n    uint race;\\n  }\\n\\n  struct Statuses {\\n    bool stun;\\n    bool burn;\\n    bool freeze;\\n    bool confuse;\\n    bool curse;\\n    bool poison;\\n    bool gotCriticalHit;\\n    bool missed;\\n    bool hitBlocked;\\n  }\\n\\n  struct FightResult {\\n    int32 healthA;\\n    int32 healthB;\\n    int32 manaConsumedA;\\n    int32 manaConsumedB;\\n  }\\n\\n  struct FightCall {\\n    FighterInfo fighterA;\\n    FighterInfo fighterB;\\n    uint64 dungeonId;\\n    uint32 objectId;\\n    address heroAdr;\\n    uint heroId;\\n    uint8 stageId;\\n    uint iteration;\\n    uint8 turn;\\n  }\\n\\n  struct SkillSlots {\\n    bool slot1;\\n    bool slot2;\\n    bool slot3;\\n  }\\n\\n  //region ------------------------ FightLib-internal (FightInfoInternal is required by IApplicationEvents..)\\n  struct FightInfoInternal {\\n    Fighter fighterA;\\n    Fighter fighterB;\\n  }\\n\\n  struct Fighter {\\n    IFightCalculator.FighterInfo info;\\n    IItemController.AttackInfo magicAttack;\\n    int32 health;\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 damagePoison;\\n    int32 damageReflect;\\n    IFightCalculator.Statuses statuses;\\n  }\\n  //endregion ------------------------ FightLib-internal\\n\\n  function fight(FightCall memory callData) external returns (FightResult memory);\\n}\\n\",\"keccak256\":\"0xdf9ba809ea21a35a24eed12bf80e53452b0d772623d59211a35498b518eb604b\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGOC.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\n\\ninterface IGOC {\\n\\n  enum ObjectType {\\n    UNKNOWN, // 0\\n    EVENT, // 1\\n    MONSTER, // 2\\n    STORY, // 3\\n    END_SLOT\\n  }\\n\\n  enum ObjectSubType {\\n    UNKNOWN_0, // 0\\n    ENEMY_NPC_1, // 1\\n    ENEMY_NPC_SUPER_RARE_2, // 2\\n    BOSS_3, // 3\\n    SHRINE_4, // 4\\n    CHEST_5, // 5\\n    STORY_6, // 6\\n    STORY_UNIQUE_7, // 7\\n    SHRINE_UNIQUE_8, // 8\\n    CHEST_UNIQUE_9, // 9\\n    ENEMY_NPC_UNIQUE_10, // 10\\n    STORY_ON_ROAD_11, // 11\\n    STORY_UNDERGROUND_12, // 12\\n    STORY_NIGHT_CAMP_13, // 13\\n    STORY_MOUNTAIN_14, // 14\\n    STORY_WATER_15, // 15\\n    STORY_CASTLE_16, // 16\\n    STORY_HELL_17, // 17\\n    STORY_SPACE_18, // 18\\n    STORY_WOOD_19, // 19\\n    STORY_CATACOMBS_20, // 20\\n    STORY_BAD_HOUSE_21, // 21\\n    STORY_GOOD_TOWN_22, // 22\\n    STORY_BAD_TOWN_23, // 23\\n    STORY_BANDIT_CAMP_24, // 24\\n    STORY_BEAST_LAIR_25, // 25\\n    STORY_PRISON_26, // 26\\n    STORY_SWAMP_27, // 27\\n    STORY_INSIDE_28, // 28\\n    STORY_OUTSIDE_29, // 29\\n    STORY_INSIDE_RARE_30,\\n    STORY_OUTSIDE_RARE_31,\\n    ENEMY_NPC_INSIDE_32,\\n    ENEMY_NPC_INSIDE_RARE_33,\\n    ENEMY_NPC_OUTSIDE_34,\\n    ENEMY_NPC_OUTSIDE_RARE_35,\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:game.object.controller.main\\n  struct MainState {\\n\\n    /// @dev objId = biome(00) type(00) id(0000) => biome(uint8) + objType(uint8)\\n    /// Id is id of the event, story or monster.\\n    mapping(uint32 => bytes32) objectMeta;\\n\\n    /// @dev biome(uint8) + objType(uint8) => set of object id\\n    mapping(bytes32 => EnumerableSet.UintSet) objectIds;\\n\\n    /// @dev heroAdr180 + heroId64 + cType8 + biome8 => set of already played objects. Should be cleared periodically\\n    mapping(bytes32 => EnumerableSet.UintSet) playedObjects;\\n\\n    /// @dev HeroAdr(160) + heroId(uint64) + objId(uint32) => iteration count. It needs for properly emit events for every new entrance.\\n    mapping(bytes32 => uint) iterations;\\n\\n    /// @dev objId(uint32) => EventInfo\\n    mapping(uint32 => EventInfo) eventInfos;\\n\\n    /// @dev objId(uint32) => storyId\\n    mapping(uint32 => uint16) storyIds;\\n\\n    /// @dev objId(uint32) => MonsterInfo\\n    mapping(uint32 => MonsterInfo) monsterInfos;\\n\\n    /// @dev hero+id => last fight action timestamp\\n    mapping(bytes32 => uint) lastHeroFightTs;\\n\\n    /// @dev delay for user actions in fight (suppose to prevent bot actions)\\n    uint fightDelay;\\n  }\\n\\n  struct ActionResult {\\n    bool kill;\\n    bool completed;\\n    address heroToken;\\n    address[] mintItems;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n    uint32 objectId;\\n    uint32 experience;\\n    uint heroTokenId;\\n    uint iteration;\\n    uint32[] rewriteNextObject;\\n  }\\n\\n  struct EventInfo {\\n    /// @dev chance to use good or bad attributes/stats\\n    uint32 goodChance;\\n\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] goodAttributes;\\n    bytes32[] badAttributes;\\n\\n    /// @dev experience(uint32) + heal(int32) + manaRegen(int32) + lifeChancesRecovered(int32) + damage(int32) + manaConsume(int32) packStatsChange\\n    bytes32 statsChange;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n  }\\n\\n  struct MonsterInfo {\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] attributes;\\n    /// @dev level(uint8) + race(uint8) + experience(uint32) + maxDropItems(uint8) packMonsterStats\\n    bytes32 stats;\\n    /// @dev attackToken(160) + attackTokenId(uint64) + attackType(uint8) packAttackInfo\\n    bytes32 attackInfo;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n\\n    /// @dev heroAdr(160) + heroId(uint64) => iteration => GeneratedMonster packed\\n    mapping(bytes32 => mapping(uint => bytes32)) _generatedMonsters;\\n  }\\n\\n  struct MultiplierInfo {\\n    uint8 biome;\\n    /// @notice NG_LEVEL of the hero who is going to fight with the given monster\\n    /// Use type(uint8).max for !NG+\\n    uint8 heroNgLevel;\\n  }\\n\\n  struct GeneratedMonster {\\n    bool generated;\\n    uint8 turnCounter;\\n    int32 hp;\\n    uint32 amplifier;\\n  }\\n\\n  struct MonsterGenInfo {\\n    uint16 monsterId;\\n    uint8 biome;\\n    ObjectSubType subType;\\n\\n    uint8[] attributeIds;\\n    int32[] attributeValues;\\n\\n    uint8 level;\\n    uint8 race;\\n    uint32 experience;\\n    uint8 maxDropItems;\\n\\n    address attackToken;\\n    uint64 attackTokenId;\\n    uint8 attackType;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct ActionContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    uint8 biome;\\n    uint8 objectSubType;\\n    uint8 stageId;\\n    uint8 heroNgLevel;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint heroTokenId;\\n    uint salt;\\n    uint iteration;\\n    bytes data;\\n  }\\n\\n  struct EventRegInfo {\\n    uint8 biome;\\n    uint16 eventId;\\n    ObjectSubType subType;\\n\\n    uint32 goodChance;\\n\\n    AttributeGenerateInfo goodAttributes;\\n    AttributeGenerateInfo badAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct AttributeGenerateInfo {\\n    uint8[] ids;\\n    int32[] values;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev represent object registration if non zero values\\n  function getObjectMeta(uint32 objectId) external view returns (uint8 biome, uint8 objectSubType);\\n\\n  function isBattleObject(uint32 objectId) external view returns (bool);\\n\\n  function getRandomObject(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biomeLevel,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external returns (uint32 objectId);\\n\\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint iteration);\\n\\n  function action(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) external returns (ActionResult memory);\\n\\n}\\n\",\"keccak256\":\"0x9f12869021850ca2a16a083d0f1808f112061ca2d0278e82fe77f2839330b0d3\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IHeroController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IHeroController {\\n\\n  /// @custom:storage-location erc7201:hero.controller.main\\n  struct MainState {\\n\\n    /// @dev A central place for all hero tokens\\n    /// @dev Deprecated. Controller is used instead.\\n    address heroTokensVault;\\n\\n    /// @dev heroAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) payToken;\\n\\n    /// @dev heroAdr => heroCls8\\n    mapping(address => uint8) heroClass;\\n\\n    // ---\\n\\n    /// @dev hero+id => individual hero name\\n    mapping(bytes32 => string) heroName;\\n\\n    /// @dev name => hero+id, needs for checking uniq names\\n    mapping(string => bytes32) nameToHero;\\n\\n    // ---\\n\\n    /// @dev hero+id => biome\\n    mapping(bytes32 => uint8) heroBiome;\\n\\n    /// @notice Exist reinforcement of any kind for the given hero\\n    /// @dev hero+id => packed reinforcement helper+id\\n    mapping(bytes32 => bytes32) reinforcementHero;\\n\\n    /// @dev hero+id => reinforcement packed attributes\\n    mapping(bytes32 => bytes32[]) reinforcementHeroAttributes;\\n\\n    /// @notice packedHero (hero + id) => count of calls of beforeTokenTransfer\\n    mapping(bytes32 => uint) countHeroTransfers;\\n\\n\\n    // ------------------------------------ NG plus\\n\\n    /// @notice (tier, hero address) => TierInfo, where tier = [2, 3]\\n    /// @dev For tier=1 no data is required. Amount for tier 1 is stored in {payToken}, no items are minted\\n    /// Token from {payToken} is equal for all tiers\\n    mapping(bytes32 packedTierHero => TierInfo) tiers;\\n\\n    mapping(bytes32 packedHero => HeroInfo) heroInfo;\\n\\n    /// @notice Max NG_LVL reached by the heroes of a given account\\n    mapping(address user => uint8 maxNgLevel) maxUserNgLevel;\\n\\n    /// @notice When the hero has killed boss on the given biome first time\\n    /// packedBiomeNgLevel = packed (biome, NG_LEVEL)\\n    mapping(bytes32 packedHero => mapping (bytes32 packedBiomeNgLevel => uint timestamp)) killedBosses;\\n\\n    /// @notice Max NG_LEVEL reached by any user\\n    uint maxOpenedNgLevel;\\n  }\\n\\n  /// @notice Tier = hero creation cost option\\n  /// There are 3 tiers:\\n  /// 1: most chip option, just pay fixed amount {payTokens} - new hero is created\\n  /// 2: pay bigger amount - random skill is equipped on the newly created hero\\n  /// 3: pay even more amount - random sill + some random items are equipped on the newly created hero\\n  struct TierInfo {\\n    /// @notice Cost of the hero creation using the given tier in terms of the token stored in {payToken}\\n    /// This amount is used for tiers 2, 3. For tier 1 the amount is taken from {payToken}\\n    uint amount;\\n\\n    /// @notice All slots for which items-to-mint are registered in {itemsToMint}\\n    EnumerableSet.UintSet slots;\\n\\n    /// @notice slot => items that can be minted and equipped on the hero to the given {slot} after hero creation\\n    mapping(uint8 slot => address[] items) itemsToMint;\\n  }\\n\\n  /// @notice Current NG+-related values\\n  struct HeroInfo {\\n    /// @notice Hero tier = [0..3]. 0 - the hero is post-paid, it can be changed by upgrading the hero to pre-paid\\n    uint8 tier;\\n\\n    /// @notice NG_LVL of the hero\\n    uint8 ngLevel;\\n\\n    /// @notice True if hero has passed last biome on current NG+ and so NG_LEVEL can be incremented (reborn is allowed)\\n    bool rebornAllowed;\\n\\n    /// @notice Amount paid for the hero on creation OR on upgrade to NG+\\n    /// Amount paid for creation of the hero in terms of game token (!NG+) is NOT stored here.\\n    /// @dev uint72 is used here to pack the whole struct to single slot\\n    uint72 paidAmount;\\n\\n    /// @notice Pay token used to pay {paidAmount}\\n    address paidToken;\\n  }\\n\\n  /// @notice Input data to create new hero\\n  struct HeroCreationData {\\n    /// @notice Desired NG_LVL of the hero\\n    uint8 ngLevel;\\n\\n    /// @notice Desired tire of the newly created hero. Allowed values: [1..3]\\n    uint8 tier;\\n\\n    /// @notice Enter to the dungeon after creation\\n    bool enter;\\n\\n    /// @notice Desired hero name\\n    string heroName;\\n\\n    /// @notice Optional: user account for which the hero is created\\n    address targetUserAccount;\\n\\n    /// @notice Optional: ref-code to be passed to the hero-creation-related event\\n    string refCode;\\n  }\\n\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function heroClass(address hero) external view returns (uint8);\\n\\n  function heroBiome(address hero, uint heroId) external view returns (uint8);\\n\\n  function payTokenInfo(address hero) external view returns (address token, uint amount);\\n\\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (address helperHeroToken, uint helperHeroId);\\n\\n  function score(address hero, uint heroId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool);\\n\\n  function beforeTokenTransfer(address hero, uint heroId) external returns (bool);\\n\\n  // ---\\n\\n  function create(address hero, string memory heroName_, bool enter) external returns (uint);\\n\\n  function kill(address hero, uint heroId) external returns (bytes32[] memory dropItems);\\n\\n  /// @notice Take off all items from the hero, reduce life to 1. The hero is NOT burnt.\\n  /// Optionally reduce mana to zero and/or decrease life chance.\\n  function softKill(address hero, uint heroId, bool decLifeChances, bool resetMana) external returns (bytes32[] memory dropItems);\\n\\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId);\\n\\n  function resetLifeAndMana(address hero, uint heroId) external;\\n\\n  function countHeroTransfers(address hero, uint heroId) external view returns (uint);\\n\\n  function askGuildReinforcement(address hero, uint heroId, address helper, uint helperId) external;\\n\\n  function getHeroInfo(address hero, uint heroId) external view returns (IHeroController.HeroInfo memory data);\\n\\n  function registerKilledBoss(address hero, uint heroId, uint32 objectId) external;\\n\\n  function maxOpenedNgLevel() external view returns (uint);\\n}\\n\",\"keccak256\":\"0xcab64849520acbfbdd1ecff59728d70d07b2b64ac3620b25ff7e9c92e25acb08\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IItemController {\\n\\n  enum GlobalParam {\\n    UNKNOWN_0,\\n\\n    /// @notice Address of ItemControllerHelper\\n    ITEM_CONTROLLER_HELPER_ADDRESS_1\\n  }\\n\\n  /// @custom:storage-location erc7201:item.controller.main\\n  struct MainState {\\n\\n    ////////////////// GENERATE //////////////////\\n\\n    EnumerableSet.AddressSet items;\\n\\n    /// @dev itemAdr => itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n    mapping(address => bytes32) itemMeta;\\n\\n    /// @dev itemAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) augmentInfo;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoAttributes;\\n\\n    // --- consumable ---\\n\\n    /// @dev itemAdr => ids+values (toBytes32ArrayWithIds)\\n    mapping(address => bytes32[]) _itemConsumableAttributes;\\n\\n    /// @dev itemAdr => IStatController.ChangeableStats packed int32[]\\n    mapping(address => bytes32) itemConsumableStats;\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoCasterAttributes;\\n\\n    /// @dev itemAdr => id8 + minDmg(int32) + maxDmg(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(address => bytes32) generateInfoAttack;\\n\\n    ////////////////// ITEMS INFO //////////////////\\n\\n    /// @dev itemAdr+id => itemRarity8 + augmentationLevel8 + itemDurability16\\n    mapping(bytes32 => bytes32) itemInfo;\\n\\n    /// @dev itemAdr+id => heroAdr+id\\n    mapping(bytes32 => bytes32) equippedOn;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemAttributes;\\n\\n    // --- consumable ---\\n\\n    // consumable stats unchangeable, get them by address\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemCasterAttributes;\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr+Id => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(bytes32 => bytes32) _itemAttackInfo;\\n\\n    ////////////////// Additional generate info //////////////////\\n\\n    /// @notice (itemAdr) => Bitmask of ConsumableActionBits\\n    mapping(address => uint) _consumableActionMask;\\n\\n\\n    /// --------------------------------- SIP-003: Item fragility\\n    /// @notice itemAdr + id => item fragility counter that displays the chance of an unsuccessful repair\\n    /// @dev [0...100_000], decimals 3\\n    mapping(bytes32 packedItem => uint fragility) itemFragility;\\n\\n    /// @notice Universal mapping to store various addresses and numbers (params of the contract)\\n    mapping (GlobalParam param => uint value) globalParam;\\n\\n    /// @notice Item address => packedMetadata\\n    /// {packedMetaData} is encoded using abi.encode/abi.decode\\n    /// Read first byte, detect meta data type by the byte value, apply proper decoder from PackingLib\\n    mapping(address item => bytes packedMetaData) packedItemMetaData;\\n  }\\n\\n  struct RegisterItemParams {\\n    ItemMeta itemMeta;\\n    address augmentToken;\\n    uint augmentAmount;\\n    ItemGenerateInfo commonAttributes;\\n\\n    IGOC.AttributeGenerateInfo consumableAttributes;\\n    IStatController.ChangeableStats consumableStats;\\n\\n    ItemGenerateInfo casterAttributes;\\n    ItemGenerateInfo targetAttributes;\\n\\n    AttackInfo genAttackInfo;\\n    /// @notice Bit mask of ConsumableActionBits\\n    uint consumableActionMask;\\n  }\\n\\n  /// @notice Possible actions that can be triggered by using the consumable item\\n  enum ConsumableActionBits {\\n    CLEAR_TEMPORARY_ATTRIBUTES_0,\\n    EXIT_FROM_DUNGEON_1,\\n    RESERVED_2,\\n    REST_IN_SHELTER_3\\n  }\\n\\n  struct ItemGenerateInfo {\\n    /// @notice Attribute ids\\n    uint8[] ids;\\n    /// @notice Min value of the attribute, != 0\\n    int32[] mins;\\n    /// @notice Max value of the attribute, != 0\\n    int32[] maxs;\\n    /// @notice Chance of the selection [0..MAX_CHANCES]\\n    uint32[] chances;\\n  }\\n\\n  struct ItemMeta {\\n    uint8 itemMetaType;\\n    // Level in range 1-99. Reducing durability in low level dungeons. lvl/5+1 = biome\\n    uint8 itemLevel;\\n    IItemController.ItemType itemType;\\n    uint16 baseDurability;\\n    uint8 defaultRarity;\\n    uint32 manaCost;\\n\\n    // it doesn't include positions with 100% chance\\n    uint8 minRandomAttributes;\\n    uint8 maxRandomAttributes;\\n\\n    IStatController.CoreAttributes requirements;\\n  }\\n\\n  // Deprecated. Todo - remove\\n  enum FeeType {\\n    UNKNOWN,\\n    REPAIR,\\n    AUGMENT,\\n    STORY,\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemRarity {\\n    UNKNOWN, // 0\\n    NORMAL, // 1\\n    MAGIC, // 2\\n    RARE, // 3\\n    SET, // 4\\n    UNIQUE, // 5\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemType {\\n    NO_SLOT, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    RING, // 6\\n    OFF_HAND, // 7\\n    BOOTS, // 8\\n    ONE_HAND, // 9\\n    TWO_HAND, // 10\\n    SKILL, // 11\\n    OTHER, // 12\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemMetaType {\\n    UNKNOWN, // 0\\n    COMMON, // 1\\n    ATTACK, // 2\\n    BUFF, // 3\\n    CONSUMABLE, // 4\\n\\n    END_SLOT\\n  }\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    FIRE, // 1\\n    COLD, // 2\\n    LIGHTNING, // 3\\n    CHAOS, // 4\\n\\n    END_SLOT\\n  }\\n\\n  struct AttackInfo {\\n    AttackType aType;\\n    int32 min;\\n    int32 max;\\n    // if not zero - activate attribute factor for the attribute\\n    IStatController.CoreAttributes attributeFactors;\\n  }\\n\\n  struct ItemInfo {\\n    ItemRarity rarity;\\n    uint8 augmentationLevel;\\n    uint16 durability;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct MintInfo {\\n    IItemController.ItemMeta meta;\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.ItemRarity itemRarity;\\n\\n    IItemController.AttackInfo attackInfo;\\n\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct AugmentInfo {\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.AttackInfo attackInfo;\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  ///region ------------------------ Item type \\\"Other\\\"\\n  /// @notice Possible kinds of \\\"Other\\\" items\\n  /// Each \\\"Other\\\" item has each own structure for metadata, see OtherItemXXX\\n  enum OtherSubtypeKind {\\n    UNKNOWN_0,\\n    /// @notice Item to reduce fragility, see SCB-1014. Metadata is {OtherItemReduceFragility}\\n    REDUCE_FRAGILITY_1,\\n\\n    /// @notice This item allows asking guild reinforcement to the guild member\\n    USE_GUILD_REINFORCEMENT_2,\\n\\n    END_SLOT\\n  }\\n  struct OtherItemReduceFragility {\\n    /// @notice \\\"Other\\\" item kind. It MUST BE first field in the struct.\\n    uint8 kind;\\n\\n    /// @notice Value on which the fragility will be reduced.\\n    /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n    uint248 value;\\n  }\\n  ///endregion ------------------------ Item type \\\"Other\\\"\\n\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function itemMeta(address item) external view returns (ItemMeta memory meta);\\n\\n  function augmentInfo(address item) external view returns (address token, uint amount);\\n\\n  function genAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genCasterAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genTargetAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genAttackInfo(address item) external view returns (AttackInfo memory info);\\n\\n  function itemInfo(address item, uint itemId) external view returns (ItemInfo memory info);\\n\\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId);\\n\\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats);\\n\\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function itemAttackInfo(address item, uint itemId) external view returns (AttackInfo memory info);\\n\\n  function score(address item, uint tokenId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address item, uint tokenId) external view returns (bool);\\n\\n  // ---\\n\\n  function mint(address item, address recipient) external returns (uint itemId);\\n\\n  function reduceDurability(address hero, uint heroId, uint8 biome, bool reduceDurabilityAllSkills) external;\\n\\n  function destroy(address item, uint tokenId) external;\\n\\n  function takeOffDirectly(\\n    address item,\\n    uint itemId,\\n    address hero,\\n    uint heroId,\\n    uint8 itemSlot,\\n    address destination,\\n    bool broken\\n  ) external;\\n\\n  /// @notice SIP-003: item fragility counter that displays the chance of an unsuccessful repair.\\n  /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n  function itemFragility(address item, uint itemId) external view returns (uint);\\n\\n  /// @notice SIP-003: The quest mechanic that previously burned the item will increase its fragility by 1%\\n  function incBrokenItemFragility(address item, uint itemId) external;\\n\\n  function equip(\\n    address hero,\\n    uint heroId,\\n    address[] calldata items,\\n    uint[] calldata itemIds,\\n    uint8[] calldata itemSlots\\n  ) external;\\n}\\n\",\"keccak256\":\"0x6db2366d167d1a1077974b053d7b3fae242e44a28554e7497b730f175022ed28\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IOracle {\\n\\n  function getRandomNumber(uint max, uint seed) external returns (uint);\\n\\n  function getRandomNumberInRange(uint min, uint max, uint seed) external returns (uint);\\n\\n}\\n\",\"keccak256\":\"0x75a2bed27cbd9be6c76b6f3e941ee5f6f55380f61cd867254a0c766fc3b71976\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStatController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IStatController {\\n\\n  /// @custom:storage-location erc7201:stat.controller.main\\n  struct MainState {\\n    mapping(bytes32 => bytes32[]) heroTotalAttributes;\\n    /// @dev heroAdr+heroId => int32 packed strength, dexterity, vitality, energy\\n    mapping(bytes32 => bytes32) _heroCore;\\n    mapping(bytes32 => bytes32[]) heroBonusAttributes;\\n    mapping(bytes32 => bytes32[]) heroTemporallyAttributes;\\n    /// @dev heroAdr+heroId => uint32 packed level, experience, life, mana, lifeChances\\n    mapping(bytes32 => bytes32) heroStats;\\n    /// @dev heroAdr+heroId+itemSlot => itemAdr + itemId\\n    mapping(bytes32 => bytes32) heroSlots;\\n    /// @dev heroAdr+heroId => busy slots uint8[] packed\\n    mapping(bytes32 => bytes32) heroBusySlots;\\n    mapping(bytes32 => EnumerableSet.AddressSet) usedConsumables;\\n    /// @dev heroCustomDataV2 is used instead\\n    mapping(bytes32 => mapping(bytes32 => uint)) _deprecated_heroCustomData;\\n    mapping(bytes32 => uint) globalCustomData;\\n\\n    /// @notice packNftIdWithValue(hero, heroId, ngLevel) => hero custom data map\\n    /// @dev initially it was packedHero => hero custom data map\\n    mapping(bytes32 => EnumerableMap.Bytes32ToUintMap) heroCustomDataV2;\\n  }\\n\\n\\n  enum ATTRIBUTES {\\n    // core\\n    STRENGTH, // 0\\n    DEXTERITY, // 1\\n    VITALITY, // 2\\n    ENERGY, // 3\\n    // attributes\\n    DAMAGE_MIN, // 4\\n    DAMAGE_MAX, // 5\\n    ATTACK_RATING, // 6\\n    DEFENSE, // 7\\n    BLOCK_RATING, // 8\\n    LIFE, // 9\\n    MANA, // 10\\n    // resistance\\n    FIRE_RESISTANCE, // 11\\n    COLD_RESISTANCE, // 12\\n    LIGHTNING_RESISTANCE, // 13\\n    // dmg against\\n    DMG_AGAINST_HUMAN, // 14\\n    DMG_AGAINST_UNDEAD, // 15\\n    DMG_AGAINST_DAEMON, // 16\\n    DMG_AGAINST_BEAST, // 17\\n\\n    // defence against\\n    DEF_AGAINST_HUMAN, // 18\\n    DEF_AGAINST_UNDEAD, // 19\\n    DEF_AGAINST_DAEMON, // 20\\n    DEF_AGAINST_BEAST, // 21\\n\\n    // --- unique, not augmentable\\n    // hero will not die until have positive chances\\n    LIFE_CHANCES, // 22\\n    // increase chance to get an item\\n    MAGIC_FIND, // 23\\n    // decrease chance to get an item\\n    DESTROY_ITEMS, // 24\\n    // percent of chance x2 dmg\\n    CRITICAL_HIT, // 25\\n    // dmg factors\\n    MELEE_DMG_FACTOR, // 26\\n    FIRE_DMG_FACTOR, // 27\\n    COLD_DMG_FACTOR, // 28\\n    LIGHTNING_DMG_FACTOR, // 29\\n    // increase attack rating on given percent\\n    AR_FACTOR, // 30\\n    // percent of damage will be converted to HP\\n    LIFE_STOLEN_PER_HIT, // 31\\n    // amount of mana restored after each battle\\n    MANA_AFTER_KILL, // 32\\n    // reduce all damage on percent after all other reductions\\n    DAMAGE_REDUCTION, // 33\\n\\n    // -- statuses\\n    // chance to stun an enemy, stunned enemy skip next hit\\n    STUN, // 34\\n    // chance burn an enemy, burned enemy will loss 50% of defence\\n    BURN, // 35\\n    // chance freeze an enemy, frozen enemy will loss 50% of MELEE damage\\n    FREEZE, // 36\\n    // chance to reduce enemy's attack rating on 50%\\n    CONFUSE, // 37\\n    // chance curse an enemy, cursed enemy will loss 50% of resistance\\n    CURSE, // 38\\n    // percent of dmg return to attacker\\n    REFLECT_DAMAGE_MELEE, // 39\\n    REFLECT_DAMAGE_MAGIC, // 40\\n    // chance to poison enemy, poisoned enemy will loss 10% of the current health\\n    POISON, // 41\\n    // reduce chance get any of uniq statuses\\n    RESIST_TO_STATUSES, // 42\\n\\n    END_SLOT // 46\\n  }\\n\\n  // possible\\n  // HEAL_FACTOR\\n\\n  struct CoreAttributes {\\n    int32 strength;\\n    int32 dexterity;\\n    int32 vitality;\\n    int32 energy;\\n  }\\n\\n  struct ChangeableStats {\\n    uint32 level;\\n    uint32 experience;\\n    uint32 life;\\n    uint32 mana;\\n    uint32 lifeChances;\\n  }\\n\\n  enum ItemSlots {\\n    UNKNOWN, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    BOOTS, // 6\\n    RIGHT_RING, // 7\\n    LEFT_RING, // 8\\n    RIGHT_HAND, // 9\\n    LEFT_HAND, // 10\\n    TWO_HAND, // 11\\n    SKILL_1, // 12\\n    SKILL_2, // 13\\n    SKILL_3, // 14\\n    END_SLOT // 15\\n  }\\n\\n  struct NftItem {\\n    address token;\\n    uint tokenId;\\n  }\\n\\n  enum Race {\\n    UNKNOWN, // 0\\n    HUMAN, // 1\\n    UNDEAD, // 2\\n    DAEMON, // 3\\n    BEAST, // 4\\n    END_SLOT // 5\\n  }\\n\\n  struct ChangeAttributesInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    int32[] changeAttributes;\\n    bool add;\\n    bool temporally;\\n  }\\n\\n  struct BuffInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    uint32 heroLevel;\\n    address[] buffTokens;\\n    uint[] buffTokenIds;\\n  }\\n\\n  /// @dev This struct is used inside event, so it's moved here from lib\\n  struct ActionInternalInfo {\\n    int32[] posAttributes;\\n    int32[] negAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintedItems;\\n  }\\n\\n  function initNewHero(address token, uint tokenId, uint heroClass) external;\\n\\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory);\\n\\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32);\\n\\n  function heroAttributesLength(address token, uint tokenId) external view returns (uint);\\n\\n  function heroBaseAttributes(address token, uint tokenId) external view returns (CoreAttributes memory);\\n\\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint);\\n\\n  function globalCustomData(bytes32 index) external view returns (uint);\\n\\n  function heroStats(address token, uint tokenId) external view returns (ChangeableStats memory);\\n\\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked);\\n\\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory);\\n\\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function levelUp(address token, uint tokenId, uint heroClass, CoreAttributes memory change) external returns (uint newLvl);\\n\\n  function changeHeroItemSlot(\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) external;\\n\\n  function changeCurrentStats(\\n    address token,\\n    uint tokenId,\\n    ChangeableStats memory change,\\n    bool increase\\n  ) external;\\n\\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external;\\n\\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external;\\n\\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external;\\n\\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external;\\n\\n  function buffHero(BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed);\\n\\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external;\\n\\n  function setGlobalCustomData(bytes32 index, uint value) external;\\n\\n  /// @notice Restore life and mana during reinforcement\\n  /// @dev Life and mana will be increased on ((current life/mana attr value) - (prev life/mana attr value))\\n  /// @param prevAttributes Hero attributes before reinforcement\\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external;\\n\\n  function reborn(address heroToken, uint heroTokenId, uint heroClass) external;\\n}\\n\",\"keccak256\":\"0x5347ef90b52cf225333751b447b17cd2ad8db2af36f278bb67efe345d5e7d536\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStoryController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"./IController.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./IHeroController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStoryController {\\n\\n  enum AnswerResultId {\\n    UNKNOWN, // 0\\n    SUCCESS, // 1\\n    ATTRIBUTE_FAIL, // 2\\n    RANDOM_FAIL, // 3\\n    DELAY_FAIL, // 4\\n    HERO_CUSTOM_DATA_FAIL, // 5\\n    GLOBAL_CUSTOM_DATA_FAIL, // 6\\n\\n    END_SLOT\\n  }\\n\\n  enum CustomDataResult {\\n    UNKNOWN, // 0\\n    HERO_SUCCESS, // 1\\n    HERO_FAIL, // 2\\n    GLOBAL_SUCCESS, // 3\\n    GLOBAL_FAIL, // 4\\n\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:story.controller.main\\n  struct MainState {\\n\\n    // --- STORY REG INFO ---\\n\\n    /// @dev Uniq story identification.\\n    mapping(uint32 => uint16) storyIds;\\n    /// @dev Revers mapping for stories for using in the next object rewrite logic.\\n    mapping(uint16 => uint32) idToStory;\\n    /// @dev Store used ids for stories.\\n    mapping(uint16 => bool) _usedStoryIds;\\n    /// @dev Prevent register the story twice\\n    mapping(uint32 => bool) registeredStories;\\n\\n    // --- ANSWER MAPPING ---\\n\\n    /// @dev storyId => all story pages. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.UintSet) allStoryPages;\\n\\n    /// @dev storyId => all possible answers. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.Bytes32Set) allStoryAnswers;\\n\\n    /// @dev storyId + pageId + heroClass (zero is default answers) => storyId + pageId + heroClass (zero is default answers) + answerId\\n    mapping(bytes32 => bytes32[]) answers;\\n    /// @dev answerUnPackedId + answerResultId => nextPageIds (will be chosen randomly from this array)\\n    ///      where answerResultId is:\\n    ///      0 - unknown,\\n    ///      1 - success,\\n    ///      2 - attr fail\\n    ///      3 - random fail\\n    ///      4 - delay fail\\n    ///      5 - hero custom data fail\\n    ///      6 - global custom data fail\\n    ///      see COUNT_ANSWER_RESULT_IDS\\n    mapping(bytes32 => uint16[]) nextPageIds;\\n    /// @dev story + pageId + heroClass (zero is default answers) => random nextObjs (adr + id, like packed nft id)\\n    mapping(bytes32 => uint32[]) nextObjectsRewrite;\\n\\n    /// @dev answerPackedId => packed array of uint32[]\\n    ///      0 - random requirement(uint32, 1 - 99% success of this action, zero means no check)\\n    ///      1 - delay requirement(uint32, if time since the last call more than this value the check is fail, zero means no check)\\n    ///      2 - isFinalAnswer(uint8)\\n    mapping(bytes32 => bytes32) answerAttributes;\\n\\n    // --- ANSWER REQUIREMENTS ---\\n\\n    /// @dev answerPackedId => array of AttributeRequirementsPacked\\n    mapping(bytes32 => bytes32[]) attributeRequirements;\\n    /// @dev answerPackedId=> array of ItemRequirementsPacked\\n    mapping(bytes32 => bytes32[]) itemRequirements;\\n    /// @dev answerPackedId => array of TokenRequirementsPacked\\n    mapping(bytes32 => bytes32[]) tokenRequirements;\\n    /// @dev answerPackedId => custom data for hero\\n    mapping(bytes32 => CustomDataRequirementPacked[]) heroCustomDataRequirement;\\n    /// @dev answerPackedId => global custom data\\n    mapping(bytes32 => CustomDataRequirementPacked[]) globalCustomDataRequirement;\\n\\n    // --- ANSWER RESULTS ---\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) successInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) successInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) successInfoMintItems;\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) failInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) failInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) failInfoMintItems;\\n\\n    /// @dev answerUnPackedId + CustomDataResult => custom data array change\\n    ///      where CustomDataResult is\\n    ///      1 - hero success\\n    ///      2 - hero fail\\n    ///      3 - global success\\n    ///      4 - global fail\\n    ///      see COUNT_CUSTOM_DATA_RESULT_IDS\\n    mapping(bytes32 => bytes32[]) customDataResult;\\n\\n    /// @notice answerPackedId => slot+chance+stopIfBurnt\\n    /// @dev Since SIP-003 the items are not burn but broke\\n    mapping(bytes32 => bytes32[]) burnItem;\\n\\n    // --- GENERAL STORY REQUIREMENTS ---\\n\\n    /// @dev story => Custom hero data requirements for a story. If exist and hero is not eligible should be not chose in a dungeon.\\n    mapping(uint => CustomDataRequirementRangePacked[]) storyRequiredHeroData;\\n    /// @dev story => Minimal level for the history. 0 means no requirements.\\n    mapping(uint => uint) storyRequiredLevel;\\n\\n    // --- HERO STATES ---\\n\\n    /// @dev hero + heroId + storyId => pageId + heroLastActionTS\\n    mapping(bytes32 => bytes32) heroState;\\n\\n    // --- OTHER ---\\n\\n    /// @dev storyId => build hash for the last update\\n    mapping(uint16 => uint) storyBuildHash;\\n\\n    /// @notice Number of already minted items by the user within the given iteration of the story.\\n    /// Only minting of the given number of items is allowed per iteration (see MAX_MINTED_ITEMS_PER_ITERATION).\\n    /// @dev hero, heroId, story => mintedInIteration\\n    /// This map is not cleared: storyId:objectId is 1:1, each object has own sequence of iterations without duplicates\\n    mapping(bytes32 => mapping(uint iteration => uint countMintedItems)) mintedInIteration;\\n  }\\n\\n  /// @dev We need to have flat structure coz Solidity can not handle arrays of structs properly\\n  struct StoryMetaInfo {\\n    uint16 storyId;\\n\\n    // --- story reqs\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n    uint minLevel;\\n\\n    // --- answer reqs\\n\\n    AnswersMeta answersMeta;\\n    AnswerNextPageMeta answerNextPage;\\n    AnswerAttributeRequirementsMeta answerAttributeRequirements;\\n    AnswerItemRequirementsMeta answerItemRequirements;\\n    AnswerTokenRequirementsMeta answerTokenRequirements;\\n    AnswerAttributesMeta answerAttributes;\\n    AnswerCustomDataMeta answerHeroCustomDataRequirement;\\n    AnswerCustomDataMeta answerGlobalCustomDataRequirement;\\n\\n    // --- answer results\\n\\n    AnswerBurnRandomItemMeta answerBurnRandomItemMeta;\\n    NextObjRewriteMeta nextObjRewriteMeta;\\n\\n    // --- story results\\n\\n    AnswerResultMeta successInfo;\\n    AnswerResultMeta failInfo;\\n\\n    AnswerCustomDataResultMeta successHeroCustomData;\\n    AnswerCustomDataResultMeta failHeroCustomData;\\n    AnswerCustomDataResultMeta successGlobalCustomData;\\n    AnswerCustomDataResultMeta failGlobalCustomData;\\n  }\\n\\n  struct NextObjRewriteMeta {\\n    uint16[] nextObjPageIds;\\n    uint8[] nextObjHeroClasses;\\n    uint32[][] nextObjIds;\\n  }\\n\\n  struct AnswersMeta {\\n    uint16[] answerPageIds;\\n    uint8[] answerHeroClasses;\\n    uint16[] answerIds;\\n  }\\n\\n  struct AnswerNextPageMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint8[] answerResultIds;\\n    uint16[][] answerNextPageIds;\\n  }\\n\\n  struct AnswerAttributeRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    bool[][] cores;\\n    uint8[][] ids;\\n    int32[][] values;\\n  }\\n\\n  struct AnswerItemRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireItems;\\n    bool[][] requireItemBurn;\\n    bool[][] requireItemEquipped;\\n  }\\n\\n  struct AnswerTokenRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireToken;\\n    uint88[][] requireAmount;\\n    bool[][] requireTransfer;\\n  }\\n\\n  struct AnswerAttributesMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint32[] randomRequirements;\\n    uint32[] delayRequirements;\\n    bool[] isFinalAnswer;\\n  }\\n\\n  struct AnswerCustomDataMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    bool[][] mandatory;\\n    uint64[][] dataValuesMin;\\n    uint64[][] dataValuesMax;\\n  }\\n\\n  struct AnswerResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    uint8[][] attributeIds;\\n    /// @dev Max value is limitied by int24, see toBytes32ArrayWithIds impl\\n    int32[][] attributeValues;\\n\\n    uint32[] experience;\\n    int32[] heal;\\n    int32[] manaRegen;\\n    int32[] lifeChancesRecovered;\\n    int32[] damage;\\n    int32[] manaConsumed;\\n\\n    address[][] mintItems;\\n    uint32[][] mintItemsChances;\\n  }\\n\\n  struct AnswerCustomDataResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    int16[][] dataValues;\\n  }\\n\\n  struct AnswerBurnRandomItemMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    /// @notice 0 - random slot\\n    uint8[][] slots;\\n    /// @notice typical chances are [0..100] (no decimals here)\\n    uint64[][] chances;\\n    /// @notice Since SIP-003 the burning is replaced by breaking bu the name is kept as is\\n    bool[][] isStopIfBurnt;\\n  }\\n\\n  struct CustomDataRequirementPacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + mandatory(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct CustomDataRequirementRangePacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + isHeroData(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct StatsChange {\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n  }\\n\\n  struct StoryActionContext {\\n    uint stageId;\\n    uint iteration;\\n    bytes32 answerIdHash;\\n    bytes32 answerAttributes;\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IStatController statController;\\n    IHeroController heroController;\\n    IOracle oracle;\\n    IItemController itemController;\\n    uint8 heroClass;\\n    uint8 heroClassFromAnswerHash;\\n    uint8 biome;\\n    uint16 storyId;\\n    uint16 storyIdFromAnswerHash;\\n    uint16 pageIdFromAnswerHash;\\n    uint16 answerNumber;\\n    uint16 pageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint40 heroLastActionTS;\\n    uint80 heroTokenId;\\n    IStatController.ChangeableStats heroStats;\\n  }\\n\\n  // --- WRITE ---\\n\\n  function storyAction(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) external returns (IGOC.ActionResult memory);\\n\\n  // --- READ ---\\n\\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function idToStory(uint16 id) external view returns (uint32 objectId);\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId);\\n\\n  function storyIds(uint32 objectId) external view returns (uint16);\\n\\n  function registeredStories(uint32 objectId) external view returns (bool);\\n\\n}\\n\",\"keccak256\":\"0x7822f79d53590b18455c5d54d91f5b38fabc1330f24ae41db546a785c151e61d\",\"license\":\"BUSL-1.1\"},\"contracts/lib/CalcLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\n\\nlibrary CalcLib {\\n\\n  uint32 public constant MAX_CHANCE = 1e9;\\n\\n  function minI32(int32 a, int32 b) internal pure returns (int32) {\\n    return a < b ? a : b;\\n  }\\n\\n  function max32(int32 a, int32 b) internal pure returns (int32) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function absDiff(int32 a, int32 b) internal pure returns (uint32) {\\n    if (!((a >= 0 && b >= 0) || (a <= 0 && b <= 0))) revert IAppErrors.AbsDiff(a, b);\\n    if (a < 0) {\\n      a = - a;\\n    }\\n    if (b < 0) {\\n      b = - b;\\n    }\\n    return uint32(uint(int(a >= b ? a - b : b - a)));\\n  }\\n\\n  function toUint(int32 n) internal pure returns (uint) {\\n    if (n < 0) {\\n      return 0;\\n    }\\n    if (n <= 0) {\\n      return 0;\\n    }\\n    return uint(int(n));\\n  }\\n\\n  function toInt32(uint a) internal pure returns (int32){\\n    if (a >= uint(int(type(int32).max))) {\\n      return type(int32).max;\\n    }\\n    return int32(int(a));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandom(uint maxValue) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n\\n    uint salt = genSalt();\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), salt))) % (maxValue + 1));\\n  }\\n\\n  function genSalt() internal view returns (uint salt) {\\n    // skale has a RNG Endpoint\\n    if (\\n      block.chainid == uint(1351057110)\\n      || block.chainid == uint(37084624)\\n    ) {\\n      assembly {\\n        let freemem := mload(0x40)\\n        let start_addr := add(freemem, 0)\\n        if iszero(staticcall(gas(), 0x18, 0, 0, start_addr, 32)) {\\n          invalid()\\n        }\\n        salt := mload(freemem)\\n      }\\n    }\\n  }\\n\\n  function pseudoRandomUint32(uint32 maxValue) internal view returns (uint32) {\\n    return uint32(pseudoRandom(uint(maxValue)));\\n  }\\n\\n  /// @notice Generate pseudo-random uint in the range [0..maxValue) using Solady pseudo-random function\\n  function nextPrng(LibPRNG.PRNG memory prng, uint maxValue) internal pure returns (uint) {\\n    return LibPRNG.next(prng) % maxValue;\\n  }\\n\\n  /// @notice pseudoRandomUint32 with customizable pseudoRandom()\\n  function pseudoRandomUint32Flex(\\n    uint32 maxValue,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint32) {\\n    return uint32(random_(uint(maxValue)));\\n  }\\n\\n  function pseudoRandomInt32(int32 maxValue) internal view returns (int32) {\\n    bool neg;\\n    if (maxValue < 0) {\\n      neg = true;\\n      maxValue = - maxValue;\\n    }\\n    uint32 v = uint32(pseudoRandom(uint(int(maxValue))));\\n    return neg\\n      ? - int32(int(uint(v)))\\n      : int32(int(uint(v)));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandomWithSeed(uint maxValue, uint seed) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    uint salt = genSalt();\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), seed, salt))) % (maxValue + 1));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  function pseudoRandomInRange(uint min, uint max) internal view returns (uint) {\\n    if (min >= max) {\\n      return max;\\n    }\\n    uint r = pseudoRandom(max - min);\\n    return min + r;\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  ///      Equal to pseudoRandomInRange(min, max, pseudoRandom)\\n  function pseudoRandomInRangeFlex(\\n    uint min,\\n    uint max,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint) {\\n    return min >= max ? max : min + random_(max - min);\\n  }\\n\\n  function minusWithZeroFloor(uint a, uint b) internal pure returns (uint){\\n    if (a <= b) {\\n      return 0;\\n    }\\n    return a - b;\\n  }\\n\\n  function minusWithMinFloorI32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) - int(b) < type(int32).min) {\\n      return type(int32).min;\\n    }\\n    return a - b;\\n  }\\n\\n  function plusWithMaxFloor32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) + int(b) >= type(int32).max) {\\n      return type(int32).max;\\n    }\\n    return a + b;\\n  }\\n\\n  function sqrt(uint x) internal pure returns (uint z) {\\n    assembly {\\n    // Start off with z at 1.\\n      z := 1\\n\\n    // Used below to help find a nearby power of 2.\\n      let y := x\\n\\n    // Find the lowest power of 2 that is at least sqrt(x).\\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n        y := shr(128, y) // Like dividing by 2 ** 128.\\n        z := shl(64, z) // Like multiplying by 2 ** 64.\\n      }\\n      if iszero(lt(y, 0x10000000000000000)) {\\n        y := shr(64, y) // Like dividing by 2 ** 64.\\n        z := shl(32, z) // Like multiplying by 2 ** 32.\\n      }\\n      if iszero(lt(y, 0x100000000)) {\\n        y := shr(32, y) // Like dividing by 2 ** 32.\\n        z := shl(16, z) // Like multiplying by 2 ** 16.\\n      }\\n      if iszero(lt(y, 0x10000)) {\\n        y := shr(16, y) // Like dividing by 2 ** 16.\\n        z := shl(8, z) // Like multiplying by 2 ** 8.\\n      }\\n      if iszero(lt(y, 0x100)) {\\n        y := shr(8, y) // Like dividing by 2 ** 8.\\n        z := shl(4, z) // Like multiplying by 2 ** 4.\\n      }\\n      if iszero(lt(y, 0x10)) {\\n        y := shr(4, y) // Like dividing by 2 ** 4.\\n        z := shl(2, z) // Like multiplying by 2 ** 2.\\n      }\\n      if iszero(lt(y, 0x8)) {\\n      // Equivalent to 2 ** z.\\n        z := shl(1, z)\\n      }\\n\\n    // Shifting right by 1 is like dividing by 2.\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n\\n    // Compute a rounded down version of z.\\n      let zRoundDown := div(x, z)\\n\\n    // If zRoundDown is smaller, use it.\\n      if lt(zRoundDown, z) {\\n        z := zRoundDown\\n      }\\n    }\\n  }\\n\\n  /*********************************************\\n *              PRB-MATH                      *\\n *   https://github.com/hifi-finance/prb-math *\\n **********************************************/\\n  /// @notice Calculates the binary logarithm of x.\\n  ///\\n  /// @dev Based on the iterative approximation algorithm.\\n  /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n  ///\\n  /// Requirements:\\n  /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n  ///\\n  /// Caveats:\\n  /// - The results are nor perfectly accurate to the last decimal,\\n  ///   due to the lossy precision of the iterative approximation.\\n  ///\\n  /// @param x The unsigned 60.18-decimal fixed-point number for which\\n  ///           to calculate the binary logarithm.\\n  /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n  function log2(uint256 x) internal pure returns (uint256 result) {\\n    if (x < 1e18) revert IAppErrors.TooLowX(x);\\n\\n    // Calculate the integer part of the logarithm\\n    // and add it to the result and finally calculate y = x * 2^(-n).\\n    uint256 n = mostSignificantBit(x / 1e18);\\n\\n    // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number.\\n    // The operation can't overflow because n is maximum 255 and SCALE is 1e18.\\n    uint256 rValue = n * 1e18;\\n\\n    // This is y = x * 2^(-n).\\n    uint256 y = x >> n;\\n\\n    // If y = 1, the fractional part is zero.\\n    if (y == 1e18) {\\n      return rValue;\\n    }\\n\\n    // Calculate the fractional part via the iterative approximation.\\n    // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n    for (uint256 delta = 5e17; delta > 0; delta >>= 1) {\\n      y = (y * y) / 1e18;\\n\\n      // Is y^2 > 2 and so in the range [2,4)?\\n      if (y >= 2 * 1e18) {\\n        // Add the 2^(-m) factor to the logarithm.\\n        rValue += delta;\\n\\n        // Corresponds to z/2 on Wikipedia.\\n        y >>= 1;\\n      }\\n    }\\n    return rValue;\\n  }\\n\\n  /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n  /// @dev See the note on msb in the \\\"Find First Set\\\"\\n  ///      Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n  /// @param x The uint256 number for which to find the index of the most significant bit.\\n  /// @return msb The index of the most significant bit as an uint256.\\n  //noinspection NoReturn\\n  function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n    if (x >= 2 ** 128) {\\n      x >>= 128;\\n      msb += 128;\\n    }\\n    if (x >= 2 ** 64) {\\n      x >>= 64;\\n      msb += 64;\\n    }\\n    if (x >= 2 ** 32) {\\n      x >>= 32;\\n      msb += 32;\\n    }\\n    if (x >= 2 ** 16) {\\n      x >>= 16;\\n      msb += 16;\\n    }\\n    if (x >= 2 ** 8) {\\n      x >>= 8;\\n      msb += 8;\\n    }\\n    if (x >= 2 ** 4) {\\n      x >>= 4;\\n      msb += 4;\\n    }\\n    if (x >= 2 ** 2) {\\n      x >>= 2;\\n      msb += 2;\\n    }\\n    if (x >= 2 ** 1) {\\n      // No need to shift x any more.\\n      msb += 1;\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x5422c2046a6f6e2a009b4999258a5e94b49b8fa60c63e5da431302699205b113\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PackingLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\n\\nlibrary PackingLib {\\n\\n  //////////////////////////\\n  // ---- PACKING LOGIC ----\\n  //////////////////////////\\n\\n  //region ------------------------------------ COMMON\\n\\n  function packNftId(address token, uint id) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert IAppErrors.TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n  }\\n\\n  function unpackNftId(bytes32 data) internal pure returns (address token, uint id) {\\n    token = address(uint160(uint(data)));\\n    id = uint(data) >> 160;\\n  }\\n\\n  function packAddressWithAmount(address token, uint amount) internal pure returns (bytes32 data) {\\n    if (amount > uint(type(uint96).max)) revert IAppErrors.TooHighValue(amount);\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(uint96(amount))) << 160;\\n  }\\n\\n  function unpackAddressWithAmount(bytes32 data) internal pure returns (address token, uint amount) {\\n    token = address(uint160(uint(data)));\\n    amount = uint(data) >> 160;\\n  }\\n\\n  function packItemMintInfo(address item, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(chance)) << 160;\\n  }\\n\\n  function unpackItemMintInfo(bytes32 data) internal pure returns (address item, uint32 chance) {\\n    item = address(uint160(uint(data)));\\n    chance = uint32(uint(data) >> 160);\\n  }\\n\\n  /// @param customDataIndex We assume, that two lowest bytes of this string are always zero\\n  /// So, the string looks like following: 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// Last 2 bytes will be used to encode {value}\\n  function packCustomDataChange(bytes32 customDataIndex, int16 value) internal pure returns (bytes32 data) {\\n    if (uint(customDataIndex) != (uint(customDataIndex) >> 16) << 16) revert IAppErrors.IncompatibleInputString();\\n    data = bytes32(uint(customDataIndex));\\n    data |= bytes32(uint(uint16(value)));\\n  }\\n\\n  function unpackCustomDataChange(bytes32 data) internal pure returns (bytes32 customDataIndex, int16 value) {\\n    customDataIndex = bytes32((uint(data) >> 16) << 16);\\n    value = int16(int(uint(uint16(uint(data)))));\\n  }\\n\\n  /// @dev min(uint64) + max(uint64) + isHeroData/isMandatory(uint8)\\n  function packCustomDataRequirements(uint64 min, uint64 max, bool key) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(min));\\n    data |= bytes32(uint(max)) << 64;\\n    data |= bytes32(uint(key ? uint8(1) : uint8(0))) << (64 + 64);\\n  }\\n\\n  function unpackCustomDataRequirements(bytes32 data) internal pure returns (uint64 min, uint64 max, bool key) {\\n    min = uint64(uint(data));\\n    max = uint64(uint(data) >> 64);\\n    key = uint8(uint(data) >> (64 + 64)) == uint8(1);\\n  }\\n\\n  function packStatsChange(\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(experience));\\n    data |= bytes32(uint(uint32(heal))) << 32;\\n    data |= bytes32(uint(uint32(manaRegen))) << (32 + 32);\\n    data |= bytes32(uint(uint32(lifeChancesRecovered))) << (32 + 32 + 32);\\n    data |= bytes32(uint(uint32(damage))) << (32 + 32 + 32 + 32);\\n    data |= bytes32(uint(uint32(manaConsumed))) << (32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackStatsChange(bytes32 data) internal pure returns (\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) {\\n    experience = uint32(uint(data));\\n    heal = int32(int(uint(data) >> 32));\\n    manaRegen = int32(int(uint(data) >> (32 + 32)));\\n    lifeChancesRecovered = int32(int(uint(data) >> (32 + 32 + 32)));\\n    damage = int32(int(uint(data) >> (32 + 32 + 32 + 32)));\\n    manaConsumed = int32(int(uint(data) >> (32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packNftIdWithValue(address token, uint id, uint32 value) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert IAppErrors.TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n    serialized |= bytes32(uint(value)) << 160 + 64;\\n  }\\n\\n  function unpackNftIdWithValue(bytes32 data) internal pure returns (address token, uint id, uint32 value) {\\n    token = address(uint160(uint(data)));\\n    id = uint64(uint(data) >> 160);\\n    value = uint32(uint(data) >> 160 + 64);\\n  }\\n  //endregion ------------------------------------ COMMON\\n\\n  //region ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(bytes20(objectAddress));\\n    packedData |= bytes32(uint(objectId) << 32);\\n    packedData |= bytes32(uint(objectType) << 24);\\n  }\\n\\n  function unpackMapObject(bytes32 packedData) internal pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\\n    objectAddress = address(bytes20(packedData));\\n    objectId = uint64(uint(packedData) >> 32);\\n    objectType = uint8(uint(packedData) >> 24);\\n  }\\n\\n  function packCoordinate(uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(x));\\n    packedData |= bytes32(uint(y) << 128);\\n  }\\n\\n  function unpackCoordinate(bytes32 packedData) internal pure returns (uint128 x, uint128 y) {\\n    x = uint128(uint(packedData));\\n    y = uint128(uint(packedData) >> 128);\\n  }\\n\\n  /// @param x Assume x <= max uint64\\n  /// @param y Assume y <= max uint64\\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    // 256 => 128 + 128;\\n    // 1) 128 is used for biomeMapFieldId, territoryNumber and probably other fields in the future\\n    // 2) 128 is used to store x, y as uint64, uint64\\n\\n    // we will use uint64 for coordinates assuming it is more than enough for biome map\\n    packedData = bytes32(uint(biomeMapFieldId));\\n    packedData |= bytes32(uint(territoryNumber) << (8));\\n    packedData |= bytes32(uint(uint64(x)) << 128);\\n    packedData |= bytes32(uint(uint64(y)) << (64 + 128));\\n  }\\n\\n  function unpackBattlefieldId(bytes32 packedData) internal pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\\n    biomeMapFieldId = uint8(uint(packedData));\\n    territoryNumber = uint8(uint(packedData) >> (8));\\n    x = uint128(uint64(uint(packedData) >> (128)));\\n    y = uint128(uint64(uint(packedData) >> (64 + 128)));\\n  }\\n  //endregion ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  //region ------------------------------------ REINFORCEMENT\\n\\n  function packReinforcementHeroInfo(uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(biome));\\n    packedData |= bytes32(uint(score) << 8);\\n    packedData |= bytes32(uint(fee) << (8 + 128));\\n    packedData |= bytes32(uint(stakeTs) << (8 + 128 + 8));\\n  }\\n\\n  function unpackReinforcementHeroInfo(bytes32 packedData) internal pure returns (uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) {\\n    biome = uint8(uint(packedData));\\n    score = uint128(uint(packedData) >> 8);\\n    fee = uint8(uint(packedData) >> (8 + 128));\\n    stakeTs = uint64(uint(packedData) >> (8 + 128 + 8));\\n  }\\n\\n  function packConfigReinforcementV2(uint32 min, uint32 max, uint32 lowDivider, uint32 highDivider, uint8 levelLimit) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(min));\\n    packedData |= bytes32(uint(max) << 32);\\n    packedData |= bytes32(uint(lowDivider) << 64);\\n    packedData |= bytes32(uint(highDivider) << 96);\\n    packedData |= bytes32(uint(levelLimit) << 128);\\n  }\\n\\n  function unpackConfigReinforcementV2(bytes32 packedData) internal pure returns (uint32 min, uint32 max, uint32 lowDivider, uint32 highDivider, uint8 levelLimit) {\\n    min = uint32(uint(packedData));\\n    max = uint32(uint(packedData) >> 32);\\n    lowDivider = uint32(uint(packedData) >> 64);\\n    highDivider = uint32(uint(packedData) >> 96);\\n    levelLimit = uint8(uint(packedData) >> 128);\\n  }\\n  //endregion ------------------------------------ REINFORCEMENT\\n\\n  //region ------------------------------------ DUNGEON\\n\\n  function packDungeonKey(address heroAdr, uint80 heroId, uint16 dungLogicNum) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(dungLogicNum)) << (160 + 80);\\n  }\\n\\n  function unpackDungeonKey(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 dungLogicNum) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    dungLogicNum = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  // --- GAME OBJECTS ---\\n\\n  function packIterationKey(address heroAdr, uint64 heroId, uint32 objId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(objId)) << (160 + 64);\\n  }\\n\\n  function unpackIterationKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint32 objId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    objId = uint32(uint(data) >> (160 + 64));\\n  }\\n\\n  function packMonsterStats(\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(level));\\n    data |= bytes32(uint(race)) << 8;\\n    data |= bytes32(uint(experience)) << (8 + 8);\\n    data |= bytes32(uint(maxDropItems)) << (8 + 8 + 32);\\n  }\\n\\n  function unpackMonsterStats(bytes32 data) internal pure returns (\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) {\\n    level = uint8(uint(data));\\n    race = uint8(uint(data) >> 8);\\n    experience = uint32(uint(data) >> (8 + 8));\\n    maxDropItems = uint8(uint(data) >> (8 + 8 + 32));\\n  }\\n\\n  function packAttackInfo(\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(attackToken)));\\n    data |= bytes32(uint(attackTokenId)) << 160;\\n    data |= bytes32(uint(attackType)) << (160 + 64);\\n  }\\n\\n  function unpackAttackInfo(bytes32 data) internal pure returns (\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) {\\n    attackToken = address(uint160(uint(data)));\\n    attackTokenId = uint64(uint(data) >> 160);\\n    attackType = uint8(uint(data) >> (160 + 64));\\n  }\\n\\n  function packPlayedObjKey(address heroAdr, uint64 heroId, uint8 oType, uint8 biome) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(oType)) << (160 + 64);\\n    data |= bytes32(uint(biome)) << (160 + 64 + 8);\\n  }\\n\\n  function unpackPlayedObjKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint8 oType, uint8 biome) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    oType = uint8(uint(data) >> (160 + 64));\\n    biome = uint8(uint(data) >> (160 + 64 + 8));\\n  }\\n\\n  function packGeneratedMonster(bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint8(generated ? 1 : 0)));\\n    data |= bytes32(uint(amplifier)) << 8;\\n    data |= bytes32(uint(uint32(hp))) << (8 + 32);\\n    data |= bytes32(uint(turnCounter)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 data) internal pure returns (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) {\\n    generated = uint8(uint(data)) == uint8(1);\\n    amplifier = uint32(uint(data) >> 8);\\n    hp = int32(int(uint(data) >> (8 + 32)));\\n    turnCounter = uint8(uint(data) >> (8 + 32 + 32));\\n  }\\n  //endregion ------------------------------------ DUNGEON\\n\\n  //region ------------------------------------ ITEMS\\n\\n  /// @notice itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n  /// @param itemType This is ItemType enum\\n  function packItemMeta(\\n    uint8 itemMetaType,\\n    uint8 itemLvl,\\n    uint8 itemType,\\n    uint16 baseDurability,\\n    uint8 defaultRarity,\\n    uint8 minAttr,\\n    uint8 maxAttr,\\n    uint32 manaCost,\\n    IStatController.CoreAttributes memory req\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(itemMetaType));\\n    data |= bytes32(uint(itemLvl)) << 8;\\n    data |= bytes32(uint(itemType)) << (8 + 8);\\n    data |= bytes32(uint(baseDurability)) << (8 + 8 + 8);\\n    data |= bytes32(uint(defaultRarity)) << (8 + 8 + 8 + 16);\\n    data |= bytes32(uint(minAttr)) << (8 + 8 + 8 + 16 + 8);\\n    data |= bytes32(uint(maxAttr)) << (8 + 8 + 8 + 16 + 8 + 8);\\n    data |= bytes32(uint(manaCost)) << (8 + 8 + 8 + 16 + 8 + 8 + 8);\\n    data |= bytes32(uint(int(req.strength))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32);\\n    data |= bytes32(uint(int(req.dexterity))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32);\\n    data |= bytes32(uint(int(req.vitality))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(req.energy))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemMeta(bytes32 data) internal pure returns (IItemController.ItemMeta memory) {\\n    IItemController.ItemMeta memory result;\\n\\n    result.itemMetaType = uint8(uint(data));\\n    result.itemLevel = uint8(uint(data) >> 8);\\n    result.itemType = IItemController.ItemType(uint8(uint(data) >> (8 + 8)));\\n    result.baseDurability = uint16(uint(data) >> (8 + 8 + 8));\\n    result.defaultRarity = uint8(uint(data) >> (8 + 8 + 8 + 16));\\n    result.minRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8));\\n    result.maxRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8));\\n    result.manaCost = uint32(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8));\\n    result.requirements.strength = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32)));\\n    result.requirements.dexterity = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32)));\\n    result.requirements.vitality = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32)));\\n    result.requirements.energy = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32)));\\n\\n    return result;\\n  }\\n\\n  function packItemGenerateInfo(uint8 id, int32 min, int32 max, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(id));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(chance)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32 data) internal pure returns (uint8 id, int32 min, int32 max, uint32 chance) {\\n    id = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    chance = uint32(uint(data) >> (8 + 32 + 32));\\n  }\\n\\n  function packItemAttackInfo(\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attackType));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(int(factorStr))) << (8 + 32 + 32);\\n    data |= bytes32(uint(int(factorDex))) << (8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorVit))) << (8 + 32 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorEng))) << (8 + 32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 data) internal pure returns (\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) {\\n    attackType = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    factorStr = int32(int(uint(data) >> (8 + 32 + 32)));\\n    factorDex = int32(int(uint(data) >> (8 + 32 + 32 + 32)));\\n    factorVit = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32)));\\n    factorEng = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packItemInfo(uint8 rarity, uint8 augmentationLevel, uint16 durability) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(rarity));\\n    data |= bytes32(uint(augmentationLevel)) << 8;\\n    data |= bytes32(uint(durability)) << (8 + 8);\\n  }\\n\\n  function unpackItemInfo(bytes32 data) internal pure returns (uint8 rarity, uint8 augmentationLevel, uint16 durability) {\\n    rarity = uint8(uint(data));\\n    augmentationLevel = uint8(uint(data) >> 8);\\n    durability = uint16(uint(data) >> (8 + 8));\\n  }\\n  //endregion ------------------------------------ ITEMS\\n\\n  //region ------------------------------------ STORIES\\n\\n  function packStoryPageId(uint16 storyId, uint16 pageId, uint8 heroClass) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n  }\\n\\n  function unpackStoryPageId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n  }\\n\\n  function packStoryAnswerId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n  }\\n\\n  function unpackStoryAnswerId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n  }\\n\\n  function packStoryNextPagesId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(resultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryNextPagesId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    resultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryAttributeRequirement(uint8 attributeIndex, int32 value, bool isCore) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attributeIndex));\\n    data |= bytes32(uint(uint32(value))) << 8;\\n    data |= bytes32(uint(isCore ? uint8(1) : uint8(0))) << (8 + 32);\\n  }\\n\\n  function unpackStoryAttributeRequirement(bytes32 data) internal pure returns (uint8 attributeIndex, int32 value, bool isCore) {\\n    attributeIndex = uint8(uint(data));\\n    value = int32(int(uint(data) >> 8));\\n    isCore = uint8(uint(data) >> (8 + 32)) == uint8(1);\\n  }\\n\\n  function packStoryItemRequirement(address item, bool requireItemBurn, bool requireItemEquipped) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(requireItemBurn ? uint8(1) : uint8(0))) << 160;\\n    data |= bytes32(uint(requireItemEquipped ? uint8(1) : uint8(0))) << (160 + 8);\\n  }\\n\\n  function unpackStoryItemRequirement(bytes32 data) internal pure returns (address item, bool requireItemBurn, bool requireItemEquipped) {\\n    item = address(uint160(uint(data)));\\n    requireItemBurn = uint8(uint(data) >> 160) == uint8(1);\\n    requireItemEquipped = uint8(uint(data) >> (160 + 8)) == uint8(1);\\n  }\\n\\n  /// @dev max amount is 309,485,009 for token with 18 decimals\\n  function packStoryTokenRequirement(address token, uint88 amount, bool requireTransfer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(amount)) << 160;\\n    data |= bytes32(uint(requireTransfer ? uint8(1) : uint8(0))) << (160 + 88);\\n  }\\n\\n  function unpackStoryTokenRequirement(bytes32 data) internal pure returns (address token, uint88 amount, bool requireTransfer) {\\n    token = address(uint160(uint(data)));\\n    amount = uint88(uint(data) >> 160);\\n    requireTransfer = uint8(uint(data) >> (160 + 88)) == uint8(1);\\n  }\\n\\n  function packStoryCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(customDataResultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryCustomDataResult(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    customDataResultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryHeroState(uint16 pageId, uint40 heroLastActionTS) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(pageId));\\n    data |= bytes32(uint(heroLastActionTS)) << 16;\\n  }\\n\\n  function unpackStoryHeroState(bytes32 data) internal pure returns (uint16 pageId, uint40 heroLastActionTS) {\\n    pageId = uint16(uint(data));\\n    heroLastActionTS = uint40(uint(data) >> 16);\\n  }\\n\\n  function packStoryHeroStateId(address heroAdr, uint80 heroId, uint16 storyId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(storyId)) << (160 + 80);\\n  }\\n\\n  function unpackStoryHeroStateId(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 storyId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    storyId = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  function packStorySimpleRequirement(uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(randomRequirement));\\n    data |= bytes32(uint(delayRequirement)) << 32;\\n    data |= bytes32(uint(isFinalAnswer ? uint8(1) : uint8(0))) << (32 + 32);\\n  }\\n\\n  function unpackStorySimpleRequirement(bytes32 data) internal pure returns (uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) {\\n    randomRequirement = uint32(uint(data));\\n    delayRequirement = uint32(uint(data) >> 32);\\n    isFinalAnswer = uint8(uint(data) >> (32 + 32)) == uint8(1);\\n  }\\n\\n  function packBreakInfo(uint8 slot, uint64 chance, bool stopIfBroken) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(slot));\\n    data |= bytes32(uint(chance)) << 8;\\n    data |= bytes32(uint(stopIfBroken ? uint8(1) : uint8(0))) << (8 + 64);\\n  }\\n\\n  function unpackBreakInfo(bytes32 data) internal pure returns (uint8 slot, uint64 chance, bool stopIfBurned) {\\n    slot = uint8(uint(data));\\n    chance = uint64(uint(data) >> 8);\\n    stopIfBurned = uint8(uint(data) >> (8 + 64)) == uint8(1);\\n  }\\n  //endregion ------------------------------------ STORIES\\n\\n  //region ------------------------------------ Hero controller\\n  function packTierHero(uint8 tier, address hero) internal pure returns (bytes32 packedTierHero) {\\n    packedTierHero = bytes32(uint(tier));\\n    packedTierHero |= bytes32(uint(uint160(hero)) << 8);\\n  }\\n\\n  function unpackTierHero(bytes32 packedTierHero) internal pure returns (uint8 tier, address hero) {\\n    tier = uint8(uint(packedTierHero));\\n    hero = address(uint160(uint(packedTierHero) >> 8));\\n  }\\n\\n  //endregion ------------------------------------ Hero controller\\n\\n  ////////////////////////////////////////////////////////////////////////////////////\\n  // ---- ARRAYS LOGIC ----\\n  ////////////////////////////////////////////////////////////////////////////////////\\n\\n  //region ------------------------------------ SIMPLE ARRAYS\\n\\n\\n  function packUint8Array(uint8[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 32) revert IAppErrors.OutOfBounds(len, 32);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 8);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {packUint8Array} for small number of items\\n  ///         It allows to exclude dynamic array creation.\\n  function packUint8Array3(uint8 a, uint8 b, uint8 c) internal pure returns (bytes32) {\\n    bytes32 result = bytes32(uint(a));\\n    result |= bytes32(uint(b)) << (1 * 8);\\n    result |= bytes32(uint(c)) << (2 * 8);\\n    return result;\\n  }\\n\\n\\n  function unpackUint8Array(bytes32 data) internal pure returns (uint8[] memory) {\\n    uint8[] memory result = new uint8[](32);\\n    for (uint i = 0; i < 32; i++) {\\n      result[i] = uint8(uint(data) >> (i * 8));\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {unpackUint8Array} for small number of items\\n  ///         It allows to exclude only first 3 values\\n  function unpackUint8Array3(bytes32 data) internal pure returns (uint8 a, uint8 b, uint8 c) {\\n    a = uint8(uint(data));\\n    b = uint8(uint(data) >> (1 * 8));\\n    c = uint8(uint(data) >> (2 * 8));\\n  }\\n\\n  function changeUnit8ArrayWithCheck(bytes32 data, uint index, uint8 value, uint8 expectedPrevValue) internal pure returns (bytes32 newData) {\\n    uint8[] memory arr = unpackUint8Array(data);\\n    if (arr[index] != expectedPrevValue) revert IAppErrors.UnexpectedValue(uint(expectedPrevValue), uint(arr[index]));\\n    arr[index] = value;\\n    return packUint8Array(arr);\\n  }\\n\\n  function packInt32Array(int32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert IAppErrors.OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i; i < len; i++) {\\n      result |= bytes32(uint(uint32(data[i]))) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackInt32Array(bytes32 data) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = int32(int(uint(data) >> (i * 32)));\\n    }\\n    return result;\\n  }\\n\\n  function packUint32Array(uint32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert IAppErrors.OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackUint32Array(bytes32 data) internal pure returns (uint32[] memory) {\\n    uint32[] memory result = new uint32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = uint32(uint(data) >> (i * 32));\\n    }\\n    return result;\\n  }\\n  //endregion ------------------------------------ SIMPLE ARRAYS\\n\\n  //region ------------------------------------ COMPLEX ARRAYS\\n\\n  // We should represent arrays without concrete size.\\n  // For this reason we must not revert IAppErrors.on out of bounds but return zero value instead.\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getInt32AsInt24(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n//    if (idx / 8 >= arr.length) {\\n//      return int32(0);\\n//    }\\n//    return int32(int24(int(uint(arr[idx / 8]) >> ((idx % 8) * 32))));\\n//  }\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getUnit8From32Step(bytes32[] memory arr, uint idx) internal pure returns (uint8) {\\n//    if (idx / 8 >= arr.length) {\\n//      return uint8(0);\\n//    }\\n//    return uint8(uint(arr[idx / 8]) >> ((idx % 8) * 32 + 24));\\n//  }\\n\\n  function getInt32Memory(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function getInt32(bytes32[] storage arr, uint idx) internal view returns (int32) {\\n    // additional gas usage, but we should not revert IAppErrors.on out of bounds\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function setInt32(bytes32[] storage arr, uint idx, int32 value) internal {\\n    uint pos = idx / 8;\\n    uint shift = (idx % 8) * 32;\\n\\n    uint curLength = arr.length;\\n    if (pos >= curLength) {\\n      arr.push(0);\\n      for (uint i = curLength; i < pos; ++i) {\\n        arr.push(0);\\n      }\\n    }\\n\\n    arr[pos] = bytes32(uint(arr[pos]) & ~(uint(0xffffffff) << shift) | (uint(uint32(value)) & 0xffffffff) << shift);\\n  }\\n\\n  /// @notice Increment {idx}-th item on {value}\\n  function changeInt32(bytes32[] storage arr, uint idx, int32 value) internal returns (int32 newValue, int32 change) {\\n    int32 cur = int32(int(getInt32(arr, idx)));\\n    int newValueI = int(cur) + int(value);\\n    newValue = int32(newValueI);\\n    change = int32(newValueI - int(cur));\\n\\n    setInt32(arr, idx, newValue);\\n  }\\n\\n  function toInt32Array(bytes32[] memory arr, uint size) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](size);\\n    for (uint i = 0; i < arr.length; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= size) break;\\n        result[idx] = getInt32Memory(arr, idx);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array\\n  function toBytes32Array(int32[] memory arr) internal pure returns (bytes32[] memory) {\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n        result[i] |= bytes32(uint(uint32(arr[idx]))) << (j * 32);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array using last 8bytes for ids\\n  ///      we can not use zero values coz will not able to properly unpack it later\\n  function toBytes32ArrayWithIds(int32[] memory arr, uint8[] memory ids) internal pure returns (bytes32[] memory) {\\n    if (arr.length != ids.length) revert IAppErrors.LengthsMismatch();\\n\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n\\n        if (arr[idx] > type(int24).max || arr[idx] < type(int24).min) revert IAppErrors.IntOutOfRange(int(arr[idx]));\\n        if (arr[idx] == 0) revert IAppErrors.ZeroValue();\\n        result[i] |= bytes32(uint(uint24(int24(arr[idx])))) << (j * 32);\\n        result[i] |= bytes32(uint(ids[idx])) << (j * 32 + 24);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev we do not know exact size of array, assume zero values is not acceptable for this array\\n  function toInt32ArrayWithIds(bytes32[] memory arr) internal pure returns (int32[] memory values, uint8[] memory ids) {\\n    uint len = arr.length;\\n    uint size = len * 8;\\n    int32[] memory valuesTmp = new int32[](size);\\n    uint8[] memory idsTmp = new uint8[](size);\\n    uint counter;\\n    for (uint i = 0; i < len; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        // if (idx >= size) break;  // it looks like a useless check\\n        valuesTmp[idx] = int32(int24(int(uint(arr[i]) >> (j * 32)))); // getInt32AsInt24(arr, idx);\\n        idsTmp[idx] = uint8(uint(arr[i]) >> (j * 32 + 24)); // getUnit8From32Step(arr, idx);\\n        if (valuesTmp[idx] == 0) {\\n          break;\\n        }\\n        counter++;\\n      }\\n    }\\n\\n    values = new int32[](counter);\\n    ids = new uint8[](counter);\\n    for (uint i; i < counter; ++i) {\\n      values[i] = valuesTmp[i];\\n      ids[i] = idsTmp[i];\\n    }\\n  }\\n  //endregion ------------------------------------ COMPLEX ARRAYS\\n\\n  //region ------------------------------------ Guilds\\n  /// @dev ShelterID is uint. But in the code we assume that this ID can be stored as uint64 (see auctions)\\n  /// @param biome 1, 2, 3...\\n  /// @param shelterLevel 1, 2 or 3.\\n  /// @param shelterIndex 0, 1, 2 ...\\n  function packShelterId(uint8 biome, uint8 shelterLevel, uint8 shelterIndex) internal pure returns (uint) {\\n    return uint(biome) | (uint(shelterLevel) << 8) | (uint(shelterIndex) << 16);\\n  }\\n\\n  function unpackShelterId(uint shelterId) internal pure returns (uint8 biome, uint8 shelterLevel, uint8 shelterIndex) {\\n    return (uint8(shelterId), uint8(shelterId >> 8), uint8(shelterId >> 16));\\n  }\\n  //endregion ------------------------------------ Guilds\\n\\n  //region ------------------------------------ Metadata of IItemController.OtherSubtypeKind\\n\\n  function getOtherItemTypeKind(bytes memory packedData) internal pure returns (IItemController.OtherSubtypeKind) {\\n    bytes32 serialized;\\n    assembly {\\n      serialized := mload(add(packedData, 32))\\n    }\\n    uint8 kind = uint8(uint(serialized));\\n    if (kind == 0 || kind >= uint8(IItemController.OtherSubtypeKind.END_SLOT)) revert IAppErrors.IncorrectOtherItemTypeKind(kind);\\n    return IItemController.OtherSubtypeKind(kind);\\n  }\\n\\n  function packOtherItemReduceFragility(uint value) internal pure returns (bytes memory packedData) {\\n    bytes32 serialized = bytes32(uint(uint8(IItemController.OtherSubtypeKind.REDUCE_FRAGILITY_1)));\\n    serialized |= bytes32(uint(uint248(value))) << 8;\\n    return bytes.concat(serialized);\\n  }\\n\\n  function unpackOtherItemReduceFragility(bytes memory packedData) internal pure returns (uint) {\\n    bytes32 serialized;\\n    assembly {\\n      serialized := mload(add(packedData, 32))\\n    }\\n    uint8 kind = uint8(uint(serialized));\\n    if (kind != uint8(IItemController.OtherSubtypeKind.REDUCE_FRAGILITY_1)) revert IAppErrors.IncorrectOtherItemTypeKind(kind);\\n    uint value = uint248(uint(serialized) >> 8);\\n    return value;\\n  }\\n  //endregion ------------------------------------ Metadata of IItemController.OtherSubtypeKind\\n}\\n\",\"keccak256\":\"0xad88fc3fd2d436b3593cfbd2e19a838bfa73c5eaf31838ea2bdf9c84de38b65f\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StatLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\n\\nlibrary StatLib {\\n  using PackingLib for bytes32[];\\n  using PackingLib for bytes32;\\n  using PackingLib for uint32[];\\n  using PackingLib for int32[];\\n  using CalcLib for int32;\\n\\n  //region --------------------------- Constants\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant STAT_LIB_VERSION = \\\"1.0.0\\\";\\n  uint32 public constant MAX_LEVEL = 99;\\n\\n  uint public constant BASE_EXPERIENCE = 100_000;\\n  uint public constant BIOME_LEVEL_STEP = 5;\\n  uint internal constant _MAX_AMPLIFIER = 1e18;\\n  uint private constant _PRECISION = 1e18;\\n  uint private constant VIRTUAL_LEVEL_GAP = 2;\\n\\n  /// @dev Assume MAX_BIOME * BIOME_LEVEL_STEP < MAX_LEVEL + 1, see dungeonTreasuryReward\\n  uint public constant MAX_POSSIBLE_BIOME = 19;\\n  //endregion --------------------------- Constants\\n\\n  //region --------------------------- Data types\\n\\n  struct BaseMultiplier {\\n    uint minDamage;\\n    uint maxDamage;\\n    uint attackRating;\\n    uint defense;\\n    uint blockRating;\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct LevelUp {\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct InitialHero {\\n    IStatController.CoreAttributes core;\\n    BaseMultiplier multiplier;\\n    LevelUp levelUp;\\n    int32 baseLifeChances;\\n  }\\n\\n  enum HeroClasses {\\n    UNKNOWN,\\n    THRALL,\\n    SAVAGE,\\n    MAGE,\\n    ASSASSIN,\\n    GHOST,\\n    HAMMERGINA,\\n    END_SLOT\\n  }\\n  //endregion --------------------------- Data types\\n\\n  //region --------------------------- BASE\\n\\n  function isNetworkWithOldSavage() public view returns (bool) {\\n    return block.chainid == uint(111188) || block.chainid == uint(250);\\n  }\\n\\n  // --- HERO 1 (Slave) ---\\n\\n  function initialHero1() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 15,\\n      vitality: 30,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 2e18,\\n      blockRating: 0.1e18,\\n      life: 1.5e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 2e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 2 (Spata) ---\\n\\n  function initialHero2() internal view returns (InitialHero memory) {\\n\\n    bool old = isNetworkWithOldSavage();\\n\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 30,\\n      dexterity: 5,\\n      vitality: 25,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: old ? 0.25e18 : 0.5e18,\\n      attackRating: old ? 2e18 : 3e18,\\n      defense: 1e18,\\n      blockRating: 0.08e18,\\n      life: 1.3e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.8e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 3 (Decidia) ---\\n\\n  function initialHero3() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 10,\\n      dexterity: 15,\\n      vitality: 20,\\n      energy: 25\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 1e18,\\n      blockRating: 0.1e18,\\n      life: 1e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.3e18,\\n      mana: 2e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 4 (Innatus) ---\\n\\n  function initialHero4() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 25,\\n      vitality: 15,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 4e18,\\n      defense: 3e18,\\n      blockRating: 0.2e18,\\n      life: 1.2e18,\\n      mana: 1e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 5 (F2P) ---\\n\\n  function initialHero5() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 20,\\n      dexterity: 20,\\n      vitality: 20,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: 0.25e18,\\n      attackRating: 3e18,\\n      defense: 2.5e18,\\n      blockRating: 0.15e18,\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // --- HERO 6 (F2P) HAMMERGINA ---\\n\\n  function initialHero6() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 50,\\n      dexterity: 30,\\n      vitality: 50,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.2e18,\\n      maxDamage: 0.3e18,\\n      attackRating: 5e18,\\n      defense: 3e18,\\n      blockRating: 0.15e18,\\n      life: 2e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // ------\\n\\n  function initialHero(uint heroClass) internal view returns (InitialHero memory) {\\n    if (heroClass == 1) {\\n      return initialHero1();\\n    } else if (heroClass == 2) {\\n      return initialHero2();\\n    } else if (heroClass == 3) {\\n      return initialHero3();\\n    } else if (heroClass == 4) {\\n      return initialHero4();\\n    } else if (heroClass == 5) {\\n      return initialHero5();\\n    } else if (heroClass == 6) {\\n      return initialHero6();\\n    } else {\\n      revert IAppErrors.UnknownHeroClass(heroClass);\\n    }\\n  }\\n  //endregion --------------------------- BASE\\n\\n  //region --------------------------- CALCULATIONS\\n\\n  function minDamage(int32 strength, uint heroClass) internal view returns (int32) {\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.minDamage / _PRECISION));\\n  }\\n\\n  function maxDamage(int32 strength, uint heroClass) internal view returns (int32){\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.maxDamage / _PRECISION));\\n  }\\n\\n  function attackRating(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.attackRating / _PRECISION));\\n  }\\n\\n  function defense(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.defense / _PRECISION));\\n  }\\n\\n  function blockRating(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(Math.min((dexterity.toUint() * initialHero(heroClass).multiplier.blockRating / _PRECISION), 75)));\\n  }\\n\\n  function life(int32 vitality, uint heroClass, uint32 level) internal view returns (int32){\\n    return int32(int(\\n      (vitality.toUint() * initialHero(heroClass).multiplier.life / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.life / _PRECISION)\\n    ));\\n  }\\n\\n  function mana(int32 energy, uint heroClass, uint32 level) internal view returns (int32){\\n    return int32(int(\\n      (energy.toUint() * initialHero(heroClass).multiplier.mana / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.mana / _PRECISION)\\n    ));\\n  }\\n\\n  function lifeChances(uint heroClass, uint32 /*level*/) internal view returns (int32){\\n    return initialHero(heroClass).baseLifeChances;\\n  }\\n\\n  function levelExperience(uint32 level) internal pure returns (uint32) {\\n    if (level == 0 || level >= MAX_LEVEL) {\\n      return 0;\\n    }\\n    return uint32(uint(level) * BASE_EXPERIENCE * (67e17 - CalcLib.log2((uint(MAX_LEVEL - level + 2)) * 1e18)) / 1e18);\\n  }\\n\\n  function chanceToHit(\\n    uint attackersAttackRating,\\n    uint defendersDefenceRating,\\n    uint attackersLevel,\\n    uint defendersLevel,\\n    uint arFactor\\n  ) internal pure returns (uint) {\\n    attackersAttackRating += attackersAttackRating * arFactor / 100;\\n    uint x = Math.max(attackersAttackRating, 1);\\n    uint y = Math.max(attackersAttackRating + defendersDefenceRating, 1);\\n    uint z = attackersLevel;\\n    uint k = defendersLevel / 2;\\n    uint xy = x * 1e18 / y;\\n    uint zk = z * 1e18 / (attackersLevel + k);\\n    uint base = 2 * xy * zk / 1e18;\\n    return Math.max(Math.min(base, 0.95e18), 0.2e18);\\n  }\\n\\n  function experienceToVirtualLevel(uint experience, uint startFromLevel) internal pure returns (uint level) {\\n    level = startFromLevel;\\n    for (; level < MAX_LEVEL;) {\\n      if (levelExperience(uint32(level)) >= (experience + 1)) {\\n        break;\\n      }\\n      unchecked{++level;}\\n    }\\n  }\\n\\n  function expPerMonster(uint32 monsterExp, uint monsterRarity, uint32 /*heroExp*/, uint32 /*heroCurrentLvl*/, uint /*monsterBiome*/) internal pure returns (uint32) {\\n    // do not reduce exp per level, it is no economical sense\\n    return uint32(uint(monsterExp) + uint(monsterExp) * monsterRarity / _MAX_AMPLIFIER);\\n  }\\n\\n  /// @notice Allow to calculate delta param for {mintDropChance}\\n  function mintDropChanceDelta(uint heroCurrentExp, uint heroCurrentLevel, uint monsterBiome) internal pure returns (uint) {\\n    uint heroBiome = getVirtualLevel(heroCurrentExp, heroCurrentLevel, true) / StatLib.BIOME_LEVEL_STEP + 1;\\n    return heroBiome > monsterBiome ? 2 ** (heroBiome - monsterBiome + 10) : 0;\\n  }\\n\\n  function getVirtualLevel(uint heroCurrentExp, uint heroCurrentLevel, bool withGap) internal pure returns (uint) {\\n    uint virtualLevel = StatLib.experienceToVirtualLevel(heroCurrentExp, heroCurrentLevel);\\n    if (withGap && (virtualLevel + 1) > VIRTUAL_LEVEL_GAP) {\\n      virtualLevel -= VIRTUAL_LEVEL_GAP;\\n    }\\n    return virtualLevel;\\n  }\\n\\n  function initAttributes(\\n    bytes32[] storage attributes,\\n    uint heroClass,\\n    uint32 level,\\n    IStatController.CoreAttributes memory base\\n  ) internal returns (uint32[] memory result) {\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.STRENGTH), base.strength);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEXTERITY), base.dexterity);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.VITALITY), base.vitality);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ENERGY), base.energy);\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN), minDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX), maxDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING), attackRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE), defense(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING), blockRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE), life(base.vitality, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA), mana(base.energy, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE_CHANCES), lifeChances(heroClass, level));\\n\\n    result = new uint32[](3);\\n    result[0] = uint32(life(base.vitality, heroClass, level).toUint());\\n    result[1] = uint32(mana(base.energy, heroClass, level).toUint());\\n    result[2] = uint32(lifeChances(heroClass, uint32(level)).toUint());\\n  }\\n\\n  function updateCoreDependAttributesInMemory(\\n    int32[] memory attributes,\\n    int32[] memory bonus,\\n    uint heroClass,\\n    uint32 level\\n  ) internal view returns (int32[] memory) {\\n    int32 strength = attributes[uint(IStatController.ATTRIBUTES.STRENGTH)];\\n    int32 dexterity = attributes[uint(IStatController.ATTRIBUTES.DEXTERITY)];\\n    int32 vitality = attributes[uint(IStatController.ATTRIBUTES.VITALITY)];\\n    int32 energy = attributes[uint(IStatController.ATTRIBUTES.ENERGY)];\\n\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] = minDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)];\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] = maxDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)];\\n    attributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] = attackRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.ATTACK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.DEFENSE)] = defense(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DEFENSE)];\\n    attributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] = blockRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.BLOCK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.LIFE)] = life(vitality, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.LIFE)];\\n    attributes[uint(IStatController.ATTRIBUTES.MANA)] = mana(energy, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.MANA)];\\n    return attributes;\\n  }\\n\\n  function updateCoreDependAttributes(\\n    IController controller,\\n    bytes32[] storage attributes,\\n    bytes32[] storage bonusMain,\\n    bytes32[] storage bonusExtra,\\n    IStatController.ChangeableStats memory _heroStats,\\n    uint index,\\n    address heroToken,\\n    int32 base\\n  ) internal {\\n    uint heroClass = IHeroController(controller.heroController()).heroClass(heroToken);\\n    if (index == uint(IStatController.ATTRIBUTES.STRENGTH)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN),\\n        StatLib.minDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n      );\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX),\\n        StatLib.maxDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.DEXTERITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING),\\n        StatLib.attackRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE),\\n        StatLib.defense(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING),\\n        StatLib.blockRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.VITALITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE),\\n        StatLib.life(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.ENERGY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA),\\n        StatLib.mana(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n      );\\n    }\\n  }\\n\\n  function attributesAdd(int32[] memory base, int32[] memory add) internal pure returns (int32[] memory) {\\n    unchecked{\\n      for (uint i; i < base.length; ++i) {\\n        base[i] += add[i];\\n      }\\n    }\\n    return base;\\n  }\\n\\n// Currently this function is not used\\n//  function attributesRemove(int32[] memory base, int32[] memory remove) internal pure returns (int32[] memory) {\\n//    unchecked{\\n//      for (uint i; i < base.length; ++i) {\\n//        base[i] = CalcLib.minusWithMinFloorI32(base[i], remove[i]);\\n//      }\\n//    }\\n//    return base;\\n//  }\\n\\n  function packChangeableStats(IStatController.ChangeableStats memory stats) internal pure returns (bytes32) {\\n    uint32[] memory cData = new uint32[](5);\\n    cData[0] = stats.level;\\n    cData[1] = stats.experience;\\n    cData[2] = stats.life;\\n    cData[3] = stats.mana;\\n    cData[4] = stats.lifeChances;\\n\\n    return cData.packUint32Array();\\n  }\\n\\n  function unpackChangeableStats(bytes32 data) internal pure returns (IStatController.ChangeableStats memory result) {\\n    uint32[] memory cData = data.unpackUint32Array();\\n    return IStatController.ChangeableStats({\\n      level: cData[0],\\n      experience: cData[1],\\n      life: cData[2],\\n      mana: cData[3],\\n      lifeChances: cData[4]\\n    });\\n  }\\n\\n  function bytesToFullAttributesArray(bytes32[] memory attributes) internal pure returns (int32[] memory result) {\\n    (int32[] memory values, uint8[] memory ids) = attributes.toInt32ArrayWithIds();\\n    return valuesToFullAttributesArray(values, ids);\\n  }\\n\\n  function valuesToFullAttributesArray(int32[] memory values, uint8[] memory ids) internal pure returns (int32[] memory result) {\\n    result = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < values.length; ++i) {\\n      int32 value = values[i];\\n      if (value != 0) {\\n        result[ids[i]] = value;\\n      }\\n    }\\n  }\\n  //endregion --------------------------- CALCULATIONS\\n\\n}\\n\",\"keccak256\":\"0x126da898025ed4460ae137e05192ecfb9ad76b7c8da8578d39da8278d4a75aa6\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StorySetupLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\nimport \\\"../lib/StatLib.sol\\\";\\n\\nlibrary StorySetupLib {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n  using PackingLib for bytes32;\\n  using PackingLib for uint16;\\n  using PackingLib for uint8;\\n  using PackingLib for address;\\n  using PackingLib for uint32[];\\n  using PackingLib for uint32;\\n  using PackingLib for uint64;\\n  using PackingLib for int32[];\\n  using PackingLib for int32;\\n\\n  //region ------------------ Data types\\n  struct RemoveStoryContext {\\n    uint8 heroClass;\\n    uint8 answerResultId;\\n    uint8 customDataResultId;\\n    uint16 storyId;\\n    uint16 pageId;\\n    uint16 answerNum;\\n    uint len;\\n    uint[] tmpPages;\\n    bytes32 answerId;\\n    bytes32[] tmpAnswers;\\n  }\\n  //endregion ------------------ Data types\\n\\n  //region ------------------ Set story fields\\n\\n  function setAllStoryFields(IStoryController.MainState storage s, IStoryController.StoryMetaInfo memory meta) external {\\n    setBurnItemsMeta(s, meta.storyId, meta.answerBurnRandomItemMeta);\\n    setNextObjRewriteMeta(s, meta.storyId, meta.nextObjRewriteMeta);\\n    setAnswersMeta(\\n      s,\\n      meta.storyId,\\n      meta.answersMeta.answerPageIds,\\n      meta.answersMeta.answerHeroClasses,\\n      meta.answersMeta.answerIds\\n    );\\n    setAnswerNextPageMeta(s, meta.storyId, meta.answerNextPage);\\n    setAnswerAttributeRequirements(s, meta.storyId, meta.answerAttributeRequirements);\\n    setAnswerItemRequirements(s, meta.storyId, meta.answerItemRequirements);\\n    setAnswerTokenRequirementsMeta(s, meta.storyId, meta.answerTokenRequirements);\\n    setAnswerAttributes(s, meta.storyId, meta.answerAttributes);\\n    setAnswerHeroCustomDataRequirementMeta(s, meta.storyId, meta.answerHeroCustomDataRequirement);\\n    setAnswerGlobalCustomDataRequirementMeta(s, meta.storyId, meta.answerGlobalCustomDataRequirement);\\n\\n    setSuccessInfo(s, meta.storyId, meta.successInfo);\\n    setFailInfo(s, meta.storyId, meta.failInfo);\\n\\n    setCustomDataResult(s, meta.storyId, meta.successHeroCustomData, IStoryController.CustomDataResult.HERO_SUCCESS);\\n    setCustomDataResult(s, meta.storyId, meta.failHeroCustomData, IStoryController.CustomDataResult.HERO_FAIL);\\n    setCustomDataResult(s, meta.storyId, meta.successGlobalCustomData, IStoryController.CustomDataResult.GLOBAL_SUCCESS);\\n    setCustomDataResult(s, meta.storyId, meta.failGlobalCustomData, IStoryController.CustomDataResult.GLOBAL_FAIL);\\n\\n    setStoryCustomDataRequirements(\\n      s,\\n      meta.storyId,\\n      meta.requiredCustomDataIndex,\\n      meta.requiredCustomDataMinValue,\\n      meta.requiredCustomDataMaxValue,\\n      meta.requiredCustomDataIsHero,\\n      meta.minLevel\\n    );\\n\\n  }\\n\\n  /// @dev Since SIP-003 the burning is replaced by breaking\\n  function setBurnItemsMeta(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    IStoryController.AnswerBurnRandomItemMeta memory meta\\n  ) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n\\n          bytes32[] storage answersBurn = s.burnItem[answerPackedId];\\n\\n          for (uint j; j < meta.slots[i].length; ++j) {\\n            bytes32 d = meta.slots[i][j].packBreakInfo(meta.chances[i][j], meta.isStopIfBurnt[i][j]);\\n            if (d != bytes32(0)) {\\n              answersBurn.push(d);\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetBurnItemsMeta(storyId, meta);\\n  }\\n\\n  function setNextObjRewriteMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.NextObjRewriteMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.nextObjPageIds.length;\\n      for (uint i; i < len; ++i) {\\n        registerPage(s, storyId, meta.nextObjPageIds[i]);\\n        bytes32 id = storyId.packStoryPageId(meta.nextObjPageIds[i], meta.nextObjHeroClasses[i]);\\n        s.nextObjectsRewrite[id] = meta.nextObjIds[i];\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetNextObjRewriteMeta(storyId, meta);\\n  }\\n\\n  function setAnswersMeta(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    uint16[] memory answerPageIds,\\n    uint8[] memory answerHeroClasses,\\n    uint16[] memory answerIds\\n  ) public {\\n    unchecked {\\n      uint len = answerPageIds.length;\\n      for (uint i; i < len; ++i) {\\n        registerPage(s, storyId, answerPageIds[i]);\\n\\n        bytes32[] storage answersHashes = s.answers[storyId.packStoryPageId(answerPageIds[i], answerHeroClasses[i])];\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, answerPageIds[i], answerHeroClasses[i], answerIds[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          answersHashes.push(answerPackedId);\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswersMeta(storyId, answerPageIds, answerHeroClasses, answerIds);\\n  }\\n\\n  function setAnswerNextPageMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerNextPageMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          bytes32 pagePackedId = storyId.packStoryNextPagesId(\\n            meta.pageId[i],\\n            meta.heroClass[i],\\n            meta.answerId[i],\\n            meta.answerResultIds[i]\\n          );\\n          // pagePackedId cannot be 0 here because answerPackedId is not 0\\n          s.nextPageIds[pagePackedId] = meta.answerNextPageIds[i];\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswerNextPageMeta(storyId, meta);\\n  }\\n\\n  function setAnswerAttributeRequirements(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerAttributeRequirementsMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          bytes32[] storage attrs = s.attributeRequirements[answerPackedId];\\n\\n          for (uint j; j < meta.cores[i].length; ++j) {\\n            bytes32 attributeRequirementsPacked = meta.ids[i][j].packStoryAttributeRequirement(\\n              meta.values[i][j],\\n              meta.cores[i][j]\\n            );\\n\\n            if (attributeRequirementsPacked != bytes32(0)) {\\n              attrs.push(attributeRequirementsPacked);\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswerAttributeRequirements(storyId, meta);\\n  }\\n\\n  function setAnswerItemRequirements(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerItemRequirementsMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          bytes32[] storage attrs = s.itemRequirements[answerPackedId];\\n\\n          for (uint j; j < meta.requireItems[i].length; ++j) {\\n            bytes32 d = meta.requireItems[i][j].packStoryItemRequirement(\\n              meta.requireItemBurn[i][j],\\n              meta.requireItemEquipped[i][j]);\\n\\n            if (d != bytes32(0)) {\\n              attrs.push(d);\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswerItemRequirements(storyId, meta);\\n  }\\n\\n  function setAnswerTokenRequirementsMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerTokenRequirementsMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          bytes32[] storage attrs = s.tokenRequirements[answerPackedId];\\n\\n          for (uint j; j < meta.requireToken[i].length; ++j) {\\n            bytes32 d = meta.requireToken[i][j].packStoryTokenRequirement(\\n              meta.requireAmount[i][j],\\n              meta.requireTransfer[i][j]\\n            );\\n            if (d != bytes32(0)) {\\n              attrs.push(d);\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswerTokenRequirementsMeta(storyId, meta);\\n  }\\n\\n  function setAnswerAttributes(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerAttributesMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          bytes32 data = meta.randomRequirements[i].packStorySimpleRequirement(\\n            meta.delayRequirements[i],\\n            meta.isFinalAnswer[i]\\n          );\\n\\n          if (data != bytes32(0)) {\\n            s.answerAttributes[answerPackedId] = data;\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswerAttributes(storyId, meta);\\n  }\\n\\n  function setAnswerHeroCustomDataRequirementMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerCustomDataMeta memory meta) public {\\n    _setCustomDataRequirementMeta(s, storyId, meta, s.heroCustomDataRequirement);\\n    emit IApplicationEvents.SetAnswerHeroCustomDataRequirementMeta(storyId, meta);\\n  }\\n\\n  function setAnswerGlobalCustomDataRequirementMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerCustomDataMeta memory meta) public {\\n    _setCustomDataRequirementMeta(s, storyId, meta, s.globalCustomDataRequirement);\\n    emit IApplicationEvents.SetAnswerGlobalCustomDataRequirementMeta(storyId, meta);\\n  }\\n\\n  function setStoryCustomDataRequirements(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    bytes32[] memory requiredCustomDataIndex,\\n    uint64[] memory requiredCustomDataMinValue,\\n    uint64[] memory requiredCustomDataMaxValue,\\n    bool[] memory requiredCustomDataIsHero,\\n    uint minLevel\\n  ) public {\\n    s.storyRequiredLevel[storyId] = minLevel;\\n    emit IApplicationEvents.StoryRequiredLevel(storyId, minLevel);\\n\\n    IStoryController.CustomDataRequirementRangePacked[] storage allData = s.storyRequiredHeroData[storyId];\\n\\n    for (uint i; i < requiredCustomDataIndex.length; ++i) {\\n      allData.push(IStoryController.CustomDataRequirementRangePacked({\\n        index: requiredCustomDataIndex[i],\\n        data: requiredCustomDataMinValue[i].packCustomDataRequirements(\\n          requiredCustomDataMaxValue[i],\\n          requiredCustomDataIsHero[i]\\n        )\\n      }));\\n\\n      emit IApplicationEvents.StoryCustomDataRequirements(storyId, requiredCustomDataIndex[i], requiredCustomDataMinValue[i], requiredCustomDataMaxValue[i], requiredCustomDataIsHero[i]);\\n    }\\n  }\\n\\n  function setSuccessInfo(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerResultMeta memory meta) public {\\n    _setInfo(s, storyId, meta, s.successInfoAttributes, s.successInfoStats, s.successInfoMintItems);\\n    emit IApplicationEvents.SetSuccessInfo(storyId, meta);\\n  }\\n\\n  function setFailInfo(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerResultMeta memory meta) public {\\n    _setInfo(s, storyId, meta, s.failInfoAttributes, s.failInfoStats, s.failInfoMintItems);\\n    emit IApplicationEvents.SetFailInfo(storyId, meta);\\n  }\\n\\n  function setCustomDataResult(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    IStoryController.AnswerCustomDataResultMeta memory meta,\\n    IStoryController.CustomDataResult type_\\n  ) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n        if (_registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]) != bytes32(0)) {\\n          bytes32 answerPackedIdWithType = storyId.packStoryCustomDataResult(\\n            meta.pageId[i],\\n            meta.heroClass[i],\\n            meta.answerId[i],\\n            uint8(type_)\\n          );\\n\\n          bytes32[] storage arr = s.customDataResult[answerPackedIdWithType];\\n          for (uint j; j < meta.dataIndexes[i].length; ++j) {\\n            arr.push(meta.dataIndexes[i][j].packCustomDataChange(meta.dataValues[i][j]));\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetCustomDataResult(storyId, meta, type_);\\n  }\\n\\n  function finalizeStoryRegistration(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    uint32 objectId,\\n    uint buildHash\\n  ) external {\\n    // it's not necessary to remove previously stored data here\\n    // we assume, that old data is already removed completely before registering new data\\n\\n    s.registeredStories[objectId] = true;\\n    // store new used id\\n    s._usedStoryIds[storyId] = true;\\n    // register new id for story\\n    s.storyIds[objectId] = storyId;\\n    s.idToStory[storyId] = objectId;\\n    s.storyBuildHash[storyId] = buildHash;\\n\\n    emit IApplicationEvents.StoryFinalized(objectId, storyId);\\n  }\\n  //endregion ------------------ Set story fields\\n\\n  //region ------------------ Utils to set story fields\\n  function _registerAnswer(IStoryController.MainState storage s,  uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId)\\n  internal returns (bytes32 answerPackedId) {\\n    answerPackedId = storyId.packStoryAnswerId(pageId, heroClass, answerId);\\n    if (answerPackedId != bytes32(0)) {\\n      registerAnswer(s, storyId, answerPackedId);\\n    }\\n  }\\n\\n  /// @param map Either heroCustomDataRequirement or globalCustomDataRequirement\\n  function _setCustomDataRequirementMeta(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    IStoryController.AnswerCustomDataMeta memory meta,\\n    mapping(bytes32 => IStoryController.CustomDataRequirementPacked[]) storage map\\n  ) internal {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          IStoryController.CustomDataRequirementPacked[] storage arr = map[answerPackedId];\\n\\n          bytes32[] memory dataIndexes = meta.dataIndexes[i];\\n          bool[] memory mandatory = meta.mandatory[i];\\n          uint64[] memory dataValuesMin = meta.dataValuesMin[i];\\n          uint64[] memory dataValuesMax = meta.dataValuesMax[i];\\n\\n          for (uint j; j < dataIndexes.length; ++j) {\\n            arr.push(\\n              IStoryController.CustomDataRequirementPacked({\\n                index: dataIndexes[j],\\n                data: dataValuesMin[j].packCustomDataRequirements(dataValuesMax[j], mandatory[j])\\n              })\\n            );\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  function _setInfo(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    IStoryController.AnswerResultMeta memory meta,\\n    mapping(bytes32 => bytes32[]) storage infoAttributes,\\n    mapping(bytes32 => bytes32) storage infoStats,\\n    mapping(bytes32 => bytes32[]) storage infoMintItems\\n  ) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          if (meta.attributeIds[i].length != 0) {\\n            infoAttributes[answerPackedId] = meta.attributeValues[i].toBytes32ArrayWithIds(meta.attributeIds[i]);\\n          }\\n\\n          bytes32 stats = PackingLib.packStatsChange(\\n            meta.experience[i],\\n            meta.heal[i],\\n            meta.manaRegen[i],\\n            meta.lifeChancesRecovered[i],\\n            meta.damage[i],\\n            meta.manaConsumed[i]\\n          );\\n          if (stats != bytes32(0)) {\\n            infoStats[answerPackedId] = stats;\\n          }\\n\\n          uint lenItems = meta.mintItems[i].length;\\n          if (lenItems != 0) {\\n            bytes32[] memory items = new bytes32[](lenItems);\\n            for (uint j; j < lenItems; ++j) {\\n              items[j] = meta.mintItems[i][j].packItemMintInfo(meta.mintItemsChances[i][j]);\\n            }\\n            infoMintItems[answerPackedId] = items;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  //endregion ------------------ Utils to set story fields\\n\\n  //region ------------------ Remove logic\\n  // WE MUST REMOVE ALL EXIST META!\\n  // otherwise we will still have meta for story id and will totally mess data\\n  function removeStory(IStoryController.MainState storage s, uint32 objectId) external {\\n    if (s.storyIds[objectId] == 0 || !s.registeredStories[objectId]) revert IAppErrors.ZeroStoryIdRemoveStory();\\n\\n    uint16 storyId = s.storyIds[objectId];\\n    delete s._usedStoryIds[storyId];\\n    delete s.storyIds[objectId];\\n    delete s.idToStory[storyId];\\n    delete s.registeredStories[objectId];\\n    delete s.storyBuildHash[storyId];\\n\\n    delete s.storyRequiredHeroData[storyId];\\n    delete s.storyRequiredLevel[storyId];\\n\\n\\n    emit IApplicationEvents.StoryRemoved(objectId, storyId);\\n  }\\n\\n  function removeStoryPagesMeta(IStoryController.MainState storage s, uint16 storyId, uint maxIterations) external {\\n    RemoveStoryContext memory ctx;\\n    ctx.storyId = storyId;\\n\\n    // --- clean all data related to pages ---\\n\\n    EnumerableSet.UintSet storage allPages = s.allStoryPages[ctx.storyId];\\n    ctx.len = allPages.length();\\n    if (ctx.len > maxIterations) {\\n      ctx.len = maxIterations;\\n    }\\n    ctx.tmpPages = new uint[](ctx.len);\\n\\n    for (uint i; i < ctx.len; ++i) {\\n      ctx.tmpPages[i] = allPages.at(i);\\n      ctx.pageId = uint16(ctx.tmpPages[i]);\\n\\n      // zero hero class means all classes\\n      for (ctx.heroClass = 0; ctx.heroClass < uint(StatLib.HeroClasses.END_SLOT); ++ctx.heroClass) {\\n        delete s.answers[ctx.storyId.packStoryPageId(ctx.pageId, ctx.heroClass)];\\n        delete s.nextObjectsRewrite[ctx.storyId.packStoryPageId(ctx.pageId, ctx.heroClass)];\\n      }\\n    }\\n\\n    // remove all pages\\n    for (uint i; i < ctx.tmpPages.length; ++i) {\\n      if (!allPages.remove(ctx.tmpPages[i])) {\\n        revert IAppErrors.PageNotRemovedError(ctx.tmpPages[i]);\\n      }\\n    }\\n  }\\n\\n  function removeStoryAnswersMeta(IStoryController.MainState storage s, uint16 storyId, uint maxIterations) external {\\n    RemoveStoryContext memory ctx;\\n    ctx.storyId = storyId;\\n\\n    // --- clean all data related to answers ---\\n\\n    EnumerableSet.Bytes32Set storage allAnswers = s.allStoryAnswers[ctx.storyId];\\n    ctx.len = allAnswers.length();\\n    if (ctx.len > maxIterations) {\\n      ctx.len = maxIterations;\\n    }\\n    ctx.tmpAnswers = new bytes32[](ctx.len);\\n\\n    for (uint i; i < ctx.len; ++i) {\\n      ctx.answerId = allAnswers.at(i);\\n      ctx.tmpAnswers[i] = ctx.answerId;\\n\\n      (, ctx.pageId, ctx.heroClass, ctx.answerNum) = ctx.answerId.unpackStoryAnswerId();\\n\\n      delete s.answerAttributes[ctx.answerId];\\n      delete s.attributeRequirements[ctx.answerId];\\n      delete s.itemRequirements[ctx.answerId];\\n      delete s.tokenRequirements[ctx.answerId];\\n      delete s.heroCustomDataRequirement[ctx.answerId];\\n      delete s.globalCustomDataRequirement[ctx.answerId];\\n      delete s.successInfoAttributes[ctx.answerId];\\n      delete s.successInfoStats[ctx.answerId];\\n      delete s.successInfoMintItems[ctx.answerId];\\n      delete s.failInfoAttributes[ctx.answerId];\\n      delete s.failInfoStats[ctx.answerId];\\n      delete s.failInfoMintItems[ctx.answerId];\\n      delete s.burnItem[ctx.answerId];\\n\\n      for (ctx.answerResultId = 0; ctx.answerResultId < uint(IStoryController.AnswerResultId.END_SLOT); ++ctx.answerResultId) {\\n        delete s.nextPageIds[ctx.storyId.packStoryNextPagesId(\\n          ctx.pageId,\\n          ctx.heroClass,\\n          ctx.answerNum,\\n          ctx.answerResultId\\n        )];\\n      }\\n\\n      // we assume here, that CustomDataResultId.UNKNOWN = 0 shouldn't be used, so we can skip delete for it\\n      for (ctx.customDataResultId = 1; ctx.customDataResultId < uint(IStoryController.CustomDataResult.END_SLOT); ++ctx.customDataResultId) {\\n        delete s.customDataResult[ctx.storyId.packStoryCustomDataResult(\\n          ctx.pageId,\\n          ctx.heroClass,\\n          ctx.answerNum,\\n          ctx.customDataResultId\\n        )];\\n      }\\n    }\\n\\n    // ATTENTION! need to remove items one by one from sets\\n\\n    // remove all answers\\n    for (uint i; i < ctx.tmpAnswers.length; ++i) {\\n      allAnswers.remove(ctx.tmpAnswers[i]);\\n    }\\n  }\\n  //endregion ------------------ Remove logic\\n\\n  //region ------------------ Utils\\n  function registerAnswer(IStoryController.MainState storage s, uint16 storyId, bytes32 answerId) internal {\\n    s.allStoryAnswers[storyId].add(answerId);\\n  }\\n\\n  function registerPage(IStoryController.MainState storage s, uint16 storyId, uint16 pageId) internal {\\n    s.allStoryPages[storyId].add(pageId);\\n  }\\n  //endregion ------------------ Utils\\n}\\n\",\"keccak256\":\"0x5cc36aebd8e37b3792dd68873d4d9cf823e0f1b8580472237240778bbd7b3de2\",\"license\":\"BUSL-1.1\"},\"contracts/openzeppelin/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  // To implement this library for multiple types with as little code repetition as possible, we write it in\\n  // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\\n  // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\\n  // This means that we can only create new EnumerableMaps for types that fit in bytes32.\\n\\n  /**\\n   * @dev Query for a nonexistent map key.\\n     */\\n  error EnumerableMapNonexistentKey(bytes32 key);\\n\\n  struct Bytes32ToBytes32Map {\\n    // Storage of keys\\n    EnumerableSet.Bytes32Set _keys;\\n    mapping(bytes32 key => bytes32) _values;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n    map._values[key] = value;\\n    return map._keys.add(key);\\n  }\\n\\n  /**\\n   * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n    delete map._values[key];\\n    return map._keys.remove(key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n    return map._keys.contains(key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n    return map._keys.length();\\n  }\\n\\n  /**\\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n    bytes32 key = map._keys.at(index);\\n    return (key, map._values[key]);\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == bytes32(0)) {\\n      return (contains(map, key), bytes32(0));\\n    } else {\\n      return (true, value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == 0 && !contains(map, key)) {\\n      revert EnumerableMapNonexistentKey(key);\\n    }\\n    return value;\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n    return map._keys.values();\\n  }\\n\\n  // UintToUintMap\\n\\n  struct UintToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key)));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintToAddressMap\\n\\n  struct UintToAddressMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressToUintMap\\n\\n  struct AddressToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n    return remove(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (address(uint160(uint256(key))), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // Bytes32ToUintMap\\n\\n  struct Bytes32ToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, key, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n    return remove(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n    return contains(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (key, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, key);\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, key));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x5052395b3d57e4347a977f96eba69188b4a952594afae411910995ecab5c1d05\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position is the index of the value in the `values` array plus 1.\\n    // Position 0 is used to mean a value is not in the set.\\n    mapping(bytes32 value => uint256) _positions;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._positions[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We cache the value's position to prevent multiple reads from the same storage slot\\n    uint256 position = set._positions[value];\\n\\n    if (position != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 valueIndex = position - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (valueIndex != lastIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the lastValue to the index where the value to delete is\\n        set._values[valueIndex] = lastValue;\\n        // Update the tracked position of the lastValue (that was just moved)\\n        set._positions[lastValue] = position;\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the tracked position for the deleted slot\\n      delete set._positions[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._positions[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n     */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xd5483249a7bac53a40791ade8d640831cdec526eea6b42a4db68f2ce13c008fa\",\"license\":\"MIT\"},\"contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n\\n  /**\\n    * @dev Muldiv operation overflow.\\n   */\\n  error MathOverflowedMulDiv();\\n\\n  enum Rounding {\\n    Floor, // Toward negative infinity\\n    Ceil, // Toward positive infinity\\n    Trunc, // Toward zero\\n    Expand // Away from zero\\n  }\\n\\n  /**\\n   * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      uint256 c = a + b;\\n      if (c < a) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b > a) return (false, 0);\\n      return (true, a - b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n      if (a == 0) return (true, 0);\\n      uint256 c = a * b;\\n      if (c / a != b) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a / b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a % b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (b == 0) {\\n      // Guarantee the same behavior as in a regular Solidity division.\\n      return a / b;\\n    }\\n\\n    // The following calculation ensures accurate ceiling division without overflow.\\n    // Since a is non-zero, (a - 1) / b will not overflow.\\n    // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n    // but the largest value we can obtain is type(uint256).max - 1, which happens\\n    // when a = type(uint256).max and b = 1.\\n    unchecked {\\n      return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n    unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n      uint256 prod0 = x * y; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n      if (prod1 == 0) {\\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n        // The surrounding unchecked block does not change this fact.\\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n        return prod0 / denominator;\\n      }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n      if (denominator <= prod1) {\\n        revert MathOverflowedMulDiv();\\n      }\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n      uint256 remainder;\\n      assembly {\\n      // Compute remainder using mulmod.\\n        remainder := mulmod(x, y, denominator)\\n\\n      // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n    // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n      uint256 twos = denominator & (0 - denominator);\\n      assembly {\\n      // Divide denominator by twos.\\n        denominator := div(denominator, twos)\\n\\n      // Divide [prod1 prod0] by twos.\\n        prod0 := div(prod0, twos)\\n\\n      // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n\\n    // Shift in bits from prod1 into prod0.\\n      prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n      uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n    // works in modular arithmetic, doubling the correct bits in each step.\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n      result = prod0 * inverse;\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n    unchecked {\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      return min(result, a / result);\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = sqrt(a);\\n      return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 128;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 64;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 32;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 16;\\n      }\\n      if (value >> 8 > 0) {\\n        value >>= 8;\\n        result += 8;\\n      }\\n      if (value >> 4 > 0) {\\n        value >>= 4;\\n        result += 4;\\n      }\\n      if (value >> 2 > 0) {\\n        value >>= 2;\\n        result += 2;\\n      }\\n      if (value >> 1 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log2(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >= 10 ** 64) {\\n        value /= 10 ** 64;\\n        result += 64;\\n      }\\n      if (value >= 10 ** 32) {\\n        value /= 10 ** 32;\\n        result += 32;\\n      }\\n      if (value >= 10 ** 16) {\\n        value /= 10 ** 16;\\n        result += 16;\\n      }\\n      if (value >= 10 ** 8) {\\n        value /= 10 ** 8;\\n        result += 8;\\n      }\\n      if (value >= 10 ** 4) {\\n        value /= 10 ** 4;\\n        result += 4;\\n      }\\n      if (value >= 10 ** 2) {\\n        value /= 10 ** 2;\\n        result += 2;\\n      }\\n      if (value >= 10 ** 1) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log10(value);\\n      return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 16;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 8;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 4;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 2;\\n      }\\n      if (value >> 8 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log256(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n  function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n    return uint8(rounding) % 2 == 1;\\n  }\\n\\n}\\n\",\"keccak256\":\"0x4d972e3e1d79f693b6cb42007d23c27256cb6f087392edea24b93585a822572c\",\"license\":\"MIT\"},\"contracts/solady/LibPRNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for generating pseudorandom numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\\n/// @author LazyShuffler based on NextShuffler by aschlosberg (divergencearran)\\n/// (https://github.com/divergencetech/ethier/blob/main/contracts/random/NextShuffler.sol)\\nlibrary LibPRNG {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The initial length must be greater than zero and less than `2**32 - 1`.\\n    error InvalidInitialLazyShufflerLength();\\n\\n    /// @dev The new length must not be less than the current length.\\n    error InvalidNewLazyShufflerLength();\\n\\n    /// @dev The lazy shuffler has not been initialized.\\n    error LazyShufflerNotInitialized();\\n\\n    /// @dev Cannot double initialize the lazy shuffler.\\n    error LazyShufflerAlreadyInitialized();\\n\\n    /// @dev The lazy shuffle has finished.\\n    error LazyShuffleFinished();\\n\\n    /// @dev The queried index is out of bounds.\\n    error LazyShufflerGetOutOfBounds();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pseudorandom number state in memory.\\n    struct PRNG {\\n        uint256 state;\\n    }\\n\\n    /// @dev A lazy Fisher-Yates shuffler for a range `[0..n)` in storage.\\n    struct LazyShuffler {\\n        // Bits Layout:\\n        // - [0..31]    `numShuffled`\\n        // - [32..223]  `permutationSlot`\\n        // - [224..255] `length`\\n        uint256 _state;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Seeds the `prng` with `state`.\\n    function seed(PRNG memory prng, uint256 state) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(prng, state)\\n        }\\n    }\\n\\n    /// @dev Returns the next pseudorandom uint256.\\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\\n        // We simply use `keccak256` for a great balance between\\n        // runtime gas costs, bytecode size, and statistical properties.\\n        //\\n        // A high-quality LCG with a 32-byte state\\n        // is only about 30% more gas efficient during runtime,\\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\\n        // when this function is inlined.\\n        //\\n        // Using this method is about 2x more efficient than\\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n        }\\n    }\\n\\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\\n    /// between 0 (inclusive) and `upper` (exclusive).\\n    /// If your modulus is big, this method is recommended\\n    /// for uniform sampling to avoid modulo bias.\\n    /// For uniform sampling across all uint256 values,\\n    /// or for small enough moduli such that the bias is neligible,\\n    /// use {next} instead.\\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := keccak256(prng, 0x20)\\n                mstore(prng, result)\\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\\n            }\\n            result := mod(result, upper)\\n        }\\n    }\\n\\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n\\n                    {\\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                let b := add(a, 0x01)\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let o := mod(shr(128, r), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n\\n                    {\\n                        let o := mod(and(r, mask), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the standard normal distribution denominated in `WAD`.\\n    function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\\n            // The chance of drawing a sample outside 10 \\u03c3 from the standard normal distribution\\n            // is \\u2248 0.000000000000000000000015, which is insignificant for most practical purposes.\\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\\n            let s := 0x1000000000000000100000000000000010000000000000001\\n            let r1 := mulmod(result, a, n)\\n            let r2 := mulmod(r1, a, n)\\n            let r3 := mulmod(r2, a, n)\\n            // forgefmt: disable-next-item\\n            result := sub(sar(96, mul(26614938895861601847173011183,\\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the unit exponential distribution denominated in `WAD`.\\n    function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\\n            // Gas usage varies, starting from about 172+ gas.\\n            let r := keccak256(prng, 0x20)\\n            mstore(prng, r)\\n            let p := shl(129, r)\\n            let w := shl(1, r)\\n            if iszero(gt(w, p)) {\\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n                for {} 1 {} {\\n                    r := mulmod(r, a, n)\\n                    if iszero(lt(shl(129, r), w)) {\\n                        r := mulmod(r, a, n)\\n                        result := add(1000000000000000000, result)\\n                        w := shl(1, r)\\n                        p := shl(129, r)\\n                        if iszero(lt(w, p)) { break }\\n                        continue\\n                    }\\n                    w := shl(1, r)\\n                    if iszero(lt(w, shl(129, r))) { break }\\n                }\\n            }\\n            result := add(div(p, shl(129, 170141183460469231732)), result)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*       STORAGE-BASED RANGE LAZY SHUFFLING OPERATIONS        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Initializes the state for lazy-shuffling the range `[0..n)`.\\n    /// Reverts if `n == 0 || n >= 2**32 - 1`.\\n    /// Reverts if `$` has already been initialized.\\n    /// If you need to reduce the length after initialization, just use a fresh new `$`.\\n    function initialize(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sload($.slot) {\\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, $.slot)\\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Increases the length of `$`.\\n    /// Reverts if `$` has not been initialized.\\n    function grow(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            // If the new length is smaller than the old length, revert.\\n            if lt(n, shr(224, state)) {\\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\\n        }\\n    }\\n\\n    /// @dev Restarts the shuffler by setting `numShuffled` to zero,\\n    /// such that all elements can be drawn again.\\n    /// Restarting does NOT clear the internal permutation, nor changes the length.\\n    /// Even with the same sequence of randomness, reshuffling can yield different results.\\n    function restart(LazyShuffler storage $) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot)\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, shl(32, shr(32, state)))\\n        }\\n    }\\n\\n    /// @dev Returns the number of elements that have been shuffled.\\n    function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := and(0xffffffff, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns the length of `$`.\\n    /// Returns zero if `$` is not initialized, else a non-zero value less than `2**32 - 1`.\\n    function length(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := shr(224, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns if `$` has been initialized.\\n    function initialized(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(iszero(sload($.slot)))\\n        }\\n    }\\n\\n    /// @dev Returns if there are any more elements left to shuffle.\\n    /// Reverts if `$` is not initialized.\\n    function finished(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := eq(shr(224, state), and(0xffffffff, state))\\n        }\\n    }\\n\\n    /// @dev Returns the current value stored at `index`, accounting for all historical shuffling.\\n    /// Reverts if `index` is greater than or equal to the `length` of `$`.\\n    function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            let n := shr(224, state) // Length of `$`.\\n            if iszero(lt(index, n)) {\\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let u32 := gt(n, 0xfffe)\\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\\n            result := and(m, shr(o, sload(s)))\\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\\n        }\\n    }\\n\\n    /// @dev Does a single Fisher-Yates shuffle step, increments the `numShuffled` in `$`,\\n    /// and returns the next value in the shuffled range.\\n    /// `randomness` can be taken from a good-enough source, or a higher quality source like VRF.\\n    /// Reverts if there are no more values to shuffle, which includes the case if `$` is not initialized.\\n    function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function _get(u32_, state_, i_) -> _value {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                _value := and(m_, shr(o_, sload(s_)))\\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\\n            }\\n            function _set(u32_, state_, i_, value_) {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                let v_ := sload(s_) // Bucket slot value.\\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\\n            }\\n            let state := sload($.slot) // The packed value at `$`.\\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\\n            let n := shr(224, state) // Length of `$`.\\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\\n            if iszero(remainder) {\\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\\n            chosen := _get(gt(n, 0xfffe), state, index)\\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdcb71f8dc72bb7384776154ca24d34c23e3c9bcf124bc75f0d2e379f9ebd021d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6157aa6200003b600b82828239805160001a60731461002e57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106101165760003560e01c80639c9dc579116100a75780639c9dc5791461025d578063a84d660c1461027d578063a913674b1461029d578063b5083ab9146102bd578063b5287c91146102dd578063c258bf40146102fd578063c5828ff11461031d578063ca4739361461033d578063cbbefc281461035d578063d335b7f31461037d57600080fd5b806301c3192f1461011b57806301c7664c1461013d5780630324a18c1461015d5780631c9a90081461017d5780633e8dd8681461019d57806356814190146101bd578063679dde4c146101dd5780636b6cc9f8146101fd578063751dda431461021d5780638cd5642c1461023d575b600080fd5b81801561012757600080fd5b5061013b610136366004612d92565b61039d565b005b81801561014957600080fd5b5061013b61015836600461321a565b6104f9565b81801561016957600080fd5b5061013b610178366004613440565b610546565b81801561018957600080fd5b5061013b6101983660046134c1565b610757565b8180156101a957600080fd5b5061013b6101b8366004613505565b610808565b8180156101c957600080fd5b5061013b6101d8366004613814565b610be5565b8180156101e957600080fd5b5061013b6101f8366004613930565b610db4565b81801561020957600080fd5b5061013b610218366004613ad8565b610f47565b81801561022957600080fd5b5061013b610238366004613f20565b611048565b81801561024957600080fd5b5061013b6102583660046140bc565b611090565b81801561026957600080fd5b5061013b6102783660046143e8565b6111dd565b81801561028957600080fd5b5061013b610298366004614744565b61135d565b8180156102a957600080fd5b5061013b6102b8366004614790565b6114ea565b8180156102c957600080fd5b5061013b6102d8366004613f20565b611621565b8180156102e957600080fd5b5061013b6102f8366004613505565b611669565b81801561030957600080fd5b5061013b6103183660046147bc565b611880565b81801561032957600080fd5b5061013b61033836600461482e565b611c21565b81801561034957600080fd5b5061013b61035836600461487a565b611dae565b81801561036957600080fd5b5061013b61037836600461321a565b611fbb565b81801561038957600080fd5b5061013b61039836600461494a565b611ffb565b825160005b818110156104b3576103ce87878784815181106103c1576103c1614996565b60200260200101516120fe565b60008760060160006104218885815181106103eb576103eb614996565b602002602001015188868151811061040557610405614996565b60200260200101518b61ffff166121259092919063ffffffff16565b81526020019081526020016000209050600061048b898989868151811061044a5761044a614996565b602002602001015189878151811061046457610464614996565b602002602001015189888151811061047e5761047e614996565b6020026020010151612149565b905080156104a9578154600181018355600083815260209020018190555b50506001016103a2565b50507f49007bba987368aede38546653f41bd86c6ed04d5e7ba4ca166432c014b2138c848484846040516104ea9493929190614a20565b60405180910390a15050505050565b61050883838386600d0161218d565b7f49126b5a176699b1ec3b1eac8c744bfaf006d2cefcd10f794c25f29a3ace0b8e8282604051610539929190614be7565b60405180910390a1505050565b81515160005b81811015610714576000801b6105af87878760000151858151811061057357610573614996565b60200260200101518860200151868151811061059157610591614996565b60200260200101518960400151878151811061047e5761047e614996565b1461070c576000610633856000015183815181106105cf576105cf614996565b6020026020010151866020015184815181106105ed576105ed614996565b60200260200101518760400151858151811061060b5761060b614996565b602002602001015187600581111561062557610625614cc9565b61ffff8b1693929190612318565b600081815260158901602052604081209192505b8660600151848151811061065d5761065d614996565b60200260200101515181101561070857816106ed8860800151868151811061068757610687614996565b602002602001015183815181106106a0576106a0614996565b6020026020010151896060015187815181106106be576106be614996565b602002602001015184815181106106d7576106d7614996565b602002602001015161235a90919063ffffffff16565b81546001818101845560009384526020909320015501610647565b5050505b60010161054c565b50507f5144a9cbb149e306e7330f55e21a6b72086d1b86b4aef7a9d76713048802295183838360405161074993929190614d01565b60405180910390a150505050565b63ffffffff8216600081815260038601602090815260408083208054600160ff19918216811790925561ffff891680865260028b01855283862080549092168317909155858552898452828520805461ffff1916821790558085529089018352818420805463ffffffff191686179055601a89018352928190208590558051938452908301919091527f77b037a0afbc269c250968ad8197fbc330f78621131eb33de9de913bc8a510d69101610749565b6108106128c6565b61ffff831660608201819052600090815260058501602052604090206108358161238a565b60c0830181905283101561084b5760c082018390525b8160c001516001600160401b0381111561086757610867612b70565b604051908082528060200260200182016040528015610890578160200160208202803683370190505b5061012083015260005b8260c00151811015610b91576108b0828261239a565b61010084018190526101208401518051839081106108d0576108d0614996565b6020026020010181815250506108fa83610100015190601082901c90602083901c90602884901c90565b61ffff90811660a088015260ff909116865216608085015250610100830180516000908152600988016020908152604080832083905592518252600a890190529081206109469161291c565b6101008301516000908152600b8701602052604081206109659161291c565b6101008301516000908152600c8701602052604081206109849161291c565b6101008301516000908152600d8701602052604081206109a39161293d565b6101008301516000908152600e8701602052604081206109c29161293d565b6101008301516000908152600f8701602052604081206109e19161291c565b610100830180516000908152601088016020908152604080832083905592518252601189019052908120610a149161291c565b61010083015160009081526012870160205260408120610a339161291c565b610100830180516000908152601388016020908152604080832083905592518252601489019052908120610a669161291c565b61010083015160009081526016870160205260408120610a859161291c565b600060208401525b6007836020015160ff161015610b0757856007016000610ad4856080015186600001518760a001518860200151896060015161ffff1661231890949392919063ffffffff16565b81526020019081526020016000206000610aee919061295e565b826020018051610afd90614e3a565b60ff169052610a8d565b600160408401525b6005836040015160ff161015610b8957856015016000610b56856080015186600001518760a001518860400151896060015161ffff1661231890949392919063ffffffff16565b81526020019081526020016000206000610b70919061291c565b826040018051610b7f90614e3a565b60ff169052610b0f565b60010161089a565b5060005b82610120015151811015610bdd57610bd48361012001518281518110610bbd57610bbd614996565b6020026020010151836123ad90919063ffffffff16565b50600101610b95565b505050505050565b80515160005b81811015610d81576000610c4c868686600001518581518110610c1057610c10614996565b602002602001015187602001518681518110610c2e57610c2e614996565b60200260200101518860400151878151811061047e5761047e614996565b90508015610d78576000818152600c870160205260408120905b85606001518481518110610c7c57610c7c614996565b602002602001015151811015610d75576000610d4e87608001518681518110610ca757610ca7614996565b60200260200101518381518110610cc057610cc0614996565b60200260200101518860a001518781518110610cde57610cde614996565b60200260200101518481518110610cf757610cf7614996565b602002602001015189606001518881518110610d1557610d15614996565b60200260200101518581518110610d2e57610d2e614996565b60200260200101516001600160a01b03166123b99092919063ffffffff16565b90508015610d6c578254600181018455600084815260209020018190555b50600101610c66565b50505b50600101610beb565b50507ff7763619246d8f0933bc30f26ed64aa852419d4c03682ebe62c07b2b5e58189a8282604051610539929190614ed3565b80515160005b81811015610f14576000610ddf868686600001518581518110610c1057610c10614996565b90508015610f0b576000818152600b870160205260408120905b85606001518481518110610e0f57610e0f614996565b602002602001015151811015610f08576000610ee187608001518681518110610e3a57610e3a614996565b60200260200101518381518110610e5357610e53614996565b60200260200101518860a001518781518110610e7157610e71614996565b60200260200101518481518110610e8a57610e8a614996565b602002602001015189606001518881518110610ea857610ea8614996565b60200260200101518581518110610ec157610ec1614996565b60200260200101516001600160a01b03166123f39092919063ffffffff16565b90508015610eff578254600181018455600084815260209020018190555b50600101610df9565b50505b50600101610dba565b50507f75e2a553fd5c4396591939214dccd44f121aa91d9419cb35347afa55e0335bab8282604051610539929190615006565b80515160005b81811015611015576000610f72868686600001518581518110610c1057610c10614996565b9050801561100c576000610fee85608001518481518110610f9557610f95614996565b60200260200101518660a001518581518110610fb357610fb3614996565b602002602001015187606001518681518110610fd157610fd1614996565b602002602001015163ffffffff166124229092919063ffffffff16565b9050801561100a57600082815260098801602052604090208190555b505b50600101610f4d565b50507fee4f8e4fe9011c317080a888f3ea5fd4984b1f407ba1eeb36840cdb64ceef48982826040516105399291906150f7565b61105f83838386600f018760100188601101611880565b7f869c57977aa939d74e2da756cb2e738c080b4231a44f4cd81950529f2ff6bbdd82826040516105399291906152cc565b80515160005b818110156111aa5760006110bb868686600001518581518110610c1057610c10614996565b905080156111a1576000611156856000015184815181106110de576110de614996565b6020026020010151866020015185815181106110fc576110fc614996565b60200260200101518760400151868151811061111a5761111a614996565b60200260200101518860600151878151811061113857611138614996565b60200260200101518a61ffff1661231890949392919063ffffffff16565b90508460800151838151811061116e5761116e614996565b6020026020010151876007016000838152602001908152602001600020908051906020019061119e929190612983565b50505b50600101611096565b50507f978987b8c70f4ee959e5636ae6f9699d1e1473928283af297505ae4147f96ed88282604051610539929190615460565b6111f1828260000151836101c00151611c21565b611205828260000151836101e00151611ffb565b805160c08201518051602082015160409092015161122793869390929161039d565b61123a8282600001518360e00151611090565b61124e82826000015183610100015161135d565b611262828260000151836101200151610db4565b611276828260000151836101400151610be5565b61128a828260000151836101600151610f47565b61129e8282600001518361018001516104f9565b6112b2828260000151836101a00151611fbb565b6112c6828260000151836102000151611048565b6112da828260000151836102200151611621565b6112f08282600001518361024001516001610546565b6113068282600001518361026001516002610546565b61131c8282600001518361028001516003610546565b611332828260000151836102a001516004610546565b61135982826000015183602001518460400151856060015186608001518760a00151611dae565b5050565b80515160005b818110156114b7576000611388868686600001518581518110610c1057610c10614996565b905080156114ae576000818152600a870160205260408120905b856060015184815181106113b8576113b8614996565b6020026020010151518110156114ab5760006114848760a0015186815181106113e3576113e3614996565b602002602001015183815181106113fc576113fc614996565b60200260200101518860600151878151811061141a5761141a614996565b6020026020010151848151811061143357611433614996565b60200260200101518960800151888151811061145157611451614996565b6020026020010151858151811061146a5761146a614996565b602002602001015160ff166124469092919063ffffffff16565b905080156114a2578254600181018455600084815260209020018190555b506001016113a2565b50505b50600101611363565b50507f6ae02f4d7862466cf651e781506106bd39987973bcbd68688021b5bcfbd8f6848282604051610539929190615547565b63ffffffff811660009081526020839052604090205461ffff161580611528575063ffffffff8116600090815260038301602052604090205460ff16155b1561154657604051634f12d70760e11b815260040160405180910390fd5b63ffffffff8116600081815260208481526040808320805461ffff16808552600288018452828520805460ff19908116909155825461ffff1916909255600188018452828520805463ffffffff1916905594845260038701835281842080549091169055838352601a860182528083208390556017860190915281206115cb9161293d565b61ffff81166000818152601885016020908152604080832092909255815163ffffffff86168152908101929092527f36206a58dc94b3b1d63eaf20aff0d8b78da875c59739496e88c021ad18422a129101610539565b611638838383866012018760130188601401611880565b7f4b868e06a41dbd00f1781690c7c901b28487927ffb0dd540e9c643fda33232bb82826040516105399291906152cc565b6116716128c6565b61ffff831660608201819052600090815260048501602052604090206116968161238a565b60c083018190528310156116ac5760c082018390525b8160c001516001600160401b038111156116c8576116c8612b70565b6040519080825280602002602001820160405280156116f1578160200160208202803683370190505b5060e083015260005b8260c0015181101561180757611710828261239a565b8360e00151828151811061172657611726614996565b6020026020010181815250508260e00151818151811061174857611748614996565b602090810291909101015161ffff166080840152600083525b6007835160ff1610156117ff5760808301518351606085015160068901926000926117919261ffff169190612125565b815260200190815260200160002060006117ab919061291c565b60808301518351606085015160088901926000926117ce9261ffff169190612125565b815260200190815260200160002060006117e89190612a2c565b825183906117f590614e3a565b60ff169052611761565b6001016116fa565b5060005b8260e0015151811015610bdd576118318360e001518281518110610bbd57610bbd614996565b611878578260e00151818151811061184b5761184b614996565b6020026020010151604051632fd1568f60e11b815260040161186f91815260200190565b60405180910390fd5b60010161180b565b83515160005b81811015611c175760006118e78989896000015185815181106118ab576118ab614996565b60200260200101518a6020015186815181106118c9576118c9614996565b60200260200101518b60400151878151811061047e5761047e614996565b90508015611c0e578660600151828151811061190557611905614996565b602002602001015151600014611985576119628760600151838151811061192e5761192e614996565b60200260200101518860800151848151811061194c5761194c614996565b602002602001015161246590919063ffffffff16565b60008281526020888152604090912082516119839391929190910190612a51565b505b6000611aa48860a0015184815181106119a0576119a0614996565b60200260200101518960c0015185815181106119be576119be614996565b60200260200101518a60e0015186815181106119dc576119dc614996565b60200260200101518b610100015187815181106119fb576119fb614996565b60200260200101518c61012001518881518110611a1a57611a1a614996565b60200260200101518d61014001518981518110611a3957611a39614996565b60209081029190910181015163ffffffff9690961694901b63ffffffff60201b169390931760409290921b63ffffffff60401b169190911760609190911b63ffffffff60601b161760809190911b63ffffffff60801b161760a09190911b63ffffffff60a01b161790565b90508015611abe5760008281526020879052604090208190555b60008861016001518481518110611ad757611ad7614996565b602002602001015151905080600014611c0b576000816001600160401b03811115611b0457611b04612b70565b604051908082528060200260200182016040528015611b2d578160200160208202803683370190505b50905060005b82811015611bea57611bc58b61018001518781518110611b5557611b55614996565b60200260200101518281518110611b6e57611b6e614996565b60200260200101518c61016001518881518110611b8d57611b8d614996565b60200260200101518381518110611ba657611ba6614996565b60200260200101516001600160a01b03166126c390919063ffffffff16565b828281518110611bd757611bd7614996565b6020908102919091010152600101611b33565b506000848152602088815260409091208251611c0892840190612a51565b50505b50505b50600101611886565b5050505050505050565b80515160005b81811015611d7b576000611c4c868686600001518581518110610c1057610c10614996565b90508015611d725760008181526016870160205260408120905b85606001518481518110611c7c57611c7c614996565b602002602001015151811015611d6f576000611d4887608001518681518110611ca757611ca7614996565b60200260200101518381518110611cc057611cc0614996565b60200260200101518860a001518781518110611cde57611cde614996565b60200260200101518481518110611cf757611cf7614996565b602002602001015189606001518881518110611d1557611d15614996565b60200260200101518581518110611d2e57611d2e614996565b602002602001015160ff166126e19092919063ffffffff16565b90508015611d66578254600181018455600084815260209020018190555b50600101611c66565b50505b50600101611c27565b50507fe8aef7992dddcf8eab441423fa358ec12b14f62644161a4641efd65f5e5a8f0d8282604051610539929190615601565b61ffff86166000818152601889016020908152604091829020849055815192835282018390527f979e00d9ab95347fc5a2a8936556e51fbf30d23aa2b43e95a307f37590db590e910160405180910390a161ffff861660009081526017880160205260408120905b8651811015611fb057816040518060400160405280898481518110611e3d57611e3d614996565b60200260200101518152602001611eb3888581518110611e5f57611e5f614996565b6020026020010151888681518110611e7957611e79614996565b60200260200101518b8781518110611e9357611e93614996565b60200260200101516001600160401b03166127049092919063ffffffff16565b905281546001818101845560009384526020938490208351600290930201918255929091015191015586517fa4f88bdc8eedabd5953d882c5d392f683d96cbda2c76003a7f0340083bc6148b908990899084908110611f1457611f14614996565b6020026020010151888481518110611f2e57611f2e614996565b6020026020010151888581518110611f4857611f48614996565b6020026020010151888681518110611f6257611f62614996565b6020908102919091018101516040805161ffff9097168752918601949094526001600160401b03928316908501521660608301521515608082015260a00160405180910390a1600101611e16565b505050505050505050565b611fca83838386600e0161218d565b7f0d0f8f5e403cc74ac4909b11cbfe60cc6e48a9973ba32e10b9449a7365c34e688282604051610539929190614be7565b80515160005b818110156120cb576120248585856000015184815181106103c1576103c1614996565b60006120798460000151838151811061203f5761203f614996565b60200260200101518560200151848151811061205d5761205d614996565b60200260200101518761ffff166121259092919063ffffffff16565b90508360400151828151811061209157612091614996565b602002602001015186600801600083815260200190815260200160002090805190602001906120c1929190612a8c565b5050600101612001565b50507f3068977f27d58675414225648f9fddefc01a84758bcc359b64f244480b30f770828260405161053992919061569d565b61ffff8281166000908152600485016020526040902061211f91831661272f565b50505050565b61ffff9290921660109190911b63ffff0000161760209190911b60ff60201b161790565b61ffff8416601084901b63ffff00001617602083901b60ff60201b1617602882901b61ffff60281b161780156121845761218486868361273b565b95945050505050565b81515160005b81811015610bdd5760006121b887878760000151858151811061057357610573614996565b9050801561230f57600081815260208590526040812060608701518051919291859081106121e8576121e8614996565b6020026020010151905060008760800151858151811061220a5761220a614996565b6020026020010151905060008860a00151868151811061222c5761222c614996565b6020026020010151905060008960c00151878151811061224e5761224e614996565b6020026020010151905060005b84518110156123085785604051806040016040528087848151811061228257612282614996565b602002602001015181526020016122d88585815181106122a4576122a4614996565b60200260200101518886815181106122be576122be614996565b6020026020010151888781518110611e9357611e93614996565b9052815460018181018455600093845260209384902083516002909302019182559290910151908201550161225b565b5050505050505b50600101612193565b61ffff9490941660109390931b63ffff0000169290921760209190911b60ff60201b161760289190911b61ffff60281b161760389190911b60ff60381b161790565b600061ffff19831683146123815760405163508af79560e01b815260040160405180910390fd5b5061ffff161790565b6000612394825490565b92915050565b60006123a6838361275a565b9392505050565b60006123a68383612784565b600160a01b600160f81b0360a083901b166001600160a01b0384161760f8826123e35760006123e6565b60015b60ff16901b179392505050565b6001600160a01b03831660a08361240b57600061240e565b60015b60ff16901b1760a8826123e35760006123e6565b63ffffffff60201b602083901b1663ffffffff8416176040826123e35760006123e6565b64ffffffff00600883901b1660ff8416176028826123e35760006123e6565b606081518351146124895760405163586cb9e160e01b815260040160405180910390fd5b60006008845161249991906156ff565b6124a4906001615721565b90506000816001600160401b038111156124c0576124c0612b70565b6040519080825280602002602001820160405280156124e9578160200160208202803683370190505b50905060005b828110156126ba5760005b60088110156126b157600081612511846008615734565b61251b9190615721565b90508751811061252b57506126b1565b627fffff60020b88828151811061254457612544614996565b602002602001015160030b138061257d5750627fffff1960020b88828151811061257057612570614996565b602002602001015160030b125b156125bb5787818151811061259457612594614996565b602002602001015160030b604051632eb1d06960e01b815260040161186f91815260200190565b8781815181106125cd576125cd614996565b602002602001015160030b6000036125f857604051637c946ed760e01b815260040160405180910390fd5b612603826020615734565b88828151811061261557612615614996565b602002602001015162ffffff1660001b901b84848151811061263957612639614996565b6020026020010181815117915081815250508160206126589190615734565b612663906018615721565b87828151811061267557612675614996565b602002602001015160ff1660001b901b84848151811061269757612697614996565b6020908102919091010180519091179052506001016124fa565b506001016124ef565b50949350505050565b63ffffffff60a01b60a09190911b166001600160a01b039091161790565b68ffffffffffffffff00600883901b1660ff8416176048826123e35760006123e6565b67ffffffffffffffff60401b604083901b166001600160401b038416176080826123e35760006123e6565b60006123a68383612877565b61ffff82166000908152600584016020526040902061211f908261272f565b600082600001828154811061277157612771614996565b9060005260206000200154905092915050565b6000818152600183016020526040812054801561286d5760006127a860018361574b565b85549091506000906127bc9060019061574b565b90508082146128215760008660000182815481106127dc576127dc614996565b90600052602060002001549050808760000184815481106127ff576127ff614996565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806128325761283261575e565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050612394565b6000915050612394565b60008181526001830160205260408120546128be57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155612394565b506000612394565b604080516101408101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e0820181905261010082019290925261012081019190915290565b508054600082559060005260206000209081019061293a9190612b29565b50565b508054600082556002029060005260206000209081019061293a9190612b3e565b50805460008255600f01601090049060005260206000209081019061293a9190612b29565b82805482825590600052602060002090600f01601090048101928215612a1c5791602002820160005b838211156129ec57835183826101000a81548161ffff021916908361ffff16021790555092602001926002016020816001010492830192600103026129ac565b8015612a1a5782816101000a81549061ffff02191690556002016020816001010492830192600103026129ec565b505b50612a28929150612b29565b5090565b50805460008255600701600890049060005260206000209081019061293a9190612b29565b828054828255906000526020600020908101928215612a1c579160200282015b82811115612a1c578251825591602001919060010190612a71565b82805482825590600052602060002090600701600890048101928215612a1c5791602002820160005b83821115612af957835183826101000a81548163ffffffff021916908363ffffffff1602179055509260200192600401602081600301049283019260010302612ab5565b8015612a1a5782816101000a81549063ffffffff0219169055600401602081600301049283019260010302612af9565b5b80821115612a285760008155600101612b2a565b5b80821115612a285760008082556001820155600201612b3f565b803561ffff81168114612b6b57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60405160e081016001600160401b0381118282101715612ba857612ba8612b70565b60405290565b60405160a081016001600160401b0381118282101715612ba857612ba8612b70565b60405160c081016001600160401b0381118282101715612ba857612ba8612b70565b6040516101a081016001600160401b0381118282101715612ba857612ba8612b70565b604051606081016001600160401b0381118282101715612ba857612ba8612b70565b6040516102c081016001600160401b0381118282101715612ba857612ba8612b70565b604051601f8201601f191681016001600160401b0381118282101715612c8257612c82612b70565b604052919050565b60006001600160401b03821115612ca357612ca3612b70565b5060051b60200190565b600082601f830112612cbe57600080fd5b81356020612cd3612cce83612c8a565b612c5a565b8083825260208201915060208460051b870101935086841115612cf557600080fd5b602086015b84811015612d1857612d0b81612b59565b8352918301918301612cfa565b509695505050505050565b600082601f830112612d3457600080fd5b81356020612d44612cce83612c8a565b8083825260208201915060208460051b870101935086841115612d6657600080fd5b602086015b84811015612d1857803560ff81168114612d855760008081fd5b8352918301918301612d6b565b600080600080600060a08688031215612daa57600080fd5b85359450612dba60208701612b59565b935060408601356001600160401b0380821115612dd657600080fd5b612de289838a01612cad565b94506060880135915080821115612df857600080fd5b612e0489838a01612d23565b93506080880135915080821115612e1a57600080fd5b50612e2788828901612cad565b9150509295509295909350565b600082601f830112612e4557600080fd5b81356020612e55612cce83612c8a565b8083825260208201915060208460051b870101935086841115612e7757600080fd5b602086015b84811015612d185780358352918301918301612e7c565b600082601f830112612ea457600080fd5b81356020612eb4612cce83612c8a565b82815260059290921b84018101918181019086841115612ed357600080fd5b8286015b84811015612d185780356001600160401b03811115612ef65760008081fd5b612f048986838b0101612e34565b845250918301918301612ed7565b600082601f830112612f2357600080fd5b81356020612f33612cce83612c8a565b8083825260208201915060208460051b870101935086841115612f5557600080fd5b602086015b84811015612d185780358015158114612f735760008081fd5b8352918301918301612f5a565b600082601f830112612f9157600080fd5b81356020612fa1612cce83612c8a565b82815260059290921b84018101918181019086841115612fc057600080fd5b8286015b84811015612d185780356001600160401b03811115612fe35760008081fd5b612ff18986838b0101612f12565b845250918301918301612fc4565b600082601f83011261301057600080fd5b81356020613020612cce83612c8a565b8083825260208201915060208460051b87010193508684111561304257600080fd5b602086015b84811015612d185780356001600160401b03811681146130675760008081fd5b8352918301918301613047565b600082601f83011261308557600080fd5b81356020613095612cce83612c8a565b82815260059290921b840181019181810190868411156130b457600080fd5b8286015b84811015612d185780356001600160401b038111156130d75760008081fd5b6130e58986838b0101612fff565b8452509183019183016130b8565b600060e0828403121561310557600080fd5b61310d612b86565b905081356001600160401b038082111561312657600080fd5b61313285838601612cad565b8352602084013591508082111561314857600080fd5b61315485838601612d23565b6020840152604084013591508082111561316d57600080fd5b61317985838601612cad565b6040840152606084013591508082111561319257600080fd5b61319e85838601612e93565b606084015260808401359150808211156131b757600080fd5b6131c385838601612f80565b608084015260a08401359150808211156131dc57600080fd5b6131e885838601613074565b60a084015260c084013591508082111561320157600080fd5b5061320e84828501613074565b60c08301525092915050565b60008060006060848603121561322f57600080fd5b8335925061323f60208501612b59565b915060408401356001600160401b0381111561325a57600080fd5b613266868287016130f3565b9150509250925092565b600082601f83011261328157600080fd5b81356020613291612cce83612c8a565b828152600592831b85018201928282019190878511156132b057600080fd5b8387015b858110156133565780356001600160401b038111156132d35760008081fd5b8801603f81018a136132e55760008081fd5b8581013560406132f7612cce83612c8a565b82815291851b8301810191888101908d8411156133145760008081fd5b938201935b8385101561334557843592508260010b83146133355760008081fd5b8282529389019390890190613319565b8852505050938501935084016132b4565b5090979650505050505050565b600060a0828403121561337557600080fd5b61337d612bae565b905081356001600160401b038082111561339657600080fd5b6133a285838601612cad565b835260208401359150808211156133b857600080fd5b6133c485838601612d23565b602084015260408401359150808211156133dd57600080fd5b6133e985838601612cad565b6040840152606084013591508082111561340257600080fd5b61340e85838601612e93565b6060840152608084013591508082111561342757600080fd5b5061343484828501613270565b60808301525092915050565b6000806000806080858703121561345657600080fd5b8435935061346660208601612b59565b925060408501356001600160401b0381111561348157600080fd5b61348d87828801613363565b9250506060850135600681106134a257600080fd5b939692955090935050565b803563ffffffff81168114612b6b57600080fd5b600080600080608085870312156134d757600080fd5b843593506134e760208601612b59565b92506134f5604086016134ad565b9396929550929360600135925050565b60008060006060848603121561351a57600080fd5b8335925061352a60208501612b59565b9150604084013590509250925092565b600082601f83011261354b57600080fd5b8135602061355b612cce83612c8a565b828152600592831b850182019282820191908785111561357a57600080fd5b8387015b858110156133565780356001600160401b0381111561359d5760008081fd5b8801603f81018a136135af5760008081fd5b8581013560406135c1612cce83612c8a565b82815291851b8301810191888101908d8411156135de5760008081fd5b938201935b8385101561361557843592506001600160a01b03831683146136055760008081fd5b82825293890193908901906135e3565b88525050509385019350840161357e565b600082601f83011261363757600080fd5b81356020613647612cce83612c8a565b828152600592831b850182019282820191908785111561366657600080fd5b8387015b858110156133565780356001600160401b038111156136895760008081fd5b8801603f81018a1361369b5760008081fd5b8581013560406136ad612cce83612c8a565b82815291851b8301810191888101908d8411156136ca5760008081fd5b938201935b8385101561370157843592506001600160581b03831683146136f15760008081fd5b82825293890193908901906136cf565b88525050509385019350840161366a565b600060c0828403121561372457600080fd5b61372c612bd0565b905081356001600160401b038082111561374557600080fd5b61375185838601612cad565b8352602084013591508082111561376757600080fd5b61377385838601612d23565b6020840152604084013591508082111561378c57600080fd5b61379885838601612cad565b604084015260608401359150808211156137b157600080fd5b6137bd8583860161353a565b606084015260808401359150808211156137d657600080fd5b6137e285838601613626565b608084015260a08401359150808211156137fb57600080fd5b5061380884828501612f80565b60a08301525092915050565b60008060006060848603121561382957600080fd5b8335925061383960208501612b59565b915060408401356001600160401b0381111561385457600080fd5b61326686828701613712565b600060c0828403121561387257600080fd5b61387a612bd0565b905081356001600160401b038082111561389357600080fd5b61389f85838601612cad565b835260208401359150808211156138b557600080fd5b6138c185838601612d23565b602084015260408401359150808211156138da57600080fd5b6138e685838601612cad565b604084015260608401359150808211156138ff57600080fd5b61390b8583860161353a565b6060840152608084013591508082111561392457600080fd5b6137e285838601612f80565b60008060006060848603121561394557600080fd5b8335925061395560208501612b59565b915060408401356001600160401b0381111561397057600080fd5b61326686828701613860565b600082601f83011261398d57600080fd5b8135602061399d612cce83612c8a565b8083825260208201915060208460051b8701019350868411156139bf57600080fd5b602086015b84811015612d18576139d5816134ad565b83529183019183016139c4565b600060c082840312156139f457600080fd5b6139fc612bd0565b905081356001600160401b0380821115613a1557600080fd5b613a2185838601612cad565b83526020840135915080821115613a3757600080fd5b613a4385838601612d23565b60208401526040840135915080821115613a5c57600080fd5b613a6885838601612cad565b60408401526060840135915080821115613a8157600080fd5b613a8d8583860161397c565b60608401526080840135915080821115613aa657600080fd5b613ab28583860161397c565b608084015260a0840135915080821115613acb57600080fd5b5061380884828501612f12565b600080600060608486031215613aed57600080fd5b83359250613afd60208501612b59565b915060408401356001600160401b03811115613b1857600080fd5b613266868287016139e2565b600082601f830112613b3557600080fd5b81356020613b45612cce83612c8a565b82815260059290921b84018101918181019086841115613b6457600080fd5b8286015b84811015612d185780356001600160401b03811115613b875760008081fd5b613b958986838b0101612d23565b845250918301918301613b68565b600082601f830112613bb457600080fd5b81356020613bc4612cce83612c8a565b8083825260208201915060208460051b870101935086841115613be657600080fd5b602086015b84811015612d185780358060030b8114613c055760008081fd5b8352918301918301613beb565b600082601f830112613c2357600080fd5b81356020613c33612cce83612c8a565b82815260059290921b84018101918181019086841115613c5257600080fd5b8286015b84811015612d185780356001600160401b03811115613c755760008081fd5b613c838986838b0101613ba3565b845250918301918301613c56565b600082601f830112613ca257600080fd5b81356020613cb2612cce83612c8a565b82815260059290921b84018101918181019086841115613cd157600080fd5b8286015b84811015612d185780356001600160401b03811115613cf45760008081fd5b613d028986838b010161397c565b845250918301918301613cd5565b60006101a08284031215613d2357600080fd5b613d2b612bf2565b905081356001600160401b0380821115613d4457600080fd5b613d5085838601612cad565b83526020840135915080821115613d6657600080fd5b613d7285838601612d23565b60208401526040840135915080821115613d8b57600080fd5b613d9785838601612cad565b60408401526060840135915080821115613db057600080fd5b613dbc85838601613b24565b60608401526080840135915080821115613dd557600080fd5b613de185838601613c12565b608084015260a0840135915080821115613dfa57600080fd5b613e068583860161397c565b60a084015260c0840135915080821115613e1f57600080fd5b613e2b85838601613ba3565b60c084015260e0840135915080821115613e4457600080fd5b613e5085838601613ba3565b60e084015261010091508184013581811115613e6b57600080fd5b613e7786828701613ba3565b838501525061012091508184013581811115613e9257600080fd5b613e9e86828701613ba3565b838501525061014091508184013581811115613eb957600080fd5b613ec586828701613ba3565b838501525061016091508184013581811115613ee057600080fd5b613eec8682870161353a565b838501525061018091508184013581811115613f0757600080fd5b613f1386828701613c91565b8385015250505092915050565b600080600060608486031215613f3557600080fd5b83359250613f4560208501612b59565b915060408401356001600160401b03811115613f6057600080fd5b61326686828701613d10565b600082601f830112613f7d57600080fd5b81356020613f8d612cce83612c8a565b82815260059290921b84018101918181019086841115613fac57600080fd5b8286015b84811015612d185780356001600160401b03811115613fcf5760008081fd5b613fdd8986838b0101612cad565b845250918301918301613fb0565b600060a08284031215613ffd57600080fd5b614005612bae565b905081356001600160401b038082111561401e57600080fd5b61402a85838601612cad565b8352602084013591508082111561404057600080fd5b61404c85838601612d23565b6020840152604084013591508082111561406557600080fd5b61407185838601612cad565b6040840152606084013591508082111561408a57600080fd5b61409685838601612d23565b606084015260808401359150808211156140af57600080fd5b5061343484828501613f6c565b6000806000606084860312156140d157600080fd5b833592506140e160208501612b59565b915060408401356001600160401b038111156140fc57600080fd5b61326686828701613feb565b60006060828403121561411a57600080fd5b614122612c15565b905081356001600160401b038082111561413b57600080fd5b61414785838601612cad565b8352602084013591508082111561415d57600080fd5b61416985838601612d23565b6020840152604084013591508082111561418257600080fd5b5061418f84828501612cad565b60408301525092915050565b600060c082840312156141ad57600080fd5b6141b5612bd0565b905081356001600160401b03808211156141ce57600080fd5b6141da85838601612cad565b835260208401359150808211156141f057600080fd5b6141fc85838601612d23565b6020840152604084013591508082111561421557600080fd5b61422185838601612cad565b6040840152606084013591508082111561423a57600080fd5b61424685838601612f80565b6060840152608084013591508082111561425f57600080fd5b61426b85838601613b24565b608084015260a084013591508082111561428457600080fd5b5061380884828501613c12565b600060c082840312156142a357600080fd5b6142ab612bd0565b905081356001600160401b03808211156142c457600080fd5b6142d085838601612cad565b835260208401359150808211156142e657600080fd5b6142f285838601612d23565b6020840152604084013591508082111561430b57600080fd5b61431785838601612cad565b6040840152606084013591508082111561433057600080fd5b61433c85838601613b24565b6060840152608084013591508082111561435557600080fd5b6137e285838601613074565b60006060828403121561437357600080fd5b61437b612c15565b905081356001600160401b038082111561439457600080fd5b6143a085838601612cad565b835260208401359150808211156143b657600080fd5b6143c285838601612d23565b602084015260408401359150808211156143db57600080fd5b5061418f84828501613c91565b600080604083850312156143fb57600080fd5b8235915060208301356001600160401b038082111561441957600080fd5b908401906102c0828703121561442e57600080fd5b614436612c37565b61443f83612b59565b815260208301358281111561445357600080fd5b61445f88828601612e34565b60208301525060408301358281111561447757600080fd5b61448388828601612fff565b60408301525060608301358281111561449b57600080fd5b6144a788828601612fff565b6060830152506080830135828111156144bf57600080fd5b6144cb88828601612f12565b60808301525060a083013560a082015260c0830135828111156144ed57600080fd5b6144f988828601614108565b60c08301525060e08301358281111561451157600080fd5b61451d88828601613feb565b60e083015250610100808401358381111561453757600080fd5b6145438982870161419b565b828401525050610120808401358381111561455d57600080fd5b61456989828701613860565b828401525050610140808401358381111561458357600080fd5b61458f89828701613712565b82840152505061016080840135838111156145a957600080fd5b6145b5898287016139e2565b82840152505061018080840135838111156145cf57600080fd5b6145db898287016130f3565b8284015250506101a080840135838111156145f557600080fd5b614601898287016130f3565b8284015250506101c0808401358381111561461b57600080fd5b61462789828701614291565b8284015250506101e0808401358381111561464157600080fd5b61464d89828701614361565b828401525050610200808401358381111561466757600080fd5b61467389828701613d10565b828401525050610220808401358381111561468d57600080fd5b61469989828701613d10565b82840152505061024080840135838111156146b357600080fd5b6146bf89828701613363565b82840152505061026080840135838111156146d957600080fd5b6146e589828701613363565b82840152505061028080840135838111156146ff57600080fd5b61470b89828701613363565b8284015250506102a0808401358381111561472557600080fd5b61473189828701613363565b8284015250508093505050509250929050565b60008060006060848603121561475957600080fd5b8335925061476960208501612b59565b915060408401356001600160401b0381111561478457600080fd5b6132668682870161419b565b600080604083850312156147a357600080fd5b823591506147b3602084016134ad565b90509250929050565b60008060008060008060c087890312156147d557600080fd5b863595506147e560208801612b59565b945060408701356001600160401b0381111561480057600080fd5b61480c89828a01613d10565b945050606087013592506080870135915060a087013590509295509295509295565b60008060006060848603121561484357600080fd5b8335925061485360208501612b59565b915060408401356001600160401b0381111561486e57600080fd5b61326686828701614291565b600080600080600080600060e0888a03121561489557600080fd5b873596506148a560208901612b59565b955060408801356001600160401b03808211156148c157600080fd5b6148cd8b838c01612e34565b965060608a01359150808211156148e357600080fd5b6148ef8b838c01612fff565b955060808a013591508082111561490557600080fd5b6149118b838c01612fff565b945060a08a013591508082111561492757600080fd5b506149348a828b01612f12565b92505060c0880135905092959891949750929550565b60008060006060848603121561495f57600080fd5b8335925061496f60208501612b59565b915060408401356001600160401b0381111561498a57600080fd5b61326686828701614361565b634e487b7160e01b600052603260045260246000fd5b60008151808452602080850194506020840160005b838110156149e157815161ffff16875295820195908201906001016149c1565b509495945050505050565b60008151808452602080850194506020840160005b838110156149e157815160ff1687529582019590820190600101614a01565b61ffff85168152608060208201526000614a3d60808301866149ac565b8281036040840152614a4f81866149ec565b90508281036060840152614a6381856149ac565b979650505050505050565b600082825180855260208086019550808260051b8401018186016000805b85811015614adf57868403601f19018a52825180518086529086019086860190845b81811015614aca57835183529288019291880191600101614aae565b50509a86019a94505091840191600101614a8c565b509198975050505050505050565b60008151808452602080850194506020840160005b838110156149e1578151151587529582019590820190600101614b02565b60008282518085526020808601955060208260051b8401016020860160005b8481101561335657601f19868403018952614b5b838351614aed565b98840198925090830190600101614b3f565b600082825180855260208086019550808260051b8401018186016000805b85811015614adf57868403601f19018a52825180518086529086019086860190845b81811015614bd25783516001600160401b031683529288019291880191600101614bad565b50509a86019a94505091840191600101614b8b565b61ffff83168152604060208201526000825160e06040840152614c0e6101208401826149ac565b90506020840151603f1980858403016060860152614c2c83836149ec565b92506040860151915080858403016080860152614c4983836149ac565b925060608601519150808584030160a0860152614c668383614a6e565b925060808601519150808584030160c0860152614c838383614b20565b925060a08601519150808584030160e0860152614ca08383614b6d565b925060c08601519150808584030161010086015250614cbf8282614b6d565b9695505050505050565b634e487b7160e01b600052602160045260246000fd5b60068110614cfd57634e487b7160e01b600052602160045260246000fd5b9052565b61ffff8416815260006020606081840152845160a06060850152614d296101008501826149ac565b905081860151605f1980868403016080870152614d4683836149ec565b925060408801519150808684030160a0870152614d6383836149ac565b925060608801519150808684030160c0870152614d808383614a6e565b608089015187820390920160e08801528151808252909350908401915083830190600581901b840185016000805b83811015614e0457868303601f19018552855180518085529089019089850190845b81811015614def578351600190810b8452938c0193928c019201614dd0565b50509689019695890195935050600101614dae565b5050809650505050505050614e1c6040830184614cdf565b949350505050565b634e487b7160e01b600052601160045260246000fd5b600060ff821660ff8103614e5057614e50614e24565b60010192915050565b600082825180855260208086019550808260051b8401018186016000805b85811015614adf57868403601f19018a52825180518086529086019086860190845b81811015614ebe5783516001600160a01b031683529288019291880191600101614e99565b50509a86019a94505091840191600101614e77565b61ffff8316815260006020604081840152835160c06040850152614efb6101008501826149ac565b905081850151603f1980868403016060870152614f1883836149ec565b92506040870151915080868403016080870152614f3583836149ac565b925060608701519150808684030160a0870152614f528383614e59565b6080880151878203830160c089015280518083529194508501925084840190600581901b850186016000805b83811015614fda57878303601f1901855286518051808552908a01908a850190845b81811015614fc55783516001600160581b03168352928c0192918c0191600101614fa0565b5050978a0197958a0195935050600101614f7e565b505060a08a01519650838982030160e08a0152614ff78188614b20565b9b9a5050505050505050505050565b61ffff83168152604060208201526000825160c0604084015261502d6101008401826149ac565b90506020840151603f198085840301606086015261504b83836149ec565b9250604086015191508085840301608086015261506883836149ac565b925060608601519150808584030160a08601526150858383614e59565b925060808601519150808584030160c08601526150a28383614b20565b925060a08601519150808584030160e086015250614cbf8282614b20565b60008151808452602080850194506020840160005b838110156149e157815163ffffffff16875295820195908201906001016150d5565b61ffff83168152604060208201526000825160c0604084015261511e6101008401826149ac565b90506020840151603f198085840301606086015261513c83836149ec565b9250604086015191508085840301608086015261515983836149ac565b925060608601519150808584030160a086015261517683836150c0565b925060808601519150808584030160c086015261519383836150c0565b925060a08601519150808584030160e086015250614cbf8282614aed565b60008282518085526020808601955060208260051b8401016020860160005b8481101561335657601f198684030189526151ec8383516149ec565b988401989250908301906001016151d0565b60008151808452602080850194506020840160005b838110156149e157815160030b87529582019590820190600101615213565b60008282518085526020808601955060208260051b8401016020860160005b8481101561335657601f1986840301895261526d8383516151fe565b98840198925090830190600101615251565b60008282518085526020808601955060208260051b8401016020860160005b8481101561335657601f198684030189526152ba8383516150c0565b9884019892509083019060010161529e565b61ffff8316815260406020820152600082516101a08060408501526152f56101e08501836149ac565b91506020850151603f198086850301606087015261531384836149ec565b9350604087015191508086850301608087015261533084836149ac565b935060608701519150808685030160a087015261534d84836151b1565b935060808701519150808685030160c087015261536a8483615232565b935060a08701519150808685030160e087015261538784836150c0565b935060c087015191506101008187860301818801526153a685846151fe565b945060e088015192506101208288870301818901526153c586856151fe565b955081890151935061014091508288870301828901526153e586856151fe565b95508089015193505061016082888703018189015261540486856151fe565b9550818901519350610180915082888703018289015261542486856151fe565b9550808901519350508187860301848801526154408584614e59565b94508088015193505080868503016101c08701525050614cbf828261527f565b61ffff8316815260006020604081840152835160a0604085015261548760e08501826149ac565b905081850151603f19808684030160608701526154a483836149ec565b925060408701519150808684030160808701526154c183836149ac565b925060608701519150808684030160a08701526154de83836149ec565b608088015187820390920160c08801528151808252909350908401915083830190600581901b8401850160005b8281101561553957601f198683030184526155278286516149ac565b9487019493870193915060010161550b565b509998505050505050505050565b61ffff83168152604060208201526000825160c0604084015261556e6101008401826149ac565b90506020840151603f198085840301606086015261558c83836149ec565b925060408601519150808584030160808601526155a983836149ac565b925060608601519150808584030160a08601526155c68383614b20565b925060808601519150808584030160c08601526155e383836151b1565b925060a08601519150808584030160e086015250614cbf8282615232565b61ffff83168152604060208201526000825160c060408401526156286101008401826149ac565b90506020840151603f198085840301606086015261564683836149ec565b9250604086015191508085840301608086015261566383836149ac565b925060608601519150808584030160a086015261568083836151b1565b925060808601519150808584030160c08601526150a28383614b6d565b61ffff831681526040602082015260008251606060408401526156c360a08401826149ac565b90506020840151603f19808584030160608601526156e183836149ec565b9250604086015191508085840301608086015250614cbf828261527f565b60008261571c57634e487b7160e01b600052601260045260246000fd5b500490565b8082018082111561239457612394614e24565b808202811582820484141761239457612394614e24565b8181038181111561239457612394614e24565b634e487b7160e01b600052603160045260246000fdfea264697066735822122080768d5588cb9f9bb1c9ef8e0b685768fcea790ef05c2464f73af6dffa48fb1964736f6c63430008170033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106101165760003560e01c80639c9dc579116100a75780639c9dc5791461025d578063a84d660c1461027d578063a913674b1461029d578063b5083ab9146102bd578063b5287c91146102dd578063c258bf40146102fd578063c5828ff11461031d578063ca4739361461033d578063cbbefc281461035d578063d335b7f31461037d57600080fd5b806301c3192f1461011b57806301c7664c1461013d5780630324a18c1461015d5780631c9a90081461017d5780633e8dd8681461019d57806356814190146101bd578063679dde4c146101dd5780636b6cc9f8146101fd578063751dda431461021d5780638cd5642c1461023d575b600080fd5b81801561012757600080fd5b5061013b610136366004612d92565b61039d565b005b81801561014957600080fd5b5061013b61015836600461321a565b6104f9565b81801561016957600080fd5b5061013b610178366004613440565b610546565b81801561018957600080fd5b5061013b6101983660046134c1565b610757565b8180156101a957600080fd5b5061013b6101b8366004613505565b610808565b8180156101c957600080fd5b5061013b6101d8366004613814565b610be5565b8180156101e957600080fd5b5061013b6101f8366004613930565b610db4565b81801561020957600080fd5b5061013b610218366004613ad8565b610f47565b81801561022957600080fd5b5061013b610238366004613f20565b611048565b81801561024957600080fd5b5061013b6102583660046140bc565b611090565b81801561026957600080fd5b5061013b6102783660046143e8565b6111dd565b81801561028957600080fd5b5061013b610298366004614744565b61135d565b8180156102a957600080fd5b5061013b6102b8366004614790565b6114ea565b8180156102c957600080fd5b5061013b6102d8366004613f20565b611621565b8180156102e957600080fd5b5061013b6102f8366004613505565b611669565b81801561030957600080fd5b5061013b6103183660046147bc565b611880565b81801561032957600080fd5b5061013b61033836600461482e565b611c21565b81801561034957600080fd5b5061013b61035836600461487a565b611dae565b81801561036957600080fd5b5061013b61037836600461321a565b611fbb565b81801561038957600080fd5b5061013b61039836600461494a565b611ffb565b825160005b818110156104b3576103ce87878784815181106103c1576103c1614996565b60200260200101516120fe565b60008760060160006104218885815181106103eb576103eb614996565b602002602001015188868151811061040557610405614996565b60200260200101518b61ffff166121259092919063ffffffff16565b81526020019081526020016000209050600061048b898989868151811061044a5761044a614996565b602002602001015189878151811061046457610464614996565b602002602001015189888151811061047e5761047e614996565b6020026020010151612149565b905080156104a9578154600181018355600083815260209020018190555b50506001016103a2565b50507f49007bba987368aede38546653f41bd86c6ed04d5e7ba4ca166432c014b2138c848484846040516104ea9493929190614a20565b60405180910390a15050505050565b61050883838386600d0161218d565b7f49126b5a176699b1ec3b1eac8c744bfaf006d2cefcd10f794c25f29a3ace0b8e8282604051610539929190614be7565b60405180910390a1505050565b81515160005b81811015610714576000801b6105af87878760000151858151811061057357610573614996565b60200260200101518860200151868151811061059157610591614996565b60200260200101518960400151878151811061047e5761047e614996565b1461070c576000610633856000015183815181106105cf576105cf614996565b6020026020010151866020015184815181106105ed576105ed614996565b60200260200101518760400151858151811061060b5761060b614996565b602002602001015187600581111561062557610625614cc9565b61ffff8b1693929190612318565b600081815260158901602052604081209192505b8660600151848151811061065d5761065d614996565b60200260200101515181101561070857816106ed8860800151868151811061068757610687614996565b602002602001015183815181106106a0576106a0614996565b6020026020010151896060015187815181106106be576106be614996565b602002602001015184815181106106d7576106d7614996565b602002602001015161235a90919063ffffffff16565b81546001818101845560009384526020909320015501610647565b5050505b60010161054c565b50507f5144a9cbb149e306e7330f55e21a6b72086d1b86b4aef7a9d76713048802295183838360405161074993929190614d01565b60405180910390a150505050565b63ffffffff8216600081815260038601602090815260408083208054600160ff19918216811790925561ffff891680865260028b01855283862080549092168317909155858552898452828520805461ffff1916821790558085529089018352818420805463ffffffff191686179055601a89018352928190208590558051938452908301919091527f77b037a0afbc269c250968ad8197fbc330f78621131eb33de9de913bc8a510d69101610749565b6108106128c6565b61ffff831660608201819052600090815260058501602052604090206108358161238a565b60c0830181905283101561084b5760c082018390525b8160c001516001600160401b0381111561086757610867612b70565b604051908082528060200260200182016040528015610890578160200160208202803683370190505b5061012083015260005b8260c00151811015610b91576108b0828261239a565b61010084018190526101208401518051839081106108d0576108d0614996565b6020026020010181815250506108fa83610100015190601082901c90602083901c90602884901c90565b61ffff90811660a088015260ff909116865216608085015250610100830180516000908152600988016020908152604080832083905592518252600a890190529081206109469161291c565b6101008301516000908152600b8701602052604081206109659161291c565b6101008301516000908152600c8701602052604081206109849161291c565b6101008301516000908152600d8701602052604081206109a39161293d565b6101008301516000908152600e8701602052604081206109c29161293d565b6101008301516000908152600f8701602052604081206109e19161291c565b610100830180516000908152601088016020908152604080832083905592518252601189019052908120610a149161291c565b61010083015160009081526012870160205260408120610a339161291c565b610100830180516000908152601388016020908152604080832083905592518252601489019052908120610a669161291c565b61010083015160009081526016870160205260408120610a859161291c565b600060208401525b6007836020015160ff161015610b0757856007016000610ad4856080015186600001518760a001518860200151896060015161ffff1661231890949392919063ffffffff16565b81526020019081526020016000206000610aee919061295e565b826020018051610afd90614e3a565b60ff169052610a8d565b600160408401525b6005836040015160ff161015610b8957856015016000610b56856080015186600001518760a001518860400151896060015161ffff1661231890949392919063ffffffff16565b81526020019081526020016000206000610b70919061291c565b826040018051610b7f90614e3a565b60ff169052610b0f565b60010161089a565b5060005b82610120015151811015610bdd57610bd48361012001518281518110610bbd57610bbd614996565b6020026020010151836123ad90919063ffffffff16565b50600101610b95565b505050505050565b80515160005b81811015610d81576000610c4c868686600001518581518110610c1057610c10614996565b602002602001015187602001518681518110610c2e57610c2e614996565b60200260200101518860400151878151811061047e5761047e614996565b90508015610d78576000818152600c870160205260408120905b85606001518481518110610c7c57610c7c614996565b602002602001015151811015610d75576000610d4e87608001518681518110610ca757610ca7614996565b60200260200101518381518110610cc057610cc0614996565b60200260200101518860a001518781518110610cde57610cde614996565b60200260200101518481518110610cf757610cf7614996565b602002602001015189606001518881518110610d1557610d15614996565b60200260200101518581518110610d2e57610d2e614996565b60200260200101516001600160a01b03166123b99092919063ffffffff16565b90508015610d6c578254600181018455600084815260209020018190555b50600101610c66565b50505b50600101610beb565b50507ff7763619246d8f0933bc30f26ed64aa852419d4c03682ebe62c07b2b5e58189a8282604051610539929190614ed3565b80515160005b81811015610f14576000610ddf868686600001518581518110610c1057610c10614996565b90508015610f0b576000818152600b870160205260408120905b85606001518481518110610e0f57610e0f614996565b602002602001015151811015610f08576000610ee187608001518681518110610e3a57610e3a614996565b60200260200101518381518110610e5357610e53614996565b60200260200101518860a001518781518110610e7157610e71614996565b60200260200101518481518110610e8a57610e8a614996565b602002602001015189606001518881518110610ea857610ea8614996565b60200260200101518581518110610ec157610ec1614996565b60200260200101516001600160a01b03166123f39092919063ffffffff16565b90508015610eff578254600181018455600084815260209020018190555b50600101610df9565b50505b50600101610dba565b50507f75e2a553fd5c4396591939214dccd44f121aa91d9419cb35347afa55e0335bab8282604051610539929190615006565b80515160005b81811015611015576000610f72868686600001518581518110610c1057610c10614996565b9050801561100c576000610fee85608001518481518110610f9557610f95614996565b60200260200101518660a001518581518110610fb357610fb3614996565b602002602001015187606001518681518110610fd157610fd1614996565b602002602001015163ffffffff166124229092919063ffffffff16565b9050801561100a57600082815260098801602052604090208190555b505b50600101610f4d565b50507fee4f8e4fe9011c317080a888f3ea5fd4984b1f407ba1eeb36840cdb64ceef48982826040516105399291906150f7565b61105f83838386600f018760100188601101611880565b7f869c57977aa939d74e2da756cb2e738c080b4231a44f4cd81950529f2ff6bbdd82826040516105399291906152cc565b80515160005b818110156111aa5760006110bb868686600001518581518110610c1057610c10614996565b905080156111a1576000611156856000015184815181106110de576110de614996565b6020026020010151866020015185815181106110fc576110fc614996565b60200260200101518760400151868151811061111a5761111a614996565b60200260200101518860600151878151811061113857611138614996565b60200260200101518a61ffff1661231890949392919063ffffffff16565b90508460800151838151811061116e5761116e614996565b6020026020010151876007016000838152602001908152602001600020908051906020019061119e929190612983565b50505b50600101611096565b50507f978987b8c70f4ee959e5636ae6f9699d1e1473928283af297505ae4147f96ed88282604051610539929190615460565b6111f1828260000151836101c00151611c21565b611205828260000151836101e00151611ffb565b805160c08201518051602082015160409092015161122793869390929161039d565b61123a8282600001518360e00151611090565b61124e82826000015183610100015161135d565b611262828260000151836101200151610db4565b611276828260000151836101400151610be5565b61128a828260000151836101600151610f47565b61129e8282600001518361018001516104f9565b6112b2828260000151836101a00151611fbb565b6112c6828260000151836102000151611048565b6112da828260000151836102200151611621565b6112f08282600001518361024001516001610546565b6113068282600001518361026001516002610546565b61131c8282600001518361028001516003610546565b611332828260000151836102a001516004610546565b61135982826000015183602001518460400151856060015186608001518760a00151611dae565b5050565b80515160005b818110156114b7576000611388868686600001518581518110610c1057610c10614996565b905080156114ae576000818152600a870160205260408120905b856060015184815181106113b8576113b8614996565b6020026020010151518110156114ab5760006114848760a0015186815181106113e3576113e3614996565b602002602001015183815181106113fc576113fc614996565b60200260200101518860600151878151811061141a5761141a614996565b6020026020010151848151811061143357611433614996565b60200260200101518960800151888151811061145157611451614996565b6020026020010151858151811061146a5761146a614996565b602002602001015160ff166124469092919063ffffffff16565b905080156114a2578254600181018455600084815260209020018190555b506001016113a2565b50505b50600101611363565b50507f6ae02f4d7862466cf651e781506106bd39987973bcbd68688021b5bcfbd8f6848282604051610539929190615547565b63ffffffff811660009081526020839052604090205461ffff161580611528575063ffffffff8116600090815260038301602052604090205460ff16155b1561154657604051634f12d70760e11b815260040160405180910390fd5b63ffffffff8116600081815260208481526040808320805461ffff16808552600288018452828520805460ff19908116909155825461ffff1916909255600188018452828520805463ffffffff1916905594845260038701835281842080549091169055838352601a860182528083208390556017860190915281206115cb9161293d565b61ffff81166000818152601885016020908152604080832092909255815163ffffffff86168152908101929092527f36206a58dc94b3b1d63eaf20aff0d8b78da875c59739496e88c021ad18422a129101610539565b611638838383866012018760130188601401611880565b7f4b868e06a41dbd00f1781690c7c901b28487927ffb0dd540e9c643fda33232bb82826040516105399291906152cc565b6116716128c6565b61ffff831660608201819052600090815260048501602052604090206116968161238a565b60c083018190528310156116ac5760c082018390525b8160c001516001600160401b038111156116c8576116c8612b70565b6040519080825280602002602001820160405280156116f1578160200160208202803683370190505b5060e083015260005b8260c0015181101561180757611710828261239a565b8360e00151828151811061172657611726614996565b6020026020010181815250508260e00151818151811061174857611748614996565b602090810291909101015161ffff166080840152600083525b6007835160ff1610156117ff5760808301518351606085015160068901926000926117919261ffff169190612125565b815260200190815260200160002060006117ab919061291c565b60808301518351606085015160088901926000926117ce9261ffff169190612125565b815260200190815260200160002060006117e89190612a2c565b825183906117f590614e3a565b60ff169052611761565b6001016116fa565b5060005b8260e0015151811015610bdd576118318360e001518281518110610bbd57610bbd614996565b611878578260e00151818151811061184b5761184b614996565b6020026020010151604051632fd1568f60e11b815260040161186f91815260200190565b60405180910390fd5b60010161180b565b83515160005b81811015611c175760006118e78989896000015185815181106118ab576118ab614996565b60200260200101518a6020015186815181106118c9576118c9614996565b60200260200101518b60400151878151811061047e5761047e614996565b90508015611c0e578660600151828151811061190557611905614996565b602002602001015151600014611985576119628760600151838151811061192e5761192e614996565b60200260200101518860800151848151811061194c5761194c614996565b602002602001015161246590919063ffffffff16565b60008281526020888152604090912082516119839391929190910190612a51565b505b6000611aa48860a0015184815181106119a0576119a0614996565b60200260200101518960c0015185815181106119be576119be614996565b60200260200101518a60e0015186815181106119dc576119dc614996565b60200260200101518b610100015187815181106119fb576119fb614996565b60200260200101518c61012001518881518110611a1a57611a1a614996565b60200260200101518d61014001518981518110611a3957611a39614996565b60209081029190910181015163ffffffff9690961694901b63ffffffff60201b169390931760409290921b63ffffffff60401b169190911760609190911b63ffffffff60601b161760809190911b63ffffffff60801b161760a09190911b63ffffffff60a01b161790565b90508015611abe5760008281526020879052604090208190555b60008861016001518481518110611ad757611ad7614996565b602002602001015151905080600014611c0b576000816001600160401b03811115611b0457611b04612b70565b604051908082528060200260200182016040528015611b2d578160200160208202803683370190505b50905060005b82811015611bea57611bc58b61018001518781518110611b5557611b55614996565b60200260200101518281518110611b6e57611b6e614996565b60200260200101518c61016001518881518110611b8d57611b8d614996565b60200260200101518381518110611ba657611ba6614996565b60200260200101516001600160a01b03166126c390919063ffffffff16565b828281518110611bd757611bd7614996565b6020908102919091010152600101611b33565b506000848152602088815260409091208251611c0892840190612a51565b50505b50505b50600101611886565b5050505050505050565b80515160005b81811015611d7b576000611c4c868686600001518581518110610c1057610c10614996565b90508015611d725760008181526016870160205260408120905b85606001518481518110611c7c57611c7c614996565b602002602001015151811015611d6f576000611d4887608001518681518110611ca757611ca7614996565b60200260200101518381518110611cc057611cc0614996565b60200260200101518860a001518781518110611cde57611cde614996565b60200260200101518481518110611cf757611cf7614996565b602002602001015189606001518881518110611d1557611d15614996565b60200260200101518581518110611d2e57611d2e614996565b602002602001015160ff166126e19092919063ffffffff16565b90508015611d66578254600181018455600084815260209020018190555b50600101611c66565b50505b50600101611c27565b50507fe8aef7992dddcf8eab441423fa358ec12b14f62644161a4641efd65f5e5a8f0d8282604051610539929190615601565b61ffff86166000818152601889016020908152604091829020849055815192835282018390527f979e00d9ab95347fc5a2a8936556e51fbf30d23aa2b43e95a307f37590db590e910160405180910390a161ffff861660009081526017880160205260408120905b8651811015611fb057816040518060400160405280898481518110611e3d57611e3d614996565b60200260200101518152602001611eb3888581518110611e5f57611e5f614996565b6020026020010151888681518110611e7957611e79614996565b60200260200101518b8781518110611e9357611e93614996565b60200260200101516001600160401b03166127049092919063ffffffff16565b905281546001818101845560009384526020938490208351600290930201918255929091015191015586517fa4f88bdc8eedabd5953d882c5d392f683d96cbda2c76003a7f0340083bc6148b908990899084908110611f1457611f14614996565b6020026020010151888481518110611f2e57611f2e614996565b6020026020010151888581518110611f4857611f48614996565b6020026020010151888681518110611f6257611f62614996565b6020908102919091018101516040805161ffff9097168752918601949094526001600160401b03928316908501521660608301521515608082015260a00160405180910390a1600101611e16565b505050505050505050565b611fca83838386600e0161218d565b7f0d0f8f5e403cc74ac4909b11cbfe60cc6e48a9973ba32e10b9449a7365c34e688282604051610539929190614be7565b80515160005b818110156120cb576120248585856000015184815181106103c1576103c1614996565b60006120798460000151838151811061203f5761203f614996565b60200260200101518560200151848151811061205d5761205d614996565b60200260200101518761ffff166121259092919063ffffffff16565b90508360400151828151811061209157612091614996565b602002602001015186600801600083815260200190815260200160002090805190602001906120c1929190612a8c565b5050600101612001565b50507f3068977f27d58675414225648f9fddefc01a84758bcc359b64f244480b30f770828260405161053992919061569d565b61ffff8281166000908152600485016020526040902061211f91831661272f565b50505050565b61ffff9290921660109190911b63ffff0000161760209190911b60ff60201b161790565b61ffff8416601084901b63ffff00001617602083901b60ff60201b1617602882901b61ffff60281b161780156121845761218486868361273b565b95945050505050565b81515160005b81811015610bdd5760006121b887878760000151858151811061057357610573614996565b9050801561230f57600081815260208590526040812060608701518051919291859081106121e8576121e8614996565b6020026020010151905060008760800151858151811061220a5761220a614996565b6020026020010151905060008860a00151868151811061222c5761222c614996565b6020026020010151905060008960c00151878151811061224e5761224e614996565b6020026020010151905060005b84518110156123085785604051806040016040528087848151811061228257612282614996565b602002602001015181526020016122d88585815181106122a4576122a4614996565b60200260200101518886815181106122be576122be614996565b6020026020010151888781518110611e9357611e93614996565b9052815460018181018455600093845260209384902083516002909302019182559290910151908201550161225b565b5050505050505b50600101612193565b61ffff9490941660109390931b63ffff0000169290921760209190911b60ff60201b161760289190911b61ffff60281b161760389190911b60ff60381b161790565b600061ffff19831683146123815760405163508af79560e01b815260040160405180910390fd5b5061ffff161790565b6000612394825490565b92915050565b60006123a6838361275a565b9392505050565b60006123a68383612784565b600160a01b600160f81b0360a083901b166001600160a01b0384161760f8826123e35760006123e6565b60015b60ff16901b179392505050565b6001600160a01b03831660a08361240b57600061240e565b60015b60ff16901b1760a8826123e35760006123e6565b63ffffffff60201b602083901b1663ffffffff8416176040826123e35760006123e6565b64ffffffff00600883901b1660ff8416176028826123e35760006123e6565b606081518351146124895760405163586cb9e160e01b815260040160405180910390fd5b60006008845161249991906156ff565b6124a4906001615721565b90506000816001600160401b038111156124c0576124c0612b70565b6040519080825280602002602001820160405280156124e9578160200160208202803683370190505b50905060005b828110156126ba5760005b60088110156126b157600081612511846008615734565b61251b9190615721565b90508751811061252b57506126b1565b627fffff60020b88828151811061254457612544614996565b602002602001015160030b138061257d5750627fffff1960020b88828151811061257057612570614996565b602002602001015160030b125b156125bb5787818151811061259457612594614996565b602002602001015160030b604051632eb1d06960e01b815260040161186f91815260200190565b8781815181106125cd576125cd614996565b602002602001015160030b6000036125f857604051637c946ed760e01b815260040160405180910390fd5b612603826020615734565b88828151811061261557612615614996565b602002602001015162ffffff1660001b901b84848151811061263957612639614996565b6020026020010181815117915081815250508160206126589190615734565b612663906018615721565b87828151811061267557612675614996565b602002602001015160ff1660001b901b84848151811061269757612697614996565b6020908102919091010180519091179052506001016124fa565b506001016124ef565b50949350505050565b63ffffffff60a01b60a09190911b166001600160a01b039091161790565b68ffffffffffffffff00600883901b1660ff8416176048826123e35760006123e6565b67ffffffffffffffff60401b604083901b166001600160401b038416176080826123e35760006123e6565b60006123a68383612877565b61ffff82166000908152600584016020526040902061211f908261272f565b600082600001828154811061277157612771614996565b9060005260206000200154905092915050565b6000818152600183016020526040812054801561286d5760006127a860018361574b565b85549091506000906127bc9060019061574b565b90508082146128215760008660000182815481106127dc576127dc614996565b90600052602060002001549050808760000184815481106127ff576127ff614996565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806128325761283261575e565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050612394565b6000915050612394565b60008181526001830160205260408120546128be57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155612394565b506000612394565b604080516101408101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e0820181905261010082019290925261012081019190915290565b508054600082559060005260206000209081019061293a9190612b29565b50565b508054600082556002029060005260206000209081019061293a9190612b3e565b50805460008255600f01601090049060005260206000209081019061293a9190612b29565b82805482825590600052602060002090600f01601090048101928215612a1c5791602002820160005b838211156129ec57835183826101000a81548161ffff021916908361ffff16021790555092602001926002016020816001010492830192600103026129ac565b8015612a1a5782816101000a81549061ffff02191690556002016020816001010492830192600103026129ec565b505b50612a28929150612b29565b5090565b50805460008255600701600890049060005260206000209081019061293a9190612b29565b828054828255906000526020600020908101928215612a1c579160200282015b82811115612a1c578251825591602001919060010190612a71565b82805482825590600052602060002090600701600890048101928215612a1c5791602002820160005b83821115612af957835183826101000a81548163ffffffff021916908363ffffffff1602179055509260200192600401602081600301049283019260010302612ab5565b8015612a1a5782816101000a81549063ffffffff0219169055600401602081600301049283019260010302612af9565b5b80821115612a285760008155600101612b2a565b5b80821115612a285760008082556001820155600201612b3f565b803561ffff81168114612b6b57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60405160e081016001600160401b0381118282101715612ba857612ba8612b70565b60405290565b60405160a081016001600160401b0381118282101715612ba857612ba8612b70565b60405160c081016001600160401b0381118282101715612ba857612ba8612b70565b6040516101a081016001600160401b0381118282101715612ba857612ba8612b70565b604051606081016001600160401b0381118282101715612ba857612ba8612b70565b6040516102c081016001600160401b0381118282101715612ba857612ba8612b70565b604051601f8201601f191681016001600160401b0381118282101715612c8257612c82612b70565b604052919050565b60006001600160401b03821115612ca357612ca3612b70565b5060051b60200190565b600082601f830112612cbe57600080fd5b81356020612cd3612cce83612c8a565b612c5a565b8083825260208201915060208460051b870101935086841115612cf557600080fd5b602086015b84811015612d1857612d0b81612b59565b8352918301918301612cfa565b509695505050505050565b600082601f830112612d3457600080fd5b81356020612d44612cce83612c8a565b8083825260208201915060208460051b870101935086841115612d6657600080fd5b602086015b84811015612d1857803560ff81168114612d855760008081fd5b8352918301918301612d6b565b600080600080600060a08688031215612daa57600080fd5b85359450612dba60208701612b59565b935060408601356001600160401b0380821115612dd657600080fd5b612de289838a01612cad565b94506060880135915080821115612df857600080fd5b612e0489838a01612d23565b93506080880135915080821115612e1a57600080fd5b50612e2788828901612cad565b9150509295509295909350565b600082601f830112612e4557600080fd5b81356020612e55612cce83612c8a565b8083825260208201915060208460051b870101935086841115612e7757600080fd5b602086015b84811015612d185780358352918301918301612e7c565b600082601f830112612ea457600080fd5b81356020612eb4612cce83612c8a565b82815260059290921b84018101918181019086841115612ed357600080fd5b8286015b84811015612d185780356001600160401b03811115612ef65760008081fd5b612f048986838b0101612e34565b845250918301918301612ed7565b600082601f830112612f2357600080fd5b81356020612f33612cce83612c8a565b8083825260208201915060208460051b870101935086841115612f5557600080fd5b602086015b84811015612d185780358015158114612f735760008081fd5b8352918301918301612f5a565b600082601f830112612f9157600080fd5b81356020612fa1612cce83612c8a565b82815260059290921b84018101918181019086841115612fc057600080fd5b8286015b84811015612d185780356001600160401b03811115612fe35760008081fd5b612ff18986838b0101612f12565b845250918301918301612fc4565b600082601f83011261301057600080fd5b81356020613020612cce83612c8a565b8083825260208201915060208460051b87010193508684111561304257600080fd5b602086015b84811015612d185780356001600160401b03811681146130675760008081fd5b8352918301918301613047565b600082601f83011261308557600080fd5b81356020613095612cce83612c8a565b82815260059290921b840181019181810190868411156130b457600080fd5b8286015b84811015612d185780356001600160401b038111156130d75760008081fd5b6130e58986838b0101612fff565b8452509183019183016130b8565b600060e0828403121561310557600080fd5b61310d612b86565b905081356001600160401b038082111561312657600080fd5b61313285838601612cad565b8352602084013591508082111561314857600080fd5b61315485838601612d23565b6020840152604084013591508082111561316d57600080fd5b61317985838601612cad565b6040840152606084013591508082111561319257600080fd5b61319e85838601612e93565b606084015260808401359150808211156131b757600080fd5b6131c385838601612f80565b608084015260a08401359150808211156131dc57600080fd5b6131e885838601613074565b60a084015260c084013591508082111561320157600080fd5b5061320e84828501613074565b60c08301525092915050565b60008060006060848603121561322f57600080fd5b8335925061323f60208501612b59565b915060408401356001600160401b0381111561325a57600080fd5b613266868287016130f3565b9150509250925092565b600082601f83011261328157600080fd5b81356020613291612cce83612c8a565b828152600592831b85018201928282019190878511156132b057600080fd5b8387015b858110156133565780356001600160401b038111156132d35760008081fd5b8801603f81018a136132e55760008081fd5b8581013560406132f7612cce83612c8a565b82815291851b8301810191888101908d8411156133145760008081fd5b938201935b8385101561334557843592508260010b83146133355760008081fd5b8282529389019390890190613319565b8852505050938501935084016132b4565b5090979650505050505050565b600060a0828403121561337557600080fd5b61337d612bae565b905081356001600160401b038082111561339657600080fd5b6133a285838601612cad565b835260208401359150808211156133b857600080fd5b6133c485838601612d23565b602084015260408401359150808211156133dd57600080fd5b6133e985838601612cad565b6040840152606084013591508082111561340257600080fd5b61340e85838601612e93565b6060840152608084013591508082111561342757600080fd5b5061343484828501613270565b60808301525092915050565b6000806000806080858703121561345657600080fd5b8435935061346660208601612b59565b925060408501356001600160401b0381111561348157600080fd5b61348d87828801613363565b9250506060850135600681106134a257600080fd5b939692955090935050565b803563ffffffff81168114612b6b57600080fd5b600080600080608085870312156134d757600080fd5b843593506134e760208601612b59565b92506134f5604086016134ad565b9396929550929360600135925050565b60008060006060848603121561351a57600080fd5b8335925061352a60208501612b59565b9150604084013590509250925092565b600082601f83011261354b57600080fd5b8135602061355b612cce83612c8a565b828152600592831b850182019282820191908785111561357a57600080fd5b8387015b858110156133565780356001600160401b0381111561359d5760008081fd5b8801603f81018a136135af5760008081fd5b8581013560406135c1612cce83612c8a565b82815291851b8301810191888101908d8411156135de5760008081fd5b938201935b8385101561361557843592506001600160a01b03831683146136055760008081fd5b82825293890193908901906135e3565b88525050509385019350840161357e565b600082601f83011261363757600080fd5b81356020613647612cce83612c8a565b828152600592831b850182019282820191908785111561366657600080fd5b8387015b858110156133565780356001600160401b038111156136895760008081fd5b8801603f81018a1361369b5760008081fd5b8581013560406136ad612cce83612c8a565b82815291851b8301810191888101908d8411156136ca5760008081fd5b938201935b8385101561370157843592506001600160581b03831683146136f15760008081fd5b82825293890193908901906136cf565b88525050509385019350840161366a565b600060c0828403121561372457600080fd5b61372c612bd0565b905081356001600160401b038082111561374557600080fd5b61375185838601612cad565b8352602084013591508082111561376757600080fd5b61377385838601612d23565b6020840152604084013591508082111561378c57600080fd5b61379885838601612cad565b604084015260608401359150808211156137b157600080fd5b6137bd8583860161353a565b606084015260808401359150808211156137d657600080fd5b6137e285838601613626565b608084015260a08401359150808211156137fb57600080fd5b5061380884828501612f80565b60a08301525092915050565b60008060006060848603121561382957600080fd5b8335925061383960208501612b59565b915060408401356001600160401b0381111561385457600080fd5b61326686828701613712565b600060c0828403121561387257600080fd5b61387a612bd0565b905081356001600160401b038082111561389357600080fd5b61389f85838601612cad565b835260208401359150808211156138b557600080fd5b6138c185838601612d23565b602084015260408401359150808211156138da57600080fd5b6138e685838601612cad565b604084015260608401359150808211156138ff57600080fd5b61390b8583860161353a565b6060840152608084013591508082111561392457600080fd5b6137e285838601612f80565b60008060006060848603121561394557600080fd5b8335925061395560208501612b59565b915060408401356001600160401b0381111561397057600080fd5b61326686828701613860565b600082601f83011261398d57600080fd5b8135602061399d612cce83612c8a565b8083825260208201915060208460051b8701019350868411156139bf57600080fd5b602086015b84811015612d18576139d5816134ad565b83529183019183016139c4565b600060c082840312156139f457600080fd5b6139fc612bd0565b905081356001600160401b0380821115613a1557600080fd5b613a2185838601612cad565b83526020840135915080821115613a3757600080fd5b613a4385838601612d23565b60208401526040840135915080821115613a5c57600080fd5b613a6885838601612cad565b60408401526060840135915080821115613a8157600080fd5b613a8d8583860161397c565b60608401526080840135915080821115613aa657600080fd5b613ab28583860161397c565b608084015260a0840135915080821115613acb57600080fd5b5061380884828501612f12565b600080600060608486031215613aed57600080fd5b83359250613afd60208501612b59565b915060408401356001600160401b03811115613b1857600080fd5b613266868287016139e2565b600082601f830112613b3557600080fd5b81356020613b45612cce83612c8a565b82815260059290921b84018101918181019086841115613b6457600080fd5b8286015b84811015612d185780356001600160401b03811115613b875760008081fd5b613b958986838b0101612d23565b845250918301918301613b68565b600082601f830112613bb457600080fd5b81356020613bc4612cce83612c8a565b8083825260208201915060208460051b870101935086841115613be657600080fd5b602086015b84811015612d185780358060030b8114613c055760008081fd5b8352918301918301613beb565b600082601f830112613c2357600080fd5b81356020613c33612cce83612c8a565b82815260059290921b84018101918181019086841115613c5257600080fd5b8286015b84811015612d185780356001600160401b03811115613c755760008081fd5b613c838986838b0101613ba3565b845250918301918301613c56565b600082601f830112613ca257600080fd5b81356020613cb2612cce83612c8a565b82815260059290921b84018101918181019086841115613cd157600080fd5b8286015b84811015612d185780356001600160401b03811115613cf45760008081fd5b613d028986838b010161397c565b845250918301918301613cd5565b60006101a08284031215613d2357600080fd5b613d2b612bf2565b905081356001600160401b0380821115613d4457600080fd5b613d5085838601612cad565b83526020840135915080821115613d6657600080fd5b613d7285838601612d23565b60208401526040840135915080821115613d8b57600080fd5b613d9785838601612cad565b60408401526060840135915080821115613db057600080fd5b613dbc85838601613b24565b60608401526080840135915080821115613dd557600080fd5b613de185838601613c12565b608084015260a0840135915080821115613dfa57600080fd5b613e068583860161397c565b60a084015260c0840135915080821115613e1f57600080fd5b613e2b85838601613ba3565b60c084015260e0840135915080821115613e4457600080fd5b613e5085838601613ba3565b60e084015261010091508184013581811115613e6b57600080fd5b613e7786828701613ba3565b838501525061012091508184013581811115613e9257600080fd5b613e9e86828701613ba3565b838501525061014091508184013581811115613eb957600080fd5b613ec586828701613ba3565b838501525061016091508184013581811115613ee057600080fd5b613eec8682870161353a565b838501525061018091508184013581811115613f0757600080fd5b613f1386828701613c91565b8385015250505092915050565b600080600060608486031215613f3557600080fd5b83359250613f4560208501612b59565b915060408401356001600160401b03811115613f6057600080fd5b61326686828701613d10565b600082601f830112613f7d57600080fd5b81356020613f8d612cce83612c8a565b82815260059290921b84018101918181019086841115613fac57600080fd5b8286015b84811015612d185780356001600160401b03811115613fcf5760008081fd5b613fdd8986838b0101612cad565b845250918301918301613fb0565b600060a08284031215613ffd57600080fd5b614005612bae565b905081356001600160401b038082111561401e57600080fd5b61402a85838601612cad565b8352602084013591508082111561404057600080fd5b61404c85838601612d23565b6020840152604084013591508082111561406557600080fd5b61407185838601612cad565b6040840152606084013591508082111561408a57600080fd5b61409685838601612d23565b606084015260808401359150808211156140af57600080fd5b5061343484828501613f6c565b6000806000606084860312156140d157600080fd5b833592506140e160208501612b59565b915060408401356001600160401b038111156140fc57600080fd5b61326686828701613feb565b60006060828403121561411a57600080fd5b614122612c15565b905081356001600160401b038082111561413b57600080fd5b61414785838601612cad565b8352602084013591508082111561415d57600080fd5b61416985838601612d23565b6020840152604084013591508082111561418257600080fd5b5061418f84828501612cad565b60408301525092915050565b600060c082840312156141ad57600080fd5b6141b5612bd0565b905081356001600160401b03808211156141ce57600080fd5b6141da85838601612cad565b835260208401359150808211156141f057600080fd5b6141fc85838601612d23565b6020840152604084013591508082111561421557600080fd5b61422185838601612cad565b6040840152606084013591508082111561423a57600080fd5b61424685838601612f80565b6060840152608084013591508082111561425f57600080fd5b61426b85838601613b24565b608084015260a084013591508082111561428457600080fd5b5061380884828501613c12565b600060c082840312156142a357600080fd5b6142ab612bd0565b905081356001600160401b03808211156142c457600080fd5b6142d085838601612cad565b835260208401359150808211156142e657600080fd5b6142f285838601612d23565b6020840152604084013591508082111561430b57600080fd5b61431785838601612cad565b6040840152606084013591508082111561433057600080fd5b61433c85838601613b24565b6060840152608084013591508082111561435557600080fd5b6137e285838601613074565b60006060828403121561437357600080fd5b61437b612c15565b905081356001600160401b038082111561439457600080fd5b6143a085838601612cad565b835260208401359150808211156143b657600080fd5b6143c285838601612d23565b602084015260408401359150808211156143db57600080fd5b5061418f84828501613c91565b600080604083850312156143fb57600080fd5b8235915060208301356001600160401b038082111561441957600080fd5b908401906102c0828703121561442e57600080fd5b614436612c37565b61443f83612b59565b815260208301358281111561445357600080fd5b61445f88828601612e34565b60208301525060408301358281111561447757600080fd5b61448388828601612fff565b60408301525060608301358281111561449b57600080fd5b6144a788828601612fff565b6060830152506080830135828111156144bf57600080fd5b6144cb88828601612f12565b60808301525060a083013560a082015260c0830135828111156144ed57600080fd5b6144f988828601614108565b60c08301525060e08301358281111561451157600080fd5b61451d88828601613feb565b60e083015250610100808401358381111561453757600080fd5b6145438982870161419b565b828401525050610120808401358381111561455d57600080fd5b61456989828701613860565b828401525050610140808401358381111561458357600080fd5b61458f89828701613712565b82840152505061016080840135838111156145a957600080fd5b6145b5898287016139e2565b82840152505061018080840135838111156145cf57600080fd5b6145db898287016130f3565b8284015250506101a080840135838111156145f557600080fd5b614601898287016130f3565b8284015250506101c0808401358381111561461b57600080fd5b61462789828701614291565b8284015250506101e0808401358381111561464157600080fd5b61464d89828701614361565b828401525050610200808401358381111561466757600080fd5b61467389828701613d10565b828401525050610220808401358381111561468d57600080fd5b61469989828701613d10565b82840152505061024080840135838111156146b357600080fd5b6146bf89828701613363565b82840152505061026080840135838111156146d957600080fd5b6146e589828701613363565b82840152505061028080840135838111156146ff57600080fd5b61470b89828701613363565b8284015250506102a0808401358381111561472557600080fd5b61473189828701613363565b8284015250508093505050509250929050565b60008060006060848603121561475957600080fd5b8335925061476960208501612b59565b915060408401356001600160401b0381111561478457600080fd5b6132668682870161419b565b600080604083850312156147a357600080fd5b823591506147b3602084016134ad565b90509250929050565b60008060008060008060c087890312156147d557600080fd5b863595506147e560208801612b59565b945060408701356001600160401b0381111561480057600080fd5b61480c89828a01613d10565b945050606087013592506080870135915060a087013590509295509295509295565b60008060006060848603121561484357600080fd5b8335925061485360208501612b59565b915060408401356001600160401b0381111561486e57600080fd5b61326686828701614291565b600080600080600080600060e0888a03121561489557600080fd5b873596506148a560208901612b59565b955060408801356001600160401b03808211156148c157600080fd5b6148cd8b838c01612e34565b965060608a01359150808211156148e357600080fd5b6148ef8b838c01612fff565b955060808a013591508082111561490557600080fd5b6149118b838c01612fff565b945060a08a013591508082111561492757600080fd5b506149348a828b01612f12565b92505060c0880135905092959891949750929550565b60008060006060848603121561495f57600080fd5b8335925061496f60208501612b59565b915060408401356001600160401b0381111561498a57600080fd5b61326686828701614361565b634e487b7160e01b600052603260045260246000fd5b60008151808452602080850194506020840160005b838110156149e157815161ffff16875295820195908201906001016149c1565b509495945050505050565b60008151808452602080850194506020840160005b838110156149e157815160ff1687529582019590820190600101614a01565b61ffff85168152608060208201526000614a3d60808301866149ac565b8281036040840152614a4f81866149ec565b90508281036060840152614a6381856149ac565b979650505050505050565b600082825180855260208086019550808260051b8401018186016000805b85811015614adf57868403601f19018a52825180518086529086019086860190845b81811015614aca57835183529288019291880191600101614aae565b50509a86019a94505091840191600101614a8c565b509198975050505050505050565b60008151808452602080850194506020840160005b838110156149e1578151151587529582019590820190600101614b02565b60008282518085526020808601955060208260051b8401016020860160005b8481101561335657601f19868403018952614b5b838351614aed565b98840198925090830190600101614b3f565b600082825180855260208086019550808260051b8401018186016000805b85811015614adf57868403601f19018a52825180518086529086019086860190845b81811015614bd25783516001600160401b031683529288019291880191600101614bad565b50509a86019a94505091840191600101614b8b565b61ffff83168152604060208201526000825160e06040840152614c0e6101208401826149ac565b90506020840151603f1980858403016060860152614c2c83836149ec565b92506040860151915080858403016080860152614c4983836149ac565b925060608601519150808584030160a0860152614c668383614a6e565b925060808601519150808584030160c0860152614c838383614b20565b925060a08601519150808584030160e0860152614ca08383614b6d565b925060c08601519150808584030161010086015250614cbf8282614b6d565b9695505050505050565b634e487b7160e01b600052602160045260246000fd5b60068110614cfd57634e487b7160e01b600052602160045260246000fd5b9052565b61ffff8416815260006020606081840152845160a06060850152614d296101008501826149ac565b905081860151605f1980868403016080870152614d4683836149ec565b925060408801519150808684030160a0870152614d6383836149ac565b925060608801519150808684030160c0870152614d808383614a6e565b608089015187820390920160e08801528151808252909350908401915083830190600581901b840185016000805b83811015614e0457868303601f19018552855180518085529089019089850190845b81811015614def578351600190810b8452938c0193928c019201614dd0565b50509689019695890195935050600101614dae565b5050809650505050505050614e1c6040830184614cdf565b949350505050565b634e487b7160e01b600052601160045260246000fd5b600060ff821660ff8103614e5057614e50614e24565b60010192915050565b600082825180855260208086019550808260051b8401018186016000805b85811015614adf57868403601f19018a52825180518086529086019086860190845b81811015614ebe5783516001600160a01b031683529288019291880191600101614e99565b50509a86019a94505091840191600101614e77565b61ffff8316815260006020604081840152835160c06040850152614efb6101008501826149ac565b905081850151603f1980868403016060870152614f1883836149ec565b92506040870151915080868403016080870152614f3583836149ac565b925060608701519150808684030160a0870152614f528383614e59565b6080880151878203830160c089015280518083529194508501925084840190600581901b850186016000805b83811015614fda57878303601f1901855286518051808552908a01908a850190845b81811015614fc55783516001600160581b03168352928c0192918c0191600101614fa0565b5050978a0197958a0195935050600101614f7e565b505060a08a01519650838982030160e08a0152614ff78188614b20565b9b9a5050505050505050505050565b61ffff83168152604060208201526000825160c0604084015261502d6101008401826149ac565b90506020840151603f198085840301606086015261504b83836149ec565b9250604086015191508085840301608086015261506883836149ac565b925060608601519150808584030160a08601526150858383614e59565b925060808601519150808584030160c08601526150a28383614b20565b925060a08601519150808584030160e086015250614cbf8282614b20565b60008151808452602080850194506020840160005b838110156149e157815163ffffffff16875295820195908201906001016150d5565b61ffff83168152604060208201526000825160c0604084015261511e6101008401826149ac565b90506020840151603f198085840301606086015261513c83836149ec565b9250604086015191508085840301608086015261515983836149ac565b925060608601519150808584030160a086015261517683836150c0565b925060808601519150808584030160c086015261519383836150c0565b925060a08601519150808584030160e086015250614cbf8282614aed565b60008282518085526020808601955060208260051b8401016020860160005b8481101561335657601f198684030189526151ec8383516149ec565b988401989250908301906001016151d0565b60008151808452602080850194506020840160005b838110156149e157815160030b87529582019590820190600101615213565b60008282518085526020808601955060208260051b8401016020860160005b8481101561335657601f1986840301895261526d8383516151fe565b98840198925090830190600101615251565b60008282518085526020808601955060208260051b8401016020860160005b8481101561335657601f198684030189526152ba8383516150c0565b9884019892509083019060010161529e565b61ffff8316815260406020820152600082516101a08060408501526152f56101e08501836149ac565b91506020850151603f198086850301606087015261531384836149ec565b9350604087015191508086850301608087015261533084836149ac565b935060608701519150808685030160a087015261534d84836151b1565b935060808701519150808685030160c087015261536a8483615232565b935060a08701519150808685030160e087015261538784836150c0565b935060c087015191506101008187860301818801526153a685846151fe565b945060e088015192506101208288870301818901526153c586856151fe565b955081890151935061014091508288870301828901526153e586856151fe565b95508089015193505061016082888703018189015261540486856151fe565b9550818901519350610180915082888703018289015261542486856151fe565b9550808901519350508187860301848801526154408584614e59565b94508088015193505080868503016101c08701525050614cbf828261527f565b61ffff8316815260006020604081840152835160a0604085015261548760e08501826149ac565b905081850151603f19808684030160608701526154a483836149ec565b925060408701519150808684030160808701526154c183836149ac565b925060608701519150808684030160a08701526154de83836149ec565b608088015187820390920160c08801528151808252909350908401915083830190600581901b8401850160005b8281101561553957601f198683030184526155278286516149ac565b9487019493870193915060010161550b565b509998505050505050505050565b61ffff83168152604060208201526000825160c0604084015261556e6101008401826149ac565b90506020840151603f198085840301606086015261558c83836149ec565b925060408601519150808584030160808601526155a983836149ac565b925060608601519150808584030160a08601526155c68383614b20565b925060808601519150808584030160c08601526155e383836151b1565b925060a08601519150808584030160e086015250614cbf8282615232565b61ffff83168152604060208201526000825160c060408401526156286101008401826149ac565b90506020840151603f198085840301606086015261564683836149ec565b9250604086015191508085840301608086015261566383836149ac565b925060608601519150808584030160a086015261568083836151b1565b925060808601519150808584030160c08601526150a28383614b6d565b61ffff831681526040602082015260008251606060408401526156c360a08401826149ac565b90506020840151603f19808584030160608601526156e183836149ec565b9250604086015191508085840301608086015250614cbf828261527f565b60008261571c57634e487b7160e01b600052601260045260246000fd5b500490565b8082018082111561239457612394614e24565b808202811582820484141761239457612394614e24565b8181038181111561239457612394614e24565b634e487b7160e01b600052603160045260246000fdfea264697066735822122080768d5588cb9f9bb1c9ef8e0b685768fcea790ef05c2464f73af6dffa48fb1964736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "setBurnItemsMeta(IStoryController.MainState storage,uint16,IStoryController.AnswerBurnRandomItemMeta)": {
        "details": "Since SIP-003 the burning is replaced by breaking"
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "IncompatibleInputString()": [
        {
          "notice": "packCustomDataChange requires an input string with two zero bytes at the beginning         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000 This error happens if these bytes are not zero"
        }
      ]
    },
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}