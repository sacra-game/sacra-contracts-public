{
  "address": "0xdB3eb5370d642CF68B38D78a3E202fe72D17ed17",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pawnShop_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "gameToken_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "deployed",
          "type": "address"
        }
      ],
      "name": "AlreadyDeployed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "pawnShop",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "gameToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "routerOwner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "deployed",
          "type": "address"
        }
      ],
      "name": "PawnShopRouterDeployed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "deployRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gameToken",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pawnShop",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "router",
      "outputs": [
        {
          "internalType": "address",
          "name": "router",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xe4d5ac5bd4d2596a3486b70b8f61559b8d4520e4094a8486c2f0a0ddff0d5dd9",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0xdB3eb5370d642CF68B38D78a3E202fe72D17ed17",
    "transactionIndex": 0,
    "gasUsed": "2451441",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0004ae6f0000292711405df725b889121c877a5444e0c91dfa223138661f7193",
    "transactionHash": "0xe4d5ac5bd4d2596a3486b70b8f61559b8d4520e4094a8486c2f0a0ddff0d5dd9",
    "logs": [],
    "blockNumber": 92345646,
    "cumulativeGasUsed": "2451441",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xfc0a5E585Ddc9bD07D5513848d1232b00F9e8264",
    "0xe4436821E403e78a6Dd62f7a9F5611f97a18f44C"
  ],
  "numDeployments": 1,
  "solcInputHash": "d9ffe6b6ea34889802b7fb760a8d08cb",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pawnShop_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gameToken_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployed\",\"type\":\"address\"}],\"name\":\"AlreadyDeployed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pawnShop\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gameToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"routerOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"deployed\",\"type\":\"address\"}],\"name\":\"PawnShopRouterDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"deployRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pawnShop\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"VERSION\":{\"details\":\"Should be incremented when contract changed\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"VERSION()\":{\"notice\":\"Version of the contract\"},\"deployRouter(address)\":{\"notice\":\"Deploy {PawnShopRouter} for the given {user}. Any user is allowed to have only one instance of deployed router. Address of the deployed router can be taken through {deployedRouter}\"},\"router(address)\":{\"notice\":\"Deployed instances of PawnShopRouter for the given users\"}},\"notice\":\"Factory to deploy personal instances of PawnShopRouter\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/marketplace/PawnShopRouterFactory.sol\":\"PawnShopRouterFactory\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":50},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IAppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @notice All errors of the app\\ninterface IAppErrors {\\n  error ZeroAddress();\\n  error ZeroValueNotAllowed();\\n  error LengthsMismatch();\\n  error NotEnoughBalance();\\n  error EmptyNameNotAllowed();\\n  error NotInitialized();\\n  error AlreadyInitialized();\\n  error ReentrancyGuardReentrantCall();\\n  error TooLongString();\\n  error AlreadyDeployed(address deployed);\\n\\n  //region Restrictions\\n  error ErrorNotDeployer(address sender);\\n  error ErrorNotGoc();\\n  error NotGovernance(address sender);\\n  error ErrorOnlyEoa();\\n  error NotEOA(address sender);\\n  error ErrorForbidden(address sender);\\n  error ErrorNotItemController(address sender);\\n  error ErrorNotHeroController(address sender);\\n  error ErrorNotDungeonFactory(address sender);\\n  error ErrorNotObjectController(address sender);\\n  error ErrorNotStoryController();\\n  error ErrorNotAllowedSender();\\n  error MintNotAllowed();\\n  //endregion Restrictions\\n\\n  //region Hero\\n  error ErrorHeroIsNotRegistered(address heroToken);\\n  error ErrorHeroIsDead(address heroToken, uint heroTokenId);\\n  error ErrorHeroNotInDungeon();\\n  error HeroInDungeon();\\n  error ErrorNotHeroOwner(address heroToken, address msgSender);\\n  error Staked(address heroToken, uint heroId);\\n  error HeroTokensVaultAlreadySet();\\n  error NameTaken();\\n  error TooBigName();\\n  error WrongSymbolsInTheName();\\n  error NoPayToken(address token, uint payTokenAmount);\\n  error AlreadyHaveReinforcement();\\n  /// @notice SIP-001 - Reinforcement requires 3 skills\\n  error ErrorReinforcementRequiresThreeSkills();\\n  //endregion Hero\\n\\n  //region Dungeon\\n  error ErrorDungeonIsFreeAlready();\\n  error ErrorNoEligibleDungeons();\\n  error ErrorDungeonBusy();\\n  error ErrorNoDungeonsForBiome(uint8 heroBiome);\\n  error ErrorDungeonCompleted();\\n  error ErrorAlreadyInDungeon();\\n  error NotEnoughTokens(uint balance, uint expectedBalance);\\n  error DungeonAlreadySpecific(uint16 dungNum);\\n  error DungeonAlreadySpecific2(uint16 dungNum);\\n  error WrongSpecificDungeon();\\n  //endregion Dungeon\\n\\n  //region Items\\n  error ErrorItemNotEligibleForTheSlot(uint itemType, uint8 itemSlot);\\n  error ErrorItemSlotBusyHand(uint8 slot);\\n  error ErrorItemSlotBusy();\\n  error ErrorItemNotInSlot();\\n  error ErrorConsumableItemIsUsed(address item);\\n  error ErrorCannotRemoveItemFromMap();\\n  error ItemEquipped();\\n  error ZeroItemMetaType();\\n  error ZeroLevel();\\n  error ItemTypeChanged();\\n  error ItemMetaTypeChanged();\\n  error UnknownItem(address item);\\n  error ItemIsAlreadyEquipped(address item);\\n  error ErrorEquipForbidden();\\n  error EquipForbiddenInDungeon();\\n  error TakeOffForbiddenInDungeon();\\n  error Consumable(address item);\\n  error NotConsumable(address item);\\n  error Broken(address item);\\n  error ZeroLife();\\n  error RequirementsToItemAttributes();\\n  error NotEquipped(address item);\\n  error ZeroDurability();\\n  error ZeroAugmentation();\\n  error TooHighAgLevel(uint8 augmentationLevel);\\n  error UseForbiddenZeroPayToken();\\n  error IncorrectMinMaxAttributeRange(int32 min, int32 max);\\n  error SameIdsNotAllowed();\\n  error DoubleItemUsageForbidden(uint itemIndex, address[] items);\\n  error ItemAlreadyUsedInSlot(address item, uint8 equippedSlot);\\n  //endregion Items\\n\\n  //region Stages\\n  error ErrorWrongStage(uint stage);\\n  error ErrorNotStages();\\n  //endregion Stages\\n\\n  //region Level\\n  error ErrorWrongLevel(uint heroLevel);\\n  error ErrorLevelTooLow(uint heroLevel);\\n  error ErrorHeroLevelStartFrom1();\\n  error ErrorWrongLevelUpSum();\\n  error ErrorMaxLevel();\\n  //endregion Level\\n\\n  //region Treasure\\n  error ErrorNotValidTreasureToken(address treasureToken);\\n  //endregion Treasure\\n\\n  //region State\\n  error ErrorPaused();\\n  error ErrorNotReady();\\n  error ErrorNotObject1();\\n  error ErrorNotObject2();\\n  error ErrorNotCompleted();\\n  //endregion State\\n\\n  //region Biome\\n  error ErrorNotBiome();\\n  error ErrorIncorrectBiome(uint biome);\\n  error TooHighBiome(uint biome);\\n  //endregion Biome\\n\\n  //region Misc\\n  error ErrorWrongMultiplier(uint multiplier);\\n  error ErrorNotEnoughMana(uint32 mana, uint requiredMana);\\n  error ErrorExperienceMustNotDecrease();\\n  error ErrorNotEnoughExperience();\\n  error ErrorNotChances();\\n  error ErrorNotEligible(address heroToken, uint16 dungNum);\\n  error ErrorZeroKarmaNotAllowed();\\n  //endregion Misc\\n\\n  //region GOC\\n  error GenObjectIdBiomeOverflow(uint8 biome);\\n  error GenObjectIdSubTypeOverflow(uint subType);\\n  error GenObjectIdIdOverflow(uint id);\\n  error UnknownObjectTypeGoc1(uint8 objectType);\\n  error UnknownObjectTypeGoc2(uint8 objectType);\\n  error UnknownObjectTypeGocLib1(uint8 objectType);\\n  error UnknownObjectTypeGocLib2(uint8 objectType);\\n  error UnknownObjectTypeForSubtype(uint8 objectSubType);\\n  error FightDelay();\\n  error ZeroChance();\\n  error TooHighChance(uint32 chance);\\n  error TooHighRandom(uint random);\\n  error EmptyObjects();\\n  error ObjectNotFound();\\n  error WrongGetObjectTypeInput();\\n  error WrongChances(uint32 chances, uint32 maxChances);\\n  //endregion GOC\\n\\n  //region Story\\n  error PageNotRemovedError(uint pageId);\\n  error NotItem1();\\n  error NotItem2();\\n  error NotRandom(uint32 random);\\n  error NotHeroData();\\n  error NotGlobalData();\\n  error ZeroStoryIdRemoveStory();\\n  error ZeroStoryIdStoryAction();\\n  error ZeroStoryIdAction();\\n  error NotEnoughAmount(uint balance, uint requiredAmount);\\n  error NotAnswer();\\n  error AnswerStoryIdMismatch(uint16 storyId, uint16 storyIdFromAnswerHash);\\n  error AnswerPageIdMismatch(uint16 pageId, uint16 pageIdFromAnswerHash);\\n  //endregion Story\\n\\n  //region FightLib\\n  error NotMagic();\\n  error NotAType(uint atype);\\n  //endregion FightLib\\n\\n  //region MonsterLib\\n  error NotYourDebuffItem();\\n  error UnknownAttackType(uint attackType);\\n  error NotYourAttackItem();\\n  /// @notice The skill item cannot be used because it doesn't belong either to the hero or to the hero's helper\\n  error NotYourBuffItem();\\n  //endregion MonsterLib\\n\\n  //region GameToken\\n  error ApproveToZeroAddress();\\n  error MintToZeroAddress();\\n  error TransferToZeroAddress();\\n  error TransferAmountExceedsBalance(uint balance, uint value);\\n  error InsufficientAllowance();\\n  error BurnAmountExceedsBalance();\\n  error NotMinter(address sender);\\n  //endregion GameToken\\n\\n  //region NFT\\n  error TokenTransferNotAllowed();\\n  error IdOverflow(uint id);\\n  error NotExistToken(uint tokenId);\\n  error EquippedItemIsNotAllowedToTransfer(uint tokenId);\\n  //endregion NFT\\n\\n  //region CalcLib\\n  error TooLowX(uint x);\\n  //endregion CalcLib\\n\\n  //region Controller\\n  error NotFutureGovernance(address sender);\\n  //endregion Controller\\n\\n  //region Oracle\\n  error OracleWrongInput();\\n  //region Oracle\\n\\n  //region ReinforcementController\\n  error AlreadyStaked();\\n  error MaxFee(uint8 fee);\\n  error MinFee(uint8 fee);\\n  error StakeHeroNotStats();\\n  error NotStaked();\\n  error NoStakedHeroes();\\n  //region ReinforcementController\\n\\n  //region SponsoredHero\\n  error InvalidHeroClass();\\n  error ZeroAmount();\\n  error InvalidProof();\\n  error NoHeroesAvailable();\\n  error AlreadyRegistered();\\n  //endregion SponsoredHero\\n\\n  //region SacraRelay\\n  error SacraRelayNotOwner();\\n  error SacraRelayNotDelegator();\\n  error SacraRelayNotOperator();\\n  error SacraRelayInvalidChainId(uint callChainId, uint blockChainId);\\n  error SacraRelayInvalidNonce(uint callNonce, uint txNonce);\\n  error SacraRelayDeadline();\\n  error SacraRelayDelegationExpired();\\n  error SacraRelayNotAllowed();\\n  error SacraRelayInvalidSignature();\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error by selector, see tests\\n  error SacraRelayNoErrorSelector(bytes4 selector, string tracingInfo);\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error manually from {errorBytes} as following:\\n  /// if (keccak256(abi.encodeWithSignature(\\\"MyError()\\\")) == keccak256(errorBytes)) { ... }\\n  error SacraRelayUnexpectedReturnData(bytes errorBytes, string tracingInfo);\\n  error SacraRelayCallToNotContract(address notContract, string tracingInfo);\\n  //endregion SacraRelay\\n\\n  //region Misc\\n  error UnknownHeroClass(uint heroClass);\\n  error AbsDiff(int32 a, int32 b);\\n  //region Misc\\n\\n  //region ------------------------ Guilds\\n  error NoAvailableLootBox(address msgSender, uint lootBoxKind);\\n  error AlreadyGuildMember();\\n  error NotGuildMember();\\n  error WrongGuild();\\n  error GuildActionForbidden(uint right);\\n  error GuildHasMaxSize(uint guildSize);\\n  error GuildHasMaxLevel(uint level);\\n  error TooLongUrl();\\n  error CannotRemoveGuildOwnerFromNotEmptyGuild();\\n  error GuildControllerOnly();\\n  error GuildAlreadyHasShelter();\\n  error ShelterIsBusy();\\n  error ShelterIsNotRegistered();\\n  error ShelterIsNotOwnedByTheGuild();\\n  error ShelterIsInUse();\\n  error GuildHasNoShelter();\\n  error ShelterBidIsNotAllowedToBeUsed();\\n  error ShelterHasHeroesInside();\\n  error SecondGuildAdminIsNotAllowed();\\n  error UserTokensVaultAlreadySet();\\n  error GuildRequestNotActive();\\n  error GuildRequestNotAvailable();\\n  //endregion ------------------------ Guilds\\n\\n  //region ------------------------ Pawnshop\\n  error AuctionPositionNotSupported(uint positionId);\\n  error PositionNotSupported(uint positionId);\\n  error NotNftPositionNotSupported(uint positionId);\\n  error CallFailed(bytes callResultData);\\n\\n  error PawnShopZeroOwner();\\n  error PawnShopZeroFeeRecipient();\\n  error PawnShopNotOwner();\\n  error PawnShopAlreadyAnnounced();\\n  error PawnShopTimeLock();\\n  error PawnShopWrongAddressValue();\\n  error PawnShopWrongUintValue();\\n  error PawnShopZeroAddress();\\n  error PawnShopTooHighValue();\\n  error PawnShopZeroAToken();\\n  error PawnShopZeroCToken();\\n  error PawnShopWrongAmounts();\\n  error PawnShopPosFeeForInstantDealForbidden();\\n  error PawnShopPosFeeAbsurdlyHigh();\\n  error PawnShopIncorrect();\\n  error PawnShopWrongId();\\n  error PawnShopNotBorrower();\\n  error PawnShopPositionClosed();\\n  error PawnShopPositionExecuted();\\n  error PawnShopWrongBidAmount();\\n  error PawnShopTooLowBid();\\n  error PawnShopNewBidTooLow();\\n  error PawnShopBidAlreadyExists();\\n  error PawnShopAuctionEnded();\\n  error PawnShopNotLender();\\n  error PawnShopTooEarlyToClaim();\\n  error PawnShopPositionNotExecuted();\\n  error PawnShopAlreadyClaimed();\\n  error PawnShopAuctionNotEnded();\\n  error PawnShopBidClosed();\\n  error PawnShopNoBids();\\n  error PawnShopAuctionBidNotFound();\\n  error PawnShopWrongBid();\\n  error PawnShopBidNotFound();\\n\\n\\n  //endregion ------------------------ Pawnshop\\n}\\n\\n\",\"keccak256\":\"0x38a5efa0ad767382d3d47942528d06bb410bb6a60d50984e6fbc7bbae3f3b24f\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IApplicationEvents.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IDungeonFactory.sol\\\";\\nimport \\\"./IStoryController.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\n\\n/// @notice All events of the app\\ninterface IApplicationEvents {\\n\\n  //region ------------------ StatController\\n  event HeroItemSlotChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint itemType,\\n    uint itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip,\\n    address caller\\n  );\\n  event CurrentStatsChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats change,\\n    bool increase,\\n    address caller\\n  );\\n  event BonusAttributesChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    bool add,\\n    bool temporally,\\n    address caller\\n  );\\n  event TemporallyAttributesCleared(address heroToken, uint heroTokenId, address caller);\\n  event NewHeroInited(address heroToken, uint heroTokenId, IStatController.ChangeableStats stats);\\n  event LevelUp(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes change\\n  );\\n  event ConsumableUsed(address heroToken, uint heroTokenId, address item);\\n  event RemoveConsumableUsage(address heroToken, uint heroTokenId, address item);\\n  event HeroCustomDataChanged(address token, uint tokenId, bytes32 index, uint value);\\n  event GlobalCustomDataChanged(bytes32 index, uint value);\\n  //endregion ------------------ StatController\\n\\n  //region ------------------ DungeonFactoryController\\n  event DungeonLaunched(\\n    uint16 dungeonLogicNum,\\n    uint64 dungeonId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken,\\n    uint treasuryAmount\\n  );\\n\\n  event BossCompleted(uint32 objectId, uint biome, address hero, uint heroId);\\n  event FreeDungeonAdded(uint8 biome, uint64 dungeonId);\\n\\n  event ObjectOpened(uint64 dungId, address hero, uint id, uint32 objId, uint iteration, uint currentStage);\\n  event Clear(uint64 dungId);\\n\\n  event DungeonLogicRegistered(uint16 dungLogicId, IDungeonFactory.DungeonGenerateInfo info);\\n  event DungeonLogicRemoved(uint16 dungLogicId);\\n  event DungeonSpecificLogicRegistered(uint16 dungLogicId, uint biome, uint heroCls);\\n  event DungeonSpecificLogicRemoved(uint16 dungLogicId, uint heroLvl, uint heroCls);\\n  event DungeonRegistered(uint16 dungLogicId, uint64 dungeonId);\\n  event DungeonRemoved(uint16 dungLogicId, uint64 dungeonId);\\n  event MinLevelForTreasuryChanged(address token, uint level);\\n\\n  event ObjectAction(\\n    uint64 dungId,\\n    IGOC.ActionResult result,\\n    uint currentStage,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint newStage\\n  );\\n  /// @notice On add the item to the dungeon\\n  event AddTreasuryItem(uint64 dungId, address itemAdr, uint itemId);\\n  event AddTreasuryToken(uint64 dungId, address token, uint amount);\\n  event ClaimToken(uint64 dungId, address token, uint amount);\\n  event ClaimItem(uint64 dungId, address token, uint id);\\n\\n  event Entered(uint64 dungId, address hero, uint id);\\n  event DungeonCompleted(uint16 dungLogicNum, uint64 dungId, address hero, uint heroId);\\n  event Exit(uint64 dungId, bool claim);\\n  event FreeDungeonRemoved(uint8 biome, uint64 dungeonId);\\n  event HeroCurrentDungeonChanged(address hero, uint heroId, uint64 dungeonId);\\n  //endregion ------------------ DungeonFactoryController\\n\\n  //region ------------------ GameObjectController\\n  event EventRegistered(uint32 objectId, IGOC.EventRegInfo eventRegInfo);\\n  event StoryRegistered(uint32 objectId, uint16 storyId);\\n  event MonsterRegistered(uint32 objectId, IGOC.MonsterGenInfo monsterGenInfo);\\n  event ObjectRemoved(uint32 objectId);\\n  event ObjectResultEvent(\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    IGOC.ObjectType objectType,\\n    address hero,\\n    uint heroId,\\n    uint8 stageId,\\n    uint iteration,\\n    bytes data,\\n    IGOC.ActionResult result,\\n    uint salt\\n  );\\n  //endregion ------------------ GameObjectController\\n\\n  //region ------------------ StoryController\\n  event SetBurnItemsMeta(uint storyId, IStoryController.AnswerBurnRandomItemMeta meta);\\n  event SetNextObjRewriteMeta(uint storyId, IStoryController.NextObjRewriteMeta meta);\\n  event SetAnswersMeta(uint storyId, uint16[] answerPageIds, uint8[] answerHeroClasses, uint16[] answerIds);\\n  event SetAnswerNextPageMeta(uint storyId, IStoryController.AnswerNextPageMeta meta);\\n  event SetAnswerAttributeRequirements(uint storyId, IStoryController.AnswerAttributeRequirementsMeta meta);\\n  event SetAnswerItemRequirements(uint storyId, IStoryController.AnswerItemRequirementsMeta meta);\\n  event SetAnswerTokenRequirementsMeta(uint storyId, IStoryController.AnswerTokenRequirementsMeta meta);\\n  event SetAnswerAttributes(uint storyId, IStoryController.AnswerAttributesMeta meta);\\n  event SetAnswerHeroCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetAnswerGlobalCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetSuccessInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetFailInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetCustomDataResult(uint storyId, IStoryController.AnswerCustomDataResultMeta meta, IStoryController.CustomDataResult _type);\\n  event StoryCustomDataRequirements(uint storyId, bytes32 requiredCustomDataIndex, uint requiredCustomDataMinValue, uint requiredCustomDataMaxValue, bool requiredCustomDataIsHero);\\n  event StoryRequiredLevel(uint storyId, uint requiredLevel);\\n  event StoryFinalized(uint32 objectId, uint storyId);\\n  event StoryRemoved(uint32 objectId, uint storyId);\\n\\n  event ItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  /// @notice Durability of the item was reduced to 0\\n  event ItemBroken(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n\\n  event NotEquippedItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event StoryChangeAttributes(\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    uint stageId,\\n    uint iteration,\\n    int32[] attributes\\n  );\\n  //endregion ------------------ StoryController\\n\\n  //region ------------------------ HeroController\\n  event HeroTokensVaultSet(address value);\\n  event HeroRegistered(address hero, uint8 heroClass, address payToken, uint payAmount);\\n  event HeroCreated(address hero, uint heroId, string name, address owner, string refCode);\\n  event BiomeChanged(address hero, uint heroId, uint8 biome);\\n  event LevelUp(address hero, uint heroId, address owner, IStatController.CoreAttributes change);\\n  event ReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event ReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event Killed(address hero, uint heroId, address killer, bytes32[] dropItems, uint dropTokenAmount);\\n  //endregion ------------------------ HeroController\\n\\n  //region ------------------------ FightLib\\n  event FightResultProcessed(\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    IFightCalculator.FightCall callData,\\n    uint iteration\\n  );\\n  //endregion ------------------------ FightLib\\n\\n  //region ------------------------ Oracle\\n  event Random(uint number, uint max);\\n  //endregion ------------------------ Oracle\\n\\n  //region ------------------------ Controller\\n  event OfferGovernance(address newGov);\\n  event GovernanceAccepted(address gov);\\n  event StatControllerChanged(address value);\\n  event StoryControllerChanged(address value);\\n  event GameObjectControllerChanged(address value);\\n  event ReinforcementControllerChanged(address value);\\n  event OracleChanged(address value);\\n  event TreasuryChanged(address value);\\n  event ItemControllerChanged(address value);\\n  event HeroControllerChanged(address value);\\n  event GameTokenChanged(address value);\\n  event DungeonFactoryChanged(address value);\\n  event ProxyUpdated(address proxy, address logic);\\n  event Claimed(address token, uint amount);\\n  event TokenStatusChanged(address token, bool status);\\n  event UserControllerChanged(address value);\\n  event GuildControllerChanged(address value);\\n  //endregion ------------------------ Controller\\n\\n  //region ------------------------ HeroTokensVault\\n  event Process(address token, uint amount, address from, uint toBurn, uint toTreasury, uint toGov);\\n  //endregion ------------------------ HeroTokensVault\\n\\n  //region ------------------------ ReinforcementController\\n  event HeroStaked(address heroToken, uint heroId, uint biome, uint score);\\n  event HeroWithdraw(address heroToken, uint heroId);\\n  event HeroAsk(address heroToken, uint heroId);\\n  event TokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint totalAmount);\\n  event NftRewardRegistered(address heroToken, uint heroId, address token, uint id);\\n  event ToHelperRatioChanged(uint value);\\n  event ClaimedToken(address heroToken, uint heroId, address token, uint amount, address recipient);\\n  event ClaimedItem(address heroToken, uint heroId, address item, uint itemId, address recipient);\\n  event MinLevelChanged(uint8 value);\\n  event MinLifeChancesChanged(uint value);\\n  //endregion ------------------------ ReinforcementController\\n\\n  //region ------------------------ Treasury\\n  event AssetsSentToDungeon(address dungeon, address token, uint amount);\\n  //endregion ------------------------ Treasury\\n\\n  //region ------------------------ EventLib\\n  event EventResult(uint64 dungeonId, address heroToken, uint heroTokenId, uint8 stageId, IStatController.ActionInternalInfo gen, uint iteration);\\n  //endregion ------------------------ EventLib\\n\\n  //region ------------------------ ItemStatsLib\\n  event ItemRegistered(address item, IItemController.RegisterItemParams info);\\n  event ItemRemoved(address item);\\n  event NewItemMinted(address item, uint itemId, IItemController.MintInfo info);\\n  event Equipped(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot);\\n  event TakenOff(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot, address destination);\\n  event ItemRepaired(address item, uint itemId, uint consumedItemId, uint16 baseDurability);\\n  event FailedToRepairItem(address item, uint itemId, uint consumedItemId, uint16 itemDurability);\\n  event Augmented(address item, uint itemId, uint consumedItemId, uint8 augLevel, IItemController.AugmentInfo info);\\n  event NotAugmented(address item, uint itemId, uint consumedItemId, uint8 augLevel);\\n  event ReduceDurability(address item, uint itemId, uint newDurability);\\n  event Used(address item, uint tokenId, address heroToken, uint heroTokenId);\\n  event Destroyed(address item, uint itemId);\\n  //endregion ------------------------ ItemStatsLib\\n\\n  //region ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n  event ChangePauseStatus(bool value);\\n  event MinterChanged(address value);\\n\\n  event UniqueUriChanged(uint id, string uri);\\n  event BaseUriChanged(string uri);\\n\\n  event HeroMinted(uint heroId);\\n  event HeroBurned(uint heroId);\\n  event HeroUriByStatusChanged(string uri, uint statusLvl);\\n\\n  event ItemMinted(uint tokenId);\\n  event ItemBurned(uint tokenId);\\n  event UriByRarityChanged(string uri, uint rarity);\\n  event SponsoredHeroCreated(address msgSender, address heroAddress, uint heroId, string heroName);\\n  //endregion ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n\\n  //region ------------------------ Guild\\n  event SetUserName(address user, string name);\\n  event LootBoxOpened(address user, uint lootBoxKind, address[] itemTokens, uint[] itemTokenIds);\\n  event LootBoxConfigChanged(uint lootBoxKind, address[] mintItems, uint32[] mintItemsChances, uint maxDropItems);\\n  event SetFeeRenaming(uint feeRenaming);\\n  event ActivityCompleted(address user, bool daily, bool weekly);\\n\\n  event GuildCreated(address owner, uint guildId, string name, string urlLogo);\\n  event AddToGuild(uint guildId, address newUser);\\n  event ChangeGuildRights(uint guildId, address user, uint rights);\\n  event RemoveFromGuild(uint guildId, address user);\\n  event GuildDeleted(uint guildId);\\n  event GuildLevelUp(uint guildId, uint8 newLevel);\\n  event GuildRename(uint guildId, string newName);\\n  event GuildLogoChanged(uint guildId, string newLogoUrl);\\n  event SetGuildRelation(uint guildId1, uint guildId2, bool peace);\\n  event TransferFromGuildBank(address user, address token, uint amount, address recipient);\\n  event TransferNftFromGuildBank(address user, address[] nfts, uint[] tokenIds, address recipient);\\n  event GuildBankDeployed(uint guildId, address guildBank);\\n\\n  event UserTokensVaultSet(address value);\\n  event GuildRequestRegistered(address msgSender, uint guildId, string userMessage, uint depositAmount);\\n  event GuildRequestStatusChanged(address msgSender, uint guildRequestId, uint8 newStatus, address user);\\n  event SetToHelperRatio(uint guildId, address msgSender, uint8 toHelperRatio);\\n  event SetGuildRequestDepositAmount(uint guildId, address msgSender, uint amount);\\n  event SetGuildBaseFee(uint fee);\\n  //endregion ------------------------ Guild\\n\\n  //region ------------------------ Pawnshop\\n  event PawnShopRouterDeployed(address pawnShop, address gameToken, address routerOwner, address deployed);\\n  event PawnShopRouterTransfer(address token, uint amount, address receiver);\\n  event PawnShopRouterBulkSell(address[] nfts, uint[] nftIds, uint[] prices, address nftOwner, uint[] positionIds);\\n  event PawnShopRouterClosePositions(uint[] positionIds, address receiver);\\n  event PawnShopRouterBulkBuy(uint[] positionIds, address receiver);\\n\\n  //endregion ------------------------ Pawnshop\\n\\n}\\n\",\"keccak256\":\"0x0a6c0621a8916e378b9019c18b0b219bc385fc920a9ba8b6485b22d806b59c15\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IControllable {\\n\\n  function VERSION() external pure returns (string memory);\\n\\n  function revision() external view returns (uint);\\n\\n  function previousImplementation() external view returns (address);\\n\\n  function isController(address contract_) external view returns (bool);\\n\\n  function isGovernance(address contract_) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0x296b634c46b5d178b2408523fcf569ed370e20a719b7b3f2183b278631b94f65\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IController {\\n\\n  function governance() external view returns (address);\\n\\n  function statController() external view returns (address);\\n\\n  function storyController() external view returns (address);\\n\\n  function gameObjectController() external view returns (address);\\n\\n  function reinforcementController() external view returns (address);\\n\\n  function oracle() external view returns (address);\\n\\n  function treasury() external view returns (address);\\n\\n  function itemController() external view returns (address);\\n\\n  function heroController() external view returns (address);\\n\\n  function dungeonFactory() external view returns (address);\\n\\n  function gameToken() external view returns (address);\\n\\n  function validTreasuryTokens(address token) external view returns (bool);\\n\\n  function isDeployer(address adr) external view returns (bool);\\n\\n  function onPause() external view returns (bool);\\n\\n  function userController() external view returns (address);\\n\\n  function guildController() external view returns (address);\\n}\\n\",\"keccak256\":\"0xae4746df4915fbe35e8f0a582097b4c8cc3ee4da249d403c89a990648177b3ee\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDungeonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IDungeonFactory {\\n\\n  /// @custom:storage-location erc7201:dungeon.factory.main\\n  struct MainState {\\n    /// @dev biome => dungeonLaunchedId\\n    mapping(uint => EnumerableSet.UintSet) freeDungeons;\\n    /// @dev hero + heroId + biome (packMapObject) -> completed\\n    mapping(bytes32 => bool) bossCompleted;\\n    /// @dev hero + heroId + dungNum (packDungeonKey) -> completed\\n    mapping(bytes32 => bool) specificDungeonCompleted;\\n    /// @notice Max biome completed by the hero\\n    /// @dev hero + heroId (nftPacked) -> max biome completed\\n    mapping(bytes32 => uint8) maxBiomeCompleted;\\n    /// @notice which dungeon the hero is currently in\\n    /// @dev hero+id => current DungeonId\\n    mapping(bytes32 => uint64) heroCurrentDungeon;\\n\\n    // ---\\n\\n    /// @notice Specific dungeon for the given pair of hero level + hero class\\n    ///         ALl specific dungeons are listed also in allSpecificDungeons\\n    /// @dev packUint8Array(specReqBiome, specReqHeroClass) => dungNum\\n    mapping(bytes32 => uint16) dungeonSpecific;\\n    /// @dev contains all specific dungNum for easy management\\n    EnumerableSet.UintSet allSpecificDungeons;\\n    /// @dev biome => dungNum\\n    mapping(uint8 => EnumerableSet.UintSet) dungeonsLogicByBiome;\\n\\n    // ---\\n\\n    /// @dev max available biome. auto-increment with new dung deploy\\n    uint8 maxBiome;\\n\\n    /// @notice Address of treasure token => min hero level required\\n    /// @dev manual threshold for treasury\\n    mapping(address => uint) minLevelForTreasury;\\n\\n    /// @notice Contains arrays for SKILL_1, SKILL_2, SKILL_3 with 0 or 1\\n    /// i.e. [0, 1, 0] means that durability of SKILL_2 should be reduced\\n    /// @dev hero + heroId => uint8[] array where idx = slotNum\\n    mapping(bytes32 => bytes32) skillSlotsForDurabilityReduction;\\n\\n    /// @notice Counter of dungeons, it's incremented on launch of a new dungeon\\n    uint64 dungeonCounter;\\n\\n    /// @dev dungNum = init attributes\\n    mapping(uint16 => DungeonAttributes) dungeonAttributes;\\n    /// @dev dungeonId => status\\n    mapping(uint64 => DungeonStatus) dungeonStatuses;\\n  }\\n\\n  struct ObjectGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    /// @dev uint8 types, packed using PackingLib.packUint8Array\\n    bytes32[] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    /// @dev uint64 chances\\n    uint32[][] objChancesByStages;\\n  }\\n\\n  struct DungeonGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    uint8[][] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    uint32[][] objChancesByStages;\\n\\n    uint32[] uniqObjects;\\n\\n    uint8 minLevel;\\n    uint8 maxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n  }\\n\\n  /// @notice Attributes of the given dungeon logic\\n  struct DungeonAttributes {\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    uint8 stages;\\n    uint8 biome;\\n\\n    /// @notice Default list of objects that should be passed in the dungeon\\n    uint32[] uniqObjects;\\n\\n    /// @dev min+max (packUint8Array)\\n    bytes32 minMaxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    /// @notice Packed DungeonGenerateInfo.requiredCustomData: MinValue, MaxValue, IsHero\\n    /// @dev min+max+isHero(packStoryCustomDataRequirements)\\n    bytes32[] requiredCustomDataValue;\\n\\n    ObjectGenerateInfo info;\\n  }\\n\\n  /// @notice Current status of the given dungeon\\n  struct DungeonStatus {\\n    uint64 dungeonId;\\n    /// @notice Dungeon logic id\\n    uint16 dungNum;\\n\\n    /// @notice True if the dungeon is completed by the hero\\n    bool isCompleted;\\n\\n    /// @notice Hero in the dungeon or 0\\n    address heroToken;\\n    uint heroTokenId;\\n    /// @notice Current object that should be passed by the hero. 0 - new object is not opened\\n    uint32 currentObject;\\n    /// @notice Current stage in the dungeon that should be passed by the hero.\\n    uint8 currentStage;\\n\\n    EnumerableMap.AddressToUintMap treasuryTokens;\\n    /// @notice All items that were minted on result of made actions\\n    bytes32[] treasuryItems;\\n\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    /// This value can be bigger than length of uniqObjects\\n    uint8 stages;\\n    /// @notice List of objects to be passed in the stage. The list can be dynamically changed during passing the stages\\n    uint32[] uniqObjects;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n\\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external returns (uint64 dungeonId);\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8);\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64);\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result);\\n\\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external;\\n\\n}\\n\",\"keccak256\":\"0x2f24028d35a06e44dc9bd096d8a1807cfa64518ebd73692a1cc479736814b741\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbca9de297214bb9c30daefda5ecaedd0af2c3e8e0440403ad543fb33528c5ef8\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xa365c0e17de806f6262765ef6236512674ac8563a6ee3436e81cec7b1d87468e\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  /**\\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n   */\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n   */\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of tokens in ``owner``'s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\n   *\\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n   * The approval is cleared when the token is transferred.\\n   *\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n   *\\n   * Requirements:\\n   *\\n   * - The caller must own the token or be an approved operator.\\n   * - `tokenId` must exist.\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address to, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Returns the account approved for `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  /**\\n   * @dev Approve or remove `operator` as an operator for the caller.\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n   *\\n   * Requirements:\\n   *\\n   * - The `operator` cannot be the caller.\\n   *\\n   * Emits an {ApprovalForAll} event.\\n   */\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  /**\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n   *\\n   * See {setApprovalForAll}\\n   */\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0xe7d89e4cdfc41317d90bf469428b6ef17cec6eb6fccab0080bdf0378129d2708\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n  /**\\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n   * by `operator` from `from`, this function is called.\\n   *\\n   * It must return its Solidity selector to confirm the token transfer.\\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n   *\\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n   */\\n  function onERC721Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xe5e9287463463820051374de194e01b41e1b77c1df73fab6ea0409b485edf33d\",\"license\":\"MIT\"},\"contracts/interfaces/IFightCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface IFightCalculator {\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    MELEE, // 1\\n    MAGIC, // 2\\n    SLOT_3,\\n    SLOT_4,\\n    SLOT_5,\\n    SLOT_6,\\n    SLOT_7,\\n    SLOT_8,\\n    SLOT_9,\\n    SLOT_10\\n  }\\n\\n  /// @notice Attacker info: suitable both for hero and monsters\\n  struct AttackInfo {\\n    /// @notice Type of the attack\\n    /// by default, if attack token presents, it's magic attack and not-magic otherwise\\n    /// but this logic can become more complicated after introducing new attack types\\n    AttackType attackType;\\n    /// @notice NFT selected by hero for attack, it should be equip on.\\n    /// If attacker is a monster, this is a special case (stub NFT with zero ID is used)\\n    address attackToken;\\n    uint attackTokenId;\\n    address[] skillTokens;\\n    uint[] skillTokenIds;\\n  }\\n\\n  struct FighterInfo {\\n    int32[] fighterAttributes;\\n    IStatController.ChangeableStats fighterStats;\\n    AttackType attackType;\\n    address attackToken;\\n    uint attackTokenId;\\n    uint race;\\n  }\\n\\n  struct Statuses {\\n    bool stun;\\n    bool burn;\\n    bool freeze;\\n    bool confuse;\\n    bool curse;\\n    bool poison;\\n    bool gotCriticalHit;\\n    bool missed;\\n    bool hitBlocked;\\n  }\\n\\n  struct FightResult {\\n    int32 healthA;\\n    int32 healthB;\\n    int32 manaConsumedA;\\n    int32 manaConsumedB;\\n  }\\n\\n  struct FightCall {\\n    FighterInfo fighterA;\\n    FighterInfo fighterB;\\n    uint64 dungeonId;\\n    uint32 objectId;\\n    address heroAdr;\\n    uint heroId;\\n    uint8 stageId;\\n    uint iteration;\\n    uint8 turn;\\n  }\\n\\n  struct SkillSlots {\\n    bool slot1;\\n    bool slot2;\\n    bool slot3;\\n  }\\n\\n  //region ------------------------ FightLib-internal (FightInfoInternal is required by IApplicationEvents..)\\n  struct FightInfoInternal {\\n    Fighter fighterA;\\n    Fighter fighterB;\\n  }\\n\\n  struct Fighter {\\n    IFightCalculator.FighterInfo info;\\n    IItemController.AttackInfo magicAttack;\\n    int32 health;\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 damagePoison;\\n    int32 damageReflect;\\n    IFightCalculator.Statuses statuses;\\n  }\\n  //endregion ------------------------ FightLib-internal\\n\\n  function fight(FightCall memory callData) external returns (FightResult memory);\\n}\\n\",\"keccak256\":\"0xdf9ba809ea21a35a24eed12bf80e53452b0d772623d59211a35498b518eb604b\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGOC.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\n\\ninterface IGOC {\\n\\n  enum ObjectType {\\n    UNKNOWN, // 0\\n    EVENT, // 1\\n    MONSTER, // 2\\n    STORY, // 3\\n    END_SLOT\\n  }\\n\\n  enum ObjectSubType {\\n    UNKNOWN_0, // 0\\n    ENEMY_NPC_1, // 1\\n    ENEMY_NPC_SUPER_RARE_2, // 2\\n    BOSS_3, // 3\\n    SHRINE_4, // 4\\n    CHEST_5, // 5\\n    STORY_6, // 6\\n    STORY_UNIQUE_7, // 7\\n    SHRINE_UNIQUE_8, // 8\\n    CHEST_UNIQUE_9, // 9\\n    ENEMY_NPC_UNIQUE_10, // 10\\n    STORY_ON_ROAD_11, // 11\\n    STORY_UNDERGROUND_12, // 12\\n    STORY_NIGHT_CAMP_13, // 13\\n    STORY_MOUNTAIN_14, // 14\\n    STORY_WATER_15, // 15\\n    STORY_CASTLE_16, // 16\\n    STORY_HELL_17, // 17\\n    STORY_SPACE_18, // 18\\n    STORY_WOOD_19, // 19\\n    STORY_CATACOMBS_20, // 20\\n    STORY_BAD_HOUSE_21, // 21\\n    STORY_GOOD_TOWN_22, // 22\\n    STORY_BAD_TOWN_23, // 23\\n    STORY_BANDIT_CAMP_24, // 24\\n    STORY_BEAST_LAIR_25, // 25\\n    STORY_PRISON_26, // 26\\n    STORY_SWAMP_27, // 27\\n    STORY_INSIDE_28, // 28\\n    STORY_OUTSIDE_29, // 29\\n    STORY_INSIDE_RARE_30,\\n    STORY_OUTSIDE_RARE_31,\\n    ENEMY_NPC_INSIDE_32,\\n    ENEMY_NPC_INSIDE_RARE_33,\\n    ENEMY_NPC_OUTSIDE_34,\\n    ENEMY_NPC_OUTSIDE_RARE_35,\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:game.object.controller.main\\n  struct MainState {\\n\\n    /// @dev objId = biome(00) type(00) id(0000) => biome(uint8) + objType(uint8)\\n    /// Id is id of the event, story or monster.\\n    mapping(uint32 => bytes32) objectMeta;\\n\\n    /// @dev biome(uint8) + objType(uint8) => set of object id\\n    mapping(bytes32 => EnumerableSet.UintSet) objectIds;\\n\\n    /// @dev heroAdr180 + heroId64 + cType8 + biome8 => set of already played objects. Should be cleared periodically\\n    mapping(bytes32 => EnumerableSet.UintSet) playedObjects;\\n\\n    /// @dev HeroAdr(160) + heroId(uint64) + objId(uint32) => iteration count. It needs for properly emit events for every new entrance.\\n    mapping(bytes32 => uint) iterations;\\n\\n    /// @dev objId(uint32) => EventInfo\\n    mapping(uint32 => EventInfo) eventInfos;\\n\\n    /// @dev objId(uint32) => storyId\\n    mapping(uint32 => uint16) storyIds;\\n\\n    /// @dev objId(uint32) => MonsterInfo\\n    mapping(uint32 => MonsterInfo) monsterInfos;\\n\\n    /// @dev hero+id => last fight action timestamp\\n    mapping(bytes32 => uint) lastHeroFightTs;\\n\\n    /// @dev delay for user actions in fight (suppose to prevent bot actions)\\n    uint fightDelay;\\n  }\\n\\n  struct ActionResult {\\n    bool kill;\\n    bool completed;\\n    address heroToken;\\n    address[] mintItems;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n    uint32 objectId;\\n    uint32 experience;\\n    uint heroTokenId;\\n    uint iteration;\\n    uint32[] rewriteNextObject;\\n  }\\n\\n  struct EventInfo {\\n    /// @dev chance to use good or bad attributes/stats\\n    uint32 goodChance;\\n\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] goodAttributes;\\n    bytes32[] badAttributes;\\n\\n    /// @dev experience(uint32) + heal(int32) + manaRegen(int32) + lifeChancesRecovered(int32) + damage(int32) + manaConsume(int32) packStatsChange\\n    bytes32 statsChange;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n  }\\n\\n  struct MonsterInfo {\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] attributes;\\n    /// @dev level(uint8) + race(uint8) + experience(uint32) + maxDropItems(uint8) packMonsterStats\\n    bytes32 stats;\\n    /// @dev attackToken(160) + attackTokenId(uint64) + attackType(uint8) packAttackInfo\\n    bytes32 attackInfo;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n\\n    /// @dev heroAdr(160) + heroId(uint64) => iteration => GeneratedMonster packed\\n    mapping(bytes32 => mapping(uint => bytes32)) _generatedMonsters;\\n  }\\n\\n  struct MultiplierInfo {\\n    uint8 biome;\\n    uint totalSupply;\\n  }\\n\\n  struct GeneratedMonster {\\n    bool generated;\\n    uint8 turnCounter;\\n    int32 hp;\\n    uint32 amplifier;\\n  }\\n\\n  struct MonsterGenInfo {\\n    uint16 monsterId;\\n    uint8 biome;\\n    ObjectSubType subType;\\n\\n    uint8[] attributeIds;\\n    int32[] attributeValues;\\n\\n    uint8 level;\\n    uint8 race;\\n    uint32 experience;\\n    uint8 maxDropItems;\\n\\n    address attackToken;\\n    uint64 attackTokenId;\\n    uint8 attackType;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct ActionContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    uint8 biome;\\n    uint8 objectSubType;\\n    uint8 stageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint heroTokenId;\\n    uint salt;\\n    uint iteration;\\n    bytes data;\\n  }\\n\\n  struct EventRegInfo {\\n    uint8 biome;\\n    uint16 eventId;\\n    ObjectSubType subType;\\n\\n    uint32 goodChance;\\n\\n    AttributeGenerateInfo goodAttributes;\\n    AttributeGenerateInfo badAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct AttributeGenerateInfo {\\n    uint8[] ids;\\n    int32[] values;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev represent object registration if non zero values\\n  function getObjectMeta(uint32 objectId) external view returns (uint8 biome, uint8 objectSubType);\\n\\n  function isBattleObject(uint32 objectId) external view returns (bool);\\n\\n  function getRandomObject(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biomeLevel,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external returns (uint32 objectId);\\n\\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint iteration);\\n\\n  function action(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) external returns (ActionResult memory);\\n\\n}\\n\",\"keccak256\":\"0x6493b091bb99b51586b94064eea3eb60f5fa921c5a6f7e061b3c491a73b89a9e\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IHeroController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IHeroController {\\n\\n  /// @custom:storage-location erc7201:hero.controller.main\\n  struct MainState {\\n\\n    /// @dev A central place for all hero tokens\\n    address heroTokensVault;\\n\\n    /// @dev heroAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) payToken;\\n\\n    /// @dev heroAdr => heroCls8\\n    mapping(address => uint8) heroClass;\\n\\n    // ---\\n\\n    /// @dev hero+id => individual hero name\\n    mapping(bytes32 => string) heroName;\\n\\n    /// @dev name => hero+id, needs for checking uniq names\\n    mapping(string => bytes32) nameToHero;\\n\\n    // ---\\n\\n    /// @dev hero+id => biome\\n    mapping(bytes32 => uint8) heroBiome;\\n\\n    /// @dev hero+id => rein hero+id\\n    mapping(bytes32 => bytes32) reinforcementHero;\\n\\n    /// @dev hero+id => rein packed attributes\\n    mapping(bytes32 => bytes32[]) reinforcementHeroAttributes;\\n\\n    /// @notice packedHero (hero + id) => count of calls of beforeTokenTransfer\\n    mapping(bytes32 => uint) countHeroTransfers;\\n  }\\n\\n  function heroClass(address hero) external view returns (uint8);\\n\\n  function heroBiome(address hero, uint heroId) external view returns (uint8);\\n\\n  function payTokenInfo(address hero) external view returns (address token, uint amount);\\n\\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (address helperHeroToken, uint helperHeroId);\\n\\n  function score(address hero, uint heroId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool);\\n\\n  function beforeTokenTransfer(address hero, uint heroId) external returns (bool);\\n\\n  function heroTokensVault() external view returns (address);\\n\\n  // ---\\n\\n  function create(address hero, string memory heroName_, bool enter) external returns (uint);\\n\\n  function kill(address hero, uint heroId) external returns (bytes32[] memory dropItems);\\n\\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId);\\n\\n  function countHeroTransfers(address hero, uint heroId) external view returns (uint);\\n}\\n\",\"keccak256\":\"0x6371cc9217548e9efa70a51ef190b9425d68d62ec65fe5f60d2ed3d3cc35f75e\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IItemController {\\n\\n  /// @custom:storage-location erc7201:item.controlbler.main\\n  struct MainState {\\n\\n    ////////////////// GENERATE //////////////////\\n\\n    EnumerableSet.AddressSet items;\\n\\n    /// @dev itemAdr => itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n    mapping(address => bytes32) itemMeta;\\n\\n    /// @dev itemAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) augmentInfo;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoAttributes;\\n\\n    // --- consumable ---\\n\\n    /// @dev itemAdr => ids+values (toBytes32ArrayWithIds)\\n    mapping(address => bytes32[]) _itemConsumableAttributes;\\n\\n    /// @dev itemAdr => IStatController.ChangeableStats packed int32[]\\n    mapping(address => bytes32) itemConsumableStats;\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoCasterAttributes;\\n\\n    /// @dev itemAdr => id8 + minDmg(int32) + maxDmg(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(address => bytes32) generateInfoAttack;\\n\\n    ////////////////// ITEMS INFO //////////////////\\n\\n    /// @dev itemAdr+id => itemRarity8 + augmentationLevel8 + itemDurability16\\n    mapping(bytes32 => bytes32) itemInfo;\\n\\n    /// @dev itemAdr+id => heroAdr+id\\n    mapping(bytes32 => bytes32) equippedOn;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemAttributes;\\n\\n    // --- consumable ---\\n\\n    // consumable stats unchangeable, get them by address\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemCasterAttributes;\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr+Id => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(bytes32 => bytes32) _itemAttackInfo;\\n\\n    ////////////////// Additional generate info //////////////////\\n\\n    /// @notice (itemAdr) => Bitmask of ConsumableActionBits\\n    mapping(address => uint) _consumableActionMask;\\n\\n\\n    /// --------------------------------- SIP-003: Item fragility\\n    /// @notice itemAdr + id => item fragility counter that displays the chance of an unsuccessful repair\\n    mapping(bytes32 packedItem => uint fragility) itemFragility;\\n  }\\n\\n  struct RegisterItemParams {\\n    ItemMeta itemMeta;\\n    address augmentToken;\\n    uint augmentAmount;\\n    ItemGenerateInfo commonAttributes;\\n\\n    IGOC.AttributeGenerateInfo consumableAttributes;\\n    IStatController.ChangeableStats consumableStats;\\n\\n    ItemGenerateInfo casterAttributes;\\n    ItemGenerateInfo targetAttributes;\\n\\n    AttackInfo genAttackInfo;\\n    /// @notice Bit mask of ConsumableActionBits\\n    uint consumableActionMask;\\n  }\\n\\n  /// @notice Possible actions that can be triggered by using the consumable item\\n  enum ConsumableActionBits {\\n    CLEAR_TEMPORARY_ATTRIBUTES_0,\\n    EXIT_FROM_DUNGEON_1,\\n    USE_GUILD_REINFORCEMENT_2,\\n    RECREATION_IN_GUILD_HOUSE_3\\n  }\\n\\n  struct ItemGenerateInfo {\\n    /// @notice Attribute ids\\n    uint8[] ids;\\n    /// @notice Min value of the attribute, != 0\\n    int32[] mins;\\n    /// @notice Max value of the attribute, != 0\\n    int32[] maxs;\\n    /// @notice Chance of the selection [0..MAX_CHANCES]\\n    uint32[] chances;\\n  }\\n\\n  struct ItemMeta {\\n    uint8 itemMetaType;\\n    // Level in range 1-99. Reducing durability in low level dungeons. lvl/5+1 = biome\\n    uint8 itemLevel;\\n    IItemController.ItemType itemType;\\n    uint16 baseDurability;\\n    uint8 defaultRarity;\\n    uint32 manaCost;\\n\\n    // it doesn't include positions with 100% chance\\n    uint8 minRandomAttributes;\\n    uint8 maxRandomAttributes;\\n\\n    IStatController.CoreAttributes requirements;\\n  }\\n\\n  enum FeeType {\\n    UNKNOWN,\\n    REPAIR,\\n    AUGMENT,\\n    STORY,\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemRarity {\\n    UNKNOWN, // 0\\n    NORMAL, // 1\\n    MAGIC, // 2\\n    RARE, // 3\\n    SET, // 4\\n    UNIQUE, // 5\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemType {\\n    NO_SLOT, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    RING, // 6\\n    OFF_HAND, // 7\\n    BOOTS, // 8\\n    ONE_HAND, // 9\\n    TWO_HAND, // 10\\n    SKILL, // 11\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemMetaType {\\n    UNKNOWN, // 0\\n    COMMON, // 1\\n    ATTACK, // 2\\n    BUFF, // 3\\n    CONSUMABLE, // 4\\n\\n    END_SLOT\\n  }\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    FIRE, // 1\\n    COLD, // 2\\n    LIGHTNING, // 3\\n    CHAOS, // 4\\n\\n    END_SLOT\\n  }\\n\\n  struct AttackInfo {\\n    AttackType aType;\\n    int32 min;\\n    int32 max;\\n    // if not zero - activate attribute factor for the attribute\\n    IStatController.CoreAttributes attributeFactors;\\n  }\\n\\n  struct ItemInfo {\\n    ItemRarity rarity;\\n    uint8 augmentationLevel;\\n    uint16 durability;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct MintInfo {\\n    IItemController.ItemMeta meta;\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.ItemRarity itemRarity;\\n\\n    IItemController.AttackInfo attackInfo;\\n\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct AugmentInfo {\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.AttackInfo attackInfo;\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function itemMeta(address item) external view returns (ItemMeta memory meta);\\n\\n  function augmentInfo(address item) external view returns (address token, uint amount);\\n\\n  function genAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genCasterAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genTargetAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genAttackInfo(address item) external view returns (AttackInfo memory info);\\n\\n  function itemInfo(address item, uint itemId) external view returns (ItemInfo memory info);\\n\\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId);\\n\\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats);\\n\\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function itemAttackInfo(address item, uint itemId) external view returns (AttackInfo memory info);\\n\\n  function score(address item, uint tokenId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address item, uint tokenId) external view returns (bool);\\n\\n  // ---\\n\\n  function mint(address item, address recipient) external returns (uint itemId);\\n\\n  function reduceDurability(address hero, uint heroId, uint8 biome) external;\\n\\n  function destroy(address item, uint tokenId) external;\\n\\n  function takeOffDirectly(\\n    address item,\\n    uint itemId,\\n    address hero,\\n    uint heroId,\\n    uint8 itemSlot,\\n    address destination,\\n    bool broken\\n  ) external;\\n\\n  /// @notice SIP-003: item fragility counter that displays the chance of an unsuccessful repair.\\n  /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n  function itemFragility(address item, uint itemId) external view returns (uint);\\n\\n  /// @notice SIP-003: The quest mechanic that previously burned the item will increase its fragility by 1%\\n  function incBrokenItemFragility(address item, uint itemId) external;\\n}\\n\",\"keccak256\":\"0x50b0c0da23481b6b88cc7fcc9c70d92e98a680700b634ff7be5843c16cc947aa\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IOracle {\\n\\n  function getRandomNumber(uint max, uint seed) external returns (uint);\\n\\n  function getRandomNumberInRange(uint min, uint max, uint seed) external returns (uint);\\n\\n}\\n\",\"keccak256\":\"0x75a2bed27cbd9be6c76b6f3e941ee5f6f55380f61cd867254a0c766fc3b71976\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IPawnShop.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Interface for Tetu PawnShop contract\\n/// @author belbix\\ninterface IPawnShop {\\n\\n  event PositionOpened(\\n    address indexed sender,\\n    uint256 posId,\\n    address collateralToken,\\n    uint256 collateralAmount,\\n    uint256 collateralTokenId,\\n    address acquiredToken,\\n    uint256 acquiredAmount,\\n    uint256 posDurationBlocks,\\n    uint256 posFee\\n  );\\n  event PositionClosed(address indexed borrower, uint256 posId);\\n  event BidExecuted(\\n    uint256 posId,\\n    uint256 bidId,\\n    uint256 amount,\\n    address acquiredMoneyHolder,\\n    address lender\\n  );\\n  event AuctionBidOpened(uint256 posId, uint256 bidId, uint256 amount, address lender);\\n  event PositionClaimed(address indexed sender, uint256 posId);\\n  event PositionRedeemed(address indexed sender, uint256 posId);\\n  event AuctionBidAccepted(address indexed borrower, uint256 posId, uint256 bidId);\\n  event AuctionBidClosed(uint256 posId, uint256 bidId);\\n\\n  event GovernanceActionAnnounced(uint256 id, address addressValue, uint256 uintValue);\\n  event OwnerChanged(address oldOwner, address newOwner);\\n  event FeeRecipientChanged(address oldRecipient, address newRecipient);\\n  event PlatformFeeChanged(uint256 oldFee, uint256 newFee);\\n  event DepositAmountChanged(uint256 oldAmount, uint256 newAmount);\\n  event DepositTokenChanged(address oldToken, address newToken);\\n\\n  enum GovernanceAction {\\n    ChangeOwner, // 0\\n    ChangeFeeRecipient, // 1\\n    ChangePlatformFee, // 2\\n    ChangePositionDepositAmount, // 3\\n    ChangePositionDepositToken // 4\\n  }\\n\\n  enum AssetType {\\n    ERC20, // 0\\n    ERC721 // 1\\n  }\\n\\n  enum IndexType {\\n    LIST, // 0\\n    BY_COLLATERAL, // 1\\n    BY_ACQUIRED, // 2\\n    BORROWER_POSITION, // 3\\n    LENDER_POSITION // 4\\n  }\\n\\n  struct TimeLock {\\n    uint256 time;\\n    address addressValue;\\n    uint256 uintValue;\\n  }\\n\\n  struct Position {\\n    uint256 id;\\n    address borrower;\\n    address depositToken;\\n    uint256 depositAmount;\\n    bool open;\\n    uint minAuctionAmount;\\n    PositionInfo info;\\n    PositionCollateral collateral;\\n    PositionAcquired acquired;\\n    PositionExecution execution;\\n  }\\n\\n  struct PositionInfo {\\n    uint256 posDurationBlocks;\\n    uint256 posFee;\\n    uint256 createdBlock;\\n    uint256 createdTs;\\n  }\\n\\n  struct PositionCollateral {\\n    address collateralToken;\\n    AssetType collateralType;\\n    uint256 collateralAmount;\\n    uint256 collateralTokenId;\\n  }\\n\\n  struct PositionAcquired {\\n    address acquiredToken;\\n    uint256 acquiredAmount;\\n  }\\n\\n  struct PositionExecution {\\n    address lender;\\n    uint256 posStartBlock;\\n    uint256 posStartTs;\\n    uint256 posEndTs;\\n  }\\n\\n  struct AuctionBid {\\n    uint256 id;\\n    uint256 posId;\\n    address lender;\\n    uint256 amount;\\n    bool open;\\n  }\\n\\n  // ****************** VIEWS ****************************\\n\\n  /// @dev PosId counter. Should start from 1 for keep 0 as empty value\\n  function positionCounter() external view returns (uint256);\\n\\n  /// @notice Return Position for given id\\n  /// @dev AbiEncoder not able to auto generate functions for mapping with structs\\n  function getPosition(uint256 posId) external view returns (Position memory);\\n\\n  /// @dev Hold open positions ids. Removed when position closed\\n  function openPositions(uint256 index) external view returns (uint256 posId);\\n\\n  /// @dev Collateral token => PosIds\\n  function positionsByCollateral(address collateralToken, uint256 index) external view returns (uint256 posId);\\n\\n  /// @dev Acquired token => PosIds\\n  function positionsByAcquired(address acquiredToken, uint256 index) external view returns (uint256 posId);\\n\\n  /// @dev Borrower token => PosIds\\n  function borrowerPositions(address borrower, uint256 index) external view returns (uint256 posId);\\n\\n  /// @dev Lender token => PosIds\\n  function lenderPositions(address lender, uint256 index) external view returns (uint256 posId);\\n\\n  /// @dev index type => PosId => index\\n  ///      Hold array positions for given type of array\\n  function posIndexes(IndexType typeId, uint256 posId) external view returns (uint256 index);\\n\\n  /// @dev BidId counter. Should start from 1 for keep 0 as empty value\\n  function auctionBidCounter() external view returns (uint256);\\n\\n  /// @notice Return auction bid for given id\\n  /// @dev AbiEncoder not able to auto generate functions for mapping with structs\\n  function getAuctionBid(uint256 bidId) external view returns (AuctionBid memory);\\n\\n  /// @dev lender => PosId => positionToBidIds + 1\\n  ///      Lender auction position for given PosId. 0 keep for empty position\\n  function lenderOpenBids(address lender, uint256 posId) external view returns (uint256 index);\\n\\n  /// @dev PosId => bidIds. All open and close bids for the given position\\n  function positionToBidIds(uint256 posId, uint256 index) external view returns (uint256 bidId);\\n\\n  /// @dev PosId => timestamp. Timestamp of the last bid for the auction\\n  function lastAuctionBidTs(uint256 posId) external view returns (uint256 ts);\\n\\n  /// @dev Return amount required for redeem position\\n  function toRedeem(uint256 posId) external view returns (uint256 amount);\\n\\n  /// @dev Return asset type ERC20 or ERC721\\n  function getAssetType(address _token) external view returns (AssetType);\\n\\n  function isERC721(address _token) external view returns (bool);\\n\\n  function isERC20(address _token) external view returns (bool);\\n\\n  /// @dev Return size of active positions\\n  function openPositionsSize() external view returns (uint256);\\n\\n  /// @dev Return size of all auction bids for given position\\n  function auctionBidSize(uint256 posId) external view returns (uint256);\\n\\n  function positionsByCollateralSize(address collateral) external view returns (uint256);\\n\\n  function positionsByAcquiredSize(address acquiredToken) external view returns (uint256);\\n\\n  function borrowerPositionsSize(address borrower) external view returns (uint256);\\n\\n  function lenderPositionsSize(address lender) external view returns (uint256);\\n\\n  // ************* USER ACTIONS *************\\n\\n  /// @dev Borrower action. Assume approve\\n  ///      Allows the user to create a new borrowing position by depositing their collateral tokens.\\n  function openPosition(\\n    address _collateralToken,\\n    uint256 _collateralAmount,\\n    uint256 _collateralTokenId,\\n    address _acquiredToken,\\n    uint256 _acquiredAmount,\\n    uint256 _posDurationBlocks,\\n    uint256 _posFee,\\n    uint minAuctionPrice\\n  ) external returns (uint256);\\n\\n  /// @dev Borrower action\\n  ///      Close not executed position. Return collateral and deposit to borrower\\n  function closePosition(uint256 id) external;\\n\\n  /// @dev Lender action. Assume approve for acquired token\\n  ///      Place a bid for given position ID\\n  ///      It can be an auction bid if acquired amount is zero\\n  function bid(uint256 id, uint256 amount) external;\\n\\n  /// @dev Lender action\\n  ///      Transfer collateral to lender if borrower didn't return the loan\\n  ///      Deposit will be returned to borrower\\n  function claim(uint256 id) external;\\n\\n  /// @dev Borrower action. Assume approve on acquired token\\n  ///      Return the loan to lender, transfer collateral and deposit to borrower\\n  function redeem(uint256 id) external;\\n\\n  /// @dev Borrower action. Assume that auction ended.\\n  ///      Transfer acquired token to borrower\\n  function acceptAuctionBid(uint256 posId) external;\\n\\n  /// @dev Lender action. Requires ended auction, or not the last bid\\n  ///      Close auction bid and transfer acquired tokens to lender\\n  function closeAuctionBid(uint256 bidId) external;\\n\\n  /// @dev Announce governance action\\n  function announceGovernanceAction(GovernanceAction id, address addressValue, uint256 uintValue) external;\\n\\n  /// @dev Set new contract owner\\n  function setOwner(address _newOwner) external;\\n\\n  /// @dev Set new fee recipient\\n  function setFeeRecipient(address _newFeeRecipient) external;\\n\\n  /// @dev Platform fee in range 0 - 500, with denominator 10000\\n  function setPlatformFee(uint256 _value) external;\\n\\n  /// @dev Tokens amount that need to deposit for a new position\\n  ///      Will be returned when position closed\\n  function setPositionDepositAmount(uint256 _value) external;\\n\\n  /// @dev Tokens that need to deposit for a new position\\n  function setPositionDepositToken(address _value) external;\\n\\n  function platformFee() external view returns (uint);\\n  function positionDepositToken() external view returns (address);\\n  function AUCTION_DURATION() external view returns (uint);\\n  function positionDepositAmount() external view returns (uint);\\n}\\n\",\"keccak256\":\"0x776608adf2b882db366f13688021e26cefa5d60b07523e19c3fa13c2504efa37\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IPawnShopRouter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\ninterface IPawnShopRouter {\\n  struct CoreData {\\n    address pawnShop;\\n    address gameToken;\\n    address user;\\n  }\\n\\n}\\n\\n\\n\",\"keccak256\":\"0x226f02d7fc959086122aac4ca8e82c5b4e283cc23194fe6a127204b0ac3adb47\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStatController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStatController {\\n\\n  /// @custom:storage-location erc7201:stat.controller.main\\n  struct MainState {\\n    mapping(bytes32 => bytes32[]) heroTotalAttributes;\\n    /// @dev heroAdr+heroId => int32 packed strength, dexterity, vitality, energy\\n    mapping(bytes32 => bytes32) _heroCore;\\n    mapping(bytes32 => bytes32[]) heroBonusAttributes;\\n    mapping(bytes32 => bytes32[]) heroTemporallyAttributes;\\n    /// @dev heroAdr+heroId => uint32 packed level, experience, life, mana, lifeChances\\n    mapping(bytes32 => bytes32) heroStats;\\n    /// @dev heroAdr+heroId+itemSlot => itemAdr + itemId\\n    mapping(bytes32 => bytes32) heroSlots;\\n    /// @dev heroAdr+heroId => busy slots uint8[] packed\\n    mapping(bytes32 => bytes32) heroBusySlots;\\n    mapping(bytes32 => EnumerableSet.AddressSet) usedConsumables;\\n    mapping(bytes32 => mapping(bytes32 => uint)) heroCustomData;\\n    mapping(bytes32 => uint) globalCustomData;\\n  }\\n\\n\\n  enum ATTRIBUTES {\\n    // core\\n    STRENGTH, // 0\\n    DEXTERITY, // 1\\n    VITALITY, // 2\\n    ENERGY, // 3\\n    // attributes\\n    DAMAGE_MIN, // 4\\n    DAMAGE_MAX, // 5\\n    ATTACK_RATING, // 6\\n    DEFENSE, // 7\\n    BLOCK_RATING, // 8\\n    LIFE, // 9\\n    MANA, // 10\\n    // resistance\\n    FIRE_RESISTANCE, // 11\\n    COLD_RESISTANCE, // 12\\n    LIGHTNING_RESISTANCE, // 13\\n    // dmg against\\n    DMG_AGAINST_HUMAN, // 14\\n    DMG_AGAINST_UNDEAD, // 15\\n    DMG_AGAINST_DAEMON, // 16\\n    DMG_AGAINST_BEAST, // 17\\n\\n    // defence against\\n    DEF_AGAINST_HUMAN, // 18\\n    DEF_AGAINST_UNDEAD, // 19\\n    DEF_AGAINST_DAEMON, // 20\\n    DEF_AGAINST_BEAST, // 21\\n\\n    // --- unique, not augmentable\\n    // hero will not die until have positive chances\\n    LIFE_CHANCES, // 22\\n    // increase chance to get an item\\n    MAGIC_FIND, // 23\\n    // decrease chance to get an item\\n    DESTROY_ITEMS, // 24\\n    // percent of chance x2 dmg\\n    CRITICAL_HIT, // 25\\n    // dmg factors\\n    MELEE_DMG_FACTOR, // 26\\n    FIRE_DMG_FACTOR, // 27\\n    COLD_DMG_FACTOR, // 28\\n    LIGHTNING_DMG_FACTOR, // 29\\n    // increase attack rating on given percent\\n    AR_FACTOR, // 30\\n    // percent of damage will be converted to HP\\n    LIFE_STOLEN_PER_HIT, // 31\\n    // amount of mana restored after each battle\\n    MANA_AFTER_KILL, // 32\\n    // reduce all damage on percent after all other reductions\\n    DAMAGE_REDUCTION, // 33\\n\\n    // -- statuses\\n    // chance to stun an enemy, stunned enemy skip next hit\\n    STUN, // 34\\n    // chance burn an enemy, burned enemy will loss 50% of defence\\n    BURN, // 35\\n    // chance freeze an enemy, frozen enemy will loss 50% of MELEE damage\\n    FREEZE, // 36\\n    // chance to reduce enemy's attack rating on 50%\\n    CONFUSE, // 37\\n    // chance curse an enemy, cursed enemy will loss 50% of resistance\\n    CURSE, // 38\\n    // percent of dmg return to attacker\\n    REFLECT_DAMAGE_MELEE, // 39\\n    REFLECT_DAMAGE_MAGIC, // 40\\n    // chance to poison enemy, poisoned enemy will loss 10% of the current health\\n    POISON, // 41\\n    // reduce chance get any of uniq statuses\\n    RESIST_TO_STATUSES, // 42\\n\\n    END_SLOT // 46\\n  }\\n\\n  // possible\\n  // HEAL_FACTOR\\n\\n  struct CoreAttributes {\\n    int32 strength;\\n    int32 dexterity;\\n    int32 vitality;\\n    int32 energy;\\n  }\\n\\n  struct ChangeableStats {\\n    uint32 level;\\n    uint32 experience;\\n    uint32 life;\\n    uint32 mana;\\n    uint32 lifeChances;\\n  }\\n\\n  enum ItemSlots {\\n    UNKNOWN, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    BOOTS, // 6\\n    RIGHT_RING, // 7\\n    LEFT_RING, // 8\\n    RIGHT_HAND, // 9\\n    LEFT_HAND, // 10\\n    TWO_HAND, // 11\\n    SKILL_1, // 12\\n    SKILL_2, // 13\\n    SKILL_3, // 14\\n    END_SLOT // 15\\n  }\\n\\n  struct NftItem {\\n    address token;\\n    uint tokenId;\\n  }\\n\\n  enum Race {\\n    UNKNOWN, // 0\\n    HUMAN, // 1\\n    UNDEAD, // 2\\n    DAEMON, // 3\\n    BEAST, // 4\\n    END_SLOT // 5\\n  }\\n\\n  struct ChangeAttributesInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    int32[] changeAttributes;\\n    bool add;\\n    bool temporally;\\n  }\\n\\n  struct BuffInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    uint32 heroLevel;\\n    address[] buffTokens;\\n    uint[] buffTokenIds;\\n  }\\n\\n  /// @dev This struct is used inside event, so it's moved here from lib\\n  struct ActionInternalInfo {\\n    int32[] posAttributes;\\n    int32[] negAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintedItems;\\n  }\\n\\n  function initNewHero(address token, uint tokenId, uint heroClass) external;\\n\\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory);\\n\\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32);\\n\\n  function heroAttributesLength(address token, uint tokenId) external view returns (uint);\\n\\n  function heroBaseAttributes(address token, uint tokenId) external view returns (CoreAttributes memory);\\n\\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint);\\n\\n  function globalCustomData(bytes32 index) external view returns (uint);\\n\\n  function heroStats(address token, uint tokenId) external view returns (ChangeableStats memory);\\n\\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked);\\n\\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory);\\n\\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function levelUp(address token, uint tokenId, uint heroClass, CoreAttributes memory change) external returns (uint newLvl);\\n\\n  function changeHeroItemSlot(\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) external;\\n\\n  function changeCurrentStats(\\n    address token,\\n    uint tokenId,\\n    ChangeableStats memory change,\\n    bool increase\\n  ) external;\\n\\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external;\\n\\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external;\\n\\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external;\\n\\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external;\\n\\n  function buffHero(BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed);\\n\\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external;\\n\\n  function setGlobalCustomData(bytes32 index, uint value) external;\\n\\n  /// @notice Restore life and mana during reinforcement\\n  /// @param prevAttributes Hero attributes before reinforcement\\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external;\\n}\\n\",\"keccak256\":\"0xb6e25f1fae300c03cacdba3b8b0e56b7e8c46a8cb3abb168ddada2375aaf1f3c\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStoryController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"./IController.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./IHeroController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStoryController {\\n\\n  enum AnswerResultId {\\n    UNKNOWN, // 0\\n    SUCCESS, // 1\\n    ATTRIBUTE_FAIL, // 2\\n    RANDOM_FAIL, // 3\\n    DELAY_FAIL, // 4\\n    HERO_CUSTOM_DATA_FAIL, // 5\\n    GLOBAL_CUSTOM_DATA_FAIL, // 6\\n\\n    END_SLOT\\n  }\\n\\n  enum CustomDataResult {\\n    UNKNOWN, // 0\\n    HERO_SUCCESS, // 1\\n    HERO_FAIL, // 2\\n    GLOBAL_SUCCESS, // 3\\n    GLOBAL_FAIL, // 4\\n\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:story.controller.main\\n  struct MainState {\\n\\n    // --- STORY REG INFO ---\\n\\n    /// @dev Uniq story identification.\\n    mapping(uint32 => uint16) storyIds;\\n    /// @dev Revers mapping for stories for using in the next object rewrite logic.\\n    mapping(uint16 => uint32) idToStory;\\n    /// @dev Store used ids for stories.\\n    mapping(uint16 => bool) _usedStoryIds;\\n    /// @dev Prevent register the story twice\\n    mapping(uint32 => bool) registeredStories;\\n\\n    // --- ANSWER MAPPING ---\\n\\n    /// @dev storyId => all story pages. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.UintSet) allStoryPages;\\n\\n    /// @dev storyId => all possible answers. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.Bytes32Set) allStoryAnswers;\\n\\n    /// @dev storyId + pageId + heroClass (zero is default answers) => storyId + pageId + heroClass (zero is default answers) + answerId\\n    mapping(bytes32 => bytes32[]) answers;\\n    /// @dev answerUnPackedId + answerResultId => nextPageIds (will be chosen randomly from this array)\\n    ///      where answerResultId is:\\n    ///      0 - unknown,\\n    ///      1 - success,\\n    ///      2 - attr fail\\n    ///      3 - random fail\\n    ///      4 - delay fail\\n    ///      5 - hero custom data fail\\n    ///      6 - global custom data fail\\n    ///      see COUNT_ANSWER_RESULT_IDS\\n    mapping(bytes32 => uint16[]) nextPageIds;\\n    /// @dev story + pageId + heroClass (zero is default answers) => random nextObjs (adr + id, like packed nft id)\\n    mapping(bytes32 => uint32[]) nextObjectsRewrite;\\n\\n    /// @dev answerPackedId => packed array of uint32[]\\n    ///      0 - random requirement(uint32, 1 - 99% success of this action, zero means no check)\\n    ///      1 - delay requirement(uint32, if time since the last call more than this value the check is fail, zero means no check)\\n    ///      2 - isFinalAnswer(uint8)\\n    mapping(bytes32 => bytes32) answerAttributes;\\n\\n    // --- ANSWER REQUIREMENTS ---\\n\\n    /// @dev answerPackedId => array of AttributeRequirementsPacked\\n    mapping(bytes32 => bytes32[]) attributeRequirements;\\n    /// @dev answerPackedId=> array of ItemRequirementsPacked\\n    mapping(bytes32 => bytes32[]) itemRequirements;\\n    /// @dev answerPackedId => array of TokenRequirementsPacked\\n    mapping(bytes32 => bytes32[]) tokenRequirements;\\n    /// @dev answerPackedId => custom data for hero\\n    mapping(bytes32 => CustomDataRequirementPacked[]) heroCustomDataRequirement;\\n    /// @dev answerPackedId => global custom data\\n    mapping(bytes32 => CustomDataRequirementPacked[]) globalCustomDataRequirement;\\n\\n    // --- ANSWER RESULTS ---\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) successInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) successInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) successInfoMintItems;\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) failInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) failInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) failInfoMintItems;\\n\\n    /// @dev answerUnPackedId + CustomDataResult => custom data array change\\n    ///      where CustomDataResult is\\n    ///      1 - hero success\\n    ///      2 - hero fail\\n    ///      3 - global success\\n    ///      4 - global fail\\n    ///      see COUNT_CUSTOM_DATA_RESULT_IDS\\n    mapping(bytes32 => bytes32[]) customDataResult;\\n\\n    /// @notice answerPackedId => slot+chance+stopIfBurnt\\n    /// @dev Since SIP-003 the items are not burn but broke\\n    mapping(bytes32 => bytes32[]) burnItem;\\n\\n    // --- GENERAL STORY REQUIREMENTS ---\\n\\n    /// @dev story => Custom hero data requirements for a story. If exist and hero is not eligible should be not chose in a dungeon.\\n    mapping(uint => CustomDataRequirementRangePacked[]) storyRequiredHeroData;\\n    /// @dev story => Minimal level for the history. 0 means no requirements.\\n    mapping(uint => uint) storyRequiredLevel;\\n\\n    // --- HERO STATES ---\\n\\n    /// @dev hero + heroId + storyId => pageId + heroLastActionTS\\n    mapping(bytes32 => bytes32) heroState;\\n\\n    // --- OTHER ---\\n\\n    /// @dev storyId => build hash for the last update\\n    mapping(uint16 => uint) storyBuildHash;\\n\\n    /// @notice Number of already minted items by the user within the given iteration of the story.\\n    /// Only minting of the given number of items is allowed per iteration (see MAX_MINTED_ITEMS_PER_ITERATION).\\n    /// @dev hero, heroId, story => mintedInIteration\\n    /// This map is not cleared: storyId:objectId is 1:1, each object has own sequence of iterations without duplicates\\n    mapping(bytes32 => mapping(uint iteration => uint countMintedItems)) mintedInIteration;\\n  }\\n\\n  /// @dev We need to have flat structure coz Solidity can not handle arrays of structs properly\\n  struct StoryMetaInfo {\\n    uint16 storyId;\\n\\n    // --- story reqs\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n    uint minLevel;\\n\\n    // --- answer reqs\\n\\n    AnswersMeta answersMeta;\\n    AnswerNextPageMeta answerNextPage;\\n    AnswerAttributeRequirementsMeta answerAttributeRequirements;\\n    AnswerItemRequirementsMeta answerItemRequirements;\\n    AnswerTokenRequirementsMeta answerTokenRequirements;\\n    AnswerAttributesMeta answerAttributes;\\n    AnswerCustomDataMeta answerHeroCustomDataRequirement;\\n    AnswerCustomDataMeta answerGlobalCustomDataRequirement;\\n\\n    // --- answer results\\n\\n    AnswerBurnRandomItemMeta answerBurnRandomItemMeta;\\n    NextObjRewriteMeta nextObjRewriteMeta;\\n\\n    // --- story results\\n\\n    AnswerResultMeta successInfo;\\n    AnswerResultMeta failInfo;\\n\\n    AnswerCustomDataResultMeta successHeroCustomData;\\n    AnswerCustomDataResultMeta failHeroCustomData;\\n    AnswerCustomDataResultMeta successGlobalCustomData;\\n    AnswerCustomDataResultMeta failGlobalCustomData;\\n  }\\n\\n  struct NextObjRewriteMeta {\\n    uint16[] nextObjPageIds;\\n    uint8[] nextObjHeroClasses;\\n    uint32[][] nextObjIds;\\n  }\\n\\n  struct AnswersMeta {\\n    uint16[] answerPageIds;\\n    uint8[] answerHeroClasses;\\n    uint16[] answerIds;\\n  }\\n\\n  struct AnswerNextPageMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint8[] answerResultIds;\\n    uint16[][] answerNextPageIds;\\n  }\\n\\n  struct AnswerAttributeRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    bool[][] cores;\\n    uint8[][] ids;\\n    int32[][] values;\\n  }\\n\\n  struct AnswerItemRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireItems;\\n    bool[][] requireItemBurn;\\n    bool[][] requireItemEquipped;\\n  }\\n\\n  struct AnswerTokenRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireToken;\\n    uint88[][] requireAmount;\\n    bool[][] requireTransfer;\\n  }\\n\\n  struct AnswerAttributesMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint32[] randomRequirements;\\n    uint32[] delayRequirements;\\n    bool[] isFinalAnswer;\\n  }\\n\\n  struct AnswerCustomDataMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    bool[][] mandatory;\\n    uint64[][] dataValuesMin;\\n    uint64[][] dataValuesMax;\\n  }\\n\\n  struct AnswerResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    uint8[][] attributeIds;\\n    /// @dev Max value is limitied by int24, see toBytes32ArrayWithIds impl\\n    int32[][] attributeValues;\\n\\n    uint32[] experience;\\n    int32[] heal;\\n    int32[] manaRegen;\\n    int32[] lifeChancesRecovered;\\n    int32[] damage;\\n    int32[] manaConsumed;\\n\\n    address[][] mintItems;\\n    uint32[][] mintItemsChances;\\n  }\\n\\n  struct AnswerCustomDataResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    int16[][] dataValues;\\n  }\\n\\n  struct AnswerBurnRandomItemMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    /// @notice 0 - random slot\\n    uint8[][] slots;\\n    /// @notice typical chances are [0..100] (no decimals here)\\n    uint64[][] chances;\\n    /// @notice Since SIP-003 the burning is replaced by breaking bu the name is kept as is\\n    bool[][] isStopIfBurnt;\\n  }\\n\\n  struct CustomDataRequirementPacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + mandatory(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct CustomDataRequirementRangePacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + isHeroData(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct StatsChange {\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n  }\\n\\n  struct StoryActionContext {\\n    uint stageId;\\n    uint iteration;\\n    bytes32 answerIdHash;\\n    bytes32 answerAttributes;\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IStatController statController;\\n    IHeroController heroController;\\n    IOracle oracle;\\n    IItemController itemController;\\n    uint8 heroClass;\\n    uint8 heroClassFromAnswerHash;\\n    uint8 biome;\\n    uint16 storyId;\\n    uint16 storyIdFromAnswerHash;\\n    uint16 pageIdFromAnswerHash;\\n    uint16 answerNumber;\\n    uint16 pageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint40 heroLastActionTS;\\n    uint80 heroTokenId;\\n    IStatController.ChangeableStats heroStats;\\n  }\\n\\n  // --- WRITE ---\\n\\n  function storyAction(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) external returns (IGOC.ActionResult memory);\\n\\n  // --- READ ---\\n\\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function idToStory(uint16 id) external view returns (uint32 objectId);\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId);\\n\\n  function storyIds(uint32 objectId) external view returns (uint16);\\n\\n  function registeredStories(uint32 objectId) external view returns (bool);\\n\\n}\\n\",\"keccak256\":\"0x7822f79d53590b18455c5d54d91f5b38fabc1330f24ae41db546a785c151e61d\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PackingLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\n\\nlibrary PackingLib {\\n\\n  error TooHighValue(uint value);\\n  error OutOfBounds(uint index, uint length);\\n  error UnexpectedValue(uint expected, uint actual);\\n  error WrongValue(uint newValue, uint actual);\\n  error LengthsMismatch();\\n  error IntOutOfRange(int value);\\n  error ZeroValue();\\n  /// @notice packCustomDataChange requires an input string with two zero bytes at the beginning\\n  ///         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// This error happens if these bytes are not zero\\n  error IncompatibleInputString();\\n\\n  //////////////////////////\\n  // ---- PACKING LOGIC ----\\n  //////////////////////////\\n\\n  //region ------------------------------------ COMMON\\n\\n  function packNftId(address token, uint id) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n  }\\n\\n  function unpackNftId(bytes32 data) internal pure returns (address token, uint id) {\\n    token = address(uint160(uint(data)));\\n    id = uint(data) >> 160;\\n  }\\n\\n  function packAddressWithAmount(address token, uint amount) internal pure returns (bytes32 data) {\\n    if (amount > uint(type(uint96).max)) revert TooHighValue(amount);\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(uint96(amount))) << 160;\\n  }\\n\\n  function unpackAddressWithAmount(bytes32 data) internal pure returns (address token, uint amount) {\\n    token = address(uint160(uint(data)));\\n    amount = uint(data) >> 160;\\n  }\\n\\n  function packItemMintInfo(address item, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(chance)) << 160;\\n  }\\n\\n  function unpackItemMintInfo(bytes32 data) internal pure returns (address item, uint32 chance) {\\n    item = address(uint160(uint(data)));\\n    chance = uint32(uint(data) >> 160);\\n  }\\n\\n  /// @param customDataIndex We assume, that two lowest bytes of this string are always zero\\n  /// So, the string looks like following: 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// Last 2 bytes will be used to encode {value}\\n  function packCustomDataChange(bytes32 customDataIndex, int16 value) internal pure returns (bytes32 data) {\\n    if (uint(customDataIndex) != (uint(customDataIndex) >> 16) << 16) revert IncompatibleInputString();\\n    data = bytes32(uint(customDataIndex));\\n    data |= bytes32(uint(uint16(value)));\\n  }\\n\\n  function unpackCustomDataChange(bytes32 data) internal pure returns (bytes32 customDataIndex, int16 value) {\\n    customDataIndex = bytes32((uint(data) >> 16) << 16);\\n    value = int16(int(uint(uint16(uint(data)))));\\n  }\\n\\n  /// @dev min(uint64) + max(uint64) + isHeroData/isMandatory(uint8)\\n  function packCustomDataRequirements(uint64 min, uint64 max, bool key) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(min));\\n    data |= bytes32(uint(max)) << 64;\\n    data |= bytes32(uint(key ? uint8(1) : uint8(0))) << (64 + 64);\\n  }\\n\\n  function unpackCustomDataRequirements(bytes32 data) internal pure returns (uint64 min, uint64 max, bool key) {\\n    min = uint64(uint(data));\\n    max = uint64(uint(data) >> 64);\\n    key = uint8(uint(data) >> (64 + 64)) == uint8(1);\\n  }\\n\\n  function packStatsChange(\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(experience));\\n    data |= bytes32(uint(uint32(heal))) << 32;\\n    data |= bytes32(uint(uint32(manaRegen))) << (32 + 32);\\n    data |= bytes32(uint(uint32(lifeChancesRecovered))) << (32 + 32 + 32);\\n    data |= bytes32(uint(uint32(damage))) << (32 + 32 + 32 + 32);\\n    data |= bytes32(uint(uint32(manaConsumed))) << (32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackStatsChange(bytes32 data) internal pure returns (\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) {\\n    experience = uint32(uint(data));\\n    heal = int32(int(uint(data) >> 32));\\n    manaRegen = int32(int(uint(data) >> (32 + 32)));\\n    lifeChancesRecovered = int32(int(uint(data) >> (32 + 32 + 32)));\\n    damage = int32(int(uint(data) >> (32 + 32 + 32 + 32)));\\n    manaConsumed = int32(int(uint(data) >> (32 + 32 + 32 + 32 + 32)));\\n  }\\n  //endregion ------------------------------------ COMMON\\n\\n  //region ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(bytes20(objectAddress));\\n    packedData |= bytes32(uint(objectId) << 32);\\n    packedData |= bytes32(uint(objectType) << 24);\\n  }\\n\\n  function unpackMapObject(bytes32 packedData) internal pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\\n    objectAddress = address(bytes20(packedData));\\n    objectId = uint64(uint(packedData) >> 32);\\n    objectType = uint8(uint(packedData) >> 24);\\n  }\\n\\n  function packCoordinate(uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(x));\\n    packedData |= bytes32(uint(y) << 128);\\n  }\\n\\n  function unpackCoordinate(bytes32 packedData) internal pure returns (uint128 x, uint128 y) {\\n    x = uint128(uint(packedData));\\n    y = uint128(uint(packedData) >> 128);\\n  }\\n\\n  /// @param x Assume x <= max uint64\\n  /// @param y Assume y <= max uint64\\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    // 256 => 128 + 128;\\n    // 1) 128 is used for biomeMapFieldId, territoryNumber and probably other fields in the future\\n    // 2) 128 is used to store x, y as uint64, uint64\\n\\n    // we will use uint64 for coordinates assuming it is more than enough for biome map\\n    packedData = bytes32(uint(biomeMapFieldId));\\n    packedData |= bytes32(uint(territoryNumber) << (8));\\n    packedData |= bytes32(uint(uint64(x)) << 128);\\n    packedData |= bytes32(uint(uint64(y)) << (64 + 128));\\n  }\\n\\n  function unpackBattlefieldId(bytes32 packedData) internal pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\\n    biomeMapFieldId = uint8(uint(packedData));\\n    territoryNumber = uint8(uint(packedData) >> (8));\\n    x = uint128(uint64(uint(packedData) >> (128)));\\n    y = uint128(uint64(uint(packedData) >> (64 + 128)));\\n  }\\n  //endregion ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  //region ------------------------------------ REINFORCEMENT\\n\\n  function packReinforcementHeroInfo(uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(biome));\\n    packedData |= bytes32(uint(score) << 8);\\n    packedData |= bytes32(uint(fee) << (8 + 128));\\n    packedData |= bytes32(uint(stakeTs) << (8 + 128 + 8));\\n  }\\n\\n  function unpackReinforcementHeroInfo(bytes32 packedData) internal pure returns (uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) {\\n    biome = uint8(uint(packedData));\\n    score = uint128(uint(packedData) >> 8);\\n    fee = uint8(uint(packedData) >> (8 + 128));\\n    stakeTs = uint64(uint(packedData) >> (8 + 128 + 8));\\n  }\\n  //endregion ------------------------------------ REINFORCEMENT\\n\\n  //region ------------------------------------ DUNGEON\\n\\n  function packDungeonKey(address heroAdr, uint80 heroId, uint16 dungLogicNum) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(dungLogicNum)) << (160 + 80);\\n  }\\n\\n  function unpackDungeonKey(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 dungLogicNum) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    dungLogicNum = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  // --- GAME OBJECTS ---\\n\\n  function packIterationKey(address heroAdr, uint64 heroId, uint32 objId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(objId)) << (160 + 64);\\n  }\\n\\n  function unpackIterationKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint32 objId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    objId = uint32(uint(data) >> (160 + 64));\\n  }\\n\\n  function packMonsterStats(\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(level));\\n    data |= bytes32(uint(race)) << 8;\\n    data |= bytes32(uint(experience)) << (8 + 8);\\n    data |= bytes32(uint(maxDropItems)) << (8 + 8 + 32);\\n  }\\n\\n  function unpackMonsterStats(bytes32 data) internal pure returns (\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) {\\n    level = uint8(uint(data));\\n    race = uint8(uint(data) >> 8);\\n    experience = uint32(uint(data) >> (8 + 8));\\n    maxDropItems = uint8(uint(data) >> (8 + 8 + 32));\\n  }\\n\\n  function packAttackInfo(\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(attackToken)));\\n    data |= bytes32(uint(attackTokenId)) << 160;\\n    data |= bytes32(uint(attackType)) << (160 + 64);\\n  }\\n\\n  function unpackAttackInfo(bytes32 data) internal pure returns (\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) {\\n    attackToken = address(uint160(uint(data)));\\n    attackTokenId = uint64(uint(data) >> 160);\\n    attackType = uint8(uint(data) >> (160 + 64));\\n  }\\n\\n  function packPlayedObjKey(address heroAdr, uint64 heroId, uint8 oType, uint8 biome) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(oType)) << (160 + 64);\\n    data |= bytes32(uint(biome)) << (160 + 64 + 8);\\n  }\\n\\n  function unpackPlayedObjKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint8 oType, uint8 biome) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    oType = uint8(uint(data) >> (160 + 64));\\n    biome = uint8(uint(data) >> (160 + 64 + 8));\\n  }\\n\\n  function packGeneratedMonster(bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint8(generated ? 1 : 0)));\\n    data |= bytes32(uint(amplifier)) << 8;\\n    data |= bytes32(uint(uint32(hp))) << (8 + 32);\\n    data |= bytes32(uint(turnCounter)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 data) internal pure returns (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) {\\n    generated = uint8(uint(data)) == uint8(1);\\n    amplifier = uint32(uint(data) >> 8);\\n    hp = int32(int(uint(data) >> (8 + 32)));\\n    turnCounter = uint8(uint(data) >> (8 + 32 + 32));\\n  }\\n  //endregion ------------------------------------ DUNGEON\\n\\n  //region ------------------------------------ ITEMS\\n\\n  /// @notice itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n  /// @param itemType This is ItemType enum\\n  function packItemMeta(\\n    uint8 itemMetaType,\\n    uint8 itemLvl,\\n    uint8 itemType,\\n    uint16 baseDurability,\\n    uint8 defaultRarity,\\n    uint8 minAttr,\\n    uint8 maxAttr,\\n    uint32 manaCost,\\n    IStatController.CoreAttributes memory req\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(itemMetaType));\\n    data |= bytes32(uint(itemLvl)) << 8;\\n    data |= bytes32(uint(itemType)) << (8 + 8);\\n    data |= bytes32(uint(baseDurability)) << (8 + 8 + 8);\\n    data |= bytes32(uint(defaultRarity)) << (8 + 8 + 8 + 16);\\n    data |= bytes32(uint(minAttr)) << (8 + 8 + 8 + 16 + 8);\\n    data |= bytes32(uint(maxAttr)) << (8 + 8 + 8 + 16 + 8 + 8);\\n    data |= bytes32(uint(manaCost)) << (8 + 8 + 8 + 16 + 8 + 8 + 8);\\n    data |= bytes32(uint(int(req.strength))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32);\\n    data |= bytes32(uint(int(req.dexterity))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32);\\n    data |= bytes32(uint(int(req.vitality))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(req.energy))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemMeta(bytes32 data) internal pure returns (IItemController.ItemMeta memory) {\\n    IItemController.ItemMeta memory result;\\n\\n    result.itemMetaType = uint8(uint(data));\\n    result.itemLevel = uint8(uint(data) >> 8);\\n    result.itemType = IItemController.ItemType(uint8(uint(data) >> (8 + 8)));\\n    result.baseDurability = uint16(uint(data) >> (8 + 8 + 8));\\n    result.defaultRarity = uint8(uint(data) >> (8 + 8 + 8 + 16));\\n    result.minRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8));\\n    result.maxRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8));\\n    result.manaCost = uint32(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8));\\n    result.requirements.strength = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32)));\\n    result.requirements.dexterity = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32)));\\n    result.requirements.vitality = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32)));\\n    result.requirements.energy = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32)));\\n\\n    return result;\\n  }\\n\\n  function packItemGenerateInfo(uint8 id, int32 min, int32 max, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(id));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(chance)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32 data) internal pure returns (uint8 id, int32 min, int32 max, uint32 chance) {\\n    id = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    chance = uint32(uint(data) >> (8 + 32 + 32));\\n  }\\n\\n  function packItemAttackInfo(\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attackType));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(int(factorStr))) << (8 + 32 + 32);\\n    data |= bytes32(uint(int(factorDex))) << (8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorVit))) << (8 + 32 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorEng))) << (8 + 32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 data) internal pure returns (\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) {\\n    attackType = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    factorStr = int32(int(uint(data) >> (8 + 32 + 32)));\\n    factorDex = int32(int(uint(data) >> (8 + 32 + 32 + 32)));\\n    factorVit = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32)));\\n    factorEng = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packItemInfo(uint8 rarity, uint8 augmentationLevel, uint16 durability) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(rarity));\\n    data |= bytes32(uint(augmentationLevel)) << 8;\\n    data |= bytes32(uint(durability)) << (8 + 8);\\n  }\\n\\n  function unpackItemInfo(bytes32 data) internal pure returns (uint8 rarity, uint8 augmentationLevel, uint16 durability) {\\n    rarity = uint8(uint(data));\\n    augmentationLevel = uint8(uint(data) >> 8);\\n    durability = uint16(uint(data) >> (8 + 8));\\n  }\\n  //endregion ------------------------------------ ITEMS\\n\\n  //region ------------------------------------ STORIES\\n\\n  function packStoryPageId(uint16 storyId, uint16 pageId, uint8 heroClass) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n  }\\n\\n  function unpackStoryPageId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n  }\\n\\n  function packStoryAnswerId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n  }\\n\\n  function unpackStoryAnswerId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n  }\\n\\n  function packStoryNextPagesId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(resultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryNextPagesId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    resultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryAttributeRequirement(uint8 attributeIndex, int32 value, bool isCore) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attributeIndex));\\n    data |= bytes32(uint(uint32(value))) << 8;\\n    data |= bytes32(uint(isCore ? uint8(1) : uint8(0))) << (8 + 32);\\n  }\\n\\n  function unpackStoryAttributeRequirement(bytes32 data) internal pure returns (uint8 attributeIndex, int32 value, bool isCore) {\\n    attributeIndex = uint8(uint(data));\\n    value = int32(int(uint(data) >> 8));\\n    isCore = uint8(uint(data) >> (8 + 32)) == uint8(1);\\n  }\\n\\n  function packStoryItemRequirement(address item, bool requireItemBurn, bool requireItemEquipped) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(requireItemBurn ? uint8(1) : uint8(0))) << 160;\\n    data |= bytes32(uint(requireItemEquipped ? uint8(1) : uint8(0))) << (160 + 8);\\n  }\\n\\n  function unpackStoryItemRequirement(bytes32 data) internal pure returns (address item, bool requireItemBurn, bool requireItemEquipped) {\\n    item = address(uint160(uint(data)));\\n    requireItemBurn = uint8(uint(data) >> 160) == uint8(1);\\n    requireItemEquipped = uint8(uint(data) >> (160 + 8)) == uint8(1);\\n  }\\n\\n  /// @dev max amount is 309,485,009 for token with 18 decimals\\n  function packStoryTokenRequirement(address token, uint88 amount, bool requireTransfer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(amount)) << 160;\\n    data |= bytes32(uint(requireTransfer ? uint8(1) : uint8(0))) << (160 + 88);\\n  }\\n\\n  function unpackStoryTokenRequirement(bytes32 data) internal pure returns (address token, uint88 amount, bool requireTransfer) {\\n    token = address(uint160(uint(data)));\\n    amount = uint88(uint(data) >> 160);\\n    requireTransfer = uint8(uint(data) >> (160 + 88)) == uint8(1);\\n  }\\n\\n  function packStoryCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(customDataResultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryCustomDataResult(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    customDataResultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryHeroState(uint16 pageId, uint40 heroLastActionTS) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(pageId));\\n    data |= bytes32(uint(heroLastActionTS)) << 16;\\n  }\\n\\n  function unpackStoryHeroState(bytes32 data) internal pure returns (uint16 pageId, uint40 heroLastActionTS) {\\n    pageId = uint16(uint(data));\\n    heroLastActionTS = uint40(uint(data) >> 16);\\n  }\\n\\n  function packStoryHeroStateId(address heroAdr, uint80 heroId, uint16 storyId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(storyId)) << (160 + 80);\\n  }\\n\\n  function unpackStoryHeroStateId(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 storyId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    storyId = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  function packStorySimpleRequirement(uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(randomRequirement));\\n    data |= bytes32(uint(delayRequirement)) << 32;\\n    data |= bytes32(uint(isFinalAnswer ? uint8(1) : uint8(0))) << (32 + 32);\\n  }\\n\\n  function unpackStorySimpleRequirement(bytes32 data) internal pure returns (uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) {\\n    randomRequirement = uint32(uint(data));\\n    delayRequirement = uint32(uint(data) >> 32);\\n    isFinalAnswer = uint8(uint(data) >> (32 + 32)) == uint8(1);\\n  }\\n\\n  function packBreakInfo(uint8 slot, uint64 chance, bool stopIfBroken) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(slot));\\n    data |= bytes32(uint(chance)) << 8;\\n    data |= bytes32(uint(stopIfBroken ? uint8(1) : uint8(0))) << (8 + 64);\\n  }\\n\\n  function unpackBreakInfo(bytes32 data) internal pure returns (uint8 slot, uint64 chance, bool stopIfBurned) {\\n    slot = uint8(uint(data));\\n    chance = uint64(uint(data) >> 8);\\n    stopIfBurned = uint8(uint(data) >> (8 + 64)) == uint8(1);\\n  }\\n  //endregion ------------------------------------ STORIES\\n\\n  ////////////////////////////////////////////////////////////////////////////////////\\n  // ---- ARRAYS LOGIC ----\\n  ////////////////////////////////////////////////////////////////////////////////////\\n\\n  //region ------------------------------------ SIMPLE ARRAYS\\n\\n\\n  function packUint8Array(uint8[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 32) revert OutOfBounds(len, 32);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 8);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {packUint8Array} for small number of items\\n  ///         It allows to exclude dynamic array creation.\\n  function packUint8Array3(uint8 a, uint8 b, uint8 c) internal pure returns (bytes32) {\\n    bytes32 result = bytes32(uint(a));\\n    result |= bytes32(uint(b)) << (1 * 8);\\n    result |= bytes32(uint(c)) << (2 * 8);\\n    return result;\\n  }\\n\\n\\n  function unpackUint8Array(bytes32 data) internal pure returns (uint8[] memory) {\\n    uint8[] memory result = new uint8[](32);\\n    for (uint i = 0; i < 32; i++) {\\n      result[i] = uint8(uint(data) >> (i * 8));\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {unpackUint8Array} for small number of items\\n  ///         It allows to exclude only first 3 values\\n  function unpackUint8Array3(bytes32 data) internal pure returns (uint8 a, uint8 b, uint8 c) {\\n    a = uint8(uint(data));\\n    b = uint8(uint(data) >> (1 * 8));\\n    c = uint8(uint(data) >> (2 * 8));\\n  }\\n\\n  function changeUnit8ArrayWithCheck(bytes32 data, uint index, uint8 value, uint8 expectedPrevValue) internal pure returns (bytes32 newData) {\\n    uint8[] memory arr = unpackUint8Array(data);\\n    if (arr[index] != expectedPrevValue) revert UnexpectedValue(uint(expectedPrevValue), uint(arr[index]));\\n    arr[index] = value;\\n    return packUint8Array(arr);\\n  }\\n\\n  function packInt32Array(int32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i; i < len; i++) {\\n      result |= bytes32(uint(uint32(data[i]))) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackInt32Array(bytes32 data) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = int32(int(uint(data) >> (i * 32)));\\n    }\\n    return result;\\n  }\\n\\n  function packUint32Array(uint32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackUint32Array(bytes32 data) internal pure returns (uint32[] memory) {\\n    uint32[] memory result = new uint32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = uint32(uint(data) >> (i * 32));\\n    }\\n    return result;\\n  }\\n  //endregion ------------------------------------ SIMPLE ARRAYS\\n\\n  //region ------------------------------------ COMPLEX ARRAYS\\n\\n  // We should represent arrays without concrete size.\\n  // For this reason we must not revert on out of bounds but return zero value instead.\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getInt32AsInt24(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n//    if (idx / 8 >= arr.length) {\\n//      return int32(0);\\n//    }\\n//    return int32(int24(int(uint(arr[idx / 8]) >> ((idx % 8) * 32))));\\n//  }\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getUnit8From32Step(bytes32[] memory arr, uint idx) internal pure returns (uint8) {\\n//    if (idx / 8 >= arr.length) {\\n//      return uint8(0);\\n//    }\\n//    return uint8(uint(arr[idx / 8]) >> ((idx % 8) * 32 + 24));\\n//  }\\n\\n  function getInt32Memory(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function getInt32(bytes32[] storage arr, uint idx) internal view returns (int32) {\\n    // additional gas usage, but we should not revert on out of bounds\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function setInt32(bytes32[] storage arr, uint idx, int32 value) internal {\\n    uint pos = idx / 8;\\n    uint shift = (idx % 8) * 32;\\n\\n    uint curLength = arr.length;\\n    if (pos >= curLength) {\\n      arr.push(0);\\n      for (uint i = curLength; i < pos; ++i) {\\n        arr.push(0);\\n      }\\n    }\\n\\n    arr[pos] = bytes32(uint(arr[pos]) & ~(uint(0xffffffff) << shift) | (uint(uint32(value)) & 0xffffffff) << shift);\\n  }\\n\\n  /// @notice Increment {idx}-th item on {value}\\n  function changeInt32(bytes32[] storage arr, uint idx, int32 value) internal returns (int32 newValue, int32 change) {\\n    int32 cur = int32(int(getInt32(arr, idx)));\\n    int newValueI = int(cur) + int(value);\\n    newValue = int32(newValueI);\\n    change = int32(newValueI - int(cur));\\n\\n    setInt32(arr, idx, newValue);\\n  }\\n\\n  function toInt32Array(bytes32[] memory arr, uint size) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](size);\\n    for (uint i = 0; i < arr.length; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= size) break;\\n        result[idx] = getInt32Memory(arr, idx);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array\\n  function toBytes32Array(int32[] memory arr) internal pure returns (bytes32[] memory) {\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n        result[i] |= bytes32(uint(uint32(arr[idx]))) << (j * 32);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array using last 8bytes for ids\\n  ///      we can not use zero values coz will not able to properly unpack it later\\n  function toBytes32ArrayWithIds(int32[] memory arr, uint8[] memory ids) internal pure returns (bytes32[] memory) {\\n    if (arr.length != ids.length) revert LengthsMismatch();\\n\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n\\n//        console.log(\\\"toBytes32ArrayWithIds id: %s, value: %s%s\\\", ids[idx], arr[idx] >= 0 ? '' : '-', arr[idx] >= 0 ? uint(int(arr[idx])) : uint(int(-arr[idx])));\\n\\n        if (arr[idx] > type(int24).max || arr[idx] < type(int24).min) revert IntOutOfRange(int(arr[idx]));\\n        if (arr[idx] == 0) revert ZeroValue();\\n        result[i] |= bytes32(uint(uint24(int24(arr[idx])))) << (j * 32);\\n        result[i] |= bytes32(uint(ids[idx])) << (j * 32 + 24);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev we do not know exact size of array, assume zero values is not acceptable for this array\\n  function toInt32ArrayWithIds(bytes32[] memory arr) internal pure returns (int32[] memory values, uint8[] memory ids) {\\n    uint len = arr.length;\\n    uint size = len * 8;\\n    int32[] memory valuesTmp = new int32[](size);\\n    uint8[] memory idsTmp = new uint8[](size);\\n    uint counter;\\n    for (uint i = 0; i < len; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        // if (idx >= size) break;  // it looks like a useless check\\n        valuesTmp[idx] = int32(int24(int(uint(arr[i]) >> (j * 32)))); // getInt32AsInt24(arr, idx);\\n        idsTmp[idx] = uint8(uint(arr[i]) >> (j * 32 + 24)); // getUnit8From32Step(arr, idx);\\n        if (valuesTmp[idx] == 0) {\\n          break;\\n        }\\n        counter++;\\n      }\\n    }\\n\\n    values = new int32[](counter);\\n    ids = new uint8[](counter);\\n    for (uint i; i < counter; ++i) {\\n      values[i] = valuesTmp[i];\\n      ids[i] = idsTmp[i];\\n    }\\n  }\\n  //endregion ------------------------------------ COMPLEX ARRAYS\\n\\n}\\n\",\"keccak256\":\"0x5cd23c28a36e25e667e6a01b8cc483c2dd47be9abfd0f2d54e6c59d1a1d01884\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PawnShopRouterLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IPawnShopRouter.sol\\\";\\nimport \\\"../interfaces/IPawnShop.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\n\\nlibrary PawnShopRouterLib {\\n  //region ------------------------ Restrictions\\n  function userOnly(address msgSender, address user) internal pure {\\n    if (msgSender != user) revert IAppErrors.ErrorForbidden(msgSender);\\n  }\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ View\\n  function getOpenedPositionsLength(address pawnShop) internal view returns (uint) {\\n    return IPawnShop(pawnShop).borrowerPositionsSize(address(this));\\n  }\\n\\n  function getOpenedPosition(address pawnShop, uint index) internal view returns (uint positionId) {\\n    return IPawnShop(pawnShop).borrowerPositions(address(this), index);\\n  }\\n\\n  function getDepositAmount(address pawnShop, uint countPositionsToSell) internal view returns (\\n    address positionDepositToken,\\n    uint amount\\n  ) {\\n    return (\\n      IPawnShop(pawnShop).positionDepositToken(),\\n      IPawnShop(pawnShop).positionDepositAmount() * countPositionsToSell\\n    );\\n  }\\n\\n  function getAmountToBulkBuying(IPawnShopRouter.CoreData memory p, uint[] memory positionIds) internal view returns (uint amount) {\\n    uint len = positionIds.length;\\n    for (uint i; i < len; ++i) {\\n      IPawnShop.Position memory position = _getValidPositionToBuy(p, positionIds[i]);\\n      amount += position.acquired.acquiredAmount;\\n    }\\n    return amount;\\n  }\\n  //endregion ------------------------ View\\n\\n  //region ------------------------ User actions\\n\\n  /// @notice Transfer given amount of the game token to the receiver\\n  function transfer(IPawnShopRouter.CoreData memory p, address msgSender, uint amount, address receiver) internal {\\n    userOnly(msgSender, p.user);\\n\\n    IERC20(p.gameToken).transfer(receiver, amount);\\n    emit IApplicationEvents.PawnShopRouterTransfer(p.gameToken, amount, receiver);\\n  }\\n\\n  function salvage(IPawnShopRouter.CoreData memory p, address msgSender, address token, uint amount, address receiver) internal {\\n    userOnly(msgSender, p.user);\\n\\n    IERC20(token).transfer(receiver, amount);\\n    emit IApplicationEvents.PawnShopRouterTransfer(token, amount, receiver);\\n  }\\n\\n  /// @notice Function to call arbitrary code\\n  function call(address user, address msgSender, address target, bytes memory callData) internal returns (\\n    bytes memory data\\n  ) {\\n    userOnly(msgSender, user);\\n\\n    bool success;\\n    (success, data) = target.call(callData);\\n    if (!success) {\\n      revert IAppErrors.CallFailed(data);\\n    }\\n  }\\n  //endregion ------------------------ User actions\\n\\n  //region ------------------------ Bulk instant selling\\n\\n  /// @notice Bulk selling of the given set of NFT through PawnShop.sol\\n  function bulkSell(\\n    IPawnShopRouter.CoreData memory p,\\n    address msgSender,\\n    address[] memory nfts,\\n    uint[] memory nftIds,\\n    uint[] memory prices,\\n    address nftOwner\\n  ) internal {\\n    userOnly(msgSender, p.user);\\n\\n    uint len = nftIds.length;\\n    if (len != prices.length || len != nfts.length) revert IAppErrors.LengthsMismatch();\\n\\n    uint positionDepositAmount = IPawnShop(p.pawnShop).positionDepositAmount();\\n\\n    if (positionDepositAmount != 0) {\\n      // take deposit from user and approve the deposit for pawnShop\\n      address token = IPawnShop(p.pawnShop).positionDepositToken();\\n\\n      IERC20(token).transferFrom(msgSender, address(this), positionDepositAmount * len);\\n      _approveIfNeeded(token, positionDepositAmount * len, p.pawnShop);\\n    }\\n\\n    // open and register positions\\n    uint[] memory positionIds = new uint[](len);\\n    for (uint i; i < len; ++i) {\\n      address nft = nfts[i];\\n      IERC721(nft).transferFrom(nftOwner, address(this), nftIds[i]);\\n      _approveIfNeededNft(nft, p.pawnShop);\\n\\n      positionIds[i] = IPawnShop(p.pawnShop).openPosition(\\n        nft,\\n        0,\\n        nftIds[i],\\n        p.gameToken,\\n        prices[i],\\n        // 0 for instant selling\\n        0, // posDurationBlocks\\n        0, // posFee,\\n        0  // minAuctionAmount\\n      );\\n    }\\n\\n    emit IApplicationEvents.PawnShopRouterBulkSell(nfts, nftIds, prices, nftOwner, positionIds);\\n  }\\n\\n  /// @notice Close unsold positions, transfer NFTs to {receiver}\\n  function closePositions(\\n    IPawnShopRouter.CoreData memory p,\\n    address msgSender,\\n    uint[] memory positionIds,\\n    address receiver\\n  ) internal {\\n    userOnly(msgSender, p.user);\\n\\n    IPawnShop _pawnShop = IPawnShop(p.pawnShop);\\n\\n    uint len = positionIds.length;\\n    for (uint i; i < len; ++i) {\\n      IPawnShop.Position memory position = _pawnShop.getPosition(positionIds[i]);\\n      _pawnShop.closePosition(positionIds[i]);\\n      IERC721(position.collateral.collateralToken).transferFrom(\\n        address(this),\\n        receiver,\\n        position.collateral.collateralTokenId\\n      );\\n    }\\n\\n    emit IApplicationEvents.PawnShopRouterClosePositions(positionIds, receiver);\\n  }\\n\\n  //endregion ------------------------ Bulk instant selling\\n\\n  //region ------------------------ Bulk instant buying\\n  function bulkBuy(\\n    IPawnShopRouter.CoreData memory p,\\n    address msgSender,\\n    uint[] memory positionIds,\\n    address receiver\\n  ) internal {\\n    userOnly(msgSender, p.user);\\n\\n    IPawnShop _pawnShop = IPawnShop(p.pawnShop);\\n\\n    uint len = positionIds.length;\\n    IPawnShop.Position[] memory positions = new IPawnShop.Position[](len);\\n    uint totalAmount;\\n\\n    // get all amounts and total amount required to be approved\\n    // ensure that all positions are instant and they use game token as the deposit token\\n    for (uint i; i < len; ++i) {\\n      positions[i] = _getValidPositionToBuy(p, positionIds[i]);\\n      totalAmount += positions[i].acquired.acquiredAmount;\\n    }\\n\\n    // take deposit from user and approve the deposit for pawnShop\\n    IERC20(p.gameToken).transferFrom(msgSender, address(this), totalAmount);\\n    // no need to approve totalAmount, there is infinite approve\\n\\n    // bulk buying\\n    for (uint i; i < len; ++i) {\\n      _pawnShop.bid(positionIds[i], positions[i].acquired.acquiredAmount);\\n      // transfer purchased nft to the receiver\\n      IERC721(positions[i].collateral.collateralToken).transferFrom(address(this), receiver, positions[i].collateral.collateralTokenId);\\n    }\\n\\n    emit IApplicationEvents.PawnShopRouterBulkBuy(positionIds, receiver);\\n  }\\n  //endregion ------------------------ Bulk instant buying\\n\\n  //region ------------------------ Internal logic\\n  function _getValidPositionToBuy(IPawnShopRouter.CoreData memory p, uint positionId) internal view returns (IPawnShop.Position memory) {\\n    IPawnShop.Position memory position = IPawnShop(p.pawnShop).getPosition(positionId);\\n    if (position.acquired.acquiredAmount == 0) revert IAppErrors.AuctionPositionNotSupported(positionId);\\n    if (position.acquired.acquiredToken != p.gameToken) revert IAppErrors.PositionNotSupported(positionId);\\n    if (position.collateral.collateralType != IPawnShop.AssetType.ERC721) revert IAppErrors.NotNftPositionNotSupported(positionId);\\n    return position;\\n  }\\n\\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\\n  function _approveIfNeeded(address token, uint amount, address spender) internal {\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\\n      IERC20(token).approve(spender, 2 ** 255);\\n    }\\n  }\\n\\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\\n  function _approveIfNeededNft(address nft, address spender) internal {\\n    if (!IERC721(nft).isApprovedForAll(address(this), spender)) {\\n      IERC721(nft).setApprovalForAll(spender, true);\\n    }\\n  }\\n  //endregion ------------------------ Internal logic\\n}\\n\",\"keccak256\":\"0x30fcd1fc7ecda436d69ca1ddc8543fbf488496dd8877a1e0f659f71135aa6884\",\"license\":\"BUSL-1.1\"},\"contracts/lib/SlotsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\\n/// @author bogdoslav\\nlibrary SlotsLib {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant SLOT_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  // ************* GETTERS *******************\\n\\n  /// @dev Gets a slot as bytes32\\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as an address\\n  function getAddress(bytes32 slot) internal view returns (address result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as uint256\\n  function getUint(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  // ************* ARRAY GETTERS *******************\\n\\n  /// @dev Gets an array length\\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  // ************* SETTERS *******************\\n\\n  /// @dev Sets a slot with bytes32\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, bytes32 value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with address\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, address value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with uint\\n  function set(bytes32 slot, uint value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x52ede981a6bb509c0dce07a0373e3c073c24fd16ca4ca7fbaa24f6c8b747b45b\",\"license\":\"BUSL-1.1\"},\"contracts/marketplace/PawnShopRouter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../lib/PawnShopRouterLib.sol\\\";\\nimport \\\"../proxy/Controllable.sol\\\";\\nimport \\\"../relay/ERC2771Context.sol\\\";\\nimport \\\"../openzeppelin/ERC721Holder.sol\\\";\\n\\n/// @notice Personal router for the given to user to make bulk selling/buying on the given marketplace.\\n/// Only instant positions are supported. Auction positions are not supported in bulk operations.\\ncontract PawnShopRouter is ERC2771Context, ERC721Holder {\\n  //region ------------------------ Constants\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant VERSION = \\\"1.0.1\\\";\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Variables\\n  /// @notice Factory that has created this contract instance\\n  address immutable public factory;\\n\\n  /// @notice The marketplace - address of PawnShop contract\\n  address immutable public pawnShop;\\n\\n  /// @notice ERC20 token that is used to paying for any positions on the marketplace\\n  address immutable public gameToken;\\n\\n  /// @notice This contract instance owner. All functions can be called by the user only.\\n  address immutable public user;\\n\\n  /// @notice Value returned by last successful call of \\\"call()\\\"\\n  bytes public callResultData;\\n\\n  //endregion ------------------------ Variables\\n\\n  //region ------------------------ Constructor\\n  constructor(address factory_, address pawnShop_, address gameToken_, address user_) {\\n    if (\\n      factory_ == address(0)\\n      || pawnShop_ == address(0)\\n      || gameToken_ == address(0)\\n      || user_ == address(0)\\n    ) revert IAppErrors.ZeroAddress();\\n\\n    factory = factory_;\\n    gameToken = gameToken_;\\n    pawnShop = pawnShop_;\\n    user = user_;\\n\\n    // infinite approve, 2*255 is more gas efficient then type(uint).max\\n    IERC20(gameToken).approve(pawnShop, 2 ** 255);\\n  }\\n\\n  //endregion ------------------------ Constructor\\n\\n  //region ------------------------ View\\n  /// @notice Give current number of opened and unsold positions on the marketplace for the user\\n  function getOpenedPositionsLength() external view returns (uint) {\\n    return PawnShopRouterLib.getOpenedPositionsLength(pawnShop);\\n  }\\n\\n  /// @param index [0...getOpenedPositionsLength())\\n  function getOpenedPosition(uint index) external view returns (uint positionId) {\\n    return PawnShopRouterLib.getOpenedPosition(pawnShop, index);\\n  }\\n\\n  /// @notice Get deposit {amount} required to open {countPositionsToSell} positions on the marketplace\\n  function getDepositAmount(uint countPositionsToSell) external view returns (address positionDepositToken, uint amount) {\\n    return PawnShopRouterLib.getDepositAmount(pawnShop, countPositionsToSell);\\n  }\\n\\n  /// @notice Get amount required to purchase positions with given ids. Revert if any position is not suitable for bulk buying\\n  function getAmountToBulkBuying(uint[] memory positionIds) external view returns (uint amount) {\\n    return PawnShopRouterLib.getAmountToBulkBuying(\\n      IPawnShopRouter.CoreData({user: user, gameToken: gameToken, pawnShop: pawnShop}),\\n      positionIds\\n    );\\n  }\\n  //endregion ------------------------ View\\n\\n  //region ------------------------ Bulk instant selling\\n\\n  /// @notice Bulk selling of the given set of NFT through PawnShop.sol\\n  /// Assume that deposit amount is approved by the user. Use {getDepositAmount} to get deposit amount.\\n  /// @param nftOwner Owner of all {nftIds}. Assume that all NFTs are approved to the router by NFT owner.\\n  function bulkSell(address[] memory nfts, uint[] memory nftIds, uint[] memory prices, address nftOwner) external {\\n    return PawnShopRouterLib.bulkSell(\\n      IPawnShopRouter.CoreData({user: user, gameToken: gameToken, pawnShop: pawnShop}),\\n      _msgSender(),\\n      nfts,\\n      nftIds,\\n      prices,\\n      nftOwner\\n    );\\n  }\\n\\n  /// @notice Close unsold positions, return NFT back and transfer them to the {receiver}\\n  function closePositions(uint[] memory positionIds, address receiver) external {\\n    PawnShopRouterLib.closePositions(\\n      IPawnShopRouter.CoreData({user: user, gameToken: gameToken, pawnShop: pawnShop}),\\n      _msgSender(),\\n      positionIds,\\n      receiver\\n    );\\n  }\\n  //endregion ------------------------ Bulk instant selling\\n\\n  //region ------------------------ Bulk instant buying\\n  /// @notice Buy given positions and send purchased NFT to the {receiver}\\n  function bulkBuy(uint[] memory positionIds, address receiver) external {\\n    return PawnShopRouterLib.bulkBuy(\\n      IPawnShopRouter.CoreData({user: user, gameToken: gameToken, pawnShop: pawnShop}),\\n      _msgSender(),\\n      positionIds,\\n      receiver\\n    );\\n  }\\n  //endregion ------------------------ Bulk instant buying\\n\\n  //region ------------------------ User actions\\n\\n  /// @notice Transfer given amount of the game token to the receiver\\n  function transfer(uint amount, address receiver) external {\\n    PawnShopRouterLib.transfer(\\n      IPawnShopRouter.CoreData({user: user, gameToken: gameToken, pawnShop: pawnShop}),\\n      _msgSender(),\\n      amount,\\n      receiver\\n    );\\n  }\\n\\n  /// @notice Transfer given amount of the given token to the receiver\\n  function salvage(address token, uint amount, address receiver) external {\\n    PawnShopRouterLib.salvage(\\n      IPawnShopRouter.CoreData({user: user, gameToken: gameToken, pawnShop: pawnShop}),\\n      _msgSender(),\\n      token,\\n      amount,\\n      receiver\\n    );\\n  }\\n\\n  /// @notice Allow the user to execute arbitrary code on this contract\\n  /// Results of successful call are stored to {callResultData}.\\n  /// Exception CallFailed with error details is generated if the call is failed.\\n  function call(address target_, bytes memory callData_) external {\\n    callResultData = PawnShopRouterLib.call(user, _msgSender(), target_, callData_);\\n  }\\n  //endregion ------------------------ User actions\\n\\n}\\n\",\"keccak256\":\"0x0e34bd957ebe16b317e0aa1cd1812b077cd0637635477e275ac0b4e42efcb113\",\"license\":\"BUSL-1.1\"},\"contracts/marketplace/PawnShopRouterFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./PawnShopRouter.sol\\\";\\n\\n/// @notice Factory to deploy personal instances of PawnShopRouter\\ncontract PawnShopRouterFactory {\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant VERSION = \\\"1.0.0\\\";\\n\\n  address immutable public pawnShop;\\n  address immutable public gameToken;\\n\\n  /// @notice Deployed instances of PawnShopRouter for the given users\\n  mapping(address user => address router) public router;\\n\\n  constructor(address pawnShop_, address gameToken_) {\\n    if (pawnShop_ == address(0) || gameToken_ == address(0)) revert IAppErrors.ZeroAddress();\\n\\n    pawnShop = pawnShop_;\\n    gameToken = gameToken_;\\n  }\\n\\n  /// @notice Deploy {PawnShopRouter} for the given {user}.\\n  /// Any user is allowed to have only one instance of deployed router.\\n  /// Address of the deployed router can be taken through {deployedRouter}\\n  function deployRouter(address user) external {\\n    // no restrictions\\n    if (user == address(0)) revert IAppErrors.ZeroAddress();\\n\\n    address deployed = router[user];\\n    if (deployed != address(0)) revert IAppErrors.AlreadyDeployed(deployed);\\n\\n    deployed = address(new PawnShopRouter(address(this), pawnShop, gameToken, user));\\n    router[user] = deployed;\\n\\n    emit IApplicationEvents.PawnShopRouterDeployed(pawnShop, gameToken, user, deployed);\\n  }\\n}\",\"keccak256\":\"0x69ad83c246e8b975e45baf273b5f583ecfc92627696c5a7a0f67f061658fdf02\",\"license\":\"BUSL-1.1\"},\"contracts/openzeppelin/ERC721Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n  /**\\n   * @dev See {IERC721Receiver-onERC721Received}.\\n   *\\n   * Always returns `IERC721Receiver.onERC721Received.selector`.\\n   */\\n  function onERC721Received(\\n    address,\\n    address,\\n    uint256,\\n    bytes memory\\n  ) public virtual override returns (bytes4) {\\n    return this.onERC721Received.selector;\\n  }\\n}\\n\",\"keccak256\":\"0xaf4708e1efc6a96ca12406877a82d66ea4bc82b71b26e982a70b0ce8755d8eed\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  // To implement this library for multiple types with as little code repetition as possible, we write it in\\n  // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\\n  // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\\n  // This means that we can only create new EnumerableMaps for types that fit in bytes32.\\n\\n  /**\\n   * @dev Query for a nonexistent map key.\\n     */\\n  error EnumerableMapNonexistentKey(bytes32 key);\\n\\n  struct Bytes32ToBytes32Map {\\n    // Storage of keys\\n    EnumerableSet.Bytes32Set _keys;\\n    mapping(bytes32 key => bytes32) _values;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n    map._values[key] = value;\\n    return map._keys.add(key);\\n  }\\n\\n  /**\\n   * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n    delete map._values[key];\\n    return map._keys.remove(key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n    return map._keys.contains(key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n    return map._keys.length();\\n  }\\n\\n  /**\\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n    bytes32 key = map._keys.at(index);\\n    return (key, map._values[key]);\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == bytes32(0)) {\\n      return (contains(map, key), bytes32(0));\\n    } else {\\n      return (true, value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == 0 && !contains(map, key)) {\\n      revert EnumerableMapNonexistentKey(key);\\n    }\\n    return value;\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n    return map._keys.values();\\n  }\\n\\n  // UintToUintMap\\n\\n  struct UintToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key)));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintToAddressMap\\n\\n  struct UintToAddressMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressToUintMap\\n\\n  struct AddressToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n    return remove(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (address(uint160(uint256(key))), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // Bytes32ToUintMap\\n\\n  struct Bytes32ToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, key, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n    return remove(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n    return contains(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (key, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, key);\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, key));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x5052395b3d57e4347a977f96eba69188b4a952594afae411910995ecab5c1d05\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position is the index of the value in the `values` array plus 1.\\n    // Position 0 is used to mean a value is not in the set.\\n    mapping(bytes32 value => uint256) _positions;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._positions[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We cache the value's position to prevent multiple reads from the same storage slot\\n    uint256 position = set._positions[value];\\n\\n    if (position != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 valueIndex = position - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (valueIndex != lastIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the lastValue to the index where the value to delete is\\n        set._values[valueIndex] = lastValue;\\n        // Update the tracked position of the lastValue (that was just moved)\\n        set._positions[lastValue] = position;\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the tracked position for the deleted slot\\n      delete set._positions[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._positions[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n     */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xd5483249a7bac53a40791ade8d640831cdec526eea6b42a4db68f2ce13c008fa\",\"license\":\"MIT\"},\"contracts/openzeppelin/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n  struct InitializableStorage {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n         */\\n    uint64 _initialized;\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n    bool _initializing;\\n  }\\n\\n  // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n  /**\\n   * @dev The contract is already initialized.\\n     */\\n  error InvalidInitialization();\\n\\n  /**\\n   * @dev The contract is not initializing.\\n     */\\n  error NotInitializing();\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n  event Initialized(uint64 version);\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier initializer() {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    // Cache values to avoid duplicated sloads\\n    bool isTopLevelCall = !$._initializing;\\n    uint64 initialized = $._initialized;\\n\\n    // Allowed calls:\\n    // - initialSetup: the contract is not in the initializing state and no previous version was\\n    //                 initialized\\n    // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n    //                 current contract is just being deployed\\n    bool initialSetup = initialized == 0 && isTopLevelCall;\\n    bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n    if (!initialSetup && !construction) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = 1;\\n    if (isTopLevelCall) {\\n      $._initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      $._initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier reinitializer(uint64 version) {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing || $._initialized >= version) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = version;\\n    $._initializing = true;\\n    _;\\n    $._initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n  modifier onlyInitializing() {\\n    _checkInitializing();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n  function _checkInitializing() internal view virtual {\\n    if (!_isInitializing()) {\\n      revert NotInitializing();\\n    }\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n  function _disableInitializers() internal virtual {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing) {\\n      revert InvalidInitialization();\\n    }\\n    if ($._initialized != type(uint64).max) {\\n      $._initialized = type(uint64).max;\\n      emit Initialized(type(uint64).max);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n  function _getInitializedVersion() internal view returns (uint64) {\\n    return _getInitializableStorage()._initialized;\\n  }\\n\\n  /**\\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n  function _isInitializing() internal view returns (bool) {\\n    return _getInitializableStorage()._initializing;\\n  }\\n\\n  /**\\n   * @dev Returns a pointer to the storage namespace.\\n     */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n    assembly {\\n      $.slot := INITIALIZABLE_STORAGE\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x80aa3fc0fc9afdf84bd1a51716150cd13041f42d920a9afa8020ea41cf673809\",\"license\":\"MIT\"},\"contracts/proxy/Controllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Initializable.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../lib/SlotsLib.sol\\\";\\n\\n/// @title Implement basic functionality for any contract that require strict control\\n/// @dev Can be used with upgradeable pattern.\\n///      Require call __Controllable_init() in any case.\\n/// @author belbix\\nabstract contract Controllable is Initializable, IControllable {\\n  using SlotsLib for bytes32;\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant CONTROLLABLE_VERSION = \\\"1.0.0\\\";\\n\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.revision\\\")) - 1);\\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.prev_logic\\\")) - 1);\\n\\n  event ContractInitialized(address controller, uint ts, uint block);\\n  event RevisionIncreased(uint value, address oldLogic);\\n\\n  // init implementation contract\\n  constructor() initializer {}\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\n  /// @dev Use it only once after first logic setup\\n  /// @param controller_ Controller address\\n  function __Controllable_init(address controller_) internal onlyInitializing {\\n    _init(controller_);\\n  }\\n\\n  function _init(address controller_) private {\\n    require(controller_ != address(0), \\\"Zero controller\\\");\\n    _CONTROLLER_SLOT.set(controller_);\\n    _CREATED_SLOT.set(block.timestamp);\\n    _CREATED_BLOCK_SLOT.set(block.number);\\n    emit ContractInitialized(controller_, block.timestamp, block.number);\\n  }\\n\\n  /// @dev Return true if given address is controller\\n  function isController(address value_) public override view returns (bool) {\\n    return value_ == controller();\\n  }\\n\\n  /// @notice Return true if given address is setup as governance in Controller\\n  function isGovernance(address value_) public override view returns (bool) {\\n    return IController(controller()).governance() == value_;\\n  }\\n\\n  /// @dev Contract upgrade counter\\n  function revision() external view override returns (uint) {\\n    return _REVISION_SLOT.getUint();\\n  }\\n\\n  /// @dev Previous logic implementation\\n  function previousImplementation() external view override returns (address) {\\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\\n  }\\n\\n  // ************* SETTERS/GETTERS *******************\\n\\n  /// @notice Return controller address saved in the contract slot\\n  function controller() public view override returns (address) {\\n    return _CONTROLLER_SLOT.getAddress();\\n  }\\n\\n  /// @notice Return creation timestamp\\n  /// @return Creation timestamp\\n  function created() external view override returns (uint256) {\\n    return _CREATED_SLOT.getUint();\\n  }\\n\\n  /// @notice Return creation block number\\n  /// @return Creation block number\\n  function createdBlock() external override view returns (uint256) {\\n    return _CREATED_BLOCK_SLOT.getUint();\\n  }\\n\\n  /// @dev Revision should be increased on each contract upgrade\\n  function increaseRevision(address oldLogic) external override {\\n    require(msg.sender == address(this), \\\"Increase revision forbidden\\\");\\n    uint r = _REVISION_SLOT.getUint() + 1;\\n    _REVISION_SLOT.set(r);\\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\\n    emit RevisionIncreased(r, oldLogic);\\n  }\\n\\n}\\n\",\"keccak256\":\"0x1edc53f0d11834bebf4485746d04112ed10db9d4cb19b4945362c593ebf97daf\",\"license\":\"BUSL-1.1\"},\"contracts/relay/ERC2771Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.1;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\n// based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol\\nabstract contract ERC2771Context {\\n  // for whitelist new relayers need to add new constants and update proxies\\n  address private constant GELATO_RELAY_1_BALANCE_ERC_2771 = 0xd8253782c45a12053594b9deB72d8e8aB2Fca54c;\\n  address private constant SACRA_RELAY = 0x52CEba41Da235Af367bFC0b0cCd3314cb901bB5F;\\n\\n  function isTrustedForwarder(address forwarder) public view virtual returns (bool){\\n    return forwarder == GELATO_RELAY_1_BALANCE_ERC_2771 || forwarder == SACRA_RELAY;\\n  }\\n\\n  function _msgSender() internal view virtual returns (address sender) {\\n    if (isTrustedForwarder(msg.sender)) {\\n      // The assembly code is more direct than the Solidity version using `abi.decode`.\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n      }\\n      return sender;\\n    } else {\\n      return msg.sender;\\n    }\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    if (isTrustedForwarder(msg.sender)) {\\n      return msg.data[: msg.data.length - 20];\\n    } else {\\n      return msg.data;\\n    }\\n  }\\n\\n  /// @notice Return true if given address is not a smart contract but a wallet address.\\n  /// @dev It is not 100% guarantee after EIP-3074 implementation, use it as an additional check.\\n  /// @return true if the address is a wallet.\\n  function _isNotSmartContract() internal view returns (bool) {\\n    return isTrustedForwarder(msg.sender) || msg.sender == tx.origin;\\n  }\\n\\n  function onlyEOA() internal view {\\n    if (!_isNotSmartContract()) {\\n      revert IAppErrors.NotEOA(msg.sender);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x1ca981a603a741a635268b53ecde2ea35fa994a4a809e1a4947e47ba8cc565ee\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c060405234801561001057600080fd5b50604051612c95380380612c9583398101604081905261002f9161009d565b6001600160a01b038216158061004c57506001600160a01b038116155b1561006a5760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b039182166080521660a0526100d0565b80516001600160a01b038116811461009857600080fd5b919050565b600080604083850312156100b057600080fd5b6100b983610081565b91506100c760208401610081565b90509250929050565b60805160a051612b8661010f60003960008181609e015281816101bf015261029401526000818160610152818161019e01526102720152612b866000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c8063b784a4971461005c578063c3dfdae614610099578063e2a1bd4e146100c0578063e4b643e3146100d5578063ffa1ad74146100fe575b600080fd5b6100837f000000000000000000000000000000000000000000000000000000000000000081565b60405161009091906102d6565b60405180910390f35b6100837f000000000000000000000000000000000000000000000000000000000000000081565b6100d36100ce3660046102ea565b61012f565b005b6100836100e33660046102ea565b6000602081905290815260409020546001600160a01b031681565b610122604051806040016040528060058152602001640312e302e360dc1b81525081565b604051610090919061031a565b6001600160a01b0381166101565760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b0380821660009081526020819052604090205416801561019b57806040516329ab51bf60e01b815260040161019291906102d6565b60405180910390fd5b307f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000846040516101eb906102c9565b6101f89493929190610369565b604051809103906000f080158015610214573d6000803e3d6000fd5b506001600160a01b038381166000908152602081905260409081902080546001600160a01b03191692841692909217909155519091507f38540df229fbabf3d176dfb78f1b8174d9a93eb70dcf74fd90a2c61d042520dd906102bd907f0000000000000000000000000000000000000000000000000000000000000000907f00000000000000000000000000000000000000000000000000000000000000009086908690610369565b60405180910390a15050565b6127bc8061039583390190565b6001600160a01b0391909116815260200190565b6000602082840312156102fc57600080fd5b81356001600160a01b038116811461031357600080fd5b9392505050565b60006020808352835180602085015260005b818110156103485785810183015185820160400152820161032c565b506000604082860101526040601f19601f8301168501019250505092915050565b6001600160a01b0394851681529284166020840152908316604083015290911660608201526080019056fe6101006040523480156200001257600080fd5b50604051620027bc380380620027bc833981016040819052620000359162000153565b6001600160a01b03841615806200005357506001600160a01b038316155b806200006657506001600160a01b038216155b806200007957506001600160a01b038116155b15620000985760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b0384811660805282811660c081905284821660a081905291831660e05260405163095ea7b360e01b81526004810192909252600160ff1b60248301529063095ea7b3906044016020604051808303816000875af115801562000105573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200012b9190620001b0565b5050505050620001db565b80516001600160a01b03811681146200014e57600080fd5b919050565b600080600080608085870312156200016a57600080fd5b620001758562000136565b9350620001856020860162000136565b9250620001956040860162000136565b9150620001a56060860162000136565b905092959194509250565b600060208284031215620001c357600080fd5b81518015158114620001d457600080fd5b9392505050565b60805160a05160c05160e05161250d620002af600039600081816101b901528181610312015281816103c0015281816104690152818161065901528181610701015281816107b1015261088b0152600081816102a0015281816103910152818161043a0152818161062a015281816106d201528181610782015261085c01526000818161025e015281816103620152818161040b015281816104af015281816104e4015281816105fb015281816106a301528181610753015281816107f2015261082d015260006102c7015261250d6000f3fe608060405234801561001057600080fd5b50600436106100f65760003560e01c80637189983f116100925780637189983f14610220578063aa820e3014610233578063b7760c8f14610246578063b784a49714610259578063bbda23e414610280578063c1d7ee9214610288578063c3dfdae61461029b578063c45a0155146102c2578063ffa1ad74146102e957600080fd5b8063150b7a02146100fb5780631b8b921d146101375780631e3cd4041461014c5780632742d6441461015f578063378de45b146101725780633a58ad8d146101935780634f8632ba146101b4578063572b6c05146101e857806370bf11941461020b575b600080fd5b610119610109366004611b41565b630a85bd0160e11b949350505050565b6040516001600160e01b031990911681526020015b60405180910390f35b61014a610145366004611bac565b61030d565b005b61014a61015a366004611bfb565b610352565b61014a61016d366004611ccf565b6103fb565b610185610180366004611d20565b6104a7565b60405161012e929190611d39565b6101a66101a1366004611d20565b6104dd565b60405190815260200161012e565b6101db7f000000000000000000000000000000000000000000000000000000000000000081565b60405161012e9190611d52565b6101fb6101f6366004611d66565b61050f565b604051901515815260200161012e565b61021361055d565b60405161012e9190611dd3565b61014a61022e366004611ccf565b6105eb565b61014a610241366004611de6565b610693565b61014a610254366004611edc565b610743565b6101db7f000000000000000000000000000000000000000000000000000000000000000081565b6101a66107eb565b6101a6610296366004611f01565b61081b565b6101db7f000000000000000000000000000000000000000000000000000000000000000081565b6101db7f000000000000000000000000000000000000000000000000000000000000000081565b61021360405180604001604052806005815260200164312e302e3160d81b81525081565b6103407f00000000000000000000000000000000000000000000000000000000000000006103396108bc565b84846108de565b60009061034d9082611fbf565b505050565b61034d60405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152506103f36108bc565b85858561097d565b6104a360405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681525061049c6108bc565b8484610a3f565b5050565b6000806104d47f000000000000000000000000000000000000000000000000000000000000000084610c1e565b91509150915091565b60006105097f000000000000000000000000000000000000000000000000000000000000000083610cfb565b92915050565b60006001600160a01b03821673d8253782c45a12053594b9deb72d8e8ab2fca54c148061050957506001600160a01b0382167352ceba41da235af367bfc0b0ccd3314cb901bb5f1492915050565b6000805461056a90611f3d565b80601f016020809104026020016040519081016040528092919081815260200182805461059690611f3d565b80156105e35780601f106105b8576101008083540402835291602001916105e3565b820191906000526020600020905b8154815290600101906020018083116105c657829003601f168201915b505050505081565b6104a360405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681525061068c6108bc565b8484610d74565b61073d60405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152506107346108bc565b8686868661107b565b50505050565b6104a360405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152506107e46108bc565b8484611483565b60006108167f000000000000000000000000000000000000000000000000000000000000000061154c565b905090565b600061050960405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316815250836115ba565b60006108c73361050f565b156108d9575060131936013560601c90565b503390565b60606108ea848661160b565b6000836001600160a01b031683604051610904919061207e565b6000604051808303816000865af19150503d8060008114610941576040519150601f19603f3d011682016040523d82523d6000602084013e610946565b606091505b509250905080610974578160405163a5fa8d2b60e01b815260040161096b9190611dd3565b60405180910390fd5b50949350505050565b61098b84866040015161160b565b60405163a9059cbb60e01b81526001600160a01b0384169063a9059cbb906109b99084908690600401611d39565b6020604051808303816000875af11580156109d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109fc91906120aa565b507f0661ce452aa0a13f47c93bb193363973d51bb9664404a6f6e1ce817d082dea29838383604051610a30939291906120c5565b60405180910390a15050505050565b610a4d83856040015161160b565b8351825160005b81811015610bdc576000836001600160a01b031663eb02c301878481518110610a7f57610a7f6120e8565b60200260200101516040518263ffffffff1660e01b8152600401610aa591815260200190565b61028060405180830381865afa158015610ac3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ae79190612252565b9050836001600160a01b031663a126d601878481518110610b0a57610b0a6120e8565b60200260200101516040518263ffffffff1660e01b8152600401610b3091815260200190565b600060405180830381600087803b158015610b4a57600080fd5b505af1158015610b5e573d6000803e3d6000fd5b5050505060e081015180516060909101516040516323b872dd60e01b81526001600160a01b03909216916323b872dd91610b9e9130918a9160040161230c565b600060405180830381600087803b158015610bb857600080fd5b505af1158015610bcc573d6000803e3d6000fd5b5050505050806001019050610a54565b507f73ebb0c261bcb022f9442dff3e06c47787cf88f7bdaf9f1d39801266e19630fc8484604051610c0e92919061236c565b60405180910390a1505050505050565b600080836001600160a01b031663db2dbb446040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c5f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c839190612396565b83856001600160a01b03166398584c0f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cc2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ce691906123b3565b610cf091906123e2565b915091509250929050565b6040516302c0601960e11b81526000906001600160a01b03841690630580c03290610d2c9030908690600401611d39565b602060405180830381865afa158015610d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d6d91906123b3565b9392505050565b610d8283856040015161160b565b835182516000816001600160401b03811115610da057610da0611a41565b604051908082528060200260200182016040528015610dd957816020015b610dc6611928565b815260200190600190039081610dbe5790505b5090506000805b83811015610e6057610e0b89888381518110610dfe57610dfe6120e8565b602002602001015161163f565b838281518110610e1d57610e1d6120e8565b6020026020010181905250828181518110610e3a57610e3a6120e8565b602002602001015161010001516020015182610e5691906123f9565b9150600101610de0565b5087602001516001600160a01b03166323b872dd8830846040518463ffffffff1660e01b8152600401610e959392919061230c565b6020604051808303816000875af1158015610eb4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ed891906120aa565b5060005b8381101561103757846001600160a01b031663598647f8888381518110610f0557610f056120e8565b6020026020010151858481518110610f1f57610f1f6120e8565b60200260200101516101000151602001516040518363ffffffff1660e01b8152600401610f56929190918252602082015260400190565b600060405180830381600087803b158015610f7057600080fd5b505af1158015610f84573d6000803e3d6000fd5b50505050828181518110610f9a57610f9a6120e8565b602002602001015160e00151600001516001600160a01b03166323b872dd3088868581518110610fcc57610fcc6120e8565b602002602001015160e00151606001516040518463ffffffff1660e01b8152600401610ffa9392919061230c565b600060405180830381600087803b15801561101457600080fd5b505af1158015611028573d6000803e3d6000fd5b50505050806001019050610edc565b507f9ed1012aa23606a118975c1396e31aef3e82a0ae379c4cc6abbd1c403ecec7bc868660405161106992919061236c565b60405180910390a15050505050505050565b61108985876040015161160b565b825182518114158061109c575084518114155b156110ba5760405163586cb9e160e01b815260040160405180910390fd5b600087600001516001600160a01b03166398584c0f6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156110fe573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061112291906123b3565b9050801561122857600088600001516001600160a01b031663db2dbb446040518163ffffffff1660e01b8152600401602060405180830381865afa15801561116e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111929190612396565b90506001600160a01b0381166323b872dd89306111af87876123e2565b6040518463ffffffff1660e01b81526004016111cd9392919061230c565b6020604051808303816000875af11580156111ec573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121091906120aa565b506112268161121f85856123e2565b8b51611763565b505b6000826001600160401b0381111561124257611242611a41565b60405190808252806020026020018201604052801561126b578160200160208202803683370190505b50905060005b8381101561143857600088828151811061128d5761128d6120e8565b60200260200101519050806001600160a01b03166323b872dd87308b86815181106112ba576112ba6120e8565b60200260200101516040518463ffffffff1660e01b81526004016112e09392919061230c565b600060405180830381600087803b1580156112fa57600080fd5b505af115801561130e573d6000803e3d6000fd5b50505050611320818c6000015161184f565b8a600001516001600160a01b0316633a5edc548260008b8681518110611348576113486120e8565b60200260200101518f602001518c8881518110611367576113676120e8565b602090810291909101015160405160e087901b6001600160e01b03191681526001600160a01b0395861660048201526024810194909452604484019290925290921660648201526084810191909152600060a4820181905260c4820181905260e4820152610104016020604051808303816000875af11580156113ee573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061141291906123b3565b838381518110611424576114246120e8565b602090810291909101015250600101611271565b507fdc0ba8e6af9d6a2318c8ee4dcc198ed3ebcfd722d7d4a37b0c24f0f48ccb201c878787878560405161147095949392919061240c565b60405180910390a1505050505050505050565b61149183856040015161160b565b83602001516001600160a01b031663a9059cbb82846040518363ffffffff1660e01b81526004016114c3929190611d39565b6020604051808303816000875af11580156114e2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061150691906120aa565b507f0661ce452aa0a13f47c93bb193363973d51bb9664404a6f6e1ce817d082dea298460200151838360405161153e939291906120c5565b60405180910390a150505050565b604051624ce3d360e01b81526000906001600160a01b03831690624ce3d390611579903090600401611d52565b602060405180830381865afa158015611596573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050991906123b3565b8051600090815b818110156116035760006115e186868481518110610dfe57610dfe6120e8565b905080610100015160200151846115f891906123f9565b9350506001016115c1565b505092915050565b806001600160a01b0316826001600160a01b0316146104a3578160405163f652640360e01b815260040161096b9190611d52565b611647611928565b825160405163eb02c30160e01b8152600481018490526000916001600160a01b03169063eb02c3019060240161028060405180830381865afa158015611691573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116b59190612252565b9050806101000151602001516000036116e457604051633ad994bb60e11b81526004810184905260240161096b565b83602001516001600160a01b0316816101000151600001516001600160a01b0316146117265760405163778f598560e01b81526004810184905260240161096b565b60018160e00151602001516001811115611742576117426124a7565b14610d6d5760405163ed450ff160e01b81526004810184905260240161096b565b604051636eb1769f60e11b815282906001600160a01b0385169063dd62ed3e9061179390309086906004016124bd565b602060405180830381865afa1580156117b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117d491906123b3565b101561034d5760405163095ea7b360e01b81526001600160a01b0384169063095ea7b39061180c908490600160ff1b90600401611d39565b6020604051808303816000875af115801561182b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073d91906120aa565b60405163e985e9c560e01b81526001600160a01b0383169063e985e9c59061187d90309085906004016124bd565b602060405180830381865afa15801561189a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118be91906120aa565b6104a35760405163a22cb46560e01b81526001600160a01b0382811660048301526001602483015283169063a22cb46590604401600060405180830381600087803b15801561190c57600080fd5b505af1158015611920573d6000803e3d6000fd5b505050505050565b6040518061014001604052806000815260200160006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000151581526020016000815260200161199d6040518060800160405280600081526020016000815260200160008152602001600081525090565b81526040805160808101825260008082526020808301829052828401829052606083018290528085019290925282518084018452818152918201529101908152602001611a14604051806080016040528060006001600160a01b031681526020016000815260200160008152602001600081525090565b905290565b6001600160a01b0381168114611a2e57600080fd5b50565b8035611a3c81611a19565b919050565b634e487b7160e01b600052604160045260246000fd5b604051608081016001600160401b0381118282101715611a7957611a79611a41565b60405290565b60405161014081016001600160401b0381118282101715611a7957611a79611a41565b604051601f8201601f191681016001600160401b0381118282101715611aca57611aca611a41565b604052919050565b600082601f830112611ae357600080fd5b81356001600160401b03811115611afc57611afc611a41565b611b0f601f8201601f1916602001611aa2565b818152846020838601011115611b2457600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060808587031215611b5757600080fd5b8435611b6281611a19565b93506020850135611b7281611a19565b92506040850135915060608501356001600160401b03811115611b9457600080fd5b611ba087828801611ad2565b91505092959194509250565b60008060408385031215611bbf57600080fd5b8235611bca81611a19565b915060208301356001600160401b03811115611be557600080fd5b611bf185828601611ad2565b9150509250929050565b600080600060608486031215611c1057600080fd5b8335611c1b81611a19565b9250602084013591506040840135611c3281611a19565b809150509250925092565b60006001600160401b03821115611c5657611c56611a41565b5060051b60200190565b600082601f830112611c7157600080fd5b81356020611c86611c8183611c3d565b611aa2565b8083825260208201915060208460051b870101935086841115611ca857600080fd5b602086015b84811015611cc45780358352918301918301611cad565b509695505050505050565b60008060408385031215611ce257600080fd5b82356001600160401b03811115611cf857600080fd5b611d0485828601611c60565b9250506020830135611d1581611a19565b809150509250929050565b600060208284031215611d3257600080fd5b5035919050565b6001600160a01b03929092168252602082015260400190565b6001600160a01b0391909116815260200190565b600060208284031215611d7857600080fd5b8135610d6d81611a19565b60005b83811015611d9e578181015183820152602001611d86565b50506000910152565b60008151808452611dbf816020860160208601611d83565b601f01601f19169290920160200192915050565b602081526000610d6d6020830184611da7565b60008060008060808587031215611dfc57600080fd5b84356001600160401b0380821115611e1357600080fd5b818701915087601f830112611e2757600080fd5b81356020611e37611c8183611c3d565b82815260059290921b8401810191818101908b841115611e5657600080fd5b948201945b83861015611e7d578535611e6e81611a19565b82529482019490820190611e5b565b98505088013592505080821115611e9357600080fd5b611e9f88838901611c60565b94506040870135915080821115611eb557600080fd5b50611ec287828801611c60565b925050611ed160608601611a31565b905092959194509250565b60008060408385031215611eef57600080fd5b823591506020830135611d1581611a19565b600060208284031215611f1357600080fd5b81356001600160401b03811115611f2957600080fd5b611f3584828501611c60565b949350505050565b600181811c90821680611f5157607f821691505b602082108103611f7157634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561034d576000816000526020600020601f850160051c81016020861015611fa05750805b601f850160051c820191505b8181101561192057828155600101611fac565b81516001600160401b03811115611fd857611fd8611a41565b611fec81611fe68454611f3d565b84611f77565b602080601f83116001811461202157600084156120095750858301515b600019600386901b1c1916600185901b178555611920565b600085815260208120601f198616915b8281101561205057888601518255948401946001909101908401612031565b508582101561206e5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60008251612090818460208701611d83565b9190910192915050565b80518015158114611a3c57600080fd5b6000602082840312156120bc57600080fd5b610d6d8261209a565b6001600160a01b0393841681526020810192909252909116604082015260600190565b634e487b7160e01b600052603260045260246000fd5b8051611a3c81611a19565b60006080828403121561211b57600080fd5b612123611a57565b90508151815260208201516020820152604082015160408201526060820151606082015292915050565b60006080828403121561215f57600080fd5b612167611a57565b9050815161217481611a19565b815260208201516002811061218857600080fd5b80602083015250604082015160408201526060820151606082015292915050565b6000604082840312156121bb57600080fd5b604051604081018181106001600160401b03821117156121dd576121dd611a41565b806040525080915082516121f081611a19565b8152602092830151920191909152919050565b60006080828403121561221557600080fd5b61221d611a57565b9050815161222a81611a19565b8082525060208201516020820152604082015160408201526060820151606082015292915050565b6000610280828403121561226557600080fd5b61226d611a7f565b8251815261227d602084016120fe565b602082015261228e604084016120fe565b6040820152606083015160608201526122a96080840161209a565b608082015260a083015160a08201526122c58460c08501612109565b60c08201526122d884610140850161214d565b60e08201526122eb846101c085016121a9565b6101008201526122ff846102008501612203565b6101208201529392505050565b6001600160a01b039384168152919092166020820152604081019190915260600190565b60008151808452602080850194506020840160005b8381101561236157815187529582019590820190600101612345565b509495945050505050565b60408152600061237f6040830185612330565b905060018060a01b03831660208301529392505050565b6000602082840312156123a857600080fd5b8151610d6d81611a19565b6000602082840312156123c557600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b8082028115828204841417610509576105096123cc565b80820180821115610509576105096123cc565b60a0808252865190820181905260009060209060c0840190828a01845b8281101561244e5781516001600160a01b031684529284019290840190600101612429565b50505083810360208501526124638189612330565b91505082810360408401526124788187612330565b6001600160a01b03861660608501528381036080850152905061249b8185612330565b98975050505050505050565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b039283168152911660208201526040019056fea264697066735822122028652835ab111f76a64a51e027f8cf353ec228d4605c77311b862b5655ebe5e864736f6c63430008170033a2646970667358221220567e6ad5b53fbfa433f4d6fb0a18fe447edbdc994cfd59225195429271ff01ae64736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c8063b784a4971461005c578063c3dfdae614610099578063e2a1bd4e146100c0578063e4b643e3146100d5578063ffa1ad74146100fe575b600080fd5b6100837f000000000000000000000000000000000000000000000000000000000000000081565b60405161009091906102d6565b60405180910390f35b6100837f000000000000000000000000000000000000000000000000000000000000000081565b6100d36100ce3660046102ea565b61012f565b005b6100836100e33660046102ea565b6000602081905290815260409020546001600160a01b031681565b610122604051806040016040528060058152602001640312e302e360dc1b81525081565b604051610090919061031a565b6001600160a01b0381166101565760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b0380821660009081526020819052604090205416801561019b57806040516329ab51bf60e01b815260040161019291906102d6565b60405180910390fd5b307f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000846040516101eb906102c9565b6101f89493929190610369565b604051809103906000f080158015610214573d6000803e3d6000fd5b506001600160a01b038381166000908152602081905260409081902080546001600160a01b03191692841692909217909155519091507f38540df229fbabf3d176dfb78f1b8174d9a93eb70dcf74fd90a2c61d042520dd906102bd907f0000000000000000000000000000000000000000000000000000000000000000907f00000000000000000000000000000000000000000000000000000000000000009086908690610369565b60405180910390a15050565b6127bc8061039583390190565b6001600160a01b0391909116815260200190565b6000602082840312156102fc57600080fd5b81356001600160a01b038116811461031357600080fd5b9392505050565b60006020808352835180602085015260005b818110156103485785810183015185820160400152820161032c565b506000604082860101526040601f19601f8301168501019250505092915050565b6001600160a01b0394851681529284166020840152908316604083015290911660608201526080019056fe6101006040523480156200001257600080fd5b50604051620027bc380380620027bc833981016040819052620000359162000153565b6001600160a01b03841615806200005357506001600160a01b038316155b806200006657506001600160a01b038216155b806200007957506001600160a01b038116155b15620000985760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b0384811660805282811660c081905284821660a081905291831660e05260405163095ea7b360e01b81526004810192909252600160ff1b60248301529063095ea7b3906044016020604051808303816000875af115801562000105573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200012b9190620001b0565b5050505050620001db565b80516001600160a01b03811681146200014e57600080fd5b919050565b600080600080608085870312156200016a57600080fd5b620001758562000136565b9350620001856020860162000136565b9250620001956040860162000136565b9150620001a56060860162000136565b905092959194509250565b600060208284031215620001c357600080fd5b81518015158114620001d457600080fd5b9392505050565b60805160a05160c05160e05161250d620002af600039600081816101b901528181610312015281816103c0015281816104690152818161065901528181610701015281816107b1015261088b0152600081816102a0015281816103910152818161043a0152818161062a015281816106d201528181610782015261085c01526000818161025e015281816103620152818161040b015281816104af015281816104e4015281816105fb015281816106a301528181610753015281816107f2015261082d015260006102c7015261250d6000f3fe608060405234801561001057600080fd5b50600436106100f65760003560e01c80637189983f116100925780637189983f14610220578063aa820e3014610233578063b7760c8f14610246578063b784a49714610259578063bbda23e414610280578063c1d7ee9214610288578063c3dfdae61461029b578063c45a0155146102c2578063ffa1ad74146102e957600080fd5b8063150b7a02146100fb5780631b8b921d146101375780631e3cd4041461014c5780632742d6441461015f578063378de45b146101725780633a58ad8d146101935780634f8632ba146101b4578063572b6c05146101e857806370bf11941461020b575b600080fd5b610119610109366004611b41565b630a85bd0160e11b949350505050565b6040516001600160e01b031990911681526020015b60405180910390f35b61014a610145366004611bac565b61030d565b005b61014a61015a366004611bfb565b610352565b61014a61016d366004611ccf565b6103fb565b610185610180366004611d20565b6104a7565b60405161012e929190611d39565b6101a66101a1366004611d20565b6104dd565b60405190815260200161012e565b6101db7f000000000000000000000000000000000000000000000000000000000000000081565b60405161012e9190611d52565b6101fb6101f6366004611d66565b61050f565b604051901515815260200161012e565b61021361055d565b60405161012e9190611dd3565b61014a61022e366004611ccf565b6105eb565b61014a610241366004611de6565b610693565b61014a610254366004611edc565b610743565b6101db7f000000000000000000000000000000000000000000000000000000000000000081565b6101a66107eb565b6101a6610296366004611f01565b61081b565b6101db7f000000000000000000000000000000000000000000000000000000000000000081565b6101db7f000000000000000000000000000000000000000000000000000000000000000081565b61021360405180604001604052806005815260200164312e302e3160d81b81525081565b6103407f00000000000000000000000000000000000000000000000000000000000000006103396108bc565b84846108de565b60009061034d9082611fbf565b505050565b61034d60405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152506103f36108bc565b85858561097d565b6104a360405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681525061049c6108bc565b8484610a3f565b5050565b6000806104d47f000000000000000000000000000000000000000000000000000000000000000084610c1e565b91509150915091565b60006105097f000000000000000000000000000000000000000000000000000000000000000083610cfb565b92915050565b60006001600160a01b03821673d8253782c45a12053594b9deb72d8e8ab2fca54c148061050957506001600160a01b0382167352ceba41da235af367bfc0b0ccd3314cb901bb5f1492915050565b6000805461056a90611f3d565b80601f016020809104026020016040519081016040528092919081815260200182805461059690611f3d565b80156105e35780601f106105b8576101008083540402835291602001916105e3565b820191906000526020600020905b8154815290600101906020018083116105c657829003601f168201915b505050505081565b6104a360405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681525061068c6108bc565b8484610d74565b61073d60405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152506107346108bc565b8686868661107b565b50505050565b6104a360405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152506107e46108bc565b8484611483565b60006108167f000000000000000000000000000000000000000000000000000000000000000061154c565b905090565b600061050960405180606001604052807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681526020017f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316815250836115ba565b60006108c73361050f565b156108d9575060131936013560601c90565b503390565b60606108ea848661160b565b6000836001600160a01b031683604051610904919061207e565b6000604051808303816000865af19150503d8060008114610941576040519150601f19603f3d011682016040523d82523d6000602084013e610946565b606091505b509250905080610974578160405163a5fa8d2b60e01b815260040161096b9190611dd3565b60405180910390fd5b50949350505050565b61098b84866040015161160b565b60405163a9059cbb60e01b81526001600160a01b0384169063a9059cbb906109b99084908690600401611d39565b6020604051808303816000875af11580156109d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109fc91906120aa565b507f0661ce452aa0a13f47c93bb193363973d51bb9664404a6f6e1ce817d082dea29838383604051610a30939291906120c5565b60405180910390a15050505050565b610a4d83856040015161160b565b8351825160005b81811015610bdc576000836001600160a01b031663eb02c301878481518110610a7f57610a7f6120e8565b60200260200101516040518263ffffffff1660e01b8152600401610aa591815260200190565b61028060405180830381865afa158015610ac3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ae79190612252565b9050836001600160a01b031663a126d601878481518110610b0a57610b0a6120e8565b60200260200101516040518263ffffffff1660e01b8152600401610b3091815260200190565b600060405180830381600087803b158015610b4a57600080fd5b505af1158015610b5e573d6000803e3d6000fd5b5050505060e081015180516060909101516040516323b872dd60e01b81526001600160a01b03909216916323b872dd91610b9e9130918a9160040161230c565b600060405180830381600087803b158015610bb857600080fd5b505af1158015610bcc573d6000803e3d6000fd5b5050505050806001019050610a54565b507f73ebb0c261bcb022f9442dff3e06c47787cf88f7bdaf9f1d39801266e19630fc8484604051610c0e92919061236c565b60405180910390a1505050505050565b600080836001600160a01b031663db2dbb446040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c5f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c839190612396565b83856001600160a01b03166398584c0f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cc2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ce691906123b3565b610cf091906123e2565b915091509250929050565b6040516302c0601960e11b81526000906001600160a01b03841690630580c03290610d2c9030908690600401611d39565b602060405180830381865afa158015610d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d6d91906123b3565b9392505050565b610d8283856040015161160b565b835182516000816001600160401b03811115610da057610da0611a41565b604051908082528060200260200182016040528015610dd957816020015b610dc6611928565b815260200190600190039081610dbe5790505b5090506000805b83811015610e6057610e0b89888381518110610dfe57610dfe6120e8565b602002602001015161163f565b838281518110610e1d57610e1d6120e8565b6020026020010181905250828181518110610e3a57610e3a6120e8565b602002602001015161010001516020015182610e5691906123f9565b9150600101610de0565b5087602001516001600160a01b03166323b872dd8830846040518463ffffffff1660e01b8152600401610e959392919061230c565b6020604051808303816000875af1158015610eb4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ed891906120aa565b5060005b8381101561103757846001600160a01b031663598647f8888381518110610f0557610f056120e8565b6020026020010151858481518110610f1f57610f1f6120e8565b60200260200101516101000151602001516040518363ffffffff1660e01b8152600401610f56929190918252602082015260400190565b600060405180830381600087803b158015610f7057600080fd5b505af1158015610f84573d6000803e3d6000fd5b50505050828181518110610f9a57610f9a6120e8565b602002602001015160e00151600001516001600160a01b03166323b872dd3088868581518110610fcc57610fcc6120e8565b602002602001015160e00151606001516040518463ffffffff1660e01b8152600401610ffa9392919061230c565b600060405180830381600087803b15801561101457600080fd5b505af1158015611028573d6000803e3d6000fd5b50505050806001019050610edc565b507f9ed1012aa23606a118975c1396e31aef3e82a0ae379c4cc6abbd1c403ecec7bc868660405161106992919061236c565b60405180910390a15050505050505050565b61108985876040015161160b565b825182518114158061109c575084518114155b156110ba5760405163586cb9e160e01b815260040160405180910390fd5b600087600001516001600160a01b03166398584c0f6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156110fe573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061112291906123b3565b9050801561122857600088600001516001600160a01b031663db2dbb446040518163ffffffff1660e01b8152600401602060405180830381865afa15801561116e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111929190612396565b90506001600160a01b0381166323b872dd89306111af87876123e2565b6040518463ffffffff1660e01b81526004016111cd9392919061230c565b6020604051808303816000875af11580156111ec573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121091906120aa565b506112268161121f85856123e2565b8b51611763565b505b6000826001600160401b0381111561124257611242611a41565b60405190808252806020026020018201604052801561126b578160200160208202803683370190505b50905060005b8381101561143857600088828151811061128d5761128d6120e8565b60200260200101519050806001600160a01b03166323b872dd87308b86815181106112ba576112ba6120e8565b60200260200101516040518463ffffffff1660e01b81526004016112e09392919061230c565b600060405180830381600087803b1580156112fa57600080fd5b505af115801561130e573d6000803e3d6000fd5b50505050611320818c6000015161184f565b8a600001516001600160a01b0316633a5edc548260008b8681518110611348576113486120e8565b60200260200101518f602001518c8881518110611367576113676120e8565b602090810291909101015160405160e087901b6001600160e01b03191681526001600160a01b0395861660048201526024810194909452604484019290925290921660648201526084810191909152600060a4820181905260c4820181905260e4820152610104016020604051808303816000875af11580156113ee573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061141291906123b3565b838381518110611424576114246120e8565b602090810291909101015250600101611271565b507fdc0ba8e6af9d6a2318c8ee4dcc198ed3ebcfd722d7d4a37b0c24f0f48ccb201c878787878560405161147095949392919061240c565b60405180910390a1505050505050505050565b61149183856040015161160b565b83602001516001600160a01b031663a9059cbb82846040518363ffffffff1660e01b81526004016114c3929190611d39565b6020604051808303816000875af11580156114e2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061150691906120aa565b507f0661ce452aa0a13f47c93bb193363973d51bb9664404a6f6e1ce817d082dea298460200151838360405161153e939291906120c5565b60405180910390a150505050565b604051624ce3d360e01b81526000906001600160a01b03831690624ce3d390611579903090600401611d52565b602060405180830381865afa158015611596573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050991906123b3565b8051600090815b818110156116035760006115e186868481518110610dfe57610dfe6120e8565b905080610100015160200151846115f891906123f9565b9350506001016115c1565b505092915050565b806001600160a01b0316826001600160a01b0316146104a3578160405163f652640360e01b815260040161096b9190611d52565b611647611928565b825160405163eb02c30160e01b8152600481018490526000916001600160a01b03169063eb02c3019060240161028060405180830381865afa158015611691573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116b59190612252565b9050806101000151602001516000036116e457604051633ad994bb60e11b81526004810184905260240161096b565b83602001516001600160a01b0316816101000151600001516001600160a01b0316146117265760405163778f598560e01b81526004810184905260240161096b565b60018160e00151602001516001811115611742576117426124a7565b14610d6d5760405163ed450ff160e01b81526004810184905260240161096b565b604051636eb1769f60e11b815282906001600160a01b0385169063dd62ed3e9061179390309086906004016124bd565b602060405180830381865afa1580156117b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117d491906123b3565b101561034d5760405163095ea7b360e01b81526001600160a01b0384169063095ea7b39061180c908490600160ff1b90600401611d39565b6020604051808303816000875af115801561182b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073d91906120aa565b60405163e985e9c560e01b81526001600160a01b0383169063e985e9c59061187d90309085906004016124bd565b602060405180830381865afa15801561189a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118be91906120aa565b6104a35760405163a22cb46560e01b81526001600160a01b0382811660048301526001602483015283169063a22cb46590604401600060405180830381600087803b15801561190c57600080fd5b505af1158015611920573d6000803e3d6000fd5b505050505050565b6040518061014001604052806000815260200160006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000151581526020016000815260200161199d6040518060800160405280600081526020016000815260200160008152602001600081525090565b81526040805160808101825260008082526020808301829052828401829052606083018290528085019290925282518084018452818152918201529101908152602001611a14604051806080016040528060006001600160a01b031681526020016000815260200160008152602001600081525090565b905290565b6001600160a01b0381168114611a2e57600080fd5b50565b8035611a3c81611a19565b919050565b634e487b7160e01b600052604160045260246000fd5b604051608081016001600160401b0381118282101715611a7957611a79611a41565b60405290565b60405161014081016001600160401b0381118282101715611a7957611a79611a41565b604051601f8201601f191681016001600160401b0381118282101715611aca57611aca611a41565b604052919050565b600082601f830112611ae357600080fd5b81356001600160401b03811115611afc57611afc611a41565b611b0f601f8201601f1916602001611aa2565b818152846020838601011115611b2457600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060808587031215611b5757600080fd5b8435611b6281611a19565b93506020850135611b7281611a19565b92506040850135915060608501356001600160401b03811115611b9457600080fd5b611ba087828801611ad2565b91505092959194509250565b60008060408385031215611bbf57600080fd5b8235611bca81611a19565b915060208301356001600160401b03811115611be557600080fd5b611bf185828601611ad2565b9150509250929050565b600080600060608486031215611c1057600080fd5b8335611c1b81611a19565b9250602084013591506040840135611c3281611a19565b809150509250925092565b60006001600160401b03821115611c5657611c56611a41565b5060051b60200190565b600082601f830112611c7157600080fd5b81356020611c86611c8183611c3d565b611aa2565b8083825260208201915060208460051b870101935086841115611ca857600080fd5b602086015b84811015611cc45780358352918301918301611cad565b509695505050505050565b60008060408385031215611ce257600080fd5b82356001600160401b03811115611cf857600080fd5b611d0485828601611c60565b9250506020830135611d1581611a19565b809150509250929050565b600060208284031215611d3257600080fd5b5035919050565b6001600160a01b03929092168252602082015260400190565b6001600160a01b0391909116815260200190565b600060208284031215611d7857600080fd5b8135610d6d81611a19565b60005b83811015611d9e578181015183820152602001611d86565b50506000910152565b60008151808452611dbf816020860160208601611d83565b601f01601f19169290920160200192915050565b602081526000610d6d6020830184611da7565b60008060008060808587031215611dfc57600080fd5b84356001600160401b0380821115611e1357600080fd5b818701915087601f830112611e2757600080fd5b81356020611e37611c8183611c3d565b82815260059290921b8401810191818101908b841115611e5657600080fd5b948201945b83861015611e7d578535611e6e81611a19565b82529482019490820190611e5b565b98505088013592505080821115611e9357600080fd5b611e9f88838901611c60565b94506040870135915080821115611eb557600080fd5b50611ec287828801611c60565b925050611ed160608601611a31565b905092959194509250565b60008060408385031215611eef57600080fd5b823591506020830135611d1581611a19565b600060208284031215611f1357600080fd5b81356001600160401b03811115611f2957600080fd5b611f3584828501611c60565b949350505050565b600181811c90821680611f5157607f821691505b602082108103611f7157634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561034d576000816000526020600020601f850160051c81016020861015611fa05750805b601f850160051c820191505b8181101561192057828155600101611fac565b81516001600160401b03811115611fd857611fd8611a41565b611fec81611fe68454611f3d565b84611f77565b602080601f83116001811461202157600084156120095750858301515b600019600386901b1c1916600185901b178555611920565b600085815260208120601f198616915b8281101561205057888601518255948401946001909101908401612031565b508582101561206e5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60008251612090818460208701611d83565b9190910192915050565b80518015158114611a3c57600080fd5b6000602082840312156120bc57600080fd5b610d6d8261209a565b6001600160a01b0393841681526020810192909252909116604082015260600190565b634e487b7160e01b600052603260045260246000fd5b8051611a3c81611a19565b60006080828403121561211b57600080fd5b612123611a57565b90508151815260208201516020820152604082015160408201526060820151606082015292915050565b60006080828403121561215f57600080fd5b612167611a57565b9050815161217481611a19565b815260208201516002811061218857600080fd5b80602083015250604082015160408201526060820151606082015292915050565b6000604082840312156121bb57600080fd5b604051604081018181106001600160401b03821117156121dd576121dd611a41565b806040525080915082516121f081611a19565b8152602092830151920191909152919050565b60006080828403121561221557600080fd5b61221d611a57565b9050815161222a81611a19565b8082525060208201516020820152604082015160408201526060820151606082015292915050565b6000610280828403121561226557600080fd5b61226d611a7f565b8251815261227d602084016120fe565b602082015261228e604084016120fe565b6040820152606083015160608201526122a96080840161209a565b608082015260a083015160a08201526122c58460c08501612109565b60c08201526122d884610140850161214d565b60e08201526122eb846101c085016121a9565b6101008201526122ff846102008501612203565b6101208201529392505050565b6001600160a01b039384168152919092166020820152604081019190915260600190565b60008151808452602080850194506020840160005b8381101561236157815187529582019590820190600101612345565b509495945050505050565b60408152600061237f6040830185612330565b905060018060a01b03831660208301529392505050565b6000602082840312156123a857600080fd5b8151610d6d81611a19565b6000602082840312156123c557600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b8082028115828204841417610509576105096123cc565b80820180821115610509576105096123cc565b60a0808252865190820181905260009060209060c0840190828a01845b8281101561244e5781516001600160a01b031684529284019290840190600101612429565b50505083810360208501526124638189612330565b91505082810360408401526124788187612330565b6001600160a01b03861660608501528381036080850152905061249b8185612330565b98975050505050505050565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b039283168152911660208201526040019056fea264697066735822122028652835ab111f76a64a51e027f8cf353ec228d4605c77311b862b5655ebe5e864736f6c63430008170033a2646970667358221220567e6ad5b53fbfa433f4d6fb0a18fe447edbdc994cfd59225195429271ff01ae64736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "stateVariables": {
      "VERSION": {
        "details": "Should be incremented when contract changed"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "VERSION()": {
        "notice": "Version of the contract"
      },
      "deployRouter(address)": {
        "notice": "Deploy {PawnShopRouter} for the given {user}. Any user is allowed to have only one instance of deployed router. Address of the deployed router can be taken through {deployedRouter}"
      },
      "router(address)": {
        "notice": "Deployed instances of PawnShopRouter for the given users"
      }
    },
    "notice": "Factory to deploy personal instances of PawnShopRouter",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 63685,
        "contract": "contracts/marketplace/PawnShopRouterFactory.sol:PawnShopRouterFactory",
        "label": "router",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_address)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      }
    }
  }
}