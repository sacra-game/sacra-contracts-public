// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.23;

import "../interfaces/IController.sol";
import "../interfaces/IERC20.sol";
import "../openzeppelin/EnumerableMap.sol";
import "../proxy/Controllable.sol";
import "../relay/ERC2771Context.sol";
import "../openzeppelin/MerkleProof.sol";
import "../interfaces/IApplicationEvents.sol";

contract AirdropDistributor is Controllable, ERC2771Context {
  using EnumerableMap for EnumerableMap.UintToUintMap;
  using EnumerableSet for EnumerableSet.AddressSet;

  //region ------------------------ Constants
  /// @notice Version of the contract
  string public constant override VERSION = "1.0.1";
  //endregion ------------------------ Constants

  //region ------------------------ Members
  /// @notice List of roots of registered merkle trees: week => merkleRoot
  EnumerableMap.UintToUintMap internal _merkleRoots;
  address public airdropToken;

  /// @notice key = keccak256(abi.encode(week, merkleRoot))
  mapping(bytes32 key => mapping (address user => bool isClaimed)) internal _claimed;

  /// @notice List of allowed operators
  EnumerableSet.AddressSet internal _operators;
  //endregion ------------------------ Members

  //region ------------------------ Restrictions
  function onlyDeployerOrOperator(IController controller_) internal view {
    address sender = _msgSender();
    if (
      !controller_.isDeployer(sender)
      && !_operators.contains(sender)
      && sender != controller_.governance()
    ) revert IAppErrors.ErrorNotAllowedSender();
  }
  //endregion ------------------------ Restrictions

  //region ------------------------ Initialization
  function init(address controller_) external initializer {
    __Controllable_init(controller_);
  }
  //endregion ------------------------ Initialization

  //region ------------------------ View
  function merkleRootsLength() external view returns (uint) {
    return _merkleRoots.length();
  }

  function merkleRoot(uint index) external view returns (uint week, bytes32 _merkleRoot) {
    (uint key, uint value) = _merkleRoots.at(index);
    return (key, bytes32(value));
  }

  function allMerkleRoots() external view returns (uint[] memory week, bytes32[] memory merkleRoots) {
    uint len = _merkleRoots.length();
    week = new uint[](len);
    merkleRoots = new bytes32[](len);
    for (uint i; i < len; ++i) {
      (uint key, uint value) = _merkleRoots.at(i);
      (week[i], merkleRoots[i]) = (key, bytes32(value));
    }
  }

  /// @notice Try to verify using the merkle tree with the given {indexTree}
  function verify(bytes32[] memory proof, address user, uint256 amount, uint week) public view returns (bool) {
    return _verify(proof, user, amount,  bytes32(_merkleRoots.get(week)));
  }

  /// @dev It doesn't allow to return claimed value for removed tree until it's re-registered
  function claimed(uint week, address user) external view returns (bool) {
    (bool exist, uint value) = _merkleRoots.tryGet(week);
    return exist ? _claimed[_key(week, bytes32(value))][user] : false;
  }

  function allOperators() external view returns (address[] memory operators) {
    return _operators.values();
  }
  //endregion ------------------------ View

  //region ------------------------ Governance actions
  function setAirdropToken(address token_) external {
    onlyDeployerOrOperator(IController(controller()));

    airdropToken = token_;
    emit IApplicationEvents.AirdropDistributorSetToken(token_);
  }

  function addTree(uint week, bytes32 merkleRoot_) external {
    onlyDeployerOrOperator(IController(controller()));
    if (_merkleRoots.contains(week)) revert IAppErrors.AlreadyRegistered();

    _merkleRoots.set(week, uint(merkleRoot_));
    emit IApplicationEvents.AirdropDistributorAddTree(week, merkleRoot_);
  }

  function removeTree(uint week) external {
    onlyDeployerOrOperator(IController(controller()));
    if (!_merkleRoots.contains(week)) revert IAppErrors.NotInitialized();

    _merkleRoots.remove(week);
    // _claimed is not cleared - it can be used if the tree will be re-registered

    emit IApplicationEvents.AirdropDistributorRemoveTree(week);
  }

  function setOperator(address operator_, bool remove) external {
    onlyDeployerOrOperator(IController(controller()));

    if (remove) {
      _operators.remove(operator_);
    } else {
      _operators.add(operator_);
    }
    emit IApplicationEvents.SetOperator(operator_, remove);
  }
  //endregion ------------------------ Governance actions

  //region ------------------------ Main logic

  /// @notice The signer claims {amounts} for the given {weeks}
  /// @param proofs_ Merkle proofs generated by full tree
  /// @param receiver_ Transfer claimed amounts on the given address
  function claim(bytes32[][] memory proofs_, uint[] memory weeks_, uint[] memory amounts_, address receiver_) external {
    address user = _msgSender();
    address _airdropToken = airdropToken;

    uint len = proofs_.length;
    if (len != weeks_.length || len != amounts_.length) revert IAppErrors.LengthsMismatch();

    for (uint i; i < len; ++i) {
      (bool exist, uint _merkleRoot) = _merkleRoots.tryGet(weeks_[i]);
      if (!exist) revert IAppErrors.ZeroValue();

      if (!_verify(proofs_[i], user, amounts_[i], bytes32(_merkleRoot))) revert IAppErrors.InvalidProof();
      bytes32 key = _key(weeks_[i], bytes32(_merkleRoot));

      if (_claimed[key][user]) revert IAppErrors.AlreadyClaimed();
      _claimed[key][user] = true;

      IERC20(_airdropToken).transfer(receiver_, amounts_[i]);
    }

    emit IApplicationEvents.AirdropDistributorClaim(weeks_, amounts_, receiver_);
  }

  function salvage(address receiver_, address token_, uint amount_) external {
    onlyDeployerOrOperator(IController(controller()));

    IERC20(token_).transfer(receiver_, amount_);
    emit IApplicationEvents.Salvage(receiver_, token_, amount_);
  }

  //endregion ------------------------ Main logic

  //region ------------------------ Internal logic
  function _key(uint week, bytes32 merkleRoot_) internal pure returns (bytes32) {
    return keccak256(abi.encode(week, merkleRoot_));
  }

  function _verify(bytes32[] memory proof, address addr, uint256 amount, bytes32 merkleRoot_) internal pure returns (bool) {
    bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(addr, amount))));
    return MerkleProof.verify(proof, merkleRoot_, leaf);
  }
  //endregion ------------------------ Internal logic
}

