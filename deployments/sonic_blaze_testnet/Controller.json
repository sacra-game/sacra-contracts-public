{
  "address": "0x232cC35E4f68db73d7f361Fe1cFBD3b5B140e811",
  "abi": [
    {
      "inputs": [],
      "name": "ErrorNotAllowedSender",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ErrorNotDeployer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidInitialization",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "NotFutureGovernance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "NotGovernance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotInitializing",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAmount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Claimed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ts",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "block",
          "type": "uint256"
        }
      ],
      "name": "ContractInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "DungeonFactoryChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "GameObjectControllerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "GameTokenChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "GameTokenPriceChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "gauge",
          "type": "address"
        }
      ],
      "name": "GaugeChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "gov",
          "type": "address"
        }
      ],
      "name": "GovernanceAccepted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "GuildControllerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "HeroControllerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "version",
          "type": "uint64"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "ItemBoxControllerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "ItemControllerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "NotifyRewardAmount",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "newGov",
          "type": "address"
        }
      ],
      "name": "OfferGovernance",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "OracleChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "toBurn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "toTreasury",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "toGov",
          "type": "uint256"
        }
      ],
      "name": "Process",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "proxy",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "logic",
          "type": "address"
        }
      ],
      "name": "ProxyUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "PvpControllerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "ReinforcementControllerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "RevisionIncreased",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "RewardsPoolChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "StatControllerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "StoryControllerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "status",
          "type": "bool"
        }
      ],
      "name": "TokenStatusChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "TreasuryChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "myrdAmount",
          "type": "uint256"
        }
      ],
      "name": "UpdatePeriod",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "UserControllerChanged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CONTROLLABLE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DEPLOYER_ELIGIBILITY_PERIOD",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptGovernance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "eoa",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "remove",
          "type": "bool"
        }
      ],
      "name": "changeDeployer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "value",
          "type": "bool"
        }
      ],
      "name": "changePause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "status",
          "type": "bool"
        }
      ],
      "name": "changeTreasuryTokenStatus",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "claimToGovernance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "created",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "createdBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "dungeonFactory",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "futureGovernance",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gameObjectController",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gameToken",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gameTokenPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gauge",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getProcessDetails",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "toBurn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "toTreasury",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "toGov",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "toRewardsPool",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "governance",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "guildController",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "heroController",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "increaseRevision",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "governance_",
          "type": "address"
        }
      ],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isController",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "adr",
          "type": "address"
        }
      ],
      "name": "isDeployer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isGovernance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "itemBoxController",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "itemController",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newGov",
          "type": "address"
        }
      ],
      "name": "offerGovernance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "onPause",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "oracle",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "totalSupply",
          "type": "uint256"
        }
      ],
      "name": "percentToBurn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "previousImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        }
      ],
      "name": "process",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pvpController",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "reinforcementController",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "revision",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rewardsPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setDungeonFactory",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setGameObjectController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setGameToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "setGameTokenPrice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setGauge",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setGuildController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setHeroController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setItemBoxController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setItemController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setOracle",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setPvpController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setReinforcementController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setRewardsPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setStatController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setStoryController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setTreasury",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value",
          "type": "address"
        }
      ],
      "name": "setUserController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "statController",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "storyController",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "treasury",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "proxies",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "newLogic",
          "type": "address"
        }
      ],
      "name": "updateProxies",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "userController",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "validTreasuryTokens",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x8f880f8c59c44fa32c09b0370e5efe275f7598fc9cb96f42150eb40bd7a4741f",
  "receipt": {
    "to": null,
    "from": "0x2F5294b805f6c0b4B7942c88111d8fB3c0597051",
    "contractAddress": "0x232cC35E4f68db73d7f361Fe1cFBD3b5B140e811",
    "transactionIndex": 0,
    "gasUsed": "2809533",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000800000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000010000000000000000000000000000000000000000000000000000",
    "blockHash": "0x00213774ce9ce0455359c5a139092cd145f991ddbd75910e6c485d4c9845d6ca",
    "transactionHash": "0x8f880f8c59c44fa32c09b0370e5efe275f7598fc9cb96f42150eb40bd7a4741f",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 40675048,
        "transactionHash": "0x8f880f8c59c44fa32c09b0370e5efe275f7598fc9cb96f42150eb40bd7a4741f",
        "address": "0x232cC35E4f68db73d7f361Fe1cFBD3b5B140e811",
        "topics": [
          "0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 0,
        "blockHash": "0x00213774ce9ce0455359c5a139092cd145f991ddbd75910e6c485d4c9845d6ca"
      }
    ],
    "blockNumber": 40675048,
    "cumulativeGasUsed": "2809533",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "d0e7b78f844cf860ee0bc8ebf8c63b8d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ErrorNotAllowedSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ErrorNotDeployer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotFutureGovernance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotGovernance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"ContractInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"DungeonFactoryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"GameObjectControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"GameTokenChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"GameTokenPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"GaugeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gov\",\"type\":\"address\"}],\"name\":\"GovernanceAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"GuildControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"HeroControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"ItemBoxControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"ItemControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotifyRewardAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGov\",\"type\":\"address\"}],\"name\":\"OfferGovernance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"OracleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTreasury\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toGov\",\"type\":\"uint256\"}],\"name\":\"Process\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"logic\",\"type\":\"address\"}],\"name\":\"ProxyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"PvpControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"ReinforcementControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"RevisionIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"RewardsPoolChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"StatControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"StoryControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"TokenStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"TreasuryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"myrdAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatePeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"UserControllerChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTROLLABLE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPLOYER_ELIGIBILITY_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"eoa\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"remove\",\"type\":\"bool\"}],\"name\":\"changeDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"changePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"changeTreasuryTokenStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimToGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dungeonFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"futureGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameObjectController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getProcessDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"toBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTreasury\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toGov\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toRewardsPool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guildController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"heroController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"increaseRevision\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isDeployer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"itemBoxController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"itemController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGov\",\"type\":\"address\"}],\"name\":\"offerGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onPause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"percentToBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"process\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pvpController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinforcementController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setDungeonFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setGameObjectController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setGameToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setGameTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setGuildController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setHeroController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setItemBoxController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setItemController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setPvpController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setReinforcementController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setRewardsPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setStatController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setStoryController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setUserController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"statController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storyController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"proxies\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"newLogic\",\"type\":\"address\"}],\"name\":\"updateProxies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"validTreasuryTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidInitialization()\":[{\"details\":\"The contract is already initialized.\"}],\"NotInitializing()\":[{\"details\":\"The contract is not initializing.\"}]},\"events\":{\"Initialized(uint64)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"}},\"kind\":\"dev\",\"methods\":{\"created()\":{\"returns\":{\"_0\":\"Creation timestamp\"}},\"createdBlock()\":{\"returns\":{\"_0\":\"Creation block number\"}},\"increaseRevision(address)\":{\"details\":\"Revision should be increased on each contract upgrade\"},\"isController(address)\":{\"details\":\"Return true if given address is controller\"},\"previousImplementation()\":{\"details\":\"Previous logic implementation\"},\"process(address,uint256,address)\":{\"params\":{\"amount\":\"Assume that this amount is approved by {from} to this contract\"}},\"revision()\":{\"details\":\"Contract upgrade counter\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"CONTROLLABLE_VERSION()\":{\"notice\":\"Version of the contract\"},\"VERSION()\":{\"notice\":\"Version of the contract\"},\"controller()\":{\"notice\":\"Return controller address saved in the contract slot\"},\"created()\":{\"notice\":\"Return creation timestamp\"},\"createdBlock()\":{\"notice\":\"Return creation block number\"},\"isGovernance(address)\":{\"notice\":\"Return true if given address is setup as governance in Controller\"},\"process(address,uint256,address)\":{\"notice\":\"Transfer {amount} from {from}, divide it on three parts: to treasury, to governance, to burn User must approve given amount to the controller.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/Controller.sol\":\"Controller\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":50},\"remappings\":[]},\"sources\":{\"contracts/core/Controller.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n/**\\n            \\u2592\\u2593\\u2592  \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2593\\n             \\u2592\\u2588\\u2588\\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593  \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n              \\u2592\\u2588\\u2588\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592 \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n               \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592                   \\u2592\\u2588\\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                     \\u2592\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592     \\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                   \\u2592\\u2592\\u2592\\u2592\\u2592   \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                         \\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                       \\u2592\\u2588\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\n                        \\u2592\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592       \\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\n                          \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593   \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                           \\u2592\\u2592\\u2593\\u2593\\u2592   \\u2592\\u2588\\u2588\\u2593\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                  \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                                 \\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                                \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n      \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593                  \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                      \\u2592\\u2593\\u2593\\n    \\u2592\\u2593\\u2588\\u2592   \\u2592\\u2592\\u2588\\u2592\\u2592                   \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2592\\u2593\\u2593\\u2592\\n   \\u2592\\u2592\\u2588\\u2592       \\u2593\\u2592                    \\u2592\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2588\\u2593\\u2592\\n   \\u2593\\u2592\\u2588\\u2588\\u2593\\u2592                             \\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2592\\n    \\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2593\\u2592        \\u2592\\u2592\\u2592         \\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592\\u2592\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2592 \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n     \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2592\\u2592\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2593\\u2593     \\u2593\\u2593  \\u2593\\u2593\\u2588\\u2593   \\u2592\\u2592\\u2593\\u2593   \\u2592\\u2592\\u2588\\u2592   \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n            \\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592  \\u2592\\u2593\\u2593\\u2593\\u2592\\u2588\\u2592   \\u2592\\u2592\\u2592\\u2588\\u2592          \\u2592\\u2592\\u2588\\u2593\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592   \\u2593\\u2588\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\n \\u2592            \\u2592\\u2593\\u2593\\u2588\\u2593  \\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2593  \\u2592\\u2588\\u2593\\u2593\\u2592          \\u2593\\u2593\\u2588\\u2593\\u2592\\u2593\\u2588\\u2593\\u2592\\u2592   \\u2593\\u2588\\u2593        \\u2593\\u2588\\u2588\\u2588\\u2593\\n\\u2593\\u2593\\u2592         \\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592\\u2592\\u2593\\u2588\\u2592   \\u2592\\u2593\\u2588\\u2588\\u2593  \\u2593\\u2588\\u2588\\u2593\\u2592     \\u2592\\u2588\\u2593 \\u2593\\u2593\\u2588\\u2588   \\u2592\\u2593\\u2593\\u2593\\u2592\\u2592\\u2593\\u2588\\u2593        \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2592\\n \\u2588\\u2588\\u2593\\u2593\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592\\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592     \\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592\\n*/\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../proxy/Controllable.sol\\\";\\nimport \\\"../lib/ControllerLib.sol\\\";\\n\\ncontract Controller is Controllable, IController {\\n\\n  //region ------------------------ Constants\\n  /// @notice Version of the contract\\n  string public constant override VERSION = \\\"1.0.3\\\";\\n  uint public constant DEPLOYER_ELIGIBILITY_PERIOD = ControllerLib.DEPLOYER_ELIGIBILITY_PERIOD;\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Initializer\\n  function init(address governance_) external initializer {\\n    __Controllable_init(address(this));\\n    ControllerLib._S().governance = governance_;\\n  }\\n  //endregion ------------------------ Initializer\\n\\n  //region ------------------------ Views\\n\\n  function isDeployer(address adr) public view override returns (bool) {\\n    return ControllerLib.isDeployer(adr);\\n  }\\n\\n  function governance() external view override returns (address) {\\n    return ControllerLib.governance();\\n  }\\n\\n  function futureGovernance() external view returns (address) {\\n    return ControllerLib.futureGovernance();\\n  }\\n\\n  function statController() external view override returns (address) {\\n    return ControllerLib.statController();\\n  }\\n\\n  function storyController() external view override returns (address) {\\n    return ControllerLib.storyController();\\n  }\\n\\n  function oracle() external view override returns (address) {\\n    return ControllerLib.oracle();\\n  }\\n\\n  function treasury() external view override returns (address) {\\n    return ControllerLib.treasury();\\n  }\\n\\n  function dungeonFactory() external view override returns (address) {\\n    return ControllerLib.dungeonFactory();\\n  }\\n\\n  function gameObjectController() external view override returns (address) {\\n    return ControllerLib.gameObjectController();\\n  }\\n\\n  function reinforcementController() external view override returns (address) {\\n    return ControllerLib.reinforcementController();\\n  }\\n\\n  function itemController() external view override returns (address) {\\n    return ControllerLib.itemController();\\n  }\\n\\n  function heroController() external view override returns (address) {\\n    return ControllerLib.heroController();\\n  }\\n\\n  function gameToken() external view override returns (address) {\\n    return ControllerLib.gameToken();\\n  }\\n\\n  function validTreasuryTokens(address token) external view override returns (bool) {\\n    return ControllerLib.validTreasuryTokens(token);\\n  }\\n\\n  function onPause() external view override returns (bool) {\\n    return ControllerLib.onPause();\\n  }\\n\\n  function userController() external view override returns (address) {\\n    return ControllerLib.userController();\\n  }\\n\\n  function guildController() external view override returns (address) {\\n    return ControllerLib.guildController();\\n  }\\n\\n  function pvpController() external view override returns (address) {\\n    return ControllerLib.pvpController();\\n  }\\n\\n  function rewardsPool() external view override returns (address) {\\n    return ControllerLib.rewardsPool();\\n  }\\n\\n  function itemBoxController() external view override returns (address) {\\n    return ControllerLib.itemBoxController();\\n  }\\n\\n  function gameTokenPrice() external view override returns (uint) {\\n    return ControllerLib.gameTokenPrice();\\n  }\\n\\n  function gauge() external view returns (address) {\\n    return ControllerLib.gauge();\\n  }\\n  //endregion ------------------------ Views\\n\\n  //region ------------------------ Gov actions - setters\\n\\n  function changePause(bool value) external {\\n    ControllerLib.changePause(value);\\n  }\\n\\n  function offerGovernance(address newGov) external {\\n    ControllerLib.offerGovernance(newGov);\\n  }\\n\\n  function acceptGovernance() external {\\n    ControllerLib.acceptGovernance();\\n  }\\n\\n  function setStatController(address value) external {\\n    ControllerLib.setStatController(value);\\n  }\\n\\n  function setStoryController(address value) external {\\n    ControllerLib.setStoryController(value);\\n  }\\n\\n  function setGameObjectController(address value) external {\\n    ControllerLib.setGameObjectController(value);\\n  }\\n\\n  function setReinforcementController(address value) external {\\n    ControllerLib.setReinforcementController(value);\\n  }\\n\\n  function setOracle(address value) external {\\n    ControllerLib.setOracle(value);\\n  }\\n\\n  function setTreasury(address value) external {\\n    ControllerLib.setTreasury(value);\\n  }\\n\\n  function setItemController(address value) external {\\n    ControllerLib.setItemController(value);\\n  }\\n\\n  function setHeroController(address value) external {\\n    ControllerLib.setHeroController(value);\\n  }\\n\\n  function setGameToken(address value) external {\\n    ControllerLib.setGameToken(value);\\n  }\\n\\n  function setDungeonFactory(address value) external {\\n    ControllerLib.setDungeonFactory(value);\\n  }\\n\\n  function changeDeployer(address eoa, bool remove) external {\\n    ControllerLib.changeDeployer(eoa, remove);\\n  }\\n\\n  function setUserController(address value) external {\\n    ControllerLib.setUserController(value);\\n  }\\n\\n  function setGuildController(address value) external {\\n    ControllerLib.setGuildController(value);\\n  }\\n\\n  function setPvpController(address value) external {\\n    ControllerLib.setPvpController(value);\\n  }\\n\\n  function setRewardsPool(address value) external {\\n    ControllerLib.setRewardsPool(value);\\n  }\\n\\n  function setItemBoxController(address value) external {\\n    ControllerLib.setItemBoxController(value);\\n  }\\n\\n  function setGameTokenPrice(uint value) external {\\n    ControllerLib.setGameTokenPrice(value);\\n  }\\n\\n  function setGauge(address value) external {\\n    ControllerLib.setGauge(value);\\n  }\\n  //endregion ------------------------ Gov actions - setters\\n\\n  //region ------------------------ Gov actions - others\\n\\n  function updateProxies(address[] memory proxies, address newLogic) external {\\n    ControllerLib.updateProxies(proxies, newLogic);\\n  }\\n\\n  function claimToGovernance(address token) external {\\n    ControllerLib.claimToGovernance(token);\\n  }\\n  //endregion ------------------------ Gov actions - others\\n\\n  //region ------------------------ REGISTER ACTIONS\\n\\n  function changeTreasuryTokenStatus(address token, bool status) external {\\n    ControllerLib.changeTreasuryTokenStatus(token, status);\\n  }\\n  //endregion ------------------------ REGISTER ACTIONS\\n\\n  //region ------------------------ User actions\\n\\n  /// @notice Transfer {amount} from {from}, divide it on three parts: to treasury, to governance, to burn\\n  /// User must approve given amount to the controller.\\n  /// @param amount Assume that this amount is approved by {from} to this contract\\n  function process(address token, uint amount, address from) external {\\n    ControllerLib.process(IController(address(this)), token, amount, from);\\n  }\\n\\n  function percentToBurn(uint totalSupply) external pure returns (uint) {\\n    return ControllerLib.percentToBurn(totalSupply);\\n  }\\n\\n  function getProcessDetails(address token, uint amount) external view returns (uint toBurn, uint toTreasury, uint toGov, uint toRewardsPool) {\\n    (toBurn, toTreasury, toGov, toRewardsPool) = ControllerLib.getProcessDetails(token, amount, IController(address(this)).gameToken());\\n  }\\n  //endregion ------------------------ User actions\\n}\\n\",\"keccak256\":\"0xae9f964f7f9b08babe4e928f37741d22b6c2873784167dce4d4e089665304999\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IAppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @notice All errors of the app\\ninterface IAppErrors {\\n\\n  //region ERC20Errors\\n  /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n  error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n  /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n  error ERC20InvalidSender(address sender);\\n\\n  /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n  error ERC20InvalidReceiver(address receiver);\\n\\n  /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n  error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n  /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n  error ERC20InvalidApprover(address approver);\\n\\n  /**\\n   * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n  error ERC20InvalidSpender(address spender);\\n\\n  //endregion ERC20Errors\\n\\n  //region ERC721Errors\\n\\n  /**\\n  * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n  error ERC721InvalidOwner(address owner);\\n\\n  /**\\n   * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n  error ERC721NonexistentToken(uint256 tokenId);\\n\\n  /**\\n   * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n  error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n  /**\\n   * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n  error ERC721InvalidSender(address sender);\\n\\n  /**\\n   * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n  error ERC721InvalidReceiver(address receiver);\\n\\n  /**\\n   * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n  error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n  /**\\n   * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n  error ERC721InvalidApprover(address approver);\\n\\n  /**\\n   * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n  error ERC721InvalidOperator(address operator);\\n\\n  //endregion ERC721Errors\\n\\n  error ZeroAddress();\\n  error ZeroValueNotAllowed();\\n  error ZeroToken();\\n  error LengthsMismatch();\\n  error NotEnoughBalance();\\n  error NotEnoughAllowance();\\n  error EmptyNameNotAllowed();\\n  error NotInitialized();\\n  error AlreadyInitialized();\\n  error ReentrancyGuardReentrantCall();\\n  error TooLongString();\\n  error AlreadyDeployed(address deployed);\\n  error AlreadyClaimed();\\n\\n  //region Restrictions\\n  error ErrorNotDeployer(address sender);\\n  error ErrorNotGoc();\\n  error NotGovernance(address sender);\\n  error ErrorOnlyEoa();\\n  error NotEOA(address sender);\\n  error ErrorForbidden(address sender);\\n  error AdminOnly();\\n  error ErrorNotItemController(address sender);\\n  error ErrorNotHeroController(address sender);\\n  error ErrorNotDungeonFactory(address sender);\\n  error ErrorNotObjectController(address sender);\\n  error ErrorNotStoryController();\\n  error ErrorNotAllowedSender();\\n  error MintNotAllowed();\\n  error NotPvpController();\\n  //endregion Restrictions\\n\\n  //region PackingLib\\n  error TooHighValue(uint value);\\n  error IntValueOutOfRange(int value);\\n  error OutOfBounds(uint index, uint length);\\n  error UnexpectedValue(uint expected, uint actual);\\n  error WrongValue(uint newValue, uint actual);\\n  error IntOutOfRange(int value);\\n  error ZeroValue();\\n  /// @notice packCustomDataChange requires an input string with two zero bytes at the beginning\\n  ///         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// This error happens if these bytes are not zero\\n  error IncompatibleInputString();\\n  error IncorrectOtherItemTypeKind(uint8 kind);\\n  //endregion PackingLib\\n\\n  //region Hero\\n  error ErrorHeroIsNotRegistered(address heroToken);\\n  error ErrorHeroIsDead(address heroToken, uint heroTokenId);\\n  error ErrorHeroNotInDungeon();\\n  error HeroInDungeon();\\n  error ErrorNotOwner(address token, uint tokenId);\\n  error ErrorNotOwnerOrHero(address token, uint tokenId);\\n  error Staked(address heroToken, uint heroId);\\n  error NameTaken();\\n  error TooBigName();\\n  error WrongSymbolsInTheName();\\n  error NoPayToken(address token, uint payTokenAmount);\\n  error AlreadyHaveReinforcement();\\n  /// @notice SIP-001 - Reinforcement requires 3 skills\\n  error ErrorReinforcementRequiresThreeSkills();\\n  error WrongTier(uint tier);\\n  error NotEnoughNgLevel(uint8 ngLevel);\\n  error NgpNotActive(address hero);\\n  error RebornNotAllowed();\\n  error AlreadyPrePaidHero();\\n\\n  error TierForbidden();\\n  error SandboxPrepaidOnly();\\n  error SandboxNgZeroOnly();\\n  error SandboxModeNotAllowed();\\n  error SandboxUpgradeModeRequired();\\n  error SandboxModeRequired();\\n  error SandboxItemOutside();\\n  error SandboxItemNotActive();\\n  error SandboxItemNotRegistered();\\n  error SandboxItemAlreadyEquipped();\\n  error SandboxDifferentHeroesNotAllowed();\\n  error HeroWasTransferredBetweenAccounts();\\n  error SandboxFreeHeroNotAllowed();\\n  //endregion Hero\\n\\n  //region Dungeon\\n  error ErrorDungeonIsFreeAlready();\\n  error ErrorNoEligibleDungeons();\\n  error ErrorDungeonBusy();\\n  error ErrorNoDungeonsForBiome(uint8 heroBiome);\\n  error ErrorDungeonCompleted();\\n  error ErrorAlreadyInDungeon();\\n  error NotEnoughTokens(uint balance, uint expectedBalance);\\n  error DungeonAlreadySpecific(uint16 dungNum);\\n  error DungeonAlreadySpecific2(uint16 dungNum);\\n  error WrongSpecificDungeon();\\n  error LastLifeChance();\\n  //endregion Dungeon\\n\\n  //region Items\\n  error ErrorItemNotEligibleForTheSlot(uint itemType, uint8 itemSlot);\\n  error ErrorItemSlotBusyHand(uint8 slot);\\n  error ErrorItemSlotBusy();\\n  error ErrorItemNotInSlot();\\n  error ErrorConsumableItemIsUsed(address item);\\n  error ErrorCannotRemoveItemFromMap();\\n  error ErrorCannotRemoveDataFromMap();\\n  error EquippedItemsExist();\\n  error ItemEquipped(address item, uint itemId);\\n  error ZeroItemMetaType();\\n  error NotZeroOtherItemMetaType();\\n  error ZeroLevel();\\n  error ItemTypeChanged();\\n  error ItemMetaTypeChanged();\\n  error UnknownItem(address item);\\n  error ErrorEquipForbidden();\\n  error EquipForbiddenInDungeon();\\n  error TakeOffForbiddenInDungeon();\\n  error Consumable(address item);\\n  error NotConsumable(address item);\\n  error Broken(address item);\\n  error ZeroLife();\\n  error RequirementsToItemAttributes();\\n  error NotEquipped(address item);\\n  error ZeroDurability();\\n  error ZeroAugmentation();\\n  error TooHighAgLevel(uint8 augmentationLevel);\\n  error UseForbiddenZeroPayToken();\\n  error IncorrectMinMaxAttributeRange(int32 min, int32 max);\\n  error SameIdsNotAllowed();\\n  error ZeroFragility();\\n  error OtherTypeItemNotRepairable();\\n  error NotOther();\\n  error DoubleItemUsageForbidden(uint itemIndex, address[] items);\\n  error ItemAlreadyUsedInSlot(address item, uint8 equippedSlot);\\n  error WrongWayToRegisterItem();\\n  error UnionItemNotFound(address item);\\n  error WrongListUnionItemTokens(address item, uint countTokens, uint requiredCountTokens);\\n  error UnknownUnionConfig(uint unionConfigId);\\n  error UserHasNoKeyPass(address user, address keyPassItem);\\n  error MaxValue(uint value);\\n  error UnexpectedOtherItem(address item);\\n  error NotExist();\\n  error ItemNotFound(address item, uint itemId);\\n  error NoFirstAugmentationInfo();\\n  error NotAugmentationProtectiveItem(address item);\\n  //endregion Items\\n\\n  //region Stages\\n  error ErrorWrongStage(uint stage);\\n  error ErrorNotStages();\\n  //endregion Stages\\n\\n  //region Level\\n  error ErrorWrongLevel(uint heroLevel);\\n  error ErrorLevelTooLow(uint heroLevel);\\n  error ErrorHeroLevelStartFrom1();\\n  error ErrorWrongLevelUpSum();\\n  error ErrorMaxLevel();\\n  //endregion Level\\n\\n  //region Treasure\\n  error ErrorNotValidTreasureToken(address treasureToken);\\n  //endregion Treasure\\n\\n  //region State\\n  error ErrorPaused();\\n  error ErrorNotReady();\\n  error ErrorNotObject1();\\n  error ErrorNotObject2();\\n  error ErrorNotCompleted();\\n  //endregion State\\n\\n  //region Biome\\n  error ErrorNotBiome();\\n  error ErrorIncorrectBiome(uint biome);\\n  error TooHighBiome(uint biome);\\n  //endregion Biome\\n\\n  //region Misc\\n  error ErrorWrongMultiplier(uint multiplier);\\n  error ErrorNotEnoughMana(uint32 mana, uint requiredMana);\\n  error ErrorExperienceMustNotDecrease();\\n  error ErrorNotEnoughExperience();\\n  error ErrorNotChances();\\n  error ErrorNotEligible(address heroToken, uint16 dungNum);\\n  error ErrorZeroKarmaNotAllowed();\\n  //endregion Misc\\n\\n  //region GOC\\n  error GenObjectIdBiomeOverflow(uint8 biome);\\n  error GenObjectIdSubTypeOverflow(uint subType);\\n  error GenObjectIdIdOverflow(uint id);\\n  error UnknownObjectTypeGoc1(uint8 objectType);\\n  error UnknownObjectTypeGoc2(uint8 objectType);\\n  error UnknownObjectTypeGocLib1(uint8 objectType);\\n  error UnknownObjectTypeGocLib2(uint8 objectType);\\n  error UnknownObjectTypeForSubtype(uint8 objectSubType);\\n  error FightDelay();\\n  error ZeroChance();\\n  error TooHighChance(uint32 chance);\\n  error TooHighRandom(uint random);\\n  error EmptyObjects();\\n  error ObjectNotFound();\\n  error WrongGetObjectTypeInput();\\n  error WrongChances(uint32 chances, uint32 maxChances);\\n  //endregion GOC\\n\\n  //region Story\\n  error PageNotRemovedError(uint pageId);\\n  error NotItem1();\\n  error NotItem2();\\n  error NotRandom(uint32 random);\\n  error NotHeroData();\\n  error NotGlobalData();\\n  error ZeroStoryIdRemoveStory();\\n  error ZeroStoryIdStoryAction();\\n  error ZeroStoryIdAction();\\n  error NotEnoughAmount(uint balance, uint requiredAmount);\\n  error NotAnswer();\\n  error AnswerStoryIdMismatch(uint16 storyId, uint16 storyIdFromAnswerHash);\\n  error AnswerPageIdMismatch(uint16 pageId, uint16 pageIdFromAnswerHash);\\n  error NotSkippableStory();\\n  error StoryNotPassed();\\n  error SkippingNotAllowed();\\n  //endregion Story\\n\\n  //region FightLib\\n  error NotMagic();\\n  error NotAType(uint atype);\\n  //endregion FightLib\\n\\n  //region MonsterLib\\n  error NotYourDebuffItem();\\n  error UnknownAttackType(uint attackType);\\n  error NotYourAttackItem();\\n  /// @notice The skill item cannot be used because it doesn't belong either to the hero or to the hero's helper\\n  error NotYourBuffItem();\\n  //endregion MonsterLib\\n\\n  //region GameToken\\n  error ApproveToZeroAddress();\\n  error MintToZeroAddress();\\n  error TransferToZeroAddress();\\n  error TransferAmountExceedsBalance(uint balance, uint value);\\n  error InsufficientAllowance();\\n  error BurnAmountExceedsBalance();\\n  error NotMinter(address sender);\\n  //endregion GameToken\\n\\n  //region NFT\\n  error TokenTransferNotAllowed();\\n  error IdOverflow(uint id);\\n  error NotExistToken(uint tokenId);\\n  error EquippedItemIsNotAllowedToTransfer(uint tokenId);\\n  //endregion NFT\\n\\n  //region CalcLib\\n  error TooLowX(uint x);\\n  //endregion CalcLib\\n\\n  //region Controller\\n  error NotFutureGovernance(address sender);\\n  //endregion Controller\\n\\n  //region Oracle\\n  error OracleWrongInput();\\n  //endregion Oracle\\n\\n  //region ReinforcementController\\n  error AlreadyStaked();\\n  error MaxFee(uint8 fee);\\n  error MinFee(uint8 fee);\\n  error StakeHeroNotStats();\\n  error NotStaked();\\n  error NoStakedHeroes();\\n  error GuildHelperNotAvailable(uint guildId, address helper, uint helperId);\\n  error PvpStaked();\\n  error HelperNotAvailableInGivenBiome();\\n  //endregion ReinforcementController\\n\\n  //region SponsoredHero\\n  error InvalidHeroClass();\\n  error ZeroAmount();\\n  error InvalidProof();\\n  error NoHeroesAvailable();\\n  error AlreadyRegistered();\\n  //endregion SponsoredHero\\n\\n  //region SacraRelay\\n  error SacraRelayNotOwner();\\n  error SacraRelayNotDelegator();\\n  error SacraRelayNotOperator();\\n  error SacraRelayInvalidChainId(uint callChainId, uint blockChainId);\\n  error SacraRelayInvalidNonce(uint callNonce, uint txNonce);\\n  error SacraRelayDeadline();\\n  error SacraRelayDelegationExpired();\\n  error SacraRelayNotAllowed();\\n  error SacraRelayInvalidSignature();\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error by selector, see tests\\n  error SacraRelayNoErrorSelector(bytes4 selector, string tracingInfo);\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error manually from {errorBytes} as following:\\n  /// if (keccak256(abi.encodeWithSignature(\\\"MyError()\\\")) == keccak256(errorBytes)) { ... }\\n  error SacraRelayUnexpectedReturnData(bytes errorBytes, string tracingInfo);\\n  error SacraRelayCallToNotContract(address notContract, string tracingInfo);\\n  //endregion SacraRelay\\n\\n  //region Misc\\n  error UnknownHeroClass(uint heroClass);\\n  error AbsDiff(int32 a, int32 b);\\n  //endregion Misc\\n\\n  //region ------------------------ UserController\\n  error NoAvailableLootBox(address msgSender, uint lootBoxKind);\\n  error FameHallHeroAlreadyRegistered(uint8 openedNgLevel);\\n\\n  //endregion ------------------------ UserController\\n\\n  //region ------------------------ Guilds\\n  error AlreadyGuildMember();\\n  error NotGuildMember();\\n  error WrongGuild();\\n  error GuildActionForbidden(uint right);\\n  error GuildHasMaxSize(uint guildSize);\\n  error GuildHasMaxLevel(uint level);\\n  error TooLongUrl();\\n  error TooLongDescription();\\n  error CannotRemoveGuildOwnerFromNotEmptyGuild();\\n  error GuildControllerOnly();\\n  error GuildAlreadyHasShelter();\\n  error ShelterIsBusy();\\n  error ShelterIsNotRegistered();\\n  error ShelterIsNotOwnedByTheGuild();\\n  error ShelterIsInUse();\\n  error GuildHasNoShelter();\\n  error ShelterBidIsNotAllowedToBeUsed();\\n  error ShelterHasHeroesInside();\\n  error SecondGuildAdminIsNotAllowed();\\n  error NotEnoughGuildBankBalance(uint guildId);\\n\\n  error GuildReinforcementCooldownPeriod();\\n  error NoStakedGuildHeroes();\\n  error NotStakedInGuild();\\n  error ShelterHasNotEnoughLevelForReinforcement();\\n  error NotBusyGuildHelper();\\n  error TooLowGuildLevel();\\n\\n  /// @notice Target biome can be selected only once per epoch\\n  error BiomeAlreadySelected();\\n  error NoDominationRequest();\\n  error PvpFightIsNotPrepared(uint8 biome, uint32 week, address user);\\n  error PvpFightIsCompleted(uint8 biome, uint32 week, address user);\\n  error TooLowMaxCountTurns();\\n  error UserTokensVaultAlreadySet();\\n\\n  error DifferentBiomeInPvpFight();\\n  error PvpFightOpponentNotFound();\\n  error PvpHeroHasInitializedFight();\\n  error PvpHeroNotRegistered();\\n\\n  /// @notice User should unregister pvp-hero from prev biome and only then register it in the new biome\\n  error UserHasRegisteredPvpHeroInBiome(uint8 biome);\\n  error UserHasRegisteredPvpHero();\\n  error UserNotAllowedForPvpInCurrentEpoch(uint week);\\n\\n  error UnknownPvpStrategy();\\n\\n  error GuildRequestNotActive();\\n  error GuildRequestNotAvailable();\\n  error NotAdminCannotAddMemberWithNotZeroRights();\\n  //endregion ------------------------ Guilds\\n\\n  //region ------------------------ Shelters\\n  error ErrorNotShelterController();\\n  error ErrorNotGuildController();\\n  error ShelterHasNotItem(uint shelterId, address item);\\n  error MaxNumberItemsSoldToday(uint numSoldItems, uint limit);\\n  error GuildHasNotEnoughPvpPoints(uint64 pointsAvailable, uint pointRequired);\\n  error FreeShelterItemsAreNotAllowed(uint shelterId, address item);\\n  error TooLowShelterLevel(uint8 shelterLevel, uint8 allowedShelterLevel);\\n  error NotEnoughPvpPointsCapacity(address user, uint usedPoints, uint pricePvpPoints, uint64 capactiy);\\n  error IncorrectShelterLevel(uint8 shelterLevel);\\n  //endregion ------------------------ Shelters\\n\\n  //region ------------------------ Auction\\n  error WrongAuctionPosition();\\n  error AuctionPositionClosed();\\n  error AuctionBidOpened(uint positionId);\\n  error TooLowAmountToBid();\\n  error AuctionEnded();\\n  error TooLowAmountForNewBid();\\n  error AuctionSellerOnly();\\n  error AuctionBuyerOnly();\\n  error AuctionBidNotFound();\\n  error AuctionBidClosed();\\n  error OnlyShelterAuction();\\n  error CannotCloseLastBid();\\n  error AuctionNotEnded();\\n  error NotShelterAuction();\\n  error AuctionPositionOpened(uint positionId);\\n  error AuctionSellerCannotBid();\\n  error AuctionGuildWithShelterCannotBid();\\n  error AuctionBidExists();\\n  //endregion ------------------------ Auction\\n\\n  //region ------------------------ Pawnshop\\n  error AuctionPositionNotSupported(uint positionId);\\n  error PositionNotSupported(uint positionId);\\n  error NotNftPositionNotSupported(uint positionId);\\n  error CallFailed(bytes callResultData);\\n\\n  error PawnShopZeroOwner();\\n  error PawnShopZeroFeeRecipient();\\n  error PawnShopNotOwner();\\n  error PawnShopAlreadyAnnounced();\\n  error PawnShopTimeLock();\\n  error PawnShopWrongAddressValue();\\n  error PawnShopWrongUintValue();\\n  error PawnShopZeroAddress();\\n  error PawnShopTooHighValue();\\n  error PawnShopZeroAToken();\\n  error PawnShopZeroCToken();\\n  error PawnShopWrongAmounts();\\n  error PawnShopPosFeeForInstantDealForbidden();\\n  error PawnShopPosFeeAbsurdlyHigh();\\n  error PawnShopIncorrect();\\n  error PawnShopWrongId();\\n  error PawnShopNotBorrower();\\n  error PawnShopPositionClosed();\\n  error PawnShopPositionExecuted();\\n  error PawnShopWrongBidAmount();\\n  error PawnShopTooLowBid();\\n  error PawnShopNewBidTooLow();\\n  error PawnShopBidAlreadyExists();\\n  error PawnShopAuctionEnded();\\n  error PawnShopNotLender();\\n  error PawnShopTooEarlyToClaim();\\n  error PawnShopPositionNotExecuted();\\n  error PawnShopAlreadyClaimed();\\n  error PawnShopAuctionNotEnded();\\n  error PawnShopBidClosed();\\n  error PawnShopNoBids();\\n  error PawnShopAuctionBidNotFound();\\n  error PawnShopWrongBid();\\n  error PawnShopBidNotFound();\\n\\n  //endregion ------------------------ Pawnshop\\n}\\n\\n\",\"keccak256\":\"0x1499e2f247c89c1f29defd7858180276e37d5b2e2140a5e80e69d2ae95f2d7f8\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IApplicationEvents.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IDungeonFactory.sol\\\";\\nimport \\\"./IStoryController.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\nimport \\\"./IPvpController.sol\\\";\\n\\n/// @notice All events of the app\\ninterface IApplicationEvents {\\n\\n  //region ------------------------ Common\\n  event SetOperator(address operator, bool remove);\\n  event Salvage(address receiver, address token, uint amount);\\n  //endregion ------------------------ Common\\n\\n\\n  //region ------------------ StatController\\n  event HeroItemSlotChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint itemType,\\n    uint itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip,\\n    address caller\\n  );\\n  event CurrentStatsChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats change,\\n    bool increase,\\n    address caller\\n  );\\n  event BonusAttributesChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    bool add,\\n    bool temporally,\\n    address caller\\n  );\\n  event TemporallyAttributesCleared(address heroToken, uint heroTokenId, address caller);\\n  event NewHeroInited(address heroToken, uint heroTokenId, IStatController.ChangeableStats stats);\\n  event LevelUp(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes change\\n  );\\n  event ConsumableUsed(address heroToken, uint heroTokenId, address item);\\n  event RemoveConsumableUsage(address heroToken, uint heroTokenId, address item);\\n  event HeroCustomDataChanged(address token, uint tokenId, bytes32 index, uint value);\\n  event HeroCustomDataChangedNg(address token, uint tokenId, bytes32 index, uint value, uint8 ngLevel);\\n  event HeroCustomDataCleared(address token, uint tokenId);\\n  event GlobalCustomDataChanged(bytes32 index, uint value);\\n  //endregion ------------------ StatController\\n\\n  //region ------------------ DungeonFactoryController\\n  event DungeonLaunched(\\n    uint16 dungeonLogicNum,\\n    uint64 dungeonId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken,\\n    uint treasuryAmount\\n  );\\n\\n  event BossCompleted(uint32 objectId, uint biome, address hero, uint heroId);\\n  event FreeDungeonAdded(uint8 biome, uint64 dungeonId);\\n\\n  event ObjectOpened(uint64 dungId, address hero, uint id, uint32 objId, uint iteration, uint currentStage);\\n  event Clear(uint64 dungId);\\n\\n  event DungeonLogicRegistered(uint16 dungLogicId, IDungeonFactory.DungeonGenerateInfo info);\\n  event DungeonLogicRemoved(uint16 dungLogicId);\\n  event DungeonSpecificLogicRegistered(uint16 dungLogicId, uint biome, uint heroCls);\\n  event DungeonSpecificLogicRemoved(uint16 dungLogicId, uint heroLvl, uint heroCls);\\n  event DungeonRegistered(uint16 dungLogicId, uint64 dungeonId);\\n  event DungeonRemoved(uint16 dungLogicId, uint64 dungeonId);\\n  event MinLevelForTreasuryChanged(address token, uint level);\\n\\n  event ObjectAction(\\n    uint64 dungId,\\n    IGOC.ActionResultEvent result,\\n    uint currentStage,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint newStage\\n  );\\n  /// @notice On add the item to the dungeon\\n  event AddTreasuryItem(uint64 dungId, address itemAdr, uint itemId);\\n  event AddTreasuryToken(uint64 dungId, address token, uint amount);\\n  event ClaimToken(uint64 dungId, address token, uint amount);\\n  event ClaimItem(uint64 dungId, address token, uint id);\\n\\n  event Entered(uint64 dungId, address hero, uint id);\\n  event DungeonCompleted(uint16 dungLogicNum, uint64 dungId, address hero, uint heroId);\\n  event Exit(uint64 dungId, bool claim);\\n  event ExitForcibly(uint64 dungId, address hero, uint heroId);\\n  event FreeDungeonRemoved(uint8 biome, uint64 dungeonId);\\n  event HeroCurrentDungeonChanged(address hero, uint heroId, uint64 dungeonId);\\n  //endregion ------------------ DungeonFactoryController\\n\\n  //region ------------------ GameObjectController\\n  event EventRegistered(uint32 objectId, IGOC.EventRegInfo eventRegInfo);\\n  event StoryRegistered(uint32 objectId, uint16 storyId);\\n  event MonsterRegistered(uint32 objectId, IGOC.MonsterGenInfo monsterGenInfo);\\n  event ObjectRemoved(uint32 objectId);\\n  event ObjectResultEvent(\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    IGOC.ObjectType objectType,\\n    address hero,\\n    uint heroId,\\n    uint8 stageId,\\n    uint iteration,\\n    bytes data,\\n    IGOC.ActionResultEvent result,\\n    uint salt\\n  );\\n  //endregion ------------------ GameObjectController\\n\\n  //region ------------------ StoryController\\n  event SetBurnItemsMeta(uint storyId, IStoryController.AnswerBurnRandomItemMeta meta);\\n  event SetNextObjRewriteMeta(uint storyId, IStoryController.NextObjRewriteMeta meta);\\n  event SetAnswersMeta(uint storyId, uint16[] answerPageIds, uint8[] answerHeroClasses, uint16[] answerIds);\\n  event SetAnswerNextPageMeta(uint storyId, IStoryController.AnswerNextPageMeta meta);\\n  event SetAnswerAttributeRequirements(uint storyId, IStoryController.AnswerAttributeRequirementsMeta meta);\\n  event SetAnswerItemRequirements(uint storyId, IStoryController.AnswerItemRequirementsMeta meta);\\n  event SetAnswerTokenRequirementsMeta(uint storyId, IStoryController.AnswerTokenRequirementsMeta meta);\\n  event SetAnswerAttributes(uint storyId, IStoryController.AnswerAttributesMeta meta);\\n  event SetAnswerHeroCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetAnswerGlobalCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetSuccessInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetFailInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetCustomDataResult(uint storyId, IStoryController.AnswerCustomDataResultMeta meta, IStoryController.CustomDataResult _type);\\n  event StoryCustomDataRequirements(uint storyId, bytes32 requiredCustomDataIndex, uint requiredCustomDataMinValue, uint requiredCustomDataMaxValue, bool requiredCustomDataIsHero);\\n  event StoryRequiredLevel(uint storyId, uint requiredLevel);\\n  event StoryFinalized(uint32 objectId, uint storyId);\\n  event StoryRemoved(uint32 objectId, uint storyId);\\n\\n  event ItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  /// @notice Durability of the item was reduced to 0\\n  event ItemBroken(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n\\n  event NotEquippedItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event StoryChangeAttributes(\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    uint stageId,\\n    uint iteration,\\n    int32[] attributes\\n  );\\n  //endregion ------------------ StoryController\\n\\n  //region ------------------------ HeroController\\n  event HeroRegistered(address hero, uint8 heroClass, address payToken, uint payAmount);\\n  /// @notice Deprecated, replaced by {HeroCreatedNgpSandbox}. Don't remove - it's required by subgraph\\n  event HeroCreatedNgp(address hero, uint heroId, string name, address owner, string refCode, uint8 tier, uint8 ngLevel);\\n  event HeroCreatedNgpSandbox(address hero, uint heroId, string name, address owner, string refCode, uint8 tier, uint8 ngLevel, bool sandbox);\\n  event FreeHeroCreated(address hero, uint heroId);\\n\\n  event BiomeChanged(address hero, uint heroId, uint8 biome);\\n  event LevelUp(address hero, uint heroId, address owner, IStatController.CoreAttributes change);\\n  event ReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event GuildReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event OtherItemGuildReinforcement(address item, uint itemId, address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event ReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event GuildReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event Killed(address hero, uint heroId, address killer, bytes32[] dropItems, uint dropTokenAmount);\\n  event Reborn(address hero, uint heroId, uint8 newNgLevel);\\n  event BossKilled(address account, address hero, uint heroId, uint8 biome, uint8 newNgLevel, bool reborn, uint rewardAmount);\\n  event TierSetup(uint8 tier, address hero, uint72 payAmount, uint8[] slots, address[][] items);\\n  event SandboxUpgraded(address hero, uint heroId);\\n  event SandboxReturnAmountToTreasury(uint64 dungId, address token, uint amount);\\n  //endregion ------------------------ HeroController\\n\\n  //region ------------------------ FightLib\\n  event FightResultProcessed(\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    IFightCalculator.FightCall callData,\\n    uint iteration\\n  );\\n  /// @param heroA Address of the fighter A.  Address of the fighter B can be detected by fightId\\n  /// @param heroIdA ID of the figher A. ID of the fighter B can be detected by fightId\\n  event PvpFightResultProcessed(\\n    uint48 fightId,\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    uint turn,\\n    address heroA,\\n    uint heroIdA\\n  );\\n  //endregion ------------------------ FightLib\\n\\n  //region ------------------------ Oracle\\n  event Random(uint number, uint max);\\n  //endregion ------------------------ Oracle\\n\\n  //region ------------------------ Controller\\n  event OfferGovernance(address newGov);\\n  event GovernanceAccepted(address gov);\\n  event StatControllerChanged(address value);\\n  event StoryControllerChanged(address value);\\n  event GameObjectControllerChanged(address value);\\n  event ReinforcementControllerChanged(address value);\\n  event OracleChanged(address value);\\n  event TreasuryChanged(address value);\\n  event ItemControllerChanged(address value);\\n  event HeroControllerChanged(address value);\\n  event GameTokenChanged(address value);\\n  event DungeonFactoryChanged(address value);\\n  event ProxyUpdated(address proxy, address logic);\\n  event Claimed(address token, uint amount);\\n  event TokenStatusChanged(address token, bool status);\\n  event UserControllerChanged(address value);\\n  event GuildControllerChanged(address value);\\n\\n  event PvpControllerChanged(address value);\\n\\n  event GameTokenPriceChanged(uint value);\\n  event RewardsPoolChanged(address value);\\n  event ItemBoxControllerChanged(address value);\\n  event Process(address token, uint amount, address from, uint toBurn, uint toTreasury, uint toGov);\\n  event GaugeChanged(address gauge);\\n  event NotifyRewardAmount(address token, uint amount);\\n  event UpdatePeriod(uint myrdAmount);\\n  //endregion ------------------------ Controller\\n\\n\\n  //region ------------------------ ReinforcementController\\n  event HeroStaked(address heroToken, uint heroId, uint biome, uint score);\\n  event HeroStakedV2(address heroToken, uint heroId, uint biome, uint rewardAmount);\\n  event HeroWithdraw(address heroToken, uint heroId);\\n  event HeroAsk(address heroToken, uint heroId);\\n  event HeroAskV2(address heroToken, uint heroId, uint hitsLast24h, uint fixedFee, uint helperRewardAmount);\\n  event TokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint totalAmount);\\n  event GuildTokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint guildId, uint64 dungeonId);\\n  event NftRewardRegistered(address heroToken, uint heroId, address token, uint id);\\n  event GuildNftRewardRegistered(address heroToken, uint heroId, address token, uint id, uint guildId, uint64 dungeonId);\\n  event ToHelperRatioChanged(uint value);\\n  event ClaimedToken(address heroToken, uint heroId, address token, uint amount, address recipient);\\n  event ClaimedItem(address heroToken, uint heroId, address item, uint itemId, address recipient);\\n  event MinLevelChanged(uint8 value);\\n  event MinLifeChancesChanged(uint value);\\n  //endregion ------------------------ ReinforcementController\\n\\n  //region ------------------------ Treasury, reward pool\\n  event AssetsSentToDungeon(address dungeon, address token, uint amount);\\n  event RewardSentToUser(address receiver, address token, uint rewardAmount);\\n  event NotEnoughReward(address receiver, address token, uint rewardAmountToPay);\\n  event BaseAmountChanged(uint oldValue, uint newValue);\\n  //endregion ------------------------ Treasury, reward pool\\n\\n  //region ------------------------ EventLib\\n  event EventResult(uint64 dungeonId, address heroToken, uint heroTokenId, uint8 stageId, IStatController.EventActionInfo gen, uint iteration);\\n  //endregion ------------------------ EventLib\\n\\n  //region ------------------------ Item controller and helper contracts\\n  event ItemRegistered(address item, IItemController.RegisterItemParams info);\\n  event OtherItemRegistered(address item, IItemController.ItemMeta meta, bytes packedItemMetaData);\\n  event ItemRemoved(address item);\\n  event OtherItemRemoved(address item);\\n  event NewItemMinted(address item, uint itemId, IItemController.MintInfo info);\\n  event Equipped(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot);\\n  event TakenOff(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot, address destination);\\n  event ItemRepaired(address item, uint itemId, uint consumedItemId, uint16 baseDurability);\\n  event FailedToRepairItem(address item, uint itemId, uint consumedItemId, uint16 itemDurability);\\n  event Augmented(address item, uint itemId, uint consumedItemId, uint8 augLevel, IItemController.AugmentInfo info);\\n  event ResetAugmentation(address item, uint itemId, uint consumedItemId, IItemController.AugmentInfo info);\\n  event NotAugmented(address item, uint itemId, uint consumedItemId, uint8 augLevel);\\n  event ReduceDurability(address item, uint itemId, uint newDurability);\\n  event Used(address item, uint tokenId, address heroToken, uint heroTokenId);\\n  event Destroyed(address item, uint itemId);\\n  event FragilityReduced(address item, uint itemId, address consumedItem, uint consumedItemId, uint fragility);\\n  event ItemControllerHelper(address helper);\\n  event SetUnionConfig(uint configId, address[] items, uint[] count, address itemToMint);\\n  event RemoveUnionConfig(uint configId);\\n  event SetUnionKeyPass(address keyPassItem);\\n  event SetAugmentationProtectiveItem(address keyPassItem);\\n  event CombineItems(address msgSender, uint configId, address[] items, uint[][] itemIds, address mintedItem, uint mintedItemId);\\n  event RegisterSandboxItem(address hero, uint heroId, address item, uint itemId, uint tsMinting);\\n  event WithdrawItemsFromSandbox(address hero, uint heroId, address[] items, uint[] itemIds);\\n  event ItemReturnedToSandbox(address hero, uint heroId, address item, uint itemId);\\n  event RegisterSandboxUpgrade(address hero, uint heroId, uint tsUpgradng);\\n  event TransferItemToHeroFromSandbox(address hero, uint heroId, address item, uint itemId);\\n  event DestroyItemInSandbox(address item, uint itemId);\\n  event NewItemSentToSandbox(address item, uint itemId);\\n  event ExitFromDungeon(address hero, uint heroId);\\n  //endregion ------------------------ Item controller and helper contracts\\n\\n  //region ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n  event ChangePauseStatus(bool value);\\n  event MinterChanged(address value);\\n\\n  event UniqueUriChanged(uint id, string uri);\\n  event BaseUriChanged(string uri);\\n\\n  event HeroMinted(uint heroId);\\n  event HeroBurned(uint heroId);\\n  event HeroUriByStatusChanged(string uri, uint statusLvl);\\n\\n  event ItemMinted(uint tokenId);\\n  event ItemBurned(uint tokenId);\\n  event UriByRarityChanged(string uri, uint rarity);\\n  event SponsoredHeroCreated(address msgSender, address heroAddress, uint heroId, string heroName);\\n  //endregion ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n\\n  //region ------------------------ User controller\\n  event SetUserName(address user, string name);\\n  event SetUserAvatar(address user, string avatar);\\n  event LootBoxOpened(address user, uint lootBoxKind, address[] itemTokens, uint[] itemTokenIds);\\n  event LootBoxConfigChanged(uint lootBoxKind, address[] mintItems, uint32[] mintItemsChances, uint maxDropItems);\\n  event SetFeeRenaming(uint feeRenaming);\\n\\n  event ActivityCompleted(address user, bool daily, bool weekly);\\n  event RegisterPassedDungeon(address user, uint32 epochWeek, uint counterPassedDungeons);\\n  event RegisterPvp(address user, uint32 epochWeek, uint counterPvp);\\n  event FameHallHeroRegistered(address hero, uint heroId, address heroOwner, uint8 openedNgLevel);\\n  event SetMinHeroLevel(uint level);\\n  event SetGuildStakingAdapter(address adapter);\\n\\n  event AddGamePoints(address user, uint finalBalanceGamePoints);\\n  /// @param paramId See IUserController.UserControllerParam\\n  event SetUserControllerParam(uint8 paramId, uint paramValue);\\n  event UseGamePointsToSkipStory(address user, uint16 storyId, uint priceInGamePoints, uint finalBalanceGamePoints);\\n  event SetStoryPassed(address user, uint16 storyId);\\n  //endregion ------------------------ User controller\\n\\n  //region ------------------------ Guild\\n\\n  event GuildCreated(address owner, uint guildId, string name, string urlLogo);\\n  event AddToGuild(uint guildId, address newUser);\\n  event ChangeGuildRights(uint guildId, address user, uint rights);\\n  event RemoveFromGuild(uint guildId, address user);\\n  event GuildDeleted(uint guildId);\\n  event GuildLevelUp(uint guildId, uint8 newLevel);\\n  event GuildRename(uint guildId, string newName);\\n  event GuildLogoChanged(uint guildId, string newLogoUrl);\\n  event GuildDescriptionChanged(uint guildId, string newDescription);\\n  event GuildBannerChanged(uint guildId, string newBanner);\\n  event SetGuildRelation(uint guildId1, uint guildId2, bool peace);\\n  event TransferFromGuildBank(address user, address token, uint amount, address recipient);\\n  event TransferNftFromGuildBank(address user, address[] nfts, uint[] tokenIds, address recipient);\\n  event GuildBankDeployed(uint guildId, address guildBank);\\n  event TransferOwnership(address prevOwner, address newOwner);\\n\\n  event SetToHelperRatio(uint guildId, uint8 value, address user);\\n  event TopUpGuildBank(address msgSender, uint guildId, address guildBank, uint amount);\\n\\n  event GuildRequestRegistered(address msgSender, uint guildId, string userMessage, uint depositAmount);\\n  event GuildRequestStatusChanged(address msgSender, uint guildRequestId, uint8 newStatus, address user);\\n  event SetToHelperRatio(uint guildId, address msgSender, uint8 toHelperRatio);\\n  event SetGuildRequestDepositAmount(uint guildId, address msgSender, uint amount);\\n  event SetGuildBaseFee(uint fee);\\n  event SetPvpPointsCapacity(address msgSender, uint64 capacityPvpPoints, address[] users);\\n  event SetShelterController(address shelterController);\\n  event SetShelterAuction(address shelterAuction);\\n  event PayForBidFromGuildBank(uint guildId, uint amount, uint bid);\\n  //endregion ------------------------ Guild\\n\\n  //region ------------------------ Guild shelter\\n  event RegisterShelter(uint sheleterId, uint price);\\n  event SetShelterItems(\\n    uint shelterId,\\n    address[] items,\\n    uint64[] pricesInPvpPoints,\\n    uint128[] pricesInGameTokens,\\n    uint16[] maxItemsPerDayThresholds\\n  );\\n  event RemoveShelterItems(uint shelterId, address[] items);\\n  event BuyShelter(uint guidlId, uint shelterId);\\n  event LeaveShelter(uint guildId, uint shelterId);\\n  event NewShelterBid(uint shelterId, uint buyerGuildId, uint amount);\\n  event RevokeShelterBid(uint shelterId);\\n  event UseShelterBid(uint shelterId, uint sellerGuildId, uint buyerGuidId, uint amount);\\n  event PurchaseShelterItem(address msgSender, address item, uint numSoldItems, uint priceInPvpPoints, uint priceInGameToken);\\n  event ChangeShelterOwner(uint shelterId, uint fromGuildId, uint toGuildId);\\n  event RestInShelter(address msgSender, address heroToken, uint heroTokenId);\\n  //endregion ------------------------ Guild shelter\\n\\n  //region ------------------------ Guild reinforcement\\n  event GuildHeroStaked(address heroToken, uint heroId, uint guildId);\\n  event GuildHeroWithdrawn(address heroToken, uint heroId, uint guildId);\\n  event GuildHeroAsked(address heroToken, uint heroId, uint guildId, address user);\\n\\n  /// @param user Address can be 0 if heroId was already burnt at the moment of reinforcement releasing\\n  event GuildHeroReleased(address heroToken, uint heroId, uint guildId, address user);\\n  //endregion ------------------------ Guild reinforcement\\n\\n  //region ------------------------ Pvp\\n  event AddBiomeRequest(address user, uint8 biome, uint guildId, uint32 week);\\n  event PvpHeroAdded(address user, uint guildId, address hero, uint heroId, uint week, uint8 biome);\\n  /// @param manuallyRemoved True - removed manually by the user, false - removed automatically after the fight\\n  event PvpHeroRemoved(address user, uint guildId, uint week, uint8 biome, address hero, uint heroId, bool manuallyRemoved);\\n  event PreparePvpFight(uint48 fightId, uint32 week, address hero, uint heroId, uint heroGuildId, address opponentHero, uint opponentHeroId, uint opponentGuildId);\\n\\n  /// @notice heroId can be detected by {fightId} and {heroes}\\n  event PvpFightCompleted(\\n    IPvpController.PvpFightResults fightResult,\\n    uint48 fightId,\\n    address[2] heroes,\\n    uint64[2] guilds,\\n    bool[2] winners,\\n    uint[2] prizes,\\n    bool technicalDefeat\\n  );\\n  event UpdatePvpEpoch(uint8 biome, uint32 week, uint guildBiomeOwnerId);\\n  event FirstPvpEpoch(uint8 biome, uint32 week);\\n  event BiomeTaxPaid(address msgSender, uint8 biome, uint guildId, uint amount, uint taxPercent, uint taxAmount, uint64 dungeonId);\\n  event BiomeTaxPaidNft(address msgSender, uint8 biome, uint guildId, address item, uint itemId, uint taxPercent, uint64 dungeonId);\\n  event AddPvpFightItems(uint48 fightId, address[] items, uint[] itemIds);\\n\\n  //endregion ------------------------ Pvp\\n\\n  //region ------------------------ Guild auction\\n  event AuctionPositionOpened(uint positionId, uint shelterId, uint sellerGuildId, address msgSender, uint minAuctionPrice);\\n  event AuctionPositionClosed(uint positionId, address msgSender);\\n  event AuctionBidOpened(uint bidId, uint positionId, uint amount, address msgSender);\\n  event ApplyAuctionBid(uint bidId, address msgSender);\\n  event AuctionSetFee(uint fee);\\n  //endregion ------------------------ Guild auction\\n\\n  //region ------------------------ Guild bank\\n  event GuildBankTransfer(address token, address recipient, uint amount);\\n  event GuildBankTransferNft(address to, address nft, uint tokenId);\\n  event GuildBankTransferNftMulti(address to, address[] nfts, uint[] tokenIds);\\n  //endregion ------------------------ Guild bank\\n\\n  //region ------------------------ Pawnshop\\n  event PawnShopRouterDeployed(address pawnShop, address gameToken, address routerOwner, address deployed);\\n  event PawnShopRouterTransfer(address token, uint amount, address receiver);\\n  event PawnShopRouterBulkSell(address[] nfts, uint[] nftIds, uint[] prices, address nftOwner, uint[] positionIds);\\n  event PawnShopRouterClosePositions(uint[] positionIds, address receiver);\\n  event PawnShopRouterBulkBuy(uint[] positionIds, address receiver);\\n\\n  //endregion ------------------------ Pawnshop\\n\\n  //region ------------------------ Airdrop Distributor\\n  event AirdropDistributorSetToken(address token);\\n  event AirdropDistributorAddTree(uint week, bytes32 merkleRoot_);\\n  event AirdropDistributorRemoveTree(uint week);\\n  event AirdropDistributorClaim(uint[] _weeks, uint[] amounts, address receiver);\\n\\n  //endregion ------------------------ Airdrop Distributor\\n\\n  //region ------------------------ GuildStakingManager\\n  event SetStakingToken(address token);\\n  event StakeTokens(address token, uint amount, uint guildId, uint total);\\n  //endregion ------------------------ GuildStakingManager\\n\\n}\\n\",\"keccak256\":\"0x5b5f06c2fb855d5c7a2c996702eedeb40183a8244dd7a15ec0366acc7a8eab8a\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IControllable {\\n\\n  function VERSION() external pure returns (string memory);\\n\\n  function revision() external view returns (uint);\\n\\n  function previousImplementation() external view returns (address);\\n\\n  function isController(address contract_) external view returns (bool);\\n\\n  function isGovernance(address contract_) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0x296b634c46b5d178b2408523fcf569ed370e20a719b7b3f2183b278631b94f65\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IController {\\n\\n  function governance() external view returns (address);\\n\\n  function statController() external view returns (address);\\n\\n  function storyController() external view returns (address);\\n\\n  function gameObjectController() external view returns (address);\\n\\n  function reinforcementController() external view returns (address);\\n\\n  function oracle() external view returns (address);\\n\\n  function treasury() external view returns (address);\\n\\n  function itemController() external view returns (address);\\n\\n  function heroController() external view returns (address);\\n\\n  function dungeonFactory() external view returns (address);\\n\\n  function gameToken() external view returns (address);\\n\\n  function validTreasuryTokens(address token) external view returns (bool);\\n\\n  function isDeployer(address adr) external view returns (bool);\\n\\n  function onPause() external view returns (bool);\\n\\n  function userController() external view returns (address);\\n\\n  function guildController() external view returns (address);\\n\\n  function pvpController() external view returns (address);\\n\\n  function rewardsPool() external view returns (address);\\n\\n  function itemBoxController() external view returns (address);\\n\\n  function gameTokenPrice() external view returns (uint);\\n\\n  function process(address token, uint amount, address from) external;\\n\\n  function gauge() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd8c6f7c276c6ed5ec5ece6d0073ad4079a66dcd951acbb2e6449f471fde117c5\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDungeonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IDungeonFactory {\\n\\n  /// @custom:storage-location erc7201:dungeon.factory.main\\n  struct MainState {\\n    /// @dev biome => dungeonLaunchedId\\n    mapping(uint => EnumerableSet.UintSet) freeDungeons;\\n    /// @dev hero + heroId + biome (packMapObject) -> completed\\n    mapping(bytes32 => bool) bossCompleted;\\n    /// @dev hero + heroId + dungNum (packDungeonKey) -> completed\\n    mapping(bytes32 => bool) specificDungeonCompleted;\\n    /// @notice Max biome completed by the hero\\n    /// @dev hero + heroId (nftPacked) -> max biome completed\\n    mapping(bytes32 => uint8) maxBiomeCompleted;\\n    /// @notice which dungeon the hero is currently in\\n    /// @dev hero+id => current DungeonId\\n    mapping(bytes32 => uint64) heroCurrentDungeon;\\n\\n    // ---\\n\\n    /// @notice Specific dungeon for the given pair of hero level + hero class\\n    ///         ALl specific dungeons are listed also in allSpecificDungeons\\n    /// @dev packUint8Array(specReqBiome, specReqHeroClass) => dungNum\\n    mapping(bytes32 => uint16) dungeonSpecific;\\n    /// @dev contains all specific dungNum for easy management\\n    EnumerableSet.UintSet allSpecificDungeons;\\n    /// @dev biome => dungNum\\n    mapping(uint8 => EnumerableSet.UintSet) dungeonsLogicByBiome;\\n\\n    // ---\\n\\n    /// @dev max available biome. auto-increment with new dung deploy\\n    uint8 maxBiome;\\n\\n    /// @notice Address of treasure token => min hero level required\\n    /// @dev manual threshold for treasury\\n    mapping(address => uint) minLevelForTreasury;\\n\\n    /// @notice Contains arrays for SKILL_1, SKILL_2, SKILL_3 with 0 or 1\\n    /// i.e. [0, 1, 0] means that durability of SKILL_2 should be reduced\\n    /// @dev hero + heroId => uint8[] array where idx = slotNum\\n    mapping(bytes32 => bytes32) skillSlotsForDurabilityReduction;\\n\\n    /// @notice Counter of dungeons, it's incremented on launch of a new dungeon\\n    uint64 dungeonCounter;\\n\\n    /// @dev dungNum = init attributes\\n    mapping(uint16 => DungeonAttributes) dungeonAttributes;\\n    /// @dev dungeonId => status\\n    mapping(uint64 => DungeonStatus) dungeonStatuses;\\n\\n    /// @notice NG_LEVEL of the hero that has created the given dungeon\\n    mapping(uint64 dungeonId => uint ngLevel) dungeonNgLevel;\\n  }\\n\\n  struct ObjectGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    /// @dev uint8 types, packed using PackingLib.packUint8Array\\n    bytes32[] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    /// @dev uint64 chances\\n    uint32[][] objChancesByStages;\\n  }\\n\\n  struct DungeonGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    uint8[][] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    uint32[][] objChancesByStages;\\n\\n    uint32[] uniqObjects;\\n\\n    uint8 minLevel;\\n    uint8 maxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n  }\\n\\n  /// @notice Attributes of the given dungeon logic\\n  struct DungeonAttributes {\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    uint8 stages;\\n    uint8 biome;\\n\\n    /// @notice Default list of objects that should be passed in the dungeon\\n    uint32[] uniqObjects;\\n\\n    /// @dev min+max (packUint8Array)\\n    bytes32 minMaxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    /// @notice Packed DungeonGenerateInfo.requiredCustomData: MinValue, MaxValue, IsHero\\n    /// @dev min+max+isHero(packStoryCustomDataRequirements)\\n    bytes32[] requiredCustomDataValue;\\n\\n    ObjectGenerateInfo info;\\n  }\\n\\n  /// @notice Current status of the given dungeon\\n  struct DungeonStatus {\\n    uint64 dungeonId;\\n    /// @notice Dungeon logic id\\n    uint16 dungNum;\\n\\n    /// @notice True if the dungeon is completed by the hero\\n    bool isCompleted;\\n\\n    /// @notice Hero in the dungeon or 0\\n    address heroToken;\\n    uint heroTokenId;\\n    /// @notice Current object that should be passed by the hero. 0 - new object is not opened\\n    uint32 currentObject;\\n    /// @notice Current stage in the dungeon that should be passed by the hero.\\n    uint8 currentStage;\\n\\n    EnumerableMap.AddressToUintMap treasuryTokens;\\n    /// @notice All items that were minted on result of made actions\\n    bytes32[] treasuryItems;\\n\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    /// This value can be bigger than length of uniqObjects\\n    uint8 stages;\\n    /// @notice List of objects to be passed in the stage. The list can be dynamically changed during passing the stages\\n    uint32[] uniqObjects;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n\\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external returns (uint64 dungeonId);\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8);\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64);\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result);\\n\\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external;\\n\\n  /// @notice Hero exists current dungeon forcibly same as when dying but without loosing life chance\\n  function exitForcibly(address heroToken, uint heroTokenId, address msgSender) external;\\n\\n  function maxAvailableBiome() external view returns (uint8);\\n\\n  function reborn(address hero, uint heroId) external;\\n}\\n\",\"keccak256\":\"0x4e3a2e8f2fc6a0a59c3639e1548919e3a4f5b06295fcb8b4556df4f033e8ae87\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbca9de297214bb9c30daefda5ecaedd0af2c3e8e0440403ad543fb33528c5ef8\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xa365c0e17de806f6262765ef6236512674ac8563a6ee3436e81cec7b1d87468e\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  /**\\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n   */\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n   */\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of tokens in ``owner``'s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\n   *\\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n   * The approval is cleared when the token is transferred.\\n   *\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n   *\\n   * Requirements:\\n   *\\n   * - The caller must own the token or be an approved operator.\\n   * - `tokenId` must exist.\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address to, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Returns the account approved for `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  /**\\n   * @dev Approve or remove `operator` as an operator for the caller.\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n   *\\n   * Requirements:\\n   *\\n   * - The `operator` cannot be the caller.\\n   *\\n   * Emits an {ApprovalForAll} event.\\n   */\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  /**\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n   *\\n   * See {setApprovalForAll}\\n   */\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0xe7d89e4cdfc41317d90bf469428b6ef17cec6eb6fccab0080bdf0378129d2708\",\"license\":\"MIT\"},\"contracts/interfaces/IFightCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface IFightCalculator {\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    MELEE, // 1\\n    MAGIC, // 2\\n    SLOT_3,\\n    SLOT_4,\\n    SLOT_5,\\n    SLOT_6,\\n    SLOT_7,\\n    SLOT_8,\\n    SLOT_9,\\n    SLOT_10\\n  }\\n\\n  /// @notice Attacker info: suitable both for hero and monsters\\n  struct AttackInfo {\\n    /// @notice Type of the attack\\n    /// by default, if attack token presents, it's magic attack and not-magic otherwise\\n    /// but this logic can become more complicated after introducing new attack types\\n    AttackType attackType;\\n    /// @notice NFT selected by hero for attack, it should be equip on.\\n    /// If attacker is a monster, this is a special case (stub NFT with zero ID is used)\\n    address attackToken;\\n    uint attackTokenId;\\n    address[] skillTokens;\\n    uint[] skillTokenIds;\\n  }\\n\\n  struct FighterInfo {\\n    int32[] fighterAttributes;\\n    IStatController.ChangeableStats fighterStats;\\n    AttackType attackType;\\n    address attackToken;\\n    uint attackTokenId;\\n    uint race;\\n  }\\n\\n  struct Statuses {\\n    bool stun;\\n    bool burn;\\n    bool freeze;\\n    bool confuse;\\n    bool curse;\\n    bool poison;\\n    bool gotCriticalHit;\\n    bool missed;\\n    bool hitBlocked;\\n  }\\n\\n  struct FightResult {\\n    int32 healthA;\\n    int32 healthB;\\n    int32 manaConsumedA;\\n    int32 manaConsumedB;\\n  }\\n\\n  struct FightCall {\\n    FighterInfo fighterA;\\n    FighterInfo fighterB;\\n    uint64 dungeonId;\\n    uint32 objectId;\\n    address heroAdr;\\n    uint heroId;\\n    uint8 stageId;\\n    uint iteration;\\n    uint8 turn;\\n  }\\n\\n  /// @notice Additional info passed to fight\\n  struct FightCallAdd {\\n    address msgSender;\\n\\n    /// @notice Unique ID of the pvp-fight, 0 for not pvp fights\\n    uint48 fightId;\\n  }\\n\\n  struct SkillSlots {\\n    bool slot1;\\n    bool slot2;\\n    bool slot3;\\n  }\\n\\n  //region ------------------------ FightLib-internal (FightInfoInternal is required by IApplicationEvents..)\\n  struct FightInfoInternal {\\n    Fighter fighterA;\\n    Fighter fighterB;\\n  }\\n\\n  struct Fighter {\\n    IFightCalculator.FighterInfo info;\\n    IItemController.AttackInfo magicAttack;\\n    int32 health;\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 damagePoison;\\n    int32 damageReflect;\\n    IFightCalculator.Statuses statuses;\\n  }\\n  //endregion ------------------------ FightLib-internal\\n\\n  function fight(FightCall memory callData) external returns (FightResult memory);\\n}\\n\",\"keccak256\":\"0xc985eb5db749909d4a80ba77a85e105245d8edee11f1c9532b69dc38dcc53c38\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGOC.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\n\\ninterface IGOC {\\n\\n  enum ObjectType {\\n    UNKNOWN, // 0\\n    EVENT, // 1\\n    MONSTER, // 2\\n    STORY, // 3\\n    END_SLOT\\n  }\\n\\n  enum ObjectSubType {\\n    UNKNOWN_0, // 0\\n    ENEMY_NPC_1, // 1\\n    ENEMY_NPC_SUPER_RARE_2, // 2\\n    BOSS_3, // 3\\n    SHRINE_4, // 4\\n    CHEST_5, // 5\\n    STORY_6, // 6\\n    STORY_UNIQUE_7, // 7\\n    SHRINE_UNIQUE_8, // 8\\n    CHEST_UNIQUE_9, // 9\\n    ENEMY_NPC_UNIQUE_10, // 10\\n    STORY_ON_ROAD_11, // 11\\n    STORY_UNDERGROUND_12, // 12\\n    STORY_NIGHT_CAMP_13, // 13\\n    STORY_MOUNTAIN_14, // 14\\n    STORY_WATER_15, // 15\\n    STORY_CASTLE_16, // 16\\n    STORY_HELL_17, // 17\\n    STORY_SPACE_18, // 18\\n    STORY_WOOD_19, // 19\\n    STORY_CATACOMBS_20, // 20\\n    STORY_BAD_HOUSE_21, // 21\\n    STORY_GOOD_TOWN_22, // 22\\n    STORY_BAD_TOWN_23, // 23\\n    STORY_BANDIT_CAMP_24, // 24\\n    STORY_BEAST_LAIR_25, // 25\\n    STORY_PRISON_26, // 26\\n    STORY_SWAMP_27, // 27\\n    STORY_INSIDE_28, // 28\\n    STORY_OUTSIDE_29, // 29\\n    STORY_INSIDE_RARE_30,\\n    STORY_OUTSIDE_RARE_31,\\n    ENEMY_NPC_INSIDE_32,\\n    ENEMY_NPC_INSIDE_RARE_33,\\n    ENEMY_NPC_OUTSIDE_34,\\n    ENEMY_NPC_OUTSIDE_RARE_35,\\n    STORY_ASCRA_36,\\n    STORY_ASCRA_RARE_37,\\n    STORY_BANFOOT_38,\\n    STORY_BANFOOT_RARE_39,\\n    STORY_ENFITILIA_40,\\n    STORY_ENFITILIA_RARE_41,\\n\\n    ENEMY_NPC_ASCRA_42,\\n    ENEMY_NPC_ASCRA_RARE_43,\\n    ENEMY_NPC_BANFOOT_44,\\n    ENEMY_NPC_BANFOOT_RARE_45,\\n    ENEMY_NPC_ENFITILA_46,\\n    ENEMY_NPC_ENFITILA_RARE_47,\\n\\n    STORY_FREE_LAND_48,\\n    STORY_GAME_THEORY_49,\\n    STORY_WEARY_50,\\n    STORY_EXHAUSTED_51,\\n    STORY_TRAPPED_52,\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:game.object.controller.main\\n  struct MainState {\\n\\n    /// @dev objId = biome(00) type(00) id(0000) => biome(uint8) + objType(uint8)\\n    /// Id is id of the event, story or monster.\\n    mapping(uint32 => bytes32) objectMeta;\\n\\n    /// @dev biome(uint8) + objType(uint8) => set of object id\\n    mapping(bytes32 => EnumerableSet.UintSet) objectIds;\\n\\n    /// @dev heroAdr180 + heroId64 + cType8 + biome8 => set of already played objects. Should be cleared periodically\\n    mapping(bytes32 => EnumerableSet.UintSet) playedObjects;\\n\\n    /// @dev HeroAdr(160) + heroId(uint64) + objId(uint32) => iteration count. It needs for properly emit events for every new entrance.\\n    mapping(bytes32 => uint) iterations;\\n\\n    /// @dev objId(uint32) => EventInfo\\n    mapping(uint32 => EventInfo) eventInfos;\\n\\n    /// @dev objId(uint32) => storyId\\n    mapping(uint32 => uint16) storyIds;\\n\\n    /// @dev objId(uint32) => MonsterInfo\\n    mapping(uint32 => MonsterInfo) monsterInfos;\\n\\n    /// @dev hero+id => last fight action timestamp\\n    mapping(bytes32 => uint) lastHeroFightTs;\\n\\n    /// @dev delay for user actions in fight (suppose to prevent bot actions)\\n    uint fightDelay;\\n  }\\n\\n  struct ActionResult {\\n    bool kill;\\n    bool completed;\\n    address heroToken;\\n    address[] mintItems;\\n    uint32[] mintItemsMF;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n    uint32 objectId;\\n    uint32 experience;\\n    uint heroTokenId;\\n    uint iteration;\\n    uint32[] rewriteNextObject;\\n  }\\n\\n  struct ActionResultEvent {\\n    bool kill;\\n    bool completed;\\n    address heroToken;\\n    address[] mintItems;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n    uint32 objectId;\\n    uint32 experience;\\n    uint heroTokenId;\\n    uint iteration;\\n    uint32[] rewriteNextObject;\\n  }\\n\\n  struct EventInfo {\\n    /// @dev chance to use good or bad attributes/stats\\n    uint32 goodChance;\\n\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] goodAttributes;\\n    bytes32[] badAttributes;\\n\\n    /// @dev experience(uint32) + heal(int32) + manaRegen(int32) + lifeChancesRecovered(int32) + damage(int32) + manaConsume(int32) packStatsChange\\n    bytes32 statsChange;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n  }\\n\\n  struct MonsterInfo {\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] attributes;\\n    /// @dev level(uint8) + race(uint8) + experience(uint32) + maxDropItems(uint8) packMonsterStats\\n    bytes32 stats;\\n    /// @dev attackToken(160) + attackTokenId(uint64) + attackType(uint8) packAttackInfo\\n    bytes32 attackInfo;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n\\n    /// @dev heroAdr(160) + heroId(uint64) => iteration => GeneratedMonster packed\\n    mapping(bytes32 => mapping(uint => bytes32)) _generatedMonsters;\\n  }\\n\\n  struct MultiplierInfo {\\n    uint8 biome;\\n    /// @notice NG_LEVEL of the hero who is going to fight with the given monster\\n    /// Use type(uint8).max for !NG+\\n    uint8 heroNgLevel;\\n  }\\n\\n  struct GeneratedMonster {\\n    bool generated;\\n    uint8 turnCounter;\\n    int32 hp;\\n    uint32 amplifier;\\n  }\\n\\n  struct MonsterGenInfo {\\n    uint16 monsterId;\\n    uint8 biome;\\n    ObjectSubType subType;\\n\\n    uint8[] attributeIds;\\n    int32[] attributeValues;\\n\\n    uint8 level;\\n    uint8 race;\\n    uint32 experience;\\n    uint8 maxDropItems;\\n\\n    address attackToken;\\n    uint64 attackTokenId;\\n    uint8 attackType;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct ActionContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    uint8 biome;\\n    uint8 objectSubType;\\n    uint8 stageId;\\n    uint8 heroNgLevel;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint heroTokenId;\\n    uint salt;\\n    uint iteration;\\n    bytes data;\\n  }\\n\\n  struct EventRegInfo {\\n    uint8 biome;\\n    uint16 eventId;\\n    ObjectSubType subType;\\n\\n    uint32 goodChance;\\n\\n    AttributeGenerateInfo goodAttributes;\\n    AttributeGenerateInfo badAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct AttributeGenerateInfo {\\n    uint8[] ids;\\n    int32[] values;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev represent object registration if non zero values\\n  function getObjectMeta(uint32 objectId) external view returns (uint8 biome, uint8 objectSubType);\\n\\n  function isBattleObject(uint32 objectId) external view returns (bool);\\n\\n  function getRandomObject(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biomeLevel,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external returns (uint32 objectId);\\n\\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint iteration);\\n\\n  function action(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) external returns (ActionResult memory);\\n\\n}\\n\",\"keccak256\":\"0x88580823abc58707f82f64ec370d58663b0d9c42185749023d4b4f6b1e3b9655\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGameToken.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IGameToken is IERC20 {\\n\\n  function minter() external view returns (address);\\n\\n  function mint(address account, uint amount) external returns (bool);\\n\\n  function burn(uint amount) external returns (bool);\\n\\n  function setMinter(address minter_) external;\\n\\n  function pause(bool value) external;\\n\\n}\\n\",\"keccak256\":\"0x55fbc7d57c7c72905132decd85a2008a901e550d0b71cf7ac5db6b36a1c598d6\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGuildController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IGuildController {\\n  enum GuildRightBits {\\n    ADMIN_0,\\n    RENAME_1,\\n    CHANGE_LOGO_2,\\n    CHANGE_SHELTER_3,\\n    ADD_MEMBER_4,\\n    REMOVE_MEMBER_5,\\n    BANK_TOKENS_OPERATION_6,\\n    CHANGE_ROLES_7,\\n    LEVEL_UP_8,\\n    SET_RELATION_KIND_9,\\n    BANK_ITEMS_OPERATION_10,\\n    SET_GUILD_PARAMS_11,\\n    CHANGE_PURCHASING_SHELTER_ITEMS_CAPACITY_12,\\n    DOMINATION_REQUEST_13\\n  }\\n\\n  enum GuildsParams {\\n    NONE_0,\\n    COUNTER_GUILD_IDS_1,\\n    BASE_FEE_2,\\n    COUNTER_GUILD_REQUESTS_3,\\n    REENTRANT_STATUS_4,\\n    SHELTER_CONTROLLER_5,\\n    SHELTER_AUCTION_6\\n\\n    // max 255 params because enum is uint8 by default\\n  }\\n\\n  enum GuildRequestStatus {\\n    NONE_0,\\n    ACCEPTED_1,\\n    REJECTED_2,\\n    CANCELED_3\\n  }\\n\\n  /// @custom:storage-location erc7201:guild.controller.main\\n  struct MainState {\\n    /// @notice Mapping to store various guilds params (with global values for all guilds)\\n    mapping(GuildsParams param => uint value) guildsParam;\\n\\n    /// @notice guildId => address of instance of GuildBank contract\\n    mapping(uint guildId => address) guildBanks;\\n\\n    /// @notice guild id => guild data (owner, name, logo, etc)\\n    mapping(uint guildId => GuildData) guildData;\\n\\n    /// @notice name => guild id\\n    mapping(string guildName => uint guildId) nameToGuild;\\n\\n    /// @notice EOA => guild id, EOA can be a member of a single guild only\\n    mapping(address member => uint guildId) memberToGuild;\\n\\n    /// @notice List of participants of guilds\\n    /// @dev Allowed number of members is 20 + 5 * guildLevel\\n    mapping(uint guildId => EnumerableSet.AddressSet listEoa) members;\\n\\n    /// @notice Rights of the member in the guild, mask of GuildRightBits\\n    mapping(address member => uint maskRights) rights;\\n\\n    /// @notice _getGuildsPairKey(guild1, guild2) => status (false - war, true - peace)\\n    mapping(bytes32 guildsPairKey => bool) relationsPeaceful;\\n\\n    // ---------------------------- Request to join to the guild\\n    /// @notice Full list of requests registered for the guild\\n    mapping(uint guildId => mapping(GuildRequestStatus status => EnumerableSet.UintSet guildRequestIds)) guildRequests;\\n\\n    /// @notice List of active requests created by the given user.\\n    /// \\\"Active\\\" => deposit should be returned to the user.\\n    /// All not-active requests are removed from here automatically.\\n    mapping(address user => EnumerableSet.UintSet guildRequestIds) userActiveGuildRequests;\\n\\n    /// @notice Data of all guild requests ever created\\n    mapping(uint guildRequestId => GuildRequestData) guildRequestData;\\n\\n    /// @notice Deposit amount required to create a guild request\\n    mapping(uint guildId => GuildRequestDeposit) guildRequestDepositAmounts;\\n\\n    /// @notice Counter of spent pvp points + number of guild pvp-points allowed to be used by the guild member\\n    mapping(uint guildId => mapping(address member => UserPvpPoints)) userPvpPoints;\\n\\n    /// @notice guild id => guildDescription\\n    mapping(uint guildId => string) guildDescription;\\n\\n    /// @notice guild id => guildBanner\\n    mapping(uint guildId => string) guildBanner;\\n  }\\n\\n  struct GuildData {\\n    /// @notice Not empty unique guild name\\n    string guildName;\\n\\n    /// @notice URL of guild logo (empty is allowed)\\n    string urlLogo;\\n\\n    /// @notice Creator (owner) of the guild\\n    address owner;\\n\\n    /// @notice Guild level [1...10]\\n    uint8 guildLevel;\\n\\n    /// @notice Percent of guild reinforcement fee Value in range [_FEE_MIN ... _TO_HELPER_RATIO_MAX], i.e. [10..50]\\n    uint8 toHelperRatio;\\n\\n    /// @notice Global guild points counter, it's incremented on each victory in php-fight.\\n    /// @dev Assume here, that uint64 is enough to store any sums of scores\\n    uint64 pvpCounter;\\n  }\\n\\n  struct GuildRequestData {\\n    GuildRequestStatus status;\\n    /// @notice Creator of the guild request that asks to include him to the guild\\n    address user;\\n    /// @notice Message to the guild owner from the user\\n    string userMessage;\\n    uint guildId;\\n  }\\n\\n  struct GuildRequestDeposit {\\n    bool initialized;\\n    uint192 amount;\\n  }\\n\\n  struct UserPvpPoints {\\n    /// @notice How many guild pvp-points the user is allowed to use\\n    uint64 capacityPvpPoints;\\n\\n    /// @notice How many guild pvp-points the user has used\\n    uint64 spentPvpPoints;\\n  }\\n\\n  /// ----------------------------------------------------------------------------------------------\\n\\n  function memberOf(address user) external view returns (uint guildId);\\n  function guildToShelter(uint guildId) external view returns (uint shelterId);\\n\\n  function getGuildData(uint guildId) external view returns (\\n    string memory guildName,\\n    string memory urlLogo,\\n    address owner,\\n    uint8 guildLevel,\\n    uint64 pvpCounter,\\n    uint toHelperRatio\\n  );\\n\\n  function getRights(address user) external view returns (uint);\\n  function getGuildBank(uint guildId) external view returns (address);\\n  function shelterController() external view returns (address);\\n\\n  function isPeacefulRelation(uint guildId, uint guildId2) external view returns (bool);\\n  function incPvpCounter(uint guildId, uint64 value) external;\\n\\n  function usePvpPoints(uint guildId, address user, uint64 priceInPvpPoints) external;\\n  function payFromGuildBank(uint guildId, uint shelterPrice) external;\\n  function payFromBalance(uint amount, address user) external;\\n\\n  /// @notice Ensure that the {user} has given {right}, revert otherwise\\n  function checkPermissions(address user, uint right) external view returns (uint guildId, uint rights);\\n  function shelterAuctionController() external view returns (address);\\n  function payForAuctionBid(uint guildId, uint amount, uint bid) external;\\n\\n}\\n\",\"keccak256\":\"0x258d04e52bc4e487cc8d93e5c54427089ca2fe4589d6dc555c98fe22c3d0f708\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IHeroController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IHeroController {\\n\\n  /// @custom:storage-location erc7201:hero.controller.main\\n  struct MainState {\\n\\n    /// @dev A central place for all hero tokens\\n    /// @dev Deprecated. Controller is used instead.\\n    address heroTokensVault;\\n\\n    /// @notice heroAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) payToken;\\n\\n    /// @dev heroAdr => heroCls8\\n    mapping(address => uint8) heroClass;\\n\\n    // ---\\n\\n    /// @dev hero+id => individual hero name\\n    mapping(bytes32 => string) heroName;\\n\\n    /// @dev name => hero+id, needs for checking uniq names\\n    mapping(string => bytes32) nameToHero;\\n\\n    // ---\\n\\n    /// @dev hero+id => biome\\n    mapping(bytes32 => uint8) heroBiome;\\n\\n    /// @notice Exist reinforcement of any kind for the given hero\\n    /// @dev hero+id => packed reinforcement helper+id\\n    mapping(bytes32 => bytes32) reinforcementHero;\\n\\n    /// @dev hero+id => reinforcement packed attributes\\n    mapping(bytes32 => bytes32[]) reinforcementHeroAttributes;\\n\\n    /// @notice packedHero (hero + id) => count of calls of beforeTokenTransfer\\n    mapping(bytes32 => uint) countHeroTransfers;\\n\\n\\n    // ------------------------------------ NG plus\\n\\n    /// @notice (tier, hero address) => TierInfo, where tier = [2, 3]\\n    /// @dev For tier=1 no data is required. Amount for tier 1 is stored in {payToken}, no items are minted\\n    /// Token from {payToken} is equal for all tiers\\n    mapping(bytes32 packedTierHero => TierInfo) tiers;\\n\\n    mapping(bytes32 packedHero => HeroInfo) heroInfo;\\n\\n    /// @notice Max NG_LVL reached by the heroes of a given account\\n    mapping(address user => uint8 maxNgLevel) maxUserNgLevel;\\n\\n    /// @notice When the hero has killed boss on the given biome first time\\n    /// packedBiomeNgLevel = packed (biome, NG_LEVEL)\\n    mapping(bytes32 packedHero => mapping (bytes32 packedBiomeNgLevel => uint timestamp)) killedBosses;\\n\\n    /// @notice Max NG_LEVEL reached by any user\\n    uint maxOpenedNgLevel;\\n\\n    /// @notice Sandbox mode for heroes, see SCR-1153\\n    mapping(bytes32 packedHero => SandboxMode sandboxMode) sandbox;\\n\\n    /// @notice List of packed skill-tokens equipped on the helper at the moment of asking him for help by the hero\\n    /// @dev Packed skill contains item address, item id and slot number (use unpackNftIdWithValue)\\n    /// Size of the array can be 0..3\\n    mapping(bytes32 packedHero => bytes32[] packedSkills) helperSkills;\\n  }\\n\\n  /// @notice Tier = hero creation cost option\\n  /// There are 3 tiers:\\n  /// 1: most chip option, just pay fixed amount {payTokens} - new hero is created\\n  /// 2: pay bigger amount - random skill is equipped on the newly created hero\\n  /// 3: pay even more amount - random sill + some random items are equipped on the newly created hero\\n  struct TierInfo {\\n    /// @notice Cost of the hero creation using the given tier in terms of the token stored in {payToken}\\n    /// This amount is used for tiers 2, 3. For tier 1 the amount is taken from {payToken}\\n    uint amount;\\n\\n    /// @notice All slots for which items-to-mint are registered in {itemsToMint}\\n    EnumerableSet.UintSet slots;\\n\\n    /// @notice slot => items that can be minted and equipped on the hero to the given {slot} after hero creation\\n    mapping(uint8 slot => address[] items) itemsToMint;\\n  }\\n\\n  /// @notice Current NG+-related values\\n  /// @dev Only post-paid hero has tier = 0\\n  /// @dev Only free-hero has paidToken != 0 && paidAmount == 0\\n  struct HeroInfo {\\n    /// @notice Hero tier = [0..3].\\n    /// 0 - the hero is post-paid, it can be changed by upgrading the hero to pre-paid\\n    /// always 1 for sandbox-heroes\\n    /// always 1 for free-heroes\\n    uint8 tier;\\n\\n    /// @notice NG_LVL of the hero\\n    uint8 ngLevel;\\n\\n    /// @notice True if hero has passed last biome on current NG+ and so NG_LEVEL can be incremented (reborn is allowed)\\n    bool rebornAllowed;\\n\\n    /// @notice Amount paid for the hero on creation OR on upgrade to NG+\\n    /// Amount paid for creation of the hero in terms of game token (!NG+) is NOT stored here.\\n    /// @dev uint72 is used here to pack the whole struct to single slot\\n    /// Zero for sandbox-heroes and for free-heroes\\n    uint72 paidAmount;\\n\\n    /// @notice Pay token used to pay {paidAmount}\\n    /// Zero for sandbox-heroes\\n    address paidToken;\\n  }\\n\\n  /// @notice Input data to create new hero\\n  struct HeroCreationData {\\n    /// @notice Desired NG_LVL of the hero\\n    uint8 ngLevel;\\n\\n    /// @notice Desired tire of the newly created hero. Allowed values: [1..3]\\n    uint8 tier;\\n\\n    /// @notice Enter to the dungeon after creation\\n    bool enter;\\n\\n    /// @notice Desired hero name\\n    string heroName;\\n\\n    /// @notice Optional: user account for which the hero is created\\n    address targetUserAccount;\\n\\n    /// @notice Optional: ref-code to be passed to the hero-creation-related event\\n    string refCode;\\n\\n    /// @notice SCR-1153: create not-paid hero with limited rights\\n    bool sandboxMode;\\n  }\\n\\n  enum SandboxMode {\\n    /// @notice The hero is created in normal (not sandbox) mode\\n    NORMAL_MODE_0,\\n\\n    /// @notice The hero was created in sandbox mode and wasn't upgraded.\\n    SANDBOX_MODE_1,\\n\\n    /// @notice The hero was created in sandbox mode and was upgraded to the normal mode\\n    UPGRADED_TO_NORMAL_2\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function heroClass(address hero) external view returns (uint8);\\n\\n  function heroBiome(address hero, uint heroId) external view returns (uint8);\\n\\n  function payTokenInfo(address hero) external view returns (address token, uint amount);\\n\\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (address helperHeroToken, uint helperHeroId);\\n\\n  function score(address hero, uint heroId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool);\\n\\n  function beforeTokenTransfer(address hero, uint heroId) external returns (bool);\\n\\n  // ---\\n\\n  function create(address hero, string memory heroName_, bool enter) external returns (uint);\\n\\n  function kill(address hero, uint heroId) external returns (bytes32[] memory dropItems);\\n\\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId);\\n\\n  function resetLifeAndMana(address hero, uint heroId) external;\\n\\n  function countHeroTransfers(address hero, uint heroId) external view returns (uint);\\n\\n  function askGuildReinforcement(address hero, uint heroId, address helper, uint helperId) external;\\n\\n  function getHeroInfo(address hero, uint heroId) external view returns (IHeroController.HeroInfo memory data);\\n\\n  function registerKilledBoss(address hero, uint heroId, uint32 objectId) external;\\n\\n  function maxOpenedNgLevel() external view returns (uint);\\n\\n  function sandboxMode(address hero, uint heroId) external view returns (uint8);\\n\\n  function helperSkills(address hero, uint heroId) external view returns (\\n    address[] memory items,\\n    uint[] memory itemIds,\\n    uint[] memory slots\\n  );\\n}\\n\",\"keccak256\":\"0x60f116a19db03b6caabdb7e8e5a291f4ab80562cd7bc6dd6b0de7f8404e4bef4\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemBoxController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IItemBoxController {\\n  /// @custom:storage-location erc7201:ItemBox.controller.main\\n  struct MainState {\\n    mapping(bytes32 packedHero => HeroData) heroData;\\n\\n    /// @notice Owners of all items minted in sandbox mode\\n    mapping(bytes32 packedItem => bytes32 packedHero) heroes;\\n  }\\n\\n  struct HeroData {\\n    /// @notice Moment of upgrading sandbox-hero to normal-hero\\n    uint tsUpgraded;\\n\\n    /// @notice List of all items registered for the hero\\n    EnumerableSet.AddressSet items;\\n\\n    /// @notice item => (itemId => packedItemBoxItemInfo)\\n    /// @dev Ids are never deleted from the map, so the order of ids is never changed\\n    mapping(address item => EnumerableMap.UintToUintMap) states;\\n  }\\n\\n  struct ItemBoxItemInfo {\\n    /// @notice True if the item was withdrawn from balance\\n    /// It can happens in follow cases:\\n    /// 1) the hero was upgraded and the item was withdrawn on hero owner balance\\n    /// 2) the item is used by ItemController:\\n    /// 2.1) the item is equipped on the hero and so it's transferred to the hero balance\\n    /// 2.2) the consumable item is used\\n    /// 3) the item is burnt\\n    /// @dev Status is required to avoid deletion (and so changing order) of the {items}\\n    bool withdrawn;\\n\\n    /// @notice The moment of the initial item minting\\n    uint64 timestamp;\\n  }\\n\\n  enum ItemState {\\n    /// @notice The item was never registered in the sandbox\\n    NOT_REGISTERED_0,\\n    /// @notice The item is not active (outdated) and cannot be used anymore\\n    NOT_AVAILABLE_1,\\n    /// @notice The item is active and located inside the sandbox\\n    INSIDE_2,\\n    /// @notice The item is either withdrawn or equipped\\n    OUTSIDE_3\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function firstActiveItemOfHeroByIndex(address hero, uint heroId, address item) external view returns (uint itemId);\\n  function registerItems(address hero, uint heroId, address[] memory items, uint[] memory itemIds, uint countValidItems) external;\\n  function itemState(address hero, uint heroId, address item, uint itemId) external view returns (IItemBoxController.ItemState);\\n  function itemHero(address item, uint itemId) external view returns (address hero, uint heroId);\\n  function registerSandboxUpgrade(bytes32 packedHero) external;\\n  function transferToHero(address hero, uint heroId, address item, uint itemId) external;\\n  function destroyItem(address item, uint itemId) external;\\n}\\n\",\"keccak256\":\"0xdb480923e0879904a4a5fda24ebf7caf027238c1cec2a0eb58885655e7b624e0\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IItemController {\\n\\n  enum GlobalParam {\\n    UNKNOWN_0,\\n\\n    /// @notice Address of ItemControllerHelper\\n    ITEM_CONTROLLER_HELPER_ADDRESS_1\\n  }\\n\\n  /// @custom:storage-location erc7201:item.controller.main\\n  struct MainState {\\n\\n    ////////////////// GENERATE //////////////////\\n\\n    EnumerableSet.AddressSet items;\\n\\n    /// @dev itemAdr => itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n    mapping(address => bytes32) itemMeta;\\n\\n    /// @dev itemAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) augmentInfo;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoAttributes;\\n\\n    // --- consumable ---\\n\\n    /// @dev itemAdr => ids+values (toBytes32ArrayWithIds)\\n    mapping(address => bytes32[]) _itemConsumableAttributes;\\n\\n    /// @dev itemAdr => IStatController.ChangeableStats packed int32[]\\n    mapping(address => bytes32) itemConsumableStats;\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoCasterAttributes;\\n\\n    /// @dev itemAdr => id8 + minDmg(int32) + maxDmg(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(address => bytes32) generateInfoAttack;\\n\\n    ////////////////// ITEMS INFO //////////////////\\n\\n    /// @dev itemAdr+id => itemRarity8 + augmentationLevel8 + itemDurability16\\n    mapping(bytes32 => bytes32) itemInfo;\\n\\n    /// @dev itemAdr+id => heroAdr+id\\n    mapping(bytes32 => bytes32) equippedOn;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemAttributes;\\n\\n    // --- consumable ---\\n\\n    // consumable stats unchangeable, get them by address\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemCasterAttributes;\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr+Id => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(bytes32 => bytes32) _itemAttackInfo;\\n\\n    ////////////////// Additional generate info //////////////////\\n\\n    /// @notice (itemAdr) => Bitmask of ConsumableActionBits\\n    mapping(address => uint) _consumableActionMask;\\n\\n\\n    /// --------------------------------- SIP-003: Item fragility\\n    /// @notice itemAdr + id => item fragility counter that displays the chance of an unsuccessful repair\\n    /// @dev [0...100_000], decimals 3\\n    mapping(bytes32 packedItem => uint fragility) itemFragility;\\n\\n    /// @notice Universal mapping to store various addresses and numbers (params of the contract)\\n    mapping (GlobalParam param => uint value) globalParam;\\n\\n    /// @notice Item address => packedMetadata\\n    /// {packedMetaData} is encoded using abi.encode/abi.decode\\n    /// Read first byte, detect meta data type by the byte value, apply proper decoder from PackingLib\\n    mapping(address item => bytes packedMetaData) packedItemMetaData;\\n\\n    /// --------------------------------- SCR-1263: Reverse-augmentation\\n    /// @notice Item attributes values before first augmentation.\\n    /// @dev SCR-1263: The values are required in augmentation if protective item is used and the augmentation is failed.\\n    mapping(bytes32 packedItem => ResetAugmentationData) _resetAugmentation;\\n  }\\n\\n  struct RegisterItemParams {\\n    ItemMeta itemMeta;\\n    address augmentToken;\\n    uint augmentAmount;\\n    ItemGenerateInfo commonAttributes;\\n\\n    IGOC.AttributeGenerateInfo consumableAttributes;\\n    IStatController.ChangeableStats consumableStats;\\n\\n    ItemGenerateInfo casterAttributes;\\n    ItemGenerateInfo targetAttributes;\\n\\n    AttackInfo genAttackInfo;\\n    /// @notice Bit mask of ConsumableActionBits\\n    uint consumableActionMask;\\n  }\\n\\n  /// @notice Possible actions that can be triggered by using the consumable item\\n  enum ConsumableActionBits {\\n    CLEAR_TEMPORARY_ATTRIBUTES_0\\n    // other items are used instead this mask\\n  }\\n\\n  struct ItemGenerateInfo {\\n    /// @notice Attribute ids\\n    uint8[] ids;\\n    /// @notice Min value of the attribute, != 0\\n    int32[] mins;\\n    /// @notice Max value of the attribute, != 0\\n    int32[] maxs;\\n    /// @notice Chance of the selection [0..MAX_CHANCES]\\n    uint32[] chances;\\n  }\\n\\n  struct ItemMeta {\\n    uint8 itemMetaType;\\n    // Level in range 1-99. Reducing durability in low level dungeons. lvl/5+1 = biome\\n    uint8 itemLevel;\\n    IItemController.ItemType itemType;\\n    uint16 baseDurability;\\n    uint8 defaultRarity;\\n    uint32 manaCost;\\n\\n    // it doesn't include positions with 100% chance\\n    uint8 minRandomAttributes;\\n    uint8 maxRandomAttributes;\\n\\n    IStatController.CoreAttributes requirements;\\n  }\\n\\n  // Deprecated. Todo - remove\\n  enum FeeType {\\n    UNKNOWN,\\n    REPAIR,\\n    AUGMENT,\\n    STORY,\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemRarity {\\n    UNKNOWN, // 0\\n    NORMAL, // 1\\n    MAGIC, // 2\\n    RARE, // 3\\n    SET, // 4\\n    UNIQUE, // 5\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemType {\\n    NO_SLOT, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    RING, // 6\\n    OFF_HAND, // 7\\n    BOOTS, // 8\\n    ONE_HAND, // 9\\n    TWO_HAND, // 10\\n    SKILL, // 11\\n    OTHER, // 12\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemMetaType {\\n    UNKNOWN, // 0\\n    COMMON, // 1\\n    ATTACK, // 2\\n    BUFF, // 3\\n    CONSUMABLE, // 4\\n\\n    END_SLOT\\n  }\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    FIRE, // 1\\n    COLD, // 2\\n    LIGHTNING, // 3\\n    CHAOS, // 4\\n\\n    END_SLOT\\n  }\\n\\n  struct AttackInfo {\\n    AttackType aType;\\n    int32 min;\\n    int32 max;\\n    // if not zero - activate attribute factor for the attribute\\n    IStatController.CoreAttributes attributeFactors;\\n  }\\n\\n  struct ItemInfo {\\n    ItemRarity rarity;\\n    uint8 augmentationLevel;\\n    uint16 durability;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct MintInfo {\\n    IItemController.ItemMeta meta;\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.ItemRarity itemRarity;\\n\\n    IItemController.AttackInfo attackInfo;\\n\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct AugmentInfo {\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.AttackInfo attackInfo;\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  ///region ------------------------ Item type \\\"Other\\\"\\n  /// @notice Possible kinds of \\\"Other\\\" items\\n  /// Each \\\"Other\\\" item has each own structure for metadata, see OtherItemXXX\\n  enum OtherSubtypeKind {\\n    UNKNOWN_0,\\n    /// @notice Item to reduce fragility, see SCB-1014. Metadata is {OtherItemReduceFragility}\\n    REDUCE_FRAGILITY_1,\\n\\n    /// @notice This item allows asking guild reinforcement to the guild member\\n    USE_GUILD_REINFORCEMENT_2,\\n\\n    /// @notice Exit from dungeon (shelter of level 3 is required)\\n    EXIT_FROM_DUNGEON_3,\\n\\n    /// @notice OTHER_5 Rest in the shelter: restore of hp & mp, clear temporally attributes, clear used consumables (shelter of level 3 is required)\\n    /// @dev It's OTHER_5 in deploy script, but internally it has subtype 4, see gen_others.ts\\n    REST_IN_SHELTER_4,\\n\\n    /// @notice OTHER_4 Stub item that has no logic in contracts, but it has correct (not empty) packedMetaData\\n    /// @dev It's OTHER_4 in deploy script, but internally it has subtype 5, see gen_others.ts\\n    EMPTY_NO_LOGIC_5,\\n\\n    END_SLOT\\n  }\\n  struct OtherItemReduceFragility {\\n    /// @notice \\\"Other\\\" item kind. It MUST BE first field in the struct.\\n    uint8 kind;\\n\\n    /// @notice Value on which the fragility will be reduced.\\n    /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n    uint248 value;\\n  }\\n  ///endregion ------------------------ Item type \\\"Other\\\"\\n\\n  struct AugmentOptParams {\\n    /// @notice Optional protective item\\n    /// @dev SCR-1263: If the protective item specified\\n    /// than failed augmentation doesn't destroy main item but reduces its augmentation level to the zero instead.\\n    /// Protective item is configured in ItemControllerHelper.\\n    address protectiveItem;\\n    uint protectiveItemId;\\n  }\\n\\n  struct ResetAugmentationData {\\n    /// @notice Moment of the first augmentation if any\\n    uint tsFirstAugmentation;\\n\\n    /// @notice Values of the item attributes before the first augmentation\\n    /// @dev Use PackingLib.toInt32ArrayWithIds to decode attribute ids and values\\n    bytes32[] itemAttributes;\\n\\n    /// @notice Values of the caster attributes before the first augmentation\\n    /// @dev Use PackingLib.toInt32ArrayWithIds to decode attribute ids and values\\n    bytes32[] itemCasterAttributes;\\n\\n    /// @notice Values of the target attributes before the first augmentation\\n    /// @dev Use PackingLib.toInt32ArrayWithIds to decode attribute ids and values\\n    bytes32[] itemTargetAttributes;\\n\\n    /// @notice packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    bytes32 itemAttackInfo;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function itemMeta(address item) external view returns (ItemMeta memory meta);\\n\\n  function augmentInfo(address item) external view returns (address token, uint amount);\\n\\n  function genAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genCasterAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genTargetAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genAttackInfo(address item) external view returns (AttackInfo memory info);\\n\\n  function itemInfo(address item, uint itemId) external view returns (ItemInfo memory info);\\n\\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId);\\n\\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats);\\n\\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function itemAttackInfo(address item, uint itemId) external view returns (AttackInfo memory info);\\n\\n  function score(address item, uint tokenId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address item, uint tokenId) external view returns (bool);\\n\\n  // ---\\n\\n  function mint(address item, address recipient, uint32 magicFind) external returns (uint itemId);\\n\\n  function reduceDurability(address hero, uint heroId, uint8 biome, bool reduceDurabilityAllSkills) external;\\n\\n  function destroy(address item, uint tokenId) external;\\n\\n  function takeOffDirectly(\\n    address item,\\n    uint itemId,\\n    address hero,\\n    uint heroId,\\n    uint8 itemSlot,\\n    address destination,\\n    bool broken\\n  ) external;\\n\\n  /// @notice SIP-003: item fragility counter that displays the chance of an unsuccessful repair.\\n  /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n  function itemFragility(address item, uint itemId) external view returns (uint);\\n\\n  /// @notice SIP-003: The quest mechanic that previously burned the item will increase its fragility by 1%\\n  function incBrokenItemFragility(address item, uint itemId) external;\\n\\n  function equip(\\n    address hero,\\n    uint heroId,\\n    address[] calldata items,\\n    uint[] calldata itemIds,\\n    uint8[] calldata itemSlots\\n  ) external;\\n\\n  function itemControllerHelper() external view returns (address);\\n}\\n\",\"keccak256\":\"0x0ccf4570904a08ccacec9b92a5870889b440328459f1596fef496ff8f677c1b3\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IOracle {\\n\\n  function getRandomNumber(uint max, uint seed) external returns (uint);\\n\\n  function getRandomNumberInRange(uint min, uint max, uint seed) external returns (uint);\\n\\n}\\n\",\"keccak256\":\"0x75a2bed27cbd9be6c76b6f3e941ee5f6f55380f61cd867254a0c766fc3b71976\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IProxyControlled.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IProxyControlled {\\n\\n  function upgrade(address newImplementation_) external;\\n\\n  function implementation() external view returns (address);\\n\\n}\\n\",\"keccak256\":\"0xfeb4690babcbc0bc349e9bb62d6f48be9f53fb1ede347805d1c386b5b3b3defe\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IPvpController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\n\\ninterface IPvpController {\\n  enum PvpParams {\\n    NONE_0,\\n    /// @notice Hero can be pvp-staked if his level is greater of equal to the given min level\\n    MIN_HERO_LEVEL_1,\\n\\n    /// @notice Address of IGuildStakingAdapter, can be not initialized\\n    GUILD_STAKING_ADAPTER_2,\\n\\n    /// @notice Unique ID of the pvp-fight (each pvp-fight consists from multiple turns)\\n    FIGHT_COUNTER_3\\n\\n    // max 255 params because enum is uint8 by default\\n  }\\n\\n  /// @custom:storage-location erc7201:pvp.controller.main\\n  struct MainState {\\n    /// @notice Mapping to store various params of PvpController\\n    mapping(PvpParams param => uint value) pvpParam;\\n\\n    /// @notice Current states of biomes\\n    mapping(uint8 biome => BiomeData) biomeState;\\n\\n    /// @notice Biomes owned by the guilds\\n    mapping(uint guildId => uint8 biome) ownedBiome;\\n\\n    mapping(uint epochWeek => EpochData) epochData;\\n  }\\n\\n  struct EpochData {\\n    /// @notice Current state of the user in the current epoch\\n    mapping (address user => PvpUserState) pvpUserState;\\n\\n    /// @notice biome data for the given epoch\\n    mapping(uint8 biome => EpochBiomeData) epochBiomeData;\\n\\n    /// @notice All prepared pvp-fights for the given user\\n    /// Index of currently active fight is stored in {pvpUserState.activeFightIndex1}\\n    mapping (address user => PvpFightData[]) fightData;\\n\\n    /// @notice All currently registered packed-heroes\\n    EnumerableSet.UintSet stakedHeroes;\\n\\n    /// @notice Weekly request of the guild to dominate at the given biome starting from the next week\\n    mapping(uint guildId => uint8 biome) targetBiome;\\n\\n    /// @notice All guilds pretend for the given biome\\n    mapping(uint8 biome => EnumerableSet.UintSet guildIds) biomeGuilds;\\n  }\\n\\n  /// @notice Current state of the user. Possible states: user has or hasn't staked a hero in pvp.\\n  /// Each user is able to stake pvp-heroes multiple times per epoch\\n  /// but the user is able to stake only 1 pvp-hero at any moment.\\n  /// @dev Implementation assumes that the struct occupies single slot, the struct is read as a whole\\n  struct PvpUserState {\\n    /// @notice Domination biome at the moment of staking\\n    /// @dev not 0 if the user has pvp-staked hero\\n    uint8 biome;\\n\\n    /// @notice 1-based index of currently active fight in {fightData} (the fight is either prepared or in-progress).\\n    /// 0 - there is no active fight\\n    uint32 activeFightIndex1;\\n\\n    /// @notice How many times the user has staked heroes for PVP\\n    /// @dev Max possible value is limited by MAX_NUMBER_STAKES_FOR_USER_PER_EPOCH\\n    uint32 numHeroesStaked;\\n\\n    /// @notice User's guild at the moment of staking\\n    /// 0 if user has no hero staked in pvp currently\\n    uint64 guildId;\\n\\n    /// @notice Total number of pvp-fights performed since the last call of addPvpHero.\\n    /// @dev All pvp-fights are won here because looser is auto removed.\\n    uint8 countFights;\\n\\n    /// @notice Max number of pvp-fights allowed by the user per single call of addPvpHero, 0 - no limits\\n    uint8 maxFights;\\n\\n    /// @notice Unique id of the current pvp-fight (the fight with activeFightIndex1)\\n    uint48 fightId;\\n  }\\n\\n  struct BiomeData {\\n    /// @notice Biome owner - the guild that dominates in the biome at the given epoch. He has a right to get a tax\\n    /// @dev Assume here that uint64 is enough to store any guildId. It allows us to store whole struct in a single slot\\n    uint64 guildBiomeOwnerId;\\n\\n    /// @notice Current epoch (last epoch for which pvp-battle was made)\\n    /// 0 if epoch was never started\\n    uint32 startedEpochWeek;\\n\\n    /// @notice Number of consecutive epochs during which {guildBiomeOwnerId} wasn't changed\\n    uint16 dominationCounter;\\n  }\\n\\n  struct EpochBiomeData {\\n    /// @notice List of guilds asked for domination in the biome => total points scored by the guilds in the given epoch\\n    /// @dev guildId => count points\\n    EnumerableMap.UintToUintMap guildPoints;\\n\\n    /// @notice All users free for pvp-fight\\n    /// User is added here on registration and removed as soon as the fight for the user is initialized.\\n    mapping(uint guildId => EnumerableSet.AddressSet) freeUsers;\\n\\n    /// @notice All users (from the {guilds}) provided heroes for pvp\\n    /// @dev guildId => (user address => packedHero (hero + heroId))\\n    mapping(uint guildId => EnumerableMap.AddressToUintMap) registeredHeroes;\\n\\n    /// @notice The skills and attack type selected in advance\\n    mapping(bytes32 packedHero => bytes) pvpStrategy;\\n  }\\n\\n  enum PvpFightStatus {\\n    /// @notice No fight, the hero doesn't have selected opponent\\n    NOT_INITIALIZED_0,\\n\\n    /// @notice The hero has opponent, the fight is not started\\n    PREPARED_1,\\n\\n    /// @notice The fight is started but not completed\\n    FIGHTING_2,\\n\\n    /// @notice The fight is completed, the hero is the winner\\n    WINNER_3,\\n\\n    /// @notice The fight is completed, the hero is the looser\\n    LOSER_4\\n  }\\n\\n  /// @notice Current state of the fight\\n  /// @dev Implementation assumes that the struct occupies single slot, the struct is read as a whole\\n  /// @dev We don't store biome and guildId here. This info is stored in user state and can be lost after fight ending.\\n  struct PvpFightData {\\n    /// @notice address of user whose hero is the fight opponent\\n    address fightOpponent;\\n\\n    /// @notice Current status of PVP-fight\\n    PvpFightStatus fightStatus;\\n\\n    /// @notice Current value of the health (only when fightStatus is FIGHTING_2)\\n    uint32 health;\\n\\n    /// @notice Current value of the mana (only when fightStatus is FIGHTING_2)\\n    uint32 mana;\\n\\n    /// @notice Number of moves made (only when fightStatus is FIGHTING_2)\\n    uint8 countTurns;\\n  }\\n\\n  /// @dev Implementation assumes that the struct occupies single slot, the struct is read as a whole\\n  struct PvpFightResults {\\n    bool completed;\\n    uint8 totalCountFights;\\n    uint32 healthHero;\\n    uint32 healthOpponent;\\n    uint32 manaConsumedHero;\\n    uint32 manaConsumedOpponent;\\n  }\\n\\n  /// @notice Strategy how to use attack info\\n  enum PvpBehaviourStrategyKinds {\\n    /// @notice Use all skills, use magic attack if it's available\\n    /// @dev {PvpStrategyDefault} is used as data in {addPvpHero}\\n    DEFAULT_STRATEGY_0\\n\\n    // new strategies are able to use different structures to store data passed to {addPvpHero}\\n  }\\n\\n  /// @notice The data provided by user at the staking with {DEFAULT_STRATEGY_0}\\n  struct PvpStrategyDefault {\\n    /// @notice Should be equal to DEFAULT_STRATEGY_0\\n    uint behaviourStrategyKind;\\n    IFightCalculator.AttackInfo attackInfo;\\n  }\\n\\n  struct HeroData {\\n    address hero;\\n    uint heroId;\\n    bytes pvpStrategy;\\n  }\\n\\n  /// ------------------------------------------------------------------------------------------------------------------\\n  /// ------------------------------------------------------------------------------------------------------------------\\n  /// ------------------------------------------------------------------------------------------------------------------\\n\\n  /// @notice Update epoch if necessary and return actual biome owner and tax\\n  /// @return guildId Owner of the biome\\n  /// @return taxPercent Tax percent , [0...100_000], decimals 3\\n  function refreshBiomeTax(uint8 biome) external returns (uint guildId, uint taxPercent);\\n\\n  function isHeroStakedCurrently(address hero, uint heroId) external view returns (bool staked);\\n  function onGuildDeletion(uint guildId) external;\\n}\",\"keccak256\":\"0x9af8cb3a40e61bb50dbb672847272498d5e87f4eca22ff7598dbb48970321ad1\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IReinforcementController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\n/// @notice Terms\\n/// Reinforcement v1: helper is selected randomly in askHero, fixed part of rewards (tokens and NFT) is sent to the helper.\\n/// Guild reinforcement: helper is selected from guild heroes. Rewards are sent to guild bank.\\n/// Reinforcement v2: helper is selected manually in askHeroV2, helper receives fixed amount.\\ninterface IReinforcementController {\\n\\n  enum ConfigParams {\\n    /// @notice Packed MinMaxBoardV2\\n    V2_MIN_MAX_BOARD_0\\n  }\\n\\n  /// @custom:storage-location erc7201:reinforcement.controller.main\\n  struct MainState {\\n\\n    // ------------------------ Reinforcement v1\\n\\n    /// @dev minLvl8 + minLifeChances8\\n    bytes32 config;\\n    /// @dev hero token + hero id => heroInfo(biome8 + score128 + fee8 + stakeTs64)\\n    mapping(bytes32 => bytes32) _stakedHeroes;\\n    /// @dev biome => helperAdr+id\\n    mapping(uint => EnumerableSet.Bytes32Set) _internalIdsByBiomes;\\n    /// @dev biome => score  // The field is deprecated and not updated any more\\n    mapping(uint => uint) maxScore;\\n    /// @dev heroAdr+id => itemAdr+id\\n    mapping(bytes32 => bytes32[]) _heroNftRewards;\\n    /// @dev heroAdr+id => tokenAdr and amount map\\n    mapping(bytes32 => EnumerableMap.AddressToUintMap) _heroTokenRewards;\\n\\n\\n    // ------------------------ Guild reinforcement\\n\\n    /// @notice All staked guild heroes for the given guild\\n    /// @dev helper (hero token + hero id) => guild\\n    mapping(bytes32 packedHero => uint guildId) stakedGuildHeroes;\\n\\n    /// @notice All guild heroes that are currently in use by guild reinforcement\\n    /// It's allowed to withdraw a hero before reinforcement releasing,\\n    /// so it's possible to have !0 in {guildBusyHelpers} and 0 in {stakedGuildHeroes} simultaneously.\\n    /// @dev helper (hero token + hero id) => guildId (guild at the moment of askGuildReinforcement)\\n    mapping(bytes32 packedHero => uint guildId) busyGuildHelpers;\\n\\n    /// @notice All (free and busy) staked guild heroes per guild.\\n    /// guild => (packed helper => guild where the helper is busy currently)\\n    /// @dev There is a chance that guilds are different here\\n    /// i.e. hero can be:\\n    /// 1) added to G1 2) staked in G1 3) asked for help 4) withdrawn 5) G1=>G2 6) staked in G2\\n    /// In such case guildHelpers[G2][hero] = G1, guildHelpers[G1][hero] = 0\\n    /// After releasing guildHelpers[G2][hero] = 0\\n    mapping(uint guildId => EnumerableMap.Bytes32ToUintMap) guildHelpers;\\n\\n    /// @notice Moment of withdrawing the hero from staking. Next staking is possible in 1 day since withdrawing\\n    mapping(bytes32 packedHero => uint lastWithdrawTimestamp) lastGuildHeroWithdrawTs;\\n\\n\\n    // ------------------------ Reinforcement v2\\n    /// @notice Map to store various config params\\n    mapping(ConfigParams paramId => uint) configParams;\\n\\n    mapping(bytes32 packedHero => HeroInfoV2) stakedHeroesV2;\\n\\n    /// @notice biome => set of packedHero. All staked heroes (they can be busy of free currently)\\n    mapping(uint biome => EnumerableSet.Bytes32Set) heroesByBiomeV2;\\n\\n    mapping(uint biome => LastWindowsV2) stat24hV2;\\n  }\\n\\n  /// @notice Deprecated. Reinforcement v1\\n  struct HeroInfo {\\n    uint8 biome;\\n    uint score; // stored in 128 but easy to use 256\\n    /// @notice To helper ratio\\n    uint8 fee;\\n    uint64 stakeTs;\\n  }\\n\\n  struct HeroInfoV2 {\\n    uint8 biome;\\n    uint64 stakeTs;\\n    /// @notice Amount of game token that is paid to the helper at the moment of the call {askHeroV2}\\n    uint128 rewardAmount;\\n  }\\n\\n  /// @notice Statistic of askHeroV2 calls per last 24 hours at the moment of the last call\\n  struct LastWindowsV2 {\\n    /// @notice 24 hours are divided on 8 intervals, each interval is 3 hour\\n    /// Current basket has index {basketIndex}\\n    /// {baskets[current basket]} contains \\\"old\\\" value.\\n    /// New value for the current basket is collected in {basketValue}.\\n    /// The value for the current basket is calculated as weighted average of old and new values.\\n    /// New value replaces the old value at the moment of changing current basket index.\\n    uint24[8] baskets;\\n    /// @notice New value (hits counter) for current basket\\n    uint24 basketValue;\\n    /// @notice Abs. index of the current basket (abs. hour / 3)\\n    uint48 basketIndex;\\n  }\\n\\n  /// @dev 1 slot\\n  struct ConfigReinforcementV2 {\\n    /// @notice if Number-of-askHeroV2-calls is below given value then burn fee has min value\\n    uint32 minNumberHits;\\n    /// @notice if Number-of-askHeroV2-calls is above given value then burn fee has max value\\n    uint32 maxNumberHits;\\n    /// @notice Lowest fee = amountForDungeon / given value, i.e. 100 => amountForDungeon/100 as lower fee\\n    uint32 lowDivider;\\n    /// @notice Highest fee = amountForDungeon / given value, i.e. 2 => amountForDungeon/2 as highest fee\\n    uint32 highDivider;\\n    /// @notice Limit for min level of the staked hero\\n    /// In practice we need following limitation: (stats.level < 5 || (stats.level - 5) / 5 < biome)\\n    /// so, levelLimit should be equal 5\\n    /// In tests we need to be able to disable such limitation, so levelLimit = 0 allow to disable that constraint\\n    uint8 levelLimit;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function toHelperRatio(address heroToken, uint heroId) external view returns (uint);\\n\\n  function isStaked(address heroToken, uint heroId) external view returns (bool);\\n\\n  function registerTokenReward(address heroToken, uint heroId, address token, uint amount, uint64 dungeonId) external;\\n\\n  function registerNftReward(address heroToken, uint heroId, address token, uint tokenId, uint64 dungeonId) external;\\n\\n  function askHeroV2(address hero, uint heroId, address helper, uint helperId) external returns (int32[] memory attributes);\\n\\n  function askGuildHero(address hero, uint heroId, address helper, uint helperId) external returns (int32[] memory attributes);\\n\\n  /// @notice Return the guild in which the hero is currently asked for guild reinforcement\\n  function busyGuildHelperOf(address heroToken, uint heroId) external view returns (uint guildId);\\n\\n  function releaseGuildHero(address helperHeroToken, uint helperHeroTokenId) external;\\n}\",\"keccak256\":\"0x4c0227232dde2f6406173c12e97a02238d7703ee2d1d71342f937ed60b80288c\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IRewardsPool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IRewardsPool {\\n\\n  /// @custom:storage-location erc7201:rewards.pool.main\\n  struct MainState {\\n    mapping(address token => uint baseAmountValue) baseAmounts;\\n  }\\n\\n  function balanceOfToken(address token) external view returns (uint);\\n\\n  function rewardAmount(address token, uint maxBiome, uint maxNgLevel, uint biome, uint heroNgLevel) external view returns (uint);\\n\\n  function sendReward(address token, uint rewardAmount_, address receiver) external;\\n\\n  function lostProfitPercent(uint maxBiome, uint maxNgLevel, uint heroNgLevel) external view returns (uint percent);\\n}\\n\",\"keccak256\":\"0x1059791209fc6106767c7c2d894b38a08ef2d806eff084b07f663d25fdf18609\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStatController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IStatController {\\n\\n  /// @custom:storage-location erc7201:stat.controller.main\\n  struct MainState {\\n    mapping(bytes32 => bytes32[]) heroTotalAttributes;\\n    /// @dev heroAdr+heroId => int32 packed strength, dexterity, vitality, energy\\n    mapping(bytes32 => bytes32) _heroCore;\\n    mapping(bytes32 => bytes32[]) heroBonusAttributes;\\n    mapping(bytes32 => bytes32[]) heroTemporallyAttributes;\\n    /// @dev heroAdr+heroId => uint32 packed level, experience, life, mana, lifeChances\\n    mapping(bytes32 => bytes32) heroStats;\\n    /// @dev heroAdr+heroId+itemSlot => itemAdr + itemId\\n    mapping(bytes32 => bytes32) heroSlots;\\n    /// @dev heroAdr+heroId => busy slots uint8[] packed\\n    mapping(bytes32 => bytes32) heroBusySlots;\\n    mapping(bytes32 => EnumerableSet.AddressSet) usedConsumables;\\n    /// @dev heroCustomDataV2 is used instead\\n    mapping(bytes32 => mapping(bytes32 => uint)) _deprecated_heroCustomData;\\n    mapping(bytes32 => uint) globalCustomData;\\n\\n    /// @notice packNftIdWithValue(hero, heroId, ngLevel) => hero custom data map\\n    /// @dev initially it was packedHero => hero custom data map\\n    mapping(bytes32 => EnumerableMap.Bytes32ToUintMap) heroCustomDataV2;\\n  }\\n\\n\\n  enum ATTRIBUTES {\\n    // core\\n    STRENGTH, // 0\\n    DEXTERITY, // 1\\n    VITALITY, // 2\\n    ENERGY, // 3\\n    // attributes\\n    DAMAGE_MIN, // 4\\n    DAMAGE_MAX, // 5\\n    ATTACK_RATING, // 6\\n    DEFENSE, // 7\\n    BLOCK_RATING, // 8\\n    LIFE, // 9\\n    MANA, // 10\\n    // resistance\\n    FIRE_RESISTANCE, // 11\\n    COLD_RESISTANCE, // 12\\n    LIGHTNING_RESISTANCE, // 13\\n    // dmg against\\n    DMG_AGAINST_HUMAN, // 14\\n    DMG_AGAINST_UNDEAD, // 15\\n    DMG_AGAINST_DAEMON, // 16\\n    DMG_AGAINST_BEAST, // 17\\n\\n    // defence against\\n    DEF_AGAINST_HUMAN, // 18\\n    DEF_AGAINST_UNDEAD, // 19\\n    DEF_AGAINST_DAEMON, // 20\\n    DEF_AGAINST_BEAST, // 21\\n\\n    // --- unique, not augmentable\\n    // hero will not die until have positive chances\\n    LIFE_CHANCES, // 22\\n    // increase chance to get a better item\\n    MAGIC_FIND, // 23\\n    // decrease chance to get an item\\n    DESTROY_ITEMS, // 24\\n    // percent of chance x2 dmg\\n    CRITICAL_HIT, // 25\\n    // dmg factors\\n    MELEE_DMG_FACTOR, // 26\\n    FIRE_DMG_FACTOR, // 27\\n    COLD_DMG_FACTOR, // 28\\n    LIGHTNING_DMG_FACTOR, // 29\\n    // increase attack rating on given percent\\n    AR_FACTOR, // 30\\n    // percent of damage will be converted to HP\\n    LIFE_STOLEN_PER_HIT, // 31\\n    // amount of mana restored after each battle\\n    MANA_AFTER_KILL, // 32\\n    // reduce all damage on percent after all other reductions\\n    DAMAGE_REDUCTION, // 33\\n\\n    // -- statuses\\n    // chance to stun an enemy, stunned enemy skip next hit\\n    STUN, // 34\\n    // chance burn an enemy, burned enemy will loss 50% of defence\\n    BURN, // 35\\n    // chance freeze an enemy, frozen enemy will loss 50% of MELEE damage\\n    FREEZE, // 36\\n    // chance to reduce enemy's attack rating on 50%\\n    CONFUSE, // 37\\n    // chance curse an enemy, cursed enemy will loss 50% of resistance\\n    CURSE, // 38\\n    // percent of dmg return to attacker\\n    REFLECT_DAMAGE_MELEE, // 39\\n    REFLECT_DAMAGE_MAGIC, // 40\\n    // chance to poison enemy, poisoned enemy will loss 10% of the current health\\n    POISON, // 41\\n    // reduce chance get any of uniq statuses\\n    RESIST_TO_STATUSES, // 42\\n\\n    END_SLOT // 43\\n  }\\n\\n  // possible\\n  // HEAL_FACTOR\\n\\n  struct CoreAttributes {\\n    int32 strength;\\n    int32 dexterity;\\n    int32 vitality;\\n    int32 energy;\\n  }\\n\\n  struct ChangeableStats {\\n    uint32 level;\\n    uint32 experience;\\n    uint32 life;\\n    uint32 mana;\\n    uint32 lifeChances;\\n  }\\n\\n  enum ItemSlots {\\n    UNKNOWN, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    BOOTS, // 6\\n    RIGHT_RING, // 7\\n    LEFT_RING, // 8\\n    RIGHT_HAND, // 9\\n    LEFT_HAND, // 10\\n    TWO_HAND, // 11\\n    SKILL_1, // 12\\n    SKILL_2, // 13\\n    SKILL_3, // 14\\n    END_SLOT // 15\\n  }\\n\\n  struct NftItem {\\n    address token;\\n    uint tokenId;\\n  }\\n\\n  enum Race {\\n    UNKNOWN, // 0\\n    HUMAN, // 1\\n    UNDEAD, // 2\\n    DAEMON, // 3\\n    BEAST, // 4\\n    END_SLOT // 5\\n  }\\n\\n  struct ChangeAttributesInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    int32[] changeAttributes;\\n    bool add;\\n    bool temporally;\\n  }\\n\\n  struct BuffInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    uint32 heroLevel;\\n    address[] buffTokens;\\n    uint[] buffTokenIds;\\n  }\\n\\n  /// @dev This struct is used inside event, so it's moved here from lib\\n  struct EventActionInfo {\\n    int32[] posAttributes;\\n    int32[] negAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintedItems;\\n  }\\n\\n  function initNewHero(address token, uint tokenId, uint heroClass) external;\\n\\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory);\\n\\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32);\\n\\n  function heroAttributesLength(address token, uint tokenId) external view returns (uint);\\n\\n  function heroBaseAttributes(address token, uint tokenId) external view returns (CoreAttributes memory);\\n\\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint);\\n\\n  function globalCustomData(bytes32 index) external view returns (uint);\\n\\n  function heroStats(address token, uint tokenId) external view returns (ChangeableStats memory);\\n\\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked);\\n\\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory);\\n\\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function levelUp(address token, uint tokenId, uint heroClass, CoreAttributes memory change) external returns (uint newLvl);\\n\\n  function changeHeroItemSlot(\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) external;\\n\\n  function changeCurrentStats(\\n    address token,\\n    uint tokenId,\\n    ChangeableStats memory change,\\n    bool increase\\n  ) external;\\n\\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external;\\n\\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external;\\n\\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external;\\n\\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external;\\n\\n  function buffHero(BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed);\\n\\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external;\\n\\n  function setGlobalCustomData(bytes32 index, uint value) external;\\n\\n  /// @notice Restore life and mana during reinforcement\\n  /// @dev Life and mana will be increased on ((current life/mana attr value) - (prev life/mana attr value))\\n  /// @param prevAttributes Hero attributes before reinforcement\\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external;\\n\\n  function reborn(address heroToken, uint heroTokenId, uint heroClass) external;\\n}\\n\",\"keccak256\":\"0xca4609984b969cbff0b3c4c899f16b1deedb0458a1f8f63905b69aecf63157e4\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStoryController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../lib/ControllerContextLib.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\nimport \\\"./IHeroController.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n\\ninterface IStoryController {\\n\\n  enum AnswerResultId {\\n    UNKNOWN, // 0\\n    SUCCESS, // 1\\n    ATTRIBUTE_FAIL, // 2\\n    RANDOM_FAIL, // 3\\n    DELAY_FAIL, // 4\\n    HERO_CUSTOM_DATA_FAIL, // 5\\n    GLOBAL_CUSTOM_DATA_FAIL, // 6\\n\\n    END_SLOT\\n  }\\n\\n  enum CustomDataResult {\\n    UNKNOWN, // 0\\n    HERO_SUCCESS, // 1\\n    HERO_FAIL, // 2\\n    GLOBAL_SUCCESS, // 3\\n    GLOBAL_FAIL, // 4\\n\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:story.controller.main\\n  struct MainState {\\n\\n    // --- STORY REG INFO ---\\n\\n    /// @dev Uniq story identification.\\n    mapping(uint32 => uint16) storyIds;\\n    /// @dev Revers mapping for stories for using in the next object rewrite logic.\\n    mapping(uint16 => uint32) idToStory;\\n    /// @dev Store used ids for stories.\\n    mapping(uint16 => bool) _usedStoryIds;\\n    /// @dev Prevent register the story twice\\n    mapping(uint32 => bool) registeredStories;\\n\\n    // --- ANSWER MAPPING ---\\n\\n    /// @dev storyId => all story pages. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.UintSet) allStoryPages;\\n\\n    /// @dev storyId => all possible answers. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.Bytes32Set) allStoryAnswers;\\n\\n    /// @dev storyId + pageId + heroClass (zero is default answers) => storyId + pageId + heroClass (zero is default answers) + answerId\\n    mapping(bytes32 => bytes32[]) answers;\\n    /// @dev answerUnPackedId + answerResultId => nextPageIds (will be chosen randomly from this array)\\n    ///      where answerResultId is:\\n    ///      0 - unknown,\\n    ///      1 - success,\\n    ///      2 - attr fail\\n    ///      3 - random fail\\n    ///      4 - delay fail\\n    ///      5 - hero custom data fail\\n    ///      6 - global custom data fail\\n    ///      see COUNT_ANSWER_RESULT_IDS\\n    mapping(bytes32 => uint16[]) nextPageIds;\\n    /// @dev story + pageId + heroClass (zero is default answers) => random nextObjs (adr + id, like packed nft id)\\n    mapping(bytes32 => uint32[]) nextObjectsRewrite;\\n\\n    /// @dev answerPackedId => packed array of uint32[]\\n    ///      0 - random requirement(uint32, 1 - 99% success of this action, zero means no check)\\n    ///      1 - delay requirement(uint32, if time since the last call more than this value the check is fail, zero means no check)\\n    ///      2 - isFinalAnswer(uint8)\\n    mapping(bytes32 => bytes32) answerAttributes;\\n\\n    // --- ANSWER REQUIREMENTS ---\\n\\n    /// @dev answerPackedId => array of AttributeRequirementsPacked\\n    mapping(bytes32 => bytes32[]) attributeRequirements;\\n    /// @dev answerPackedId=> array of ItemRequirementsPacked\\n    mapping(bytes32 => bytes32[]) itemRequirements;\\n    /// @dev answerPackedId => array of TokenRequirementsPacked\\n    mapping(bytes32 => bytes32[]) tokenRequirements;\\n    /// @dev answerPackedId => custom data for hero\\n    mapping(bytes32 => CustomDataRequirementPacked[]) heroCustomDataRequirement;\\n    /// @dev answerPackedId => global custom data\\n    mapping(bytes32 => CustomDataRequirementPacked[]) globalCustomDataRequirement;\\n\\n    // --- ANSWER RESULTS ---\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) successInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) successInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) successInfoMintItems;\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) failInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) failInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) failInfoMintItems;\\n\\n    /// @dev answerUnPackedId + CustomDataResult => custom data array change\\n    ///      where CustomDataResult is\\n    ///      1 - hero success\\n    ///      2 - hero fail\\n    ///      3 - global success\\n    ///      4 - global fail\\n    ///      see COUNT_CUSTOM_DATA_RESULT_IDS\\n    mapping(bytes32 => bytes32[]) customDataResult;\\n\\n    /// @notice answerPackedId => slot+chance+stopIfBurnt\\n    /// @dev Since SIP-003 the items are not burn but broke\\n    mapping(bytes32 => bytes32[]) burnItem;\\n\\n    // --- GENERAL STORY REQUIREMENTS ---\\n\\n    /// @dev story => Custom hero data requirements for a story. If exist and hero is not eligible should be not chose in a dungeon.\\n    mapping(uint => CustomDataRequirementRangePacked[]) storyRequiredHeroData;\\n    /// @dev story => Minimal level for the history. 0 means no requirements.\\n    mapping(uint => uint) storyRequiredLevel;\\n\\n    // --- HERO STATES ---\\n\\n    /// @dev hero + heroId + storyId => pageId + heroLastActionTS\\n    mapping(bytes32 => bytes32) heroState;\\n\\n    // --- OTHER ---\\n\\n    /// @dev storyId => build hash for the last update\\n    mapping(uint16 => uint) storyBuildHash;\\n\\n    /// @notice Number of already minted items by the user within the given iteration of the story.\\n    /// Only minting of the given number of items is allowed per iteration (see MAX_MINTED_ITEMS_PER_ITERATION).\\n    /// @dev hero, heroId, story => mintedInIteration\\n    /// This map is not cleared: storyId:objectId is 1:1, each object has own sequence of iterations without duplicates\\n    mapping(bytes32 => mapping(uint iteration => uint countMintedItems)) mintedInIteration;\\n\\n    /// @notice True if the story is allowed to be skipped, see SCR-1248\\n    EnumerableSet.UintSet skippableStory;\\n  }\\n\\n  /// @dev We need to have flat structure coz Solidity can not handle arrays of structs properly\\n  struct StoryMetaInfo {\\n    uint16 storyId;\\n\\n    // --- story reqs\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n    uint minLevel;\\n\\n    // --- answer reqs\\n\\n    AnswersMeta answersMeta;\\n    AnswerNextPageMeta answerNextPage;\\n    AnswerAttributeRequirementsMeta answerAttributeRequirements;\\n    AnswerItemRequirementsMeta answerItemRequirements;\\n    AnswerTokenRequirementsMeta answerTokenRequirements;\\n    AnswerAttributesMeta answerAttributes;\\n    AnswerCustomDataMeta answerHeroCustomDataRequirement;\\n    AnswerCustomDataMeta answerGlobalCustomDataRequirement;\\n\\n    // --- answer results\\n\\n    AnswerBurnRandomItemMeta answerBurnRandomItemMeta;\\n    NextObjRewriteMeta nextObjRewriteMeta;\\n\\n    // --- story results\\n\\n    AnswerResultMeta successInfo;\\n    AnswerResultMeta failInfo;\\n\\n    AnswerCustomDataResultMeta successHeroCustomData;\\n    AnswerCustomDataResultMeta failHeroCustomData;\\n    AnswerCustomDataResultMeta successGlobalCustomData;\\n    AnswerCustomDataResultMeta failGlobalCustomData;\\n  }\\n\\n  struct NextObjRewriteMeta {\\n    uint16[] nextObjPageIds;\\n    uint8[] nextObjHeroClasses;\\n    uint32[][] nextObjIds;\\n  }\\n\\n  struct AnswersMeta {\\n    uint16[] answerPageIds;\\n    uint8[] answerHeroClasses;\\n    uint16[] answerIds;\\n  }\\n\\n  struct AnswerNextPageMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint8[] answerResultIds;\\n    uint16[][] answerNextPageIds;\\n  }\\n\\n  struct AnswerAttributeRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    bool[][] cores;\\n    uint8[][] ids;\\n    int32[][] values;\\n  }\\n\\n  struct AnswerItemRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireItems;\\n    bool[][] requireItemBurn;\\n    bool[][] requireItemEquipped;\\n  }\\n\\n  struct AnswerTokenRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireToken;\\n    uint88[][] requireAmount;\\n    bool[][] requireTransfer;\\n  }\\n\\n  struct AnswerAttributesMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint32[] randomRequirements;\\n    uint32[] delayRequirements;\\n    bool[] isFinalAnswer;\\n  }\\n\\n  struct AnswerCustomDataMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    bool[][] mandatory;\\n    uint64[][] dataValuesMin;\\n    uint64[][] dataValuesMax;\\n  }\\n\\n  struct AnswerResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    uint8[][] attributeIds;\\n    /// @dev Max value is limitied by int24, see toBytes32ArrayWithIds impl\\n    int32[][] attributeValues;\\n\\n    uint32[] experience;\\n    int32[] heal;\\n    int32[] manaRegen;\\n    int32[] lifeChancesRecovered;\\n    int32[] damage;\\n    int32[] manaConsumed;\\n\\n    address[][] mintItems;\\n    uint32[][] mintItemsChances;\\n  }\\n\\n  struct AnswerCustomDataResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    int16[][] dataValues;\\n  }\\n\\n  struct AnswerBurnRandomItemMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    /// @notice 0 - random slot\\n    uint8[][] slots;\\n    /// @notice typical chances are [0..100] (no decimals here)\\n    uint64[][] chances;\\n    /// @notice Since SIP-003 the burning is replaced by breaking bu the name is kept as is\\n    bool[][] isStopIfBurnt;\\n  }\\n\\n  struct CustomDataRequirementPacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + mandatory(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct CustomDataRequirementRangePacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + isHeroData(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct StatsChange {\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n  }\\n\\n  struct StoryActionContext {\\n    uint stageId;\\n    uint iteration;\\n    bytes32 answerIdHash;\\n    bytes32 answerAttributes;\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IOracle oracle;\\n    uint8 heroClassFromAnswerHash;\\n    uint8 biome;\\n    uint16 storyId;\\n    uint16 storyIdFromAnswerHash;\\n    uint16 pageIdFromAnswerHash;\\n    uint16 answerNumber;\\n    uint16 pageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint40 heroLastActionTS;\\n    uint80 heroTokenId;\\n    IStatController.ChangeableStats heroStats;\\n  }\\n\\n  // --- WRITE ---\\n\\n  function storyAction(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) external returns (IGOC.ActionResult memory);\\n\\n  // --- READ ---\\n\\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function idToStory(uint16 id) external view returns (uint32 objectId);\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId);\\n\\n  function storyIds(uint32 objectId) external view returns (uint16);\\n\\n  function registeredStories(uint32 objectId) external view returns (bool);\\n\\n  function skippableStory(uint16 storyId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xeac9e7fe282320b84466c974533f30b7e4c96b8ce94d40a63ef394928059bc4a\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/ITreasury.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface ITreasury {\\n\\n  function balanceOfToken(address token) external view returns (uint);\\n\\n  function sendToDungeon(address dungeon, address token, uint amount) external;\\n}\\n\",\"keccak256\":\"0x0977372e2310cd09e7b99c5f2b1af75949bf18ebcabfd0fc114e4f8714760414\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IUserController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IUserController {\\n\\n  //region ------------------------ Data types\\n\\n  enum LootBoxKind {\\n    /// @notice small loot box - reward for the daily activity\\n    DAILY_0,\\n    /// @notice large loot box - reward for the weekly activity (daily activity is passed each ot of the 7 days)\\n    WEEKLY_1,\\n\\n    END_SLOT\\n  }\\n\\n  /// @dev registerPassedDungeon assumes that the whole struct takes single slot only, not more\\n  struct UserActivity {\\n    /// @notice A day for which the daily activity is calculated (see counterXXX below)\\n    /// The number of days since 1970-01-01\\n    uint32 epochDay;\\n\\n    /// @notice A week for which total count of daily activities were calculated\\n    /// The number of weeks since (1970-01-01 Thursday) - 3 days = (1969-12-29 Monday)\\n    uint32 epochWeek;\\n\\n    /// @notice Count of dungeons passed during the day\\n    uint32 counterPassedDungeons;\\n    /// @notice Count of PvP during the day\\n    uint32 counterPvp;\\n\\n    /// @notice Count of daily activities completed per the week\\n    uint16 dailyActivities;\\n\\n    /// @notice Daily activity is completed and small loot box is added to the earned loot boxes\\n    bool dailyLootBoxReceived;\\n    /// @notice Weekly activity is completed and large loot box is added to the earned loot boxes\\n    bool weeklyLootBoxReceived;\\n  }\\n\\n  struct EarnedLootBoxes {\\n    /// @notice Count of loot boxes earned by daily activity\\n    uint32 dailyCounter;\\n    /// @notice Count of loot boxes earned by weekly activity\\n    uint32 weeklyCounter;\\n  }\\n\\n  struct LootBoxConfig {\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n    uint maxDropItems;\\n  }\\n\\n  enum UserControllerParam {\\n    /// @notice Price of story skipping in game points\\n    PRICE_STORY_SKIPPING_1\\n  }\\n\\n  /// @custom:storage-location erc7201:user.controller.main\\n  struct MainState {\\n    /// @notice Amount of sacra required to rename user account\\n    uint feeRenaming;\\n\\n    /// @dev user EOA => account name\\n    mapping(address => string) userAccountName;\\n\\n    /// @dev name => user EOA, needs for checking uniq names\\n    mapping(string => address) nameToUserAccount;\\n\\n    /// @notice user => daily activity info\\n    mapping(address => UserActivity) userActivity;\\n\\n    /// @notice user => earned loot boxes\\n    mapping(address => EarnedLootBoxes) counterLootBoxes;\\n\\n    /// @notice Configs of loot boxes of various kinds\\n    mapping(LootBoxKind => LootBoxConfig) lootBoxConfig;\\n\\n    /// @dev Deprecated, controller is used instead.\\n    address userTokensVault;\\n\\n    /// @dev user EOA => account avatar\\n    mapping(address => string) userAvatar;\\n\\n    // @notice Hall of Fame: ngLevel [1...99] => who opened the NG_LEVEL first\\n    mapping(uint8 ngLevel => FameHallData) fameHall;\\n\\n    /// @notice Points earned for passing dungeons\\n    mapping(address user => uint gamePoints) gamePoints;\\n\\n    /// @notice List of objects (currently only stories) passed by the given account\\n    /// @dev hashes of the stories are as encodePacked(\\\"STORY_{ID}\\\")\\n    mapping(address user => EnumerableSet.Bytes32Set hashes) passedObjects;\\n\\n    /// @notice Values of various params, see {UserControllerParam}\\n    mapping(UserControllerParam paramId => uint value) userControllerParams;\\n  }\\n\\n  struct FameHallData {\\n    // ------------ slot 1\\n    /// @notice The hero who opened given the NG_LEVEL first\\n    address hero;\\n    uint64 heroId;\\n    // ------------ slot 2\\n    /// @notice The owner of the hero\\n    address heroOwner;\\n    /// @notice Timestamp of the moment of the opening given NG_LEVEL\\n    uint64 tsOpen;\\n  }\\n\\n  //endregion ------------------------ Data types\\n\\n  /// @notice Register daily activity - a dungeon was passed\\n  /// @param user Owner of the hero who has passed the dungeon\\n  function registerPassedDungeon(address user) external;\\n\\n  /// @notice Register daily activity - PvP was made\\n  /// @param user Owner of the hero who has taken participation in the PvP\\n  function registerPvP(address user, bool isWinner) external;\\n\\n  function registerFameHallHero(address hero, uint heroId, uint8 openedNgLevel) external;\\n\\n  function useGamePointsToSkipStore(address user, uint16 storyId) external;\\n\\n  function setStoryPassed(address user, uint16 storyId) external;\\n\\n  function isStoryPassed(address user, uint16 storyId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa6cb408a8c73afc71c4ebee178257123ee65ed09fb96c2a806b5a83e0dac2140\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IXmyrdGauge.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\n/// @notice Restored from 0x889677E6d07D22a53dac907d204ecBB08E38B529 (sonic)\\ninterface IXMyrdGauge {\\n  function CONTROLLABLE_VERSION() external view returns (string memory);\\n\\n  function MULTI_POOL_VERSION() external view returns (string memory);\\n\\n  function REWARDS_PERIOD() external view returns (uint256);\\n\\n  function VERSION() external view returns (string memory);\\n\\n  function activePeriod() external view returns (uint256);\\n\\n  function addStakingToken(address) external pure;\\n\\n  function balanceOf(address, address) external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function defaultRewardToken() external view returns (address);\\n\\n  function derivedBalance(address stakingToken, address account) external view returns (uint256);\\n\\n  function derivedBalances(address, address) external view returns (uint256);\\n\\n  function derivedSupply(address) external view returns (uint256);\\n\\n  function duration() external view returns (uint256);\\n\\n  function earned(address stakingToken, address rewardToken, address account) external view returns (uint256);\\n\\n  function getAllRewards(address account) external;\\n\\n  function getPeriod() external view returns (uint256);\\n\\n  function getReward(address account, address[] memory tokens) external;\\n\\n  function handleBalanceChange(address account) external;\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n  function init(address controller_, address xMyrd_, address myrd_ ) external;\\n\\n  function isController(address value_) external view returns (bool);\\n\\n  function isGovernance(address value_) external view returns (bool);\\n\\n  function isRewardToken(address, address) external view returns (bool);\\n\\n  function isStakeToken(address token) external view returns (bool);\\n\\n  function lastTimeRewardApplicable(address stakingToken, address rewardToken) external view returns (uint256);\\n\\n  function lastUpdateTime(address, address) external view returns (uint256);\\n\\n  function left(address stakingToken, address rewardToken) external view returns (uint256);\\n\\n  function notifyRewardAmount(address token, uint256 amount) external;\\n\\n  function periodFinish(address, address) external view returns (uint256);\\n\\n  function previousImplementation() external view returns (address);\\n\\n  function registerRewardToken(address stakeToken, address rewardToken) external;\\n\\n  function removeRewardToken(address stakeToken, address rewardToken) external;\\n\\n  function revision() external view returns (uint256);\\n\\n  function rewardPerToken(address stakingToken, address rewardToken) external view returns (uint256);\\n\\n  function rewardPerTokenStored(address, address) external view returns (uint256);\\n\\n  function rewardRate(address, address) external view returns (uint256);\\n\\n  function rewardTokens(address, uint256) external view returns (address);\\n\\n  function rewardTokensLength(address token) external view returns (uint256);\\n\\n  function rewards(address, address, address) external view returns (uint256);\\n\\n  function rewardsRedirect(address) external view returns (address);\\n\\n  function setRewardsRedirect(address account, address recipient) external;\\n\\n  function totalSupply(address) external view returns (uint256);\\n\\n  function updatePeriod(uint256 amount_) external;\\n\\n  function userRewardPerTokenPaid(address, address, address) external view returns (uint256);\\n\\n  function xMyrd() external view returns (address);\\n}\",\"keccak256\":\"0x5f1f8c053adfa7c990c8aa384dfdf9631929ac01ced517820ba1ba6946419990\",\"license\":\"BUSL-1.1\"},\"contracts/lib/AppLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\n\\n/// @notice Common internal utils, shared constants\\nlibrary AppLib {\\n\\n  /// @notice Biome owner has the right to receive 1% tax on any income in the biome. Decimals 3.\\n  /// The final value of tax is in the range [1..10]%, it depends on total liquidity staked by the guild\\n  uint internal constant BIOME_TAX_PERCENT_MIN = 1_000; // 1%\\n\\n  /// @notice Max possible value of biome owner tax percent, decimals 3.\\n  uint internal constant BIOME_TAX_PERCENT_MAX = 10_000; // 10%\\n\\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\\n  /// @dev Should NOT be used for third-party pools\\n  function approveIfNeeded(address token, uint amount, address spender) internal {\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\n      IERC20(token).approve(spender, type(uint).max);\\n    }\\n  }\\n\\n  /// @dev Remove from array the item with given id and move the last item on it place\\n  ///      Use with mapping for keeping indexes in correct ordering\\n  function removeIndexed(\\n    uint256[] storage array,\\n    mapping(uint256 => uint256) storage indexes,\\n    uint256 id\\n  ) internal {\\n    uint256 lastId = array[array.length - 1];\\n    uint256 index = indexes[id];\\n    indexes[lastId] = index;\\n    indexes[id] = type(uint256).max;\\n    array[index] = lastId;\\n    array.pop();\\n  }\\n\\n  /// @notice Return a-b OR zero if a < b\\n  function sub0(uint32 a, uint32 b) internal pure returns (uint32) {\\n    return a > b ? a - b : 0;\\n  }\\n\\n  /// @notice Adjust the dungeon completion reward based on the hero's NG level\\n  function _getAdjustedReward(uint amount, uint heroNgLevel) internal pure returns (uint) {\\n    uint rewardPercent = heroNgLevel == 0\\n      ? 40\\n      : heroNgLevel == 1\\n        ? 60\\n        : heroNgLevel == 2\\n            ? 80\\n            : 100;\\n    return amount * rewardPercent / 100;\\n  }\\n\\n  function _ownerOf(address hero, uint heroId) internal view returns (address) {\\n    return IERC721(hero).ownerOf(heroId);\\n  }\\n\\n}\\n\",\"keccak256\":\"0x549836c3629c94eb241b75fff88fa107bb4284ba58bd96a54a2848266efb7c2b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ControllerContextLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\nimport \\\"../interfaces/IDungeonFactory.sol\\\";\\nimport \\\"../interfaces/IReinforcementController.sol\\\";\\nimport \\\"../interfaces/IGameToken.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IUserController.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IRewardsPool.sol\\\";\\nimport \\\"../interfaces/IPvpController.sol\\\";\\nimport \\\"../interfaces/IItemBoxController.sol\\\";\\n\\n/// @notice Provide context-struct with all controller addresses and routines for lazy init\\n/// Usage:\\n///       Create an instance of the structure\\n///               cc = ControllerContextLib.init(controller);\\n///       access controller directly\\n///               cc.controller.xxx();\\n///       access other contracts indirectly\\n///               sc = ControllerContextLib.statController(cc);\\nlibrary ControllerContextLib {\\n  //region ----------------- Data types\\n  enum CacheIndex {\\n    STAT_CONTROLLER_0,\\n    STORY_CONTROLLER_1,\\n    ORACLE_2,\\n    TREASURY_3,\\n    DUNGEON_FACTORY_4,\\n    GOC_5,\\n    REINFORCEMENT_CONTROLLER_6,\\n    ITEM_CONTROLLER_7,\\n    HERO_CONTROLLER_8,\\n    GAME_TOKEN_9,\\n    USER_CONTROLLER_10,\\n    GUILD_CONTROLLER_11,\\n    PVP_CONTROLLER_12,\\n    REWARDS_POOL_13,\\n    ITEM_BOX_CONTROLLER_14\\n  }\\n\\n  uint constant private CACHE_SIZE = 15;\\n\\n  struct ControllerContext {\\n    /// @notice Direct access to the controller\\n    IController controller;\\n\\n    /// @notice All lazy-initialized addresses in order of {CacheIndex}\\n    address[CACHE_SIZE] cache;\\n  }\\n  //endregion ----------------- Data types\\n\\n  //region ----------------- Initialization and _lazyInit\\n  function init(IController controller) internal pure returns (ControllerContext memory cc) {\\n    cc.controller = controller;\\n    return cc;\\n  }\\n\\n  function _lazyInit(\\n    ControllerContext memory cc,\\n    CacheIndex index,\\n    function () external view returns(address) getter\\n  ) internal view returns (address) {\\n    address a = cc.cache[uint(index)];\\n    if (a != address(0)) return a;\\n\\n    cc.cache[uint(index)] = getter();\\n    return cc.cache[uint(index)];\\n  }\\n  //endregion ----------------- Initialization and _lazyInit\\n\\n  //region ----------------- Access with lazy initialization\\n  function statController(ControllerContext memory cc) internal view returns (IStatController) {\\n    return IStatController(_lazyInit(cc, CacheIndex.STAT_CONTROLLER_0, cc.controller.statController));\\n  }\\n\\n  function storyController(ControllerContext memory cc) internal view returns (IStoryController) {\\n    return IStoryController(_lazyInit(cc, CacheIndex.STORY_CONTROLLER_1, cc.controller.storyController));\\n  }\\n\\n  function oracle(ControllerContext memory cc) internal view returns (IOracle) {\\n    return IOracle(_lazyInit(cc, CacheIndex.ORACLE_2, cc.controller.oracle));\\n  }\\n\\n  function treasury(ControllerContext memory cc) internal view returns (ITreasury) {\\n    return ITreasury(_lazyInit(cc, CacheIndex.TREASURY_3, cc.controller.treasury));\\n  }\\n\\n  function dungeonFactory(ControllerContext memory cc) internal view returns (IDungeonFactory) {\\n    return IDungeonFactory(_lazyInit(cc, CacheIndex.DUNGEON_FACTORY_4, cc.controller.dungeonFactory));\\n  }\\n\\n  function gameObjectController(ControllerContext memory cc) internal view returns (IGOC) {\\n    return IGOC(_lazyInit(cc, CacheIndex.GOC_5, cc.controller.gameObjectController));\\n  }\\n\\n  function reinforcementController(ControllerContext memory cc) internal view returns (IReinforcementController) {\\n    return IReinforcementController(_lazyInit(cc, CacheIndex.REINFORCEMENT_CONTROLLER_6, cc.controller.reinforcementController));\\n  }\\n\\n  function itemController(ControllerContext memory cc) internal view returns (IItemController) {\\n    return IItemController(_lazyInit(cc, CacheIndex.ITEM_CONTROLLER_7, cc.controller.itemController));\\n  }\\n\\n  function heroController(ControllerContext memory cc) internal view returns (IHeroController) {\\n    return IHeroController(_lazyInit(cc, CacheIndex.HERO_CONTROLLER_8, cc.controller.heroController));\\n  }\\n\\n  function gameToken(ControllerContext memory cc) internal view returns (IGameToken) {\\n    return IGameToken(_lazyInit(cc, CacheIndex.GAME_TOKEN_9, cc.controller.gameToken));\\n  }\\n\\n  function userController(ControllerContext memory cc) internal view returns (IUserController) {\\n    return IUserController(_lazyInit(cc, CacheIndex.USER_CONTROLLER_10, cc.controller.userController));\\n  }\\n\\n  function guildController(ControllerContext memory cc) internal view returns (IGuildController) {\\n    return IGuildController(_lazyInit(cc, CacheIndex.GUILD_CONTROLLER_11, cc.controller.guildController));\\n  }\\n\\n  function pvpController(ControllerContext memory cc) internal view returns (IPvpController) {\\n    return IPvpController(_lazyInit(cc, CacheIndex.PVP_CONTROLLER_12, cc.controller.pvpController));\\n  }\\n\\n  function rewardsPool(ControllerContext memory cc) internal view returns (IRewardsPool) {\\n    return IRewardsPool(_lazyInit(cc, CacheIndex.REWARDS_POOL_13, cc.controller.rewardsPool));\\n  }\\n\\n  function itemBoxController(ControllerContext memory cc) internal view returns (IItemBoxController) {\\n    return IItemBoxController(_lazyInit(cc, CacheIndex.ITEM_BOX_CONTROLLER_14, cc.controller.itemBoxController));\\n  }\\n  //endregion ----------------- Access with lazy initialization\\n}\",\"keccak256\":\"0x8fa8be52cfba698f7e5a39c5043f05bddd9629868982402238b4294a9bbadb68\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ControllerLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IGameToken.sol\\\";\\nimport \\\"../interfaces/IProxyControlled.sol\\\";\\nimport \\\"../interfaces/IXmyrdGauge.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"./AppLib.sol\\\";\\n\\nlibrary ControllerLib {\\n  //region ------------------------ Constants\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 private constant CONTROLLER_STORAGE_LOCATION = 0x4d96152d518acf5697a667aeb82f27b3218b679995afa077296a84fdcb65bb00;\\n  uint internal constant DEPLOYER_ELIGIBILITY_PERIOD = 7 days;\\n  uint internal constant DEFAULT_TOKEN_PRICE = 10e18;\\n\\n  uint private constant _BURN_DENOMINATOR = 100e18;\\n  uint private constant _TOTAL_SUPPLY_BASE = 10_000_000e18;\\n\\n  uint public constant HERO_PAYMENT_PART_BOSS_REWARDS_POOL = 80_000;\\n  uint public constant HERO_PAYMENT_PART_TREASURY_LAST_BIOME = 10_000;\\n  uint public constant HERO_PAYMENT_DENOMINATOR = 100_000;\\n\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Data types\\n\\n  /// @custom:storage-location erc7201:controller.main\\n  struct MainState {\\n    address governance;\\n    address futureGovernance;\\n\\n    address statController;\\n    address storyController;\\n    address oracle;\\n    address treasury;\\n    address dungeonFactory;\\n    address gameObjectController;\\n    address reinforcementController;\\n    address itemController;\\n    address heroController;\\n    address gameToken;\\n\\n    mapping(address => bool) validTreasuryTokens;\\n    /// @dev EOA => eligibility time. We assume that deployer is fresh EOA and will be changed every deploy cycle for security reasons.\\n    mapping(address => uint) deployers;\\n    /// @dev In emergency case governance can pause all game\\n    bool onPause;\\n\\n    address userController;\\n    address guildController;\\n\\n    // some general relative price for the game token (how much game tokens need for 1 USD), 18 decimals, 10e18 by default\\n    uint gameTokenPrice;\\n\\n    address rewardsPool;\\n\\n    address pvpController;\\n\\n    address itemBoxController;\\n\\n    address gaugeXMyrd;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Restrictions\\n\\n  function onlyGovernance() internal view {\\n    if (!_isGovernance(msg.sender)) revert IAppErrors.NotGovernance(msg.sender);\\n  }\\n\\n  function onlyDeployer() internal view {\\n    if (!isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n\\n  function onlyContractsAllowedToProcess(IController controller) internal view {\\n    if (\\n      controller.heroController() != msg.sender\\n      && controller.userController() != msg.sender\\n      && controller.guildController() != msg.sender\\n      && controller.reinforcementController() != msg.sender\\n      && controller.itemController() != msg.sender\\n      && controller.storyController() != msg.sender\\n    ) {\\n      revert IAppErrors.ErrorNotAllowedSender();\\n    }\\n  }\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ Views\\n\\n  function _S() internal pure returns (MainState storage s) {\\n    assembly {\\n      s.slot := CONTROLLER_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n\\n  function isDeployer(address adr) internal view returns (bool) {\\n    uint t = _S().deployers[adr];\\n    return (t != 0 && block.timestamp < t) || _isGovernance(adr);\\n  }\\n\\n  function governance() internal view returns (address) {return _S().governance;}\\n\\n  function futureGovernance() internal view returns (address) {return _S().futureGovernance;}\\n\\n  function statController() internal view returns (address) {return _S().statController;}\\n\\n  function storyController() internal view returns (address) {return _S().storyController;}\\n\\n  function oracle() internal view returns (address) {return _S().oracle;}\\n\\n  function treasury() internal view returns (address) {return _S().treasury;}\\n\\n  function dungeonFactory() internal view returns (address) {return _S().dungeonFactory;}\\n\\n  function gameObjectController() internal view returns (address) {return _S().gameObjectController;}\\n\\n  function reinforcementController() internal view returns (address) {return _S().reinforcementController;}\\n\\n  function itemController() internal view returns (address) {return _S().itemController;}\\n\\n  function heroController() internal view returns (address) {return _S().heroController;}\\n\\n  function gameToken() internal view returns (address) {return _S().gameToken;}\\n\\n  function rewardsPool() internal view returns (address) {return _S().rewardsPool;}\\n\\n  function validTreasuryTokens(address token) internal view returns (bool) {\\n    return _S().validTreasuryTokens[token];\\n  }\\n\\n  function onPause() internal view returns (bool) {return _S().onPause;}\\n\\n  function userController() internal view returns (address) {return _S().userController;}\\n  function guildController() internal view returns (address) {return _S().guildController;}\\n\\n  function pvpController() internal view returns (address) {return _S().pvpController;}\\n\\n  function itemBoxController() internal view returns (address) {return _S().itemBoxController;}\\n\\n  function gameTokenPrice() internal view returns (uint p) {\\n    p = _S().gameTokenPrice;\\n    if (p == 0) {\\n      p = DEFAULT_TOKEN_PRICE;\\n    }\\n    return p;\\n  }\\n\\n  function gauge() internal view returns (address) {\\n    return _S().gaugeXMyrd;\\n  }\\n  //endregion ------------------------ Views\\n\\n  //region ------------------------ Gov actions - setters\\n\\n  function changePause(bool value) internal {\\n    onlyDeployer();\\n    _S().onPause = value;\\n  }\\n\\n  function offerGovernance(address newGov) internal {\\n    onlyGovernance();\\n    _S().futureGovernance = newGov;\\n    emit IApplicationEvents.OfferGovernance(newGov);\\n  }\\n\\n  function acceptGovernance() internal {\\n    if (_S().futureGovernance != msg.sender) revert IAppErrors.NotFutureGovernance(msg.sender);\\n    _S().governance = msg.sender;\\n    delete _S().futureGovernance;\\n    emit IApplicationEvents.GovernanceAccepted(msg.sender);\\n  }\\n\\n  function setStatController(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().statController = value;\\n    emit IApplicationEvents.StatControllerChanged(value);\\n  }\\n\\n  function setStoryController(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().storyController = value;\\n    emit IApplicationEvents.StoryControllerChanged(value);\\n  }\\n\\n  function setGameObjectController(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().gameObjectController = value;\\n    emit IApplicationEvents.GameObjectControllerChanged(value);\\n  }\\n\\n  function setReinforcementController(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().reinforcementController = value;\\n    emit IApplicationEvents.ReinforcementControllerChanged(value);\\n  }\\n\\n  function setOracle(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().oracle = value;\\n    emit IApplicationEvents.OracleChanged(value);\\n  }\\n\\n  function setTreasury(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().treasury = value;\\n    emit IApplicationEvents.TreasuryChanged(value);\\n  }\\n\\n  function setItemController(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().itemController = value;\\n    emit IApplicationEvents.ItemControllerChanged(value);\\n  }\\n\\n  function setHeroController(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().heroController = value;\\n    emit IApplicationEvents.HeroControllerChanged(value);\\n  }\\n\\n  function setGameToken(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().gameToken = value;\\n    emit IApplicationEvents.GameTokenChanged(value);\\n  }\\n\\n  function setDungeonFactory(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().dungeonFactory = value;\\n    emit IApplicationEvents.DungeonFactoryChanged(value);\\n  }\\n\\n  function changeDeployer(address eoa, bool remove) internal {\\n    onlyGovernance();\\n    if (remove) {\\n      delete _S().deployers[eoa];\\n    } else {\\n      _S().deployers[eoa] = block.timestamp + DEPLOYER_ELIGIBILITY_PERIOD;\\n    }\\n  }\\n\\n  function setUserController(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().userController = value;\\n    emit IApplicationEvents.UserControllerChanged(value);\\n  }\\n\\n  function setGuildController(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().guildController = value;\\n    emit IApplicationEvents.GuildControllerChanged(value);\\n  }\\n\\n  function setPvpController(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().pvpController = value;\\n    emit IApplicationEvents.PvpControllerChanged(value);\\n  }\\n\\n  function setRewardsPool(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().rewardsPool = value;\\n    emit IApplicationEvents.RewardsPoolChanged(value);\\n  }\\n\\n  function setGameTokenPrice(uint value) internal {\\n    onlyGovernance();\\n    if (value == 0) revert IAppErrors.ZeroAmount();\\n    _S().gameTokenPrice = value;\\n    emit IApplicationEvents.GameTokenPriceChanged(value);\\n  }\\n\\n  function setItemBoxController(address value) internal {\\n    onlyGovernance();\\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\\n    _S().itemBoxController = value;\\n    emit IApplicationEvents.ItemBoxControllerChanged(value);\\n  }\\n\\n  function setGauge(address value) internal {\\n    onlyGovernance();\\n\\n    // zero values are allowed\\n\\n    _S().gaugeXMyrd = value;\\n\\n    emit IApplicationEvents.GaugeChanged(value);\\n  }\\n  //endregion ------------------------ Gov actions - setters\\n\\n  //region ------------------------ Gov actions - others\\n\\n  function updateProxies(address[] memory proxies, address newLogic) internal {\\n    onlyDeployer();\\n    for (uint i; i < proxies.length; i++) {\\n      IProxyControlled(proxies[i]).upgrade(newLogic);\\n      emit IApplicationEvents.ProxyUpdated(proxies[i], newLogic);\\n    }\\n  }\\n\\n  function claimToGovernance(address token) internal {\\n    onlyGovernance();\\n    uint amount = IERC20(token).balanceOf(address(this));\\n    if (amount != 0) {\\n      IERC20(token).transfer(_S().governance, amount);\\n      emit IApplicationEvents.Claimed(token, amount);\\n    }\\n  }\\n  //endregion ------------------------ Gov actions - others\\n\\n  //region ------------------------ User actions\\n\\n  /// @notice Transfer {amount} from {from}, divide it on three parts: to treasury, to governance, to burn\\n  /// User must approve given amount to the controller.\\n  /// @param amount Assume that this amount is approved by {from} to this contract\\n  function process(IController controller, address token, uint amount, address from) internal {\\n    onlyContractsAllowedToProcess(controller);\\n\\n    (uint toBurn, uint toTreasury, uint toGov, uint toRewardsPool) = getProcessDetails(token, amount, controller.gameToken());\\n    IERC20(token).transferFrom(from, address(this), amount);\\n\\n    if (toRewardsPool != 0) {\\n      IERC20(token).transfer(controller.rewardsPool(), toRewardsPool);\\n    }\\n\\n    if (toTreasury != 0) {\\n      IERC20(token).transfer(controller.treasury(), toTreasury);\\n    }\\n\\n    if (toBurn != 0) {\\n      IGameToken(token).burn(toBurn);\\n    }\\n\\n    // send all available token balance to XMyrd gauge\\n    _sendTokensToGauge(token);\\n\\n    emit IApplicationEvents.Process(token, amount, from, toBurn, toTreasury, toGov);\\n  }\\n\\n  function percentToBurn(uint totalSupply) internal pure returns (uint) {\\n    return Math.min(totalSupply * _BURN_DENOMINATOR / _TOTAL_SUPPLY_BASE, _BURN_DENOMINATOR);\\n  }\\n\\n  function getProcessDetails(address token, uint amount, address gameToken_) internal pure returns (\\n    uint toBurn,\\n    uint toTreasury,\\n    uint toGov,\\n    uint toRewardsPool\\n  ) {\\n    if (token == gameToken_) {\\n      // since SIP-005 we stop burn SACRA\\n      // toBurn = amount * percentToBurn(IERC20(token).totalSupply()) / _BURN_DENOMINATOR;\\n      toTreasury = (amount - toBurn) / 2;\\n      toGov = amount - toBurn - toTreasury;\\n    } else {\\n      toRewardsPool = amount * HERO_PAYMENT_PART_BOSS_REWARDS_POOL / HERO_PAYMENT_DENOMINATOR;\\n      toTreasury = amount * HERO_PAYMENT_PART_TREASURY_LAST_BIOME / HERO_PAYMENT_DENOMINATOR;\\n      toGov = amount - toRewardsPool - toTreasury;\\n    }\\n\\n    return (toBurn, toTreasury, toGov, toRewardsPool);\\n  }\\n  //endregion ------------------------ User actions\\n\\n  //region ------------------------ REGISTER ACTIONS\\n\\n  function changeTreasuryTokenStatus(address token, bool status) internal {\\n    onlyGovernance();\\n    _S().validTreasuryTokens[token] = status;\\n    emit IApplicationEvents.TokenStatusChanged(token, status);\\n  }\\n  //endregion ------------------------ REGISTER ACTIONS\\n\\n  //region ------------------------  Internal logic\\n  function _isGovernance(address _value) internal view returns (bool) {\\n    return IController(address(this)).governance() == _value;\\n  }\\n\\n  /// @notice Send all available amount of the token to xMyrd gauge and call updatePeriod to rebase\\n  function _sendTokensToGauge(address token) internal {\\n    IXMyrdGauge _gauge = IXMyrdGauge(_S().gaugeXMyrd);\\n    if (address(_gauge) != address(0)) {\\n      address myrd = _gauge.defaultRewardToken();\\n      if (token == myrd) {\\n        // --------------- special logic for MYRD: send rewards through updatePeriod(amount)\\n        // todo fix left value calculation\\n        if (_gauge.activePeriod() < _gauge.getPeriod()) {\\n          uint balance = IERC20(token).balanceOf(address(this));\\n          if (balance != 0) {\\n            AppLib.approveIfNeeded(token, balance, address(_gauge));\\n          }\\n          // we should update period even with zero balance to call rebase\\n          try _gauge.updatePeriod(balance) {\\n            emit IApplicationEvents.UpdatePeriod(balance);\\n          } catch {}\\n        }\\n      } else {\\n        // --------------- any other tokens except MYRD: use notifyRewardAmount(amount) + updatePeriod(0)\\n        uint balance = IERC20(token).balanceOf(address(this));\\n        if (balance > _gauge.left(_gauge.xMyrd(), token) && balance / 7 days > 0) {\\n          AppLib.approveIfNeeded(token, balance, address(_gauge));\\n          try _gauge.notifyRewardAmount(token, balance) {\\n            emit IApplicationEvents.NotifyRewardAmount(token, balance);\\n          } catch {}\\n        } else {\\n          // keep tokens on balance of the controller\\n          // zero-balance case is also here\\n        }\\n\\n        // call updatePeriod if it's allowed\\n        // todo fix left value calculation\\n        if (_gauge.activePeriod() < _gauge.getPeriod()) {\\n          try _gauge.updatePeriod(0) {\\n            emit IApplicationEvents.UpdatePeriod(0);\\n          } catch {}\\n        }\\n      }\\n    }\\n  }\\n  //endregion ------------------------  Internal logic\\n}\\n\",\"keccak256\":\"0xb25447872135b0378a04478fb5d8b070b8059e4bdb732d37775028e0f3c28d20\",\"license\":\"BUSL-1.1\"},\"contracts/lib/SlotsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\\n/// @author bogdoslav\\nlibrary SlotsLib {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant SLOT_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  // ************* GETTERS *******************\\n\\n  /// @dev Gets a slot as bytes32\\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as an address\\n  function getAddress(bytes32 slot) internal view returns (address result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as uint256\\n  function getUint(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  // ************* ARRAY GETTERS *******************\\n\\n  /// @dev Gets an array length\\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  // ************* SETTERS *******************\\n\\n  /// @dev Sets a slot with bytes32\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, bytes32 value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with address\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, address value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with uint\\n  function set(bytes32 slot, uint value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x52ede981a6bb509c0dce07a0373e3c073c24fd16ca4ca7fbaa24f6c8b747b45b\",\"license\":\"BUSL-1.1\"},\"contracts/openzeppelin/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  // To implement this library for multiple types with as little code repetition as possible, we write it in\\n  // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\\n  // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\\n  // This means that we can only create new EnumerableMaps for types that fit in bytes32.\\n\\n  /**\\n   * @dev Query for a nonexistent map key.\\n     */\\n  error EnumerableMapNonexistentKey(bytes32 key);\\n\\n  struct Bytes32ToBytes32Map {\\n    // Storage of keys\\n    EnumerableSet.Bytes32Set _keys;\\n    mapping(bytes32 key => bytes32) _values;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n    map._values[key] = value;\\n    return map._keys.add(key);\\n  }\\n\\n  /**\\n   * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n    delete map._values[key];\\n    return map._keys.remove(key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n    return map._keys.contains(key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n    return map._keys.length();\\n  }\\n\\n  /**\\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n    bytes32 key = map._keys.at(index);\\n    return (key, map._values[key]);\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == bytes32(0)) {\\n      return (contains(map, key), bytes32(0));\\n    } else {\\n      return (true, value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == 0 && !contains(map, key)) {\\n      revert EnumerableMapNonexistentKey(key);\\n    }\\n    return value;\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n    return map._keys.values();\\n  }\\n\\n  // UintToUintMap\\n\\n  struct UintToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key)));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintToAddressMap\\n\\n  struct UintToAddressMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressToUintMap\\n\\n  struct AddressToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n    return remove(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (address(uint160(uint256(key))), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // Bytes32ToUintMap\\n\\n  struct Bytes32ToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, key, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n    return remove(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n    return contains(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (key, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, key);\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, key));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x5052395b3d57e4347a977f96eba69188b4a952594afae411910995ecab5c1d05\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position is the index of the value in the `values` array plus 1.\\n    // Position 0 is used to mean a value is not in the set.\\n    mapping(bytes32 value => uint256) _positions;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._positions[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We cache the value's position to prevent multiple reads from the same storage slot\\n    uint256 position = set._positions[value];\\n\\n    if (position != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 valueIndex = position - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (valueIndex != lastIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the lastValue to the index where the value to delete is\\n        set._values[valueIndex] = lastValue;\\n        // Update the tracked position of the lastValue (that was just moved)\\n        set._positions[lastValue] = position;\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the tracked position for the deleted slot\\n      delete set._positions[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._positions[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n     */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xd5483249a7bac53a40791ade8d640831cdec526eea6b42a4db68f2ce13c008fa\",\"license\":\"MIT\"},\"contracts/openzeppelin/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n  struct InitializableStorage {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n         */\\n    uint64 _initialized;\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n    bool _initializing;\\n  }\\n\\n  // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n  /**\\n   * @dev The contract is already initialized.\\n     */\\n  error InvalidInitialization();\\n\\n  /**\\n   * @dev The contract is not initializing.\\n     */\\n  error NotInitializing();\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n  event Initialized(uint64 version);\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier initializer() {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    // Cache values to avoid duplicated sloads\\n    bool isTopLevelCall = !$._initializing;\\n    uint64 initialized = $._initialized;\\n\\n    // Allowed calls:\\n    // - initialSetup: the contract is not in the initializing state and no previous version was\\n    //                 initialized\\n    // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n    //                 current contract is just being deployed\\n    bool initialSetup = initialized == 0 && isTopLevelCall;\\n    bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n    if (!initialSetup && !construction) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = 1;\\n    if (isTopLevelCall) {\\n      $._initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      $._initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier reinitializer(uint64 version) {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing || $._initialized >= version) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = version;\\n    $._initializing = true;\\n    _;\\n    $._initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n  modifier onlyInitializing() {\\n    _checkInitializing();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n  function _checkInitializing() internal view virtual {\\n    if (!_isInitializing()) {\\n      revert NotInitializing();\\n    }\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n  function _disableInitializers() internal virtual {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing) {\\n      revert InvalidInitialization();\\n    }\\n    if ($._initialized != type(uint64).max) {\\n      $._initialized = type(uint64).max;\\n      emit Initialized(type(uint64).max);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n  function _getInitializedVersion() internal view returns (uint64) {\\n    return _getInitializableStorage()._initialized;\\n  }\\n\\n  /**\\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n  function _isInitializing() internal view returns (bool) {\\n    return _getInitializableStorage()._initializing;\\n  }\\n\\n  /**\\n   * @dev Returns a pointer to the storage namespace.\\n     */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n    assembly {\\n      $.slot := INITIALIZABLE_STORAGE\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x80aa3fc0fc9afdf84bd1a51716150cd13041f42d920a9afa8020ea41cf673809\",\"license\":\"MIT\"},\"contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n\\n  /**\\n    * @dev Muldiv operation overflow.\\n   */\\n  error MathOverflowedMulDiv();\\n\\n  enum Rounding {\\n    Floor, // Toward negative infinity\\n    Ceil, // Toward positive infinity\\n    Trunc, // Toward zero\\n    Expand // Away from zero\\n  }\\n\\n  /**\\n   * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      uint256 c = a + b;\\n      if (c < a) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b > a) return (false, 0);\\n      return (true, a - b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n      if (a == 0) return (true, 0);\\n      uint256 c = a * b;\\n      if (c / a != b) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a / b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a % b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (b == 0) {\\n      // Guarantee the same behavior as in a regular Solidity division.\\n      return a / b;\\n    }\\n\\n    // The following calculation ensures accurate ceiling division without overflow.\\n    // Since a is non-zero, (a - 1) / b will not overflow.\\n    // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n    // but the largest value we can obtain is type(uint256).max - 1, which happens\\n    // when a = type(uint256).max and b = 1.\\n    unchecked {\\n      return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n    unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n      uint256 prod0 = x * y; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n      if (prod1 == 0) {\\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n        // The surrounding unchecked block does not change this fact.\\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n        return prod0 / denominator;\\n      }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n      if (denominator <= prod1) {\\n        revert MathOverflowedMulDiv();\\n      }\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n      uint256 remainder;\\n      assembly {\\n      // Compute remainder using mulmod.\\n        remainder := mulmod(x, y, denominator)\\n\\n      // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n    // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n      uint256 twos = denominator & (0 - denominator);\\n      assembly {\\n      // Divide denominator by twos.\\n        denominator := div(denominator, twos)\\n\\n      // Divide [prod1 prod0] by twos.\\n        prod0 := div(prod0, twos)\\n\\n      // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n\\n    // Shift in bits from prod1 into prod0.\\n      prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n      uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n    // works in modular arithmetic, doubling the correct bits in each step.\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n      result = prod0 * inverse;\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n    unchecked {\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      return min(result, a / result);\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = sqrt(a);\\n      return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 128;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 64;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 32;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 16;\\n      }\\n      if (value >> 8 > 0) {\\n        value >>= 8;\\n        result += 8;\\n      }\\n      if (value >> 4 > 0) {\\n        value >>= 4;\\n        result += 4;\\n      }\\n      if (value >> 2 > 0) {\\n        value >>= 2;\\n        result += 2;\\n      }\\n      if (value >> 1 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log2(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >= 10 ** 64) {\\n        value /= 10 ** 64;\\n        result += 64;\\n      }\\n      if (value >= 10 ** 32) {\\n        value /= 10 ** 32;\\n        result += 32;\\n      }\\n      if (value >= 10 ** 16) {\\n        value /= 10 ** 16;\\n        result += 16;\\n      }\\n      if (value >= 10 ** 8) {\\n        value /= 10 ** 8;\\n        result += 8;\\n      }\\n      if (value >= 10 ** 4) {\\n        value /= 10 ** 4;\\n        result += 4;\\n      }\\n      if (value >= 10 ** 2) {\\n        value /= 10 ** 2;\\n        result += 2;\\n      }\\n      if (value >= 10 ** 1) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log10(value);\\n      return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 16;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 8;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 4;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 2;\\n      }\\n      if (value >> 8 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log256(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n  function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n    return uint8(rounding) % 2 == 1;\\n  }\\n\\n}\\n\",\"keccak256\":\"0x4d972e3e1d79f693b6cb42007d23c27256cb6f087392edea24b93585a822572c\",\"license\":\"MIT\"},\"contracts/proxy/Controllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Initializable.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../lib/SlotsLib.sol\\\";\\n\\n/// @title Implement basic functionality for any contract that require strict control\\n/// @dev Can be used with upgradeable pattern.\\n///      Require call __Controllable_init() in any case.\\n/// @author belbix\\nabstract contract Controllable is Initializable, IControllable {\\n  using SlotsLib for bytes32;\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant CONTROLLABLE_VERSION = \\\"1.0.0\\\";\\n\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.revision\\\")) - 1);\\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.prev_logic\\\")) - 1);\\n\\n  event ContractInitialized(address controller, uint ts, uint block);\\n  event RevisionIncreased(uint value, address oldLogic);\\n\\n  // init implementation contract\\n  constructor() initializer {}\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\n  /// @dev Use it only once after first logic setup\\n  /// @param controller_ Controller address\\n  function __Controllable_init(address controller_) internal onlyInitializing {\\n    _init(controller_);\\n  }\\n\\n  function _init(address controller_) private {\\n    require(controller_ != address(0), \\\"Zero controller\\\");\\n    _CONTROLLER_SLOT.set(controller_);\\n    _CREATED_SLOT.set(block.timestamp);\\n    _CREATED_BLOCK_SLOT.set(block.number);\\n    emit ContractInitialized(controller_, block.timestamp, block.number);\\n  }\\n\\n  /// @dev Return true if given address is controller\\n  function isController(address value_) public override view returns (bool) {\\n    return value_ == controller();\\n  }\\n\\n  /// @notice Return true if given address is setup as governance in Controller\\n  function isGovernance(address value_) public override view returns (bool) {\\n    return IController(controller()).governance() == value_;\\n  }\\n\\n  /// @dev Contract upgrade counter\\n  function revision() external view override returns (uint) {\\n    return _REVISION_SLOT.getUint();\\n  }\\n\\n  /// @dev Previous logic implementation\\n  function previousImplementation() external view override returns (address) {\\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\\n  }\\n\\n  // ************* SETTERS/GETTERS *******************\\n\\n  /// @notice Return controller address saved in the contract slot\\n  function controller() public view override returns (address) {\\n    return _CONTROLLER_SLOT.getAddress();\\n  }\\n\\n  /// @notice Return creation timestamp\\n  /// @return Creation timestamp\\n  function created() external view override returns (uint256) {\\n    return _CREATED_SLOT.getUint();\\n  }\\n\\n  /// @notice Return creation block number\\n  /// @return Creation block number\\n  function createdBlock() external override view returns (uint256) {\\n    return _CREATED_BLOCK_SLOT.getUint();\\n  }\\n\\n  /// @dev Revision should be increased on each contract upgrade\\n  function increaseRevision(address oldLogic) external override {\\n    require(msg.sender == address(this), \\\"Increase revision forbidden\\\");\\n    uint r = _REVISION_SLOT.getUint() + 1;\\n    _REVISION_SLOT.set(r);\\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\\n    emit RevisionIncreased(r, oldLogic);\\n  }\\n\\n}\\n\",\"keccak256\":\"0x1edc53f0d11834bebf4485746d04112ed10db9d4cb19b4945362c593ebf97daf\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b507ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00805468010000000000000000810460ff1615906001600160401b03166000811580156200005d5750825b90506000826001600160401b031660011480156200007a5750303b155b90508115801562000089575080155b15620000a85760405163f92ee8a960e01b815260040160405180910390fd5b84546001600160401b03191660011785558315620000d757845460ff60401b1916680100000000000000001785555b83156200011e57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505061315380620001336000396000f3fe608060405234801561001057600080fd5b50600436106102fe5760003560e01c806361d027b3116101a45780639d0bcca0116100fa578063d11d18611161009d578063d11d186114610653578063dee1f0e41461065d578063e4ce087114610670578063f0f4426014610683578063f2c7b2eb14610696578063f6914cfa146106a9578063f77c4791146106bc578063ffa1ad74146106c457600080fd5b80639d0bcca0146105f2578063a27218ac146105fa578063a6f19c8414610602578063b1bc41951461060a578063b429afeb14610612578063bcb384fa14610625578063c3dfdae614610638578063c81529c61461064057600080fd5b806361d027b3146104d957806368321eb7146104e1578063683fedf7146105145780637262bb2d1461051c5780637405bab81461052f5780637adbf973146105425780637c000293146105555780637c66b452146105685780637cc963801461057b5780637dc0d1d0146105835780638070c5031461058b57806380d29e6614610593578063822f804c146105a657806389dd9f13146105b9578063936725ec146105c157600080fd5b8063359a7d8f11610259578063359a7d8f146103e8578063361e4b27146103fb57806337cac68a1461040e5780633c8f1bbe146104215780634453bd89146104345780634576dc52146104475780634593144c1461045a578063490fb76a146104625780634fac6ccd1461046a57806350c358a41461047d578063524a562f1461049057806355a68ed3146104985780635aa6e675146104ab5780635d4fead3146104b3578063605918ae146104c657600080fd5b80628e9691146103035780630139009f14610321578063016dff5d146103295780630359fea91461033157806308ac0fd71461033957806311b0aebe1461034e5780631534e0501461036f57806318d928311461038257806319ab453c1461039a5780631ec47600146103ad578063238efcbc146103c057806325eb1c87146103c85780632f91ede9146103d057806331423c26146103d8578063325a19f1146103e0575b600080fd5b61030b6106e8565b6040516103189190612d6f565b60405180910390f35b61030b6106f7565b61030b610701565b61030b61070b565b61034c610347366004612da8565b610715565b005b61036161035c366004612dc5565b610721565b604051908152602001610318565b61034c61037d366004612da8565b610732565b61038a61073b565b6040519015158152602001610318565b61034c6103a8366004612da8565b610745565b61034c6103bb366004612da8565b610868565b61034c610871565b61030b61087b565b61030b610885565b61030b61088f565b610361610899565b61034c6103f6366004612da8565b6108cd565b61034c610409366004612da8565b6108d6565b61034c61041c366004612da8565b6108df565b61034c61042f366004612dde565b6108e8565b61034c610442366004612da8565b6108f9565b61034c610455366004612e36565b610902565b610361610910565b61030b610940565b61034c610478366004612da8565b61094a565b61038a61048b366004612da8565b610a5c565b61030b610a67565b61034c6104a6366004612da8565b610a71565b61030b610a7a565b61034c6104c1366004612f1b565b610a84565b61034c6104d4366004612da8565b610a8d565b61030b610a96565b6104f46104ef366004612f38565b610aa0565b604080519485526020850193909352918301526060820152608001610318565b61030b610b22565b61034c61052a366004612f64565b610b2c565b61034c61053d366004612da8565b610b36565b61034c610550366004612da8565b610b3f565b61034c610563366004612da8565b610b48565b61038a610576366004612da8565b610b51565b610361610b5c565b61030b610b7a565b61030b610b84565b61034c6105a1366004612da8565b610b8e565b61034c6105b4366004612da8565b610b97565b61030b610ba0565b6105e5604051806040016040528060058152602001640312e302e360dc1b81525081565b6040516103189190612f9d565b61030b610baa565b61030b610bda565b61030b610be4565b610361610bee565b61038a610620366004612da8565b610bf8565b61034c610633366004612da8565b610c1d565b61030b610c26565b61034c61064e366004612da8565b610c30565b61036162093a8081565b61038a61066b366004612da8565b610c39565b61034c61067e366004612da8565b610cbe565b61034c610691366004612da8565b610cc7565b61034c6106a4366004612dc5565b610cd0565b61034c6106b7366004612f64565b610cd9565b61030b610ce3565b6105e560405180604001604052806005815260200164312e302e3360d81b81525081565b60006106f2610d13565b905090565b60006106f2610d2f565b60006106f2610d4b565b60006106f2610d67565b61071e81610d83565b50565b600061072c82610e17565b92915050565b61071e81610e54565b60006106f2610edd565b600061074f610ef3565b805490915060ff600160401b820416159067ffffffffffffffff166000811580156107775750825b905060008267ffffffffffffffff1660011480156107945750303b155b9050811580156107a2575080155b156107c05760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff1916600117855583156107ea57845460ff60401b1916600160401b1785555b6107f330610f17565b856107fc610f28565b80546001600160a01b0319166001600160a01b0392909216919091179055831561086057845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b61071e81610f4c565b610879610fae565b565b60006106f261105e565b60006106f261107a565b60006106f2611096565b60006106f26108c960017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b613002565b5490565b61071e816110b2565b61071e81611140565b61071e816111c9565b6108f430848484611252565b505050565b61071e816115c3565b61090c828261164c565b5050565b60006106f26108c960017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1613002565b60006106f2611731565b33301461099c5760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b60006109ba6108c960016000805160206130fe833981519152613002565b6109c5906001613015565b90506109e7816109e460016000805160206130fe833981519152613002565b55565b610a16826109e460017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4613002565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c891015b60405180910390a15050565b600061072c82611752565b60006106f26117a0565b61071e816117bc565b60006106f261181e565b61071e81611837565b61071e8161185d565b60006106f26118e6565b600080600080610b128686306001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ae9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b0d9190613028565b611902565b9299919850965090945092505050565b60006106f26119af565b61090c82826119cb565b61071e81611a38565b61071e81611ac1565b61071e81611b4a565b600061072c82611bd3565b60006106f26108c960016000805160206130fe833981519152613002565b60006106f2611c02565b60006106f2611c1e565b61071e81611c3a565b61071e81611cc3565b60006106f2611d4c565b60006106f26108c960017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4613002565b60006106f2611d68565b60006106f2611d84565b60006106f2611da0565b6000610c02610ce3565b6001600160a01b0316826001600160a01b0316149050919050565b61071e81611dc6565b60006106f2611eff565b61071e81611f1b565b6000816001600160a01b0316610c4d610ce3565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c8a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cae9190613028565b6001600160a01b03161492915050565b61071e81611fa4565b61071e8161202d565b61071e816120b6565b61090c828261211c565b60006106f26108c960017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618613002565b6000610d1d610f28565b600201546001600160a01b0316919050565b6000610d39610f28565b601301546001600160a01b0316919050565b6000610d55610f28565b600a01546001600160a01b0316919050565b6000610d71610f28565b601101546001600160a01b0316919050565b610d8b612194565b6001600160a01b038116610db25760405163d92e233d60e01b815260040160405180910390fd5b80610dbb610f28565b60060180546001600160a01b0319166001600160a01b03929092169190911790556040517f5d77c617926cd1f4106de1bae23b2eb1a9d6e84911f701858a0b1d831e92816590610e0c908390612d6f565b60405180910390a150565b600061072c6a084595161401484a000000610e3b68056bc75e2d6310000085613045565b610e45919061305c565b68056bc75e2d631000006121bc565b610e5c612194565b6001600160a01b038116610e835760405163d92e233d60e01b815260040160405180910390fd5b80610e8c610f28565b60130180546001600160a01b0319166001600160a01b03929092169190911790556040517fcaa89af641ab6d1a458e39f225a12c0d1137f317d718b8713054a445bd2cde6790610e0c908390612d6f565b6000610ee7610f28565b600e015460ff16919050565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b610f1f6121d2565b61071e816121f7565b7f4d96152d518acf5697a667aeb82f27b3218b679995afa077296a84fdcb65bb0090565b610f54612194565b80610f5d610f28565b60010180546001600160a01b0319166001600160a01b03929092169190911790556040517f93a15bbe6d7cb67fff86738ed92efd14e9fe04e7d30042086570034a2f2eb3c290610e0c908390612d6f565b33610fb7610f28565b600101546001600160a01b031614610fe4573360405163ba18f1e160e01b81526004016109939190612d6f565b33610fed610f28565b80546001600160a01b0319166001600160a01b0392909216919091179055611013610f28565b60010180546001600160a01b03191690556040517fb1476cf38ac36ee528f1ad1ae81bdb46de8807d42475e16078426bce6001396190611054903390612d6f565b60405180910390a1565b6000611068610f28565b600f01546001600160a01b0316919050565b6000611084610f28565b600801546001600160a01b0316919050565b60006110a0610f28565b600901546001600160a01b0316919050565b6110ba612194565b6001600160a01b0381166110e15760405163d92e233d60e01b815260040160405180910390fd5b806110ea610f28565b600e0160016101000a8154816001600160a01b0302191690836001600160a01b031602179055507fd86fc86ebea7a7d81c1a9fa7e0977cdafcfccf0cc35295a095231a7b28274e4981604051610e0c9190612d6f565b611148612194565b6001600160a01b03811661116f5760405163d92e233d60e01b815260040160405180910390fd5b80611178610f28565b60030180546001600160a01b0319166001600160a01b03929092169190911790556040517fecbc0f0d903f1b9964d257a8043a5ecdf9c55a8e3d0060fb920b40c4009a257d90610e0c908390612d6f565b6111d1612194565b6001600160a01b0381166111f85760405163d92e233d60e01b815260040160405180910390fd5b80611201610f28565b60120180546001600160a01b0319166001600160a01b03929092169190911790556040517fe34dace06c75fb12cb36ab5627f4ad085768e0e550b787566c647aa0cd052b0690610e0c908390612d6f565b61125b84612314565b6000806000806112a487878a6001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ae9573d6000803e3d6000fd5b6040516323b872dd60e01b81526001600160a01b038a81166004830152306024830152604482018c90529498509296509094509250908816906323b872dd906064016020604051808303816000875af1158015611305573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611329919061307e565b50801561140457866001600160a01b031663a9059cbb896001600160a01b0316630359fea96040518163ffffffff1660e01b8152600401602060405180830381865afa15801561137d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113a19190613028565b836040518363ffffffff1660e01b81526004016113bf92919061309b565b6020604051808303816000875af11580156113de573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611402919061307e565b505b82156114de57866001600160a01b031663a9059cbb896001600160a01b03166361d027b36040518163ffffffff1660e01b8152600401602060405180830381865afa158015611457573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061147b9190613028565b856040518363ffffffff1660e01b815260040161149992919061309b565b6020604051808303816000875af11580156114b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114dc919061307e565b505b831561155157604051630852cd8d60e31b8152600481018590526001600160a01b038816906342966c68906024016020604051808303816000875af115801561152b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061154f919061307e565b505b61155a87612624565b604080516001600160a01b03898116825260208201899052871681830152606081018690526080810185905260a0810184905290517f1fd334c200f7b34cefbcb9762981e99dea5bdff9c149c5e4a279a1f55e8c97729181900360c00190a15050505050505050565b6115cb612194565b6001600160a01b0381166115f25760405163d92e233d60e01b815260040160405180910390fd5b806115fb610f28565b600f0180546001600160a01b0319166001600160a01b03929092169190911790556040517f0d1f076dd618d44fc1ed0ae909dcb5a875262080a1fb3386f155e47003323ed790610e0c908390612d6f565b611654612bf9565b60005b82518110156108f457828181518110611672576116726130b4565b60200260200101516001600160a01b0316630900f010836040518263ffffffff1660e01b81526004016116a59190612d6f565b600060405180830381600087803b1580156116bf57600080fd5b505af11580156116d3573d6000803e3d6000fd5b505050507fd32d24edea94f55e932d9a008afc425a8561462d1b1f57bc6e508e9a6b9509e183828151811061170a5761170a6130b4565b6020026020010151836040516117219291906130ca565b60405180910390a1600101611657565b600061173b610f28565b600e015461010090046001600160a01b0316919050565b60008061175d610f28565b6001600160a01b0384166000908152600d9190910160205260409020549050801580159061178a57508042105b80611799575061179983612c21565b9392505050565b60006117aa610f28565b600301546001600160a01b0316919050565b6117c4612194565b806117cd610f28565b60140180546001600160a01b0319166001600160a01b03929092169190911790556040517f1d609dbce8c46093a144a3723e81b905c328eb5034d986a74301fb4764ded28190610e0c908390612d6f565b6000611828610f28565b546001600160a01b0316919050565b61183f612bf9565b80611848610f28565b600e01805460ff191691151591909117905550565b611865612194565b6001600160a01b03811661188c5760405163d92e233d60e01b815260040160405180910390fd5b80611895610f28565b60020180546001600160a01b0319166001600160a01b03929092169190911790556040517f573b0be2ffc8c66825968c4e3b38a0af5edb18ce20f9a516e0f8a04867d2638990610e0c908390612d6f565b60006118f0610f28565b600501546001600160a01b0316919050565b600080600080846001600160a01b0316876001600160a01b03160361195557600261192d8588613002565b611937919061305c565b9250826119448588613002565b61194e9190613002565b91506119a6565b620186a06119666201388088613045565b611970919061305c565b9050620186a061198261271088613045565b61198c919061305c565b9250826119998288613002565b6119a39190613002565b91505b93509350935093565b60006119b9610f28565b600601546001600160a01b0316919050565b6119d3612194565b8015611a02576119e1610f28565b6001600160a01b0383166000908152600d9190910160205260408120555050565b611a0f62093a8042613015565b611a17610f28565b6001600160a01b0384166000908152600d9190910160205260409020555050565b611a40612194565b6001600160a01b038116611a675760405163d92e233d60e01b815260040160405180910390fd5b80611a70610f28565b60090180546001600160a01b0319166001600160a01b03929092169190911790556040517fedcd6ea89a41d21f1bafa9a7cc32e754079d18642839a1a48c938447d2a740eb90610e0c908390612d6f565b611ac9612194565b6001600160a01b038116611af05760405163d92e233d60e01b815260040160405180910390fd5b80611af9610f28565b60040180546001600160a01b0319166001600160a01b03929092169190911790556040517f0e05ae75e8b926552cf6fcd744d19f422561e3ced1e426868730852702dbe41890610e0c908390612d6f565b611b52612194565b6001600160a01b038116611b795760405163d92e233d60e01b815260040160405180910390fd5b80611b82610f28565b60110180546001600160a01b0319166001600160a01b03929092169190911790556040517f657bb19de5473f7be7de9ccbcfa6d9aabcb3cfd199aef85e949a1d8570c290ab90610e0c908390612d6f565b6000611bdd610f28565b6001600160a01b039092166000908152600c9290920160205250604090205460ff1690565b6000611c0c610f28565b600401546001600160a01b0316919050565b6000611c28610f28565b600101546001600160a01b0316919050565b611c42612194565b6001600160a01b038116611c695760405163d92e233d60e01b815260040160405180910390fd5b80611c72610f28565b600b0180546001600160a01b0319166001600160a01b03929092169190911790556040517f035bee136adcafe288762d810fef741bc236d20bb1b469acb4c23e5357f0856790610e0c908390612d6f565b611ccb612194565b6001600160a01b038116611cf25760405163d92e233d60e01b815260040160405180910390fd5b80611cfb610f28565b60070180546001600160a01b0319166001600160a01b03929092169190911790556040517ffa195fffb4bf4e5339e2e98fb090f0d634c64261640c07c1ee6ee43d5f23516190610e0c908390612d6f565b6000611d56610f28565b600701546001600160a01b0316919050565b6000611d72610f28565b601201546001600160a01b0316919050565b6000611d8e610f28565b601401546001600160a01b0316919050565b6000611daa610f28565b60100154905080600003611dc35750678ac7230489e800005b90565b611dce612194565b6040516370a0823160e01b81526000906001600160a01b038316906370a0823190611dfd903090600401612d6f565b602060405180830381865afa158015611e1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e3e91906130e4565b9050801561090c57816001600160a01b031663a9059cbb611e5d610f28565b546040516001600160e01b031960e084901b168152611e8a916001600160a01b031690859060040161309b565b6020604051808303816000875af1158015611ea9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ecd919061307e565b507fd8138f8a3f377c5259ca548e70e4c2de94f129f5a11036a15b69513cba2b426a8282604051610a5092919061309b565b6000611f09610f28565b600b01546001600160a01b0316919050565b611f23612194565b6001600160a01b038116611f4a5760405163d92e233d60e01b815260040160405180910390fd5b80611f53610f28565b600a0180546001600160a01b0319166001600160a01b03929092169190911790556040517fd1e9a4ae1231531a757f1e31a2ff8a1db9d359a194436efe40bccb972cde86f090610e0c908390612d6f565b611fac612194565b6001600160a01b038116611fd35760405163d92e233d60e01b815260040160405180910390fd5b80611fdc610f28565b60080180546001600160a01b0319166001600160a01b03929092169190911790556040517f29fdde0e067ae34f44ca706fd84ea4b9dabb69557e7e935d379c932ba023b2be90610e0c908390612d6f565b612035612194565b6001600160a01b03811661205c5760405163d92e233d60e01b815260040160405180910390fd5b80612065610f28565b60050180546001600160a01b0319166001600160a01b03929092169190911790556040517fc714d22a2f08b695f81e7c707058db484aa5b4d6b4c9fd64beb10fe85832f60890610e0c908390612d6f565b6120be612194565b806000036120df57604051631f2a200560e01b815260040160405180910390fd5b806120e8610f28565b601001556040518181527f867c590cfc1b2ba6732d5d876a96733ad5cde9c836a978d6107517c00cf3f44590602001610e0c565b612124612194565b8061212d610f28565b6001600160a01b0384166000818152600c929092016020908152604092839020805460ff1916941515949094179093558151908152831515928101929092527f0de9c5667496fd561ff9dfa59efdc1c76f7dbf3844adae3d14a3a14d563321b19101610a50565b61219d33612c21565b610879573360405163988d1f0360e01b81526004016109939190612d6f565b60008183106121cb5781611799565b5090919050565b6121da612c6b565b61087957604051631afcd79f60e31b815260040160405180910390fd5b6001600160a01b03811661223f5760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b6044820152606401610993565b61226e816109e460017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618613002565b61229d426109e460017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b613002565b6122cc436109e460017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1613002565b604080516001600160a01b038316815242602082015243918101919091527f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe23671342690606001610e0c565b336001600160a01b0316816001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561235c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123809190613028565b6001600160a01b03161415801561240a5750336001600160a01b0316816001600160a01b031663490fb76a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156123da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123fe9190613028565b6001600160a01b031614155b80156124895750336001600160a01b0316816001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa158015612459573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061247d9190613028565b6001600160a01b031614155b80156125085750336001600160a01b0316816001600160a01b0316632f91ede96040518163ffffffff1660e01b8152600401602060405180830381865afa1580156124d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124fc9190613028565b6001600160a01b031614155b80156125875750336001600160a01b0316816001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa158015612557573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061257b9190613028565b6001600160a01b031614155b80156126065750336001600160a01b0316816001600160a01b031663524a562f6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156125d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125fa9190613028565b6001600160a01b031614155b1561071e5760405163f20e063760e01b815260040160405180910390fd5b600061262e610f28565b601401546001600160a01b03169050801561090c576000816001600160a01b031663ff3a4ac06040518163ffffffff1660e01b8152600401602060405180830381865afa158015612683573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126a79190613028565b9050806001600160a01b0316836001600160a01b0316036128a257816001600160a01b0316631ed241956040518163ffffffff1660e01b8152600401602060405180830381865afa158015612700573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061272491906130e4565b826001600160a01b0316630a441f7b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612762573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061278691906130e4565b10156108f4576040516370a0823160e01b81526000906001600160a01b038516906370a08231906127bb903090600401612d6f565b602060405180830381865afa1580156127d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127fc91906130e4565b9050801561280f5761280f848285612c85565b60405163e270d1df60e01b8152600481018290526001600160a01b0384169063e270d1df90602401600060405180830381600087803b15801561285157600080fd5b505af1925050508015612862575060015b1561289c576040518181527fd1c043d38a3243c01780647a1340049807cd98af891021c89c32c99a8e0c59e7906020015b60405180910390a15b50505050565b6040516370a0823160e01b81526000906001600160a01b038516906370a08231906128d1903090600401612d6f565b602060405180830381865afa1580156128ee573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061291291906130e4565b9050826001600160a01b0316636180c3f9846001600160a01b03166379d83f8e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612961573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129859190613028565b866040518363ffffffff1660e01b81526004016129a39291906130ca565b602060405180830381865afa1580156129c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129e491906130e4565b811180156129fe575060006129fc62093a808361305c565b115b15612aa657612a0e848285612c85565b60405163b66503cf60e01b81526001600160a01b0384169063b66503cf90612a3c908790859060040161309b565b600060405180830381600087803b158015612a5657600080fd5b505af1925050508015612a67575060015b15612aa6577ff6b60b7da8e0f883e399412005b6205515604a993e7e3f0c3b199b9cb07d6ae68482604051612a9d92919061309b565b60405180910390a15b826001600160a01b0316631ed241956040518163ffffffff1660e01b8152600401602060405180830381865afa158015612ae4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b0891906130e4565b836001600160a01b0316630a441f7b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612b46573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b6a91906130e4565b101561289c5760405163e270d1df60e01b8152600060048201526001600160a01b0384169063e270d1df90602401600060405180830381600087803b158015612bb257600080fd5b505af1925050508015612bc3575060015b1561289c57604051600081527fd1c043d38a3243c01780647a1340049807cd98af891021c89c32c99a8e0c59e790602001612893565b612c0233611752565b610879573360405163451cea1760e11b81526004016109939190612d6f565b6000816001600160a01b0316306001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c8a573d6000803e3d6000fd5b6000612c75610ef3565b54600160401b900460ff16919050565b604051636eb1769f60e11b815282906001600160a01b0385169063dd62ed3e90612cb590309086906004016130ca565b602060405180830381865afa158015612cd2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612cf691906130e4565b10156108f45760405163095ea7b360e01b81526001600160a01b0384169063095ea7b390612d2c9084906000199060040161309b565b6020604051808303816000875af1158015612d4b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061289c919061307e565b6001600160a01b0391909116815260200190565b6001600160a01b038116811461071e57600080fd5b8035612da381612d83565b919050565b600060208284031215612dba57600080fd5b813561179981612d83565b600060208284031215612dd757600080fd5b5035919050565b600080600060608486031215612df357600080fd5b8335612dfe81612d83565b9250602084013591506040840135612e1581612d83565b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b60008060408385031215612e4957600080fd5b823567ffffffffffffffff80821115612e6157600080fd5b818501915085601f830112612e7557600080fd5b8135602082821115612e8957612e89612e20565b8160051b604051601f19603f83011681018181108682111715612eae57612eae612e20565b604052928352818301935084810182019289841115612ecc57600080fd5b948201945b83861015612ef157612ee286612d98565b85529482019493820193612ed1565b9650612f009050878201612d98565b9450505050509250929050565b801515811461071e57600080fd5b600060208284031215612f2d57600080fd5b813561179981612f0d565b60008060408385031215612f4b57600080fd5b8235612f5681612d83565b946020939093013593505050565b60008060408385031215612f7757600080fd5b8235612f8281612d83565b91506020830135612f9281612f0d565b809150509250929050565b60006020808352835180602085015260005b81811015612fcb57858101830151858201604001528201612faf565b506000604082860101526040601f19601f8301168501019250505092915050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561072c5761072c612fec565b8082018082111561072c5761072c612fec565b60006020828403121561303a57600080fd5b815161179981612d83565b808202811582820484141761072c5761072c612fec565b60008261307957634e487b7160e01b600052601260045260246000fd5b500490565b60006020828403121561309057600080fd5b815161179981612f0d565b6001600160a01b03929092168252602082015260400190565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b0392831681529116602082015260400190565b6000602082840312156130f657600080fd5b505191905056fe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda26469706673582212209dab2921094ac04a62bc389e403315b51537eec1a88ac4e5c4423ae9162982f964736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106102fe5760003560e01c806361d027b3116101a45780639d0bcca0116100fa578063d11d18611161009d578063d11d186114610653578063dee1f0e41461065d578063e4ce087114610670578063f0f4426014610683578063f2c7b2eb14610696578063f6914cfa146106a9578063f77c4791146106bc578063ffa1ad74146106c457600080fd5b80639d0bcca0146105f2578063a27218ac146105fa578063a6f19c8414610602578063b1bc41951461060a578063b429afeb14610612578063bcb384fa14610625578063c3dfdae614610638578063c81529c61461064057600080fd5b806361d027b3146104d957806368321eb7146104e1578063683fedf7146105145780637262bb2d1461051c5780637405bab81461052f5780637adbf973146105425780637c000293146105555780637c66b452146105685780637cc963801461057b5780637dc0d1d0146105835780638070c5031461058b57806380d29e6614610593578063822f804c146105a657806389dd9f13146105b9578063936725ec146105c157600080fd5b8063359a7d8f11610259578063359a7d8f146103e8578063361e4b27146103fb57806337cac68a1461040e5780633c8f1bbe146104215780634453bd89146104345780634576dc52146104475780634593144c1461045a578063490fb76a146104625780634fac6ccd1461046a57806350c358a41461047d578063524a562f1461049057806355a68ed3146104985780635aa6e675146104ab5780635d4fead3146104b3578063605918ae146104c657600080fd5b80628e9691146103035780630139009f14610321578063016dff5d146103295780630359fea91461033157806308ac0fd71461033957806311b0aebe1461034e5780631534e0501461036f57806318d928311461038257806319ab453c1461039a5780631ec47600146103ad578063238efcbc146103c057806325eb1c87146103c85780632f91ede9146103d057806331423c26146103d8578063325a19f1146103e0575b600080fd5b61030b6106e8565b6040516103189190612d6f565b60405180910390f35b61030b6106f7565b61030b610701565b61030b61070b565b61034c610347366004612da8565b610715565b005b61036161035c366004612dc5565b610721565b604051908152602001610318565b61034c61037d366004612da8565b610732565b61038a61073b565b6040519015158152602001610318565b61034c6103a8366004612da8565b610745565b61034c6103bb366004612da8565b610868565b61034c610871565b61030b61087b565b61030b610885565b61030b61088f565b610361610899565b61034c6103f6366004612da8565b6108cd565b61034c610409366004612da8565b6108d6565b61034c61041c366004612da8565b6108df565b61034c61042f366004612dde565b6108e8565b61034c610442366004612da8565b6108f9565b61034c610455366004612e36565b610902565b610361610910565b61030b610940565b61034c610478366004612da8565b61094a565b61038a61048b366004612da8565b610a5c565b61030b610a67565b61034c6104a6366004612da8565b610a71565b61030b610a7a565b61034c6104c1366004612f1b565b610a84565b61034c6104d4366004612da8565b610a8d565b61030b610a96565b6104f46104ef366004612f38565b610aa0565b604080519485526020850193909352918301526060820152608001610318565b61030b610b22565b61034c61052a366004612f64565b610b2c565b61034c61053d366004612da8565b610b36565b61034c610550366004612da8565b610b3f565b61034c610563366004612da8565b610b48565b61038a610576366004612da8565b610b51565b610361610b5c565b61030b610b7a565b61030b610b84565b61034c6105a1366004612da8565b610b8e565b61034c6105b4366004612da8565b610b97565b61030b610ba0565b6105e5604051806040016040528060058152602001640312e302e360dc1b81525081565b6040516103189190612f9d565b61030b610baa565b61030b610bda565b61030b610be4565b610361610bee565b61038a610620366004612da8565b610bf8565b61034c610633366004612da8565b610c1d565b61030b610c26565b61034c61064e366004612da8565b610c30565b61036162093a8081565b61038a61066b366004612da8565b610c39565b61034c61067e366004612da8565b610cbe565b61034c610691366004612da8565b610cc7565b61034c6106a4366004612dc5565b610cd0565b61034c6106b7366004612f64565b610cd9565b61030b610ce3565b6105e560405180604001604052806005815260200164312e302e3360d81b81525081565b60006106f2610d13565b905090565b60006106f2610d2f565b60006106f2610d4b565b60006106f2610d67565b61071e81610d83565b50565b600061072c82610e17565b92915050565b61071e81610e54565b60006106f2610edd565b600061074f610ef3565b805490915060ff600160401b820416159067ffffffffffffffff166000811580156107775750825b905060008267ffffffffffffffff1660011480156107945750303b155b9050811580156107a2575080155b156107c05760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff1916600117855583156107ea57845460ff60401b1916600160401b1785555b6107f330610f17565b856107fc610f28565b80546001600160a01b0319166001600160a01b0392909216919091179055831561086057845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b61071e81610f4c565b610879610fae565b565b60006106f261105e565b60006106f261107a565b60006106f2611096565b60006106f26108c960017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b613002565b5490565b61071e816110b2565b61071e81611140565b61071e816111c9565b6108f430848484611252565b505050565b61071e816115c3565b61090c828261164c565b5050565b60006106f26108c960017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1613002565b60006106f2611731565b33301461099c5760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b60006109ba6108c960016000805160206130fe833981519152613002565b6109c5906001613015565b90506109e7816109e460016000805160206130fe833981519152613002565b55565b610a16826109e460017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4613002565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c891015b60405180910390a15050565b600061072c82611752565b60006106f26117a0565b61071e816117bc565b60006106f261181e565b61071e81611837565b61071e8161185d565b60006106f26118e6565b600080600080610b128686306001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ae9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b0d9190613028565b611902565b9299919850965090945092505050565b60006106f26119af565b61090c82826119cb565b61071e81611a38565b61071e81611ac1565b61071e81611b4a565b600061072c82611bd3565b60006106f26108c960016000805160206130fe833981519152613002565b60006106f2611c02565b60006106f2611c1e565b61071e81611c3a565b61071e81611cc3565b60006106f2611d4c565b60006106f26108c960017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4613002565b60006106f2611d68565b60006106f2611d84565b60006106f2611da0565b6000610c02610ce3565b6001600160a01b0316826001600160a01b0316149050919050565b61071e81611dc6565b60006106f2611eff565b61071e81611f1b565b6000816001600160a01b0316610c4d610ce3565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c8a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cae9190613028565b6001600160a01b03161492915050565b61071e81611fa4565b61071e8161202d565b61071e816120b6565b61090c828261211c565b60006106f26108c960017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618613002565b6000610d1d610f28565b600201546001600160a01b0316919050565b6000610d39610f28565b601301546001600160a01b0316919050565b6000610d55610f28565b600a01546001600160a01b0316919050565b6000610d71610f28565b601101546001600160a01b0316919050565b610d8b612194565b6001600160a01b038116610db25760405163d92e233d60e01b815260040160405180910390fd5b80610dbb610f28565b60060180546001600160a01b0319166001600160a01b03929092169190911790556040517f5d77c617926cd1f4106de1bae23b2eb1a9d6e84911f701858a0b1d831e92816590610e0c908390612d6f565b60405180910390a150565b600061072c6a084595161401484a000000610e3b68056bc75e2d6310000085613045565b610e45919061305c565b68056bc75e2d631000006121bc565b610e5c612194565b6001600160a01b038116610e835760405163d92e233d60e01b815260040160405180910390fd5b80610e8c610f28565b60130180546001600160a01b0319166001600160a01b03929092169190911790556040517fcaa89af641ab6d1a458e39f225a12c0d1137f317d718b8713054a445bd2cde6790610e0c908390612d6f565b6000610ee7610f28565b600e015460ff16919050565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b610f1f6121d2565b61071e816121f7565b7f4d96152d518acf5697a667aeb82f27b3218b679995afa077296a84fdcb65bb0090565b610f54612194565b80610f5d610f28565b60010180546001600160a01b0319166001600160a01b03929092169190911790556040517f93a15bbe6d7cb67fff86738ed92efd14e9fe04e7d30042086570034a2f2eb3c290610e0c908390612d6f565b33610fb7610f28565b600101546001600160a01b031614610fe4573360405163ba18f1e160e01b81526004016109939190612d6f565b33610fed610f28565b80546001600160a01b0319166001600160a01b0392909216919091179055611013610f28565b60010180546001600160a01b03191690556040517fb1476cf38ac36ee528f1ad1ae81bdb46de8807d42475e16078426bce6001396190611054903390612d6f565b60405180910390a1565b6000611068610f28565b600f01546001600160a01b0316919050565b6000611084610f28565b600801546001600160a01b0316919050565b60006110a0610f28565b600901546001600160a01b0316919050565b6110ba612194565b6001600160a01b0381166110e15760405163d92e233d60e01b815260040160405180910390fd5b806110ea610f28565b600e0160016101000a8154816001600160a01b0302191690836001600160a01b031602179055507fd86fc86ebea7a7d81c1a9fa7e0977cdafcfccf0cc35295a095231a7b28274e4981604051610e0c9190612d6f565b611148612194565b6001600160a01b03811661116f5760405163d92e233d60e01b815260040160405180910390fd5b80611178610f28565b60030180546001600160a01b0319166001600160a01b03929092169190911790556040517fecbc0f0d903f1b9964d257a8043a5ecdf9c55a8e3d0060fb920b40c4009a257d90610e0c908390612d6f565b6111d1612194565b6001600160a01b0381166111f85760405163d92e233d60e01b815260040160405180910390fd5b80611201610f28565b60120180546001600160a01b0319166001600160a01b03929092169190911790556040517fe34dace06c75fb12cb36ab5627f4ad085768e0e550b787566c647aa0cd052b0690610e0c908390612d6f565b61125b84612314565b6000806000806112a487878a6001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ae9573d6000803e3d6000fd5b6040516323b872dd60e01b81526001600160a01b038a81166004830152306024830152604482018c90529498509296509094509250908816906323b872dd906064016020604051808303816000875af1158015611305573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611329919061307e565b50801561140457866001600160a01b031663a9059cbb896001600160a01b0316630359fea96040518163ffffffff1660e01b8152600401602060405180830381865afa15801561137d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113a19190613028565b836040518363ffffffff1660e01b81526004016113bf92919061309b565b6020604051808303816000875af11580156113de573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611402919061307e565b505b82156114de57866001600160a01b031663a9059cbb896001600160a01b03166361d027b36040518163ffffffff1660e01b8152600401602060405180830381865afa158015611457573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061147b9190613028565b856040518363ffffffff1660e01b815260040161149992919061309b565b6020604051808303816000875af11580156114b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114dc919061307e565b505b831561155157604051630852cd8d60e31b8152600481018590526001600160a01b038816906342966c68906024016020604051808303816000875af115801561152b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061154f919061307e565b505b61155a87612624565b604080516001600160a01b03898116825260208201899052871681830152606081018690526080810185905260a0810184905290517f1fd334c200f7b34cefbcb9762981e99dea5bdff9c149c5e4a279a1f55e8c97729181900360c00190a15050505050505050565b6115cb612194565b6001600160a01b0381166115f25760405163d92e233d60e01b815260040160405180910390fd5b806115fb610f28565b600f0180546001600160a01b0319166001600160a01b03929092169190911790556040517f0d1f076dd618d44fc1ed0ae909dcb5a875262080a1fb3386f155e47003323ed790610e0c908390612d6f565b611654612bf9565b60005b82518110156108f457828181518110611672576116726130b4565b60200260200101516001600160a01b0316630900f010836040518263ffffffff1660e01b81526004016116a59190612d6f565b600060405180830381600087803b1580156116bf57600080fd5b505af11580156116d3573d6000803e3d6000fd5b505050507fd32d24edea94f55e932d9a008afc425a8561462d1b1f57bc6e508e9a6b9509e183828151811061170a5761170a6130b4565b6020026020010151836040516117219291906130ca565b60405180910390a1600101611657565b600061173b610f28565b600e015461010090046001600160a01b0316919050565b60008061175d610f28565b6001600160a01b0384166000908152600d9190910160205260409020549050801580159061178a57508042105b80611799575061179983612c21565b9392505050565b60006117aa610f28565b600301546001600160a01b0316919050565b6117c4612194565b806117cd610f28565b60140180546001600160a01b0319166001600160a01b03929092169190911790556040517f1d609dbce8c46093a144a3723e81b905c328eb5034d986a74301fb4764ded28190610e0c908390612d6f565b6000611828610f28565b546001600160a01b0316919050565b61183f612bf9565b80611848610f28565b600e01805460ff191691151591909117905550565b611865612194565b6001600160a01b03811661188c5760405163d92e233d60e01b815260040160405180910390fd5b80611895610f28565b60020180546001600160a01b0319166001600160a01b03929092169190911790556040517f573b0be2ffc8c66825968c4e3b38a0af5edb18ce20f9a516e0f8a04867d2638990610e0c908390612d6f565b60006118f0610f28565b600501546001600160a01b0316919050565b600080600080846001600160a01b0316876001600160a01b03160361195557600261192d8588613002565b611937919061305c565b9250826119448588613002565b61194e9190613002565b91506119a6565b620186a06119666201388088613045565b611970919061305c565b9050620186a061198261271088613045565b61198c919061305c565b9250826119998288613002565b6119a39190613002565b91505b93509350935093565b60006119b9610f28565b600601546001600160a01b0316919050565b6119d3612194565b8015611a02576119e1610f28565b6001600160a01b0383166000908152600d9190910160205260408120555050565b611a0f62093a8042613015565b611a17610f28565b6001600160a01b0384166000908152600d9190910160205260409020555050565b611a40612194565b6001600160a01b038116611a675760405163d92e233d60e01b815260040160405180910390fd5b80611a70610f28565b60090180546001600160a01b0319166001600160a01b03929092169190911790556040517fedcd6ea89a41d21f1bafa9a7cc32e754079d18642839a1a48c938447d2a740eb90610e0c908390612d6f565b611ac9612194565b6001600160a01b038116611af05760405163d92e233d60e01b815260040160405180910390fd5b80611af9610f28565b60040180546001600160a01b0319166001600160a01b03929092169190911790556040517f0e05ae75e8b926552cf6fcd744d19f422561e3ced1e426868730852702dbe41890610e0c908390612d6f565b611b52612194565b6001600160a01b038116611b795760405163d92e233d60e01b815260040160405180910390fd5b80611b82610f28565b60110180546001600160a01b0319166001600160a01b03929092169190911790556040517f657bb19de5473f7be7de9ccbcfa6d9aabcb3cfd199aef85e949a1d8570c290ab90610e0c908390612d6f565b6000611bdd610f28565b6001600160a01b039092166000908152600c9290920160205250604090205460ff1690565b6000611c0c610f28565b600401546001600160a01b0316919050565b6000611c28610f28565b600101546001600160a01b0316919050565b611c42612194565b6001600160a01b038116611c695760405163d92e233d60e01b815260040160405180910390fd5b80611c72610f28565b600b0180546001600160a01b0319166001600160a01b03929092169190911790556040517f035bee136adcafe288762d810fef741bc236d20bb1b469acb4c23e5357f0856790610e0c908390612d6f565b611ccb612194565b6001600160a01b038116611cf25760405163d92e233d60e01b815260040160405180910390fd5b80611cfb610f28565b60070180546001600160a01b0319166001600160a01b03929092169190911790556040517ffa195fffb4bf4e5339e2e98fb090f0d634c64261640c07c1ee6ee43d5f23516190610e0c908390612d6f565b6000611d56610f28565b600701546001600160a01b0316919050565b6000611d72610f28565b601201546001600160a01b0316919050565b6000611d8e610f28565b601401546001600160a01b0316919050565b6000611daa610f28565b60100154905080600003611dc35750678ac7230489e800005b90565b611dce612194565b6040516370a0823160e01b81526000906001600160a01b038316906370a0823190611dfd903090600401612d6f565b602060405180830381865afa158015611e1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e3e91906130e4565b9050801561090c57816001600160a01b031663a9059cbb611e5d610f28565b546040516001600160e01b031960e084901b168152611e8a916001600160a01b031690859060040161309b565b6020604051808303816000875af1158015611ea9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ecd919061307e565b507fd8138f8a3f377c5259ca548e70e4c2de94f129f5a11036a15b69513cba2b426a8282604051610a5092919061309b565b6000611f09610f28565b600b01546001600160a01b0316919050565b611f23612194565b6001600160a01b038116611f4a5760405163d92e233d60e01b815260040160405180910390fd5b80611f53610f28565b600a0180546001600160a01b0319166001600160a01b03929092169190911790556040517fd1e9a4ae1231531a757f1e31a2ff8a1db9d359a194436efe40bccb972cde86f090610e0c908390612d6f565b611fac612194565b6001600160a01b038116611fd35760405163d92e233d60e01b815260040160405180910390fd5b80611fdc610f28565b60080180546001600160a01b0319166001600160a01b03929092169190911790556040517f29fdde0e067ae34f44ca706fd84ea4b9dabb69557e7e935d379c932ba023b2be90610e0c908390612d6f565b612035612194565b6001600160a01b03811661205c5760405163d92e233d60e01b815260040160405180910390fd5b80612065610f28565b60050180546001600160a01b0319166001600160a01b03929092169190911790556040517fc714d22a2f08b695f81e7c707058db484aa5b4d6b4c9fd64beb10fe85832f60890610e0c908390612d6f565b6120be612194565b806000036120df57604051631f2a200560e01b815260040160405180910390fd5b806120e8610f28565b601001556040518181527f867c590cfc1b2ba6732d5d876a96733ad5cde9c836a978d6107517c00cf3f44590602001610e0c565b612124612194565b8061212d610f28565b6001600160a01b0384166000818152600c929092016020908152604092839020805460ff1916941515949094179093558151908152831515928101929092527f0de9c5667496fd561ff9dfa59efdc1c76f7dbf3844adae3d14a3a14d563321b19101610a50565b61219d33612c21565b610879573360405163988d1f0360e01b81526004016109939190612d6f565b60008183106121cb5781611799565b5090919050565b6121da612c6b565b61087957604051631afcd79f60e31b815260040160405180910390fd5b6001600160a01b03811661223f5760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b6044820152606401610993565b61226e816109e460017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618613002565b61229d426109e460017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b613002565b6122cc436109e460017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1613002565b604080516001600160a01b038316815242602082015243918101919091527f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe23671342690606001610e0c565b336001600160a01b0316816001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561235c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123809190613028565b6001600160a01b03161415801561240a5750336001600160a01b0316816001600160a01b031663490fb76a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156123da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123fe9190613028565b6001600160a01b031614155b80156124895750336001600160a01b0316816001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa158015612459573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061247d9190613028565b6001600160a01b031614155b80156125085750336001600160a01b0316816001600160a01b0316632f91ede96040518163ffffffff1660e01b8152600401602060405180830381865afa1580156124d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124fc9190613028565b6001600160a01b031614155b80156125875750336001600160a01b0316816001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa158015612557573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061257b9190613028565b6001600160a01b031614155b80156126065750336001600160a01b0316816001600160a01b031663524a562f6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156125d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125fa9190613028565b6001600160a01b031614155b1561071e5760405163f20e063760e01b815260040160405180910390fd5b600061262e610f28565b601401546001600160a01b03169050801561090c576000816001600160a01b031663ff3a4ac06040518163ffffffff1660e01b8152600401602060405180830381865afa158015612683573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126a79190613028565b9050806001600160a01b0316836001600160a01b0316036128a257816001600160a01b0316631ed241956040518163ffffffff1660e01b8152600401602060405180830381865afa158015612700573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061272491906130e4565b826001600160a01b0316630a441f7b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612762573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061278691906130e4565b10156108f4576040516370a0823160e01b81526000906001600160a01b038516906370a08231906127bb903090600401612d6f565b602060405180830381865afa1580156127d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127fc91906130e4565b9050801561280f5761280f848285612c85565b60405163e270d1df60e01b8152600481018290526001600160a01b0384169063e270d1df90602401600060405180830381600087803b15801561285157600080fd5b505af1925050508015612862575060015b1561289c576040518181527fd1c043d38a3243c01780647a1340049807cd98af891021c89c32c99a8e0c59e7906020015b60405180910390a15b50505050565b6040516370a0823160e01b81526000906001600160a01b038516906370a08231906128d1903090600401612d6f565b602060405180830381865afa1580156128ee573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061291291906130e4565b9050826001600160a01b0316636180c3f9846001600160a01b03166379d83f8e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612961573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129859190613028565b866040518363ffffffff1660e01b81526004016129a39291906130ca565b602060405180830381865afa1580156129c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129e491906130e4565b811180156129fe575060006129fc62093a808361305c565b115b15612aa657612a0e848285612c85565b60405163b66503cf60e01b81526001600160a01b0384169063b66503cf90612a3c908790859060040161309b565b600060405180830381600087803b158015612a5657600080fd5b505af1925050508015612a67575060015b15612aa6577ff6b60b7da8e0f883e399412005b6205515604a993e7e3f0c3b199b9cb07d6ae68482604051612a9d92919061309b565b60405180910390a15b826001600160a01b0316631ed241956040518163ffffffff1660e01b8152600401602060405180830381865afa158015612ae4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b0891906130e4565b836001600160a01b0316630a441f7b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612b46573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b6a91906130e4565b101561289c5760405163e270d1df60e01b8152600060048201526001600160a01b0384169063e270d1df90602401600060405180830381600087803b158015612bb257600080fd5b505af1925050508015612bc3575060015b1561289c57604051600081527fd1c043d38a3243c01780647a1340049807cd98af891021c89c32c99a8e0c59e790602001612893565b612c0233611752565b610879573360405163451cea1760e11b81526004016109939190612d6f565b6000816001600160a01b0316306001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c8a573d6000803e3d6000fd5b6000612c75610ef3565b54600160401b900460ff16919050565b604051636eb1769f60e11b815282906001600160a01b0385169063dd62ed3e90612cb590309086906004016130ca565b602060405180830381865afa158015612cd2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612cf691906130e4565b10156108f45760405163095ea7b360e01b81526001600160a01b0384169063095ea7b390612d2c9084906000199060040161309b565b6020604051808303816000875af1158015612d4b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061289c919061307e565b6001600160a01b0391909116815260200190565b6001600160a01b038116811461071e57600080fd5b8035612da381612d83565b919050565b600060208284031215612dba57600080fd5b813561179981612d83565b600060208284031215612dd757600080fd5b5035919050565b600080600060608486031215612df357600080fd5b8335612dfe81612d83565b9250602084013591506040840135612e1581612d83565b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b60008060408385031215612e4957600080fd5b823567ffffffffffffffff80821115612e6157600080fd5b818501915085601f830112612e7557600080fd5b8135602082821115612e8957612e89612e20565b8160051b604051601f19603f83011681018181108682111715612eae57612eae612e20565b604052928352818301935084810182019289841115612ecc57600080fd5b948201945b83861015612ef157612ee286612d98565b85529482019493820193612ed1565b9650612f009050878201612d98565b9450505050509250929050565b801515811461071e57600080fd5b600060208284031215612f2d57600080fd5b813561179981612f0d565b60008060408385031215612f4b57600080fd5b8235612f5681612d83565b946020939093013593505050565b60008060408385031215612f7757600080fd5b8235612f8281612d83565b91506020830135612f9281612f0d565b809150509250929050565b60006020808352835180602085015260005b81811015612fcb57858101830151858201604001528201612faf565b506000604082860101526040601f19601f8301168501019250505092915050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561072c5761072c612fec565b8082018082111561072c5761072c612fec565b60006020828403121561303a57600080fd5b815161179981612d83565b808202811582820484141761072c5761072c612fec565b60008261307957634e487b7160e01b600052601260045260246000fd5b500490565b60006020828403121561309057600080fd5b815161179981612f0d565b6001600160a01b03929092168252602082015260400190565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b0392831681529116602082015260400190565b6000602082840312156130f657600080fd5b505191905056fe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda26469706673582212209dab2921094ac04a62bc389e403315b51537eec1a88ac4e5c4423ae9162982f964736f6c63430008170033",
  "devdoc": {
    "errors": {
      "InvalidInitialization()": [
        {
          "details": "The contract is already initialized."
        }
      ],
      "NotInitializing()": [
        {
          "details": "The contract is not initializing."
        }
      ]
    },
    "events": {
      "Initialized(uint64)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      }
    },
    "kind": "dev",
    "methods": {
      "created()": {
        "returns": {
          "_0": "Creation timestamp"
        }
      },
      "createdBlock()": {
        "returns": {
          "_0": "Creation block number"
        }
      },
      "increaseRevision(address)": {
        "details": "Revision should be increased on each contract upgrade"
      },
      "isController(address)": {
        "details": "Return true if given address is controller"
      },
      "previousImplementation()": {
        "details": "Previous logic implementation"
      },
      "process(address,uint256,address)": {
        "params": {
          "amount": "Assume that this amount is approved by {from} to this contract"
        }
      },
      "revision()": {
        "details": "Contract upgrade counter"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "CONTROLLABLE_VERSION()": {
        "notice": "Version of the contract"
      },
      "VERSION()": {
        "notice": "Version of the contract"
      },
      "controller()": {
        "notice": "Return controller address saved in the contract slot"
      },
      "created()": {
        "notice": "Return creation timestamp"
      },
      "createdBlock()": {
        "notice": "Return creation block number"
      },
      "isGovernance(address)": {
        "notice": "Return true if given address is setup as governance in Controller"
      },
      "process(address,uint256,address)": {
        "notice": "Transfer {amount} from {from}, divide it on three parts: to treasury, to governance, to burn User must approve given amount to the controller."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}