{
  "language": "Solidity",
  "sources": {
    "contracts/core/Controller.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../proxy/Controllable.sol\";\nimport \"../lib/ControllerLib.sol\";\n\ncontract Controller is Controllable, IController {\n\n  //region ------------------------ Constants\n  /// @notice Version of the contract\n  string public constant override VERSION = \"1.0.3\";\n  uint public constant DEPLOYER_ELIGIBILITY_PERIOD = ControllerLib.DEPLOYER_ELIGIBILITY_PERIOD;\n  //endregion ------------------------ Constants\n\n  //region ------------------------ Initializer\n  function init(address governance_) external initializer {\n    __Controllable_init(address(this));\n    ControllerLib._S().governance = governance_;\n  }\n  //endregion ------------------------ Initializer\n\n  //region ------------------------ Views\n\n  function isDeployer(address adr) public view override returns (bool) {\n    return ControllerLib.isDeployer(adr);\n  }\n\n  function governance() external view override returns (address) {\n    return ControllerLib.governance();\n  }\n\n  function futureGovernance() external view returns (address) {\n    return ControllerLib.futureGovernance();\n  }\n\n  function statController() external view override returns (address) {\n    return ControllerLib.statController();\n  }\n\n  function storyController() external view override returns (address) {\n    return ControllerLib.storyController();\n  }\n\n  function oracle() external view override returns (address) {\n    return ControllerLib.oracle();\n  }\n\n  function treasury() external view override returns (address) {\n    return ControllerLib.treasury();\n  }\n\n  function dungeonFactory() external view override returns (address) {\n    return ControllerLib.dungeonFactory();\n  }\n\n  function gameObjectController() external view override returns (address) {\n    return ControllerLib.gameObjectController();\n  }\n\n  function reinforcementController() external view override returns (address) {\n    return ControllerLib.reinforcementController();\n  }\n\n  function itemController() external view override returns (address) {\n    return ControllerLib.itemController();\n  }\n\n  function heroController() external view override returns (address) {\n    return ControllerLib.heroController();\n  }\n\n  function gameToken() external view override returns (address) {\n    return ControllerLib.gameToken();\n  }\n\n  function validTreasuryTokens(address token) external view override returns (bool) {\n    return ControllerLib.validTreasuryTokens(token);\n  }\n\n  function onPause() external view override returns (bool) {\n    return ControllerLib.onPause();\n  }\n\n  function userController() external view override returns (address) {\n    return ControllerLib.userController();\n  }\n\n  function guildController() external view override returns (address) {\n    return ControllerLib.guildController();\n  }\n  //endregion ------------------------ Views\n\n  //region ------------------------ Gov actions - setters\n\n  function changePause(bool value) external {\n    ControllerLib.changePause(value);\n  }\n\n  function offerGovernance(address newGov) external {\n    ControllerLib.offerGovernance(newGov);\n  }\n\n  function acceptGovernance() external {\n    ControllerLib.acceptGovernance();\n  }\n\n  function setStatController(address value) external {\n    ControllerLib.setStatController(value);\n  }\n\n  function setStoryController(address value) external {\n    ControllerLib.setStoryController(value);\n  }\n\n  function setGameObjectController(address value) external {\n    ControllerLib.setGameObjectController(value);\n  }\n\n  function setReinforcementController(address value) external {\n    ControllerLib.setReinforcementController(value);\n  }\n\n  function setOracle(address value) external {\n    ControllerLib.setOracle(value);\n  }\n\n  function setTreasury(address value) external {\n    ControllerLib.setTreasury(value);\n  }\n\n  function setItemController(address value) external {\n    ControllerLib.setItemController(value);\n  }\n\n  function setHeroController(address value) external {\n    ControllerLib.setHeroController(value);\n  }\n\n  function setGameToken(address value) external {\n    ControllerLib.setGameToken(value);\n  }\n\n  function setDungeonFactory(address value) external {\n    ControllerLib.setDungeonFactory(value);\n  }\n\n  function changeDeployer(address eoa, bool remove) external {\n    ControllerLib.changeDeployer(eoa, remove);\n  }\n\n  function setUserController(address value) external {\n    ControllerLib.setUserController(value);\n  }\n\n  function setGuildController(address value) external {\n    ControllerLib.setGuildController(value);\n  }\n  //endregion ------------------------ Gov actions - setters\n\n  //region ------------------------ Gov actions - others\n\n  function updateProxies(address[] memory proxies, address newLogic) external {\n    ControllerLib.updateProxies(proxies, newLogic);\n  }\n\n  function claimToGovernance(address token) external {\n    ControllerLib.claimToGovernance(token);\n  }\n  //endregion ------------------------ Gov actions - others\n\n  //region ------------------------ REGISTER ACTIONS\n\n  function changeTreasuryTokenStatus(address token, bool status) external {\n    ControllerLib.changeTreasuryTokenStatus(token, status);\n  }\n  //endregion ------------------------ REGISTER ACTIONS\n}\n"
    },
    "contracts/core/DungeonFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\nimport \"../proxy/Controllable.sol\";\nimport \"../lib/DungeonFactoryLib.sol\";\nimport \"../relay/ERC2771Context.sol\";\nimport \"../openzeppelin/ERC721Holder.sol\";\n\ncontract DungeonFactory is Controllable, IDungeonFactory, ERC2771Context, ERC721Holder {\n  //region ------------------------ CONSTANTS\n\n  /// @notice Version of the contract\n  string public constant override VERSION = \"2.1.1\";\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ INITIALIZER\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ------------------------ INITIALIZER\n\n  //region ------------------------ VIEWS\n  function dungeonAttributes(uint16 dungLogicNum) external view returns (DungeonAttributes memory) {\n    return DungeonFactoryLib.dungeonAttributes(dungLogicNum);\n  }\n\n  function dungeonStatus(uint64 dungeonId) external view returns (\n    uint16 dungNum,\n    bool isCompleted,\n    address heroToken,\n    uint heroTokenId,\n    uint32 currentObject,\n    uint8 currentObjIndex,\n    address[] memory treasuryTokens,\n    uint[] memory treasuryTokensAmounts,\n    bytes32[] memory treasuryItems,\n    uint8 stages,\n    uint32[] memory uniqObjects\n  ) {\n    return DungeonFactoryLib.dungeonStatus(dungeonId);\n  }\n\n  function dungeonCounter() external view returns (uint64) {\n    return DungeonFactoryLib.dungeonCounter();\n  }\n\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view override returns (uint8) {\n    return DungeonFactoryLib.maxBiomeCompleted(heroToken, heroTokenId);\n  }\n\n  function currentDungeon(address heroToken, uint heroTokenId) external view override returns (uint64) {\n    return DungeonFactoryLib.currentDungeon(heroToken, heroTokenId);\n  }\n\n  function minLevelForTreasury(address token) external view returns (uint) {\n    return DungeonFactoryLib.minLevelForTreasury(token);\n  }\n\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external override view returns (uint8[] memory result) {\n    return DungeonFactoryLib.skillSlotsForDurabilityReduction(heroToken, heroTokenId);\n  }\n\n  function freeDungeonsByLevelLength(uint biome) external view returns (uint) {\n    return DungeonFactoryLib.freeDungeonsByLevelLength(biome);\n  }\n\n  function freeDungeonsByLevel(uint id, uint biome) external view returns (uint64) {\n    return DungeonFactoryLib.freeDungeonsByLevel(id, biome);\n  }\n\n  function dungeonTreasuryReward(address token, uint maxAvailableBiome, uint treasuryBalance, uint8 heroLevel, uint8 dungeonBiome)\n  external view returns (uint) {\n    return DungeonLib.dungeonTreasuryReward(token, maxAvailableBiome, treasuryBalance, heroLevel, dungeonBiome);\n  }\n\n  function getDungeonTreasuryAmount(address token, uint heroLevel, uint biome) external view returns (\n    uint totalAmount,\n    uint amountForDungeon,\n    uint mintAmount\n  ) {\n    return DungeonFactoryLib.getDungeonTreasuryAmount(IController(controller()), token, heroLevel, biome);\n  }\n\n  function getDungeonLogic(IController controller_, uint8 heroLevel, address heroToken, uint heroTokenId, uint random)\n  external view returns (uint16) {\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller_);\n    return DungeonLib.getDungeonLogic(DungeonLib._S(), cc, heroLevel, heroToken, heroTokenId, random);\n  }\n\n  function isDungeonEligibleForHero(uint16 dungeonLogic, uint8 heroLevel, address heroToken, uint heroTokenId)\n  external view returns (bool) {\n    return DungeonLib.isDungeonEligibleForHero(\n      DungeonLib._S(),\n      IStatController(IController(controller()).statController()),\n      dungeonLogic,\n      heroLevel,\n      heroToken,\n      heroTokenId\n    );\n  }\n\n  /// @dev Easily get info should given hero fight with boss in the current biome or not.\n  function isBiomeBoss(address heroToken, uint heroTokenId) external view returns (bool) {\n    return DungeonFactoryLib.isBiomeBoss(IController(controller()), heroToken, heroTokenId);\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ ACTIONS\n\n  function launch(address heroToken, uint heroTokenId, address treasuryToken) external returns (uint64 dungeonId) {\n    return DungeonFactoryLib.launch(_isNotSmartContract(), IController(controller()), _msgSender(), heroToken, heroTokenId, treasuryToken);\n  }\n\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external override returns (uint64 dungeonId) {\n    return DungeonFactoryLib.launchForNewHero(IController(controller()), owner, heroToken, heroTokenId);\n  }\n\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external override {\n    DungeonFactoryLib.setBossCompleted(IController(controller()), objectId, heroToken, heroTokenId, heroBiome);\n  }\n  //endregion ------------------------ ACTIONS\n\n  //////////////////////////////////////////////////////////////////////////////////////\n  //           DUNGEON LOGIC\n  //////////////////////////////////////////////////////////////////////////////////////\n\n  //region ------------------------ GOV ACTIONS\n\n  /// @notice Register ordinal or specific dungeon\n  /// @param biome Assume biome > 0\n  /// @param isSpecific The dungeon is specific, so it shouldn't be registered in dungeonsLogicByBiome\n  /// @param specReqBiome required biome\n  /// @param specReqHeroClass required hero class\n  function registerDungeonLogic(\n    uint16 dungLogicId,\n    uint8 biome,\n    DungeonGenerateInfo calldata genInfo,\n    uint8 specReqBiome,\n    uint8 specReqHeroClass,\n    bool isSpecific\n  ) external {\n    DungeonFactoryLib.registerDungeonLogic(\n      IController(controller()),\n      dungLogicId,\n      biome,\n      genInfo,\n      specReqBiome,\n      specReqHeroClass,\n      isSpecific\n    );\n  }\n\n  function removeDungeonLogic(uint16 dungLogicId, uint8 specReqBiome, uint8 specReqHeroClass) external {\n    DungeonFactoryLib.removeDungeonLogic(IController(controller()), dungLogicId, specReqBiome, specReqHeroClass);\n  }\n\n  /// @dev Set eligible hero level for treasury tokens\n  function setMinLevelForTreasury(address token, uint heroLevel) external {\n    DungeonFactoryLib.setMinLevelForTreasury(IController(controller()), token, heroLevel);\n  }\n\n  /// @dev Governance can drop hero from dungeon in emergency case\n  function emergencyExit(uint64 dungId) external {\n    DungeonFactoryLib.emergencyExit(IController(controller()), dungId);\n  }\n  //endregion ------------------------ GOV ACTIONS\n\n  //region ------------------------ USER ACTIONS\n  function enter(uint64 dungId, address heroToken_, uint heroTokenId_) external {\n    DungeonFactoryLib.enter(_isNotSmartContract(), IController(controller()), _msgSender(), dungId, heroToken_, heroTokenId_);\n  }\n\n  function openObject(uint64 dungId) external {\n    DungeonFactoryLib.openObject(_isNotSmartContract(), IController(controller()), _msgSender(), dungId);\n  }\n\n  function objectAction(uint64 dungId, bytes memory data) external {\n    DungeonFactoryLib.objectAction(_isNotSmartContract(), IController(controller()), _msgSender(), dungId, data);\n  }\n\n  function exit(uint64 dungId, bool claim) external {\n    DungeonFactoryLib.exit(_isNotSmartContract(), IController(controller()), _msgSender(), dungId, claim);\n  }\n  //endregion ------------------------ USER ACTIONS\n}\n"
    },
    "contracts/core/GameObjectController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../interfaces/IGOC.sol\";\nimport \"../proxy/Controllable.sol\";\nimport \"../lib/GameObjectControllerLib.sol\";\nimport \"../lib/PackingLib.sol\";\nimport \"../lib/EventLib.sol\";\nimport \"../lib/StoryLib.sol\";\nimport \"../lib/MonsterLib.sol\";\nimport \"../lib/GOCLib.sol\";\n\ncontract GameObjectController is Controllable, IGOC {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using PackingLib for bytes32;\n  using PackingLib for uint16;\n  using PackingLib for uint8;\n  using PackingLib for address;\n  using PackingLib for uint32[];\n  using PackingLib for uint32;\n  using PackingLib for uint64;\n  using PackingLib for int32[];\n  using PackingLib for int32;\n\n  //region ------------------------ CONSTANTS\n\n  /// @notice Version of the contract\n  string public constant VERSION = \"1.1.5\";\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ INITIALIZER\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ------------------------ INITIALIZER\n\n  //region ------------------------ VIEWS\n\n  function getObjectMeta(uint32 objectId) external view override returns (uint8 biome, uint8 objectSubType) {\n    return GameObjectControllerLib.getObjectMeta(objectId);\n  }\n\n  function isAvailableForHero(address heroToken, uint heroTokenId, uint32 objId) external view returns (bool) {\n    return GameObjectControllerLib.isAvailableForHero(IController(controller()), heroToken, heroTokenId, objId);\n  }\n\n  function isBattleObject(uint32 objectId) external view override returns (bool) {\n    return GameObjectControllerLib.isBattleObject(objectId);\n  }\n\n  function getObjectTypeBySubType(uint32 objectId) external view returns (ObjectType) {\n    return GameObjectControllerLib.getObjectTypeBySubType(objectId);\n  }\n\n  function getMonsterInfo(address hero, uint heroId, uint32 objectId) external view returns (IGOC.MonsterGenInfo memory mGenInfo, IGOC.GeneratedMonster memory gen) {\n    return GameObjectControllerLib.getMonsterInfo(hero, heroId, objectId);\n  }\n\n  function getIteration(address heroToken, uint heroTokenId, uint32 objId) external view returns (uint) {\n    return GameObjectControllerLib.getIteration(heroToken, heroTokenId, objId);\n  }\n\n  function getLastHeroFightTs(address heroToken, uint heroTokenId) external view returns (uint) {\n    return GameObjectControllerLib.getLastHeroFightTs(heroToken, heroTokenId);\n  }\n\n  function getFightDelay() external view returns (uint) {\n    return GameObjectControllerLib.getFightDelay();\n  }\n\n  function getStoryId(uint32 objectId) external view returns (uint16) {\n    return GameObjectControllerLib.getStoryId(objectId);\n  }\n\n  function getEventInfo(uint32 objectId) external view returns (EventInfo memory) {\n    return GameObjectControllerLib.getEventInfo(objectId);\n  }\n\n  function getObjectIds(uint8 biome, ObjectSubType subType) external view returns (uint[] memory) {\n    return GameObjectControllerLib.getObjectIds(biome, subType);\n  }\n\n  function getMonsterMultiplier() external view returns (int32) {\n    return MonsterLib.getMonsterMultiplier(IController(controller()));\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ REGISTRATION\n\n  function registerEvent(EventRegInfo memory regInfo) external {\n    GameObjectControllerLib.registerEvent(IController(controller()), regInfo);\n  }\n\n  function registerStory(uint16 storyId, uint8 biome, ObjectSubType subType) external {\n    GameObjectControllerLib.registerStory(IController(controller()), storyId, biome, subType);\n  }\n\n  function registerMonster(MonsterGenInfo memory monsterGenInfo) external {\n    GameObjectControllerLib.registerMonster(IController(controller()), monsterGenInfo);\n  }\n\n  function removeObject(uint32 objectId) external {\n    GameObjectControllerLib.removeObject(IController(controller()), objectId);\n  }\n\n  //endregion ------------------------ REGISTRATION\n\n  //region ------------------------ OBJECT\n\n  /// @dev Chances in range 0-1e9\n  function getRandomObject(\n    uint8[] memory cTypes,\n    uint32[] memory chances,\n    uint8 biome,\n    address heroToken,\n    uint heroTokenId\n  ) external override returns (uint32 objectId) {\n    return GameObjectControllerLib.getRandomObject(IController(controller()), cTypes, chances, biome, heroToken, heroTokenId);\n  }\n\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external override returns (uint iteration) {\n    return GameObjectControllerLib.open(IController(controller()), heroToken, heroTokenId, objectId);\n  }\n\n  function action(\n    address sender,\n    uint64 dungeonId,\n    uint32 objectId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 stageId,\n    bytes memory data\n  ) external override returns (ActionResult memory) {\n    return GameObjectControllerLib.action(IController(controller()), sender, dungeonId, objectId, heroToken, heroTokenId, stageId, data);\n  }\n\n  //endregion ------------------------ OBJECT\n\n}\n"
    },
    "contracts/core/GuildController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IGuildController.sol\";\nimport \"../lib/GuildControllerLib.sol\";\nimport \"../proxy/Controllable.sol\";\nimport \"../relay/ERC2771Context.sol\";\n\ncontract GuildController is Initializable, Controllable, ERC2771Context, IGuildController {\n  //region ------------------------ CONSTANTS\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant override VERSION = \"1.0.0\";\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ INITIALIZER\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ------------------------ INITIALIZER\n\n// TODO\n//  //region ------------------------ VIEWS\n//  function counterGuildIds() internal view returns (uint) {\n//    return GuildControllerLib.counterGuildIds();\n//  }\n//\n//  //endregion ------------------------ VIEWS\n//\n//  //region ------------------------ ACTIONS\n//\n//  /// @notice Create new guild, pay BASE_FEE\n//  function createGuild(string memory name, string memory urlLogo) external {\n//    GuildControllerLib.createGuild(_isNotSmartContract(), IController(controller()), _msgSender(), name, urlLogo);\n//  }\n//\n//  /// @notice Add new member to the guild to which msgSender belongs\n//  function addGuildMember(address newUser, uint maskRoles) external {\n//    GuildControllerLib.addGuildMember(_msgSender(), newUser, maskRoles);\n//  }\n//\n//  /// @notice Edit roles of the given member of the guild to which msgSender belongs\n//  function changeRoles(address user, uint maskRoles) external {\n//    GuildControllerLib.changeRoles(_msgSender(), user, maskRoles);\n//  }\n//\n//  /// @notice Remove given member from the guild to which msgSender belongs\n//  /// @dev To delete the guild the owner should remove all members and remove himself at the end\n//  function removeGuildMember(address userToRemove) external {\n//    GuildControllerLib.removeGuildMember(_msgSender(), userToRemove);\n//  }\n//\n//  /// @notice Increment level of the guild, pay BASE_FEE * new level\n//  function guildLevelUp() external {\n//    GuildControllerLib.guildLevelUp(IController(controller()), _msgSender());\n//  }\n//\n//  /// @notice Rename the guild, pay BASE_FEE * current level\n//  function rename(string memory newName) external {\n//    GuildControllerLib.rename(IController(controller()), _msgSender(), newName);\n//  }\n\n  //endregion ------------------------ ACTIONS\n}"
    },
    "contracts/core/HeroController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../proxy/Controllable.sol\";\nimport \"../relay/ERC2771Context.sol\";\nimport \"../lib/HeroLib.sol\";\nimport \"../lib/HeroControllerLib.sol\";\nimport \"../lib/PackingLib.sol\";\nimport \"../lib/ScoreLib.sol\";\nimport \"../interfaces/IHeroController.sol\";\n\ncontract HeroController is Controllable, ERC2771Context, IHeroController {\n  using PackingLib for bytes32;\n  using PackingLib for address;\n\n  /// @notice Version of the contract\n  string public constant VERSION = \"1.0.3\";\n\n  //region ------------------------ INITIALIZER\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ------------------------ INITIALIZER\n\n\n  //region ------------------------ VIEWS\n  function heroTokensVault() external view returns (address) {\n    return HeroControllerLib.heroTokensVault();\n  }\n\n  function payTokenInfo(address hero) external view returns (address token, uint amount) {\n    return HeroControllerLib.payTokenInfo(hero);\n  }\n\n  function heroClass(address hero) external view returns (uint8) {\n    return HeroControllerLib.heroClass(hero);\n  }\n\n  function heroName(address hero, uint heroId) external view returns (string memory) {\n    return HeroControllerLib.heroName(hero, heroId);\n  }\n\n  function nameToHero(string memory name) external view returns (address hero, uint heroId) {\n    return HeroControllerLib.nameToHero(name);\n  }\n\n  function heroBiome(address hero, uint heroId) external view override returns (uint8) {\n    return HeroControllerLib.heroBiome(hero, heroId);\n  }\n\n  function heroReinforcementHelp(address hero, uint heroId) external view override returns (\n    address helperHeroToken,\n    uint helperHeroId\n  ) {\n    return HeroControllerLib.heroReinforcementHelp(hero, heroId);\n  }\n\n  function score(address hero, uint heroId) external view returns (uint) {\n    return HeroControllerLib.score(IController(controller()), hero, heroId);\n  }\n\n  function isAllowedToTransfer(address hero, uint heroId) external view override returns (bool) {\n    return HeroControllerLib.isAllowedToTransfer(IController(controller()), hero, heroId);\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ GOV ACTIONS\n\n  function setHeroTokensVault(address value) external {\n    HeroControllerLib.setHeroTokensVault(IController(controller()), value);\n  }\n\n  function registerHero(address hero, uint8 heroClass_, address payToken, uint payAmount) external {\n    HeroControllerLib.registerHero(IController(controller()), hero, heroClass_, payToken, payAmount);\n  }\n  //endregion ------------------------ GOV ACTIONS\n\n  //region ------------------------ USER ACTIONS\n\n  function create(address hero, string calldata heroName_, bool enter) external override returns (uint) {\n    return HeroControllerLib.create(IController(controller()), _msgSender(), hero, heroName_, enter);\n  }\n\n  function createWithRefCode(address hero, string calldata heroName_, string calldata refCode, bool enter) external returns (uint) {\n    return HeroControllerLib.createWithRefCode(_isNotSmartContract(), IController(controller()), _msgSender(), hero, heroName_, refCode, enter);\n  }\n\n  function setBiome(address hero, uint heroId, uint8 biome) external {\n    HeroControllerLib.setBiome(_isNotSmartContract(), IController(controller()), _msgSender(), hero, heroId, biome);\n  }\n\n  function levelUp(address hero, uint heroId, IStatController.CoreAttributes memory change) external {\n    HeroControllerLib.levelUp(_isNotSmartContract(), IController(controller()), _msgSender(), hero, heroId, change);\n  }\n\n  function askReinforcement(address hero, uint heroId) external virtual {\n    HeroControllerLib.askReinforcement(_isNotSmartContract(), IController(controller()), _msgSender(), hero, heroId);\n  }\n  //endregion ------------------------ USER ACTIONS\n\n  //region ------------------------ DUNGEON ACTIONS\n\n  function kill(address hero, uint heroId) external override returns (bytes32[] memory dropItems) {\n    return HeroControllerLib.kill(IController(controller()), _msgSender(), hero, heroId);\n  }\n\n  function releaseReinforcement(address hero, uint heroId) external override returns (address helperToken, uint helperId) {\n    return HeroControllerLib.releaseReinforcement(IController(controller()), _msgSender(), hero, heroId);\n  }\n  //endregion ------------------------ DUNGEON ACTIONS\n}\n"
    },
    "contracts/core/HeroTokensVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IHeroTokensVault.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../lib/HeroTokensVaultLib.sol\";\n\ncontract HeroTokensVault is IHeroTokensVault {\n\n  //region ------------------------ Constants\n\n  /// @notice Version of the contract\n  string public constant VERSION = \"1.0.2\";\n  //endregion ------------------------ Constants\n\n  //region ------------------------ Variables\n\n  IController public immutable controller;\n  //endregion ------------------------ Variables\n\n  //region ------------------------ Constructor\n  constructor(address controller_) {\n    controller = IController(controller_);\n  }\n  //endregion ------------------------ Constructor\n\n  //region ------------------------ Main logic\n  function percentToBurn(uint totalSupply) public pure returns (uint) {\n    return HeroTokensVaultLib.percentToBurn(totalSupply);\n  }\n\n  function process(address token, uint amount, address from) external override {\n    HeroTokensVaultLib.process(controller, token, amount, from);\n  }\n  //endregion ------------------------ Main logic\n\n}\n"
    },
    "contracts/core/ItemController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../proxy/Controllable.sol\";\nimport \"../relay/ERC2771Context.sol\";\nimport \"../interfaces/IItemController.sol\";\nimport \"./../lib/ItemStatsLib.sol\";\nimport \"./../lib/ScoreLib.sol\";\nimport \"./../lib/StatLib.sol\";\n\ncontract ItemController is Controllable, ERC2771Context, IItemController {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using PackingLib for address;\n\n  //region ------------------------ CONSTANTS\n\n  /// @notice Version of the contract\n  string public constant VERSION = \"1.0.2\";\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ INITIALIZER\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ------------------------ INITIALIZER\n\n  //region ------------------------ VIEWS\n  function itemByIndex(uint idx) external view returns (address) {\n    return ItemStatsLib.itemByIndex(idx);\n  }\n\n  function itemsLength() external view returns (uint) {\n    return ItemStatsLib.itemsLength();\n  }\n\n  function itemMeta(address item) external view override returns (ItemMeta memory meta) {\n    return ItemStatsLib.itemMeta(item);\n  }\n\n  function augmentInfo(address item) external view override returns (address token, uint amount) {\n    return ItemStatsLib.augmentInfo(item);\n  }\n\n  function genAttributeInfo(address item) external view override returns (ItemGenerateInfo memory info) {\n    return ItemStatsLib.genAttributeInfo(item);\n  }\n\n  function genCasterAttributeInfo(address item) external view override returns (ItemGenerateInfo memory info) {\n    return ItemStatsLib.genCasterAttributeInfo(item);\n  }\n\n  function genTargetAttributeInfo(address item) external view override returns (ItemGenerateInfo memory info) {\n    return ItemStatsLib.genTargetAttributeInfo(item);\n  }\n\n  function genAttackInfo(address item) external view override returns (AttackInfo memory info) {\n    return ItemStatsLib.genAttackInfo(item);\n  }\n\n  function itemInfo(address item, uint itemId) external view override returns (ItemInfo memory info) {\n    return ItemStatsLib.itemInfo(item, itemId);\n  }\n\n  function equippedOn(address item, uint itemId) external view override returns (address hero, uint heroId) {\n    return ItemStatsLib.equippedOn(item, itemId);\n  }\n\n  function itemAttributes(address item, uint itemId) external view override returns (int32[] memory values, uint8[] memory ids) {\n    return ItemStatsLib.itemAttributes(item, itemId);\n  }\n\n  function consumableAttributes(address item) external view override returns (int32[] memory values, uint8[] memory ids) {\n    return ItemStatsLib.consumableAttributes(item);\n  }\n\n  function consumableStats(address item) external view override returns (IStatController.ChangeableStats memory stats) {\n    return ItemStatsLib.consumableStats(item);\n  }\n\n  function casterAttributes(address item, uint itemId) external view override returns (int32[] memory values, uint8[] memory ids) {\n    return ItemStatsLib.casterAttributes(item, itemId);\n  }\n\n  function targetAttributes(address item, uint itemId) external view override returns (int32[] memory values, uint8[] memory ids) {\n    return ItemStatsLib.targetAttributes(item, itemId);\n  }\n\n  function itemAttackInfo(address item, uint itemId) external view override returns (AttackInfo memory info) {\n    return ItemStatsLib.itemAttackInfo(item, itemId);\n  }\n\n  function score(address item, uint itemId) external view override returns (uint) {\n    return ItemStatsLib.score(item, itemId);\n  }\n\n  function isAllowedToTransfer(address item, uint itemId) external view override returns (bool) {\n    return ItemStatsLib.isAllowedToTransfer(item, itemId);\n  }\n\n  function consumableActionMask(address item) external view returns (uint) {\n    return ItemStatsLib.consumableActionMask(item);\n  }\n\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ GOV ACTIONS\n\n  /// @dev It's possible to reduce size of the contract on 1kb by replacing calldata=>memory (+2k gas)\n  function registerItem(address item, RegisterItemParams calldata info) external {\n    ItemStatsLib.registerItem(IController(controller()), _msgSender(), item, info);\n  }\n\n  function removeItem(address item) external {\n    ItemStatsLib.removeItem(IController(controller()), _msgSender(), item);\n  }\n  //endregion ------------------------ GOV ACTIONS\n\n  //region ------------------------ DUNGEON ACTIONS\n\n  function mint(address item, address recipient) external override returns (uint itemId) {\n    return ItemStatsLib.mintNewItem(IController(controller()), msg.sender, item, recipient);\n  }\n\n  function reduceDurability(address hero, uint heroId, uint8 biome) external override {\n    return ItemStatsLib.reduceEquippedItemsDurability(IController(controller()), _msgSender(), hero, heroId, biome);\n  }\n\n  /// @dev Some stories can destroy items\n  function destroy(address item, uint itemId) external override {\n    ItemStatsLib.destroy(IController(controller()), _msgSender(), item, itemId);\n  }\n\n  /// @dev Some stories can manipulate items\n  function takeOffDirectly(\n    address item,\n    uint itemId,\n    address hero,\n    uint heroId,\n    uint8 itemSlot,\n    address destination,\n    bool broken\n  ) external override {\n    ItemStatsLib.takeOffDirectly(\n      IController(controller()),\n      item,\n      itemId,\n      hero,\n      heroId,\n      itemSlot,\n      destination,\n      broken\n    );\n  }\n  //endregion ------------------------ DUNGEON ACTIONS\n\n  //region ------------------------ EOA ACTIONS\n  // an item must not be equipped\n\n  function equip(\n    address heroToken,\n    uint heroTokenId,\n    address[] calldata items,\n    uint[] calldata tokenIds,\n    uint8[] calldata itemSlots\n  ) external {\n    ItemStatsLib.equipMany(\n      _isNotSmartContract(),\n      IController(controller()),\n      _msgSender(),\n      heroToken,\n      heroTokenId,\n      items,\n      tokenIds,\n      itemSlots\n    );\n  }\n\n  function takeOff(\n    address heroToken,\n    uint heroTokenId,\n    address[] calldata items,\n    uint[] calldata tokenIds,\n    uint8[] calldata itemSlots\n  ) external {\n    ItemStatsLib.takeOffMany(\n      _isNotSmartContract(),\n      IController(controller()),\n      _msgSender(),\n      heroToken,\n      heroTokenId,\n      items,\n      tokenIds,\n      itemSlots\n    );\n  }\n\n  /// @dev Repair durability.\n  function repairDurability(address item, uint itemId, uint consumedItemId) external {\n    ItemStatsLib.repairDurability(\n      _isNotSmartContract(),\n      IController(controller()),\n      _msgSender(),\n      item,\n      itemId,\n      consumedItemId\n    );\n  }\n\n  function augment(address item, uint itemId, uint consumedItemId) external {\n    ItemStatsLib.augment(\n      _isNotSmartContract(),\n      IController(controller()),\n      _msgSender(),\n      item,\n      itemId,\n      consumedItemId\n    );\n  }\n\n  function use(address item, uint tokenId, address heroToken, uint heroTokenId) external {\n    ItemStatsLib.use(\n      _isNotSmartContract(),\n      IController(controller()),\n      _msgSender(),\n      item,\n      tokenId,\n      heroToken,\n      heroTokenId\n    );\n  }\n  //endregion ------------------------ EOA ACTIONS\n\n  //region ------------------------ SIP-003: Item fragility\n  /// @notice SIP-003: item fragility counter that displays the chance of an unsuccessful repair.\n  /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\n  function itemFragility(address item, uint itemId) external view returns (uint) {\n    return ItemStatsLib.itemFragility(item, itemId);\n  }\n\n  /// @notice SIP-003: The quest mechanic that previously burned the item will increase its fragility by 1%\n  function incBrokenItemFragility(address item, uint itemId) external {\n    ItemStatsLib.incBrokenItemFragility(IController(controller()), item, itemId);\n  }\n\n  //endregion ------------------------ SIP-003: Item fragility\n}\n"
    },
    "contracts/core/Oracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\nimport \"../proxy/Controllable.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IAppErrors.sol\";\n\ncontract Oracle is Controllable, IOracle {\n\n  //region ------------------------ Constants\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant override VERSION = \"1.0.1\";\n  //endregion ------------------------ Constants\n\n  // ---- VARIABLES ----\n\n  //region ------------------------ Initializer\n\n  function init(\n    address controller_\n  ) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ------------------------ Initializer\n\n  // ---- RESTRICTIONS ----\n\n  //region ------------------------ Actions\n\n  function getRandomNumber(uint max, uint seed) external override returns (uint) {\n    return _getRandomNumber(max, seed);\n  }\n\n  function _getRandomNumber(uint maxValue, uint seed) internal returns (uint) {\n    if (maxValue == 0) revert IAppErrors.OracleWrongInput();\n\n    uint salt;\n\n// Following code is commented because currently SkaleNetworks is not used\n//    // skale has a RNG Endpoint\n//    if (isSkaleNetwork()) {\n//      assembly {\n//        let freemem := mload(0x40)\n//        let start_addr := add(freemem, 0)\n//        if iszero(staticcall(gas(), 0x18, 0, 0, start_addr, 32)) {\n//          invalid()\n//        }\n//        salt := mload(freemem)\n//      }\n//    }\n\n    // pseudo random number\n    bytes32 hash = keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, msg.sender, tx.gasprice, gasleft(), uint(salt), seed));\n    uint r = (uint(hash) % (maxValue + 1));\n    emit IApplicationEvents.Random(r, maxValue);\n    return r;\n  }\n\n  function getRandomNumberInRange(uint min, uint max, uint seed) external override returns (uint) {\n    if (min >= max) {\n      return max;\n    }\n    uint r = _getRandomNumber(max - min, seed);\n    return min + r;\n  }\n\n// Following code is commented because currently SkaleNetworks is not used\n//  function isSkaleNetwork() public view returns (bool) {\n//    return block.chainid == uint(1351057110);\n//  }\n  //endregion ------------------------ Actions\n\n}\n"
    },
    "contracts/core/ReinforcementController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\nimport \"../proxy/Controllable.sol\";\nimport \"../relay/ERC2771Context.sol\";\nimport \"../interfaces/IReinforcementController.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IDungeonFactory.sol\";\nimport \"../openzeppelin/ERC721Holder.sol\";\nimport \"../lib/PackingLib.sol\";\nimport \"../lib/ReinforcementControllerLib.sol\";\n\ncontract ReinforcementController is Controllable, IReinforcementController, ERC721Holder, ERC2771Context {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n  using PackingLib for bytes32;\n  using PackingLib for address;\n  using PackingLib for uint8[];\n\n  //region ------------------------ CONSTANTS\n\n  /// @notice Version of the contract\n  string public constant override VERSION = \"2.0.3\";\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ INITIALIZER\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ------------------------ INITIALIZER\n\n  //region ------------------------ VIEWS\n  function minLevel() external view returns (uint8 _minLevel) {\n    return ReinforcementControllerLib.minLevel();\n  }\n\n  function minLifeChances() external view returns (uint8 _minLifeChances) {\n    return ReinforcementControllerLib.minLifeChances();\n  }\n\n  function toHelperRatio(address heroToken, uint heroId) external override view returns (uint) {\n    return ReinforcementControllerLib.toHelperRatio(heroToken, heroId);\n  }\n\n  function heroInfo(address heroToken, uint heroId) external view returns (HeroInfo memory) {\n    return ReinforcementControllerLib.heroInfo(heroToken, heroId);\n  }\n\n  function isStaked(address heroToken, uint heroId) external view override returns (bool) {\n    return ReinforcementControllerLib.isStaked(heroToken, heroId);\n  }\n\n  function maxScore(uint biome) external view returns (uint) {\n    return ReinforcementControllerLib.maxScore(biome);\n  }\n\n  function earned(address heroToken, uint heroId) external view returns (\n    address[] memory tokens,\n    uint[] memory amounts,\n    address[] memory nfts,\n    uint[] memory ids\n  ) {\n    return ReinforcementControllerLib.earned(heroToken, heroId);\n  }\n\n  function heroScoreAdjusted(address heroToken, uint heroId) external view returns (uint) {\n    return ReinforcementControllerLib.heroScoreAdjusted(heroToken, heroId);\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ GOV ACTIONS\n\n  function setMinLevel(uint8 value) external {\n    ReinforcementControllerLib.setMinLevel(isGovernance(msg.sender), value);\n  }\n\n  function setMinLifeChances(uint8 value) external {\n    ReinforcementControllerLib.setMinLifeChances(isGovernance(msg.sender), value);\n  }\n\n  //endregion ------------------------ GOV ACTIONS\n\n  //region ------------------------ USER ACTIONS\n\n  function stakeHero(address heroToken, uint heroId, uint8 fee) external {\n    ReinforcementControllerLib.stakeHero(_isNotSmartContract(), IController(controller()), _msgSender(), heroToken, heroId, fee);\n  }\n\n  function withdrawHero(address heroToken, uint heroId) external {\n    ReinforcementControllerLib.withdrawHero(_isNotSmartContract(), IController(controller()), _msgSender(), heroToken, heroId);\n  }\n\n  /// @dev It's view like function but we need to touch slots in oracle function.\n  function askHero(uint biome) external override returns (address heroToken, uint heroId, int32[] memory attributes) {\n    return ReinforcementControllerLib.askHero(IController(controller()), biome);\n  }\n\n  /// @dev Only for dungeon. Assume the tokens already sent to this contract.\n  function registerTokenReward(address heroToken, uint heroId, address token, uint amount) external override {\n    ReinforcementControllerLib.registerTokenReward(IController(controller()), heroToken, heroId, token, amount);\n  }\n\n  /// @dev Only for dungeon. Assume the NFT already sent to this contract.\n  function registerNftReward(address heroToken, uint heroId, address token, uint tokenId) external override {\n    ReinforcementControllerLib.registerNftReward(IController(controller()), heroToken, heroId, token, tokenId);\n  }\n\n  function claimAll(address heroToken, uint heroId) external {\n    ReinforcementControllerLib.claimAll(_isNotSmartContract(), IController(controller()), _msgSender(), heroToken, heroId);\n  }\n\n  /// @notice Claim {countNft} last NFT\n  function claimNft(address heroToken, uint heroId, uint countNft) external {\n    ReinforcementControllerLib.claimNft(_isNotSmartContract(), IController(controller()), _msgSender(), heroToken, heroId, countNft);\n  }\n  //endregion ------------------------ USER ACTIONS\n}\n"
    },
    "contracts/core/StatController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\nimport \"../proxy/Controllable.sol\";\nimport \"../lib/StatControllerLib.sol\";\n\ncontract StatController is Controllable, IStatController {\n\n  //region ------------------------ CONSTANTS\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant override VERSION = \"2.1.2\";\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ INITIALIZER\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ------------------------ INITIALIZER\n\n  //region ------------------------ VIEWS\n\n  function heroInitialAttributes(uint heroClass) external pure returns (StatLib.InitialHero memory) {\n    return StatLib.initialHero(heroClass);\n  }\n\n  function heroAttributes(address token, uint tokenId) public view override returns (int32[] memory) {\n    return StatControllerLib.heroAttributes(StatControllerLib._S(), token, tokenId);\n  }\n\n  function heroBonusAttributes(address token, uint tokenId) public view returns (int32[] memory) {\n    return StatControllerLib.heroBonusAttributes(StatControllerLib._S(), token, tokenId);\n  }\n\n  function heroTemporallyAttributes(address token, uint tokenId) public view returns (int32[] memory) {\n    return StatControllerLib.heroTemporallyAttributes(StatControllerLib._S(), token, tokenId);\n  }\n\n  function heroAttributesLength(address token, uint tokenId) external pure override returns (uint) {\n    return StatControllerLib.heroAttributesLength(token, tokenId);\n  }\n\n  function heroAttribute(address token, uint tokenId, uint index) external view override returns (int32) {\n    return StatControllerLib.heroAttribute(StatControllerLib._S(), token, tokenId, index);\n  }\n\n  function heroBaseAttributes(address token, uint tokenId) public view override returns (CoreAttributes memory core) {\n    return StatControllerLib.heroBaseAttributes(StatControllerLib._S(), token, tokenId);\n  }\n\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view override returns (uint) {\n    return StatControllerLib.heroCustomData(StatControllerLib._S(), token, tokenId, index);\n  }\n\n  function globalCustomData(bytes32 index) external view override returns (uint) {\n    return StatControllerLib.globalCustomData(StatControllerLib._S(), index);\n  }\n\n  function heroStats(address token, uint tokenId) public view override returns (ChangeableStats memory result) {\n    return StatControllerLib.heroStats(StatControllerLib._S(), token, tokenId);\n  }\n\n  function heroItemSlot(address heroToken, uint64 heroTokenId, uint8 itemSlot) public view override returns (bytes32 nftPacked) {\n    return StatControllerLib.heroItemSlot(StatControllerLib._S(), heroToken, heroTokenId, itemSlot);\n  }\n\n  function heroItemSlots(address heroToken, uint heroTokenId) external view override returns (uint8[] memory) {\n    return StatControllerLib.heroItemSlots(StatControllerLib._S(), heroToken, heroTokenId);\n  }\n\n  function isHeroAlive(address heroToken, uint heroTokenId) external view override returns (bool) {\n    return StatControllerLib.isHeroAlive(StatControllerLib._S(), heroToken, heroTokenId);\n  }\n\n  function isConsumableUsed(address heroToken, uint heroTokenId, address item) external view returns (bool) {\n    return StatControllerLib.isConsumableUsed(StatControllerLib._S(), heroToken, heroTokenId, item);\n  }\n\n  function buffHero(BuffInfo memory info) external view override returns (int32[] memory, int32) {\n    return StatControllerLib.buffHero(StatControllerLib._S(), IController(controller()), info);\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ PURE\n\n  function levelUpExperienceRequired(uint32 level) external pure returns (uint) {\n    return StatControllerLib.levelUpExperienceRequired(level);\n  }\n\n  function levelExperience(uint32 level) external pure returns (uint) {\n    return StatLib.levelExperience(level);\n  }\n  //endregion ------------------------ PURE\n\n  //region ------------------------ ACTIONS\n\n  function initNewHero(address heroToken, uint heroTokenId, uint heroClass) external override {\n    return StatControllerLib.initNewHero(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId, heroClass);\n  }\n\n  function changeHeroItemSlot(\n    address heroToken,\n    uint64 heroTokenId,\n    uint itemType,\n    uint8 itemSlot,\n    address itemToken,\n    uint itemTokenId,\n    bool equip\n  ) external override {\n    return StatControllerLib.changeHeroItemSlot(\n      StatControllerLib._S(),\n      IController(controller()),\n      heroToken,\n      heroTokenId,\n      itemType,\n      itemSlot,\n      itemToken,\n      itemTokenId,\n      equip\n    );\n  }\n\n  function changeCurrentStats(address heroToken, uint heroTokenId, ChangeableStats memory change, bool increase) external override {\n    return StatControllerLib.changeCurrentStats(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId, change, increase);\n  }\n\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external override {\n    return StatControllerLib.registerConsumableUsage(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId, item);\n  }\n\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external override {\n    return StatControllerLib.clearUsedConsumables(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId);\n  }\n\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external override {\n    return StatControllerLib.changeBonusAttributes(StatControllerLib._S(), IController(controller()), info);\n  }\n\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external override {\n    return StatControllerLib.clearTemporallyAttributes(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId);\n  }\n\n  function levelUp(address heroToken, uint heroTokenId, uint heroClass, CoreAttributes memory change)\n  external override returns (uint newLvl) {\n    return StatControllerLib.levelUp(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId, heroClass, change);\n  }\n\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external override {\n    return StatControllerLib.setHeroCustomData(StatControllerLib._S(), IController(controller()), token, tokenId, index, value);\n  }\n\n  function setGlobalCustomData(bytes32 index, uint value) external override {\n    return StatControllerLib.setGlobalCustomData(StatControllerLib._S(), IController(controller()), index, value);\n  }\n\n  /// @notice Restore life and mana during reinforcement\n  /// @param prevAttributes Hero attributes before reinforcement\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external override {\n    return StatControllerLib.restoreLifeAndMana(StatControllerLib._S(), IController(controller()), heroToken, heroTokenId, prevAttributes);\n  }\n  //endregion ------------------------ ACTIONS\n\n}\n"
    },
    "contracts/core/StoryController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\nimport \"../proxy/Controllable.sol\";\nimport \"../interfaces/IStoryController.sol\";\nimport \"../interfaces/IGOC.sol\";\nimport \"../lib/StoryControllerLib.sol\";\nimport \"../openzeppelin/ERC721Holder.sol\";\n\ncontract StoryController is Controllable, IStoryController, ERC721Holder {\n  //region ------------------------ CONSTANTS\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant override VERSION = \"2.1.1\";\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ INITIALIZER\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ------------------------ INITIALIZER\n\n  //region ------------------------ VIEWS\n  function idToStory(uint16 storyId) external view returns (uint32) {\n    return StoryControllerLib.idToStory(storyId);\n  }\n\n  function storyBuildHash(uint16 storyId) external view returns (uint) {\n    return StoryControllerLib.storyBuildHash(storyId);\n  }\n\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view override returns (uint16 pageId) {\n    return StoryControllerLib.heroPage(hero, heroId, storyId);\n  }\n\n  function storyIds(uint32 objectId) external view override returns (uint16) {\n    return StoryControllerLib.storyIds(objectId);\n  }\n\n  function registeredStories(uint32 objectId) external view override returns (bool) {\n    return StoryControllerLib.registeredStories(objectId);\n  }\n\n  function allStoryPagesLength(uint16 storyId) external view returns (uint) {\n    return StoryControllerLib.allStoryPagesLength(storyId);\n  }\n\n  function allStoryPages(uint16 storyId, uint index) external view returns (uint) {\n    return StoryControllerLib.allStoryPages(storyId, index);\n  }\n\n  function allStoryAnswersLength(uint16 storyId) external view returns (uint) {\n    return StoryControllerLib.allStoryAnswersLength(storyId);\n  }\n\n  function allStoryAnswers(uint16 storyId, uint index) external view returns (bytes32) {\n    return StoryControllerLib.allStoryAnswers(storyId, index);\n  }\n\n  function currentHeroAnswers(uint16 storyId, address hero, uint80 heroId) public view returns (bytes32[] memory) {\n    return StoryControllerLib.currentHeroAnswers(IController(controller()), storyId, hero, heroId);\n  }\n\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view override returns (bool) {\n    return StoryControllerLib.isStoryAvailableForHero(IController(controller()), objectId, heroToken, heroTokenId);\n  }\n\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ SETTERS\n\n  function setAllStoryFields(StoryMetaInfo calldata meta) external {\n    StoryControllerLib.setAllStoryFields(IController(controller()), meta);\n  }\n\n  function setBurnItemsMeta(uint16 storyId, AnswerBurnRandomItemMeta calldata meta) external {\n    StoryControllerLib.setBurnItemsMeta(IController(controller()), storyId, meta);\n  }\n\n  function setNextObjRewriteMeta(uint16 storyId, NextObjRewriteMeta calldata meta) external {\n    StoryControllerLib.setNextObjRewriteMeta(IController(controller()), storyId, meta);\n  }\n\n  function setAnswersMeta(\n    uint16 storyId,\n    uint16[] calldata answerPageIds,\n    uint8[] calldata answerHeroClasses,\n    uint16[] calldata answerIds\n  ) external {\n    StoryControllerLib.setAnswersMeta(IController(controller()), storyId, answerPageIds, answerHeroClasses, answerIds);\n  }\n\n  function setAnswerNextPageMeta(uint16 storyId, AnswerNextPageMeta calldata meta) external {\n    StoryControllerLib.setAnswerNextPageMeta(IController(controller()), storyId, meta);\n  }\n\n  function setAnswerAttributeRequirements(uint16 storyId, AnswerAttributeRequirementsMeta calldata meta) external {\n    StoryControllerLib.setAnswerAttributeRequirements(IController(controller()), storyId, meta);\n  }\n\n  function setAnswerItemRequirements(uint16 storyId, AnswerItemRequirementsMeta calldata meta) external {\n    StoryControllerLib.setAnswerItemRequirements(IController(controller()), storyId, meta);\n  }\n\n  function setAnswerTokenRequirementsMeta(uint16 storyId, AnswerTokenRequirementsMeta calldata meta) external {\n    StoryControllerLib.setAnswerTokenRequirementsMeta(IController(controller()), storyId, meta);\n  }\n\n  function setAnswerAttributes(uint16 storyId, AnswerAttributesMeta calldata meta) external {\n    StoryControllerLib.setAnswerAttributes(IController(controller()), storyId, meta);\n  }\n\n  function setAnswerHeroCustomDataRequirementMeta(uint16 storyId, AnswerCustomDataMeta calldata meta) external {\n    StoryControllerLib.setAnswerHeroCustomDataRequirementMeta(IController(controller()), storyId, meta);\n  }\n\n  function setAnswerGlobalCustomDataRequirementMeta(uint16 storyId, AnswerCustomDataMeta calldata meta) external {\n    StoryControllerLib.setAnswerGlobalCustomDataRequirementMeta(IController(controller()), storyId, meta);\n  }\n\n  function setSuccessInfo(uint16 storyId, AnswerResultMeta calldata meta) external {\n    StoryControllerLib.setSuccessInfo(IController(controller()), storyId, meta);\n  }\n\n  function setFailInfo(uint16 storyId, AnswerResultMeta calldata meta) external {\n    StoryControllerLib.setFailInfo(IController(controller()), storyId, meta);\n  }\n\n  function setCustomDataResult(uint16 storyId, AnswerCustomDataResultMeta calldata meta, CustomDataResult type_) external {\n    StoryControllerLib.setCustomDataResult(IController(controller()), storyId, meta, type_);\n  }\n\n  function setStoryCustomDataRequirements(\n    uint16 storyId,\n    bytes32[] calldata requiredCustomDataIndex,\n    uint64[] calldata requiredCustomDataMinValue,\n    uint64[] calldata requiredCustomDataMaxValue,\n    bool[] calldata requiredCustomDataIsHero,\n    uint minLevel\n  ) external {\n    StoryControllerLib.setStoryCustomDataRequirements(\n      IController(controller()),\n      storyId,\n      requiredCustomDataIndex,\n      requiredCustomDataMinValue,\n      requiredCustomDataMaxValue,\n      requiredCustomDataIsHero,\n      minLevel\n    );\n  }\n\n  function finalizeStoryRegistration(uint16 storyId, uint32 objectId, uint buildHash) external {\n    StoryControllerLib.finalizeStoryRegistration(IController(controller()), storyId, objectId, buildHash);\n  }\n  //endregion ------------------------ SETTERS\n\n  //region ------------------------ CHANGE META\n\n  function removeStory(uint32 objectId) external {\n    StoryControllerLib.removeStory(IController(controller()), objectId);\n  }\n\n  function removeStoryPagesMeta(uint16 storyId, uint maxIterations) external {\n    StoryControllerLib.removeStoryPagesMeta(IController(controller()), storyId, maxIterations);\n  }\n\n  function removeStoryAnswersMeta(uint16 storyId, uint maxIterations) external {\n    StoryControllerLib.removeStoryAnswersMeta(IController(controller()), storyId, maxIterations);\n  }\n  //endregion ------------------------ CHANGE META\n\n  //region ------------------------ MAIN LOGIC\n\n  function storyAction(\n    address sender,\n    uint64 dungeonId,\n    uint32 objectId,\n    uint stageId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 biome,\n    uint iteration,\n    bytes memory data\n  ) external override returns (IGOC.ActionResult memory result) {\n    return StoryControllerLib.storyAction(\n      IController(controller()),\n      sender,\n      dungeonId,\n      objectId,\n      stageId,\n      heroToken,\n      heroTokenId,\n      biome,\n      iteration,\n      data\n    );\n  }\n  //endregion ------------------------ MAIN LOGIC\n\n}\n"
    },
    "contracts/core/Treasury.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\nimport \"../proxy/Controllable.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../lib/TreasuryLib.sol\";\n\ncontract Treasury is Initializable, Controllable, ITreasury {\n\n  //region ------------------------ CONSTANTS\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant override VERSION = \"1.0.3\";\n  uint public constant AUGMENT_GOV_FEE = TreasuryLib.AUGMENT_GOV_FEE;\n  uint public constant REPAIR_GOV_FEE = TreasuryLib.REPAIR_GOV_FEE;\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ INITIALIZER\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ------------------------ INITIALIZER\n\n  //region ------------------------ VIEWS\n\n  function balanceOfToken(address token) external view override returns (uint) {\n    return TreasuryLib.balanceOfToken(token);\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ ACTIONS\n\n  function sendToDungeon(address dungeon, address token, uint amount) external override {\n    TreasuryLib.sendToDungeon(IController(controller()), dungeon, token, amount);\n  }\n\n  /// @dev Assume approve. Move fee to treasury and governance from msg.sender.\n  ///      Anyone can call\n  function sendFee(address token, uint amount, IItemController.FeeType feeType) external override {\n    TreasuryLib.sendFee(IController(controller()), token, amount, feeType);\n  }\n  //endregion ------------------------ ACTIONS\n\n}\n"
    },
    "contracts/core/UserController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IUserController.sol\";\nimport \"../lib/UserControllerLib.sol\";\nimport \"../proxy/Controllable.sol\";\nimport \"../relay/ERC2771Context.sol\";\n\ncontract UserController is Initializable, Controllable, ERC2771Context, IUserController {\n  //region ------------------------ CONSTANTS\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant override VERSION = \"1.0.0\";\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ INITIALIZER\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n\n    UserControllerLib._S().feeRenaming = UserControllerLib.FEE_RENAMING_DEFAULT_VALUE;\n  }\n  //endregion ------------------------ INITIALIZER\n\n  //region ------------------------ View\n  function userAccountName(address userAccount) external view returns (string memory) {\n    return UserControllerLib.getUserAccountName(userAccount);\n  }\n\n  function nameToUserAccount(string memory name) external view returns (address) {\n    return UserControllerLib.nameToUserAccount(name);\n  }\n\n  function userActivity(address user) external view returns (IUserController.UserActivity memory) {\n    return UserControllerLib.getUserActivity(user);\n  }\n\n  function counterLootBoxes(address user) external view returns (uint32 dailyCounter, uint32 weeklyCounter) {\n    return UserControllerLib.getCounterLootBoxes(user);\n  }\n\n  function lootBoxConfig(uint lootBoxKind) external view returns (\n    address[] memory mintItems,\n    uint32[] memory mintItemsChances,\n    uint maxDropItems\n  ) {\n    return UserControllerLib.getLootBoxConfig(lootBoxKind);\n  }\n\n  function feeRenaming() external view returns (uint) {\n    return UserControllerLib.getFeeRenaming();\n  }\n  //endregion ------------------------ View\n\n  //region ------------------------ ACTIONS\n  function setUserName(string memory name) external {\n    UserControllerLib.setUserName(_isNotSmartContract(), IController(controller()), _msgSender(), name);\n  }\n\n  function openLootBox(uint lootBoxKind) external {\n    UserControllerLib.openLootBox(\n      IController(controller()),\n      _msgSender(),\n      IUserController.LootBoxKind(lootBoxKind),\n      CalcLib.nextPrng,\n      ItemLib._mintRandomItems\n    );\n  }\n\n  function setLootBoxConfig(uint lootBoxKind, IUserController.LootBoxConfig memory config) external {\n    UserControllerLib.setLootBoxConfig(IController(controller()), _msgSender(), lootBoxKind, config);\n  }\n\n  function setFeeRenaming(uint amount) external {\n    UserControllerLib.setFeeRenaming(IController(controller()), _msgSender(), amount);\n  }\n  //endregion ------------------------ ACTIONS\n\n  //region ------------------------ IUserController\n  function registerPassedDungeon(address user) external {\n    UserControllerLib.registerPassedDungeon(\n      IController(controller()),\n      _msgSender(),\n      user,\n      block.timestamp,\n      UserControllerLib.DAILY_ACTIVITY_DUNGEONS_THRESHOLD,\n      UserControllerLib.WEEKLY_ACTIVITY_THRESHOLD\n    );\n  }\n\n  function registerPvP(address user, bool isWinner) external {\n    UserControllerLib.registerPvP(IController(controller()), _msgSender(), user, isWinner);\n  }\n  //endregion ------------------------ IUserController\n}"
    },
    "contracts/interfaces/IAppErrors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\n/// @notice All errors of the app\ninterface IAppErrors {\n  error ZeroAddress();\n  error ZeroValueNotAllowed();\n  error LengthsMismatch();\n  error NotEnoughBalance();\n  error EmptyNameNotAllowed();\n  error NotInitialized();\n  error AlreadyInitialized();\n\n  //region Restrictions\n  error ErrorNotDeployer(address sender);\n  error ErrorNotGoc();\n  error NotGovernance(address sender);\n  error ErrorOnlyEoa();\n  error NotEOA(address sender);\n  error ErrorForbidden(address sender);\n  error ErrorNotItemController(address sender);\n  error ErrorNotHeroController(address sender);\n  error ErrorNotDungeonFactory(address sender);\n  error ErrorNotObjectController(address sender);\n  error ErrorNotStoryController();\n  error ErrorNotAllowedSender();\n  error MintNotAllowed();\n  //endregion Restrictions\n\n  //region Hero\n  error ErrorHeroIsNotRegistered(address heroToken);\n  error ErrorHeroIsDead(address heroToken, uint heroTokenId);\n  error ErrorHeroNotInDungeon();\n  error HeroInDungeon();\n  error ErrorNotHeroOwner(address heroToken, address msgSender);\n  error Staked(address heroToken, uint heroId);\n  error HeroTokensVaultAlreadySet();\n  error NameTaken();\n  error TooBigName();\n  error WrongSymbolsInTheName();\n  error NoPayToken(address token, uint payTokenAmount);\n  error AlreadyHaveReinforcement();\n  /// @notice SIP-001 - Reinforcement requires 3 skills\n  error ErrorReinforcementRequiresThreeSkills();\n  //endregion Hero\n\n  //region Dungeon\n  error ErrorDungeonIsFreeAlready();\n  error ErrorNoEligibleDungeons();\n  error ErrorDungeonBusy();\n  error ErrorNoDungeonsForBiome(uint8 heroBiome);\n  error ErrorDungeonCompleted();\n  error ErrorAlreadyInDungeon();\n  error NotEnoughTokens(uint balance, uint expectedBalance);\n  error DungeonAlreadySpecific(uint16 dungNum);\n  error DungeonAlreadySpecific2(uint16 dungNum);\n  error WrongSpecificDungeon();\n  //endregion Dungeon\n\n  //region Items\n  error ErrorItemNotEligibleForTheSlot(uint itemType, uint8 itemSlot);\n  error ErrorItemSlotBusyHand(uint8 slot);\n  error ErrorItemSlotBusy();\n  error ErrorItemNotInSlot();\n  error ErrorConsumableItemIsUsed(address item);\n  error ErrorCannotRemoveItemFromMap();\n  error ItemEquipped();\n  error ZeroItemMetaType();\n  error ZeroLevel();\n  error ItemTypeChanged();\n  error ItemMetaTypeChanged();\n  error UnknownItem(address item);\n  error ItemIsAlreadyEquipped(address item);\n  error ErrorEquipForbidden();\n  error EquipForbiddenInDungeon();\n  error TakeOffForbiddenInDungeon();\n  error Consumable(address item);\n  error NotConsumable(address item);\n  error Broken(address item);\n  error ZeroLife();\n  error RequirementsToItemAttributes();\n  error NotEquipped(address item);\n  error ZeroDurability();\n  error ZeroAugmentation();\n  error TooHighAgLevel(uint8 augmentationLevel);\n  error UseForbiddenZeroPayToken();\n  error IncorrectMinMaxAttributeRange(int32 min, int32 max);\n  error SameIdsNotAllowed();\n  //endregion Items\n\n  //region Stages\n  error ErrorWrongStage(uint stage);\n  error ErrorNotStages();\n  //endregion Stages\n\n  //region Level\n  error ErrorWrongLevel(uint heroLevel);\n  error ErrorLevelTooLow(uint heroLevel);\n  error ErrorHeroLevelStartFrom1();\n  error ErrorWrongLevelUpSum();\n  error ErrorMaxLevel();\n  //endregion Level\n\n  //region Treasure\n  error ErrorNotValidTreasureToken(address treasureToken);\n  //endregion Treasure\n\n  //region State\n  error ErrorPaused();\n  error ErrorNotReady();\n  error ErrorNotObject1();\n  error ErrorNotObject2();\n  error ErrorNotCompleted();\n  //endregion State\n\n  //region Biome\n  error ErrorNotBiome();\n  error ErrorIncorrectBiome(uint biome);\n  error TooHighBiome(uint biome);\n  //endregion Biome\n\n  //region Misc\n  error ErrorWrongMultiplier(uint multiplier);\n  error ErrorNotEnoughMana(uint32 mana, uint requiredMana);\n  error ErrorExperienceMustNotDecrease();\n  error ErrorNotEnoughExperience();\n  error ErrorNotChances();\n  error ErrorNotEligible(address heroToken, uint16 dungNum);\n  error ErrorZeroKarmaNotAllowed();\n  //endregion Misc\n\n  //region GOC\n  error GenObjectIdBiomeOverflow(uint8 biome);\n  error GenObjectIdSubTypeOverflow(uint subType);\n  error GenObjectIdIdOverflow(uint id);\n  error UnknownObjectTypeGoc1(uint8 objectType);\n  error UnknownObjectTypeGoc2(uint8 objectType);\n  error UnknownObjectTypeGocLib1(uint8 objectType);\n  error UnknownObjectTypeGocLib2(uint8 objectType);\n  error UnknownObjectTypeForSubtype(uint8 objectSubType);\n  error FightDelay();\n  error ZeroChance();\n  error TooHighChance(uint32 chance);\n  error TooHighRandom(uint random);\n  error EmptyObjects();\n  error ObjectNotFound();\n  error WrongGetObjectTypeInput();\n  error WrongChances(uint32 chances, uint32 maxChances);\n  //endregion GOC\n\n  //region Story\n  error PageNotRemovedError(uint pageId);\n  error NotItem1();\n  error NotItem2();\n  error NotRandom(uint32 random);\n  error NotHeroData();\n  error NotGlobalData();\n  error ZeroStoryIdRemoveStory();\n  error ZeroStoryIdStoryAction();\n  error ZeroStoryIdAction();\n  error NotEnoughAmount(uint balance, uint requiredAmount);\n  error NotAnswer();\n  error AnswerStoryIdMismatch(uint16 storyId, uint16 storyIdFromAnswerHash);\n  error AnswerPageIdMismatch(uint16 pageId, uint16 pageIdFromAnswerHash);\n  //endregion Story\n\n  //region FightLib\n  error NotMagic();\n  error NotAType(uint atype);\n  //endregion FightLib\n\n  //region MonsterLib\n  error NotYourDebuffItem();\n  error UnknownAttackType(uint attackType);\n  error NotYourAttackItem();\n  /// @notice The skill item cannot be used because it doesn't belong either to the hero or to the hero's helper\n  error NotYourBuffItem();\n  //endregion MonsterLib\n\n  //region GameToken\n  error ApproveToZeroAddress();\n  error MintToZeroAddress();\n  error TransferToZeroAddress();\n  error TransferAmountExceedsBalance(uint balance, uint value);\n  error InsufficientAllowance();\n  error BurnAmountExceedsBalance();\n  error NotMinter(address sender);\n  //endregion GameToken\n\n  //region NFT\n  error TokenTransferNotAllowed();\n  error IdOverflow(uint id);\n  error NotExistToken(uint tokenId);\n  error EquippedItemIsNotAllowedToTransfer(uint tokenId);\n  //endregion NFT\n\n  //region CalcLib\n  error TooLowX(uint x);\n  //endregion CalcLib\n\n  //region Controller\n  error NotFutureGovernance(address sender);\n  //endregion Controller\n\n  //region Oracle\n  error OracleWrongInput();\n  //region Oracle\n\n  //region ReinforcementController\n  error AlreadyStaked();\n  error MaxFee(uint8 fee);\n  error MinFee(uint8 fee);\n  error StakeHeroNotStats();\n  error NotStaked();\n  error NoStakedHeroes();\n  //region ReinforcementController\n\n  //region SponsoredHero\n  error InvalidHeroClass();\n  error ZeroAmount();\n  error InvalidProof();\n  error NoHeroesAvailable();\n  error AlreadyRegistered();\n  //endregion SponsoredHero\n\n  //region SacraRelay\n  error SacraRelayNotOwner();\n  error SacraRelayNotDelegator();\n  error SacraRelayNotOperator();\n  error SacraRelayInvalidChainId(uint callChainId, uint blockChainId);\n  error SacraRelayInvalidNonce(uint callNonce, uint txNonce);\n  error SacraRelayDeadline();\n  error SacraRelayDelegationExpired();\n  error SacraRelayNotAllowed();\n  error SacraRelayInvalidSignature();\n  /// @notice This error is generated when custom error is caught\n  /// There is no info about custom error in SacraRelay\n  /// but you can decode custom error by selector, see tests\n  error SacraRelayNoErrorSelector(bytes4 selector, string tracingInfo);\n  /// @notice This error is generated when custom error is caught\n  /// There is no info about custom error in SacraRelay\n  /// but you can decode custom error manually from {errorBytes} as following:\n  /// if (keccak256(abi.encodeWithSignature(\"MyError()\")) == keccak256(errorBytes)) { ... }\n  error SacraRelayUnexpectedReturnData(bytes errorBytes, string tracingInfo);\n  error SacraRelayCallToNotContract(address notContract, string tracingInfo);\n  //endregion SacraRelay\n\n  //region Misc\n  error UnknownHeroClass(uint heroClass);\n  error AbsDiff(int32 a, int32 b);\n  //region Misc\n\n  //region ------------------------ Guilds\n  error NoAvailableLootBox(address msgSender, uint lootBoxKind);\n  error AlreadyGuildMember();\n  error NotGuildMember();\n  error GuildActionForbidden(uint right);\n  error GuildHasMaxSize(uint guildSize);\n  error GuildHasMaxLevel(uint level);\n  error TooLongUrl();\n  error CannotRemoveGuildOwnerFromNotEmptyGuild();\n  //endregion ------------------------ Guilds\n}\n"
    },
    "contracts/interfaces/IApplicationEvents.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"./IGOC.sol\";\nimport \"./IStatController.sol\";\nimport \"./IDungeonFactory.sol\";\nimport \"./IStoryController.sol\";\nimport \"./IFightCalculator.sol\";\n\n/// @notice All events of the app\ninterface IApplicationEvents {\n\n  //region ------------------ StatController\n  event HeroItemSlotChanged(\n    address heroToken,\n    uint heroTokenId,\n    uint itemType,\n    uint itemSlot,\n    address itemToken,\n    uint itemTokenId,\n    bool equip,\n    address caller\n  );\n  event CurrentStatsChanged(\n    address heroToken,\n    uint heroTokenId,\n    IStatController.ChangeableStats change,\n    bool increase,\n    address caller\n  );\n  event BonusAttributesChanged(\n    address heroToken,\n    uint heroTokenId,\n    bool add,\n    bool temporally,\n    address caller\n  );\n  event TemporallyAttributesCleared(address heroToken, uint heroTokenId, address caller);\n  event NewHeroInited(address heroToken, uint heroTokenId, IStatController.ChangeableStats stats);\n  event LevelUp(\n    address heroToken,\n    uint heroTokenId,\n    uint heroClass,\n    IStatController.CoreAttributes change\n  );\n  event ConsumableUsed(address heroToken, uint heroTokenId, address item);\n  event RemoveConsumableUsage(address heroToken, uint heroTokenId, address item);\n  event HeroCustomDataChanged(address token, uint tokenId, bytes32 index, uint value);\n  event GlobalCustomDataChanged(bytes32 index, uint value);\n  //endregion ------------------ StatController\n\n  //region ------------------ DungeonFactoryController\n  event DungeonLaunched(\n    uint16 dungeonLogicNum,\n    uint64 dungeonId,\n    address heroToken,\n    uint heroTokenId,\n    address treasuryToken,\n    uint treasuryAmount\n  );\n\n  event BossCompleted(uint32 objectId, uint biome, address hero, uint heroId);\n  event FreeDungeonAdded(uint8 biome, uint64 dungeonId);\n\n  event ObjectOpened(uint64 dungId, address hero, uint id, uint32 objId, uint iteration, uint currentStage);\n  event Clear(uint64 dungId);\n\n  event DungeonLogicRegistered(uint16 dungLogicId, IDungeonFactory.DungeonGenerateInfo info);\n  event DungeonLogicRemoved(uint16 dungLogicId);\n  event DungeonSpecificLogicRegistered(uint16 dungLogicId, uint biome, uint heroCls);\n  event DungeonSpecificLogicRemoved(uint16 dungLogicId, uint heroLvl, uint heroCls);\n  event DungeonRegistered(uint16 dungLogicId, uint64 dungeonId);\n  event DungeonRemoved(uint16 dungLogicId, uint64 dungeonId);\n  event MinLevelForTreasuryChanged(address token, uint level);\n\n  event ObjectAction(\n    uint64 dungId,\n    IGOC.ActionResult result,\n    uint currentStage,\n    address heroToken,\n    uint heroTokenId,\n    uint newStage\n  );\n  /// @notice On add the item to the dungeon\n  event AddTreasuryItem(uint64 dungId, address itemAdr, uint itemId);\n  event AddTreasuryToken(uint64 dungId, address token, uint amount);\n  event ClaimToken(uint64 dungId, address token, uint amount);\n  event ClaimItem(uint64 dungId, address token, uint id);\n\n  event Entered(uint64 dungId, address hero, uint id);\n  event DungeonCompleted(uint16 dungLogicNum, uint64 dungId, address hero, uint heroId);\n  event Exit(uint64 dungId, bool claim);\n  event FreeDungeonRemoved(uint8 biome, uint64 dungeonId);\n  event HeroCurrentDungeonChanged(address hero, uint heroId, uint64 dungeonId);\n  //endregion ------------------ DungeonFactoryController\n\n  //region ------------------ GameObjectController\n  event EventRegistered(uint32 objectId, IGOC.EventRegInfo eventRegInfo);\n  event StoryRegistered(uint32 objectId, uint16 storyId);\n  event MonsterRegistered(uint32 objectId, IGOC.MonsterGenInfo monsterGenInfo);\n  event ObjectRemoved(uint32 objectId);\n  event ObjectResultEvent(\n    uint64 dungeonId,\n    uint32 objectId,\n    IGOC.ObjectType objectType,\n    address hero,\n    uint heroId,\n    uint8 stageId,\n    uint iteration,\n    bytes data,\n    IGOC.ActionResult result,\n    uint salt\n  );\n  //endregion ------------------ GameObjectController\n\n  //region ------------------ StoryController\n  event SetBurnItemsMeta(uint storyId, IStoryController.AnswerBurnRandomItemMeta meta);\n  event SetNextObjRewriteMeta(uint storyId, IStoryController.NextObjRewriteMeta meta);\n  event SetAnswersMeta(uint storyId, uint16[] answerPageIds, uint8[] answerHeroClasses, uint16[] answerIds);\n  event SetAnswerNextPageMeta(uint storyId, IStoryController.AnswerNextPageMeta meta);\n  event SetAnswerAttributeRequirements(uint storyId, IStoryController.AnswerAttributeRequirementsMeta meta);\n  event SetAnswerItemRequirements(uint storyId, IStoryController.AnswerItemRequirementsMeta meta);\n  event SetAnswerTokenRequirementsMeta(uint storyId, IStoryController.AnswerTokenRequirementsMeta meta);\n  event SetAnswerAttributes(uint storyId, IStoryController.AnswerAttributesMeta meta);\n  event SetAnswerHeroCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\n  event SetAnswerGlobalCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\n  event SetSuccessInfo(uint storyId, IStoryController.AnswerResultMeta meta);\n  event SetFailInfo(uint storyId, IStoryController.AnswerResultMeta meta);\n  event SetCustomDataResult(uint storyId, IStoryController.AnswerCustomDataResultMeta meta, IStoryController.CustomDataResult _type);\n  event StoryCustomDataRequirements(uint storyId, bytes32 requiredCustomDataIndex, uint requiredCustomDataMinValue, uint requiredCustomDataMaxValue, bool requiredCustomDataIsHero);\n  event StoryRequiredLevel(uint storyId, uint requiredLevel);\n  event StoryFinalized(uint32 objectId, uint storyId);\n  event StoryRemoved(uint32 objectId, uint storyId);\n\n  event ItemBurned(\n    address heroToken,\n    uint heroTokenId,\n    uint64 dungeonId,\n    uint objectId,\n    address nftToken,\n    uint nftId,\n    uint stageId,\n    uint iteration\n  );\n\n  /// @notice Durability of the item was reduced to 0\n  event ItemBroken(\n    address heroToken,\n    uint heroTokenId,\n    uint64 dungeonId,\n    uint objectId,\n    address nftToken,\n    uint nftId,\n    uint stageId,\n    uint iteration\n  );\n\n\n  event NotEquippedItemBurned(\n    address heroToken,\n    uint heroTokenId,\n    uint64 dungeonId,\n    uint storyId,\n    address nftToken,\n    uint nftId,\n    uint stageId,\n    uint iteration\n  );\n\n  event StoryChangeAttributes(\n    uint32 objectId,\n    address heroToken,\n    uint heroTokenId,\n    uint64 dungeonId,\n    uint storyId,\n    uint stageId,\n    uint iteration,\n    int32[] attributes\n  );\n  //endregion ------------------ StoryController\n\n  //region ------------------------ HeroController\n  event HeroTokensVaultSet(address value);\n  event HeroRegistered(address hero, uint8 heroClass, address payToken, uint payAmount);\n  event HeroCreated(address hero, uint heroId, string name, address owner, string refCode);\n  event BiomeChanged(address hero, uint heroId, uint8 biome);\n  event LevelUp(address hero, uint heroId, address owner, IStatController.CoreAttributes change);\n  event ReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\n  event ReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\n  event Killed(address hero, uint heroId, address killer, bytes32[] dropItems, uint dropTokenAmount);\n  //endregion ------------------------ HeroController\n\n  //region ------------------------ FightLib\n  event FightResultProcessed(\n    address sender,\n    IFightCalculator.FightInfoInternal result,\n    IFightCalculator.FightCall callData,\n    uint iteration\n  );\n  //endregion ------------------------ FightLib\n\n  //region ------------------------ Oracle\n  event Random(uint number, uint max);\n  //endregion ------------------------ Oracle\n\n  //region ------------------------ Controller\n  event OfferGovernance(address newGov);\n  event GovernanceAccepted(address gov);\n  event StatControllerChanged(address value);\n  event StoryControllerChanged(address value);\n  event GameObjectControllerChanged(address value);\n  event ReinforcementControllerChanged(address value);\n  event OracleChanged(address value);\n  event TreasuryChanged(address value);\n  event ItemControllerChanged(address value);\n  event HeroControllerChanged(address value);\n  event GameTokenChanged(address value);\n  event DungeonFactoryChanged(address value);\n  event ProxyUpdated(address proxy, address logic);\n  event Claimed(address token, uint amount);\n  event TokenStatusChanged(address token, bool status);\n  event UserControllerChanged(address value);\n  event GuildControllerChanged(address value);\n  //endregion ------------------------ Controller\n\n  //region ------------------------ HeroTokensVault\n  event Process(address token, uint amount, address from, uint toBurn, uint toTreasury, uint toGov);\n  //endregion ------------------------ HeroTokensVault\n\n  //region ------------------------ ReinforcementController\n  event HeroStaked(address heroToken, uint heroId, uint biome, uint score);\n  event HeroWithdraw(address heroToken, uint heroId);\n  event HeroAsk(address heroToken, uint heroId);\n  event TokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint totalAmount);\n  event NftRewardRegistered(address heroToken, uint heroId, address token, uint id);\n  event ToHelperRatioChanged(uint value);\n  event ClaimedToken(address heroToken, uint heroId, address token, uint amount, address recipient);\n  event ClaimedItem(address heroToken, uint heroId, address item, uint itemId, address recipient);\n  event MinLevelChanged(uint8 value);\n  event MinLifeChancesChanged(uint value);\n  //endregion ------------------------ ReinforcementController\n\n  //region ------------------------ Treasury\n  event AssetsSentToDungeon(address dungeon, address token, uint amount);\n  //endregion ------------------------ Treasury\n\n  //region ------------------------ EventLib\n  event EventResult(uint64 dungeonId, address heroToken, uint heroTokenId, uint8 stageId, IStatController.ActionInternalInfo gen, uint iteration);\n  //endregion ------------------------ EventLib\n\n  //region ------------------------ ItemStatsLib\n  event ItemRegistered(address item, IItemController.RegisterItemParams info);\n  event ItemRemoved(address item);\n  event NewItemMinted(address item, uint itemId, IItemController.MintInfo info);\n  event Equipped(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot);\n  event TakenOff(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot, address destination);\n  event ItemRepaired(address item, uint itemId, uint consumedItemId, uint16 baseDurability);\n  event FailedToRepairItem(address item, uint itemId, uint consumedItemId, uint16 itemDurability);\n  event Augmented(address item, uint itemId, uint consumedItemId, uint8 augLevel, IItemController.AugmentInfo info);\n  event NotAugmented(address item, uint itemId, uint consumedItemId, uint8 augLevel);\n  event ReduceDurability(address item, uint itemId, uint newDurability);\n  event Used(address item, uint tokenId, address heroToken, uint heroTokenId);\n  event Destroyed(address item, uint itemId);\n  //endregion ------------------------ ItemStatsLib\n\n  //region ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\n  event ChangePauseStatus(bool value);\n  event MinterChanged(address value);\n\n  event UniqueUriChanged(uint id, string uri);\n  event BaseUriChanged(string uri);\n\n  event HeroMinted(uint heroId);\n  event HeroBurned(uint heroId);\n  event HeroUriByStatusChanged(string uri, uint statusLvl);\n\n  event ItemMinted(uint tokenId);\n  event ItemBurned(uint tokenId);\n  event UriByRarityChanged(string uri, uint rarity);\n  event SponsoredHeroCreated(address msgSender, address heroAddress, uint heroId, string heroName);\n  //endregion ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\n\n  //region ------------------------ Guild\n  event SetUserName(address user, string name);\n  event LootBoxOpened(address user, uint lootBoxKind, address[] itemTokens, uint[] itemTokenIds);\n  event LootBoxConfigChanged(uint lootBoxKind, address[] mintItems, uint32[] mintItemsChances, uint maxDropItems);\n  event SetFeeRenaming(uint feeRenaming);\n  event ActivityCompleted(address user, bool daily, bool weekly);\n\n  event GuildCreated(address owner, uint guildId, string name, string urlLogo);\n  event AddToGuild(uint guildId, address newUser);\n  event ChangeGuildRights(uint guildId, address user, uint rights);\n  event RemoveFromGuild(uint guildId, address user);\n  event GuildLevelUp(uint guildId, uint8 newLevel);\n  event GuildRename(uint guildId, string newName);\n  event SetGuildRelation(uint guildId1, uint guildId2, bool peace);\n  //endregion ------------------------ Guild\n}\n"
    },
    "contracts/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ninterface IControllable {\n\n  function VERSION() external pure returns (string memory);\n\n  function revision() external view returns (uint);\n\n  function previousImplementation() external view returns (address);\n\n  function isController(address contract_) external view returns (bool);\n\n  function isGovernance(address contract_) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function controller() external view returns (address);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ninterface IController {\n\n  function governance() external view returns (address);\n\n  function statController() external view returns (address);\n\n  function storyController() external view returns (address);\n\n  function gameObjectController() external view returns (address);\n\n  function reinforcementController() external view returns (address);\n\n  function oracle() external view returns (address);\n\n  function treasury() external view returns (address);\n\n  function itemController() external view returns (address);\n\n  function heroController() external view returns (address);\n\n  function dungeonFactory() external view returns (address);\n\n  function gameToken() external view returns (address);\n\n  function validTreasuryTokens(address token) external view returns (bool);\n\n  function isDeployer(address adr) external view returns (bool);\n\n  function onPause() external view returns (bool);\n\n  function userController() external view returns (address);\n\n  function guildController() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IDungeonFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../openzeppelin/EnumerableMap.sol\";\n\ninterface IDungeonFactory {\n\n  /// @custom:storage-location erc7201:dungeon.factory.main\n  struct MainState {\n    /// @dev biome => dungeonLaunchedId\n    mapping(uint => EnumerableSet.UintSet) freeDungeons;\n    /// @dev hero + heroId + biome (packMapObject) -> completed\n    mapping(bytes32 => bool) bossCompleted;\n    /// @dev hero + heroId + dungNum (packDungeonKey) -> completed\n    mapping(bytes32 => bool) specificDungeonCompleted;\n    /// @notice Max biome completed by the hero\n    /// @dev hero + heroId (nftPacked) -> max biome completed\n    mapping(bytes32 => uint8) maxBiomeCompleted;\n    /// @notice which dungeon the hero is currently in\n    /// @dev hero+id => current DungeonId\n    mapping(bytes32 => uint64) heroCurrentDungeon;\n\n    // ---\n\n    /// @notice Specific dungeon for the given pair of hero level + hero class\n    ///         ALl specific dungeons are listed also in allSpecificDungeons\n    /// @dev packUint8Array(specReqBiome, specReqHeroClass) => dungNum\n    mapping(bytes32 => uint16) dungeonSpecific;\n    /// @dev contains all specific dungNum for easy management\n    EnumerableSet.UintSet allSpecificDungeons;\n    /// @dev biome => dungNum\n    mapping(uint8 => EnumerableSet.UintSet) dungeonsLogicByBiome;\n\n    // ---\n\n    /// @dev max available biome. auto-increment with new dung deploy\n    uint8 maxBiome;\n\n    /// @notice Address of treasure token => min hero level required\n    /// @dev manual threshold for treasury\n    mapping(address => uint) minLevelForTreasury;\n\n    /// @notice Contains arrays for SKILL_1, SKILL_2, SKILL_3 with 0 or 1\n    /// i.e. [0, 1, 0] means that durability of SKILL_2 should be reduced\n    /// @dev hero + heroId => uint8[] array where idx = slotNum\n    mapping(bytes32 => bytes32) skillSlotsForDurabilityReduction;\n\n    /// @notice Counter of dungeons, it's incremented on launch of a new dungeon\n    uint64 dungeonCounter;\n\n    /// @dev dungNum = init attributes\n    mapping(uint16 => DungeonAttributes) dungeonAttributes;\n    /// @dev dungeonId => status\n    mapping(uint64 => DungeonStatus) dungeonStatuses;\n  }\n\n  struct ObjectGenerateInfo {\n    /// @notice List of chamber types for each unique object\n    /// @dev uint8 types, packed using PackingLib.packUint8Array\n    bytes32[] objTypesByStages;\n    /// @notice List of chances for each chamber type\n    /// @dev uint64 chances\n    uint32[][] objChancesByStages;\n  }\n\n  struct DungeonGenerateInfo {\n    /// @notice List of chamber types for each unique object\n    uint8[][] objTypesByStages;\n    /// @notice List of chances for each chamber type\n    uint32[][] objChancesByStages;\n\n    uint32[] uniqObjects;\n\n    uint8 minLevel;\n    uint8 maxLevel;\n\n    bytes32[] requiredCustomDataIndex;\n    uint64[] requiredCustomDataMinValue;\n    uint64[] requiredCustomDataMaxValue;\n    bool[] requiredCustomDataIsHero;\n  }\n\n  /// @notice Attributes of the given dungeon logic\n  struct DungeonAttributes {\n    /// @notice Total number of stages that should be passed to complete the dungeon\n    uint8 stages;\n    uint8 biome;\n\n    /// @notice Default list of objects that should be passed in the dungeon\n    uint32[] uniqObjects;\n\n    /// @dev min+max (packUint8Array)\n    bytes32 minMaxLevel;\n\n    bytes32[] requiredCustomDataIndex;\n    /// @notice Packed DungeonGenerateInfo.requiredCustomData: MinValue, MaxValue, IsHero\n    /// @dev min+max+isHero(packStoryCustomDataRequirements)\n    bytes32[] requiredCustomDataValue;\n\n    ObjectGenerateInfo info;\n  }\n\n  /// @notice Current status of the given dungeon\n  struct DungeonStatus {\n    uint64 dungeonId;\n    /// @notice Dungeon logic id\n    uint16 dungNum;\n\n    /// @notice True if the dungeon is completed by the hero\n    bool isCompleted;\n\n    /// @notice Hero in the dungeon or 0\n    address heroToken;\n    uint heroTokenId;\n    /// @notice Current object that should be passed by the hero. 0 - new object is not opened\n    uint32 currentObject;\n    /// @notice Current stage in the dungeon that should be passed by the hero.\n    uint8 currentStage;\n\n    EnumerableMap.AddressToUintMap treasuryTokens;\n    /// @notice All items that were minted on result of made actions\n    bytes32[] treasuryItems;\n\n    /// @notice Total number of stages that should be passed to complete the dungeon\n    /// This value can be bigger than length of uniqObjects\n    uint8 stages;\n    /// @notice List of objects to be passed in the stage. The list can be dynamically changed during passing the stages\n    uint32[] uniqObjects;\n  }\n\n  ////////////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////////////\n\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external returns (uint64 dungeonId);\n\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8);\n\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64);\n\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result);\n\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external;\n\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IERC20Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n  /**\n   * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n  error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n  /**\n   * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n  error ERC20InvalidSender(address sender);\n\n  /**\n   * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n  error ERC20InvalidReceiver(address receiver);\n\n  /**\n   * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n  error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n  /**\n   * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n  error ERC20InvalidApprover(address approver);\n\n  /**\n   * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n  error ERC20InvalidSpender(address spender);\n}\n"
    },
    "contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n  /**\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n  /**\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n   */\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n  /**\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n   */\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n  /**\n   * @dev Returns the number of tokens in ``owner``'s account.\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @dev Returns the owner of the `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  /**\n   * @dev Transfers `tokenId` token from `from` to `to`.\n   *\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  /**\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n   * The approval is cleared when the token is transferred.\n   *\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n   *\n   * Requirements:\n   *\n   * - The caller must own the token or be an approved operator.\n   * - `tokenId` must exist.\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address to, uint256 tokenId) external;\n\n  /**\n   * @dev Returns the account approved for `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function getApproved(uint256 tokenId) external view returns (address operator);\n\n  /**\n   * @dev Approve or remove `operator` as an operator for the caller.\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n   *\n   * Requirements:\n   *\n   * - The `operator` cannot be the caller.\n   *\n   * Emits an {ApprovalForAll} event.\n   */\n  function setApprovalForAll(address operator, bool _approved) external;\n\n  /**\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n   *\n   * See {setApprovalForAll}\n   */\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n  /**\n   * @dev Returns the total amount of tokens stored by the contract.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n   * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n   */\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n  /**\n   * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n   * Use along with {totalSupply} to enumerate all tokens.\n   */\n  function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC721Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n  /**\n   * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n  error ERC721InvalidOwner(address owner);\n\n  /**\n   * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n  error ERC721NonexistentToken(uint256 tokenId);\n\n  /**\n   * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n  error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n  /**\n   * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n  error ERC721InvalidSender(address sender);\n\n  /**\n   * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n  error ERC721InvalidReceiver(address receiver);\n\n  /**\n   * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n  error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n  /**\n   * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n  error ERC721InvalidApprover(address approver);\n\n  /**\n   * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n  error ERC721InvalidOperator(address operator);\n}\n"
    },
    "contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n  /**\n   * @dev Returns the token collection name.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the token collection symbol.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n  /**\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n   * by `operator` from `from`, this function is called.\n   *\n   * It must return its Solidity selector to confirm the token transfer.\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n   *\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n   */\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n  ) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ninterface IETH {\n\n  function balanceOf(address target) external view returns (uint256);\n\n  function deposit() external payable;\n\n  function withdraw(uint256 wad) external;\n\n  function totalSupply() external view returns (uint256);\n\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n\n  function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n\n}\n"
    },
    "contracts/interfaces/IFightCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"./IStatController.sol\";\nimport \"./IItemController.sol\";\n\ninterface IFightCalculator {\n\n  enum AttackType {\n    UNKNOWN, // 0\n    MELEE, // 1\n    MAGIC, // 2\n    SLOT_3,\n    SLOT_4,\n    SLOT_5,\n    SLOT_6,\n    SLOT_7,\n    SLOT_8,\n    SLOT_9,\n    SLOT_10\n  }\n\n  /// @notice Attacker info: suitable both for hero and monsters\n  struct AttackInfo {\n    /// @notice Type of the attack\n    /// by default, if attack token presents, it's magic attack and not-magic otherwise\n    /// but this logic can become more complicated after introducing new attack types\n    AttackType attackType;\n    /// @notice NFT selected by hero for attack, it should be equip on.\n    /// If attacker is a monster, this is a special case (stub NFT with zero ID is used)\n    address attackToken;\n    uint attackTokenId;\n    address[] skillTokens;\n    uint[] skillTokenIds;\n  }\n\n  struct FighterInfo {\n    int32[] fighterAttributes;\n    IStatController.ChangeableStats fighterStats;\n    AttackType attackType;\n    address attackToken;\n    uint attackTokenId;\n    uint race;\n  }\n\n  struct Statuses {\n    bool stun;\n    bool burn;\n    bool freeze;\n    bool confuse;\n    bool curse;\n    bool poison;\n    bool gotCriticalHit;\n    bool missed;\n    bool hitBlocked;\n  }\n\n  struct FightResult {\n    int32 healthA;\n    int32 healthB;\n    int32 manaConsumedA;\n    int32 manaConsumedB;\n  }\n\n  struct FightCall {\n    FighterInfo fighterA;\n    FighterInfo fighterB;\n    uint64 dungeonId;\n    uint32 objectId;\n    address heroAdr;\n    uint heroId;\n    uint8 stageId;\n    uint iteration;\n    uint8 turn;\n  }\n\n  struct SkillSlots {\n    bool slot1;\n    bool slot2;\n    bool slot3;\n  }\n\n  //region ------------------------ FightLib-internal (FightInfoInternal is required by IApplicationEvents..)\n  struct FightInfoInternal {\n    Fighter fighterA;\n    Fighter fighterB;\n  }\n\n  struct Fighter {\n    IFightCalculator.FighterInfo info;\n    IItemController.AttackInfo magicAttack;\n    int32 health;\n    int32 manaConsumed;\n    int32 damage;\n    int32 damagePoison;\n    int32 damageReflect;\n    IFightCalculator.Statuses statuses;\n  }\n  //endregion ------------------------ FightLib-internal\n\n  function fight(FightCall memory callData) external returns (FightResult memory);\n}\n"
    },
    "contracts/interfaces/IGameToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"./IERC20.sol\";\n\ninterface IGameToken is IERC20 {\n\n  function minter() external view returns (address);\n\n  function mint(address account, uint amount) external returns (bool);\n\n  function burn(uint amount) external returns (bool);\n\n  function setMinter(address minter_) external;\n\n  function pause(bool value) external;\n\n}\n"
    },
    "contracts/interfaces/IGOC.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"./IController.sol\";\n\ninterface IGOC {\n\n  enum ObjectType {\n    UNKNOWN, // 0\n    EVENT, // 1\n    MONSTER, // 2\n    STORY, // 3\n    END_SLOT\n  }\n\n  enum ObjectSubType {\n    UNKNOWN_0, // 0\n    ENEMY_NPC_1, // 1\n    ENEMY_NPC_SUPER_RARE_2, // 2\n    BOSS_3, // 3\n    SHRINE_4, // 4\n    CHEST_5, // 5\n    STORY_6, // 6\n    STORY_UNIQUE_7, // 7\n    SHRINE_UNIQUE_8, // 8\n    CHEST_UNIQUE_9, // 9\n    ENEMY_NPC_UNIQUE_10, // 10\n    STORY_ON_ROAD_11, // 11\n    STORY_UNDERGROUND_12, // 12\n    STORY_NIGHT_CAMP_13, // 13\n    STORY_MOUNTAIN_14, // 14\n    STORY_WATER_15, // 15\n    STORY_CASTLE_16, // 16\n    STORY_HELL_17, // 17\n    STORY_SPACE_18, // 18\n    STORY_WOOD_19, // 19\n    STORY_CATACOMBS_20, // 20\n    STORY_BAD_HOUSE_21, // 21\n    STORY_GOOD_TOWN_22, // 22\n    STORY_BAD_TOWN_23, // 23\n    STORY_BANDIT_CAMP_24, // 24\n    STORY_BEAST_LAIR_25, // 25\n    STORY_PRISON_26, // 26\n    STORY_SWAMP_27, // 27\n    STORY_INSIDE_28, // 28\n    STORY_OUTSIDE_29, // 29\n    STORY_INSIDE_RARE_30,\n    STORY_OUTSIDE_RARE_31,\n    ENEMY_NPC_INSIDE_32,\n    ENEMY_NPC_INSIDE_RARE_33,\n    ENEMY_NPC_OUTSIDE_34,\n    ENEMY_NPC_OUTSIDE_RARE_35,\n    END_SLOT\n  }\n\n  /// @custom:storage-location erc7201:game.object.controller.main\n  struct MainState {\n\n    /// @dev objId = biome(00) type(00) id(0000) => biome(uint8) + objType(uint8)\n    /// Id is id of the event, story or monster.\n    mapping(uint32 => bytes32) objectMeta;\n\n    /// @dev biome(uint8) + objType(uint8) => set of object id\n    mapping(bytes32 => EnumerableSet.UintSet) objectIds;\n\n    /// @dev heroAdr180 + heroId64 + cType8 + biome8 => set of already played objects. Should be cleared periodically\n    mapping(bytes32 => EnumerableSet.UintSet) playedObjects;\n\n    /// @dev HeroAdr(160) + heroId(uint64) + objId(uint32) => iteration count. It needs for properly emit events for every new entrance.\n    mapping(bytes32 => uint) iterations;\n\n    /// @dev objId(uint32) => EventInfo\n    mapping(uint32 => EventInfo) eventInfos;\n\n    /// @dev objId(uint32) => storyId\n    mapping(uint32 => uint16) storyIds;\n\n    /// @dev objId(uint32) => MonsterInfo\n    mapping(uint32 => MonsterInfo) monsterInfos;\n\n    /// @dev hero+id => last fight action timestamp\n    mapping(bytes32 => uint) lastHeroFightTs;\n\n    /// @dev delay for user actions in fight (suppose to prevent bot actions)\n    uint fightDelay;\n  }\n\n  struct ActionResult {\n    bool kill;\n    bool completed;\n    address heroToken;\n    address[] mintItems;\n    int32 heal;\n    int32 manaRegen;\n    int32 lifeChancesRecovered;\n    int32 damage;\n    int32 manaConsumed;\n    uint32 objectId;\n    uint32 experience;\n    uint heroTokenId;\n    uint iteration;\n    uint32[] rewriteNextObject;\n  }\n\n  struct EventInfo {\n    /// @dev chance to use good or bad attributes/stats\n    uint32 goodChance;\n\n    /// @dev toBytes32ArrayWithIds\n    bytes32[] goodAttributes;\n    bytes32[] badAttributes;\n\n    /// @dev experience(uint32) + heal(int32) + manaRegen(int32) + lifeChancesRecovered(int32) + damage(int32) + manaConsume(int32) packStatsChange\n    bytes32 statsChange;\n\n    /// @dev item+chance packItemMintInfo\n    bytes32[] mintItems;\n  }\n\n  struct MonsterInfo {\n    /// @dev toBytes32ArrayWithIds\n    bytes32[] attributes;\n    /// @dev level(uint8) + race(uint8) + experience(uint32) + maxDropItems(uint8) packMonsterStats\n    bytes32 stats;\n    /// @dev attackToken(160) + attackTokenId(uint64) + attackType(uint8) packAttackInfo\n    bytes32 attackInfo;\n\n    /// @dev item+chance packItemMintInfo\n    bytes32[] mintItems;\n\n    /// @dev heroAdr(160) + heroId(uint64) => iteration => GeneratedMonster packed\n    mapping(bytes32 => mapping(uint => bytes32)) _generatedMonsters;\n  }\n\n  struct MultiplierInfo {\n    uint8 biome;\n    uint totalSupply;\n  }\n\n  struct GeneratedMonster {\n    bool generated;\n    uint8 turnCounter;\n    int32 hp;\n    uint32 amplifier;\n  }\n\n  struct MonsterGenInfo {\n    uint16 monsterId;\n    uint8 biome;\n    ObjectSubType subType;\n\n    uint8[] attributeIds;\n    int32[] attributeValues;\n\n    uint8 level;\n    uint8 race;\n    uint32 experience;\n    uint8 maxDropItems;\n\n    address attackToken;\n    uint64 attackTokenId;\n    uint8 attackType;\n\n    address[] mintItems;\n    uint32[] mintItemsChances;\n  }\n\n  struct ActionContext {\n    address sender;\n    address heroToken;\n    IController controller;\n    uint8 biome;\n    uint8 objectSubType;\n    uint8 stageId;\n    uint32 objectId;\n    uint64 dungeonId;\n    uint heroTokenId;\n    uint salt;\n    uint iteration;\n    bytes data;\n  }\n\n  struct EventRegInfo {\n    uint8 biome;\n    uint16 eventId;\n    ObjectSubType subType;\n\n    uint32 goodChance;\n\n    AttributeGenerateInfo goodAttributes;\n    AttributeGenerateInfo badAttributes;\n\n    uint32 experience;\n    int32 heal;\n    int32 manaRegen;\n    int32 lifeChancesRecovered;\n    int32 damage;\n    int32 manaConsumed;\n\n    address[] mintItems;\n    uint32[] mintItemsChances;\n  }\n\n  struct AttributeGenerateInfo {\n    uint8[] ids;\n    int32[] values;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////////////////////////////////////////////\n\n  /// @dev represent object registration if non zero values\n  function getObjectMeta(uint32 objectId) external view returns (uint8 biome, uint8 objectSubType);\n\n  function isBattleObject(uint32 objectId) external view returns (bool);\n\n  function getRandomObject(\n    uint8[] memory cTypes,\n    uint32[] memory chances,\n    uint8 biomeLevel,\n    address heroToken,\n    uint heroTokenId\n  ) external returns (uint32 objectId);\n\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint iteration);\n\n  function action(\n    address sender,\n    uint64 dungeonId,\n    uint32 objectId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 stageId,\n    bytes memory data\n  ) external returns (ActionResult memory);\n\n}\n"
    },
    "contracts/interfaces/IGuildController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/EnumerableSet.sol\";\n\ninterface IGuildController {\n  enum GuildRightBits {\n    ADMIN_0,\n    RENAME_1,\n    CHANGE_LOGO_2,\n    CHANGE_GUILD_HOUSE_3,\n    ADD_MEMBER_4,\n    REMOVE_MEMBER_5,\n    BANK_TOKENS_OPERATION_6,\n    CHANGE_ROLES_7,\n    LEVEL_UP_8,\n    SET_RELATION_KIND_9,\n    BANK_ITEMS_OPERATION_10\n  }\n\n  struct GuildData {\n    /// @notice Not empty unique guild name\n    string guildName;\n\n    /// @notice URL of guild logo (empty is allowed)\n    string urlLogo;\n\n    /// @notice Creator (owner) of the guild\n    address owner;\n\n    /// @notice Guild level [1...10]\n    uint8 guildLevel;\n\n    uint64 pvpCounter;\n  }\n\n  /// @notice Request of the guild to dominate at the given biome\n  struct DominationRequest {\n    /// @notice Biome where the guild is going to dominate\n    uint8 biome;\n    /// @notice Number of points scored\n    uint32 points;\n  }\n\n  /// @custom:storage-location erc7201:guild.controller.main\n  struct MainState {\n    /// @notice It's used to generate guild ids\n    uint counterGuildIds;\n\n    /// @notice name => guild id\n    mapping(uint guildId => GuildData) guildData;\n\n    /// @notice name => guild id\n    mapping(string guildName => uint guildId) nameToGuild;\n\n    /// @notice EOA => guild id, EOA can be a member of a single guild only\n    mapping(address member => uint guildId) memberToGuild;\n\n    /// @notice List of participants of guilds\n    /// @dev Allowed number of members is 20 + 5 * guildLevel\n    mapping(uint guildId => EnumerableSet.AddressSet listEoa) members;\n\n    /// @notice Rights of the member in the guild, mask of GuildRightBits\n    mapping(address member => uint maskRights) rights;\n\n    /// @notice _getGuildsPairKey(guild1, guild2) => status (false - war, true - peace)\n    mapping(bytes32 guildsPairKey => bool) relationsPeaceful;\n\n    /// @notice The guild that is currently dominated at the given biome\n    mapping(uint8 biome => uint guildId) biomeOwner;\n\n    /// @notice Each user can participate in single PvP battle per week only\n    mapping(address user => mapping(uint epochWeek => uint countBattles)) countPvP;\n\n    /// @notice Weekly request of the guild to dominate at the given biome starting from the next week\n    mapping(uint guildId => mapping(uint epochWeek => DominationRequest)) biomeRequest;\n\n    /// @notice List of guilds that has domination request for the given biome at the given week.\n    mapping(uint8 biome => mapping(uint epochWeek => EnumerableSet.UintSet guildIds)) dominationParticipants;\n\n    /// @notice Hom many times the given guild had domination at the given biome (to calculate penalty points)\n    mapping(uint guildId => mapping(uint8 biome => uint dominationCounter)) dominationCounter;\n  }\n\n}"
    },
    "contracts/interfaces/IHero.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ninterface IHero {\n\n  function isHero() external pure returns (bool);\n\n  function mintFor(address recipient) external returns (uint tokenId);\n\n  function burn(uint tokenId) external;\n\n}\n"
    },
    "contracts/interfaces/IHeroController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ninterface IHeroController {\n\n  /// @custom:storage-location erc7201:hero.controller.main\n  struct MainState {\n\n    /// @dev A central place for all hero tokens\n    address heroTokensVault;\n\n    /// @dev heroAdr => packed tokenAdr160+ amount96\n    mapping(address => bytes32) payToken;\n\n    /// @dev heroAdr => heroCls8\n    mapping(address => uint8) heroClass;\n\n    // ---\n\n    /// @dev hero+id => individual hero name\n    mapping(bytes32 => string) heroName;\n\n    /// @dev name => hero+id, needs for checking uniq names\n    mapping(string => bytes32) nameToHero;\n\n    // ---\n\n    /// @dev hero+id => biome\n    mapping(bytes32 => uint8) heroBiome;\n\n    /// @dev hero+id => rein hero+id\n    mapping(bytes32 => bytes32) reinforcementHero;\n\n    /// @dev hero+id => rein packed attributes\n    mapping(bytes32 => bytes32[]) reinforcementHeroAttributes;\n  }\n\n  function heroClass(address hero) external view returns (uint8);\n\n  function heroBiome(address hero, uint heroId) external view returns (uint8);\n\n  function payTokenInfo(address hero) external view returns (address token, uint amount);\n\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (address helperHeroToken, uint helperHeroId);\n\n  function score(address hero, uint heroId) external view returns (uint);\n\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool);\n\n  function heroTokensVault() external view returns (address);\n\n  // ---\n\n  function create(address hero, string memory heroName_, bool enter) external returns (uint);\n\n  function kill(address hero, uint heroId) external returns (bytes32[] memory dropItems);\n\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId);\n\n}\n"
    },
    "contracts/interfaces/IHeroTokensVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ninterface IHeroTokensVault {\n\n  function process(\n    address token,\n    uint amount,\n    address from\n  ) external;\n\n}\n"
    },
    "contracts/interfaces/IItem.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ninterface IItem {\n\n  function isItem() external pure returns (bool);\n\n  function mintFor(address recipient) external returns (uint tokenId);\n\n  function burn(uint tokenId) external;\n\n  function controlledTransfer(address from, address to, uint tokenId) external;\n}\n"
    },
    "contracts/interfaces/IItemController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"./IStatController.sol\";\nimport \"./IGOC.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\n\ninterface IItemController {\n\n  /// @custom:storage-location erc7201:item.controlbler.main\n  struct MainState {\n\n    ////////////////// GENERATE //////////////////\n\n    EnumerableSet.AddressSet items;\n\n    /// @dev itemAdr => itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\n    mapping(address => bytes32) itemMeta;\n\n    /// @dev itemAdr => packed tokenAdr160+ amount96\n    mapping(address => bytes32) augmentInfo;\n\n    // --- common attr ---\n\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\n    mapping(address => bytes32[]) generateInfoAttributes;\n\n    // --- consumable ---\n\n    /// @dev itemAdr => ids+values (toBytes32ArrayWithIds)\n    mapping(address => bytes32[]) _itemConsumableAttributes;\n\n    /// @dev itemAdr => IStatController.ChangeableStats packed int32[]\n    mapping(address => bytes32) itemConsumableStats;\n\n    // --- buff ---\n\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\n    mapping(address => bytes32[]) generateInfoCasterAttributes;\n\n    /// @dev itemAdr => id8 + minDmg(int32) + maxDmg(int32) + chance32\n    mapping(address => bytes32[]) generateInfoTargetAttributes;\n\n    // --- attack ---\n\n    /// @dev itemAdr => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\n    mapping(address => bytes32) generateInfoAttack;\n\n    ////////////////// ITEMS INFO //////////////////\n\n    /// @dev itemAdr+id => itemRarity8 + augmentationLevel8 + itemDurability16\n    mapping(bytes32 => bytes32) itemInfo;\n\n    /// @dev itemAdr+id => heroAdr+id\n    mapping(bytes32 => bytes32) equippedOn;\n\n    // --- common attr ---\n\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\n    mapping(bytes32 => bytes32[]) _itemAttributes;\n\n    // --- consumable ---\n\n    // consumable stats unchangeable, get them by address\n\n    // --- buff ---\n\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\n    mapping(bytes32 => bytes32[]) _itemCasterAttributes;\n\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\n    mapping(bytes32 => bytes32[]) _itemTargetAttributes;\n\n    // --- attack ---\n\n    /// @dev itemAdr+Id => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\n    mapping(bytes32 => bytes32) _itemAttackInfo;\n\n    ////////////////// Additional generate info //////////////////\n\n    /// @notice (itemAdr) => Bitmask of ConsumableActionBits\n    mapping(address => uint) _consumableActionMask;\n\n\n    /// --------------------------------- SIP-003: Item fragility\n    /// @notice itemAdr + id => item fragility counter that displays the chance of an unsuccessful repair\n    mapping(bytes32 packedItem => uint fragility) itemFragility;\n  }\n\n  struct RegisterItemParams {\n    ItemMeta itemMeta;\n    address augmentToken;\n    uint augmentAmount;\n    ItemGenerateInfo commonAttributes;\n\n    IGOC.AttributeGenerateInfo consumableAttributes;\n    IStatController.ChangeableStats consumableStats;\n\n    ItemGenerateInfo casterAttributes;\n    ItemGenerateInfo targetAttributes;\n\n    AttackInfo genAttackInfo;\n    /// @notice Bit mask of ConsumableActionBits\n    uint consumableActionMask;\n  }\n\n  /// @notice Possible actions that can be triggered by using the consumable item\n  enum ConsumableActionBits {\n    CLEAR_TEMPORARY_ATTRIBUTES_0,\n    EXIT_FROM_DUNGEON_1,\n    USE_GUILD_REINFORCEMENT_2,\n    RECREATION_IN_GUILD_HOUSE_3\n  }\n\n  struct ItemGenerateInfo {\n    /// @notice Attribute ids\n    uint8[] ids;\n    /// @notice Min value of the attribute, != 0\n    int32[] mins;\n    /// @notice Max value of the attribute, != 0\n    int32[] maxs;\n    /// @notice Chance of the selection [0..MAX_CHANCES]\n    uint32[] chances;\n  }\n\n  struct ItemMeta {\n    uint8 itemMetaType;\n    // Level in range 1-99. Reducing durability in low level dungeons. lvl/5+1 = biome\n    uint8 itemLevel;\n    IItemController.ItemType itemType;\n    uint16 baseDurability;\n    uint8 defaultRarity;\n    uint32 manaCost;\n\n    // it doesn't include positions with 100% chance\n    uint8 minRandomAttributes;\n    uint8 maxRandomAttributes;\n\n    IStatController.CoreAttributes requirements;\n  }\n\n  enum FeeType {\n    UNKNOWN,\n    REPAIR,\n    AUGMENT,\n    STORY,\n\n    END_SLOT\n  }\n\n  enum ItemRarity {\n    UNKNOWN, // 0\n    NORMAL, // 1\n    MAGIC, // 2\n    RARE, // 3\n    SET, // 4\n    UNIQUE, // 5\n\n    END_SLOT\n  }\n\n  enum ItemType {\n    NO_SLOT, // 0\n    HEAD, // 1\n    BODY, // 2\n    GLOVES, // 3\n    BELT, // 4\n    AMULET, // 5\n    RING, // 6\n    OFF_HAND, // 7\n    BOOTS, // 8\n    ONE_HAND, // 9\n    TWO_HAND, // 10\n    SKILL, // 11\n\n    END_SLOT\n  }\n\n  enum ItemMetaType {\n    UNKNOWN, // 0\n    COMMON, // 1\n    ATTACK, // 2\n    BUFF, // 3\n    CONSUMABLE, // 4\n\n    END_SLOT\n  }\n\n  enum AttackType {\n    UNKNOWN, // 0\n    FIRE, // 1\n    COLD, // 2\n    LIGHTNING, // 3\n    CHAOS, // 4\n\n    END_SLOT\n  }\n\n  struct AttackInfo {\n    AttackType aType;\n    int32 min;\n    int32 max;\n    // if not zero - activate attribute factor for the attribute\n    IStatController.CoreAttributes attributeFactors;\n  }\n\n  struct ItemInfo {\n    ItemRarity rarity;\n    uint8 augmentationLevel;\n    uint16 durability;\n  }\n\n  /// @dev The struct is used in events, so it's moved here from the lib\n  struct MintInfo {\n    IItemController.ItemMeta meta;\n    uint8[] attributesIds;\n    int32[] attributesValues;\n    IItemController.ItemRarity itemRarity;\n\n    IItemController.AttackInfo attackInfo;\n\n    uint8[] casterIds;\n    int32[] casterValues;\n    uint8[] targetIds;\n    int32[] targetValues;\n  }\n\n  /// @dev The struct is used in events, so it's moved here from the lib\n  struct AugmentInfo {\n    uint8[] attributesIds;\n    int32[] attributesValues;\n    IItemController.AttackInfo attackInfo;\n    uint8[] casterIds;\n    int32[] casterValues;\n    uint8[] targetIds;\n    int32[] targetValues;\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function itemMeta(address item) external view returns (ItemMeta memory meta);\n\n  function augmentInfo(address item) external view returns (address token, uint amount);\n\n  function genAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\n\n  function genCasterAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\n\n  function genTargetAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\n\n  function genAttackInfo(address item) external view returns (AttackInfo memory info);\n\n  function itemInfo(address item, uint itemId) external view returns (ItemInfo memory info);\n\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId);\n\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\n\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids);\n\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats);\n\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\n\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\n\n  function itemAttackInfo(address item, uint itemId) external view returns (AttackInfo memory info);\n\n  function score(address item, uint tokenId) external view returns (uint);\n\n  function isAllowedToTransfer(address item, uint tokenId) external view returns (bool);\n\n  // ---\n\n  function mint(address item, address recipient) external returns (uint itemId);\n\n  function reduceDurability(address hero, uint heroId, uint8 biome) external;\n\n  function destroy(address item, uint tokenId) external;\n\n  function takeOffDirectly(\n    address item,\n    uint itemId,\n    address hero,\n    uint heroId,\n    uint8 itemSlot,\n    address destination,\n    bool broken\n  ) external;\n\n  /// @notice SIP-003: item fragility counter that displays the chance of an unsuccessful repair.\n  /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\n  function itemFragility(address item, uint itemId) external view returns (uint);\n\n  /// @notice SIP-003: The quest mechanic that previously burned the item will increase its fragility by 1%\n  function incBrokenItemFragility(address item, uint itemId) external;\n}\n"
    },
    "contracts/interfaces/IMinter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\n\ninterface IMinter {\n\n  function amountForDungeon(uint dungeonBiomeLevel, uint heroLevel) external view returns (uint);\n\n  function mintDungeonReward(uint64 dungeonId, uint dungeonBiomeLevel, uint heroLevel) external returns (uint amount);\n\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ninterface IOracle {\n\n  function getRandomNumber(uint max, uint seed) external returns (uint);\n\n  function getRandomNumberInRange(uint min, uint max, uint seed) external returns (uint);\n\n}\n"
    },
    "contracts/interfaces/IPriceCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ninterface IPriceCalculator {\n\n  function getPrice(address token, address outputToken) external view returns (uint256);\n\n  function getPriceWithDefaultOutput(address token) external view returns (uint256);\n\n  function getLargestPool(address token, address[] memory usedLps) external view returns (address, uint256, address);\n\n  function getPriceFromLp(address lpAddress, address token) external view returns (uint256);\n\n}\n"
    },
    "contracts/interfaces/IProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ninterface IProxyControlled {\n\n  function upgrade(address newImplementation_) external;\n\n  function implementation() external view returns (address);\n\n}\n"
    },
    "contracts/interfaces/IReinforcementController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"./IStatController.sol\";\nimport \"../openzeppelin/EnumerableMap.sol\";\n\ninterface IReinforcementController {\n\n  /// @custom:storage-location erc7201:reinforcement.controller.main\n  struct MainState {\n\n    /// @dev minLvl8 + minLifeChances8\n    bytes32 config;\n\n    /// @dev hero token + hero id => heroInfo(biome8 + score128 + fee8 + stakeTs64)\n    mapping(bytes32 => bytes32) _stakedHeroes;\n    /// @dev biome => helperAdr+id\n    mapping(uint => EnumerableSet.Bytes32Set) _internalIdsByBiomes;\n    /// @dev biome => score  // The field is deprecated and not updated any more\n    mapping(uint => uint) maxScore;\n    /// @dev heroAdr+id => itemAdr+id\n    mapping(bytes32 => bytes32[]) _heroNftRewards;\n    /// @dev heroAdr+id => tokenAdr and amount map\n    mapping(bytes32 => EnumerableMap.AddressToUintMap) _heroTokenRewards;\n\n  }\n\n  struct HeroInfo {\n    uint8 biome;\n    uint score; // stored in 128 but easy to use 256\n    /// @notice To helper ratio\n    uint8 fee;\n    uint64 stakeTs;\n  }\n\n  function toHelperRatio(address heroToken, uint heroId) external view returns (uint);\n\n  function isStaked(address heroToken, uint heroId) external view returns (bool);\n\n  function askHero(uint biome) external returns (address heroToken, uint heroId, int32[] memory attributes);\n\n  function registerTokenReward(address heroToken, uint heroId, address token, uint amount) external;\n\n  function registerNftReward(address heroToken, uint heroId, address token, uint tokenId) external;\n\n}\n"
    },
    "contracts/interfaces/IStatController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\nimport \"../openzeppelin/EnumerableSet.sol\";\n\ninterface IStatController {\n\n  /// @custom:storage-location erc7201:stat.controller.main\n  struct MainState {\n    mapping(bytes32 => bytes32[]) heroTotalAttributes;\n    /// @dev heroAdr+heroId => int32 packed strength, dexterity, vitality, energy\n    mapping(bytes32 => bytes32) _heroCore;\n    mapping(bytes32 => bytes32[]) heroBonusAttributes;\n    mapping(bytes32 => bytes32[]) heroTemporallyAttributes;\n    /// @dev heroAdr+heroId => uint32 packed level, experience, life, mana, lifeChances\n    mapping(bytes32 => bytes32) heroStats;\n    /// @dev heroAdr+heroId+itemSlot => itemAdr + itemId\n    mapping(bytes32 => bytes32) heroSlots;\n    /// @dev heroAdr+heroId => busy slots uint8[] packed\n    mapping(bytes32 => bytes32) heroBusySlots;\n    mapping(bytes32 => EnumerableSet.AddressSet) usedConsumables;\n    mapping(bytes32 => mapping(bytes32 => uint)) heroCustomData;\n    mapping(bytes32 => uint) globalCustomData;\n  }\n\n\n  enum ATTRIBUTES {\n    // core\n    STRENGTH, // 0\n    DEXTERITY, // 1\n    VITALITY, // 2\n    ENERGY, // 3\n    // attributes\n    DAMAGE_MIN, // 4\n    DAMAGE_MAX, // 5\n    ATTACK_RATING, // 6\n    DEFENSE, // 7\n    BLOCK_RATING, // 8\n    LIFE, // 9\n    MANA, // 10\n    // resistance\n    FIRE_RESISTANCE, // 11\n    COLD_RESISTANCE, // 12\n    LIGHTNING_RESISTANCE, // 13\n    // dmg against\n    DMG_AGAINST_HUMAN, // 14\n    DMG_AGAINST_UNDEAD, // 15\n    DMG_AGAINST_DAEMON, // 16\n    DMG_AGAINST_BEAST, // 17\n\n    // defence against\n    DEF_AGAINST_HUMAN, // 18\n    DEF_AGAINST_UNDEAD, // 19\n    DEF_AGAINST_DAEMON, // 20\n    DEF_AGAINST_BEAST, // 21\n\n    // --- unique, not augmentable\n    // hero will not die until have positive chances\n    LIFE_CHANCES, // 22\n    // increase chance to get an item\n    MAGIC_FIND, // 23\n    // decrease chance to get an item\n    DESTROY_ITEMS, // 24\n    // percent of chance x2 dmg\n    CRITICAL_HIT, // 25\n    // dmg factors\n    MELEE_DMG_FACTOR, // 26\n    FIRE_DMG_FACTOR, // 27\n    COLD_DMG_FACTOR, // 28\n    LIGHTNING_DMG_FACTOR, // 29\n    // increase attack rating on given percent\n    AR_FACTOR, // 30\n    // percent of damage will be converted to HP\n    LIFE_STOLEN_PER_HIT, // 31\n    // amount of mana restored after each battle\n    MANA_AFTER_KILL, // 32\n    // reduce all damage on percent after all other reductions\n    DAMAGE_REDUCTION, // 33\n\n    // -- statuses\n    // chance to stun an enemy, stunned enemy skip next hit\n    STUN, // 34\n    // chance burn an enemy, burned enemy will loss 50% of defence\n    BURN, // 35\n    // chance freeze an enemy, frozen enemy will loss 50% of MELEE damage\n    FREEZE, // 36\n    // chance to reduce enemy's attack rating on 50%\n    CONFUSE, // 37\n    // chance curse an enemy, cursed enemy will loss 50% of resistance\n    CURSE, // 38\n    // percent of dmg return to attacker\n    REFLECT_DAMAGE_MELEE, // 39\n    REFLECT_DAMAGE_MAGIC, // 40\n    // chance to poison enemy, poisoned enemy will loss 10% of the current health\n    POISON, // 41\n    // reduce chance get any of uniq statuses\n    RESIST_TO_STATUSES, // 42\n\n    END_SLOT // 46\n  }\n\n  // possible\n  // HEAL_FACTOR\n\n  struct CoreAttributes {\n    int32 strength;\n    int32 dexterity;\n    int32 vitality;\n    int32 energy;\n  }\n\n  struct ChangeableStats {\n    uint32 level;\n    uint32 experience;\n    uint32 life;\n    uint32 mana;\n    uint32 lifeChances;\n  }\n\n  enum ItemSlots {\n    UNKNOWN, // 0\n    HEAD, // 1\n    BODY, // 2\n    GLOVES, // 3\n    BELT, // 4\n    AMULET, // 5\n    BOOTS, // 6\n    RIGHT_RING, // 7\n    LEFT_RING, // 8\n    RIGHT_HAND, // 9\n    LEFT_HAND, // 10\n    TWO_HAND, // 11\n    SKILL_1, // 12\n    SKILL_2, // 13\n    SKILL_3, // 14\n    END_SLOT // 15\n  }\n\n  struct NftItem {\n    address token;\n    uint tokenId;\n  }\n\n  enum Race {\n    UNKNOWN, // 0\n    HUMAN, // 1\n    UNDEAD, // 2\n    DAEMON, // 3\n    BEAST, // 4\n    END_SLOT // 5\n  }\n\n  struct ChangeAttributesInfo {\n    address heroToken;\n    uint heroTokenId;\n    int32[] changeAttributes;\n    bool add;\n    bool temporally;\n  }\n\n  struct BuffInfo {\n    address heroToken;\n    uint heroTokenId;\n    uint32 heroLevel;\n    address[] buffTokens;\n    uint[] buffTokenIds;\n  }\n\n  /// @dev This struct is used inside event, so it's moved here from lib\n  struct ActionInternalInfo {\n    int32[] posAttributes;\n    int32[] negAttributes;\n\n    uint32 experience;\n    int32 heal;\n    int32 manaRegen;\n    int32 lifeChancesRecovered;\n    int32 damage;\n    int32 manaConsumed;\n\n    address[] mintedItems;\n  }\n\n  function initNewHero(address token, uint tokenId, uint heroClass) external;\n\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory);\n\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32);\n\n  function heroAttributesLength(address token, uint tokenId) external view returns (uint);\n\n  function heroBaseAttributes(address token, uint tokenId) external view returns (CoreAttributes memory);\n\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint);\n\n  function globalCustomData(bytes32 index) external view returns (uint);\n\n  function heroStats(address token, uint tokenId) external view returns (ChangeableStats memory);\n\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked);\n\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory);\n\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool);\n\n  function levelUp(address token, uint tokenId, uint heroClass, CoreAttributes memory change) external returns (uint newLvl);\n\n  function changeHeroItemSlot(\n    address heroToken,\n    uint64 heroTokenId,\n    uint itemType,\n    uint8 itemSlot,\n    address itemToken,\n    uint itemTokenId,\n    bool equip\n  ) external;\n\n  function changeCurrentStats(\n    address token,\n    uint tokenId,\n    ChangeableStats memory change,\n    bool increase\n  ) external;\n\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external;\n\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external;\n\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external;\n\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external;\n\n  function buffHero(BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed);\n\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external;\n\n  function setGlobalCustomData(bytes32 index, uint value) external;\n\n  /// @notice Restore life and mana during reinforcement\n  /// @param prevAttributes Hero attributes before reinforcement\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external;\n}\n"
    },
    "contracts/interfaces/IStoryController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../interfaces/IGOC.sol\";\nimport \"../interfaces/IStatController.sol\";\nimport \"../interfaces/IItemController.sol\";\nimport \"./IController.sol\";\nimport \"./IOracle.sol\";\nimport \"./IHeroController.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\n\ninterface IStoryController {\n\n  enum AnswerResultId {\n    UNKNOWN, // 0\n    SUCCESS, // 1\n    ATTRIBUTE_FAIL, // 2\n    RANDOM_FAIL, // 3\n    DELAY_FAIL, // 4\n    HERO_CUSTOM_DATA_FAIL, // 5\n    GLOBAL_CUSTOM_DATA_FAIL, // 6\n\n    END_SLOT\n  }\n\n  enum CustomDataResult {\n    UNKNOWN, // 0\n    HERO_SUCCESS, // 1\n    HERO_FAIL, // 2\n    GLOBAL_SUCCESS, // 3\n    GLOBAL_FAIL, // 4\n\n    END_SLOT\n  }\n\n  /// @custom:storage-location erc7201:story.controller.main\n  struct MainState {\n\n    // --- STORY REG INFO ---\n\n    /// @dev Uniq story identification.\n    mapping(uint32 => uint16) storyIds;\n    /// @dev Revers mapping for stories for using in the next object rewrite logic.\n    mapping(uint16 => uint32) idToStory;\n    /// @dev Store used ids for stories.\n    mapping(uint16 => bool) _usedStoryIds;\n    /// @dev Prevent register the story twice\n    mapping(uint32 => bool) registeredStories;\n\n    // --- ANSWER MAPPING ---\n\n    /// @dev storyId => all story pages. We need to have this mapping for properly remove meta info\n    mapping(uint16 => EnumerableSet.UintSet) allStoryPages;\n\n    /// @dev storyId => all possible answers. We need to have this mapping for properly remove meta info\n    mapping(uint16 => EnumerableSet.Bytes32Set) allStoryAnswers;\n\n    /// @dev storyId + pageId + heroClass (zero is default answers) => storyId + pageId + heroClass (zero is default answers) + answerId\n    mapping(bytes32 => bytes32[]) answers;\n    /// @dev answerUnPackedId + answerResultId => nextPageIds (will be chosen randomly from this array)\n    ///      where answerResultId is:\n    ///      0 - unknown,\n    ///      1 - success,\n    ///      2 - attr fail\n    ///      3 - random fail\n    ///      4 - delay fail\n    ///      5 - hero custom data fail\n    ///      6 - global custom data fail\n    ///      see COUNT_ANSWER_RESULT_IDS\n    mapping(bytes32 => uint16[]) nextPageIds;\n    /// @dev story + pageId + heroClass (zero is default answers) => random nextObjs (adr + id, like packed nft id)\n    mapping(bytes32 => uint32[]) nextObjectsRewrite;\n\n    /// @dev answerPackedId => packed array of uint32[]\n    ///      0 - random requirement(uint32, 1 - 99% success of this action, zero means no check)\n    ///      1 - delay requirement(uint32, if time since the last call more than this value the check is fail, zero means no check)\n    ///      2 - isFinalAnswer(uint8)\n    mapping(bytes32 => bytes32) answerAttributes;\n\n    // --- ANSWER REQUIREMENTS ---\n\n    /// @dev answerPackedId => array of AttributeRequirementsPacked\n    mapping(bytes32 => bytes32[]) attributeRequirements;\n    /// @dev answerPackedId=> array of ItemRequirementsPacked\n    mapping(bytes32 => bytes32[]) itemRequirements;\n    /// @dev answerPackedId => array of TokenRequirementsPacked\n    mapping(bytes32 => bytes32[]) tokenRequirements;\n    /// @dev answerPackedId => custom data for hero\n    mapping(bytes32 => CustomDataRequirementPacked[]) heroCustomDataRequirement;\n    /// @dev answerPackedId => global custom data\n    mapping(bytes32 => CustomDataRequirementPacked[]) globalCustomDataRequirement;\n\n    // --- ANSWER RESULTS ---\n\n    /// @dev answerPackedId => change attributes\n    mapping(bytes32 => bytes32[]) successInfoAttributes;\n    /// @dev answerPackedId => change stats\n    mapping(bytes32 => bytes32) successInfoStats;\n    /// @dev answerPackedId => mint items\n    mapping(bytes32 => bytes32[]) successInfoMintItems;\n\n    /// @dev answerPackedId => change attributes\n    mapping(bytes32 => bytes32[]) failInfoAttributes;\n    /// @dev answerPackedId => change stats\n    mapping(bytes32 => bytes32) failInfoStats;\n    /// @dev answerPackedId => mint items\n    mapping(bytes32 => bytes32[]) failInfoMintItems;\n\n    /// @dev answerUnPackedId + CustomDataResult => custom data array change\n    ///      where CustomDataResult is\n    ///      1 - hero success\n    ///      2 - hero fail\n    ///      3 - global success\n    ///      4 - global fail\n    ///      see COUNT_CUSTOM_DATA_RESULT_IDS\n    mapping(bytes32 => bytes32[]) customDataResult;\n\n    /// @notice answerPackedId => slot+chance+stopIfBurnt\n    /// @dev Since SIP-003 the items are not burn but broke\n    mapping(bytes32 => bytes32[]) burnItem;\n\n    // --- GENERAL STORY REQUIREMENTS ---\n\n    /// @dev story => Custom hero data requirements for a story. If exist and hero is not eligible should be not chose in a dungeon.\n    mapping(uint => CustomDataRequirementRangePacked[]) storyRequiredHeroData;\n    /// @dev story => Minimal level for the history. 0 means no requirements.\n    mapping(uint => uint) storyRequiredLevel;\n\n    // --- HERO STATES ---\n\n    /// @dev hero + heroId + storyId => pageId + heroLastActionTS\n    mapping(bytes32 => bytes32) heroState;\n\n    // --- OTHER ---\n\n    /// @dev storyId => build hash for the last update\n    mapping(uint16 => uint) storyBuildHash;\n\n    /// @notice Number of already minted items by the user within the given iteration of the story.\n    /// Only minting of the given number of items is allowed per iteration (see MAX_MINTED_ITEMS_PER_ITERATION).\n    /// @dev hero, heroId, story => mintedInIteration\n    /// This map is not cleared: storyId:objectId is 1:1, each object has own sequence of iterations without duplicates\n    mapping(bytes32 => mapping(uint iteration => uint countMintedItems)) mintedInIteration;\n  }\n\n  /// @dev We need to have flat structure coz Solidity can not handle arrays of structs properly\n  struct StoryMetaInfo {\n    uint16 storyId;\n\n    // --- story reqs\n\n    bytes32[] requiredCustomDataIndex;\n    uint64[] requiredCustomDataMinValue;\n    uint64[] requiredCustomDataMaxValue;\n    bool[] requiredCustomDataIsHero;\n    uint minLevel;\n\n    // --- answer reqs\n\n    AnswersMeta answersMeta;\n    AnswerNextPageMeta answerNextPage;\n    AnswerAttributeRequirementsMeta answerAttributeRequirements;\n    AnswerItemRequirementsMeta answerItemRequirements;\n    AnswerTokenRequirementsMeta answerTokenRequirements;\n    AnswerAttributesMeta answerAttributes;\n    AnswerCustomDataMeta answerHeroCustomDataRequirement;\n    AnswerCustomDataMeta answerGlobalCustomDataRequirement;\n\n    // --- answer results\n\n    AnswerBurnRandomItemMeta answerBurnRandomItemMeta;\n    NextObjRewriteMeta nextObjRewriteMeta;\n\n    // --- story results\n\n    AnswerResultMeta successInfo;\n    AnswerResultMeta failInfo;\n\n    AnswerCustomDataResultMeta successHeroCustomData;\n    AnswerCustomDataResultMeta failHeroCustomData;\n    AnswerCustomDataResultMeta successGlobalCustomData;\n    AnswerCustomDataResultMeta failGlobalCustomData;\n  }\n\n  struct NextObjRewriteMeta {\n    uint16[] nextObjPageIds;\n    uint8[] nextObjHeroClasses;\n    uint32[][] nextObjIds;\n  }\n\n  struct AnswersMeta {\n    uint16[] answerPageIds;\n    uint8[] answerHeroClasses;\n    uint16[] answerIds;\n  }\n\n  struct AnswerNextPageMeta {\n    uint16[] pageId;\n    uint8[] heroClass;\n    uint16[] answerId;\n    uint8[] answerResultIds;\n    uint16[][] answerNextPageIds;\n  }\n\n  struct AnswerAttributeRequirementsMeta {\n    uint16[] pageId;\n    uint8[] heroClass;\n    uint16[] answerId;\n    bool[][] cores;\n    uint8[][] ids;\n    int32[][] values;\n  }\n\n  struct AnswerItemRequirementsMeta {\n    uint16[] pageId;\n    uint8[] heroClass;\n    uint16[] answerId;\n    address[][] requireItems;\n    bool[][] requireItemBurn;\n    bool[][] requireItemEquipped;\n  }\n\n  struct AnswerTokenRequirementsMeta {\n    uint16[] pageId;\n    uint8[] heroClass;\n    uint16[] answerId;\n    address[][] requireToken;\n    uint88[][] requireAmount;\n    bool[][] requireTransfer;\n  }\n\n  struct AnswerAttributesMeta {\n    uint16[] pageId;\n    uint8[] heroClass;\n    uint16[] answerId;\n    uint32[] randomRequirements;\n    uint32[] delayRequirements;\n    bool[] isFinalAnswer;\n  }\n\n  struct AnswerCustomDataMeta {\n    uint16[] pageId;\n    uint8[] heroClass;\n    uint16[] answerId;\n\n    bytes32[][] dataIndexes;\n    bool[][] mandatory;\n    uint64[][] dataValuesMin;\n    uint64[][] dataValuesMax;\n  }\n\n  struct AnswerResultMeta {\n    uint16[] pageId;\n    uint8[] heroClass;\n    uint16[] answerId;\n\n    uint8[][] attributeIds;\n    /// @dev Max value is limitied by int24, see toBytes32ArrayWithIds impl\n    int32[][] attributeValues;\n\n    uint32[] experience;\n    int32[] heal;\n    int32[] manaRegen;\n    int32[] lifeChancesRecovered;\n    int32[] damage;\n    int32[] manaConsumed;\n\n    address[][] mintItems;\n    uint32[][] mintItemsChances;\n  }\n\n  struct AnswerCustomDataResultMeta {\n    uint16[] pageId;\n    uint8[] heroClass;\n    uint16[] answerId;\n\n    bytes32[][] dataIndexes;\n    int16[][] dataValues;\n  }\n\n  struct AnswerBurnRandomItemMeta {\n    uint16[] pageId;\n    uint8[] heroClass;\n    uint16[] answerId;\n\n    /// @notice 0 - random slot\n    uint8[][] slots;\n    /// @notice typical chances are [0..100] (no decimals here)\n    uint64[][] chances;\n    /// @notice Since SIP-003 the burning is replaced by breaking bu the name is kept as is\n    bool[][] isStopIfBurnt;\n  }\n\n  struct CustomDataRequirementPacked {\n    bytes32 index;\n    /// @dev min(uint64) + max(uint64) + mandatory(uint8)\n    bytes32 data;\n  }\n\n  struct CustomDataRequirementRangePacked {\n    bytes32 index;\n    /// @dev min(uint64) + max(uint64) + isHeroData(uint8)\n    bytes32 data;\n  }\n\n  struct StatsChange {\n    uint32 experience;\n    int32 heal;\n    int32 manaRegen;\n    int32 lifeChancesRecovered;\n    int32 damage;\n    int32 manaConsumed;\n  }\n\n  struct StoryActionContext {\n    uint stageId;\n    uint iteration;\n    bytes32 answerIdHash;\n    bytes32 answerAttributes;\n    address sender;\n    address heroToken;\n    IController controller;\n    IStatController statController;\n    IHeroController heroController;\n    IOracle oracle;\n    IItemController itemController;\n    uint8 heroClass;\n    uint8 heroClassFromAnswerHash;\n    uint8 biome;\n    uint16 storyId;\n    uint16 storyIdFromAnswerHash;\n    uint16 pageIdFromAnswerHash;\n    uint16 answerNumber;\n    uint16 pageId;\n    uint32 objectId;\n    uint64 dungeonId;\n    uint40 heroLastActionTS;\n    uint80 heroTokenId;\n    IStatController.ChangeableStats heroStats;\n  }\n\n  // --- WRITE ---\n\n  function storyAction(\n    address sender,\n    uint64 dungeonId,\n    uint32 objectId,\n    uint stageId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 biome,\n    uint iteration,\n    bytes memory data\n  ) external returns (IGOC.ActionResult memory);\n\n  // --- READ ---\n\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool);\n\n  function idToStory(uint16 id) external view returns (uint32 objectId);\n\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId);\n\n  function storyIds(uint32 objectId) external view returns (uint16);\n\n  function registeredStories(uint32 objectId) external view returns (bool);\n\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"./IItemController.sol\";\n\ninterface ITreasury {\n\n  function balanceOfToken(address token) external view returns (uint);\n\n  function sendToDungeon(address dungeon, address token, uint amount) external;\n\n  function sendFee(address token, uint amount, IItemController.FeeType feeType) external;\n\n}\n"
    },
    "contracts/interfaces/IUserController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ninterface IUserController {\n\n  //region ------------------------ Data types\n\n  enum LootBoxKind {\n    /// @notice small loot box - reward for the daily activity\n    DAILY_0,\n    /// @notice large loot box - reward for the weekly activity (daily activity is passed each ot of the 7 days)\n    WEEKLY_1,\n\n    END_SLOT\n  }\n\n  /// @dev registerPassedDungeon assumes that the whole struct takes single slot only, not more\n  struct UserActivity {\n    /// @notice A day for which the daily activity is calculated (see counterXXX below)\n    /// The number of days since 1970-01-01\n    uint32 epochDay;\n\n    /// @notice A week for which total count of daily activities were calculated\n    /// The number of weeks since (1970-01-01 Thursday) - 3 days = (1969-12-29 Monday)\n    uint32 epochWeek;\n\n    /// @notice Count of dungeons passed during the day\n    uint32 counterPassedDungeons;\n    /// @notice Count of PvP during the day\n    uint32 counterPvp;\n\n    /// @notice Count of daily activities completed per the week\n    uint16 dailyActivities;\n\n    /// @notice Daily activity is completed and small loot box is added to the earned loot boxes\n    bool dailyLootBoxReceived;\n    /// @notice Weekly activity is completed and large loot box is added to the earned loot boxes\n    bool weeklyLootBoxReceived;\n  }\n\n  struct EarnedLootBoxes {\n    /// @notice Count of loot boxes earned by daily activity\n    uint32 dailyCounter;\n    /// @notice Count of loot boxes earned by weekly activity\n    uint32 weeklyCounter;\n  }\n\n  struct LootBoxConfig {\n    address[] mintItems;\n    uint32[] mintItemsChances;\n    uint maxDropItems;\n  }\n\n  /// @custom:storage-location erc7201:user.controller.main\n  struct MainState {\n    /// @notice Amount of sacra required to rename user account\n    uint feeRenaming;\n\n    /// @dev user EOA => account name\n    mapping(address => string) userAccountName;\n\n    /// @dev name => user EOA, needs for checking uniq names\n    mapping(string => address) nameToUserAccount;\n\n    /// @notice user => daily activity info\n    mapping(address => UserActivity) userActivity;\n\n    /// @notice user => earned loot boxes\n    mapping(address => EarnedLootBoxes) counterLootBoxes;\n\n    /// @notice Configs of loot boxes of various kinds\n    mapping(LootBoxKind => LootBoxConfig) lootBoxConfig;\n  }\n  //endregion ------------------------ Data types\n\n  /// @notice Register daily activity - a dungeon was passed\n  /// @param user Owner of the hero who has passed the dungeon\n  function registerPassedDungeon(address user) external;\n\n  /// @notice Register daily activity - PvP was made\n  /// @param user Owner of the hero who has taken participation in the PvP\n  function registerPvP(address user, bool isWinner) external;\n}"
    },
    "contracts/lib/AppLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IERC20.sol\";\n\n/// @notice Common internal utils\nlibrary AppLib {\n\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\n  /// @dev Should NOT be used for third-party pools\n  function approveIfNeeded(address token, uint amount, address spender) internal {\n    if (IERC20(token).allowance(address(this), spender) < amount) {\n      IERC20(token).approve(spender, type(uint).max);\n    }\n  }\n\n}\n"
    },
    "contracts/lib/CalcLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../solady/LibPRNG.sol\";\n\nlibrary CalcLib {\n\n  uint32 public constant MAX_CHANCE = 1e9;\n\n  function minI32(int32 a, int32 b) internal pure returns (int32) {\n    return a < b ? a : b;\n  }\n\n  function max32(int32 a, int32 b) internal pure returns (int32) {\n    return a >= b ? a : b;\n  }\n\n  function absDiff(int32 a, int32 b) internal pure returns (uint32) {\n    if (!((a >= 0 && b >= 0) || (a <= 0 && b <= 0))) revert IAppErrors.AbsDiff(a, b);\n    if (a < 0) {\n      a = - a;\n    }\n    if (b < 0) {\n      b = - b;\n    }\n    return uint32(uint(int(a >= b ? a - b : b - a)));\n  }\n\n  function toUint(int32 n) internal pure returns (uint) {\n    if (n < 0) {\n      return 0;\n    }\n    if (n <= 0) {\n      return 0;\n    }\n    return uint(int(n));\n  }\n\n  function toInt32(uint a) internal pure returns (int32){\n    if (a >= uint(int(type(int32).max))) {\n      return type(int32).max;\n    }\n    return int32(int(a));\n  }\n\n  /// @dev Simplified pseudo-random for minor functionality\n  function pseudoRandom(uint maxValue) internal view returns (uint) {\n    if (maxValue == 0) {\n      return 0;\n    }\n    // pseudo random number\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft()))) % (maxValue + 1));\n  }\n\n  function pseudoRandomUint32(uint32 maxValue) internal view returns (uint32) {\n    return uint32(pseudoRandom(uint(maxValue)));\n  }\n\n  /// @notice Generate pseudo-random uint in the range [0..maxValue) using Solady pseudo-random function\n  function nextPrng(LibPRNG.PRNG memory prng, uint maxValue) internal pure returns (uint) {\n    return LibPRNG.next(prng) % maxValue;\n  }\n\n  /// @notice pseudoRandomUint32 with customizable pseudoRandom()\n  function pseudoRandomUint32Flex(\n    uint32 maxValue,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (uint32) {\n    return uint32(random_(uint(maxValue)));\n  }\n\n  function pseudoRandomInt32(int32 maxValue) internal view returns (int32) {\n    bool neg;\n    if (maxValue < 0) {\n      neg = true;\n      maxValue = - maxValue;\n    }\n    uint32 v = uint32(pseudoRandom(uint(int(maxValue))));\n    return neg\n      ? - int32(int(uint(v)))\n      : int32(int(uint(v)));\n  }\n\n  /// @dev Simplified pseudo-random for minor functionality\n  function pseudoRandomWithSeed(uint maxValue, uint seed) internal view returns (uint) {\n    if (maxValue == 0) {\n      return 0;\n    }\n    // pseudo random number\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), seed))) % (maxValue + 1));\n  }\n\n  /// @dev Simplified pseudo-random for minor functionality, in range\n  function pseudoRandomInRange(uint min, uint max) internal view returns (uint) {\n    if (min >= max) {\n      return max;\n    }\n    uint r = pseudoRandom(max - min);\n    return min + r;\n  }\n\n  /// @dev Simplified pseudo-random for minor functionality, in range\n  ///      Equal to pseudoRandomInRange(min, max, pseudoRandom)\n  function pseudoRandomInRangeFlex(\n    uint min,\n    uint max,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (uint) {\n    return min >= max ? max : min + random_(max - min);\n  }\n\n  function minusWithZeroFloor(uint a, uint b) internal pure returns (uint){\n    if (a <= b) {\n      return 0;\n    }\n    return a - b;\n  }\n\n  function minusWithMinFloorI32(int32 a, int32 b) internal pure returns (int32){\n    if (int(a) - int(b) < type(int32).min) {\n      return type(int32).min;\n    }\n    return a - b;\n  }\n\n  function plusWithMaxFloor32(int32 a, int32 b) internal pure returns (int32){\n    if (int(a) + int(b) >= type(int32).max) {\n      return type(int32).max;\n    }\n    return a + b;\n  }\n\n  function sqrt(uint x) internal pure returns (uint z) {\n    assembly {\n    // Start off with z at 1.\n      z := 1\n\n    // Used below to help find a nearby power of 2.\n      let y := x\n\n    // Find the lowest power of 2 that is at least sqrt(x).\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\n        y := shr(128, y) // Like dividing by 2 ** 128.\n        z := shl(64, z) // Like multiplying by 2 ** 64.\n      }\n      if iszero(lt(y, 0x10000000000000000)) {\n        y := shr(64, y) // Like dividing by 2 ** 64.\n        z := shl(32, z) // Like multiplying by 2 ** 32.\n      }\n      if iszero(lt(y, 0x100000000)) {\n        y := shr(32, y) // Like dividing by 2 ** 32.\n        z := shl(16, z) // Like multiplying by 2 ** 16.\n      }\n      if iszero(lt(y, 0x10000)) {\n        y := shr(16, y) // Like dividing by 2 ** 16.\n        z := shl(8, z) // Like multiplying by 2 ** 8.\n      }\n      if iszero(lt(y, 0x100)) {\n        y := shr(8, y) // Like dividing by 2 ** 8.\n        z := shl(4, z) // Like multiplying by 2 ** 4.\n      }\n      if iszero(lt(y, 0x10)) {\n        y := shr(4, y) // Like dividing by 2 ** 4.\n        z := shl(2, z) // Like multiplying by 2 ** 2.\n      }\n      if iszero(lt(y, 0x8)) {\n      // Equivalent to 2 ** z.\n        z := shl(1, z)\n      }\n\n    // Shifting right by 1 is like dividing by 2.\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n\n    // Compute a rounded down version of z.\n      let zRoundDown := div(x, z)\n\n    // If zRoundDown is smaller, use it.\n      if lt(zRoundDown, z) {\n        z := zRoundDown\n      }\n    }\n  }\n\n  /*********************************************\n *              PRB-MATH                      *\n *   https://github.com/hifi-finance/prb-math *\n **********************************************/\n  /// @notice Calculates the binary logarithm of x.\n  ///\n  /// @dev Based on the iterative approximation algorithm.\n  /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n  ///\n  /// Requirements:\n  /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n  ///\n  /// Caveats:\n  /// - The results are nor perfectly accurate to the last decimal,\n  ///   due to the lossy precision of the iterative approximation.\n  ///\n  /// @param x The unsigned 60.18-decimal fixed-point number for which\n  ///           to calculate the binary logarithm.\n  /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n  function log2(uint256 x) internal pure returns (uint256 result) {\n    if (x < 1e18) revert IAppErrors.TooLowX(x);\n\n    // Calculate the integer part of the logarithm\n    // and add it to the result and finally calculate y = x * 2^(-n).\n    uint256 n = mostSignificantBit(x / 1e18);\n\n    // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number.\n    // The operation can't overflow because n is maximum 255 and SCALE is 1e18.\n    uint256 rValue = n * 1e18;\n\n    // This is y = x * 2^(-n).\n    uint256 y = x >> n;\n\n    // If y = 1, the fractional part is zero.\n    if (y == 1e18) {\n      return rValue;\n    }\n\n    // Calculate the fractional part via the iterative approximation.\n    // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n    for (uint256 delta = 5e17; delta > 0; delta >>= 1) {\n      y = (y * y) / 1e18;\n\n      // Is y^2 > 2 and so in the range [2,4)?\n      if (y >= 2 * 1e18) {\n        // Add the 2^(-m) factor to the logarithm.\n        rValue += delta;\n\n        // Corresponds to z/2 on Wikipedia.\n        y >>= 1;\n      }\n    }\n    return rValue;\n  }\n\n  /// @notice Finds the zero-based index of the first one in the binary representation of x.\n  /// @dev See the note on msb in the \"Find First Set\"\n  ///      Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n  /// @param x The uint256 number for which to find the index of the most significant bit.\n  /// @return msb The index of the most significant bit as an uint256.\n  //noinspection NoReturn\n  function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n    if (x >= 2 ** 128) {\n      x >>= 128;\n      msb += 128;\n    }\n    if (x >= 2 ** 64) {\n      x >>= 64;\n      msb += 64;\n    }\n    if (x >= 2 ** 32) {\n      x >>= 32;\n      msb += 32;\n    }\n    if (x >= 2 ** 16) {\n      x >>= 16;\n      msb += 16;\n    }\n    if (x >= 2 ** 8) {\n      x >>= 8;\n      msb += 8;\n    }\n    if (x >= 2 ** 4) {\n      x >>= 4;\n      msb += 4;\n    }\n    if (x >= 2 ** 2) {\n      x >>= 2;\n      msb += 2;\n    }\n    if (x >= 2 ** 1) {\n      // No need to shift x any more.\n      msb += 1;\n    }\n  }\n\n}\n"
    },
    "contracts/lib/ControllerContextLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport {IController} from \"../interfaces/IController.sol\";\nimport {IOracle} from \"../interfaces/IOracle.sol\";\nimport {IStatController} from \"../interfaces/IStatController.sol\";\nimport {IStoryController} from \"../interfaces/IStoryController.sol\";\nimport {ITreasury} from \"../interfaces/ITreasury.sol\";\nimport {IDungeonFactory} from \"../interfaces/IDungeonFactory.sol\";\nimport {IReinforcementController} from \"../interfaces/IReinforcementController.sol\";\nimport {IGameToken} from \"../interfaces/IGameToken.sol\";\nimport {IGOC} from \"../interfaces/IGOC.sol\";\nimport {IItemController} from \"../interfaces/IItemController.sol\";\nimport {IHeroController} from \"../interfaces/IHeroController.sol\";\nimport {IUserController} from \"../interfaces/IUserController.sol\";\nimport {IGuildController} from \"../interfaces/IGuildController.sol\";\n\n/// @notice Provide context-struct with all controller addresses and routines for lazy init\n/// Usage:\n///       Create an instance of the structure\n///               cc = ControllerContextLib.init(controller);\n///       access controller directly\n///               cc.controller.xxx();\n///       access other contracts indirectly\n///               sc = ControllerContextLib.getStatController(cc);\nlibrary ControllerContextLib {\n  struct ControllerContext {\n    IController controller;\n    IStatController statController;\n    IStoryController storyController;\n    IOracle oracle;\n    ITreasury treasury;\n    IDungeonFactory dungeonFactory;\n    IGOC gameObjectController;\n    IReinforcementController reinforcementController;\n    IItemController itemController;\n    IHeroController heroController;\n    IGameToken gameToken;\n    IUserController userController;\n    IGuildController guildController;\n  }\n\n  function init(IController controller) internal pure returns (ControllerContext memory cc) {\n    cc.controller = controller;\n    return cc;\n  }\n\n  function getStatController(ControllerContext memory cc) internal view returns (IStatController statController) {\n    if (address(cc.statController) == address(0)) {\n      cc.statController = IStatController(cc.controller.statController());\n    }\n    return cc.statController;\n  }\n\n  function getStoryController(ControllerContext memory cc) internal view returns (IStoryController storyController) {\n    if (address(cc.storyController) == address(0)) {\n      cc.storyController = IStoryController(cc.controller.storyController());\n    }\n    return cc.storyController;\n  }\n\n  function getOracle(ControllerContext memory cc) internal view returns (IOracle oracle) {\n    if (address(cc.oracle) == address(0)) {\n      cc.oracle = IOracle(cc.controller.oracle());\n    }\n    return cc.oracle;\n  }\n\n  function getTreasury(ControllerContext memory cc) internal view returns (ITreasury treasury) {\n    if (address(cc.treasury) == address(0)) {\n      cc.treasury = ITreasury(cc.controller.treasury());\n    }\n    return cc.treasury;\n  }\n\n  function getDungeonFactory(ControllerContext memory cc) internal view returns (IDungeonFactory dungeonFactory) {\n    if (address(cc.dungeonFactory) == address(0)) {\n      cc.dungeonFactory = IDungeonFactory(cc.controller.dungeonFactory());\n    }\n    return cc.dungeonFactory;\n  }\n\n  function getGameObjectController(ControllerContext memory cc) internal view returns (IGOC gameObjectController) {\n    if (address(cc.gameObjectController) == address(0)) {\n      cc.gameObjectController = IGOC(cc.controller.gameObjectController());\n    }\n    return cc.gameObjectController;\n  }\n\n  function getReinforcementController(ControllerContext memory cc) internal view returns (IReinforcementController reinforcementController) {\n    if (address(cc.reinforcementController) == address(0)) {\n      cc.reinforcementController = IReinforcementController(cc.controller.reinforcementController());\n    }\n    return cc.reinforcementController;\n  }\n\n  function getItemController(ControllerContext memory cc) internal view returns (IItemController itemController) {\n    if (address(cc.itemController) == address(0)) {\n      cc.itemController = IItemController(cc.controller.itemController());\n    }\n    return cc.itemController;\n  }\n\n  function getHeroController(ControllerContext memory cc) internal view returns (IHeroController heroController) {\n    if (address(cc.heroController) == address(0)) {\n      cc.heroController = IHeroController(cc.controller.heroController());\n    }\n    return cc.heroController;\n  }\n\n  function getGameToken(ControllerContext memory cc) internal view returns (IGameToken gameToken) {\n    if (address(cc.gameToken) == address(0)) {\n      cc.gameToken = IGameToken(cc.controller.gameToken());\n    }\n    return cc.gameToken;\n  }\n\n  function getUserController(ControllerContext memory cc) internal view returns (IUserController userController) {\n    if (address(cc.userController) == address(0)) {\n      cc.userController = IUserController(cc.controller.userController());\n    }\n    return cc.userController;\n  }\n\n  function getGuildController(ControllerContext memory cc) internal view returns (IGuildController guildController) {\n    if (address(cc.guildController) == address(0)) {\n      cc.guildController = IGuildController(cc.controller.guildController());\n    }\n    return cc.guildController;\n  }\n}"
    },
    "contracts/lib/ControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\n\nlibrary ControllerLib {\n  //region ------------------------ Constants\n  /// @dev keccak256(abi.encode(uint256(keccak256(\"controller.main\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant CONTROLLER_STORAGE_LOCATION = 0x4d96152d518acf5697a667aeb82f27b3218b679995afa077296a84fdcb65bb00;\n  uint internal constant DEPLOYER_ELIGIBILITY_PERIOD = 7 days;\n  //endregion ------------------------ Constants\n\n  //region ------------------------ Data types\n\n  /// @custom:storage-location erc7201:controller.main\n  struct MainState {\n    address governance;\n    address futureGovernance;\n\n    address statController;\n    address storyController;\n    address oracle;\n    address treasury;\n    address dungeonFactory;\n    address gameObjectController;\n    address reinforcementController;\n    address itemController;\n    address heroController;\n    address gameToken;\n\n    mapping(address => bool) validTreasuryTokens;\n    /// @dev EOA => eligibility time. We assume that deployer is fresh EOA and will be changed every deploy cycle for security reasons.\n    mapping(address => uint) deployers;\n    /// @dev In emergency case governance can pause all game\n    bool onPause;\n\n    address userController;\n    address guildController;\n  }\n  //endregion ------------------------ Data types\n\n  //region ------------------------ Restrictions\n\n  function onlyGovernance() internal view {\n    if (!_isGovernance(msg.sender)) revert IAppErrors.NotGovernance(msg.sender);\n  }\n\n  function onlyDeployer() internal view {\n    if (!isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\n  }\n  //endregion ------------------------ Restrictions\n\n  //region ------------------------ Views\n\n  function _S() internal pure returns (MainState storage s) {\n    assembly {\n      s.slot := CONTROLLER_STORAGE_LOCATION\n    }\n    return s;\n  }\n\n  function isDeployer(address adr) internal view returns (bool) {\n    uint t = _S().deployers[adr];\n    return (t != 0 && block.timestamp < t) || _isGovernance(adr);\n  }\n\n  function governance() internal view returns (address) {return _S().governance;}\n\n  function futureGovernance() internal view returns (address) {return _S().futureGovernance;}\n\n  function statController() internal view returns (address) {return _S().statController;}\n\n  function storyController() internal view returns (address) {return _S().storyController;}\n\n  function oracle() internal view returns (address) {return _S().oracle;}\n\n  function treasury() internal view returns (address) {return _S().treasury;}\n\n  function dungeonFactory() internal view returns (address) {return _S().dungeonFactory;}\n\n  function gameObjectController() internal view returns (address) {return _S().gameObjectController;}\n\n  function reinforcementController() internal view returns (address) {return _S().reinforcementController;}\n\n  function itemController() internal view returns (address) {return _S().itemController;}\n\n  function heroController() internal view returns (address) {return _S().heroController;}\n\n  function gameToken() internal view returns (address) {return _S().gameToken;}\n\n  function validTreasuryTokens(address token) internal view returns (bool) {\n    return _S().validTreasuryTokens[token];\n  }\n\n  function onPause() internal view returns (bool) {return _S().onPause;}\n\n  function userController() internal view returns (address) {return _S().userController;}\n  function guildController() internal view returns (address) {return _S().guildController;}\n  //endregion ------------------------ Views\n\n  //region ------------------------ Gov actions - setters\n\n  function changePause(bool value) internal {\n    onlyDeployer();\n    _S().onPause = value;\n  }\n\n  function offerGovernance(address newGov) internal {\n    onlyGovernance();\n    _S().futureGovernance = newGov;\n    emit IApplicationEvents.OfferGovernance(newGov);\n  }\n\n  function acceptGovernance() internal {\n    if (_S().futureGovernance != msg.sender) revert IAppErrors.NotFutureGovernance(msg.sender);\n    _S().governance = msg.sender;\n    delete _S().futureGovernance;\n    emit IApplicationEvents.GovernanceAccepted(msg.sender);\n  }\n\n  function setStatController(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().statController = value;\n    emit IApplicationEvents.StatControllerChanged(value);\n  }\n\n  function setStoryController(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().storyController = value;\n    emit IApplicationEvents.StoryControllerChanged(value);\n  }\n\n  function setGameObjectController(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().gameObjectController = value;\n    emit IApplicationEvents.GameObjectControllerChanged(value);\n  }\n\n  function setReinforcementController(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().reinforcementController = value;\n    emit IApplicationEvents.ReinforcementControllerChanged(value);\n  }\n\n  function setOracle(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().oracle = value;\n    emit IApplicationEvents.OracleChanged(value);\n  }\n\n  function setTreasury(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().treasury = value;\n    emit IApplicationEvents.TreasuryChanged(value);\n  }\n\n  function setItemController(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().itemController = value;\n    emit IApplicationEvents.ItemControllerChanged(value);\n  }\n\n  function setHeroController(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().heroController = value;\n    emit IApplicationEvents.HeroControllerChanged(value);\n  }\n\n  function setGameToken(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().gameToken = value;\n    emit IApplicationEvents.GameTokenChanged(value);\n  }\n\n  function setDungeonFactory(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().dungeonFactory = value;\n    emit IApplicationEvents.DungeonFactoryChanged(value);\n  }\n\n  function changeDeployer(address eoa, bool remove) internal {\n    onlyGovernance();\n    if (remove) {\n      delete _S().deployers[eoa];\n    } else {\n      _S().deployers[eoa] = block.timestamp + DEPLOYER_ELIGIBILITY_PERIOD;\n    }\n  }\n\n  function setUserController(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().userController = value;\n    emit IApplicationEvents.UserControllerChanged(value);\n  }\n\n  function setGuildController(address value) internal {\n    onlyGovernance();\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    _S().guildController = value;\n    emit IApplicationEvents.GuildControllerChanged(value);\n  }\n  //endregion ------------------------ Gov actions - setters\n\n  //region ------------------------ Gov actions - others\n\n  function updateProxies(address[] memory proxies, address newLogic) internal {\n    onlyDeployer();\n    for (uint i; i < proxies.length; i++) {\n      IProxyControlled(proxies[i]).upgrade(newLogic);\n      emit IApplicationEvents.ProxyUpdated(proxies[i], newLogic);\n    }\n  }\n\n  function claimToGovernance(address token) internal {\n    onlyGovernance();\n    uint amount = IERC20(token).balanceOf(address(this));\n    if (amount != 0) {\n      IERC20(token).transfer(_S().governance, amount);\n      emit IApplicationEvents.Claimed(token, amount);\n    }\n  }\n  //endregion ------------------------ Gov actions - others\n\n  //region ------------------------ REGISTER ACTIONS\n\n  function changeTreasuryTokenStatus(address token, bool status) internal {\n    onlyGovernance();\n    _S().validTreasuryTokens[token] = status;\n    emit IApplicationEvents.TokenStatusChanged(token, status);\n  }\n  //endregion ------------------------ REGISTER ACTIONS\n\n  //region ------------------------  Internal logic\n  function _isGovernance(address _value) internal view returns (bool) {\n    return IController(address(this)).governance() == _value;\n  }\n  //endregion ------------------------  Internal logic\n}\n"
    },
    "contracts/lib/DungeonFactoryLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IStatController.sol\";\nimport \"../interfaces/IDungeonFactory.sol\";\nimport \"../interfaces/IGameToken.sol\";\nimport \"../interfaces/IMinter.sol\";\nimport \"../interfaces/IReinforcementController.sol\";\nimport \"../interfaces/IGOC.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../proxy/Controllable.sol\";\nimport \"../lib/StringLib.sol\";\nimport \"../lib/DungeonLib.sol\";\nimport \"../relay/ERC2771Context.sol\";\nimport \"../lib/ControllerContextLib.sol\";\n\nlibrary DungeonFactoryLib {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n  using PackingLib for bytes32;\n  using PackingLib for uint16;\n  using PackingLib for uint8;\n  using PackingLib for address;\n  using PackingLib for uint32[];\n  using PackingLib for uint32;\n  using PackingLib for uint64;\n  using PackingLib for int32[];\n  using PackingLib for int32;\n\n  //region ------------------------ Data types\n  struct ObjectActionLocal {\n    bool isCompleted;\n    bool needClear;\n    uint32 currentObjectId;\n    uint32 newCurrentObjectId;\n    uint newCurrentStage;\n  }\n\n  //endregion ------------------------ Data types\n\n  //region ------------------------ RESTRICTIONS\n\n  function onlyDeployer(IController controller) internal view {\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\n  }\n\n  function _onlyEoa(bool isEoa) internal pure {\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\n  }\n\n  function onlyHeroController(IController controller) internal view {\n    if (IController(controller).heroController() != msg.sender) revert IAppErrors.ErrorNotHeroController(msg.sender);\n  }\n\n  function _checkOwnerRegisteredNotPaused(\n    address heroToken,\n    uint heroTokenId,\n    address msgSender,\n    ControllerContextLib.ControllerContext memory cc\n  ) internal view {\n    if (IERC721(heroToken).ownerOf(heroTokenId) != msgSender) revert IAppErrors.ErrorNotHeroOwner(heroToken, msgSender);\n    if (ControllerContextLib.getHeroController(cc).heroClass(heroToken) == 0) revert IAppErrors.ErrorHeroIsNotRegistered(heroToken);\n    if (cc.controller.onPause()) revert IAppErrors.ErrorPaused();\n  }\n\n  //endregion ------------------------ RESTRICTIONS\n\n  //region ------------------------ VIEWS\n  function _S() internal pure returns (IDungeonFactory.MainState storage s) {\n    return DungeonLib._S();\n  }\n\n  function dungeonAttributes(uint16 dungNum) internal view returns (IDungeonFactory.DungeonAttributes memory) {\n    return _S().dungeonAttributes[dungNum];\n  }\n\n  function dungeonStatus(uint64 dungeonId) internal view returns (\n    uint16 dungNum,\n    bool isCompleted,\n    address heroToken,\n    uint heroTokenId,\n    uint32 currentObject,\n    uint8 currentStage,\n    address[] memory treasuryTokens_,\n    uint[] memory treasuryTokensAmounts_,\n    bytes32[] memory treasuryItems,\n    uint8 stages,\n    uint32[] memory uniqObjects\n  ) {\n    IDungeonFactory.DungeonStatus storage dungStatus = _S().dungeonStatuses[dungeonId];\n\n    dungNum = dungStatus.dungNum;\n    isCompleted = dungStatus.isCompleted;\n    heroToken = dungStatus.heroToken;\n    heroTokenId = dungStatus.heroTokenId;\n    currentObject = dungStatus.currentObject;\n    currentStage = dungStatus.currentStage;\n    treasuryItems = dungStatus.treasuryItems;\n    stages = dungStatus.stages;\n    uniqObjects = dungStatus.uniqObjects;\n\n    uint tokensLength = dungStatus.treasuryTokens.length();\n\n    treasuryTokens_ = new address[](tokensLength);\n    treasuryTokensAmounts_ = new uint[](tokensLength);\n\n    for (uint i; i < tokensLength; ++i) {\n      (treasuryTokens_[i], treasuryTokensAmounts_[i]) = dungStatus.treasuryTokens.at(i);\n    }\n  }\n\n  function dungeonCounter() internal view returns (uint64) {\n    return _S().dungeonCounter;\n  }\n\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) internal view returns (uint8) {\n    return _S().maxBiomeCompleted[heroToken.packNftId(heroTokenId)];\n  }\n\n  function currentDungeon(address heroToken, uint heroTokenId) internal view returns (uint64) {\n    return _S().heroCurrentDungeon[heroToken.packNftId(heroTokenId)];\n  }\n\n  function minLevelForTreasury(address token) internal view returns (uint) {\n    return _S().minLevelForTreasury[token];\n  }\n\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) internal view returns (\n    uint8[] memory result\n  ) {\n    return _S().skillSlotsForDurabilityReduction[heroToken.packNftId(heroTokenId)].unpackUint8Array();\n  }\n\n  /// @return Length of the items in freeDungeons map for the given {biome}\n  function freeDungeonsByLevelLength(uint biome) internal view returns (uint) {\n    return _S().freeDungeons[biome].length();\n  }\n\n  /// @param index Index of the free dungeon inside freeDungeons map\n  /// @return dungeonId\n  function freeDungeonsByLevel(uint index, uint biome) internal view returns (uint64) {\n    return uint64(_S().freeDungeons[biome].at(index));\n  }\n\n  function getDungeonTreasuryAmount(IController controller, address token, uint heroLevel, uint biome)\n  internal view returns (\n    uint totalAmount,\n    uint amountForDungeon,\n    uint mintAmount\n  ) {\n    totalAmount = ITreasury(controller.treasury()).balanceOfToken(token);\n    mintAmount = IMinter(IGameToken(controller.gameToken()).minter()).amountForDungeon(biome, heroLevel);\n    amountForDungeon = DungeonLib.dungeonTreasuryReward(\n      token,\n      uint(_S().maxBiome),\n      totalAmount,\n      uint8(heroLevel),\n      uint8(biome)\n    );\n  }\n\n  /// @notice Check if biome boss completed by the hero.\n  /// @dev isBiomeBossCompleted would be more correct title, but isBiomeBoss is already used\n  function isBiomeBoss(IController controller, address heroToken, uint heroTokenId)\n  internal view returns (bool) {\n    uint8 heroBiome = IHeroController(controller.heroController()).heroBiome(heroToken, heroTokenId);\n    return _S().bossCompleted[heroToken.packMapObject(uint64(heroTokenId), heroBiome)];\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ ACTIONS\n  function launch(\n    bool isEoa,\n    IController controller,\n    address msgSender,\n    address heroToken,\n    uint heroTokenId,\n    address treasuryToken\n  ) external returns (uint64 dungeonId) {\n    _onlyEoa(isEoa);\n    return _launch(controller, msgSender, heroToken, heroTokenId, treasuryToken);\n  }\n\n  function launchForNewHero(\n    IController controller,\n    address msgSender,\n    address heroToken,\n    uint heroTokenId\n  ) external returns (uint64 dungeonId) {\n    onlyHeroController(controller);\n    return _launch(controller, msgSender, heroToken, heroTokenId, controller.gameToken());\n  }\n\n  /// @notice Create new dungeon and enter to it. Treasury reward is sent by treasury to the dungeon.\n  function _launch(\n    IController controller,\n    address msgSender,\n    address heroToken,\n    uint heroTokenId,\n    address treasuryToken\n  ) internal returns (uint64 dungeonId) {\n    IDungeonFactory.MainState storage s = _S();\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\n\n    // check part of restrictions; other part is checked inside DungeonLib._enter\n    _checkOwnerRegisteredNotPaused(heroToken, heroTokenId, msgSender, cc);\n    if (!controller.validTreasuryTokens(treasuryToken)) revert IAppErrors.ErrorNotValidTreasureToken(treasuryToken);\n\n    // select a logic for new dungeon\n    uint8 heroLevel = uint8(ControllerContextLib.getStatController(cc).heroStats(heroToken, heroTokenId).level);\n    uint16 dungNum = DungeonLib.getDungeonLogic(\n      s,\n      cc,\n      heroLevel,\n      heroToken,\n      heroTokenId,\n      ControllerContextLib.getOracle(cc).getRandomNumber(1e18, heroLevel)\n    );\n\n    // register new dungeon\n    dungeonId = s.dungeonCounter + 1;\n    s.dungeonCounter = dungeonId;\n\n    IDungeonFactory.DungeonAttributes storage dungAttr = s.dungeonAttributes[dungNum];\n    IDungeonFactory.DungeonStatus storage dungStatus = s.dungeonStatuses[dungeonId];\n\n    if (dungStatus.isCompleted) revert IAppErrors.ErrorDungeonCompleted();\n\n    dungStatus.dungeonId = dungeonId;\n    dungStatus.dungNum = dungNum;\n    dungStatus.stages = dungAttr.stages;\n    dungStatus.uniqObjects = dungAttr.uniqObjects;\n\n    emit IApplicationEvents.DungeonRegistered(dungNum, dungeonId);\n\n    // enter to the dungeon\n    DungeonLib._enter(cc, dungStatus, dungAttr, dungNum, dungeonId, heroToken, heroTokenId);\n\n    // when entered, open the first object for reduce txs\n    _openObject(cc, msgSender, dungeonId);\n\n    // send treasury to the dungeon\n    uint treasuryAmount = DungeonLib.dungeonTreasuryReward(\n      treasuryToken,\n      uint(_S().maxBiome),\n      ControllerContextLib.getTreasury(cc).balanceOfToken(treasuryToken),\n      heroLevel,\n      dungAttr.biome\n    );\n\n    if (treasuryAmount != 0) {\n      ControllerContextLib.getTreasury(cc).sendToDungeon(address(this), treasuryToken, treasuryAmount);\n      DungeonLib._registerTreasuryToken(treasuryToken, s.dungeonStatuses[dungeonId].treasuryTokens, treasuryAmount);\n    }\n\n    emit IApplicationEvents.DungeonLaunched(dungNum, dungeonId, heroToken, heroTokenId, treasuryToken, treasuryAmount);\n  }\n\n  /// @notice Set boss completed for the given hero and given biome.\n  /// @dev Set custom data for the hero: BOSS_COMPLETED_ = 1\n  function setBossCompleted(IController controller, uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) internal {\n    if (controller.gameObjectController() != msg.sender) revert IAppErrors.ErrorNotGoc();\n\n    IDungeonFactory.MainState storage s = _S();\n\n    if (!s.bossCompleted[heroToken.packMapObject(uint64(heroTokenId), heroBiome)]) {\n      s.bossCompleted[heroToken.packMapObject(uint64(heroTokenId), heroBiome)] = true;\n    }\n\n    if (s.maxBiomeCompleted[heroToken.packNftId(heroTokenId)] < heroBiome) {\n      s.maxBiomeCompleted[heroToken.packNftId(heroTokenId)] = heroBiome;\n    }\n\n    bytes32 index = _getBossCompletedIndex(heroBiome);\n    IStatController(controller.statController()).setHeroCustomData(heroToken, heroTokenId, index, 1);\n\n    emit IApplicationEvents.BossCompleted(objectId, heroBiome, heroToken, heroTokenId);\n  }\n  //endregion ------------------------ ACTIONS\n\n  //region ------------------------ DUNGEON LOGIC - GOV ACTIONS\n\n  /// @notice Register ordinal or specific dungeon\n  /// @dev can be called for exist dungeon - will rewrite dungeon data\n  /// @param dungNum Dungeon logic id\n  /// @param biome Assume biome > 0\n  /// @param isSpecific The dungeon is specific, so it shouldn't be registered in dungeonsLogicByBiome\n  function registerDungeonLogic(\n    IController controller,\n    uint16 dungNum,\n    uint8 biome,\n    IDungeonFactory.DungeonGenerateInfo calldata genInfo,\n    uint8 specReqBiome,\n    uint8 specReqHeroClass,\n    bool isSpecific\n  ) internal {\n    onlyDeployer(controller);\n    IDungeonFactory.MainState storage s = _S();\n\n    uint len = genInfo.objChancesByStages.length;\n    if (len != genInfo.objTypesByStages.length || len != genInfo.uniqObjects.length) revert IAppErrors.ErrorNotStages();\n\n    for (uint i; i < len; ++i) {\n      if (genInfo.objChancesByStages[i].length != genInfo.objTypesByStages[i].length) revert IAppErrors.ErrorNotChances();\n    }\n\n    IDungeonFactory.DungeonAttributes storage info = s.dungeonAttributes[dungNum];\n\n    if (biome > s.maxBiome) {\n      s.maxBiome = biome;\n    }\n\n    info.stages = uint8(len); // info.stages can be increased later by chamber story\n    info.biome = biome;\n\n    info.uniqObjects = genInfo.uniqObjects;\n    info.minMaxLevel = DungeonLib._toUint8PackedArray(genInfo.minLevel, genInfo.maxLevel);\n\n    info.requiredCustomDataIndex = genInfo.requiredCustomDataIndex;\n    bytes32[] storage requiredCustomDataValue = info.requiredCustomDataValue;\n\n    for (uint i; i < genInfo.requiredCustomDataMinValue.length; ++i) {\n      requiredCustomDataValue.push(\n        PackingLib.packCustomDataRequirements(\n          genInfo.requiredCustomDataMinValue[i],\n          genInfo.requiredCustomDataMaxValue[i],\n          genInfo.requiredCustomDataIsHero[i]\n        )\n      );\n    }\n\n    for (uint i; i < len; ++i) {\n      info.info.objTypesByStages.push(PackingLib.packUint8Array(genInfo.objTypesByStages[i]));\n      info.info.objChancesByStages.push(genInfo.objChancesByStages[i]);\n    }\n\n    if (isSpecific) {\n      bytes32 packedId = DungeonLib._toUint8PackedArray(specReqBiome, specReqHeroClass);\n      if (s.dungeonSpecific[packedId] != 0) revert IAppErrors.DungeonAlreadySpecific(dungNum);\n      s.dungeonSpecific[packedId] = dungNum;\n\n      if (s.allSpecificDungeons.contains(dungNum)) revert IAppErrors.DungeonAlreadySpecific2(dungNum);\n\n      s.allSpecificDungeons.add(dungNum);\n\n      emit IApplicationEvents.DungeonSpecificLogicRegistered(dungNum, specReqBiome, specReqHeroClass);\n    } else {\n      s.dungeonsLogicByBiome[info.biome].add(dungNum);\n    }\n\n    emit IApplicationEvents.DungeonLogicRegistered(dungNum, genInfo);\n  }\n\n  /// @dev Remove the dungeon logic (both ordinal and specific logics are supported)\n  /// @param dungNum Dungeon logic id\n  function removeDungeonLogic(IController controller, uint16 dungNum, uint8 specReqBiome, uint8 specReqHeroClass) internal {\n    onlyDeployer(controller);\n    IDungeonFactory.MainState storage s = _S();\n\n    uint8 biome = s.dungeonAttributes[dungNum].biome;\n    delete s.dungeonAttributes[dungNum];\n\n    if (s.dungeonsLogicByBiome[biome].contains(dungNum)) {\n      s.dungeonsLogicByBiome[biome].remove(dungNum);\n      emit IApplicationEvents.DungeonLogicRemoved(dungNum);\n    }\n\n    if (s.allSpecificDungeons.contains(dungNum)) {\n      bytes32 packedId = DungeonLib._toUint8PackedArray(specReqBiome, specReqHeroClass);\n      if (s.dungeonSpecific[packedId] != dungNum) revert IAppErrors.WrongSpecificDungeon();\n\n      delete s.dungeonSpecific[packedId];\n      s.allSpecificDungeons.remove(dungNum);\n      emit IApplicationEvents.DungeonSpecificLogicRemoved(dungNum, specReqBiome, specReqHeroClass);\n    }\n  }\n\n  /// @dev Set eligible hero level for treasury tokens\n  function setMinLevelForTreasury(IController controller, address token, uint heroLevel) internal {\n    onlyDeployer(controller);\n\n    if (heroLevel < DungeonLib.MIN_LEVEL_FOR_TREASURY_DEFAULT) {\n      revert IAppErrors.ErrorLevelTooLow(heroLevel);\n    }\n\n    _S().minLevelForTreasury[token] = heroLevel;\n    emit IApplicationEvents.MinLevelForTreasuryChanged(token, heroLevel);\n  }\n\n  /// @dev Governance can drop hero from dungeon in emergency case\n  function emergencyExit(IController controller, uint64 dungId) internal {\n    onlyDeployer(controller);\n    DungeonLib.emergencyExit(controller, dungId);\n  }\n  //endregion ------------------------ DUNGEON LOGIC - GOV ACTIONS\n\n  //region ------------------------ DUNGEON LOGIC - USER ACTIONS\n\n  /// @notice Enter to the exist dungeon\n  function enter(bool isEoa, IController controller, address msgSender, uint64 dungId, address heroToken, uint heroTokenId) external {\n    IDungeonFactory.MainState storage s = _S();\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\n    IDungeonFactory.DungeonStatus storage dungStatus = s.dungeonStatuses[dungId];\n\n    // check part of restrictions; other part is checked inside DungeonLib._enter\n    _onlyEoa(isEoa);\n    _checkOwnerRegisteredNotPaused(heroToken, heroTokenId, msgSender, cc);\n    if (dungStatus.isCompleted) revert IAppErrors.ErrorDungeonCompleted();\n\n    // enter to the dungeon\n    uint16 dungNum = dungStatus.dungNum;\n    DungeonLib._enter(cc, dungStatus, s.dungeonAttributes[dungNum], dungNum, dungId, heroToken, heroTokenId);\n\n    // when entered, open the first object for reduce txs\n    _openObject(cc, msgSender, dungId);\n  }\n\n  function openObject(bool isEoa, IController controller, address msgSender, uint64 dungId) internal {\n    _onlyEoa(isEoa);\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\n    _openObject(cc, msgSender, dungId);\n  }\n\n  /// @notice Set new current object for the dungeon\n  function _openObject(ControllerContextLib.ControllerContext memory cc, address msgSender, uint64 dungId) internal {\n    IDungeonFactory.MainState storage s = _S();\n    IDungeonFactory.DungeonStatus storage dungStatus = s.dungeonStatuses[dungId];\n    IDungeonFactory.DungeonAttributes storage dungAttributes = s.dungeonAttributes[dungStatus.dungNum];\n\n    IGOC goc = ControllerContextLib.getGameObjectController(cc);\n\n    // check restrictions\n    if (dungStatus.currentObject != 0) revert IAppErrors.ErrorNotReady();\n    (address dungHero, uint dungHeroId) = _checkCurrentHero(dungStatus, msgSender, cc);\n\n    // select new object and set it as current object in the dungeon\n    uint currentStage = dungStatus.currentStage;\n    uint32 objectId = _generateObject(dungAttributes, dungStatus, currentStage, goc, dungHero, dungHeroId);\n    if (objectId == 0) revert IAppErrors.ErrorNotObject1();\n    dungStatus.currentObject = objectId;\n\n    // generate some info for UI\n    uint iteration = goc.open(dungHero, dungHeroId, objectId);\n    emit IApplicationEvents.ObjectOpened(dungId, dungHero, dungHeroId, objectId, iteration, currentStage);\n  }\n\n  /// @notice Do action and handle results\n  /// @param data AttackInfo struct encoded using abi.encode\n  function objectAction(bool isEoa, IController controller, address msgSender, uint64 dungId, bytes memory data) internal {\n    IDungeonFactory.MainState storage s = _S();\n\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\n    ObjectActionLocal memory v;\n\n    IDungeonFactory.DungeonStatus storage dungStatus = s.dungeonStatuses[dungId];\n    IDungeonFactory.DungeonAttributes storage dungAttributes = s.dungeonAttributes[dungStatus.dungNum];\n\n    // check restrictions, some restrictions are checked inside objectAction\n    _onlyEoa(isEoa);\n    _checkCurrentHero(dungStatus, msgSender, cc);\n\n    v.currentObjectId = dungStatus.currentObject;\n\n    (v.isCompleted, v.newCurrentStage, v.newCurrentObjectId, v.needClear) = DungeonLib.objectAction(\n      dungStatus,\n      dungAttributes,\n      dungId,\n      msgSender,\n      data,\n      controller, // we pass controller, not cc, because objectAction is external\n      v.currentObjectId\n    );\n\n    if (v.isCompleted) {\n      dungStatus.isCompleted = true;\n    }\n\n    if (v.newCurrentStage != 0) {\n      dungStatus.currentStage = uint8(v.newCurrentStage);\n    }\n\n    if (v.newCurrentObjectId != v.currentObjectId) {\n      dungStatus.currentObject = v.newCurrentObjectId;\n    }\n\n    if (v.needClear) {\n      _clear(dungStatus, dungAttributes.biome, dungId);\n    }\n\n    // if dungeon is not ended and current object is empty we can open next object for reduce users transactions\n    if (!v.isCompleted && dungStatus.currentObject == 0 && !v.needClear) {\n      _openObject(cc, msgSender, dungId);\n    }\n  }\n\n  /// @notice Exit from completed dungeon\n  function exit(bool isEoa, IController controller, address msgSender, uint64 dungId, bool claim) internal {\n    _onlyEoa(isEoa);\n    DungeonLib.exitDungeon(controller, dungId, claim, msgSender);\n  }\n  //endregion ------------------------ DUNGEON LOGIC - USER ACTIONS\n\n  //region ------------------------ DUNGEON LOGIC - INTERNAL LOGIC\n\n  /// @notice Generate object for the current stage\n  /// @return objectId Either uniqObj or randomly generated object if uniqObj is not specified for the stage\n  function _generateObject(\n    IDungeonFactory.DungeonAttributes storage dungAttributes,\n    IDungeonFactory.DungeonStatus storage dungStatus,\n    uint currentStage,\n    IGOC goc,\n    address heroToken,\n    uint heroTokenId\n  ) internal returns (uint32 objectId) {\n    if (currentStage >= dungStatus.stages) revert IAppErrors.ErrorWrongStage(currentStage);\n\n    objectId = dungStatus.uniqObjects[currentStage];\n    if (objectId == 0) {\n      IDungeonFactory.ObjectGenerateInfo memory info = dungAttributes.info;\n      objectId = goc.getRandomObject(\n        DungeonLib._toUint8ArrayWithoutZeroes(info.objTypesByStages[currentStage]),\n        info.objChancesByStages[currentStage],\n        dungAttributes.biome,\n        heroToken,\n        heroTokenId\n      );\n    }\n  }\n\n  /// @notice Clear hero info in dungeon status, add dungeon to the list of free dungeons\n  function _clear(IDungeonFactory.DungeonStatus storage dungStatus, uint8 biome, uint64 dungId) internal {\n    delete dungStatus.heroToken;\n    delete dungStatus.heroTokenId;\n    delete dungStatus.currentObject;\n    delete dungStatus.currentStage;\n    _addFreeDungeon(biome, dungId);\n    emit IApplicationEvents.Clear(dungId);\n  }\n\n  /// @notice Check: hero is registered, not dead, in the dungeon, sender is the owner, the dungeon is not completed,\n  /// controller is not paused\n  /// @return heroToken Token of the hero who is in the dungeon\n  /// @return heroTokenId Token ID of the hero who is in the dungeon\n  function _checkCurrentHero(\n    IDungeonFactory.DungeonStatus storage dungStatus,\n    address msgSender,\n    ControllerContextLib.ControllerContext memory cc\n  ) internal view returns (address heroToken, uint heroTokenId) {\n\n    heroToken = dungStatus.heroToken;\n    heroTokenId = dungStatus.heroTokenId;\n\n    if (dungStatus.isCompleted) revert IAppErrors.ErrorDungeonCompleted();\n    _checkOwnerRegisteredNotPaused(heroToken, heroTokenId, msgSender, cc);\n\n    if (!ControllerContextLib.getStatController(cc).isHeroAlive(heroToken, heroTokenId)) revert IAppErrors.ErrorHeroIsDead(heroToken, heroTokenId);\n    if (currentDungeon(heroToken, heroTokenId) != dungStatus.dungeonId) revert IAppErrors.ErrorHeroNotInDungeon();\n  }\n\n  /// @notice Add the {dungeonId} to the list of free dungeons (available to pass) of the given {biome}\n  function _addFreeDungeon(uint8 biome, uint64 dungeonId) internal {\n    if (!_S().freeDungeons[biome].add(dungeonId)) revert IAppErrors.ErrorDungeonIsFreeAlready();\n    emit IApplicationEvents.FreeDungeonAdded(biome, dungeonId);\n  }\n  //endregion ------------------------ DUNGEON LOGIC - INTERNAL LOGIC\n\n  //region ------------------------ Utils\n  /// @dev We need separate utility function for tests\n  function _getBossCompletedIndex(uint8 heroBiome) internal pure returns (bytes32) {\n    return bytes32(abi.encodePacked(\"BOSS_COMPLETED_\", StringLib._toString(heroBiome)));\n  }\n  //endregion ------------------------ Utils\n\n}\n"
    },
    "contracts/lib/DungeonLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IDungeonFactory.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IFightCalculator.sol\";\nimport \"../interfaces/IGOC.sol\";\nimport \"../interfaces/IGameToken.sol\";\nimport \"../interfaces/IHeroController.sol\";\nimport \"../interfaces/IItemController.sol\";\nimport \"../interfaces/IMinter.sol\";\nimport \"../interfaces/IReinforcementController.sol\";\nimport \"../interfaces/IStatController.sol\";\nimport \"../interfaces/IStoryController.sol\";\nimport \"../interfaces/IUserController.sol\";\nimport \"../openzeppelin/EnumerableMap.sol\";\nimport \"./CalcLib.sol\";\nimport \"./ControllerContextLib.sol\";\nimport \"./PackingLib.sol\";\nimport \"./StatControllerLib.sol\";\nimport \"./StatLib.sol\";\n\nlibrary DungeonLib {\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using CalcLib for int32;\n  using PackingLib for bytes32;\n  using PackingLib for uint16;\n  using PackingLib for uint8;\n  using PackingLib for address;\n  using PackingLib for uint8[];\n  using PackingLib for uint32[];\n  using PackingLib for uint32;\n  using PackingLib for uint64;\n  using PackingLib for int32[];\n  using PackingLib for int32;\n\n  /// @dev keccak256(abi.encode(uint256(keccak256(\"dungeon.factory.main\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant DUNGEON_FACTORY_STORAGE_LOCATION = 0xae5971282b317bbed599861775fe0712755bb3b2f655bfe8fb14280d8429f600;\n\n  /// @notice Treasure reward is available starting from level 5. We need some initial gap as protection against bots\n  uint public constant MIN_LEVEL_FOR_TREASURY_DEFAULT = 5;\n\n  /// @notice Max possible default minLevelForTreasury (= 95)\n  uint internal constant MAX_NIM_LEVEL_FOR_TREASURE = StatLib.MAX_LEVEL - StatLib.BIOME_LEVEL_STEP + 1;\n\n  //region ------------------------ Data types\n\n  struct ObjectActionInternalData {\n    address msgSender;\n    address heroToken;\n    IStatController statController;\n    bytes data;\n    uint stages;\n    uint biome;\n    uint heroTokenId;\n    uint64 dungId;\n    uint32 objectId;\n    uint8 currentStage;\n    bool isBattleObj;\n    IGOC.ActionResult result;\n    IStatController.ChangeableStats stats;\n  }\n\n  /// @notice Lazy initialization data for _claimAll\n  struct ClaimContext {\n    address helpHeroToken;\n    address heroPayToken;\n    address msgSender;\n    address[] tokens;\n    uint64 dungId;\n    uint helpHeroId;\n\n    /// @dev Limited by ReinforcementController._TO_HELPER_RATIO_MAX\n    uint toHelperRatio;\n    uint itemLength;\n    uint tokenLength;\n    uint[] amounts;\n  }\n  //endregion ------------------------ Data types\n\n  //region ------------------------ Common\n\n  function _S() internal pure returns (IDungeonFactory.MainState storage s) {\n    assembly {\n      s.slot := DUNGEON_FACTORY_STORAGE_LOCATION\n    }\n    return s;\n  }\n\n  /// @notice Calculate amount of treasure reward that a hero can count on\n  /// @param token Treasury token\n  /// @param maxAvailableBiome Max deployed biome\n  /// @param treasuryBalance Total treasury of the dungeon\n  /// @param heroLevel Current level of the hero\n  /// @param dungeonBiome Biome to which the dungeon belongs\n  function dungeonTreasuryReward(\n    address token,\n    uint maxAvailableBiome,\n    uint treasuryBalance,\n    uint heroLevel,\n    uint dungeonBiome\n  ) internal view returns (uint) {\n    if (dungeonBiome < maxAvailableBiome) {\n      return 0;\n    }\n\n    uint customMinLevel = _S().minLevelForTreasury[token];\n    if (customMinLevel != 0 && heroLevel < customMinLevel) {\n      return 0;\n    }\n\n    if (heroLevel > StatLib.MAX_LEVEL) revert IAppErrors.ErrorWrongLevel(heroLevel);\n    if (dungeonBiome > StatLib.MAX_POSSIBLE_BIOME) revert IAppErrors.ErrorIncorrectBiome(dungeonBiome);\n\n    uint biomeLevel = dungeonBiome * StatLib.BIOME_LEVEL_STEP;\n\n    // CalcLib.log2((StatLib.MAX_LEVEL + 1) * 1e18);\n    uint maxMultiplier = 6643856189774724682;\n    uint multiplier = (maxMultiplier - CalcLib.log2((StatLib.MAX_LEVEL - biomeLevel + 1) * 1e18)) / 100;\n    if (multiplier >= 1e18) revert IAppErrors.ErrorWrongMultiplier(multiplier);\n    uint base = treasuryBalance * multiplier / 1e18;\n\n    if (biomeLevel < heroLevel) {\n      // reduce base on biome difference\n      base = base / 2 ** (heroLevel - biomeLevel);\n    }\n    return base;\n  }\n  //endregion ------------------------ Common\n\n  //region ------------------------ Main logic\n\n  /// @notice Make an action with object, update hero params according results\n  function objectAction(\n    IDungeonFactory.DungeonStatus storage dungStatus,\n    IDungeonFactory.DungeonAttributes storage dungAttributes,\n    uint64 dungId,\n    address msgSender,\n    bytes memory data,\n    IController controller,\n    uint32 currentObject_\n  ) external returns (\n    bool isCompleted,\n    uint currentStage,\n    uint32 currentObject,\n    bool clear\n  ) {\n    IGOC.ActionResult memory a;\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\n    return _objectAction(\n      ObjectActionInternalData({\n        dungId: dungId,\n        msgSender: msgSender,\n        data: data,\n        heroToken: dungStatus.heroToken,\n        heroTokenId: dungStatus.heroTokenId,\n        objectId: currentObject_,\n        currentStage: dungStatus.currentStage,\n        biome: uint(dungAttributes.biome),\n        statController: ControllerContextLib.getStatController(cc),\n        result: a,\n        stats: IStatController.ChangeableStats(0, 0, 0, 0, 0),\n        stages: uint(dungStatus.stages),\n        isBattleObj: false\n      }),\n      dungStatus,\n      dungAttributes,\n      cc\n    );\n  }\n\n  /// @notice Make an action with object, update hero params according results\n  /// @param c Context\n  /// @return isCompleted The dungeon is completed (there is no new stage to pass)\n  /// @return newStage Next stage (0 if the dungeon is completed)\n  /// @return currentObject Id of the current object. It's always 0 if new stage is selected (new object is not opened)\n  /// @return clear True if dungStatus of the hero should be cleared and the dungeon should be added to free dungeon list\n  function _objectAction(\n    ObjectActionInternalData memory c,\n    IDungeonFactory.DungeonStatus storage dungStatus,\n    IDungeonFactory.DungeonAttributes storage dungAttributes,\n    ControllerContextLib.ControllerContext memory cc\n  ) internal returns (\n    bool isCompleted,\n    uint newStage,\n    uint32 currentObject,\n    bool clear\n  ) {\n    // isCompleted = false;\n    currentObject = c.objectId;\n    // newStage = 0;\n\n    // check restrictions, most of them are checked by the caller\n    if (c.objectId == 0) revert IAppErrors.ErrorNotObject2();\n\n    c.isBattleObj = ControllerContextLib.getGameObjectController(cc).isBattleObject(c.objectId);\n    c.result = ControllerContextLib.getGameObjectController(cc).action(\n      c.msgSender, c.dungId, c.objectId, c.heroToken, c.heroTokenId, c.currentStage, c.data\n    );\n\n    if (c.isBattleObj) {\n      _markSkillSlotsForDurabilityReduction(\n        _S(),\n        c.statController,\n        ControllerContextLib.getItemController(cc),\n        c.data,\n        c.heroToken,\n        c.heroTokenId\n      );\n    }\n\n    c.stats = c.statController.heroStats(c.heroToken, c.heroTokenId);\n    if (c.stats.mana < c.result.manaConsumed.toUint()) {\n      revert IAppErrors.ErrorNotEnoughMana(c.stats.mana, c.result.manaConsumed.toUint());\n    }\n\n    if (c.result.kill || c.stats.life <= c.result.damage.toUint()) {\n      c.result.kill = true;\n      _changeCurrentDungeon(_S(), c.heroToken, c.heroTokenId, 0);\n      IHeroController hc = ControllerContextLib.getHeroController(cc);\n      hc.releaseReinforcement(c.heroToken, c.heroTokenId);\n\n      // in case of death we need to remove rewrote objects and reset initial stages\n      _resetUniqueObjects(dungStatus, dungAttributes);\n\n      // no need to release if we completed the dungeon - we will never back on the same\n      _releaseSkillSlotsForDurabilityReduction(_S(), c.heroToken, c.heroTokenId);\n\n      // if it was the last life chance - kill the hero\n      if (c.stats.lifeChances <= 1) {\n        _killHero(hc, c.dungId, c.heroToken, c.heroTokenId, dungStatus.treasuryItems);\n      } else {\n        _afterObjCompleteForSurvivedHero(c, cc);\n        _reduceLifeChances(c.statController, c.heroToken, c.heroTokenId, c.stats.life, c.stats.mana);\n\n        // scb-1000: soft death resets used consumables\n        c.statController.clearUsedConsumables(c.heroToken, c.heroTokenId);\n        // also soft death reset all buffs\n        c.statController.clearTemporallyAttributes(c.heroToken, c.heroTokenId);\n      }\n\n      // scb-994: increment death count counter\n      uint deathCounter = c.statController.heroCustomData(c.heroToken, c.heroTokenId, StatControllerLib.DEATH_COUNT_HASH);\n      c.statController.setHeroCustomData(c.heroToken, c.heroTokenId, StatControllerLib.DEATH_COUNT_HASH, deathCounter + 1);\n\n      clear = true;\n    } else {\n      _increaseChangeableStats(c.statController, c.heroToken, c.heroTokenId, c.result);\n      _decreaseChangeableStats(c.statController, c.heroToken, c.heroTokenId, c.result);\n      _mintItems(c, cc, dungStatus.treasuryItems);\n      if (c.result.completed) {\n        _afterObjCompleteForSurvivedHero(c, cc);\n        (isCompleted, newStage, currentObject) = _nextRoomOrComplete(c, cc, dungStatus, c.stages, dungStatus.treasuryTokens);\n      }\n      // clear = false;\n    }\n\n    emit IApplicationEvents.ObjectAction(c.dungId, c.result, c.currentStage, c.heroToken, c.heroTokenId, newStage);\n    return (isCompleted, newStage, currentObject, clear);\n  }\n\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ Main logic - auxiliary functions\n\n  /// @notice If hero has dead in the dungeon, it's necessary to restore initial set of unique objects,\n  ///         in other words, all changes introduces by {_nextRoomOrComplete} should be thrown away.\n  function _resetUniqueObjects(\n    IDungeonFactory.DungeonStatus storage dungStatus,\n    IDungeonFactory.DungeonAttributes storage dungAttributes\n  ) internal {\n    dungStatus.stages = dungAttributes.stages;\n    delete dungStatus.uniqObjects;\n\n    uint32[] memory uniqObjects = dungAttributes.uniqObjects;\n    for (uint i; i < uniqObjects.length; ++i) {\n      dungStatus.uniqObjects.push(uniqObjects[i]);\n    }\n  }\n\n  /// @notice Kill the hero, take hero's tokens and items\n  function _killHero(\n    IHeroController heroController,\n    uint64 dungId,\n    address heroToken,\n    uint heroTokenId,\n    bytes32[] storage treasuryItems\n  ) internal {\n    (bytes32[] memory drop) = heroController.kill(heroToken, heroTokenId);\n\n    // all hero's items are taken by the dungeon\n    uint dropLength = drop.length;\n    for (uint i; i < dropLength; ++i) {\n      treasuryItems.push(drop[i]);\n      (address itemAdr, uint itemId) = drop[i].unpackNftId();\n      emit IApplicationEvents.AddTreasuryItem(dungId, itemAdr, itemId);\n    }\n  }\n\n  /// @notice If battle object: reduce equipped items durability and clear temporally attributes\n  /// @dev Not necessary to call if a hero is dead\n  function _afterObjCompleteForSurvivedHero(\n    ObjectActionInternalData memory context,\n    ControllerContextLib.ControllerContext memory cc\n  ) internal {\n    if (context.isBattleObj) {\n      // reduce equipped items durability\n      ControllerContextLib.getItemController(cc).reduceDurability(context.heroToken, context.heroTokenId, uint8(context.biome));\n      // clear temporally attributes\n      context.statController.clearTemporallyAttributes(context.heroToken, context.heroTokenId);\n    }\n  }\n\n  /// @notice Check if the dungeon is completed, calculate index of the next stage.\n  /// @dev Take {rewriteNextObject} from the results of the previous action and set next objects for the dungeon\n  /// @param curStages Current value of dungStatus.stages\n  /// @return isCompleted The dungeon is completed\n  /// @return currentStage Next stage (0 if the dungeon is completed)\n  /// @return currentObj Always 0. It means, that new current object should be opened.\n  function _nextRoomOrComplete(\n    ObjectActionInternalData memory context,\n    ControllerContextLib.ControllerContext memory cc,\n    IDungeonFactory.DungeonStatus storage dungStatus,\n    uint curStages,\n    EnumerableMap.AddressToUintMap storage treasuryTokens\n  ) internal returns (\n    bool isCompleted,\n    uint currentStage,\n    uint32 currentObj\n  ) {\n    uint len = context.result.rewriteNextObject.length;\n\n    if (context.currentStage + 1 >= curStages && len == 0) {\n      _mintGameTokens(context.dungId, cc, context.stats.level, context.biome, treasuryTokens);\n      isCompleted = true;\n    } else {\n      // need to extend stages for new rewrite objects size\n      uint newStages = context.currentStage + 1 + len;\n      if (curStages < newStages) {\n        dungStatus.stages = uint8(newStages);\n\n        // need to extend exist array\n        dungStatus.uniqObjects = new uint32[](newStages);\n        // no need to write again old uniq objects, they will be updated in case of hero death\n      }\n\n      for (uint i; i < len; ++i) {\n        uint32 nextObjId = context.result.rewriteNextObject[i];\n        dungStatus.uniqObjects[context.currentStage + 1 + i] = nextObjId;\n      }\n\n      currentStage = context.currentStage + 1;\n    }\n\n    // currentObj is 0 by default\n    return (isCompleted, currentStage, currentObj);\n  }\n\n  /// @notice Increase life, mana and lifeChances according to the action {result}\n  function _increaseChangeableStats(\n    IStatController statController,\n    address heroToken,\n    uint heroTokenId,\n    IGOC.ActionResult memory result\n  ) internal {\n    if (result.heal != 0 || result.manaRegen != 0 || result.experience != 0 || result.lifeChancesRecovered != 0) {\n      statController.changeCurrentStats(\n        heroToken,\n        heroTokenId,\n        IStatController.ChangeableStats({\n          level: 0,\n          experience: result.experience,\n          life: uint32(result.heal.toUint()),\n          mana: uint32(result.manaRegen.toUint()),\n          lifeChances: uint32(result.lifeChancesRecovered.toUint())\n        }),\n        true\n      );\n    }\n  }\n\n  /// @notice Decrease life and mana according to the action {result}\n  function _decreaseChangeableStats(\n    IStatController statController,\n    address heroToken,\n    uint heroTokenId,\n    IGOC.ActionResult memory result\n  ) internal {\n    // decrease changeable stats\n    if (result.damage != 0 || result.manaConsumed != 0) {\n      statController.changeCurrentStats(\n        heroToken,\n        heroTokenId,\n        IStatController.ChangeableStats({\n          level: 0,\n          experience: 0,\n          life: uint32(result.damage.toUint()),\n          mana: uint32(result.manaConsumed.toUint()),\n          lifeChances: 0\n        }),\n        false\n      );\n    }\n  }\n\n  /// @notice Reduce life to 1, decrease lifeChances on 1, set mana to 0\n  function _reduceLifeChances(IStatController statController, address heroToken, uint heroTokenId, uint32 curLife, uint32 curMana) internal {\n    statController.changeCurrentStats(\n      heroToken,\n      heroTokenId,\n      IStatController.ChangeableStats({\n        level: 0,\n        experience: 0,\n        life: uint32(curLife - 1),\n        mana: uint32(curMana),\n        lifeChances: 1\n      }),\n      false\n    );\n  }\n\n  /// @notice Mint mint-items from {result}, add them to {treasuryItems}\n  function _mintItems(\n    ObjectActionInternalData memory context,\n    ControllerContextLib.ControllerContext memory cc,\n    bytes32[] storage treasuryItems\n  ) internal {\n    uint64 dungId = context.dungId;\n    IGOC.ActionResult memory result = context.result;\n\n    IItemController ic = ControllerContextLib.getItemController(cc);\n\n    for (uint i; i < result.mintItems.length; i++) {\n      if (result.mintItems[i] == address(0)) {\n        continue;\n      }\n      uint itemId = ic.mint(result.mintItems[i], address(this));\n      treasuryItems.push(result.mintItems[i].packNftId(itemId));\n      emit IApplicationEvents.AddTreasuryItem(dungId, result.mintItems[i], itemId);\n    }\n  }\n\n  /// @notice Register game-token in {treasuryTokens}, mint dungeon reward\n  function _mintGameTokens(\n    uint64 dungId,\n    ControllerContextLib.ControllerContext memory cc,\n    uint heroLevel,\n    uint biome,\n    EnumerableMap.AddressToUintMap storage treasuryTokens\n  ) private {\n    IGameToken gameToken = ControllerContextLib.getGameToken(cc);\n    uint amount = IMinter(gameToken.minter()).mintDungeonReward(dungId, biome, heroLevel);\n    _registerTreasuryToken(address(gameToken), treasuryTokens, amount);\n    emit IApplicationEvents.AddTreasuryToken(dungId, address(gameToken), amount);\n  }\n\n  /// @notice Add {rewardToken} to {treasuryTokens} if it's not add there already\n  function _registerTreasuryToken(address rewardToken, EnumerableMap.AddressToUintMap storage treasuryTokens, uint amount) internal {\n    (bool exist, uint existAmount) = treasuryTokens.tryGet(rewardToken);\n\n    if (!exist || existAmount + amount > 0) {\n      uint balance = IERC20(rewardToken).balanceOf(address(this));\n      if (balance < existAmount + amount) {\n        revert IAppErrors.NotEnoughTokens(balance, existAmount + amount);\n      }\n\n      treasuryTokens.set(rewardToken, existAmount + amount);\n    }\n  }\n  //endregion ------------------------ Main logic - auxiliary functions\n\n  //region ------------------------ ENTER/EXIT\n\n  /// @notice Hero enters to the dungeon. Check requirements before entering, update status of the hero and the dungeon.\n  function _enter(\n    ControllerContextLib.ControllerContext memory cc,\n    IDungeonFactory.DungeonStatus storage dungStatus,\n    IDungeonFactory.DungeonAttributes storage dungAttrs,\n    uint16 dungNum,\n    uint64 dungId,\n    address heroToken,\n    uint heroTokenId\n  ) internal {\n    IDungeonFactory.MainState storage s = _S();\n\n    IStatController.ChangeableStats memory stats = ControllerContextLib.getStatController(cc).heroStats(heroToken, heroTokenId);\n    uint8 dungBiome = dungAttrs.biome;\n\n    if (ControllerContextLib.getReinforcementController(cc).isStaked(heroToken, heroTokenId)) revert IAppErrors.Staked(heroToken, heroTokenId);\n    if (stats.lifeChances == 0) revert IAppErrors.ErrorHeroIsDead(heroToken, heroTokenId);\n    if (s.heroCurrentDungeon[heroToken.packNftId(heroTokenId)] != 0) revert IAppErrors.ErrorAlreadyInDungeon();\n    // assume here that onlyEnteredHeroOwner is already checked by the caller\n\n    if (ControllerContextLib.getHeroController(cc).heroBiome(heroToken, heroTokenId) != dungBiome) revert IAppErrors.ErrorNotBiome();\n    if (dungStatus.heroToken != address(0)) revert IAppErrors.ErrorDungeonBusy();\n    if (!isDungeonEligibleForHero(s, ControllerContextLib.getStatController(cc), dungNum, uint8(stats.level), heroToken, heroTokenId)) {\n      revert IAppErrors.ErrorNotEligible(heroToken, dungNum);\n    }\n\n    // remove free dungeon\n    if (s.freeDungeons[dungBiome].remove(uint(dungId))) {\n      emit IApplicationEvents.FreeDungeonRemoved(dungBiome, dungId);\n    }\n\n    _changeCurrentDungeon(s, heroToken, heroTokenId, dungId);\n    if (dungStatus.currentStage != 0) {\n      dungStatus.currentStage = uint8(0);\n    }\n    dungStatus.heroToken = heroToken;\n    dungStatus.heroTokenId = heroTokenId;\n\n    emit IApplicationEvents.Entered(dungId, heroToken, heroTokenId);\n  }\n\n  /// @notice Check if dungeon is eligible for the hero\n  /// @param dungNum Dungeon logic id\n  function isDungeonEligibleForHero(\n    IDungeonFactory.MainState storage s,\n    IStatController statController,\n    uint16 dungNum,\n    uint8 heroLevel,\n    address heroToken,\n    uint heroTokenId\n  ) internal view returns (bool) {\n    IDungeonFactory.DungeonAttributes storage dungAttr = s.dungeonAttributes[dungNum];\n\n    // check if the hero level is in the range required by the dungeon\n    {\n      (uint minLevel, uint maxLevel,) = dungAttr.minMaxLevel.unpackUint8Array3();\n      if (heroLevel < minLevel || heroLevel > maxLevel) {\n        return false;\n      }\n    }\n\n    // check if hero/global custom values are in the ranges required by the dungeon\n    bytes32[] memory requiredCustomDataIndex = dungAttr.requiredCustomDataIndex;\n    bytes32[] memory requiredCustomDataValue = dungAttr.requiredCustomDataValue;\n\n    uint len = requiredCustomDataIndex.length;\n    for (uint i; i < len; ++i) {\n      bytes32 index = requiredCustomDataIndex[i];\n      if (index == bytes32(0)) continue;\n\n      (uint64 min, uint64 max, bool isHeroValue) = requiredCustomDataValue[i].unpackCustomDataRequirements();\n\n      uint value = isHeroValue\n        ? statController.heroCustomData(heroToken, heroTokenId, index)\n        : statController.globalCustomData(index);\n\n      if (value < uint(min) || value > uint(max)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /// @notice Select logic for the new dungeon\n  function getDungeonLogic(\n    IDungeonFactory.MainState storage s_,\n    ControllerContextLib.ControllerContext memory cc,\n    uint8 heroLevel,\n    address heroToken,\n    uint heroTokenId,\n    uint random\n  ) internal view returns (uint16) {\n    if (heroLevel == 0) revert IAppErrors.ErrorHeroLevelStartFrom1();\n\n    uint8 heroBiome;\n    {\n      IHeroController hc = ControllerContextLib.getHeroController(cc);\n      heroBiome = hc.heroBiome(heroToken, heroTokenId);\n\n      // try to get specific dungeon\n      // specific dungeon for concrete level and class\n      uint16 specificDungeon = s_.dungeonSpecific[_toUint8PackedArray(heroLevel / uint8(StatLib.BIOME_LEVEL_STEP) + 1, hc.heroClass(heroToken))];\n      // if no specific dungeon for concrete class try to find for all classes\n      if (specificDungeon == 0) {\n        specificDungeon = s_.dungeonSpecific[_toUint8PackedArray(heroLevel / uint8(StatLib.BIOME_LEVEL_STEP) + 1, 0)];\n      }\n      // if no specific dungeon for concrete class and level try to find for all classes and all levels\n      if (specificDungeon == 0) {\n        // in this case we have 1 specific dungeon for all classes and levels, and only 1, suppose to be initial territory\n        specificDungeon = s_.dungeonSpecific[_toUint8PackedArray(0, 0)];\n      }\n\n      if (specificDungeon != 0) {\n        if (!s_.specificDungeonCompleted[heroToken.packDungeonKey(uint64(heroTokenId), specificDungeon)]\n        && s_.dungeonAttributes[specificDungeon].biome == heroBiome) {\n          return specificDungeon;\n        }\n      }\n    }\n\n    EnumerableSet.UintSet storage dungs = s_.dungeonsLogicByBiome[heroBiome];\n    uint size = dungs.length();\n    if (size == 0) revert IAppErrors.ErrorNoDungeonsForBiome(heroBiome);\n\n    IStatController statController = ControllerContextLib.getStatController(cc);\n    uint16 dungeonLogic;\n    uint dungeonIndex = random % size;\n    for (uint i; i < size; ++i) {\n      dungeonLogic = uint16(dungs.at(dungeonIndex));\n\n      if (isDungeonEligibleForHero(s_, statController, dungeonLogic, heroLevel, heroToken, heroTokenId)) {\n        return dungeonLogic;\n      }\n      dungeonIndex++;\n      if (dungeonIndex >= size) {\n        dungeonIndex = 0;\n      }\n    }\n\n    revert IAppErrors.ErrorNoEligibleDungeons();\n  }\n\n  /// @notice Exit the dungeon\n  /// @param claim Claim treasure items and tokens\n  function exitDungeon(IController controller, uint64 dungId, bool claim, address msgSender) external {\n    IDungeonFactory.DungeonStatus storage dungStatus = _S().dungeonStatuses[dungId];\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\n    address heroToken = dungStatus.heroToken;\n    uint heroTokenId = dungStatus.heroTokenId;\n\n    if (!dungStatus.isCompleted) revert IAppErrors.ErrorNotCompleted();\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\n    if (IERC721(heroToken).ownerOf(heroTokenId) != msgSender) revert IAppErrors.ErrorNotHeroOwner(heroToken, msgSender);\n    if (_S().heroCurrentDungeon[heroToken.packNftId(heroTokenId)] != dungId) revert IAppErrors.ErrorHeroNotInDungeon();\n\n    IHeroController heroController = ControllerContextLib.getHeroController(cc);\n    (address payToken,) = heroController.payTokenInfo(heroToken);\n\n    _setDungeonCompleted(_S(), dungStatus.dungNum, dungId, heroToken, heroTokenId);\n\n    if (claim) {\n      _claimAll(cc, msgSender, dungId, dungStatus, heroToken, heroTokenId, payToken);\n    }\n    _heroExit(_S(), heroController, heroToken, heroTokenId);\n\n    if (payToken == address(0)) {\n      // F2P hero doesn't have pay token, he is destroyed after exit of the dungeon\n      _killHero(heroController, dungId, heroToken, heroTokenId, dungStatus.treasuryItems);\n    }\n\n    // register daily activity\n    address userController = controller.userController();\n    if (userController != address(0)) {\n      IUserController(userController).registerPassedDungeon(msgSender);\n    }\n\n    emit IApplicationEvents.Exit(dungId, claim);\n  }\n\n  /// @notice Emergency exit: the governance can drop the hero from dungeon in emergency\n  function emergencyExit(IController controller, uint64 dungId) external {\n    IDungeonFactory.MainState storage s = _S();\n    // assume that governance-restriction is checked on caller side\n    IDungeonFactory.DungeonStatus storage dungStatus = s.dungeonStatuses[dungId];\n\n    _heroExit(s, IHeroController(controller.heroController()), dungStatus.heroToken, dungStatus.heroTokenId);\n\n    dungStatus.isCompleted = true;\n    dungStatus.heroToken = address(0);\n    dungStatus.heroTokenId = 0;\n\n    emit IApplicationEvents.Exit(dungId, false);\n  }\n\n  //endregion ------------------------ ENTER/EXIT\n\n  //region ------------------------ ENTER/EXIT auxiliary functions\n  /// @dev this function should emit event to indicate dungeon remove\n  function _setDungeonCompleted(IDungeonFactory.MainState storage s, uint16 dungNum, uint64 dungeonId, address heroToken, uint heroTokenId) internal {\n    if (s.allSpecificDungeons.contains(dungNum)) {\n      s.specificDungeonCompleted[heroToken.packDungeonKey(uint64(heroTokenId), dungNum)] = true;\n    }\n    emit IApplicationEvents.DungeonCompleted(dungNum, dungeonId, heroToken, heroTokenId);\n  }\n\n  /// @notice Change current dungeon of the hero to 0 and release his reinforcement\n  function _heroExit(IDungeonFactory.MainState storage s, IHeroController heroController, address heroToken, uint heroTokenId) internal {\n    _changeCurrentDungeon(s, heroToken, heroTokenId, 0);\n    heroController.releaseReinforcement(heroToken, heroTokenId);\n  }\n\n  /// @notice Change current dungeon of the hero to the {dungeonId}\n  function _changeCurrentDungeon(IDungeonFactory.MainState storage s, address hero, uint heroId, uint64 dungeonId) internal {\n    s.heroCurrentDungeon[hero.packNftId(heroId)] = dungeonId;\n    emit IApplicationEvents.HeroCurrentDungeonChanged(hero, heroId, dungeonId);\n  }\n\n  /// @notice Enumerate busy slots of the hero, find all SKILL_XXX and return their addresses and ids\n  /// @return skillSlotAdr Addresses of available skills. 0 - SKILL_1, 1 - SKILL_2, 2 - SKILL_3.\n  ///                      Address is zero if the hero doesn't have the corresponded skill.\n  /// @return skillSlotIds Ids of available skills. 0 - SKILL_1, 1 - SKILL_2, 2 - SKILL_3\n  ///                      ID is zero if the hero doesn't have the corresponded skill.\n  function _getSkillSlotsForHero(IStatController statCtr, address heroToken, uint heroTokenId) internal view returns (\n    address[3] memory skillSlotAdr,\n    uint[3] memory skillSlotIds\n  ) {\n    uint8[] memory busySlots = statCtr.heroItemSlots(heroToken, uint64(heroTokenId));\n\n    for (uint i; i < busySlots.length; ++i) {\n      if (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_1)) {\n        (skillSlotAdr[0], skillSlotIds[0]) = statCtr.heroItemSlot(heroToken, uint64(heroTokenId), busySlots[i]).unpackNftId();\n      }\n      if (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_2)) {\n        (skillSlotAdr[1], skillSlotIds[1]) = statCtr.heroItemSlot(heroToken, uint64(heroTokenId), busySlots[i]).unpackNftId();\n      }\n      if (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_3)) {\n        (skillSlotAdr[2], skillSlotIds[2]) = statCtr.heroItemSlot(heroToken, uint64(heroTokenId), busySlots[i]).unpackNftId();\n      }\n    }\n\n    return (skillSlotAdr, skillSlotIds);\n  }\n\n  /// @notice Generate map[3] for SKILL_1, SKILL_2, SKILL_3 (0 - not marked, 1 - marked)\n  ///         and save the map to {s_}._skillSlotsForDurabilityReduction as packed uint8[]\n  /// @dev mark skill slots for durability reduction\n  /// SIP-001: take into account hero's skills only and ignore skills of the helper\n  /// @param data abi.encoded IFightCalculator.AttackInfo\n  function _markSkillSlotsForDurabilityReduction(\n    IDungeonFactory.MainState storage s_,\n    IStatController sc,\n    IItemController itemController,\n    bytes memory data,\n    address heroToken,\n    uint heroTokenId\n  ) internal {\n    uint8[] memory map = new uint8[](3);\n    (IFightCalculator.AttackInfo memory attackInfo) = abi.decode(data, (IFightCalculator.AttackInfo));\n\n    uint length = attackInfo.skillTokens.length;\n\n    if (length != 0 || attackInfo.attackToken != address(0)) {\n\n      (address[3] memory skillSlotAdr, uint[3] memory skillSlotIds) = _getSkillSlotsForHero(sc, heroToken, heroTokenId);\n\n      for (uint i; i < length; ++i) {\n        address token = attackInfo.skillTokens[i];\n        uint tokenId = attackInfo.skillTokenIds[i];\n\n        // The hero is able to use own skills OR the skills of the helper. Take into account only own hero's skills here\n        (address h, ) = itemController.equippedOn(token, tokenId);\n        if (h == heroToken) {\n          if (token == skillSlotAdr[0] && tokenId == skillSlotIds[0]) {\n            map[0] = 1;\n          } else if (token == skillSlotAdr[1] && tokenId == skillSlotIds[1]) {\n            map[1] = 1;\n          } else if (token == skillSlotAdr[2] && tokenId == skillSlotIds[2]) {\n            map[2] = 1;\n          }\n        }\n      }\n\n      if (attackInfo.attackToken == skillSlotAdr[0] && attackInfo.attackTokenId == skillSlotIds[0]) {\n        map[0] = 1;\n      } else if (attackInfo.attackToken == skillSlotAdr[1] && attackInfo.attackTokenId == skillSlotIds[1]) {\n        map[1] = 1;\n      } else if (attackInfo.attackToken == skillSlotAdr[2] && attackInfo.attackTokenId == skillSlotIds[2]) {\n        map[2] = 1;\n      }\n    }\n\n    // write even empty map for clear prev values\n    s_.skillSlotsForDurabilityReduction[heroToken.packNftId(heroTokenId)] = map.packUint8Array();\n  }\n\n  /// @dev clear all skill slots marks\n  function _releaseSkillSlotsForDurabilityReduction(IDungeonFactory.MainState storage s_, address heroToken, uint heroTokenId) internal {\n    delete s_.skillSlotsForDurabilityReduction[heroToken.packNftId(heroTokenId)];\n  }\n\n  //endregion ------------------------ ENTER/EXIT auxiliary functions\n\n  //region ------------------------ CLAIM\n\n  /// @notice Claim all treasure tokens and items registered for the given hero.\n  ///         The tokens are send to msgSender and/or helper, or they can be send to controller or burned.\n  ///         The items are transferred to msgSender or helper (random choice) or destroyed (F2P hero).\n  /// @dev ClaimContext is used both for lazy initialization and to extend limits of allowed local vars.\n  /// @param heroPayToken Hero pay token. It's zero for hero 5.\n  function _claimAll(\n    ControllerContextLib.ControllerContext memory cc,\n    address msgSender,\n    uint64 dungId,\n    IDungeonFactory.DungeonStatus storage dungStatus,\n    address heroToken,\n    uint heroTokenId,\n    address heroPayToken\n  ) internal {\n    ClaimContext memory context;\n\n    context.msgSender = msgSender;\n    context.dungId = dungId;\n\n    (context.helpHeroToken, context.helpHeroId) = ControllerContextLib.getHeroController(cc).heroReinforcementHelp(heroToken, heroTokenId);\n    context.toHelperRatio = ControllerContextLib.getReinforcementController(cc).toHelperRatio(context.helpHeroToken, context.helpHeroId);\n\n    context.itemLength = dungStatus.treasuryItems.length;\n    context.tokenLength = dungStatus.treasuryTokens.length();\n    context.tokens = new address[](context.tokenLength);\n    context.amounts = new uint[](context.tokenLength);\n\n    context.heroPayToken = heroPayToken;\n\n    // need to write tokens separately coz we need to delete them from map\n    for (uint i; i < context.tokenLength; i++) {\n      (context.tokens[i], context.amounts[i]) = dungStatus.treasuryTokens.at(i);\n    }\n\n    for (uint i; i < context.tokenLength; i++) {\n      _claimToken(dungStatus.treasuryTokens, context, cc, context.tokens[i], context.amounts[i]);\n    }\n\n    for (uint i; i < context.itemLength; i++) {\n      (address itemAdr, uint itemId) = dungStatus.treasuryItems[i].unpackNftId();\n      _claimItem(context, cc, itemAdr, itemId);\n    }\n\n    delete dungStatus.treasuryItems;\n  }\n\n  /// @notice Remove {token} from treasuryTokens, transfer/burn token {amount}\n  function _claimToken(\n    EnumerableMap.AddressToUintMap storage treasuryTokens,\n    ClaimContext memory context,\n    ControllerContextLib.ControllerContext memory cc,\n    address token,\n    uint amount\n  ) internal {\n    treasuryTokens.remove(token);\n    if (amount != 0) {\n\n      if (context.heroPayToken == address(0)) {\n        if (token == address(ControllerContextLib.getGameToken(cc)) ) {\n          IGameToken(token).burn(amount);\n        } else {\n          IERC20(token).transfer(address(cc.controller), amount);\n        }\n\n      } else {\n        uint toHelper = context.helpHeroToken == address(0)\n          ? 0\n          : amount * context.toHelperRatio / 100;\n\n        uint toHeroOwner = amount - toHelper;\n        if (toHeroOwner != 0) {\n          IERC20(token).transfer(context.msgSender, toHeroOwner);\n        }\n\n        if (toHelper != 0) {\n          IReinforcementController reinforcementController = ControllerContextLib.getReinforcementController(cc);\n          IERC20(token).transfer(address(reinforcementController), toHelper);\n          reinforcementController.registerTokenReward(context.helpHeroToken, context.helpHeroId, token, toHelper);\n        }\n\n        emit IApplicationEvents.ClaimToken(context.dungId, token, amount);\n      }\n    }\n  }\n\n  /// @notice Destroy item (for F2P) or transfer the item to helper/sender (random choice)\n  function _claimItem(\n    ClaimContext memory context,\n    ControllerContextLib.ControllerContext memory cc,\n    address token,\n    uint tokenId\n  ) internal {\n    if (IERC721(token).ownerOf(tokenId) == address(this)) {\n\n      if (context.heroPayToken == address(0)) {\n        // if it is F2P hero destroy all drop\n        ControllerContextLib.getItemController(cc).destroy(token, tokenId);\n      } else {\n\n        bool toHelper = false;\n        if (context.helpHeroToken != address(0)) {\n          toHelper = ControllerContextLib.getOracle(cc).getRandomNumber(100, 0) < context.toHelperRatio;\n        }\n\n        if (toHelper) {\n          IReinforcementController reinforcementController = ControllerContextLib.getReinforcementController(cc);\n          IERC721(token).safeTransferFrom(address(this), address(reinforcementController), tokenId);\n          reinforcementController.registerNftReward(context.helpHeroToken, context.helpHeroId, token, tokenId);\n        } else {\n          IERC721(token).safeTransferFrom(address(this), context.msgSender, tokenId);\n        }\n\n        emit IApplicationEvents.ClaimItem(context.dungId, token, tokenId);\n      }\n    }\n  }\n  //endregion ------------------------ CLAIM\n\n  //region ------------------------ Utils\n  function _toUint8PackedArray(uint8 val0, uint8 val1) internal pure returns (bytes32 key) {\n    return PackingLib.packUint8Array3(val0, val1, 0);\n  }\n\n  function _toUint8ArrayWithoutZeroes(bytes32 data) internal pure returns (uint8[] memory result) {\n    uint8[] memory arr = data.unpackUint8Array();\n\n    uint newSize;\n    for (uint i; i < arr.length; ++i) {\n      if (arr[i] == 0) {\n        break;\n      }\n      newSize++;\n    }\n\n    result = new uint8[](newSize);\n    for (uint i; i < newSize; ++i) {\n      result[i] = arr[i];\n    }\n  }\n  //endregion ------------------------ Utils\n}\n"
    },
    "contracts/lib/EventLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"./CalcLib.sol\";\nimport \"./PackingLib.sol\";\nimport \"./ItemLib.sol\";\nimport \"./StoryLib.sol\";\nimport \"../interfaces/IStatController.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IGOC.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\n\nlibrary EventLib {\n  using CalcLib for int32;\n  using PackingLib for bytes32;\n  using PackingLib for bytes32[];\n  using PackingLib for uint16;\n  using PackingLib for uint8;\n  using PackingLib for address;\n  using PackingLib for uint32[];\n  using PackingLib for uint32;\n  using PackingLib for uint64;\n  using PackingLib for int32[];\n  using PackingLib for int32;\n\n  //region ------------------------ Main logic\n\n  function action(IGOC.ActionContext calldata ctx, IGOC.EventInfo storage info) external returns (\n    IGOC.ActionResult memory\n  ) {\n    (bool accept) = abi.decode(ctx.data, (bool));\n    return accept\n      ? _eventAcceptResult(ctx, info)\n      : _noActionResult();\n  }\n\n  /// @notice Save data from {regInfo} to {info}\n  function eventRegInfoToInfo(IGOC.EventRegInfo calldata regInfo, IGOC.EventInfo storage info) external {\n    info.goodChance = regInfo.goodChance;\n    info.goodAttributes = regInfo.goodAttributes.values.toBytes32ArrayWithIds(regInfo.goodAttributes.ids);\n    info.badAttributes = regInfo.badAttributes.values.toBytes32ArrayWithIds(regInfo.badAttributes.ids);\n    info.statsChange = regInfo.experience.packStatsChange(\n      regInfo.heal,\n      regInfo.manaRegen,\n      regInfo.lifeChancesRecovered,\n      regInfo.damage,\n      regInfo.manaConsumed\n    );\n\n    bytes32[] memory mintItems = new bytes32[](regInfo.mintItems.length);\n\n    for (uint i; i < mintItems.length; ++i) {\n      mintItems[i] = regInfo.mintItems[i].packItemMintInfo(regInfo.mintItemsChances[i]);\n    }\n    info.mintItems = mintItems;\n  }\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ Internal logic\n  function _eventAcceptResult(IGOC.ActionContext calldata ctx, IGOC.EventInfo storage info) internal returns (\n    IGOC.ActionResult memory result\n  ) {\n    IStatController sc = IStatController(ctx.controller.statController());\n\n    IStatController.ActionInternalInfo memory gen = _generate(ctx, info, sc);\n\n    if (gen.posAttributes.length != 0) {\n      sc.changeBonusAttributes(IStatController.ChangeAttributesInfo({\n        heroToken: ctx.heroToken,\n        heroTokenId: ctx.heroTokenId,\n        changeAttributes: gen.posAttributes,\n        add: true,\n        temporally: true\n      }));\n    }\n\n    if (gen.negAttributes.length != 0) {\n      sc.changeBonusAttributes(IStatController.ChangeAttributesInfo({\n        heroToken: ctx.heroToken,\n        heroTokenId: ctx.heroTokenId,\n        changeAttributes: gen.negAttributes,\n        add: true,\n        temporally: true\n      }));\n    }\n\n    // refreshed stats\n    IStatController.ChangeableStats memory stats = sc.heroStats(ctx.heroToken, ctx.heroTokenId);\n\n    result.completed = true;\n    result.experience = gen.experience;\n    result.heal = gen.heal;\n    result.manaRegen = gen.manaRegen;\n    result.lifeChancesRecovered = gen.lifeChancesRecovered;\n    result.damage = gen.damage;\n    result.manaConsumed = CalcLib.minI32(gen.manaConsumed, int32(stats.mana));\n    result.mintItems = gen.mintedItems;\n\n    if (stats.life <= gen.damage.toUint()) {\n      result.kill = true;\n    }\n\n    emit IApplicationEvents.EventResult(ctx.dungeonId, ctx.heroToken, ctx.heroTokenId, ctx.stageId, gen, ctx.iteration);\n    return result;\n  }\n\n  /// @notice Generate empty result structure, only \"completed\" is true\n  function _noActionResult() internal pure returns (IGOC.ActionResult memory result) {\n    result.completed = true;\n    return result;\n  }\n\n  /// @notice Generate either positive or negative attributes, mint single item in any case\n  function _generate(IGOC.ActionContext calldata ctx, IGOC.EventInfo storage info, IStatController sc) internal returns (\n    IStatController.ActionInternalInfo memory result\n  ) {\n    uint32 goodChance = info.goodChance;\n    if (goodChance > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighChance(goodChance);\n\n    IOracle oracle = IOracle(ctx.controller.oracle());\n\n    uint random = goodChance == CalcLib.MAX_CHANCE ? CalcLib.MAX_CHANCE : oracle.getRandomNumber(CalcLib.MAX_CHANCE, 0);\n    if (random <= goodChance) {\n      result.posAttributes = StoryLib._generateAttributes(info.goodAttributes);\n      (result.experience,\n        result.heal,\n        result.manaRegen,\n        result.lifeChancesRecovered,,) = info.statsChange.unpackStatsChange();\n    } else {\n      result.negAttributes = StoryLib._generateAttributes(info.badAttributes);\n      (,,,, result.damage, result.manaConsumed) = info.statsChange.unpackStatsChange();\n    }\n\n    // always mint possible items even if bad result\n    result.mintedItems = _mintRandomItem(ctx, info, oracle, sc, CalcLib.nextPrng);\n\n    return result;\n  }\n\n  /// @notice Mint single random item\n  /// @param nextPrng_ CalcLib.nextPrng, param is required by unit tests\n  function _mintRandomItem(\n    IGOC.ActionContext calldata ctx,\n    IGOC.EventInfo storage info,\n    IOracle oracle,\n    IStatController sc,\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\n  ) internal returns (address[] memory minted) {\n    bytes32[] memory mintItemsPacked = info.mintItems;\n    if (mintItemsPacked.length == 0) {\n      return minted;\n    }\n\n    IStatController.ChangeableStats memory stats = sc.heroStats(ctx.heroToken, ctx.heroTokenId);\n\n    address[] memory mintItems = new address[](mintItemsPacked.length);\n    uint32[] memory mintItemsChances = new uint32[](mintItemsPacked.length);\n\n    for (uint i = 0; i < mintItemsPacked.length; i++) {\n      (mintItems[i], mintItemsChances[i]) = mintItemsPacked[i].unpackItemMintInfo();\n    }\n\n    return ItemLib._mintRandomItems(\n      ItemLib.MintItemInfo({\n        mintItems: mintItems,\n        mintItemsChances: mintItemsChances,\n        amplifier: 0,\n        seed: 0,\n        oracle: oracle,\n        magicFind: 0,\n        destroyItems: 0,\n        maxItems: 1, // MINT ONLY 1 ITEM!\n        mintDropChanceDelta: StatLib.mintDropChanceDelta(stats.experience, uint8(stats.level), ctx.biome)\n      }),\n      nextPrng_\n    );\n  }\n  //endregion ------------------------ Internal logic\n}\n"
    },
    "contracts/lib/FightLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IStatController.sol\";\nimport \"../interfaces/IItemController.sol\";\nimport \"../interfaces/IFightCalculator.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../lib/StatLib.sol\";\nimport \"../lib/CalcLib.sol\";\nimport \"../lib/PackingLib.sol\";\nimport \"../solady/FixedPointMathLib.sol\";\n\nlibrary FightLib {\n  using PackingLib for bytes32;\n  using CalcLib for int32;\n\n  //region ------------------------ Data types\n  struct AttackResult {\n    int32 defenderHealth;\n    int32 damage;\n    int32 lifeStolen;\n    int32 reflectDamage;\n    uint8 critical;\n    uint8 missed;\n    uint8 blocked;\n  }\n  //endregion ------------------------ Data types\n\n  //region ------------------------ Constants\n  uint internal constant MAX_FIGHT_CYCLES = 100;\n  int32 internal constant RESISTANCE_DENOMINATOR = 100;\n  int32 internal constant _MAX_RESIST = 90;\n\n  /// @notice SIP-002 constant: desired capacity\n  uint internal constant CAPACITY_RESISTS_DEFS = 90;\n  /// @notice SIP-002 constant: desired capacity\n  uint internal constant CAPACITY_CRITICAL_HIT_STATUSES = 100;\n  /// @notice SIP-002 constant: the factor of how fast the value will reach the capacity\n  uint internal constant K_FACTOR = 100;\n  /// @notice ln(2), decimals 18\n  int internal constant LN2 = 693147180559945309;\n\n  //endregion ------------------------ Constants\n\n  //region ------------------------ Main logic\n\n  /// @dev Items ownership must be checked before\n  ///      it is no write actions but we need to emit an event for properly handle the battle on UI\n  ///      return huge structs more expensive that call an event here\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests\n  function fight(\n    IItemController ic,\n    IFightCalculator.FightCall memory callData,\n    address msgSender,\n    function (uint) internal view returns (uint) random_\n  ) internal returns (\n    IFightCalculator.FightResult memory\n  ) {\n    IFightCalculator.FightInfoInternal memory fResult = prepareFightInternalInfo(ic, callData.fighterA, callData.fighterB);\n\n    fightProcessing(fResult, random_);\n\n    emit IApplicationEvents.FightResultProcessed(msgSender, fResult, callData, callData.iteration);\n\n    return IFightCalculator.FightResult({\n      healthA: fResult.fighterA.health,\n      healthB: fResult.fighterB.health,\n      manaConsumedA: fResult.fighterA.manaConsumed,\n      manaConsumedB: fResult.fighterB.manaConsumed\n    });\n  }\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ High level of internal logic\n  function fightProcessing(\n    IFightCalculator.FightInfoInternal memory fResult,\n    function (uint) internal view returns (uint) random_\n  ) internal view {\n\n    bool firstA = calcFirstHit(fResult);\n\n    setStatuses(fResult, firstA, random_);\n    setStatuses(fResult, !firstA, random_);\n\n    reduceAttributesByStatuses(fResult.fighterA.info.fighterAttributes, fResult.fighterA.statuses, fResult.fighterB.info.fighterAttributes);\n    reduceAttributesByStatuses(fResult.fighterB.info.fighterAttributes, fResult.fighterB.statuses, fResult.fighterA.info.fighterAttributes);\n\n    AttackResult memory resultA = processAttack(fResult, true, random_);\n    AttackResult memory resultB = processAttack(fResult, false, random_);\n\n    fResult.fighterA.statuses.gotCriticalHit = resultA.critical != 0;\n    fResult.fighterA.statuses.missed = resultA.missed != 0;\n    fResult.fighterA.statuses.hitBlocked = resultA.blocked != 0;\n\n    fResult.fighterB.statuses.gotCriticalHit = resultB.critical != 0;\n    fResult.fighterB.statuses.missed = resultB.missed != 0;\n    fResult.fighterB.statuses.hitBlocked = resultB.blocked != 0;\n\n    reduceHp(\n      firstA ? resultA : resultB,\n      firstA ? resultB : resultA,\n      firstA ? fResult.fighterA : fResult.fighterB,\n      firstA ? fResult.fighterB : fResult.fighterA\n    );\n\n    // restore health from stolen life\n    stealLife(fResult.fighterA, resultA);\n    stealLife(fResult.fighterB, resultB);\n  }\n\n  function processAttack(\n    IFightCalculator.FightInfoInternal memory fResult,\n    bool isA,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (AttackResult memory attackResult) {\n\n    int32 defenderHealth = isA ? fResult.fighterB.health : fResult.fighterA.health;\n\n    if (skipTurn(fResult, isA)) {\n      return AttackResult({\n        defenderHealth: defenderHealth,\n        damage: 0,\n        lifeStolen: 0,\n        reflectDamage: 0,\n        critical: 0,\n        missed: 0,\n        blocked: 0\n      });\n    }\n\n    IFightCalculator.FighterInfo memory attackerInfo = isA ? fResult.fighterA.info : fResult.fighterB.info;\n    IFightCalculator.FighterInfo memory defenderInfo = isA ? fResult.fighterB.info : fResult.fighterA.info;\n\n    if (attackerInfo.attackType == IFightCalculator.AttackType.MELEE) {\n      attackResult = meleeDamageCalculation(attackerInfo, defenderInfo, defenderHealth, random_);\n    } else if (attackerInfo.attackType == IFightCalculator.AttackType.MAGIC) {\n      attackResult = magicDamageCalculation(\n        attackerInfo,\n        defenderInfo,\n        isA ? fResult.fighterA.magicAttack : fResult.fighterB.magicAttack,\n        defenderHealth,\n        random_\n      );\n    } else {\n      revert IAppErrors.NotAType(uint(attackerInfo.attackType));\n    }\n  }\n  //endregion ------------------------ High level of internal logic\n\n  //region ------------------------ Internal logic\n  function prepareFightInternalInfo(\n    IItemController ic,\n    IFightCalculator.FighterInfo memory fighterA,\n    IFightCalculator.FighterInfo memory fighterB\n  ) internal view returns (IFightCalculator.FightInfoInternal memory) {\n    IFightCalculator.FightInfoInternal memory fInfo;\n    _setFightData(ic, fighterA, fInfo.fighterA);\n    _setFightData(ic, fighterB, fInfo.fighterB);\n    return fInfo;\n  }\n\n  /// @dev A part of prepareFightInternalInfo\n  function _setFightData(\n    IItemController ic,\n    IFightCalculator.FighterInfo memory fighter,\n    IFightCalculator.Fighter memory dest\n  ) internal view {\n    dest.info = fighter;\n    dest.health = int32(fighter.fighterStats.life);\n    if (fighter.attackToken != address(0)) {\n      if (fighter.attackType != IFightCalculator.AttackType.MAGIC) revert IAppErrors.NotMagic();\n      dest.magicAttack = ic.itemAttackInfo(fighter.attackToken, fighter.attackTokenId);\n    }\n    // dest.manaConsumed is 0 by default, in current implementation we don't need to change it\n  }\n\n  /// @param random_ Either _pseudoRandom or pseudo-random for ut\n  function statusChance(\n    IFightCalculator.FighterInfo memory attackerInfo,\n    IItemController.AttackInfo memory attackerMA,\n    IStatController.ATTRIBUTES index,\n    int32 resist,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (bool) {\n    int32 chance = _getChance(attackerInfo, attackerMA.aType, index, resist);\n    if (chance == 0) {\n      return false;\n    }\n    if (chance >= RESISTANCE_DENOMINATOR) {\n      return true;\n    }\n    return random_(RESISTANCE_DENOMINATOR.toUint()) < chance.toUint();\n  }\n\n  /// @notice set fResult.fighterB.statuses (for isA = true) or fResult.fighterA.statuses (for isA = false)\n  /// @param random_ Either _pseudoRandom or pseudo-random for ut\n  function setStatuses(\n    IFightCalculator.FightInfoInternal memory fResult,\n    bool isA,\n    function (uint) internal view returns (uint) random_\n  ) internal view {\n    // setStatuses is called twice one by one: first time for A, second time for B\n    // if stun is set for A, setStatuses is skipped for B completely\n    if (!skipTurn(fResult, isA)) {\n      IFightCalculator.FighterInfo memory attackerInfo = isA ? fResult.fighterA.info : fResult.fighterB.info;\n      IFightCalculator.FighterInfo memory defenderInfo = isA ? fResult.fighterB.info : fResult.fighterA.info;\n\n      IItemController.AttackInfo memory attackerMA = isA ? fResult.fighterA.magicAttack : fResult.fighterB.magicAttack;\n\n      IFightCalculator.Statuses memory statuses = isA ? fResult.fighterB.statuses : fResult.fighterA.statuses;\n\n      int32 resist = defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.RESIST_TO_STATUSES)];\n\n      statuses.stun = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.STUN, resist, random_);\n      statuses.burn = statusChance(\n        attackerInfo,\n        attackerMA,\n        IStatController.ATTRIBUTES.BURN,\n        defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)],\n        random_\n      );\n      statuses.freeze = statusChance(\n        attackerInfo,\n        attackerMA,\n        IStatController.ATTRIBUTES.FREEZE,\n        defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)],\n        random_\n      );\n      statuses.confuse = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.CONFUSE, resist, random_);\n      statuses.curse = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.CURSE, resist, random_);\n      statuses.poison = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.POISON, resist, random_);\n    }\n  }\n\n  function magicDamageCalculation(\n    IFightCalculator.FighterInfo memory attackerInfo,\n    IFightCalculator.FighterInfo memory defenderInfo,\n    IItemController.AttackInfo memory magicAttack,\n    int32 defenderHealth,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (AttackResult memory attackResult) {\n    // generate damage\n    int32 damage = getMagicDamage(\n      attackerInfo,\n      magicAttack,\n      CalcLib.pseudoRandomInRangeFlex(magicAttack.min.toUint(), magicAttack.max.toUint(), random_)\n    );\n    damage = increaseMagicDmgByFactor(damage, attackerInfo, magicAttack.aType);\n    damage = increaseRaceDmg(damage, attackerInfo, defenderInfo.race);\n    bool critical = isCriticalHit(attackerInfo, random_(RESISTANCE_DENOMINATOR.toUint()));\n    damage = critical ? damage * 2 : damage;\n\n    // decrease damage\n    damage = decreaseRaceDmg(damage, defenderInfo, attackerInfo.race);\n    damage = decreaseDmgByDmgReduction(damage, defenderInfo);\n\n    if (magicAttack.aType == IItemController.AttackType.FIRE) {\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.FIRE_RESISTANCE);\n    } else if (magicAttack.aType == IItemController.AttackType.COLD) {\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.COLD_RESISTANCE);\n    } else if (magicAttack.aType == IItemController.AttackType.LIGHTNING) {\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE);\n    }\n\n    int32 defenderHealthResult = defenderHealth < damage ? int32(0) : defenderHealth - damage;\n    damage = defenderHealth - defenderHealthResult;\n\n    return AttackResult({\n      defenderHealth: defenderHealthResult,\n      damage: damage,\n      lifeStolen: lifeStolenPerHit(damage, attackerInfo),\n      reflectDamage: reflectMagicDmg(damage, defenderInfo) + reflectChaos(magicAttack, attackerInfo, random_(1e18)),\n      critical: critical ? uint8(1) : uint8(0),\n      missed: 0,\n      blocked: 0\n    });\n  }\n\n  function meleeDamageCalculation(\n    IFightCalculator.FighterInfo memory attackerInfo,\n    IFightCalculator.FighterInfo memory defenderInfo,\n    int32 defenderHealth,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (AttackResult memory attackResult) {\n    attackResult = (new AttackResult[](1))[0];\n\n    // generate damage\n    int32 damage = getDamage(attackerInfo.fighterAttributes, random_);\n    damage = increaseMeleeDmgByFactor(damage, attackerInfo);\n    damage = increaseRaceDmg(damage, attackerInfo, defenderInfo.race);\n    attackResult.critical = isCriticalHit(attackerInfo, random_(RESISTANCE_DENOMINATOR.toUint())) ? uint8(1) : uint8(0);\n    damage = attackResult.critical == 0 ? damage : damage * 2;\n\n    // decrease damage\n    damage = decreaseRaceDmg(damage, defenderInfo, attackerInfo.race);\n    damage = decreaseDmgByDmgReduction(damage, defenderInfo);\n\n    attackResult.missed = random_(1e18) > StatLib.chanceToHit(\n      attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)].toUint(),\n      defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DEFENSE)].toUint(),\n      attackerInfo.fighterStats.level,\n      defenderInfo.fighterStats.level,\n      attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.AR_FACTOR)].toUint()\n    ) ? 1 : 0;\n\n    attackResult.blocked = (random_(100) < defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)].toUint()) ? 1 : 0;\n\n    if (attackResult.missed != 0 || attackResult.blocked != 0) {\n      damage = 0;\n    }\n\n    int32 defenderHealthResult = defenderHealth <= damage ? int32(0) : defenderHealth - damage;\n    damage = defenderHealth - defenderHealthResult;\n\n\n    attackResult.defenderHealth = defenderHealthResult;\n    attackResult.damage = damage;\n    attackResult.lifeStolen = lifeStolenPerHit(damage, attackerInfo);\n    attackResult.reflectDamage = reflectMeleeDmg(damage, defenderInfo);\n  }\n\n  function getDamage(\n    int32[] memory attributes,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (int32) {\n    return int32(int(CalcLib.pseudoRandomInRangeFlex(\n      attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)].toUint(),\n      attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)].toUint(),\n      random_\n    )));\n  }\n\n  //endregion ------------------------ Internal logic\n\n  //region ------------------------ Pure utils\n\n  /// @notice Modify values in {targetAttributes} and {casterAttributes} according to {statuses}\n  function reduceAttributesByStatuses(\n    int32[] memory targetAttributes,\n    IFightCalculator.Statuses memory statuses,\n    int32[] memory casterAttributes\n  ) internal pure {\n\n    if (statuses.burn) {\n      targetAttributes[uint(IStatController.ATTRIBUTES.DEFENSE)] -= (targetAttributes[uint(IStatController.ATTRIBUTES.DEFENSE)] / 3);\n      targetAttributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)] += 50;\n      casterAttributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)] += 10;\n      casterAttributes[uint(IStatController.ATTRIBUTES.DESTROY_ITEMS)] += 20;\n    }\n    if (statuses.freeze) {\n      targetAttributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] /= 2;\n      targetAttributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] /= 2;\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] -= targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] / 3;\n      targetAttributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] /= 2;\n      targetAttributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)] += 50;\n    }\n    if (statuses.confuse) {\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] /= 2;\n    }\n    if (statuses.curse) {\n      targetAttributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)] /= 2;\n      targetAttributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)] /= 2;\n      targetAttributes[uint(IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE)] /= 2;\n    }\n    if (statuses.stun) {\n      casterAttributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)] += 10;\n    }\n    if (statuses.poison) {\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] /= 2;\n    }\n\n  }\n\n  /// @notice Calculate new damage value depending on {defenderRace} and value of corresponded DMG_AGAINST_XXX attribute\n  /// @param defenderRace See IStatController.Race\n  /// @return Updated damage value\n  function increaseRaceDmg(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo, uint defenderRace)\n  internal pure returns (int32) {\n    if (defenderRace == uint(IStatController.Race.HUMAN)) {\n      return dmg + attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_HUMAN)] * dmg / RESISTANCE_DENOMINATOR;\n    } else if (defenderRace == uint(IStatController.Race.UNDEAD)) {\n      return dmg + attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_UNDEAD)] * dmg / RESISTANCE_DENOMINATOR;\n    } else if (defenderRace == uint(IStatController.Race.DAEMON)) {\n      return dmg + attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_DAEMON)] * dmg / RESISTANCE_DENOMINATOR;\n    } else if (defenderRace == uint(IStatController.Race.BEAST)) {\n      return dmg + attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_BEAST)] * dmg / RESISTANCE_DENOMINATOR;\n    } else {\n      return dmg;\n    }\n  }\n\n  /// @notice Decrease damage depending on {attackerRace}\n  function decreaseRaceDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo, uint attackerRace) internal pure returns (int32) {\n    if (attackerRace == uint(IStatController.Race.HUMAN)) {\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_HUMAN);\n    } else if (attackerRace == uint(IStatController.Race.UNDEAD)) {\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_UNDEAD);\n    } else if (attackerRace == uint(IStatController.Race.DAEMON)) {\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_DAEMON);\n    } else if (attackerRace == uint(IStatController.Race.BEAST)) {\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_BEAST);\n    } else {\n      return dmg;\n    }\n  }\n\n  /// @notice Calculate damage after Melee-attack\n  function increaseMeleeDmgByFactor(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo) internal pure returns (int32){\n    return dmg + attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MELEE_DMG_FACTOR)] * dmg / RESISTANCE_DENOMINATOR;\n  }\n\n  /// @notice Calculate damage after Magic-attack\n  function increaseMagicDmgByFactor(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo, IItemController.AttackType aType) internal pure returns (int32) {\n    if (aType == IItemController.AttackType.FIRE) {\n      return dmg + dmg * attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.FIRE_DMG_FACTOR)] / RESISTANCE_DENOMINATOR;\n    } else if (aType == IItemController.AttackType.COLD) {\n      return dmg + dmg * attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.COLD_DMG_FACTOR)] / RESISTANCE_DENOMINATOR;\n    } else if (aType == IItemController.AttackType.LIGHTNING) {\n      return dmg + dmg * attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.LIGHTNING_DMG_FACTOR)] / RESISTANCE_DENOMINATOR;\n    } else {\n      return dmg;\n    }\n  }\n\n  /// @notice Reduce damage depending on value of Damage Reduction attribute\n  function decreaseDmgByDmgReduction(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\n    return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DAMAGE_REDUCTION);\n  }\n\n  /// @notice Calculate poison damage < {health}\n  function poisonDmg(int32 health, IFightCalculator.Statuses memory statuses) internal pure returns (int32) {\n    // poison should not kill\n    if (statuses.poison && health.toUint() > 1) {\n      // at least 1 dmg\n      return int32(int(Math.max(health.toUint() / 10, 1)));\n    }\n    return 0;\n  }\n\n  /// @notice Reduce health of the fighters according to attacks results, calc damagePoison, damage and damageReflect.\n  function reduceHp(\n    AttackResult memory firstAttack,\n    AttackResult memory secondAttack,\n    IFightCalculator.Fighter memory firstFighter,\n    IFightCalculator.Fighter memory secondFighter\n  ) internal pure {\n    secondFighter.health = firstAttack.defenderHealth;\n    firstFighter.damage = firstAttack.damage;\n\n    // hit only if second fighter survived\n    if (secondFighter.health != 0) {\n      firstFighter.health = secondAttack.defenderHealth;\n      secondFighter.damage = secondAttack.damage;\n\n      // reflect damage from second to first\n      secondFighter.damageReflect = (CalcLib.minI32(firstAttack.reflectDamage, firstFighter.health));\n      firstFighter.health -= secondFighter.damageReflect;\n\n      // reflect damage from first to second\n      firstFighter.damageReflect = (CalcLib.minI32(secondAttack.reflectDamage, secondFighter.health));\n      secondFighter.health -= firstFighter.damageReflect;\n    }\n\n    // poison second firstly (he got damage and statuses early)\n    firstFighter.damagePoison = poisonDmg(secondFighter.health, secondFighter.statuses);\n    secondFighter.health -= firstFighter.damagePoison;\n\n    // poison first fighter\n    secondFighter.damagePoison = poisonDmg(firstFighter.health, firstFighter.statuses);\n    firstFighter.health -= secondFighter.damagePoison;\n  }\n\n  /// @notice Calculate life-stolen-per-hit value for the given {damage} value\n  function lifeStolenPerHit(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo) internal pure returns (int32) {\n    return dmg * attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.LIFE_STOLEN_PER_HIT)] / RESISTANCE_DENOMINATOR;\n  }\n\n  /// @notice Increase {fighter.health} on the value of life-stolen-per-hit (only if the health > 0)\n  function stealLife(IFightCalculator.Fighter memory fighter, AttackResult memory attackResult) internal pure {\n    if (fighter.health != 0) {\n      int32 newHealth = fighter.health + attackResult.lifeStolen;\n      int32 maxHealth = fighter.info.fighterAttributes[uint(IStatController.ATTRIBUTES.LIFE)];\n      fighter.health = (CalcLib.minI32(newHealth, maxHealth));\n    }\n  }\n\n  function skipTurn(IFightCalculator.FightInfoInternal memory fResult, bool isA) internal pure returns (bool) {\n    return isA ? fResult.fighterA.statuses.stun : fResult.fighterB.statuses.stun;\n  }\n\n  /// @notice Detect which hero is faster and makes the hit first. Magic is faster melee.\n  /// Otherwise first hit is made by the fighter with higher attack rating (A is selected if the ratings are equal)\n  function calcFirstHit(IFightCalculator.FightInfoInternal memory fInfo) internal pure returns (bool aFirst){\n    if (fInfo.fighterA.info.attackType == IFightCalculator.AttackType.MAGIC) {\n      if (fInfo.fighterB.info.attackType == IFightCalculator.AttackType.MAGIC) {\n        // if both fighters use magic we check attack rating\n        aFirst = isAttackerFaster(fInfo.fighterA.info, fInfo.fighterB.info);\n      } else {\n        // otherwise, magic always faster than melee\n        aFirst = true;\n      }\n    } else {\n      if (fInfo.fighterB.info.attackType == IFightCalculator.AttackType.MAGIC) {\n        // if fighter use magic he will be faster\n        aFirst = false;\n      } else {\n        // otherwise, check attack rating\n        aFirst = isAttackerFaster(fInfo.fighterA.info, fInfo.fighterB.info);\n      }\n    }\n  }\n\n  function isAttackerFaster(\n    IFightCalculator.FighterInfo memory fighterAInfo,\n    IFightCalculator.FighterInfo memory fighterBInfo\n  ) internal pure returns (bool) {\n    return fighterAInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)]\n      >= fighterBInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)];\n  }\n\n  function reflectMeleeDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\n    return dmg * defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.REFLECT_DAMAGE_MELEE)] / RESISTANCE_DENOMINATOR;\n  }\n\n  function reflectMagicDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\n    return dmg * defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.REFLECT_DAMAGE_MAGIC)] / RESISTANCE_DENOMINATOR;\n  }\n\n  function _getChance(\n    IFightCalculator.FighterInfo memory attackerInfo,\n    IItemController.AttackType aType,\n    IStatController.ATTRIBUTES index,\n    int32 resist\n  ) internal pure returns (int32 chance) {\n    chance = attackerInfo.fighterAttributes[uint(index)];\n\n    if (attackerInfo.attackType == IFightCalculator.AttackType.MAGIC) {\n      if (index == IStatController.ATTRIBUTES.BURN && aType == IItemController.AttackType.FIRE) {\n        chance += int32(20);\n      }\n      if (index == IStatController.ATTRIBUTES.FREEZE && aType == IItemController.AttackType.COLD) {\n        chance += int32(20);\n      }\n      if (index == IStatController.ATTRIBUTES.CONFUSE && aType == IItemController.AttackType.LIGHTNING) {\n        chance += int32(20);\n      }\n    }\n\n    return chance - chance * (CalcLib.minI32(resist, _MAX_RESIST)) / RESISTANCE_DENOMINATOR;\n  }\n\n  /// @param randomValue Result of call _pseudoRandom, value in the range [0...RESISTANCE_DENOMINATOR)\n  function isCriticalHit(\n    IFightCalculator.FighterInfo memory attackerInfo,\n    uint randomValue\n  ) internal pure returns (bool) {\n    return randomValue < attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)].toUint();\n  }\n\n  /// @param randomValue Result of call CalcLib.pseudoRandom(1e18)\n  function reflectChaos(\n    IItemController.AttackInfo memory magicAttack,\n    IFightCalculator.FighterInfo memory attackerInfo,\n    uint randomValue\n  ) internal pure returns (int32) {\n    return (magicAttack.aType == IItemController.AttackType.CHAOS && randomValue > 5e17)\n      ? int32(attackerInfo.fighterStats.life) / int32(2)\n      : int32(0);\n  }\n\n  function _calcDmgInline(int32 dmg, IFightCalculator.FighterInfo memory info, IStatController.ATTRIBUTES index) internal pure returns (int32) {\n    return dmg * (CalcLib.minI32(info.fighterAttributes[uint(index)], _MAX_RESIST)) / RESISTANCE_DENOMINATOR;\n  }\n\n  function getMagicDamage(\n    IFightCalculator.FighterInfo memory attackerInfo,\n    IItemController.AttackInfo memory mAttack,\n    uint randomValue_\n  ) internal pure returns (int32) {\n\n    int32 attributeFactorResult = (attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.STRENGTH)] * mAttack.attributeFactors.strength / 100);\n    attributeFactorResult += (attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DEXTERITY)] * mAttack.attributeFactors.dexterity / 100);\n    attributeFactorResult += (attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.VITALITY)] * mAttack.attributeFactors.vitality / 100);\n    attributeFactorResult += (attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.ENERGY)] * mAttack.attributeFactors.energy / 100);\n\n    return int32(int(randomValue_)) + attributeFactorResult;\n  }\n  //endregion ------------------------ Pure utils\n\n  //region ------------------------ SIP-002\n\n  /// @notice SIP-002: Implement smooth increase that approaches to y0 but never reaches that value\n  /// @dev https://discord.com/channels/1134537718039318608/1265261881652674631\n  /// @param y0 is desired capacity, 90 for resists/defs, 100 for critical hit and statuses\n  /// @param x current value, base attribute. Assume x >= 0\n  /// @param k is the factor of how fast the value will reach 90 capacity, k=100 by default\n  /// @return new attribute value that is used in calculations, decimals 18\n  function getReducedValue(uint y0, uint x, uint k) internal pure returns (uint) {\n    // 2^n = exp(ln(2^n)) = exp(n * ln2)\n    int t = FixedPointMathLib.expWad(-int(x) * LN2 / int(k));\n    return t < 0\n      ? 0 // some mistake happens (???)\n      : y0 * (1e18 - uint(t));\n  }\n\n  /// @notice Apply {getReducedValue} to the given attribute, change value in place\n  function adjustAttributeValue(int32[] memory attributes, IStatController.ATTRIBUTES a, uint y0, uint k) internal pure {\n    attributes[uint(a)] = attributes[uint(a)] <= 0\n      ? int32(0) // negative values => 0\n      : int32(int(getReducedValue(y0, uint(int(attributes[uint(a)])), k) / 1e18));\n  }\n\n  /// @notice Apply {getReducedValue} to the selected set of the attributes, change values in place\n  function adjustAttributes(int32[] memory attributes) internal pure {\n    // use CAPACITY_RESISTS_DEFS, K_FACTOR\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.BLOCK_RATING, CAPACITY_RESISTS_DEFS, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.FIRE_RESISTANCE, CAPACITY_RESISTS_DEFS, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.COLD_RESISTANCE, CAPACITY_RESISTS_DEFS, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE, CAPACITY_RESISTS_DEFS, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.DEF_AGAINST_HUMAN, CAPACITY_RESISTS_DEFS, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.DEF_AGAINST_UNDEAD, CAPACITY_RESISTS_DEFS, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.DEF_AGAINST_DAEMON, CAPACITY_RESISTS_DEFS, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.DEF_AGAINST_BEAST, CAPACITY_RESISTS_DEFS, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.DAMAGE_REDUCTION, CAPACITY_RESISTS_DEFS, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.RESIST_TO_STATUSES, CAPACITY_RESISTS_DEFS, K_FACTOR);\n\n    // use CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.CRITICAL_HIT, CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.STUN, CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.BURN, CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.FREEZE, CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.CONFUSE, CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.CURSE, CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR);\n    adjustAttributeValue(attributes, IStatController.ATTRIBUTES.POISON, CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR);\n  }\n  //endregion ------------------------ SIP-002\n\n}\n"
    },
    "contracts/lib/GameObjectControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../interfaces/IGOC.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../proxy/Controllable.sol\";\nimport \"../lib/PackingLib.sol\";\nimport \"../lib/EventLib.sol\";\nimport \"../lib/StoryLib.sol\";\nimport \"../lib/MonsterLib.sol\";\nimport \"../lib/GOCLib.sol\";\n\nlibrary GameObjectControllerLib {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using PackingLib for bytes32;\n  using PackingLib for uint16;\n  using PackingLib for uint8;\n  using PackingLib for address;\n  using PackingLib for uint32[];\n  using PackingLib for uint32;\n  using PackingLib for uint64;\n  using PackingLib for int32[];\n  using PackingLib for int32;\n\n  //region ------------------------ CONSTANTS\n  /// @dev keccak256(abi.encode(uint256(keccak256(\"game.object.controller.main\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0xfa9e067a92ca4a9057b7b4465a8f29d633e1758238bd3a4a8ec5d0f904f6b900;\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ RESTRICTIONS\n\n  function onlyDeployer(IController controller) internal view {\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\n  }\n\n  function onlyDungeonFactory(IController c) internal view {\n    if (c.dungeonFactory() != msg.sender) revert IAppErrors.ErrorNotDungeonFactory(msg.sender);\n  }\n  //endregion ------------------------ RESTRICTIONS\n\n  //region ------------------------ VIEWS\n\n  function _S() internal pure returns (IGOC.MainState storage s) {\n    assembly {\n      s.slot := MAIN_STORAGE_LOCATION\n    }\n    return s;\n  }\n\n  function getObjectMeta(uint32 objectId) internal view returns (uint8 biome, uint8 objectSubType) {\n    return GOCLib.unpackObjectMeta(_S().objectMeta[objectId]);\n  }\n\n  function isAvailableForHero(IController controller, address heroToken, uint heroTokenId, uint32 objId) internal view returns (bool) {\n    (, uint8 objectSubType) = getObjectMeta(objId);\n    return GOCLib.isAvailableForHero(IStoryController(controller.storyController()), objId, objectSubType, heroToken, heroTokenId);\n  }\n\n  function isBattleObject(uint32 objectId) internal view returns (bool) {\n    (,uint8 objectSubType) = GOCLib.unpackObjectMeta(_S().objectMeta[objectId]);\n    return GOCLib.getObjectTypeBySubType(IGOC.ObjectSubType(objectSubType)) == IGOC.ObjectType.MONSTER;\n  }\n\n  function getObjectTypeBySubType(uint32 objectId) internal view returns (IGOC.ObjectType) {\n    (,uint8 objectSubType) = GOCLib.unpackObjectMeta(_S().objectMeta[objectId]);\n    return GOCLib.getObjectTypeBySubType(IGOC.ObjectSubType(objectSubType));\n  }\n\n  function getMonsterInfo(address hero, uint heroId, uint32 objectId) internal view returns (IGOC.MonsterGenInfo memory mGenInfo, IGOC.GeneratedMonster memory gen) {\n    uint iteration = _S().iterations[hero.packIterationKey(uint64(heroId), objectId)];\n    mGenInfo = MonsterLib.unpackMonsterInfo(_S().monsterInfos[objectId]);\n    gen = MonsterLib.unpackGeneratedMonster(_S().monsterInfos[objectId]._generatedMonsters[hero.packNftId(heroId)][iteration]);\n  }\n\n  function getIteration(address heroToken, uint heroTokenId, uint32 objId) internal view returns (uint) {\n    return _S().iterations[_iterationKey(heroToken, heroTokenId, objId)];\n  }\n\n  function getLastHeroFightTs(address heroToken, uint heroTokenId) internal view returns (uint) {\n    return _S().lastHeroFightTs[heroToken.packNftId(heroTokenId)];\n  }\n\n  function getFightDelay() internal view returns (uint) {\n    return _S().fightDelay;\n  }\n\n  function getStoryId(uint32 objectId) internal view returns (uint16) {\n    return _S().storyIds[objectId];\n  }\n\n  function getEventInfo(uint32 objectId) internal view returns (IGOC.EventInfo memory) {\n    return _S().eventInfos[objectId];\n  }\n\n  function getObjectIds(uint8 biome, IGOC.ObjectSubType subType) internal view returns (uint[] memory) {\n    return _S().objectIds[GOCLib.packObjectMeta(biome, uint8(subType))].values();\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ REGISTRATION\n\n  function registerEvent(IController controller, IGOC.EventRegInfo memory regInfo) internal {\n    onlyDeployer(controller);\n    _checkMintItems(regInfo.mintItems, regInfo.mintItemsChances);\n    uint32 objectId = _registerMetaId(regInfo.biome, regInfo.subType, regInfo.eventId);\n    EventLib.eventRegInfoToInfo(regInfo, _S().eventInfos[objectId]);\n    emit IApplicationEvents.EventRegistered(objectId, regInfo);\n  }\n\n  function registerStory(IController controller, uint16 storyId, uint8 biome, IGOC.ObjectSubType subType) internal {\n    onlyDeployer(controller);\n    uint32 objectId = _registerMetaId(biome, subType, storyId);\n    _S().storyIds[objectId] = storyId;\n    emit IApplicationEvents.StoryRegistered(objectId, storyId);\n  }\n\n  function registerMonster(IController controller, IGOC.MonsterGenInfo memory monsterGenInfo) internal {\n    onlyDeployer(controller);\n    _checkMintItems(monsterGenInfo.mintItems, monsterGenInfo.mintItemsChances);\n    uint32 objectId = _registerMetaId(monsterGenInfo.biome, monsterGenInfo.subType, monsterGenInfo.monsterId);\n\n    delete _S().monsterInfos[objectId];\n\n    MonsterLib.packMonsterInfo(monsterGenInfo, _S().monsterInfos[objectId]);\n    emit IApplicationEvents.MonsterRegistered(objectId, monsterGenInfo);\n  }\n\n  function removeObject(IController controller, uint32 objectId) internal {\n    onlyDeployer(controller);\n    bytes32 meta = _S().objectMeta[objectId];\n    delete _S().objectMeta[objectId];\n    _S().objectIds[meta].remove(objectId);\n\n    emit IApplicationEvents.ObjectRemoved(objectId);\n  }\n  //endregion ------------------------ REGISTRATION\n\n  //region ------------------------ OBJECT ACTIONS\n\n  /// @param cTypes Array of object subtypes, see IGOC.ObjectSubType.XXX\n  /// @param chances Chances in range 0-1e9, chances are corresponded to {cTypes} array\n  function getRandomObject(\n    IController c,\n    uint8[] memory cTypes,\n    uint32[] memory chances,\n    uint8 biome,\n    address heroToken,\n    uint heroTokenId\n  ) internal returns (uint32 objectId) {\n    onlyDungeonFactory(c);\n    return GOCLib.getRandomObject(\n      _S(),\n      IStoryController(c.storyController()),\n      cTypes,\n      chances,\n      biome,\n      heroToken,\n      heroTokenId\n    );\n  }\n\n  /// @notice Open {object}: increase iteration, [generate monsters]\n  function open(IController c, address heroToken, uint heroTokenId, uint32 objectId) internal returns (uint iteration) {\n    onlyDungeonFactory(c);\n\n    iteration = _increaseIteration(heroToken, heroTokenId, objectId);\n\n    (, uint8 objectSubType) = getObjectMeta(objectId);\n    uint8 t = uint8(GOCLib.getObjectTypeBySubType(IGOC.ObjectSubType(objectSubType)));\n\n    if (t == uint8(IGOC.ObjectType.EVENT)) {\n      // noop\n    } else if (t == uint8(IGOC.ObjectType.MONSTER)) {\n      MonsterLib.initialGeneration(_S().monsterInfos[objectId], heroToken, heroTokenId, iteration, IERC20(c.gameToken()).totalSupply());\n    } else if (t == uint8(IGOC.ObjectType.STORY)) {\n      // noop\n    } else {\n      revert IAppErrors.UnknownObjectTypeGocLib1(t);\n    }\n  }\n\n  /// @notice Execute event/story/monster action\n  /// @param data Object type-specified data packed using abi.encode.\n  /// For events: bool (accept / not accept results)\n  /// For monsters: AttackInfo\n  /// For story: bytes32 (answer id)\n  function action(\n    IController c,\n    address sender,\n    uint64 dungeonId,\n    uint32 objectId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 stageId,\n    bytes memory data\n  ) internal returns (IGOC.ActionResult memory) {\n    onlyDungeonFactory(c);\n\n    IGOC.ActionContext memory ctx;\n\n    ctx.objectId = objectId;\n    ctx.sender = sender;\n    ctx.heroToken = heroToken;\n    ctx.heroTokenId = heroTokenId;\n    ctx.stageId = stageId;\n    ctx.data = data;\n    (ctx.biome, ctx.objectSubType) = getObjectMeta(objectId);\n\n    ctx.dungeonId = dungeonId;\n    ctx.iteration = _S().iterations[_iterationKey(heroToken, heroTokenId, objectId)];\n    ctx.controller = c;\n\n    IGOC.ActionResult memory r;\n    uint8 t = uint8(GOCLib.getObjectTypeBySubType(IGOC.ObjectSubType(ctx.objectSubType)));\n    ctx.salt = block.number;\n\n    if (t == uint8(IGOC.ObjectType.EVENT)) {\n      r = EventLib.action(ctx, _S().eventInfos[objectId]);\n    } else if (t == uint8(IGOC.ObjectType.MONSTER)) {\n      _checkAndRefreshFightTs(heroToken, heroTokenId);\n      (r, ctx.salt) = MonsterLib.action(ctx, _S().monsterInfos[objectId]);\n    } else if (t == uint8(IGOC.ObjectType.STORY)) {\n      r = StoryLib.action(ctx, _S().storyIds[objectId]);\n    } else {\n      revert IAppErrors.UnknownObjectTypeGocLib2(t);\n    }\n\n    r.objectId = ctx.objectId;\n    r.heroToken = heroToken;\n    r.heroTokenId = heroTokenId;\n    r.iteration = ctx.iteration;\n\n\n    emit IApplicationEvents.ObjectResultEvent(\n      dungeonId,\n      objectId,\n      IGOC.ObjectType(t),\n      heroToken,\n      heroTokenId,\n      stageId,\n      ctx.iteration,\n      data,\n      r,\n      ctx.salt\n    );\n    return r;\n  }\n//endregion ------------------------ OBJECT ACTIONS\n\n  //region ------------------------ Utils\n\n  /// @notice Generate object ID using (biome, subType, id)\n  /// @param biome Biome to which the object belongs. [1..99]\n  /// @param subType Subtype of the object, see IGOC.ObjectSubType.XXX. [1..99]\n  /// @param id Id of the event / story / monster. [1..10_000]\n  function _genObjectId(uint8 biome, uint8 subType, uint16 id) internal pure returns (uint32 objectId) {\n    if (biome == 0 || subType == 0 || id == 0) revert IAppErrors.ZeroValueNotAllowed();\n    if (biome >= 100) revert IAppErrors.GenObjectIdBiomeOverflow(biome);\n    if (uint(subType) >= 100) revert IAppErrors.GenObjectIdSubTypeOverflow(subType);\n    if (id > 10_000) revert IAppErrors.GenObjectIdIdOverflow(id);\n    objectId = uint32(biome) * 1_000_000 + uint32(subType) * 10_000 + uint32(id);\n  }\n\n  /// @notice Register the object in objectMeta and objectIds\n  /// @param biome Biome to which the object belongs. [1..99]\n  /// @param subType Subtype of the object, [1..99]\n  /// @param id Id of the event / story / monster. [1..10_000]\n  /// @return objectId Object id generated by {_genObjectId}\n  function _registerMetaId(uint8 biome, IGOC.ObjectSubType subType, uint16 id) internal returns (uint32 objectId) {\n    IGOC.MainState storage s = _S();\n    objectId = _genObjectId(biome, uint8(subType), id);\n    bytes32 meta = GOCLib.packObjectMeta(biome, uint8(subType));\n    s.objectMeta[objectId] = meta;\n    s.objectIds[meta].add(objectId);\n  }\n\n  /// @notice Update last-hero-fight-timestamp\n  function _checkAndRefreshFightTs(address heroToken, uint heroTokenId) internal {\n    IGOC.MainState storage s = _S();\n    bytes32 key = heroToken.packNftId(heroTokenId);\n    if (s.lastHeroFightTs[key] + s.fightDelay > block.timestamp) revert IAppErrors.FightDelay();\n    s.lastHeroFightTs[key] = block.timestamp;\n  }\n\n  function _increaseIteration(address heroToken, uint heroTokenId, uint32 objId) internal returns (uint iteration) {\n    IGOC.MainState storage s = _S();\n    bytes32 key = _iterationKey(heroToken, heroTokenId, objId);\n    iteration = s.iterations[key] + 1;\n    s.iterations[key] = iteration;\n  }\n\n  function _iterationKey(address heroToken, uint heroTokenId, uint32 objId) internal pure returns (bytes32) {\n    return heroToken.packIterationKey(uint64(heroTokenId), objId);\n  }\n\n  /// @notice Validate passed {mintItems_} and {mintItemsChances_}\n  function _checkMintItems(address[] memory mintItems_, uint32[] memory mintItemsChances_) internal pure {\n    uint length = mintItems_.length;\n    if (mintItemsChances_.length != length) revert IAppErrors.LengthsMismatch();\n\n    for (uint i; i < length; ++i) {\n      if (mintItems_[i] == address(0)) revert IAppErrors.ZeroAddress();\n      if (mintItemsChances_[i] == 0) revert IAppErrors.ZeroChance();\n      if (mintItemsChances_[i] > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighChance(mintItemsChances_[i]);\n    }\n  }\n  //endregion ------------------------ Utils\n}\n"
    },
    "contracts/lib/GOCLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IGOC.sol\";\nimport \"../interfaces/IStoryController.sol\";\nimport \"./CalcLib.sol\";\nimport \"./PackingLib.sol\";\n\nlibrary GOCLib {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using PackingLib for address;\n\n  /// @param cTypes Array of object subtypes, see IGOC.ObjectSubType.XXX\n  /// @param chances Chances in range 0-1e9, chances are corresponded to {cTypes} array\n  function getRandomObject(\n    IGOC.MainState storage s,\n    IStoryController sc,\n    uint8[] memory cTypes,\n    uint32[] memory chances,\n    uint8 biome,\n    address heroToken,\n    uint heroTokenId\n  ) internal returns (uint32 objectId) {\n\n    uint8 cType = _getObjectType(cTypes, chances, CalcLib.pseudoRandom);\n\n    EnumerableSet.UintSet storage objects = s.objectIds[packObjectMeta(biome, cType)];\n    uint len = objects.length();\n    if (len == 0) revert IAppErrors.EmptyObjects();\n    uint objectArrayIdx = len == 1\n      ? 0\n      : CalcLib.pseudoRandom(len - 1);\n\n    EnumerableSet.UintSet storage played = s.playedObjects[heroToken.packPlayedObjKey(uint64(heroTokenId), cType, biome)];\n    objectId = _searchObject(sc, len, objects, played, objectArrayIdx, false, heroToken, heroTokenId, cType);\n\n    if (objectId == 0) revert IAppErrors.ObjectNotFound();\n    played.add(objectId);\n  }\n\n  /// @notice Select cType using pseudo-random value according to the given {chances}\n  /// @param cTypes Zero values are ignored.\n  /// @param chances [0..100], decimals 9. At least once item should have value 100 to avoid {UnknownObjectType} error.\n  /// @param random_ CalcLib.pseudoRandom, required for unit tests\n  function _getObjectType(\n    uint8[] memory cTypes,\n    uint32[] memory chances,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (uint8 cType) {\n    uint len = cTypes.length;\n    if (len == 0 || len != chances.length) revert IAppErrors.WrongGetObjectTypeInput();\n\n    if (len == 1) {\n      cType = cTypes[0];\n    } else {\n      uint random = random_(CalcLib.MAX_CHANCE);\n      uint minChance = CalcLib.MAX_CHANCE + 1;\n      for (uint i; i < len; ++i) {\n        // obj set can contain empty values, ignore them\n        if (cTypes[i] == 0) continue;\n        if (chances[i] > CalcLib.MAX_CHANCE) revert IAppErrors.WrongChances(chances[i], CalcLib.MAX_CHANCE);\n        if ((CalcLib.MAX_CHANCE - chances[i]) <= random) {\n          if (chances[i] < minChance) {\n            minChance = chances[i];\n            cType = cTypes[i];\n          }\n        }\n      }\n    }\n\n    if (cType == 0) revert IAppErrors.UnknownObjectTypeGoc1(0);\n    return cType;\n  }\n\n  /// @notice Find first object in {objects} available for the hero starting from {objArrayIdx}\n  /// If object not found clear {played} and try to search again.\n  /// @param lenObjects Length of {objects}\n  /// @param objArrayIdx Start index in objects\n  /// @param cType Object subtype\n  /// @param skipPlayed true - don't check if the found object was already played\n  /// @return objectId ID of the found object or 0 if the object is not found\n  function _searchObject(\n    IStoryController sc,\n    uint lenObjects,\n    EnumerableSet.UintSet storage objects,\n    EnumerableSet.UintSet storage played,\n    uint objArrayIdx,\n    bool skipPlayed,\n    address heroToken,\n    uint heroTokenId,\n    uint8 cType\n  ) internal returns (uint32 objectId) {\n\n    // clear played objects if we played them all at the current biome\n    if (played.length() >= lenObjects) {\n      skipPlayed = true;\n      _clearPlayedObjects(played);\n    }\n\n    bool foundValid;\n\n    unchecked {\n    // search in a loop available objects\n      for (uint i; i < lenObjects; ++i) {\n        if (objArrayIdx >= lenObjects) {\n          objArrayIdx = 0;\n        }\n        uint32 objId = uint32(objects.at(objArrayIdx));\n        if (\n          isAvailableForHero(sc, objId, cType, heroToken, heroTokenId)\n          && (skipPlayed || !played.contains(objId))\n        ) {\n          foundValid = true;\n          objectId = objId;\n          break;\n        }\n\n        ++objArrayIdx;\n      }\n    }\n    // in case when we do not have available objects it is possible they are not eligible and need to reset counter\n    if (!foundValid && !skipPlayed) {\n      _clearPlayedObjects(played);\n      objectId = _searchObject(sc, lenObjects, objects, played, objArrayIdx, true, heroToken, heroTokenId, cType);\n    }\n\n    return objectId;\n  }\n\n  function _clearPlayedObjects(EnumerableSet.UintSet storage played) internal {\n    uint[] memory values = played.values();\n    for (uint i; i < values.length; ++i) {\n      played.remove(values[i]);\n    }\n  }\n\n  /// @notice Check if the object subtype is available for the hero\n  function isAvailableForHero(IStoryController sc, uint32 objId, uint8 objectSubType, address hero, uint heroId) internal view returns (bool) {\n    IGOC.ObjectType objType = getObjectTypeBySubType(IGOC.ObjectSubType(objectSubType));\n    if (objType == IGOC.ObjectType.EVENT) {\n      // no checks\n      return true;\n    } else if (objType == IGOC.ObjectType.MONSTER) {\n      // no checks\n      return true;\n    } else if (objType == IGOC.ObjectType.STORY) {\n      return sc.isStoryAvailableForHero(objId, hero, heroId);\n    } else {\n      // actually, this case is impossible, getObjectTypeBySubType will revert above if objectSubType is incorrect\n      revert IAppErrors.UnknownObjectTypeForSubtype(objectSubType);\n    }\n  }\n\n  function packObjectMeta(uint8 biome, uint8 oType) internal pure returns (bytes32) {\n    return PackingLib.packUint8Array3(biome, oType, 0);\n  }\n\n  function unpackObjectMeta(bytes32 data) internal pure returns (uint8 biome, uint8 oType) {\n    (biome, oType,) = PackingLib.unpackUint8Array3(data);\n  }\n\n  /// @notice Get object type for the given {subType}\n  function getObjectTypeBySubType(IGOC.ObjectSubType subType) internal pure returns (IGOC.ObjectType) {\n    if (\n      subType == IGOC.ObjectSubType.SHRINE_4\n      || subType == IGOC.ObjectSubType.CHEST_5\n      || subType == IGOC.ObjectSubType.SHRINE_UNIQUE_8\n    ) {\n      return IGOC.ObjectType.EVENT;\n    } else if (\n      subType == IGOC.ObjectSubType.ENEMY_NPC_1\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_SUPER_RARE_2\n      || subType == IGOC.ObjectSubType.BOSS_3\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_UNIQUE_10\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_INSIDE_32\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_INSIDE_RARE_33\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_OUTSIDE_34\n      || subType == IGOC.ObjectSubType.ENEMY_NPC_OUTSIDE_RARE_35\n    ) {\n      return IGOC.ObjectType.MONSTER;\n    } else if (\n      subType == IGOC.ObjectSubType.STORY_6\n      || subType == IGOC.ObjectSubType.STORY_UNIQUE_7\n      || subType == IGOC.ObjectSubType.STORY_ON_ROAD_11\n      || subType == IGOC.ObjectSubType.STORY_UNDERGROUND_12\n      || subType == IGOC.ObjectSubType.STORY_NIGHT_CAMP_13\n      || subType == IGOC.ObjectSubType.STORY_MOUNTAIN_14\n      || subType == IGOC.ObjectSubType.STORY_WATER_15\n      || subType == IGOC.ObjectSubType.STORY_CASTLE_16\n      || subType == IGOC.ObjectSubType.STORY_HELL_17\n      || subType == IGOC.ObjectSubType.STORY_SPACE_18\n      || subType == IGOC.ObjectSubType.STORY_WOOD_19\n      || subType == IGOC.ObjectSubType.STORY_CATACOMBS_20\n      || subType == IGOC.ObjectSubType.STORY_BAD_HOUSE_21\n      || subType == IGOC.ObjectSubType.STORY_GOOD_TOWN_22\n      || subType == IGOC.ObjectSubType.STORY_BAD_TOWN_23\n      || subType == IGOC.ObjectSubType.STORY_BANDIT_CAMP_24\n      || subType == IGOC.ObjectSubType.STORY_BEAST_LAIR_25\n      || subType == IGOC.ObjectSubType.STORY_PRISON_26\n      || subType == IGOC.ObjectSubType.STORY_SWAMP_27\n      || subType == IGOC.ObjectSubType.STORY_INSIDE_28\n      || subType == IGOC.ObjectSubType.STORY_OUTSIDE_29\n      || subType == IGOC.ObjectSubType.STORY_INSIDE_RARE_30\n      || subType == IGOC.ObjectSubType.STORY_OUTSIDE_RARE_31\n    ) {\n      return IGOC.ObjectType.STORY;\n    } else {\n      revert IAppErrors.UnknownObjectTypeGoc2(uint8(subType));\n    }\n  }\n}\n"
    },
    "contracts/lib/GuildControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IGuildController.sol\";\nimport \"../interfaces/IHeroTokensVault.sol\";\nimport \"../lib/StringLib.sol\";\n\nlibrary GuildControllerLib {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  //region ------------------------ Constants\n  /// @dev keccak256(abi.encode(uint256(keccak256(\"guild.controller.main\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant GUILD_CONTROLLER_STORAGE_LOCATION = 0x1c4340ff8478a236ed13a5ce46f8e8b8a6037975df340a04c54725978699d100;\n  uint8 internal constant FIRST_LEVEL = 1;\n  uint8 internal constant MAX_LEVEL = 10;\n  /// @notice Fee for creation guild, renaming, etc. In SACRA (decimals 18)\n  uint internal constant BASE_FEE = 10_000e18;\n  uint internal constant MAX_GUILD_MEMBERS_ON_LEVEL_1 = 25;\n  uint internal constant MAX_GUILD_MEMBERS_INC_PER_LEVEL = 5;\n  //endregion ------------------------ Constants\n\n  //region ------------------------ Restrictions\n  function _onlyEoa(bool isEoa) internal pure {\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\n  }\n  //endregion ------------------------ Restrictions\n\n  //region ------------------------ Storage\n\n  function _S() internal pure returns (IGuildController.MainState storage s) {\n    assembly {\n      s.slot := GUILD_CONTROLLER_STORAGE_LOCATION\n    }\n    return s;\n  }\n  //endregion ------------------------ Storage\n\n  //region ------------------------ VIEWS\n  function counterGuildIds() internal view returns (uint) {\n    return _S().counterGuildIds;\n  }\n\n  function getGuildData(uint guildId) internal view returns (IGuildController.GuildData memory) {\n    return _S().guildData[guildId];\n  }\n\n  function getGuildByName(string memory name) internal view returns (uint guildId) {\n    return _S().nameToGuild[name];\n  }\n\n  function memberOf(address user) internal view returns (uint guildId) {\n    return _S().memberToGuild[user];\n  }\n\n  function guildMembers(uint guildId) internal view returns (address[] memory) {\n    return _S().members[guildId].values();\n  }\n\n  function getRights(address user) internal view returns (uint) {\n    return _S().rights[user];\n  }\n\n  function isPeacefulRelation(uint guildId, uint guildId2) internal view returns (bool) {\n    return _S().relationsPeaceful[_getGuildsPairKey(guildId, guildId2)];\n  }\n\n  function getBiomeOwner(uint8 biome) internal view returns (uint guildId) {\n    return _S().biomeOwner[biome];\n  }\n\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ ACTIONS\n\n  /// @notice Generate id for new guild, increment id-counter\n  function _generateGuildId() internal returns (uint uid) {\n    uid = _S().counterGuildIds + 1;\n    _S().counterGuildIds = uid;\n  }\n\n  /// @notice Create new guild, return ID of the new guild\n  function createGuild(bool isEoa, IController controller, address msgSender, string memory name, string memory urlLogo) internal returns (uint) {\n    _onlyEoa(isEoa);\n\n    // user can be a member of a single guild only\n    if (_S().memberToGuild[msgSender] != 0) revert IAppErrors.AlreadyGuildMember();\n\n    // check guild name\n    if (_S().nameToGuild[name] != 0) revert IAppErrors.NameTaken();\n    if (bytes(name).length >= 20) revert IAppErrors.TooBigName();\n    if (!StringLib.isASCIILettersOnly(name)) revert IAppErrors.WrongSymbolsInTheName();\n    if (bytes(name).length == 0) revert IAppErrors.EmptyNameNotAllowed();\n\n    // check logo url, empty logo and duplicates are allowed\n    if (bytes(urlLogo).length >= 150) revert IAppErrors.TooLongUrl();\n\n    uint guildId = _generateGuildId();\n    IGuildController.GuildData memory guildData = IGuildController.GuildData({\n      owner: msgSender,\n      urlLogo: urlLogo,\n      guildName: name,\n      guildLevel: FIRST_LEVEL,\n      pvpCounter: 0\n    });\n\n    _S().guildData[guildId] = guildData;\n    _S().nameToGuild[name] = guildId;\n\n    _S().members[guildId].add(msgSender);\n    _S().memberToGuild[msgSender] = guildId;\n    _S().rights[msgSender] = _getMaskRights(IGuildController.GuildRightBits.ADMIN_0);\n\n    // pay base fee for guild creation\n    IHeroTokensVault(IHeroController(controller.heroController()).heroTokensVault()).process(controller.gameToken(), BASE_FEE, msgSender);\n\n    emit IApplicationEvents.GuildCreated(guildData.owner, guildId, guildData.guildName, guildData.urlLogo);\n\n    return guildId;\n  }\n\n  /// @notice Add new member to the guild to which msgSender belongs\n  function addGuildMember(address msgSender, address newUser, uint maskRights) internal {\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.ADD_MEMBER_4);\n    IGuildController.GuildData memory guildData = _S().guildData[guildId];\n\n    if (_S().memberToGuild[newUser] != 0) revert IAppErrors.AlreadyGuildMember();\n    if (newUser == address(0)) revert IAppErrors.ZeroAddress();\n\n    uint guildSize = _S().members[guildId].length();\n    if (guildSize == _getMaxMembersNumber(guildData.guildLevel)) revert IAppErrors.GuildHasMaxSize(guildSize);\n\n    _S().members[guildId].add(newUser);\n    _S().memberToGuild[newUser] = guildId;\n    _S().rights[newUser] = maskRights;\n\n    emit IApplicationEvents.AddToGuild(guildId, newUser);\n  }\n\n  /// @notice Edit roles of the given member of the guild to which msgSender belongs\n  function changeRoles(address msgSender, address user, uint maskRights) internal {\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.CHANGE_ROLES_7);\n\n    if (!_S().members[guildId].contains(user)) revert IAppErrors.NotGuildMember();\n\n    // don't allow to remove admin rights\n    IGuildController.GuildData memory guildData = _S().guildData[guildId];\n    if (guildData.owner == user) {\n      maskRights |= _getMaskRights(IGuildController.GuildRightBits.ADMIN_0);\n    }\n\n    _S().rights[user] = maskRights;\n\n    emit IApplicationEvents.ChangeGuildRights(guildId, user, maskRights);\n  }\n\n  /// @notice Remove given member from the guild to which msgSender belongs\n  /// @dev To delete the guild the owner should remove all members and remove himself at the end\n  function removeGuildMember(address msgSender, address userToRemove) internal {\n    uint guildId;\n    if (msgSender == userToRemove) {\n      guildId = _S().memberToGuild[msgSender]; // user is always able to remove himself from a guild\n      if (guildId == 0) revert IAppErrors.NotGuildMember();\n    } else {\n      (guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.REMOVE_MEMBER_5);\n      if (userToRemove == address(0)) revert IAppErrors.ZeroAddress();\n    }\n\n    IGuildController.GuildData memory guildData = _S().guildData[guildId];\n    if (guildData.owner == userToRemove) {\n      // owner can only be removed last\n      if (_S().members[guildId].length() > 1) revert IAppErrors.CannotRemoveGuildOwnerFromNotEmptyGuild();\n    }\n\n    _S().members[guildId].remove(userToRemove);\n    delete _S().memberToGuild[userToRemove];\n    delete _S().rights[userToRemove];\n\n    uint guildSize = _S().members[guildId].length();\n    if (guildSize == 0) {\n      // Last member has left the guild, delete the guild\n\n      delete _S().nameToGuild[guildData.guildName];\n      delete _S().guildData[guildId];\n      delete _S().members[guildId];\n\n      // todo free guild house if any\n    }\n\n    emit IApplicationEvents.RemoveFromGuild(guildId, userToRemove);\n  }\n\n  /// @notice Increment level of the guild, pay BASE_FEE * new level\n  function guildLevelUp(IController controller, address msgSender) internal {\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.LEVEL_UP_8);\n\n    IGuildController.GuildData memory guildData = _S().guildData[guildId];\n    if (guildData.guildLevel == MAX_LEVEL) revert IAppErrors.GuildHasMaxLevel(guildData.guildLevel);\n\n    // level up\n    guildData.guildLevel++;\n    _S().guildData[guildId] = guildData;\n\n    // pay for level up\n    uint fee = BASE_FEE * guildData.guildLevel;\n    IHeroTokensVault(IHeroController(controller.heroController()).heroTokensVault()).process(controller.gameToken(), fee, msgSender);\n\n    emit IApplicationEvents.GuildLevelUp(guildId, guildData.guildLevel);\n  }\n\n  /// @notice Rename the guild, pay BASE_FEE\n  function rename(IController controller, address msgSender, string memory newGuildName) internal {\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.RENAME_1);\n\n    // rename\n    IGuildController.GuildData memory guildData = _S().guildData[guildId];\n    guildData.guildName = newGuildName;\n    _S().guildData[guildId] = guildData;\n\n    // pay for renaming\n    IHeroTokensVault(IHeroController(controller.heroController()).heroTokensVault()).process(controller.gameToken(), BASE_FEE, msgSender);\n\n    emit IApplicationEvents.GuildRename(guildId, newGuildName);\n  }\n\n  /// @notice Set relation between two guilds\n  function setRelation(address msgSender, uint otherGuildId, bool peace) internal {\n    (uint guildId,) = _checkPermissions(msgSender, IGuildController.GuildRightBits.SET_RELATION_KIND_9);\n\n    // todo check alliances: it's not allowed to set war-relation to the co-member of the alliance\n\n    _S().relationsPeaceful[_getGuildsPairKey(guildId, otherGuildId)] = peace;\n    emit IApplicationEvents.SetGuildRelation(guildId, otherGuildId, peace);\n  }\n  //endregion ------------------------ ACTIONS\n\n  //region ------------------------ Internal logic\n  function _checkPermissions(address user, IGuildController.GuildRightBits right) internal view returns (uint guildId, uint rights) {\n    guildId = _S().memberToGuild[user];\n    rights = _S().rights[user];\n\n    if (guildId == 0) revert IAppErrors.NotGuildMember();\n\n    if (!(\n      (rights & (2**uint(IGuildController.GuildRightBits.ADMIN_0))) != 0\n      || (rights & (2**uint(right))) != 0\n    )) {\n      revert IAppErrors.GuildActionForbidden(uint(right));\n    }\n  }\n\n  function _getMaxMembersNumber(uint8 guildLevel) internal pure returns (uint) {\n    return MAX_GUILD_MEMBERS_ON_LEVEL_1 + (guildLevel - 1) * MAX_GUILD_MEMBERS_INC_PER_LEVEL;\n  }\n\n  /// @notice Generate unique pair key for (G1, G2). Guarantee that F(G1, G2) == F(G2, G1)\n  function _getGuildsPairKey(uint guildId1, uint guildId2) internal pure returns (bytes32) {\n    return guildId1 < guildId2\n      ? keccak256(abi.encodePacked(guildId1, guildId2))\n      : keccak256(abi.encodePacked(guildId2, guildId1));\n  }\n\n  /// @notice Generate mask-rights with given permission\n  function _getMaskRights(IGuildController.GuildRightBits right) internal pure returns (uint) {\n    return 2 ** uint(right);\n  }\n\n  //endregion ------------------------ Internal logic\n}\n"
    },
    "contracts/lib/HeroControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../proxy/Controllable.sol\";\nimport \"../relay/ERC2771Context.sol\";\nimport \"../lib/HeroLib.sol\";\nimport \"../lib/PackingLib.sol\";\nimport \"../lib/ScoreLib.sol\";\nimport \"../interfaces/IHeroController.sol\";\n\nlibrary HeroControllerLib {\n  using PackingLib for bytes32;\n  using PackingLib for address;\n\n  //region ------------------------ RESTRICTIONS\n\n  function onlyDeployer(IController controller) internal view {\n    if (! controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\n  }\n\n  function onlyEOA(bool isEoa) internal view {\n    if (!isEoa) {\n      revert IAppErrors.NotEOA(msg.sender);\n    }\n  }\n  //endregion ------------------------ RESTRICTIONS\n\n  //region ------------------------ VIEWS\n\n  function _S() internal pure returns (IHeroController.MainState storage s) {\n    return HeroLib._S();\n  }\n\n  function heroTokensVault() internal view returns (address) {\n    return _S().heroTokensVault;\n  }\n\n  function payTokenInfo(address hero) internal view returns (address token, uint amount) {\n    return _S().payToken[hero].unpackAddressWithAmount();\n  }\n\n  function heroClass(address hero) internal view returns (uint8) {\n    return _S().heroClass[hero];\n  }\n\n  function heroName(address hero, uint heroId) internal view returns (string memory) {\n    return _S().heroName[hero.packNftId(heroId)];\n  }\n\n  function nameToHero(string memory name) internal view returns (address hero, uint heroId) {\n    return _S().nameToHero[name].unpackNftId();\n  }\n\n  function heroBiome(address hero, uint heroId) internal view returns (uint8) {\n    return _S().heroBiome[hero.packNftId(heroId)];\n  }\n\n  function heroReinforcementHelp(address hero, uint heroId) internal view returns (\n    address helperHeroToken,\n    uint helperHeroId\n  ) {\n    return _S().reinforcementHero[hero.packNftId(heroId)].unpackNftId();\n  }\n\n  function score(IController controller, address hero, uint heroId) internal view returns (uint) {\n    IStatController _statController = IStatController(controller.statController());\n    return ScoreLib.heroScore(\n      _statController.heroAttributes(hero, heroId),\n      _statController.heroStats(hero, heroId).level\n    );\n  }\n\n  function isAllowedToTransfer(IController controller, address hero, uint heroId) internal view returns (bool) {\n    return HeroLib.isAllowedToTransfer(controller, hero, heroId);\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ GOV ACTIONS\n\n  function setHeroTokensVault(IController controller, address value) internal {\n    onlyDeployer(controller);\n    HeroLib.setHeroTokensVault(value);\n  }\n\n  function registerHero(IController controller, address hero, uint8 heroClass_, address payToken, uint payAmount) internal {\n    onlyDeployer(controller);\n    HeroLib.registerHero(hero, heroClass_, payToken, payAmount);\n  }\n  //endregion ------------------------ GOV ACTIONS\n\n  //region ------------------------ USER ACTIONS\n\n  function create(\n    IController controller,\n    address msgSender,\n    address hero,\n    string calldata _heroName,\n    bool enter\n  ) internal returns (uint) {\n    // allow create for contracts for SponsoredHero flow  // onlyEOA(isEoa);\n    return HeroLib.create(controller, msgSender, hero, _heroName, \"\", enter);\n  }\n\n  function createWithRefCode(\n    bool isEoa,\n    IController controller,\n    address msgSender,\n    address hero,\n    string calldata _heroName,\n    string memory refCode,\n    bool enter\n  ) internal returns (uint) {\n    onlyEOA(isEoa);\n    return HeroLib.create(controller, msgSender, hero, _heroName, refCode, enter);\n  }\n\n\n  function setBiome(bool isEoa, IController controller, address msgSender, address hero, uint heroId, uint8 biome) internal {\n    onlyEOA(isEoa);\n    HeroLib.setBiome(controller, msgSender, hero, heroId, biome);\n  }\n\n  function levelUp(\n    bool isEoa,\n    IController controller,\n    address msgSender,\n    address hero,\n    uint heroId,\n    IStatController.CoreAttributes memory change\n  ) internal {\n    onlyEOA(isEoa);\n    HeroLib.levelUp(controller, msgSender, hero, heroId, change);\n  }\n\n  function askReinforcement(bool isEoa, IController controller, address msgSender, address hero, uint heroId) internal {\n    onlyEOA(isEoa);\n    HeroLib.askReinforcement(controller, msgSender, hero, heroId);\n  }\n  //endregion ------------------------ USER ACTIONS\n\n  //region ------------------------ DUNGEON ACTIONS\n\n  function kill(IController controller, address msgSender, address hero, uint heroId) internal returns (\n    bytes32[] memory dropItems\n  ) {\n    // restrictions are checked in HeroLib\n    return HeroLib.kill(controller, msgSender, hero, heroId);\n  }\n\n  function releaseReinforcement(IController controller, address msgSender, address hero, uint heroId) internal returns (\n    address helperToken,\n    uint helperId\n  ) {\n    // restrictions are checked in HeroLib\n    return HeroLib.releaseReinforcement(controller, msgSender, hero, heroId);\n  }\n  //endregion ------------------------ DUNGEON ACTIONS\n\n}\n"
    },
    "contracts/lib/HeroLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"./PackingLib.sol\";\nimport \"../interfaces/IHeroController.sol\";\nimport \"../interfaces/IHero.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IHeroTokensVault.sol\";\nimport \"../interfaces/IDungeonFactory.sol\";\nimport \"../interfaces/IReinforcementController.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../lib/StringLib.sol\";\n\nlibrary HeroLib {\n  using PackingLib for int32[];\n  using PackingLib for bytes32[];\n  using PackingLib for address;\n  using PackingLib for bytes32;\n\n  /// @dev keccak256(abi.encode(uint256(keccak256(\"hero.controller.main\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant HERO_CONTROLLER_STORAGE_LOCATION = 0xd333325b749986e76669f0e0c2c1aa0e0abd19e216c3678477196e4089241400;\n  uint public constant KILL_PENALTY = 70;\n\n  //region ------------------------ Storage\n\n  function _S() internal pure returns (IHeroController.MainState storage s) {\n    assembly {\n      s.slot := HERO_CONTROLLER_STORAGE_LOCATION\n    }\n    return s;\n  }\n  //endregion ------------------------ Storage\n\n  //region ------------------------ Restrictions\n\n  function onlyDungeonFactory(address dungeonFactory, address sender) internal pure {\n    if (dungeonFactory != sender) revert IAppErrors.ErrorNotDungeonFactory(sender);\n  }\n\n  function onlyOwner(address token, uint tokenId, address sender) internal view {\n    if (IERC721(token).ownerOf(tokenId) != sender) revert IAppErrors.ErrorNotHeroOwner(token, sender);\n  }\n\n  function onlyNotStaked(IController controller_, address hero, uint heroId) internal view {\n    if (IReinforcementController(controller_.reinforcementController()).isStaked(hero, heroId)) revert IAppErrors.Staked(hero, heroId);\n  }\n\n  function onlyInDungeon(IDungeonFactory dungeonFactory, address hero, uint heroId) internal view {\n    if (dungeonFactory.currentDungeon(hero, heroId) == 0) revert IAppErrors.ErrorHeroNotInDungeon();\n  }\n\n  function onlyNotInDungeon(IDungeonFactory dungeonFactory, address hero, uint heroId) internal view {\n    if (dungeonFactory.currentDungeon(hero, heroId) != 0) revert IAppErrors.HeroInDungeon();\n  }\n\n  function isAllowedToTransfer(IController controller_, address hero, uint heroId) internal view returns (bool) {\n    onlyNotInDungeon(IDungeonFactory(controller_.dungeonFactory()), hero, heroId);\n    if (\n      IStatController(controller_.statController()).heroItemSlots(hero, heroId).length != 0\n    ) revert IAppErrors.ItemEquipped();\n    onlyNotStaked(controller_, hero, heroId);\n    return true;\n  }\n\n  function _checkOwnerRegisteredPause(IController c, address msgSender, address hero, uint heroId) internal view {\n    onlyOwner(hero, heroId, msgSender);\n    if (_S().heroClass[hero] == 0) revert IAppErrors.ErrorHeroIsNotRegistered(hero);\n    if (c.onPause()) revert IAppErrors.ErrorPaused();\n  }\n\n  function _checkOutDungeonNotStakedAlive(IController c, address hero, uint heroId) internal view returns (IDungeonFactory) {\n    IDungeonFactory dungFactory = IDungeonFactory(c.dungeonFactory());\n\n    onlyNotInDungeon(dungFactory, hero, heroId);\n    onlyNotStaked(c, hero, heroId);\n    if (!IStatController(c.statController()).isHeroAlive(hero, heroId)) revert IAppErrors.ErrorHeroIsDead(hero, heroId);\n\n    return dungFactory;\n  }\n  //endregion ------------------------ Restrictions\n\n  //region ------------------------ Register\n\n  function setHeroTokensVault(address value) internal {\n    if (value == address(0)) revert IAppErrors.ZeroAddress();\n    if (_S().heroTokensVault != address(0)) revert IAppErrors.HeroTokensVaultAlreadySet();\n\n    _S().heroTokensVault = value;\n\n    emit IApplicationEvents.HeroTokensVaultSet(value);\n  }\n\n  function registerHero(address hero, uint8 heroClass, address payToken, uint payAmount) internal {\n    _S().heroClass[hero] = heroClass;\n    _S().payToken[hero] = payToken.packAddressWithAmount(payAmount);\n\n    emit IApplicationEvents.HeroRegistered(hero, heroClass, payToken, payAmount);\n  }\n  //endregion ------------------------ Register\n\n  //region ------------------------ User actions: create, setBiome, levelUp\n\n  /// @notice Init new hero, set biome 1, generate hero id, call process() to take specific amount from the sender\n  /// @param hero Should support IHero\n  /// @param heroName length must be < 20 chars, all chars should be ASCII chars in the range [32, 127]\n  /// @param enter Enter to default biome (==1)\n  function create(IController c, address msgSender, address hero, string calldata heroName, string memory refCode, bool enter)\n  internal returns (uint heroId) {\n    if (_S().heroClass[hero] == 0) revert IAppErrors.ErrorHeroIsNotRegistered(hero);\n    if (_S().nameToHero[heroName] != bytes32(0)) revert IAppErrors.NameTaken();\n    if (bytes(heroName).length >= 20) revert IAppErrors.TooBigName();\n    if (!StringLib.isASCIILettersOnly(heroName)) revert IAppErrors.WrongSymbolsInTheName();\n    if (c.onPause()) revert IAppErrors.ErrorPaused();\n\n    heroId = IHero(hero).mintFor(msgSender);\n    bytes32 packedId = hero.packNftId(heroId);\n\n    _S().heroName[packedId] = heroName;\n    _S().nameToHero[heroName] = packedId;\n\n    IStatController(c.statController()).initNewHero(hero, heroId, _S().heroClass[hero]);\n\n    (address token, uint amount) = _S().payToken[hero].unpackAddressWithAmount();\n    if (token != address(0)) {\n      IHeroTokensVault(_S().heroTokensVault).process(token, amount, msgSender);\n    }\n\n    emit IApplicationEvents.HeroCreated(hero, heroId, heroName, msgSender, refCode);\n\n    // set first biome by default\n    _S().heroBiome[packedId] = 1;\n    emit IApplicationEvents.BiomeChanged(hero, heroId, 1);\n\n    // enter to the first dungeon\n    if (enter) {\n      IDungeonFactory(c.dungeonFactory()).launchForNewHero(hero, heroId, msgSender);\n    }\n\n    return heroId;\n  }\n\n  /// @notice Set hero biome to {biome}, ensure that it's allowed\n  /// @param msgSender Sender must be the owner of the hero\n  /// @param biome New biome value: (0, maxBiomeCompleted + 1]\n  function setBiome(IController controller, address msgSender, address hero, uint heroId, uint8 biome) internal {\n\n    _checkOwnerRegisteredPause(controller, msgSender, hero, heroId);\n    IDungeonFactory dungFactory = _checkOutDungeonNotStakedAlive(controller, hero, heroId);\n\n    if (biome == 0) revert IAppErrors.ErrorIncorrectBiome(biome);\n\n    uint8 maxBiomeCompleted = dungFactory.maxBiomeCompleted(hero, heroId);\n    if (biome > maxBiomeCompleted + 1) revert IAppErrors.TooHighBiome(biome);\n\n    _S().heroBiome[hero.packNftId(heroId)] = biome;\n    emit IApplicationEvents.BiomeChanged(hero, heroId, biome);\n  }\n\n  /// @notice Set level up according to {change}, call process() to take (payTokenAmount * level) from the sender\n  function levelUp(\n    IController controller,\n    address msgSender,\n    address hero,\n    uint heroId,\n    IStatController.CoreAttributes memory change\n  ) internal {\n    _checkOwnerRegisteredPause(controller, msgSender, hero, heroId);\n    _checkOutDungeonNotStakedAlive(controller, hero, heroId);\n\n    onlyNotInDungeon(IDungeonFactory(controller.dungeonFactory()), hero, heroId);\n    onlyNotStaked(controller, hero, heroId);\n\n    IStatController _statController = IStatController(controller.statController());\n    (address token, uint payTokenAmount) = _S().payToken[hero].unpackAddressWithAmount();\n\n    if (token == address(0) || payTokenAmount == 0) revert IAppErrors.NoPayToken(token, payTokenAmount);\n\n    // update stats\n    uint level = _statController.levelUp(hero, heroId, _S().heroClass[hero], change);\n\n    // send tokens\n    uint amount = payTokenAmount * level;\n\n    IHeroTokensVault(_S().heroTokensVault).process(token, amount, msgSender);\n\n    emit IApplicationEvents.LevelUp(hero, heroId, msgSender, change);\n  }\n\n  //endregion ------------------------ User actions: create, setBiome, levelUp\n\n  //region ------------------------ User actions: reinforcement\n\n  /// @notice Ask random other-hero for reinforcement\n  function askReinforcement(IController controller, address msgSender, address hero, uint heroId) internal {\n    _checkOwnerRegisteredPause(controller, msgSender, hero, heroId);\n\n    onlyInDungeon(IDungeonFactory(controller.dungeonFactory()), hero, heroId);\n\n    bytes32 packedId = hero.packNftId(heroId);\n    if (_S().reinforcementHero[packedId] != bytes32(0)) revert IAppErrors.AlreadyHaveReinforcement();\n\n    IStatController _statController = IStatController(controller.statController());\n    IReinforcementController rc = IReinforcementController(controller.reinforcementController());\n\n    // scb-1009: Life and mana are restored during reinforcement as following:\n    // Reinforcement increases max value of life/mana on DELTA, current value of life/mana is increased on DELTA too\n\n    (address helpHeroToken, uint helpHeroId, int32[] memory helpAttributes) = rc.askHero(uint(_S().heroBiome[packedId]));\n    int32[] memory attributes = _statController.heroAttributes(hero, heroId);\n\n    _statController.changeBonusAttributes(IStatController.ChangeAttributesInfo({\n      heroToken: hero,\n      heroTokenId: heroId,\n      changeAttributes: helpAttributes,\n      add: true,\n      temporally: false\n    }));\n\n    _S().reinforcementHero[packedId] = helpHeroToken.packNftId(helpHeroId);\n    _S().reinforcementHeroAttributes[packedId] = helpAttributes.toBytes32Array();\n\n    // restore life and mana to default values from the total attributes\n    _statController.restoreLifeAndMana(hero, heroId, attributes);\n\n    emit IApplicationEvents.ReinforcementAsked(hero, heroId, helpHeroToken, helpHeroId);\n  }\n\n  function releaseReinforcement(IController controller, address msgSender, address hero, uint heroId) internal returns (\n    address helperToken,\n    uint helperId\n  ) {\n    onlyDungeonFactory(controller.dungeonFactory(), msgSender);\n    if (_S().heroClass[hero] == 0) revert IAppErrors.ErrorHeroIsNotRegistered(hero);\n\n    bytes32 packedId = hero.packNftId(heroId);\n\n    (helperToken, helperId) = _S().reinforcementHero[packedId].unpackNftId();\n\n\n    if (helperToken != address(0)) {\n      IStatController _statController = IStatController(controller.statController());\n\n      int32[] memory attributes = _S().reinforcementHeroAttributes[packedId].toInt32Array(uint(IStatController.ATTRIBUTES.END_SLOT));\n\n      _statController.changeBonusAttributes(IStatController.ChangeAttributesInfo({\n        heroToken: hero,\n        heroTokenId: heroId,\n        changeAttributes: attributes,\n        add: false,\n        temporally: false\n      }));\n\n      delete _S().reinforcementHero[packedId];\n      delete _S().reinforcementHeroAttributes[packedId];\n\n      emit IApplicationEvents.ReinforcementReleased(hero, heroId, helperToken, helperId);\n    }\n  }\n  //endregion ------------------------ User actions: reinforcement\n\n  //region ------------------------ Kill\n  /// @return dropItems List of items (packed: item NFT address + item id)\n  function kill(IController controller, address msgSender, address hero, uint heroId) internal returns (\n    bytes32[] memory dropItems\n  ) {\n    onlyDungeonFactory(controller.dungeonFactory(), msgSender);\n    if (_S().heroClass[hero] == 0) revert IAppErrors.ErrorHeroIsNotRegistered(hero);\n\n    IStatController statController = IStatController(controller.statController());\n    dropItems = _takeOffAll(IItemController(controller.itemController()), statController, hero, heroId, msgSender, true);\n\n    // set life to zero, reduce life-chances on 1\n    statController.changeCurrentStats(\n      hero,\n      heroId,\n      IStatController.ChangeableStats({\n        level: 0,\n        experience: 0,\n        life: statController.heroStats(hero, heroId).life,\n        mana: 0,\n        lifeChances: 1\n      }),\n      false\n    );\n\n    IHero(hero).burn(heroId);\n\n    emit IApplicationEvents.Killed(hero, heroId, msgSender, dropItems, 0);\n  }\n\n  function _takeOffAll(\n    IItemController ic,\n    IStatController statController,\n    address hero,\n    uint heroId,\n    address recipient,\n    bool broken\n  ) internal returns (bytes32[] memory items) {\n    uint8[] memory busySlots = statController.heroItemSlots(hero, heroId);\n    uint len = busySlots.length;\n    items = new bytes32[](len);\n    for (uint i; i < len; ++i) {\n      bytes32 data = statController.heroItemSlot(hero, uint64(heroId), busySlots[i]);\n      (address itemAdr, uint itemId) = data.unpackNftId();\n\n      ic.takeOffDirectly(itemAdr, itemId, hero, heroId, busySlots[i], recipient, broken);\n      items[i] = data;\n    }\n  }\n  //endregion ------------------------ Kill\n\n}\n"
    },
    "contracts/lib/HeroTokensVaultLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IGameToken.sol\";\nimport \"../openzeppelin/Math.sol\";\n\nlibrary HeroTokensVaultLib {\n  \n  //region ------------------------ Constants\n  uint private constant _BURN_DENOMINATOR = 100e18;\n  uint private constant _TOTAL_SUPPLY_BASE = 10_000_000e18;\n  //endregion ------------------------ Constants\n\n  //region ------------------------ Restrictions\n  function onlyAllowedContracts(IController controller) internal view {\n    if (\n      controller.heroController() != msg.sender\n      && controller.userController() != msg.sender\n      && controller.guildController() != msg.sender\n    ) {\n      revert IAppErrors.ErrorNotAllowedSender();\n    }\n  }\n  //endregion ------------------------ Restrictions\n\n  //region ------------------------ Main logic\n\n  /// @return Value in the range [0...100e18]\n  function percentToBurn(uint totalSupply) internal pure returns (uint) {\n    return Math.min(totalSupply * _BURN_DENOMINATOR / _TOTAL_SUPPLY_BASE, _BURN_DENOMINATOR);\n  }\n\n  /// @notice Split {amount} on three parts: to treasury, to governance, to burn.\n  /// Last part is burnt if the token is game token, otherwise it's kept on balance,\n  /// @param token It's always game token\n  /// @param amount Assume that this amount is approved by {from} to this contract\n  function process(IController controller, address token, uint amount, address from) internal {\n    onlyAllowedContracts(controller);\n\n    IERC20(token).transferFrom(from, address(this), amount);\n\n    uint toBurn = amount * percentToBurn(IERC20(token).totalSupply()) / _BURN_DENOMINATOR;\n    uint toTreasury = (amount - toBurn) / 2;\n    uint toGov = amount - toBurn - toTreasury;\n\n    if (toTreasury != 0) {\n      IERC20(token).transfer(controller.treasury(), toTreasury);\n    }\n\n    if (toGov != 0) {\n      IERC20(token).transfer(address(controller), toGov);\n    }\n\n    if (toBurn != 0) {\n      IGameToken(token).burn(toBurn);\n    }\n\n    emit IApplicationEvents.Process(token, amount, from, toBurn, toTreasury, toGov);\n  }\n  //endregion ------------------------ Main logic\n}"
    },
    "contracts/lib/ItemLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"./CalcLib.sol\";\nimport \"./StatLib.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IItemController.sol\";\nimport \"../interfaces/IItem.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../solady/LibPRNG.sol\";\n\nlibrary ItemLib {\n  using CalcLib for int32;\n  using PackingLib for address;\n  using PackingLib for bytes32;\n  using PackingLib for bytes32[];\n  using PackingLib for uint32[];\n  using PackingLib for int32[];\n\n  //region ------------------------ Data types\n  struct GenerateAttributesContext {\n    /// @notice True if max allowed amount of random attributes were reached inside {_prepareAttributes}\n    bool stopGenerateRandom;\n    /// @notice Flag - attribute was generated. The array matches to info.ids\n    bool[] usedIndexes;\n    /// @notice Ids of the generated attributes\n    uint8[] ids;\n    /// @notice Randomly selected values of the generated attributes\n    int32[] values;\n    /// @notice Counter of the stored values into {ids} and {values}\n    uint counter;\n    /// @notice Total number of random attributes that were generated inside {_prepareAttributes}\n    uint randomAttrCounter;\n    /// @notice Total sum of all {random} values for random attributes generated in {_prepareAttributes}\n    uint randomSum;\n    /// @notice Total sum of all chances of the random attributes generated in {_prepareAttributes}\n    uint chancesSum;\n    /// @notice Total number of random attributes that can be generated\n    uint totalRandomAttrsPossible;\n  }\n\n  struct MintItemInfo {\n    uint8 maxItems;\n    IOracle oracle;\n    address[] mintItems;\n    int32 magicFind;\n    int32 destroyItems;\n    uint32[] mintItemsChances;\n    uint amplifier;\n    uint seed;\n    /// @notice Penalty to reduce chance as chance/delta if the hero not in his biome\n    /// @dev Use StatLib.mintDropChanceDelta\n    uint mintDropChanceDelta;\n  }\n  //endregion ------------------------ Data types\n\n  //region ------------------------ Main logic\n\n  /// @notice Mint new item, setup attributes, make extra setup if necessary (setup attack item, buff item)\n  /// @param sender Dungeon Factory / User Controller / Guild Controller are allowed\n  /// @param item Item to be minted\n  /// @param recipient The item is minted for the given recipient\n  /// @return itemId Id of the newly minted item\n  function mintNewItem(\n    IItemController.MainState storage s,\n    IController controller,\n    address sender,\n    address item,\n    address recipient\n  ) external returns (uint itemId) {\n    if (\n      controller.dungeonFactory() != sender\n      && controller.userController() != sender\n      && controller.guildController() != sender\n    ) revert IAppErrors.MintNotAllowed();\n\n    itemId = IItem(item).mintFor(recipient);\n\n    IItemController.MintInfo memory info;\n\n    (\n      info.meta,\n      info.attributesIds,\n      info.attributesValues,\n      info.itemRarity\n    ) = _setupNewAttributes(s, item, itemId, CalcLib.pseudoRandom);\n\n    // setup extra info\n\n    if (info.meta.itemMetaType == uint8(IItemController.ItemMetaType.ATTACK)) {\n      info.attackInfo = unpackItemAttackInfo(_setupNewAttackItem(s, item, itemId));\n    } else if (info.meta.itemMetaType == uint8(IItemController.ItemMetaType.BUFF)) {\n      (\n        info.casterIds,\n        info.casterValues,\n        info.targetIds,\n        info.targetValues\n      ) = _setupNewBuffItem(s, item, itemId, CalcLib.pseudoRandom);\n    }\n    // consumable stats unchangeable, get them by address\n\n    emit IApplicationEvents.NewItemMinted(item, itemId, info);\n  }\n\n  /// @notice Mint random items, not more than {info.maxItems}\n  function mintRandomItems(MintItemInfo memory info) internal returns (address[] memory) {\n    return _mintRandomItems(info, CalcLib.nextPrng);\n  }\n\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ Internal logic\n  /// @param nextPrng_ CalcLib.nextPrng, param is required by unit tests\n  function _mintRandomItems(\n    MintItemInfo memory info,\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\n  ) internal returns (address[] memory) {\n    unchecked {\n      uint len = info.mintItems.length;\n\n    // Fisher–Yates shuffle\n      LibPRNG.PRNG memory prng = LibPRNG.PRNG(info.oracle.getRandomNumber(CalcLib.MAX_CHANCE, info.seed));\n      uint[] memory indices = new uint[](len);\n      for (uint i = 1; i < len; ++i) {\n        indices[i] = i;\n      }\n      LibPRNG.shuffle(prng, indices);\n\n      address[] memory minted = new address[](len);\n      uint mintedLength;\n      uint di = Math.min(uint(int(info.destroyItems)), 100);\n\n      for (uint i; i < len; ++i) {\n        if (info.mintItemsChances[indices[i]] > CalcLib.MAX_CHANCE) {\n          revert IAppErrors.TooHighChance(info.mintItemsChances[indices[i]]);\n        }\n\n        // there are two params to increase chances: amplifier and magicFind\n        // there are two params to decrease chances: mintDropChanceDelta and destroyItems\n        // calculate result chances:\n        uint chance = info.mintItemsChances[indices[i]];\n        chance += chance * info.amplifier / StatLib._MAX_AMPLIFIER;\n        if (info.mintDropChanceDelta != 0) {\n          chance /= info.mintDropChanceDelta; // reduce chance if hero is not in his biome\n        }\n        chance += chance * uint(int(info.magicFind)) / 100;\n        chance -= chance * di / 100;\n\n        // need to call random in each loop coz each minted item should have dedicated chance\n        uint rnd = nextPrng_(prng, CalcLib.MAX_CHANCE); // randomWithSeed_(CalcLib.MAX_CHANCE, rndSeed);\n\n        if (chance != 0 && (chance >= CalcLib.MAX_CHANCE || rnd < chance)) {\n          // There is no break here: the cycle is continued even if the number of the minted items reaches the max.\n          // The reason: gas consumption of success operation must be great of equal of the gas consumption of fail op.\n          if (mintedLength < info.maxItems) {\n            minted[i] = info.mintItems[indices[i]];\n            ++mintedLength;\n          }\n        }\n      }\n\n      address[] memory mintedAdjusted = new address[](mintedLength);\n      uint j;\n      for (uint i; i < len; ++i) {\n        if (minted[i] != address(0)) {\n          mintedAdjusted[j] = minted[i];\n          ++j;\n        }\n      }\n\n      return mintedAdjusted;\n    }\n  }\n\n  function _setupNewAttributes(\n    IItemController.MainState storage s,\n    address item,\n    uint itemId,\n    function (uint) internal view returns (uint) random_\n  ) internal returns (\n    IItemController.ItemMeta memory meta,\n    uint8[] memory ids,\n    int32[] memory values,\n    IItemController.ItemRarity itemRarity\n  ){\n    meta = unpackedItemMeta(s.itemMeta[item]);\n    (ids, values, itemRarity) = _generateAttributes(unpackItemGenerateInfo(s.generateInfoAttributes[item]), meta, random_);\n\n    bytes32 packedItemId = item.packNftId(itemId);\n    if (ids.length != 0) {\n      s._itemAttributes[packedItemId] = values.toBytes32ArrayWithIds(ids);\n    }\n\n    s.itemInfo[packedItemId] = PackingLib.packItemInfo(uint8(itemRarity), 0, meta.baseDurability);\n  }\n\n  function _setupNewAttackItem(IItemController.MainState storage s, address item, uint itemId) internal returns (bytes32 attackInfo){\n    // we just write data for attack item, no need to generate, it will be augmented later so need individual data for itemId\n    attackInfo = s.generateInfoAttack[item];\n    s._itemAttackInfo[item.packNftId(itemId)] = attackInfo;\n  }\n\n  function _setupNewBuffItem(\n    IItemController.MainState storage s,\n    address item,\n    uint itemId,\n    function (uint) internal view returns (uint) random_\n  ) internal returns (\n    uint8[] memory casterIds,\n    int32[] memory casterValues,\n    uint8[] memory targetIds,\n    int32[] memory targetValues\n  ){\n\n    // CASTER\n    (casterIds, casterValues) = _generateSimpleAttributes(\n      unpackItemGenerateInfo(s.generateInfoCasterAttributes[item]),\n      true,\n      random_\n    );\n\n    if (casterIds.length != 0) {\n      s._itemCasterAttributes[item.packNftId(itemId)] = casterValues.toBytes32ArrayWithIds(casterIds);\n    }\n\n    // TARGET\n    (targetIds, targetValues) = _generateSimpleAttributes(\n      unpackItemGenerateInfo(s.generateInfoTargetAttributes[item]),\n      true,\n      random_\n    );\n\n    if (targetIds.length != 0) {\n      s._itemTargetAttributes[item.packNftId(itemId)] = targetValues.toBytes32ArrayWithIds(targetIds);\n    }\n  }\n\n  /// @notice Generate all mandatory attributes and try to generate required number of random attributes.\n  /// Generate at least {info.minRandomAttributes} of random attributes if it's possible\n  /// but not more than {info.maxRandomAttributes}. Value of each attribute is generated randomly according its chances.\n  /// @param meta Assume, that meta.min != 0, meta.max != 0 and both meta.min and meta.min should have same sign\n  /// because results value cannot be 0\n  /// @return ids Ids of the attributes, zero id is allowed\n  /// @return values Randomly generated attributes values, min <= value <= max\n  /// @return itemRarity Rarity of the item (Either meta.defaultRarity or calculated if there is no default rarity)\n  function _generateAttributes(\n    IItemController.ItemGenerateInfo memory info,\n    IItemController.ItemMeta memory meta,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (\n    uint8[] memory ids,\n    int32[] memory values,\n    IItemController.ItemRarity itemRarity\n  ) {\n    GenerateAttributesContext memory ctx;\n\n    uint len = info.ids.length;\n    if (len != 0) {\n      ctx.ids = new uint8[](len);\n      ctx.values = new int32[](len);\n      ctx.usedIndexes = new bool[](len);\n\n      // Fisher–Yates shuffle\n      _shuffleInfo(info, random_);\n\n      // initialize ctx by initial values\n      // generate all mandatory attributes, try to generate not more than {meta.maxRandomAttributes} random attributes\n      _prepareAttributes(info, meta.maxRandomAttributes, ctx, random_);\n\n      // generate missing random attributes if it's necessary, ctx.counter is incremented\n      _generateMissingRandomAttributes(info, meta.minRandomAttributes, ctx, random_);\n\n      itemRarity = meta.defaultRarity == 0\n        ? _calculateRarity(ctx.randomSum, ctx.chancesSum, ctx.randomAttrCounter, meta.maxRandomAttributes)\n        : IItemController.ItemRarity(meta.defaultRarity);\n    } else {\n      itemRarity = IItemController.ItemRarity.UNKNOWN;\n    }\n\n    (ids, values) = _fixLengthsIdsValues(ctx.ids, ctx.values, ctx.counter);\n  }\n\n  /// @notice Generate missing random attributes if necessary\n  function _generateMissingRandomAttributes(\n    IItemController.ItemGenerateInfo memory info,\n    uint8 minRandomAttributes,\n    GenerateAttributesContext memory ctx,\n    function (uint) internal view returns (uint) random_\n  ) internal view {\n    uint attrToGen = Math.min(ctx.totalRandomAttrsPossible, minRandomAttributes);\n    if (ctx.randomAttrCounter < attrToGen && ctx.totalRandomAttrsPossible > ctx.randomAttrCounter) {\n      // it's necessary AND possible to generate more random attributes\n      uint possibleRemainingAttrs = ctx.totalRandomAttrsPossible - ctx.randomAttrCounter;\n      uint remainingAttrsToGen = attrToGen - ctx.randomAttrCounter;\n\n      uint[] memory indicesToGen = new uint[](possibleRemainingAttrs);\n      uint indicesToGenCounter;\n\n      // enumerate all attributes, add all indices of not-generated attributes to {indexesToGen}\n      for (uint i; i < info.ids.length; ++i) {\n        // mandatory attrs should be already generated and no need to check\n        if (!ctx.usedIndexes[i]) {\n          indicesToGen[indicesToGenCounter] = i;\n          indicesToGenCounter++;\n        }\n      }\n\n      // Shuffle indices of not-generated attributes using Fisher–Yates shuffle\n      if (possibleRemainingAttrs > 1) {\n        for (uint i; i < possibleRemainingAttrs - 1; ++i) {\n          uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, possibleRemainingAttrs - 1, random_);\n          (indicesToGen[randomIndex], indicesToGen[i]) = (indicesToGen[i], indicesToGen[randomIndex]);\n        }\n      }\n      // Generate necessary amount of attributes. Fist (shuffled) attributes are selected (MAX_CHANCE is used for each)\n      for (uint i; i < remainingAttrsToGen; ++i) {\n        uint idx = indicesToGen[i];\n        (int32 attr,) = _generateAttribute(info.mins[idx], info.maxs[idx], CalcLib.MAX_CHANCE, random_);\n        ctx.ids[ctx.counter] = info.ids[idx];\n        ctx.values[ctx.counter] = attr;\n        ctx.counter++;\n      }\n    }\n  }\n\n  /// @notice Generate all mandatory attributes, generate not more than {meta.maxRandomAttributes} random attributes.\n  /// Updates context:\n  ///   {ctx.totalRandomAttrsPossible} - total number of possible random attributes\n  ///   {ctx.randomAttrCounter} - total number of generated random attributes  <= {maxRandomAttributes}\n  ///   {ctx.randomSum} = sum of random of all random attributes.\n  ///   {ctx.chancesSum} = sum of chances of all random attributes.\n  ///   {ctx.counter} = total number of generated attributes. Values of ctx.ids, ctx.values, ctx.usedIndexes are\n  ///   initialized in the range [0...ctx.counter)\n  /// @param ctx Empty struct but arrays ids, values and usedIndexes should be allocated for info.ids.length items\n  function _prepareAttributes(\n    IItemController.ItemGenerateInfo memory info,\n    uint8 maxRandomAttributes,\n    GenerateAttributesContext memory ctx,\n    function (uint) internal view returns (uint) random_\n  ) internal view {\n    uint len = info.ids.length;\n    for (uint i; i < len; ++i) {\n      if (info.chances[i] != CalcLib.MAX_CHANCE) {\n        ctx.totalRandomAttrsPossible++;\n      }\n\n      if (info.chances[i] >= CalcLib.MAX_CHANCE || !ctx.stopGenerateRandom) {\n        (int32 attr, uint random) = _generateAttribute(info.mins[i], info.maxs[i], info.chances[i], random_);\n//          console.log(\"GEN id: %s, value: %s%s\", _info.ids[i], attr >= 0 ? '' : '-', attr >= 0 ? uint(int(attr)) : uint(int(- attr)));\n\n        // count only random attributes for calc rarity\n        if (attr != 0) {\n\n          if (\n            info.chances[i] < CalcLib.MAX_CHANCE\n            // && random != 0 // commented: random = 0 can produce crash in _generateMissingRandomAttributes\n          ) {\n            ctx.randomAttrCounter++;\n            ctx.randomSum += random;\n            ctx.chancesSum += info.chances[i];\n          }\n          ctx.ids[ctx.counter] = info.ids[i];\n          ctx.values[ctx.counter] = attr;\n          ctx.counter++;\n          ctx.usedIndexes[i] = true;\n        }\n\n        // it is a bit less fair random for attrs in the end of the list, however we assume it should be pretty rare case\n        if (ctx.randomAttrCounter == maxRandomAttributes) {\n          ctx.stopGenerateRandom = true;\n        }\n      }\n    }\n  }\n\n  /// @notice Shuffle info arrays using Fisher–Yates shuffle algo\n  function _shuffleInfo(\n    IItemController.ItemGenerateInfo memory info,\n    function (uint) internal view returns (uint) random_\n  ) internal view {\n    uint len = info.ids.length;\n    if (len > 1) {\n      for (uint i; i < len - 1; i++) {\n        uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, len - 1, random_);\n\n        (info.ids[randomIndex], info.ids[i]) = (info.ids[i], info.ids[randomIndex]);\n        (info.mins[randomIndex], info.mins[i]) = (info.mins[i], info.mins[randomIndex]);\n        (info.maxs[randomIndex], info.maxs[i]) = (info.maxs[i], info.maxs[randomIndex]);\n        (info.chances[randomIndex], info.chances[i]) = (info.chances[i], info.chances[randomIndex]);\n      }\n    }\n  }\n\n  /// @notice Generate array [0,1,2.. N-1] and shuffle it using Fisher–Yates shuffle algo\n  function _shuffleIndices(\n    uint countItems,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (uint[] memory indices){\n    indices = new uint[](countItems);\n    for (uint i = 1; i < countItems; ++i) {\n      indices[i] = i;\n    }\n    if (countItems > 1) {\n      for (uint i; i < countItems - 1; i++) {\n        uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, countItems - 1, random_);\n        (indices[randomIndex], indices[i]) = (indices[i], indices[randomIndex]);\n      }\n    }\n  }\n\n  /// @notice Reduce lengths of {ids} and {values} to {count}\n  function _fixLengthsIdsValues(uint8[] memory ids, int32[] memory values, uint count) internal pure returns (\n    uint8[] memory idsOut,\n    int32[] memory valuesOut\n  ) {\n    if (count == ids.length) {\n      return (ids, values);\n    }\n\n    idsOut = new uint8[](count);\n    valuesOut = new int32[](count);\n    for (uint i; i < count; ++i) {\n      idsOut[i] = ids[i];\n      valuesOut[i] = values[i];\n    }\n    return (idsOut, valuesOut);\n  }\n\n  /// @param random_ Pass CalcLib.pseudoRandom here, param is required for unit tests. Max value is MAX_CHANCE\n  function _generateSimpleAttributes(\n    IItemController.ItemGenerateInfo memory info,\n    bool maxChance,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (\n    uint8[] memory ids,\n    int32[] memory values\n  ) {\n    uint len = info.ids.length;\n    ids = new uint8[](len);\n    values = new int32[](len);\n\n    uint n = 0;\n    for (uint i; i < len; ++i) {\n      (int32 attr,) = _generateAttribute(\n        info.mins[i],\n        info.maxs[i],\n        maxChance ? CalcLib.MAX_CHANCE : info.chances[i],\n        random_\n      );\n      if (attr != 0) {\n        ids[n] = info.ids[i];\n        values[n] = attr;\n        ++n;\n      }\n    }\n\n    return _fixLengthsIdsValues(ids, values, n);\n  }\n\n  //endregion ------------------------ Internal logic\n\n  //region ------------------------ Internal utils\n  /// @param chance Chance in the range [0...MAX_CHANCE], MAX_CHANCE=1e9 means \"mandatory\" element.\n  /// @param random_ Pass CalcLib.pseudoRandom here, param is required for unit tests\n  /// @return attr Either 0 or min <= attr <= max\n  /// @return rnd Random value in the range [0...MAX_CHANCE]; It's always 0 for mandatory elements\n  function _generateAttribute(\n    int32 min,\n    int32 max,\n    uint32 chance,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (\n    int32 attr,\n    uint rnd\n  ) {\n    if (chance > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighChance(chance);\n\n    uint diff = uint(CalcLib.absDiff(min, max));\n\n    if (chance < CalcLib.MAX_CHANCE) {\n      uint32 random = CalcLib.pseudoRandomUint32Flex(CalcLib.MAX_CHANCE, random_);\n      if (random < chance) {\n        uint r = uint(CalcLib.MAX_CHANCE - random * (CalcLib.MAX_CHANCE / chance));\n        int32 k = int32(int(r * diff / uint(CalcLib.MAX_CHANCE)));\n        return (min + k, random);\n      }\n    } else { // chance == CalcLib.MAX_CHANCE => mandatory element\n      if (diff == 0) {\n        return (min, 0);\n      } else {\n        uint r = uint(CalcLib.pseudoRandomUint32Flex(CalcLib.MAX_CHANCE, random_));\n        int32 k = int32(int(r % (diff + 1)));\n\n        // return zero random - no need to calc rarity for mandatory elements\n        return (min + k, 0);\n      }\n    }\n\n    return (0, 0);\n  }\n\n  /// @notice Calculate item rarity\n  /// @param randomSum Total sum random values of all random attributes in ItemGenerateInfo, [0...MAX_CHANCE/attrCounter]\n  /// @param chancesSum Total sum of all random chances in ItemGenerateInfo\n  /// @param attrCounter Count of random attributes in ItemGenerateInfo\n  /// @param maxAttr Index of max allowed random attribute (all attributes with higher indices are not random)\n  /// @return item rarity\n  function _calculateRarity(uint randomSum, uint chancesSum, uint attrCounter, uint maxAttr) internal pure returns (\n    IItemController.ItemRarity\n  ) {\n    if (attrCounter == 0) {\n      return IItemController.ItemRarity.NORMAL;\n    }\n\n    uint random = randomSum / attrCounter;\n    uint averageChance = chancesSum / attrCounter;\n\n    if (random > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighRandom(random);\n\n    if (random < averageChance / 4 && attrCounter == maxAttr) {\n      return IItemController.ItemRarity.RARE;\n    } else if (random < averageChance * 3 / 4) {\n      return attrCounter > 2\n        ? IItemController.ItemRarity.RARE\n        : IItemController.ItemRarity.MAGIC;\n    } else {\n      return attrCounter > 1\n        ? IItemController.ItemRarity.MAGIC\n        : IItemController.ItemRarity.NORMAL;\n    }\n  }\n  //endregion ------------------------ Internal utils\n\n  //region ------------------------ PACKING\n\n  function packItemGenerateInfo(IItemController.ItemGenerateInfo memory info) internal pure returns (bytes32[] memory result) {\n    uint len = info.ids.length;\n    if (len != info.mins.length || len != info.maxs.length || len != info.chances.length) {\n      revert IAppErrors.LengthsMismatch();\n    }\n\n    result = new bytes32[](len);\n\n    for (uint i; i < len; ++i) {\n      result[i] = PackingLib.packItemGenerateInfo(info.ids[i], info.mins[i], info.maxs[i], info.chances[i]);\n    }\n  }\n\n  function unpackItemGenerateInfo(bytes32[] memory gen) internal pure returns (\n    IItemController.ItemGenerateInfo memory\n  ) {\n    uint length = gen.length;\n\n    uint8[] memory ids = new uint8[](length);\n    int32[] memory mins = new int32[](length);\n    int32[] memory maxs = new int32[](length);\n    uint32[] memory chances = new uint32[](length);\n\n    for (uint i; i < length; ++i) {\n      (ids[i], mins[i], maxs[i], chances[i]) = gen[i].unpackItemGenerateInfo();\n    }\n\n    return IItemController.ItemGenerateInfo(ids, mins, maxs, chances);\n  }\n\n  function packItemMeta(IItemController.ItemMeta memory meta) internal pure returns (bytes32) {\n    return PackingLib.packItemMeta(\n      meta.itemMetaType,\n      meta.itemLevel,\n      uint8(meta.itemType),\n      meta.baseDurability,\n      meta.defaultRarity,\n      meta.minRandomAttributes,\n      meta.maxRandomAttributes,\n      meta.manaCost,\n      meta.requirements\n    );\n  }\n\n  function unpackedItemMeta(bytes32 meta) internal pure returns (IItemController.ItemMeta memory result) {\n    return meta.unpackItemMeta();\n  }\n\n  function packItemInfo(IItemController.ItemInfo memory info) internal pure returns (bytes32) {\n    return PackingLib.packItemInfo(uint8(info.rarity), info.augmentationLevel, info.durability);\n  }\n\n  function unpackedItemInfo(bytes32 info) internal pure returns (IItemController.ItemInfo memory result) {\n    uint8 rarity;\n    (rarity, result.augmentationLevel, result.durability) = info.unpackItemInfo();\n\n    result.rarity = IItemController.ItemRarity(rarity);\n    return result;\n  }\n\n  function packItemAttackInfo(IItemController.AttackInfo memory info) internal pure returns (bytes32) {\n    return PackingLib.packItemAttackInfo(\n      uint8(info.aType),\n      info.min,\n      info.max,\n      info.attributeFactors.strength,\n      info.attributeFactors.dexterity,\n      info.attributeFactors.vitality,\n      info.attributeFactors.energy\n    );\n  }\n\n  function unpackItemAttackInfo(bytes32 info) internal pure returns (IItemController.AttackInfo memory result) {\n    IStatController.CoreAttributes memory fs;\n    uint8 aType;\n    (aType, result.min, result.max, fs.strength, fs.dexterity, fs.vitality, fs.energy) = info.unpackItemAttackInfo();\n\n    result.aType = IItemController.AttackType(aType);\n    result.attributeFactors = fs;\n\n    return result;\n  }\n  //endregion ------------------------ PACKING\n}\n"
    },
    "contracts/lib/ItemStatsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n\nimport \"./PackingLib.sol\";\nimport \"./ItemLib.sol\";\nimport \"./AppLib.sol\";\nimport \"./CalcLib.sol\";\nimport \"./ScoreLib.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IItemController.sol\";\nimport \"../interfaces/IReinforcementController.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IItem.sol\";\nimport \"../interfaces/IDungeonFactory.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IAppErrors.sol\";\n\nlibrary ItemStatsLib {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using CalcLib for int32;\n  using PackingLib for address;\n  using PackingLib for bytes32;\n  using PackingLib for bytes32[];\n  using PackingLib for uint32[];\n  using PackingLib for int32[];\n\n  //region ------------------------ CONSTANTS\n\n  uint private constant AUGMENT_CHANCE = 0.7e18;\n  /// @dev should be 20%\n  uint private constant AUGMENT_FACTOR = 5;\n  uint private constant DURABILITY_REDUCTION = 3;\n  uint private constant MAX_AUGMENTATION_LEVEL = 10;\n\n  /// @dev keccak256(abi.encode(uint256(keccak256(\"item.controller.main\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0xe78a2879cd91c3f7b62ea14e72546fed47c40919bca4daada532a5fa05ac6700;\n\n  /// @notice SIP-003: Max value of item fragility that corresponds to 100%\n  uint private constant MAX_FRAGILITY = 100_000;\n  /// @notice SIP-003: Each successful repair has a chance of increasing the item's fragility by 1%.\n  uint private constant FRAGILITY_SUCCESSFUL_REPAIR_PORTION = 1_000;\n  /// @notice SIP-003: 10% chance of increasing the item's fragility on successful repair\n  uint private constant FRAGILITY_SUCCESSFUL_REPAIR_CHANCE = 10;\n  /// @notice SIP-003: The quest mechanic will break the item and increase its fragility by 1%.\n  uint private constant FRAGILITY_BREAK_ITEM_PORTION = 1_000;\n\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ STRUCTS\n\n  struct EquipLocalContext {\n    IStatController statController;\n    IDungeonFactory dungeonFactory;\n    IHeroController hc;\n    address payToken;\n    address heroToken;\n    uint heroTokenId;\n//    IItemController.ItemMeta meta;\n//    IItemController.ItemInfo itemInfo;\n//    bytes32[] attributes;\n  }\n\n  struct ReduceDurabilityContext {\n    /// @notice values 0 or 1 for SKILL_1, SKILL_2, SKILL_3\n    uint8[] skillSlots;\n    uint8[] busySlots;\n    IStatController statController;\n    address itemAdr;\n    uint16 durability;\n    uint itemId;\n  }\n\n  struct TakeOffContext {\n    bool broken;\n    IController controller;\n\n    address msgSender;\n    address heroToken;\n    address destination;\n    IHeroController heroController;\n    IDungeonFactory dungeonFactory;\n    IStatController statController;\n\n    uint heroTokenId;\n  }\n  //endregion ------------------------ STRUCTS\n\n  //region ------------------------ STORAGE\n  function _S() internal pure returns (IItemController.MainState storage s) {\n    assembly {\n      s.slot := MAIN_STORAGE_LOCATION\n    }\n    return s;\n  }\n  //endregion ------------------------ STORAGE\n\n  //region ------------------------ RESTRICTIONS\n\n  function onlyDeployer(IController c, address sender) internal view {\n    if (!c.isDeployer(sender)) revert IAppErrors.ErrorNotDeployer(sender);\n  }\n\n  function onlyOwner(address token, uint tokenId, address sender) internal view {\n    if (IERC721(token).ownerOf(tokenId) != sender) revert IAppErrors.ErrorNotHeroOwner(token, sender);\n  }\n\n  function onlyEOA(bool isEoa) internal view {\n    if (!isEoa) {\n      revert IAppErrors.NotEOA(msg.sender);\n    }\n  }\n\n  function onlyStoryController(IController c, address sender) internal view {\n    if (sender != c.storyController()) revert IAppErrors.ErrorNotStoryController();\n  }\n  //endregion ------------------------ RESTRICTIONS\n\n  //region ------------------------ REGISTER\n\n  function registerItem(\n    IController controller,\n    address msgSender,\n    address item,\n    IItemController.RegisterItemParams calldata info\n  ) internal {\n    onlyDeployer(controller, msgSender);\n    IItemController.MainState storage s = _S();\n\n    if (info.itemMeta.itemMetaType == 0) revert IAppErrors.ZeroItemMetaType();\n    if (info.itemMeta.itemLevel == 0) revert IAppErrors.ZeroLevel();\n\n    if (!s.items.add(item)) {\n      IItemController.ItemMeta memory existMeta = ItemLib.unpackedItemMeta(s.itemMeta[item]);\n        // we should not change types for existed items\n      if (existMeta.itemType != info.itemMeta.itemType) revert IAppErrors.ItemTypeChanged();\n      if (existMeta.itemMetaType != info.itemMeta.itemMetaType) revert IAppErrors.ItemMetaTypeChanged();\n    }\n\n    s.itemMeta[item] = ItemLib.packItemMeta(info.itemMeta);\n\n    s.augmentInfo[item] = PackingLib.packAddressWithAmount(info.augmentToken, info.augmentAmount);\n\n    _setAttributesWithCheck(item, info.commonAttributes, s.generateInfoAttributes);\n\n    if (info.itemMeta.itemMetaType == uint8(IItemController.ItemMetaType.CONSUMABLE)) {\n      s._itemConsumableAttributes[item] = info.consumableAttributes.values.toBytes32ArrayWithIds(info.consumableAttributes.ids);\n\n      s.itemConsumableStats[item] = StatLib.packChangeableStats(info.consumableStats);\n    }\n\n    if (info.itemMeta.itemMetaType == uint8(IItemController.ItemMetaType.BUFF)) {\n      _setAttributesWithCheck(item, info.casterAttributes, s.generateInfoCasterAttributes);\n\n      _setAttributesWithCheck(item, info.targetAttributes, s.generateInfoTargetAttributes);\n    }\n\n    if (info.itemMeta.itemMetaType == uint8(IItemController.ItemMetaType.ATTACK)) {\n      s.generateInfoAttack[item] = ItemLib.packItemAttackInfo(info.genAttackInfo);\n\n      // need to set default attack info for zero id, it will be used in monsters attacks\n      s._itemAttackInfo[item.packNftId(0)] = ItemLib.packItemAttackInfo(info.genAttackInfo);\n    }\n\n    s._consumableActionMask[item] = info.consumableActionMask;\n\n    emit IApplicationEvents.ItemRegistered(item, info);\n  }\n\n  /// @notice  Ensure: min != 0, max != 0 and both min and min should have same sign\n  /// Value of attribute cannot be equal to 0 because toBytes32ArrayWithIds cannot store zero values.\n  function _setAttributesWithCheck(\n    address item,\n    IItemController.ItemGenerateInfo memory data,\n    mapping(address => bytes32[]) storage dest\n  ) internal {\n    for (uint i = 0; i < data.ids.length; ++i) {\n      if (\n        data.mins[i] == 0\n        || data.maxs[i] == 0\n        || data.mins[i] > data.maxs[i]\n        || (data.mins[i] < 0 && data.maxs[i] > 0)\n      ) revert IAppErrors.IncorrectMinMaxAttributeRange(data.mins[i], data.maxs[i]);\n    }\n\n    dest[item] = ItemLib.packItemGenerateInfo(data);\n  }\n\n  function removeItem(IController controller, address msgSender, address item) internal {\n    IItemController.MainState storage s = _S();\n    onlyDeployer(controller, msgSender);\n\n    s.items.remove(item);\n\n    delete s.itemMeta[item];\n    delete s.augmentInfo[item];\n    delete s.generateInfoAttributes[item];\n    delete s._itemConsumableAttributes[item];\n    delete s.itemConsumableStats[item];\n    delete s.generateInfoCasterAttributes[item];\n    delete s.generateInfoTargetAttributes[item];\n    delete s.generateInfoAttack[item];\n    delete s._itemAttackInfo[item.packNftId(0)];\n    delete s._consumableActionMask[item];\n\n    emit IApplicationEvents.ItemRemoved(item);\n  }\n  //endregion ------------------------ REGISTER\n\n  //region ------------------------ EQUIP\n\n  function isItemEquipped(IItemController.MainState storage s, address item, uint itemId) internal view returns (bool) {\n    return s.equippedOn[item.packNftId(itemId)] != bytes32(0);\n  }\n\n  function equipMany(\n    bool isEoa,\n    IController controller,\n    address msgSender,\n    address heroToken,\n    uint heroTokenId,\n    address[] calldata items,\n    uint[] calldata itemIds,\n    uint8[] calldata itemSlots\n  ) internal {\n    onlyEOA(isEoa);\n    IItemController.MainState storage s = _S();\n    if (items.length != itemIds.length || items.length != itemSlots.length) revert IAppErrors.LengthsMismatch();\n\n    EquipLocalContext memory ctx;\n    ctx.statController = IStatController(controller.statController());\n    ctx.dungeonFactory = IDungeonFactory(controller.dungeonFactory());\n    ctx.hc = IHeroController(controller.heroController());\n    (ctx.payToken,) = ctx.hc.payTokenInfo(heroToken);\n    ctx.heroTokenId = heroTokenId;\n    ctx.heroToken = heroToken;\n\n    _checkHeroAndController(controller, ctx.hc, msgSender, heroToken, heroTokenId);\n    if (ctx.dungeonFactory.currentDungeon(heroToken, heroTokenId) != 0) revert IAppErrors.EquipForbiddenInDungeon();\n\n    if (ctx.payToken == address(0)) revert IAppErrors.ErrorEquipForbidden();\n\n    for (uint i; i < items.length; ++i) {\n      _equip(s, ctx, msgSender, items[i], itemIds[i], itemSlots[i]);\n    }\n  }\n\n  /// @notice Equip the item, add bonus attributes, transfer the item from the sender to the hero token\n  function _equip(\n    IItemController.MainState storage s,\n    EquipLocalContext memory c,\n    address msgSender,\n    address item,\n    uint itemId,\n    uint8 itemSlot\n  ) internal {\n    onlyOwner(item, itemId, msgSender);\n\n    IItemController.ItemMeta memory meta = ItemLib.unpackedItemMeta(s.itemMeta[item]);\n    IItemController.ItemInfo memory _itemInfo = ItemLib.unpackedItemInfo(s.itemInfo[item.packNftId(itemId)]);\n\n    if (meta.itemMetaType == 0) revert IAppErrors.UnknownItem(item);\n    if (isItemEquipped(s, item, itemId)) revert IAppErrors.ItemIsAlreadyEquipped(item);\n\n    if (uint(meta.itemType) == 0) revert IAppErrors.Consumable(item);\n    if (meta.baseDurability != 0 && _itemInfo.durability == 0) revert IAppErrors.Broken(item);\n    _checkRequirements(c.statController, c.heroToken, c.heroTokenId, meta.requirements);\n\n    c.statController.changeHeroItemSlot(\n      c.heroToken,\n      uint64(c.heroTokenId),\n      uint(meta.itemType),\n      itemSlot,\n      item,\n      itemId,\n      true\n    );\n\n    bytes32[] memory attributes = s._itemAttributes[item.packNftId(itemId)];\n    if (attributes.length != 0) {\n      c.statController.changeBonusAttributes(IStatController.ChangeAttributesInfo({\n        heroToken: c.heroToken,\n        heroTokenId: c.heroTokenId,\n        changeAttributes: StatLib.bytesToFullAttributesArray(attributes),\n        add: true,\n        temporally: false\n      }));\n\n      // some items can reduce hero life to zero, prevent this\n      if (c.statController.heroStats(c.heroToken, c.heroTokenId).life == 0) revert IAppErrors.ZeroLife();\n    }\n\n    // transfer item to hero\n    IItem(item).controlledTransfer(msgSender, c.heroToken, itemId);\n    // need to equip after transfer for properly checks\n    s.equippedOn[item.packNftId(itemId)] = c.heroToken.packNftId(c.heroTokenId);\n\n    emit IApplicationEvents.Equipped(item, itemId, c.heroToken, c.heroTokenId, itemSlot);\n  }\n\n  function _checkRequirements(\n    IStatController statController,\n    address heroToken,\n    uint heroTokenId,\n    IStatController.CoreAttributes memory requirements\n  ) internal view {\n    IStatController.CoreAttributes memory attributes = statController.heroBaseAttributes(heroToken, heroTokenId);\n    if (\n      requirements.strength > attributes.strength\n      || requirements.dexterity > attributes.dexterity\n      || requirements.vitality > attributes.vitality\n      || requirements.energy > attributes.energy\n    ) revert IAppErrors.RequirementsToItemAttributes();\n  }\n\n  /// @notice Check requirements for the hero and for the controller state before equip/take off/use items\n  function _checkHeroAndController(\n    IController controller,\n    IHeroController heroController,\n    address msgSender,\n    address heroToken,\n    uint heroTokenId\n  ) internal view {\n    onlyOwner(heroToken, heroTokenId, msgSender);\n    if (IReinforcementController(controller.reinforcementController()).isStaked(heroToken, heroTokenId)) revert IAppErrors.Staked(heroToken, heroTokenId);\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\n    if (heroController.heroClass(heroToken) == 0) revert IAppErrors.ErrorHeroIsNotRegistered(heroToken);\n  }\n  //endregion ------------------------ EQUIP\n\n  //region ------------------------ TAKE OFF\n\n  function takeOffMany(\n    bool isEoa,\n    IController controller,\n    address msgSender,\n    address heroToken,\n    uint heroTokenId,\n    address[] calldata items,\n    uint[] calldata tokenIds,\n    uint8[] calldata itemSlots\n  ) external {\n    onlyEOA(isEoa);\n\n    TakeOffContext memory ctx = ItemStatsLib.TakeOffContext({\n      controller: controller,\n      msgSender: msgSender,\n      heroToken: heroToken,\n      heroTokenId: heroTokenId,\n      destination: msgSender,\n      broken: false,\n      heroController: IHeroController(controller.heroController()),\n      dungeonFactory: IDungeonFactory(controller.dungeonFactory()),\n      statController: IStatController(controller.statController())\n    });\n\n    IItemController.MainState storage s = _S();\n    uint len = items.length;\n    if (len != tokenIds.length || len != itemSlots.length) revert IAppErrors.LengthsMismatch();\n\n    for (uint i; i < len; ++i) {\n      _takeOffWithChecks(s, ctx, items[i], tokenIds[i], itemSlots[i]);\n    }\n  }\n\n  /// @dev Some stories can manipulate items\n  function takeOffDirectly(\n    IController controller,\n    address item,\n    uint itemId,\n    address hero,\n    uint heroId,\n    uint8 itemSlot,\n    address destination,\n    bool broken\n  ) internal {\n    if (controller.storyController() != msg.sender && controller.heroController() != msg.sender) {\n      revert IAppErrors.ErrorForbidden(msg.sender);\n    }\n    ItemStatsLib._takeOff(_S(), IStatController(controller.statController()), item, itemId, hero, heroId, itemSlot, destination, broken);\n  }\n\n  function _takeOffWithChecks(\n    IItemController.MainState storage s,\n    TakeOffContext memory ctx,\n    address item,\n    uint itemId,\n    uint8 itemSlot\n  ) internal {\n    _checkHeroAndController(ctx.controller,\n      ctx.heroController,\n      ctx.msgSender,\n      ctx.heroToken,\n      ctx.heroTokenId\n    );\n    if (ctx.dungeonFactory.currentDungeon(ctx.heroToken, ctx.heroTokenId) != 0) revert IAppErrors.TakeOffForbiddenInDungeon();\n\n    if (s.equippedOn[item.packNftId(itemId)] != ctx.heroToken.packNftId(ctx.heroTokenId)) revert IAppErrors.NotEquipped(item);\n\n    _takeOff(s, ctx.statController, item, itemId, ctx.heroToken, ctx.heroTokenId, itemSlot, ctx.destination, ctx.broken);\n  }\n\n  /// @notice Take off the item, remove bonus attributes, transfer the item from the hero token to {destination}\n  /// @param broken True if the item is broken. The durability of the broken item will be set to 0.\n  function _takeOff(\n    IItemController.MainState storage s,\n    IStatController statController,\n    address item,\n    uint itemId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 itemSlot,\n    address destination,\n    bool broken\n  ) internal {\n    bytes32 packedItemId = item.packNftId(itemId);\n    IItemController.ItemMeta memory meta = ItemLib.unpackedItemMeta(s.itemMeta[item]);\n    IItemController.ItemInfo memory _itemInfo = ItemLib.unpackedItemInfo(s.itemInfo[packedItemId]);\n\n    if (uint(meta.itemType) == 0) revert IAppErrors.Consumable(item);\n\n    statController.changeHeroItemSlot(\n      heroToken,\n      uint64(heroTokenId),\n      uint(meta.itemType),\n      itemSlot,\n      item,\n      itemId,\n      false\n    );\n\n    if (broken) {\n      _itemInfo.durability = 0;\n      s.itemInfo[packedItemId] = ItemLib.packItemInfo(_itemInfo);\n    }\n\n    bytes32[] memory attributes = s._itemAttributes[packedItemId];\n    if (attributes.length != 0) {\n      statController.changeBonusAttributes(IStatController.ChangeAttributesInfo({\n        heroToken: heroToken,\n        heroTokenId: heroTokenId,\n        changeAttributes: StatLib.bytesToFullAttributesArray(attributes),\n        add: false,\n        temporally: false\n      }));\n    }\n\n    // need to take off before transfer for properly checks\n    s.equippedOn[packedItemId] = bytes32(0);\n    IItem(item).controlledTransfer(heroToken, destination, itemId);\n\n    emit IApplicationEvents.TakenOff(item, itemId, heroToken, heroTokenId, itemSlot, destination);\n  }\n  //endregion ------------------------ TAKE OFF\n\n  //region ------------------------ AUGMENT and REPAIR\n\n  /// @notice Initialization for augment() and repairDurability()\n  /// Get {meta} and {info}, check some restrictions\n  function _prepareToAugment(\n    IItemController.MainState storage s,\n    bool isEoa,\n    IController controller,\n    address msgSender,\n    address item,\n    uint itemId,\n    uint consumedItemId\n  ) internal view returns(\n    IItemController.ItemMeta memory meta,\n    IItemController.ItemInfo memory info\n  ) {\n    onlyEOA(isEoa);\n    if (itemId == consumedItemId) revert IAppErrors.SameIdsNotAllowed();\n    onlyOwner(item, itemId, msgSender);\n    onlyOwner(item, consumedItemId, msgSender);\n\n    meta = ItemLib.unpackedItemMeta(s.itemMeta[item]);\n    info = ItemLib.unpackedItemInfo(s.itemInfo[item.packNftId(itemId)]);\n\n    if (isItemEquipped(s, item, itemId) || isItemEquipped(s, item, consumedItemId)) revert IAppErrors.ItemEquipped();\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\n  }\n\n  /// @notice Destroy {consumed item} to repair durability of the {item}\n  /// There is a chance ~ item fragility that the item won't be repaired.\n  function repairDurability(\n    bool isEoa,\n    IController controller,\n    address msgSender,\n    address item,\n    uint itemId,\n    uint consumedItemId\n  ) external {\n    _repairDurability(isEoa, controller, msgSender, item, itemId, consumedItemId, CalcLib.pseudoRandom);\n  }\n\n  /// @notice Destroy {consumed item} to repair durability of the {item}\n  /// There is a chance ~ item fragility that the item won't be repaired.\n  /// @param random_ Pass _pseudoRandom here, param is required to simplify unit testing\n  function _repairDurability(\n    bool isEoa,\n    IController controller,\n    address msgSender,\n    address item,\n    uint itemId,\n    uint consumedItemId,\n    function (uint) internal view returns (uint) random_\n  ) internal {\n    // restrictions are checked inside {_prepareToAugment}\n    IItemController.MainState storage s = _S();\n    (\n      IItemController.ItemMeta memory meta,\n      IItemController.ItemInfo memory _itemInfo\n    ) = _prepareToAugment(s, isEoa, controller, msgSender, item, itemId, consumedItemId);\n\n    if (meta.baseDurability == 0) revert IAppErrors.ZeroDurability();\n\n    _destroy(item, consumedItemId);\n    _sendFee(s, controller, item, msgSender, IItemController.FeeType.REPAIR);\n\n    // SIP-003: There is a chance of unsuccessful repair ~ to the item fragility\n    uint fragility = itemFragility(item, itemId);\n    bool success = fragility == 0 || random_(MAX_FRAGILITY - 1) > fragility;\n    // Each successful repair has a 10% chance of increasing the item's fragility by 1%.\n    bool incFragility = random_(100) < FRAGILITY_SUCCESSFUL_REPAIR_CHANCE;\n\n    _itemInfo.durability = success\n      ? meta.baseDurability // the item is repaired successfully\n      : _itemInfo.durability;\n\n    // try to hide gas difference between successful and failed cases\n    _addItemFragility(item, itemId, success && incFragility ? FRAGILITY_SUCCESSFUL_REPAIR_PORTION : 0); // item fragility is increased\n\n    s.itemInfo[item.packNftId(itemId)] = ItemLib.packItemInfo(_itemInfo);\n\n    if (success) {\n      emit IApplicationEvents.ItemRepaired(item, itemId, consumedItemId, meta.baseDurability);\n    } else {\n      emit IApplicationEvents.FailedToRepairItem(item, itemId, consumedItemId, _itemInfo.durability);\n    }\n  }\n\n  /// @notice Destroy {consumed item} to augment given {item}.\n  /// There is a chance of 30% that the item will be destroyed instead of augmentation.\n  function augment(\n    bool isEoa,\n    IController controller,\n    address msgSender,\n    address item,\n    uint itemId,\n    uint consumedItemId\n  ) external {\n    // restrictions are checked inside {_prepareToAugment}\n    IItemController.MainState storage s = _S();\n    (\n      IItemController.ItemMeta memory meta,\n      IItemController.ItemInfo memory _itemInfo\n    ) = _prepareToAugment(s, isEoa, controller, msgSender, item, itemId, consumedItemId);\n\n    if (meta.itemMetaType == uint8(IItemController.ItemMetaType.CONSUMABLE)) revert IAppErrors.Consumable(item);\n    if (_itemInfo.augmentationLevel >= MAX_AUGMENTATION_LEVEL) revert IAppErrors.TooHighAgLevel(_itemInfo.augmentationLevel);\n\n    _destroy(item, consumedItemId);\n\n    address augToken = _sendFee(s, controller, item, msgSender, IItemController.FeeType.AUGMENT);\n    // we check augToken for 0 AFTER sendFee to avoid second reading of augmentInfo\n    if (augToken == address(0)) revert IAppErrors.ZeroAugmentation();\n\n    if (IOracle(controller.oracle()).getRandomNumber(1e18, 0) < AUGMENT_CHANCE) {\n      IItemController.AugmentInfo memory _augmentInfo;\n      bytes32 packedItemId = item.packNftId(itemId);\n\n      // augment base\n      (_augmentInfo.attributesValues, _augmentInfo.attributesIds) = _augmentAttributes(s._itemAttributes[packedItemId], true);\n      s._itemAttributes[packedItemId] = _augmentInfo.attributesValues.toBytes32ArrayWithIds(_augmentInfo.attributesIds);\n\n      // additionally\n      if (meta.itemMetaType == uint8(IItemController.ItemMetaType.ATTACK)) {\n        _augmentInfo.attackInfo = ItemLib.unpackItemAttackInfo(s._itemAttackInfo[packedItemId]);\n        _augmentInfo.attackInfo.min = _augmentAttribute(_augmentInfo.attackInfo.min);\n        _augmentInfo.attackInfo.max = _augmentAttribute(_augmentInfo.attackInfo.max);\n        s._itemAttackInfo[packedItemId] = ItemLib.packItemAttackInfo(_augmentInfo.attackInfo);\n      } else if (meta.itemMetaType == uint8(IItemController.ItemMetaType.BUFF)) {\n        // caster\n        (_augmentInfo.casterValues, _augmentInfo.casterIds) = _augmentAttributes(s._itemCasterAttributes[packedItemId], true);\n        s._itemCasterAttributes[packedItemId] = _augmentInfo.casterValues.toBytes32ArrayWithIds(_augmentInfo.casterIds);\n\n        // target\n        (_augmentInfo.targetValues, _augmentInfo.targetIds) = _augmentAttributes(s._itemTargetAttributes[packedItemId], false);\n        s._itemTargetAttributes[packedItemId] = _augmentInfo.targetValues.toBytes32ArrayWithIds(_augmentInfo.targetIds);\n      }\n\n      // increase aug level\n      _itemInfo.augmentationLevel = _itemInfo.augmentationLevel + 1;\n      s.itemInfo[packedItemId] = ItemLib.packItemInfo(_itemInfo);\n\n      emit IApplicationEvents.Augmented(item, itemId, consumedItemId, _itemInfo.augmentationLevel, _augmentInfo);\n    } else {\n      _destroy(item, itemId);\n      emit IApplicationEvents.NotAugmented(item, itemId, consumedItemId, _itemInfo.augmentationLevel);\n    }\n  }\n\n  /// @notice Modify either positive or negative values\n  /// @param ignoreNegative True - leave unchanged all negative values, False - don't change all positive values\n  function _augmentAttributes(bytes32[] memory packedAttr, bool ignoreNegative) internal pure returns (\n    int32[] memory values,\n    uint8[] memory ids\n  ) {\n    (values, ids) = packedAttr.toInt32ArrayWithIds();\n    for (uint i; i < values.length; ++i) {\n      // do not increase destroy item attribute\n      if(uint(ids[i]) == uint(IStatController.ATTRIBUTES.DESTROY_ITEMS)) {\n        continue;\n      }\n      if ((ignoreNegative && values[i] > 0) || (!ignoreNegative && values[i] < 0)) {\n        values[i] = _augmentAttribute(values[i]);\n      }\n    }\n  }\n\n  /// @notice Increase/decrease positive/negative value on ceil(value/20) but at least on 1\n  function _augmentAttribute(int32 value) internal pure returns (int32) {\n    if (value == 0) {\n      return 0;\n    }\n    // bonus must be not lower than 1\n    if (value > 0) {\n      return value + int32(int(Math.max(Math.ceilDiv(value.toUint(), AUGMENT_FACTOR), 1)));\n    } else {\n      return value - int32(int(Math.max(Math.ceilDiv((- value).toUint(), AUGMENT_FACTOR), 1)));\n    }\n  }\n  //endregion ------------------------ AUGMENT and REPAIR\n\n  //region ------------------------ NEW ITEM CREATION\n\n  function mintNewItem(\n    IController controller,\n    address sender,\n    address item,\n    address recipient\n  ) internal returns (uint itemId) {\n    return ItemLib.mintNewItem(_S(), controller, sender, item, recipient);\n  }\n  //endregion ------------------------ NEW ITEM CREATION\n\n  //region ------------------------ REDUCE DURABILITY\n\n  /// @notice Reduce durability of all equipped items except items of SKILL-type.\n  function reduceEquippedItemsDurability(\n    IController controller,\n    address msgSender,\n    address hero,\n    uint heroId,\n    uint8 biome\n  ) external {\n    address dungeonFactory = controller.dungeonFactory();\n    if (dungeonFactory != msgSender) revert IAppErrors.ErrorNotDungeonFactory(msgSender);\n    IItemController.MainState storage s = _S();\n\n    ReduceDurabilityContext memory ctx;\n    ctx.skillSlots = IDungeonFactory(dungeonFactory).skillSlotsForDurabilityReduction(hero, heroId);\n    ctx.statController = IStatController(controller.statController());\n    ctx.busySlots = ctx.statController.heroItemSlots(hero, heroId);\n\n    for (uint i; i < ctx.busySlots.length; ++i) {\n\n      if (\n        (ctx.busySlots[i] == uint8(IStatController.ItemSlots.SKILL_1) && ctx.skillSlots[0] == 0)\n        || (ctx.busySlots[i] == uint8(IStatController.ItemSlots.SKILL_2) && ctx.skillSlots[1] == 0)\n        || (ctx.busySlots[i] == uint8(IStatController.ItemSlots.SKILL_3) && ctx.skillSlots[2] == 0)\n      ) {\n        continue;\n      }\n\n      (ctx.itemAdr, ctx.itemId) = ctx.statController.heroItemSlot(hero, uint64(heroId), ctx.busySlots[i]).unpackNftId();\n      ctx.durability = _reduceDurabilityForItem(s, ctx.itemAdr, ctx.itemId, biome);\n\n      // if broken need to take off\n      if (ctx.durability == 0) {\n        _takeOff(\n          s,\n          ctx.statController,\n          ctx.itemAdr,\n          ctx.itemId,\n          hero,\n          heroId,\n          ctx.busySlots[i],\n          IERC721(hero).ownerOf(heroId),\n          false\n        );\n      }\n\n    }\n  }\n\n  /// @notice newDurability Calculate new durability for the {item}, update {itemInfo}\n  function _reduceDurabilityForItem(\n    IItemController.MainState storage s,\n    address item,\n    uint itemId,\n    uint biome\n  ) internal returns (uint16 newDurability) {\n    IItemController.ItemMeta memory meta = ItemLib.unpackedItemMeta(s.itemMeta[item]);\n    IItemController.ItemInfo memory _itemInfo = ItemLib.unpackedItemInfo(s.itemInfo[item.packNftId(itemId)]);\n\n    newDurability = uint16(_calcReduceDurability(biome, _itemInfo.durability, meta.itemLevel, meta.itemType));\n\n    _itemInfo.durability = newDurability;\n    s.itemInfo[item.packNftId(itemId)] = ItemLib.packItemInfo(_itemInfo);\n\n    emit IApplicationEvents.ReduceDurability(item, itemId, newDurability);\n  }\n\n  /// @return New (reduced) value for the current durability\n  function _calcReduceDurability(\n    uint biome,\n    uint currentDurability,\n    uint8 itemLevel,\n    IItemController.ItemType itemType\n  ) internal pure returns (uint) {\n    uint value = DURABILITY_REDUCTION;\n\n    if (itemType != IItemController.ItemType.SKILL) {\n      uint itemBiomeLevel = uint(itemLevel) / StatLib.BIOME_LEVEL_STEP + 1;\n      if (itemBiomeLevel < biome) {\n        value = DURABILITY_REDUCTION * ((biome - itemBiomeLevel + 1) ** 2 / 2);\n      }\n    }\n\n    return currentDurability > value\n      ? currentDurability - value\n      : 0;\n  }\n  //endregion ------------------------ REDUCE DURABILITY\n\n  //region ------------------------ DESTROY\n\n  function destroy(IController controller, address msgSender, address item, uint itemId) external {\n    if (\n      controller.gameObjectController() != msgSender\n      && controller.storyController() != msgSender\n      && IERC721(item).ownerOf(itemId) != msgSender\n    ) {\n      revert IAppErrors.ErrorForbidden(msgSender);\n    }\n\n    if (isItemEquipped(_S(), item, itemId)) revert IAppErrors.ItemEquipped();\n\n    _destroy(item, itemId);\n  }\n\n  function _destroy(address item, uint itemId) internal {\n    IItem(item).burn(itemId);\n    emit IApplicationEvents.Destroyed(item, itemId);\n  }\n  //endregion ------------------------ DESTROY\n\n  //region ------------------------ FEE\n\n  /// @return augToken Return augToken to avoid repeat reading of augmentInfo inside augment()\n  function _sendFee(\n    IItemController.MainState storage s,\n    IController controller,\n    address item,\n    address msgSender,\n    IItemController.FeeType feeType\n  ) internal returns (address augToken) {\n    (address token, uint amount) = s.augmentInfo[item].unpackAddressWithAmount();\n    if (token != address(0)) {\n      address treasury = controller.treasury();\n      IERC20(token).transferFrom(msgSender, address(this), amount);\n\n      AppLib.approveIfNeeded(token, amount, treasury);\n      ITreasury(treasury).sendFee(token, amount, feeType);\n    }\n    return token;\n  }\n  //endregion ------------------------ FEE\n\n  //region ------------------------ USE\n\n  /// @notice Use consumable item to temporally increase bonus attributes and destroy the item\n  function use(\n    bool isEoa,\n    IController controller,\n    address msgSender,\n    address item,\n    uint itemId,\n    address heroToken,\n    uint heroTokenId\n  ) external {\n    onlyEOA(isEoa);\n    onlyOwner(item, itemId, msgSender);\n\n    IItemController.MainState storage s = _S();\n\n    IStatController statController = IStatController(controller.statController());\n    IHeroController hc = IHeroController(controller.heroController());\n\n    (address payToken,) = hc.payTokenInfo(heroToken);\n    if (payToken == address(0)) revert IAppErrors.UseForbiddenZeroPayToken();\n\n    _checkHeroAndController(controller, hc, msgSender, heroToken, heroTokenId);\n\n    IItemController.ItemMeta memory meta = ItemLib.unpackedItemMeta(s.itemMeta[item]);\n    if (uint8(meta.itemType) != 0) revert IAppErrors.NotConsumable(item);\n    _checkRequirements(statController, heroToken, heroTokenId, meta.requirements);\n\n    statController.registerConsumableUsage(heroToken, heroTokenId, item);\n\n    statController.changeCurrentStats(heroToken, heroTokenId, StatLib.unpackChangeableStats(s.itemConsumableStats[item]), true);\n\n    bytes32[] memory itemConsumableAttributes = s._itemConsumableAttributes[item];\n    if (itemConsumableAttributes.length != 0) {\n      int32[] memory attributes = StatLib.bytesToFullAttributesArray(itemConsumableAttributes);\n      statController.changeBonusAttributes(IStatController.ChangeAttributesInfo({\n        heroToken: heroToken,\n        heroTokenId: heroTokenId,\n        changeAttributes: attributes,\n        add: true,\n        temporally: true\n      }));\n    }\n\n    uint actionMask = s._consumableActionMask[item];\n    if ((actionMask & (2**uint(IItemController.ConsumableActionBits.CLEAR_TEMPORARY_ATTRIBUTES_0))) != 0) {\n      statController.clearTemporallyAttributes(heroToken, heroTokenId);\n    }\n    if ((actionMask & (2**uint(IItemController.ConsumableActionBits.EXIT_FROM_DUNGEON_1))) != 0) {\n      _actionExitFromDungeon(heroToken, heroTokenId);\n    }\n    if ((actionMask & (2**uint(IItemController.ConsumableActionBits.USE_GUILD_REINFORCEMENT_2))) != 0) {\n      _askGuildReinforcement(heroToken, heroTokenId);\n    }\n    if ((actionMask & (2**uint(IItemController.ConsumableActionBits.RECREATION_IN_GUILD_HOUSE_3))) != 0) {\n      _actionRestInGuildHouse(heroToken, heroTokenId);\n    }\n\n    _destroy(item, itemId);\n    emit IApplicationEvents.Used(item, itemId, heroToken, heroTokenId);\n  }\n  //endregion ------------------------ USE\n\n  //region ------------------------ Consumable actions\n  function _actionExitFromDungeon(address heroToken, uint heroTokenId) internal {\n    // todo ensure that user belongs to a guild and the guild has a guild house\n    // todo exit from the dungeon\n  }\n\n  function _askGuildReinforcement(address heroToken, uint heroTokenId) internal {\n    // todo ensure that user belongs to a guild and the guild has free heroes for reinforcement\n  }\n\n  function _actionRestInGuildHouse(address heroToken, uint heroTokenId) internal {\n    // todo ensure that user belongs to a guild\n    // todo 100% restore of hp and mp, clear temporally attributes, restore the health of all consumable items\n  }\n  //endregion ------------------------ Consumable actions\n\n  //region ------------------------ VIEWS\n  function itemByIndex(uint idx) internal view returns (address) {\n    return _S().items.at(idx);\n  }\n\n  function itemsLength() internal view returns (uint) {\n    return _S().items.length();\n  }\n\n  function itemMeta(address item) internal view returns (IItemController.ItemMeta memory meta) {\n    return ItemLib.unpackedItemMeta(_S().itemMeta[item]);\n  }\n\n  function augmentInfo(address item) internal view returns (address token, uint amount) {\n    return PackingLib.unpackAddressWithAmount(_S().augmentInfo[item]);\n  }\n\n  function genAttributeInfo(address item) internal view returns (IItemController.ItemGenerateInfo memory info) {\n    return ItemLib.unpackItemGenerateInfo(_S().generateInfoAttributes[item]);\n  }\n\n  function genCasterAttributeInfo(address item) internal view returns (IItemController.ItemGenerateInfo memory info) {\n    return ItemLib.unpackItemGenerateInfo(_S().generateInfoCasterAttributes[item]);\n  }\n\n  function genTargetAttributeInfo(address item) internal view returns (IItemController.ItemGenerateInfo memory info) {\n    return ItemLib.unpackItemGenerateInfo(_S().generateInfoTargetAttributes[item]);\n  }\n\n  function genAttackInfo(address item) internal view returns (IItemController.AttackInfo memory info) {\n    return ItemLib.unpackItemAttackInfo(_S().generateInfoAttack[item]);\n  }\n\n  function itemInfo(address item, uint itemId) internal view returns (IItemController.ItemInfo memory info) {\n    return ItemLib.unpackedItemInfo(_S().itemInfo[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function equippedOn(address item, uint itemId) internal view returns (address hero, uint heroId) {\n    return PackingLib.unpackNftId(_S().equippedOn[item.packNftId(itemId)]);\n  }\n\n  function itemAttributes(address item, uint itemId) internal view returns (int32[] memory values, uint8[] memory ids) {\n    return PackingLib.toInt32ArrayWithIds(_S()._itemAttributes[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function consumableAttributes(address item) internal view returns (int32[] memory values, uint8[] memory ids) {\n    return PackingLib.toInt32ArrayWithIds(_S()._itemConsumableAttributes[item]);\n  }\n\n  function consumableStats(address item) internal view returns (IStatController.ChangeableStats memory stats) {\n    return StatLib.unpackChangeableStats(_S().itemConsumableStats[item]);\n  }\n\n  function casterAttributes(address item, uint itemId) internal view returns (int32[] memory values, uint8[] memory ids) {\n    return PackingLib.toInt32ArrayWithIds(_S()._itemCasterAttributes[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function targetAttributes(address item, uint itemId) internal view returns (int32[] memory values, uint8[] memory ids) {\n    return PackingLib.toInt32ArrayWithIds(_S()._itemTargetAttributes[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function itemAttackInfo(address item, uint itemId) internal view returns (IItemController.AttackInfo memory info) {\n    return ItemLib.unpackItemAttackInfo(_S()._itemAttackInfo[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function score(address item, uint itemId) external view returns (uint) {\n    return ScoreLib.itemScore(\n      StatLib.bytesToFullAttributesArray(_S()._itemAttributes[PackingLib.packNftId(item, itemId)]),\n      ItemLib.unpackedItemMeta(_S().itemMeta[item]).baseDurability\n    );\n  }\n\n  function isAllowedToTransfer(address item, uint itemId) internal view returns (bool) {\n    return _S().equippedOn[item.packNftId(itemId)] == bytes32(0);\n  }\n\n  function consumableActionMask(address item) internal view returns (uint) {\n    return _S()._consumableActionMask[item];\n  }\n\n  /// @notice SIP-003: item fragility counter that displays the chance of an unsuccessful repair.\n  /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\n  function itemFragility(address item, uint itemId) internal view returns (uint) {\n    return _S().itemFragility[item.packNftId(itemId)];\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ SIP-003: Item fragility\n  function _addItemFragility(address item, uint itemId, uint portion) internal {\n    uint fragility = _S().itemFragility[item.packNftId(itemId)];\n    _S().itemFragility[item.packNftId(itemId)] = fragility + portion > MAX_FRAGILITY\n      ? MAX_FRAGILITY\n      : fragility + portion;\n  }\n\n  /// @notice SIP-003: The quest mechanic that previously burned the item will increase its fragility by 1%\n  function incBrokenItemFragility(IController controller, address item, uint itemId) internal {\n    onlyStoryController(controller, msg.sender);\n    _addItemFragility(item, itemId, FRAGILITY_BREAK_ITEM_PORTION);\n  }\n  //endregion ------------------------ SIP-003: Item fragility\n}\n"
    },
    "contracts/lib/MonsterLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IGOC.sol\";\nimport \"./CalcLib.sol\";\nimport \"./PackingLib.sol\";\nimport \"./StatLib.sol\";\nimport \"./ItemLib.sol\";\nimport \"./StringLib.sol\";\nimport \"./FightLib.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IStatController.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IFightCalculator.sol\";\nimport \"../interfaces/IDungeonFactory.sol\";\nimport \"../interfaces/IItemController.sol\";\nimport \"../interfaces/IERC20.sol\";\n\nlibrary MonsterLib {\n  using CalcLib for int32;\n  using PackingLib for bytes32;\n  using PackingLib for bytes32[];\n  using PackingLib for uint16;\n  using PackingLib for uint8;\n  using PackingLib for address;\n  using PackingLib for uint32[];\n  using PackingLib for uint32;\n  using PackingLib for uint64;\n  using PackingLib for int32[];\n  using PackingLib for int32;\n\n  /// @notice Max value for monster rarity and monster/dungeon multiplier\n  uint32 internal constant _MAX_AMPLIFIER = 1e9;\n  uint private constant _TOTAL_SUPPLY_BASE = 10_000_000e18;\n\n  //region ------------------------ Data types\n  struct AdrContext {\n    address sender;\n    address heroToken;\n    IController controller;\n    IOracle oracle;\n    IStatController statController;\n    IItemController itemController;\n    uint heroTokenId;\n  }\n\n  struct FightInternalInfo {\n    int32 manaConsumed;\n    int32 damage;\n    int32 heroLifeRegen;\n    int32 heroHp;\n    int32 monsterHp;\n    uint32 monsterRarity;\n    IFightCalculator.FighterInfo heroFightInfo;\n    IFightCalculator.FighterInfo monsterFightInfo;\n  }\n  //endregion ------------------------ Data types\n\n  //region ------------------------ Main logic\n\n  function initialGeneration(IGOC.MonsterInfo storage mInfo, address heroToken, uint heroTokenId, uint iteration, uint totalSupply) internal {\n    return _initialGeneration(mInfo, heroToken, heroTokenId, iteration, _pseudoRandom, totalSupply);\n  }\n\n  /// @notice Fight, post fight, generate fight results\n  /// @return result Fields objectId, heroToken, heroTokenId, iteration remain uninitialized here.\n  /// Caller is responsible to set that values.\n  /// @dev weird, but memory ctx is more efficient here than calldata ctx\n  function action(IGOC.ActionContext memory ctx, IGOC.MonsterInfo storage mInfo) external returns (\n    IGOC.ActionResult memory result,\n    uint8 turn\n  ) {\n    return _action(ctx, mInfo, _pseudoRandom, FightLib.fight);\n  }\n\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ Internal calculations\n  function _action(\n    IGOC.ActionContext memory ctx,\n    IGOC.MonsterInfo storage mInfo,\n    function (uint) internal view returns (uint) random_,\n    function(\n      IItemController,\n      IFightCalculator.FightCall memory,\n      address,\n      function (uint) internal view returns (uint)\n    ) internal returns (IFightCalculator.FightResult memory) fight_\n  ) internal returns (\n    IGOC.ActionResult memory result,\n    uint8 turn\n  ) {\n    AdrContext memory adrCtx = _context(ctx);\n    IGOC.GeneratedMonster memory gen = unpackGeneratedMonster(mInfo._generatedMonsters[ctx.heroToken.packNftId(ctx.heroTokenId)][ctx.iteration]);\n    turn = gen.turnCounter;\n\n    (FightInternalInfo memory fInfo, IGOC.MonsterGenInfo memory genInfo) = _fight(ctx, mInfo, gen, adrCtx, random_, fight_);\n    result = _postFight(mInfo, ctx, adrCtx, fInfo, genInfo, gen);\n  }\n\n  /// @dev This function was extracted from {action()} to simplify unit testing\n  /// @param gen These values CAN BE modified in place in some cases.\n  /// @return result Fields objectId, heroToken, heroTokenId, iteration remain uninitialized here.\n  /// Caller is responsible to set that values.\n  function _postFight(\n    IGOC.MonsterInfo storage mInfo,\n    IGOC.ActionContext memory ctx,\n    AdrContext memory adrCtx,\n    FightInternalInfo memory fInfo,\n    IGOC.MonsterGenInfo memory genInfo,\n    IGOC.GeneratedMonster memory gen\n  ) internal returns (\n    IGOC.ActionResult memory result\n  ) {\n    bytes32 heroPackedId = ctx.heroToken.packNftId(ctx.heroTokenId);\n    if (gen.turnCounter > 100) {\n      // instant kill hero if too long battle\n      fInfo.heroHp = 0;\n    }\n\n    bool isMonsterDead = fInfo.monsterHp == 0;\n    bool isHeroDead = fInfo.heroHp == 0;\n\n    if (isMonsterDead) {\n      _bossDefeated(adrCtx, ctx);\n    }\n\n    if (isMonsterDead || isHeroDead) {\n      if (gen.generated) {\n        delete mInfo._generatedMonsters[heroPackedId][ctx.iteration];\n      }\n      // assume that if the hero is dead clearUsedConsumables will be called in _objectAction\n      if (isMonsterDead) {\n        adrCtx.statController.clearUsedConsumables(ctx.heroToken, ctx.heroTokenId);\n      }\n    } else {\n      if (gen.generated) {\n        gen.hp = fInfo.monsterHp;\n        gen.turnCounter = gen.turnCounter + 1;\n      } else {\n        // new instance of gen is created\n        gen = IGOC.GeneratedMonster({\n          generated: true,\n          amplifier: fInfo.monsterRarity,\n          hp: fInfo.monsterHp,\n          turnCounter: 1\n        });\n      }\n\n      mInfo._generatedMonsters[heroPackedId][ctx.iteration] = packGeneratedMonster(gen);\n    }\n\n    if (isMonsterDead) {\n      bytes32 index = _getMonsterCounterIndex(ctx.objectId);\n      uint curValue = adrCtx.statController.heroCustomData(ctx.heroToken, ctx.heroTokenId, index);\n      adrCtx.statController.setHeroCustomData(ctx.heroToken, ctx.heroTokenId, index, curValue + 1);\n    }\n\n    // --- generate result\n    result.kill = isHeroDead;\n    result.experience = isMonsterDead\n      ? StatLib.expPerMonster(\n        fInfo.monsterFightInfo.fighterStats.experience,\n        fInfo.monsterRarity,\n        fInfo.heroFightInfo.fighterStats.experience,\n        fInfo.heroFightInfo.fighterStats.level,\n        ctx.biome\n      )\n      : 0;\n\n    result.heal = fInfo.heroLifeRegen;\n    result.manaRegen = isMonsterDead ? fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MANA_AFTER_KILL)] : int32(0);\n    // result.lifeChancesRecovered = 0; // zero by default\n    result.damage = fInfo.damage;\n    result.manaConsumed = fInfo.manaConsumed;\n    result.mintItems = isMonsterDead\n      ? _mintRandomItems(fInfo, ctx, genInfo, CalcLib.nextPrng)\n      : new address[](0);\n    result.completed = isMonsterDead || isHeroDead;\n\n    return result;\n  }\n\n  /// @notice Generate new {GeneratedMonster} and put it to {mInfo._generatedMonsters}\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...MAX_AMPLIFIER]\n  function _initialGeneration(\n    IGOC.MonsterInfo storage mInfo,\n    address heroToken,\n    uint heroTokenId,\n    uint iteration,\n    function (uint) internal view returns (uint) random_,\n    uint totalSupply\n  ) internal {\n    IGOC.GeneratedMonster memory gen = IGOC.GeneratedMonster({\n      generated: true,\n      amplifier: uint32(random_(_MAX_AMPLIFIER)),\n      hp: 0,\n      turnCounter: 0\n    });\n\n    IGOC.MonsterGenInfo memory info = unpackMonsterInfo(mInfo);\n\n    (int32[] memory attributes,) = generateMonsterAttributes(\n      info.attributeIds,\n      info.attributeValues,\n      gen.amplifier,\n      monsterMultiplier(totalSupply),\n      info.experience\n    );\n    gen.hp = attributes[uint(IStatController.ATTRIBUTES.LIFE)];\n\n    mInfo._generatedMonsters[heroToken.packNftId(heroTokenId)][iteration] = packGeneratedMonster(gen);\n  }\n\n  function _bossDefeated(AdrContext memory adrCtx, IGOC.ActionContext memory ctx) internal {\n    if (ctx.objectSubType == uint8(IGOC.ObjectSubType.BOSS_3)) {\n      IDungeonFactory(adrCtx.controller.dungeonFactory()).setBossCompleted(ctx.objectId, ctx.heroToken, ctx.heroTokenId, ctx.biome);\n    }\n  }\n\n  function _collectHeroFighterInfo(\n    IFightCalculator.AttackInfo memory attackInfo,\n    AdrContext memory adrContext\n  ) internal view returns (\n    IFightCalculator.FighterInfo memory fInfo,\n    int32 manaConsumed\n  ) {\n    IStatController.ChangeableStats memory heroStats = adrContext.statController.heroStats(adrContext.heroToken, adrContext.heroTokenId);\n\n    (int32[] memory heroAttributes, int32 _manaConsumed) = _buffAndGetHeroAttributes(heroStats.level, attackInfo, adrContext);\n\n    manaConsumed = _manaConsumed;\n\n    if (attackInfo.attackType == IFightCalculator.AttackType.MAGIC) {\n      manaConsumed += int32(adrContext.itemController.itemMeta(attackInfo.attackToken).manaCost);\n    }\n\n    fInfo = IFightCalculator.FighterInfo({\n      fighterAttributes: heroAttributes,\n      fighterStats: heroStats,\n      attackType: attackInfo.attackType,\n      attackToken: attackInfo.attackToken,\n      attackTokenId: attackInfo.attackTokenId,\n      race: uint(IStatController.Race.HUMAN)\n    });\n  }\n\n  function _buffAndGetHeroAttributes(\n    uint level,\n    IFightCalculator.AttackInfo memory attackInfo,\n    AdrContext memory context\n  ) internal view returns (\n    int32[] memory heroAttributes,\n    int32 manaConsumed\n  ) {\n    return context.statController.buffHero(IStatController.BuffInfo({\n      heroToken: context.heroToken,\n      heroTokenId: context.heroTokenId,\n      heroLevel: uint32(level),\n      buffTokens: attackInfo.skillTokens,\n      buffTokenIds: attackInfo.skillTokenIds\n    }));\n  }\n\n  /// @notice Get skill tokens, ensure that they are equipped on, add skill-tokens target attributes to hero attributes\n  /// @param attributes Hero attributes. These values are incremented in place\n  // @param heroAttackInfo Checked attack info. Assume that all skill tokens belong either to the hero or to the helper.\n  function _debuff(\n    int32[] memory attributes,\n    IFightCalculator.AttackInfo memory heroAttackInfo,\n    AdrContext memory context\n  ) internal view {\n    uint length = heroAttackInfo.skillTokens.length;\n    for (uint i; i < length; ++i) {\n      (int32[] memory values, uint8[] memory ids) = context.itemController.targetAttributes(\n        heroAttackInfo.skillTokens[i],\n        heroAttackInfo.skillTokenIds[i]\n      );\n\n      StatLib.attributesAdd(attributes, StatLib.valuesToFullAttributesArray(values, ids));\n    }\n  }\n\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...MAX_AMPLIFIER]\n  function _collectMonsterFighterInfo(\n    IGOC.MultiplierInfo memory multiplierInfo,\n    IGOC.MonsterInfo storage mInfo,\n    IGOC.GeneratedMonster memory gen,\n    IFightCalculator.AttackInfo memory heroAttackInfo,\n    uint heroLevel,\n    AdrContext memory adrCtx,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (\n    IFightCalculator.FighterInfo memory fighterInfo,\n    uint32 rarity,\n    IGOC.MonsterGenInfo memory genInfo\n  ) {\n    IFightCalculator.AttackInfo memory attackInfo;\n\n    rarity = gen.generated ? gen.amplifier : uint32(random_(_MAX_AMPLIFIER));\n    (\n      fighterInfo.fighterAttributes,\n      fighterInfo.fighterStats.level,\n      fighterInfo.fighterStats.experience,\n      attackInfo,\n      genInfo\n    ) = _generateMonsterInfo(mInfo, rarity, monsterMultiplier(multiplierInfo.totalSupply), heroLevel, multiplierInfo.biome, random_);\n\n    _debuff(fighterInfo.fighterAttributes, heroAttackInfo, adrCtx);\n\n    fighterInfo.fighterStats.life = gen.generated\n      ? uint32(gen.hp)\n      : fighterInfo.fighterStats.life = uint32(CalcLib.max32(fighterInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.LIFE)], int32(1)));\n\n    fighterInfo.fighterStats.mana = uint32(fighterInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MANA)]);\n\n    fighterInfo.attackType = attackInfo.attackType;\n    fighterInfo.attackToken = attackInfo.attackToken;\n    fighterInfo.attackTokenId = attackInfo.attackTokenId;\n    fighterInfo.race = genInfo.race;\n\n    return (fighterInfo, rarity, genInfo);\n  }\n\n  /// @param random_ Pass _pseudoRandom here, param is required to simplify unit testing\n  /// @param fight_ Pass FightLib.fight here, param is required to simplify unit testing\n  function _fight(\n    IGOC.ActionContext memory ctx,\n    IGOC.MonsterInfo storage mInfo,\n    IGOC.GeneratedMonster memory gen,\n    AdrContext memory adrCtx,\n    function (uint) internal view returns (uint) random_,\n    function(\n      IItemController,\n      IFightCalculator.FightCall memory,\n      address,\n      function (uint) internal view returns (uint)\n    ) internal returns (IFightCalculator.FightResult memory) fight_\n  ) internal returns (\n    FightInternalInfo memory fInfo,\n    IGOC.MonsterGenInfo memory info\n  ) {\n    IFightCalculator.FighterInfo memory heroFightInfo;\n    IFightCalculator.FighterInfo memory monsterFightInfo;\n\n    {\n      IFightCalculator.AttackInfo memory heroAttackInfo = decodeAndCheckAttackInfo(\n        adrCtx.itemController,\n        IHeroController(IController(adrCtx.controller).heroController()),\n        ctx.data,\n        adrCtx.heroToken,\n        adrCtx.heroTokenId\n      );\n\n      // use fInfo.manaConsumed and fInfo.monsterRarity to story values temporally to avoid creation of additional vars\n      (heroFightInfo, fInfo.manaConsumed) = _collectHeroFighterInfo(heroAttackInfo, adrCtx);\n      (monsterFightInfo, fInfo.monsterRarity, info) = _collectMonsterFighterInfo(\n        IGOC.MultiplierInfo(ctx.biome, IERC20(ctx.controller.gameToken()).totalSupply()),\n        mInfo,\n        gen,\n        heroAttackInfo,\n        heroFightInfo.fighterStats.level,\n        adrCtx,\n        random_\n      );\n    }\n\n    // adjust selected attributes using y=z(1−2^(−x/k)) formula\n    FightLib.adjustAttributes(heroFightInfo.fighterAttributes);\n    FightLib.adjustAttributes(monsterFightInfo.fighterAttributes);\n\n    // >>> FIGHT!\n    IFightCalculator.FightResult memory fightResult = fight_(\n      adrCtx.itemController,\n      IFightCalculator.FightCall({\n        fighterA: heroFightInfo,\n        fighterB: monsterFightInfo,\n        dungeonId: ctx.dungeonId,\n        objectId: ctx.objectId,\n        heroAdr: adrCtx.heroToken,\n        heroId: adrCtx.heroTokenId,\n        stageId: ctx.stageId,\n        iteration: ctx.iteration,\n        turn: gen.turnCounter\n      }),\n      ctx.sender,\n      random_\n    );\n\n    fInfo = FightInternalInfo({\n      manaConsumed: fInfo.manaConsumed + fightResult.manaConsumedA,\n      monsterRarity: fInfo.monsterRarity,\n      damage: _calcDmg(int32(heroFightInfo.fighterStats.life), fightResult.healthA),\n      heroFightInfo: heroFightInfo,\n      monsterFightInfo: monsterFightInfo,\n      heroLifeRegen: fightResult.healthA > int32(heroFightInfo.fighterStats.life) ? fightResult.healthA - int32(heroFightInfo.fighterStats.life) : int32(0),\n      heroHp: fightResult.healthA,\n      monsterHp: fightResult.healthB\n    });\n  }\n\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...1e18]\n  /// @return attributes Attributes amplified on amplifier and dungeonMultiplier\n  /// @return level Result level in the range: [mInfo.level .. heroLevel]\n  /// @return experience Experience amplified on amplifier and dungeonMultiplier\n  /// @return attackInfo Attack info. For magic hero attack type monster will have melee in half hits (randomly)\n  /// @return info Unpacked data from {mInfo}, some fields can be uninitialized, see comments to unpackMonsterInfo (!)\n  function _generateMonsterInfo(\n    IGOC.MonsterInfo storage mInfo,\n    uint32 amplifier,\n    int32 dungeonMultiplier,\n    uint heroLevel,\n    uint biome,\n    function (uint) internal view returns (uint) random_\n  ) internal view returns (\n    int32[] memory attributes,\n    uint32 level,\n    uint32 experience,\n    IFightCalculator.AttackInfo memory attackInfo,\n    IGOC.MonsterGenInfo memory info\n  ) {\n    info = unpackMonsterInfo(mInfo);\n\n    level = uint32(info.level);\n    if (level < heroLevel + 1) {\n      level = uint32(Math.min(level + ((heroLevel - level) * 10 / 15), biome * 5));\n    }\n\n    if (info.attackType == uint8(IFightCalculator.AttackType.MAGIC)) {\n      // sometimes use melee (25% chance)\n      uint rnd = random_(1e18);\n      if (rnd > 0.75e18) {\n        attackInfo.attackType = IFightCalculator.AttackType.MELEE;\n      } else {\n        attackInfo.attackType = IFightCalculator.AttackType.MAGIC;\n        attackInfo.attackToken = info.attackToken;\n        attackInfo.attackTokenId = info.attackTokenId;\n      }\n    } else {\n      attackInfo.attackType = IFightCalculator.AttackType(info.attackType);\n    }\n\n    (attributes, experience) = generateMonsterAttributes(\n      info.attributeIds,\n      info.attributeValues,\n      amplifier,\n      dungeonMultiplier,\n      info.experience\n    );\n\n    return (attributes, level, experience, attackInfo, info);\n  }\n\n  function _mintRandomItems(\n    FightInternalInfo memory fInfo,\n    IGOC.ActionContext memory ctx,\n    IGOC.MonsterGenInfo memory genInfo,\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\n  ) internal returns (\n    address[] memory\n  ) {\n    return ItemLib._mintRandomItems(\n      ItemLib.MintItemInfo({\n        mintItems: genInfo.mintItems,\n        mintItemsChances: genInfo.mintItemsChances,\n        amplifier: fInfo.monsterRarity,\n        seed: 0,\n        oracle: IOracle(ctx.controller.oracle()),\n        magicFind: fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MAGIC_FIND)],\n        destroyItems: fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DESTROY_ITEMS)],\n        maxItems: genInfo.maxDropItems,\n        mintDropChanceDelta: StatLib.mintDropChanceDelta(\n          fInfo.heroFightInfo.fighterStats.experience,\n          uint8(fInfo.heroFightInfo.fighterStats.level),\n          ctx.biome\n        )\n      }),\n      nextPrng_\n    );\n  }\n\n  //endregion ------------------------ Internal calculations\n\n  //region ------------------------ Utils\n\n  function _context(IGOC.ActionContext memory ctx) internal view returns (AdrContext memory context) {\n    context = AdrContext({\n      sender: ctx.sender,\n      heroToken: ctx.heroToken,\n      heroTokenId: ctx.heroTokenId,\n      controller: ctx.controller,\n      oracle: IOracle(ctx.controller.oracle()),\n      statController: IStatController(ctx.controller.statController()),\n      itemController: IItemController(ctx.controller.itemController())\n    });\n  }\n\n  function unpackGeneratedMonster(bytes32 gen) internal pure returns (IGOC.GeneratedMonster memory result) {\n    (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) = gen.unpackGeneratedMonster();\n    result = IGOC.GeneratedMonster({\n      generated: generated,\n      amplifier: amplifier,\n      hp: hp,\n      turnCounter: turnCounter\n    });\n  }\n\n  function packGeneratedMonster(IGOC.GeneratedMonster memory gen) internal pure returns (bytes32) {\n    return PackingLib.packGeneratedMonster(gen.generated, gen.amplifier, gen.hp, gen.turnCounter);\n  }\n\n  function packMonsterInfo(IGOC.MonsterGenInfo memory mInfo, IGOC.MonsterInfo storage info) internal {\n    info.attributes = mInfo.attributeValues.toBytes32ArrayWithIds(mInfo.attributeIds);\n    info.stats = PackingLib.packMonsterStats(mInfo.level, mInfo.race, mInfo.experience, mInfo.maxDropItems);\n    info.attackInfo = PackingLib.packAttackInfo(mInfo.attackToken, mInfo.attackTokenId, mInfo.attackType);\n\n    uint len = mInfo.mintItems.length;\n    bytes32[] memory mintItems = new bytes32[](len);\n\n    for (uint i; i < len; ++i) {\n      mintItems[i] = mInfo.mintItems[i].packItemMintInfo(mInfo.mintItemsChances[i]);\n    }\n\n    info.mintItems = mintItems;\n  }\n\n  /// @return Attention: Following fields are not initialized: biome, subType, monsterId\n  function unpackMonsterInfo(IGOC.MonsterInfo storage mInfo) internal view returns (IGOC.MonsterGenInfo memory) {\n    IGOC.MonsterGenInfo memory result;\n    (result.attributeValues, result.attributeIds) = mInfo.attributes.toInt32ArrayWithIds();\n    (result.level, result.race, result.experience, result.maxDropItems) = mInfo.stats.unpackMonsterStats();\n    (result.attackToken, result.attackTokenId, result.attackType) = mInfo.attackInfo.unpackAttackInfo();\n\n    uint len = mInfo.mintItems.length;\n    result.mintItems = new address[](len);\n    result.mintItemsChances = new uint32[](len);\n\n    for (uint i = 0; i < len; i++) {\n      (result.mintItems[i], result.mintItemsChances[i]) = mInfo.mintItems[i].unpackItemMintInfo();\n    }\n\n    // Attention: result.biome, result.subType, result.monsterId are not initialized\n    return result;\n  }\n\n  /// @notice Decode attack info. Ensure that attack token belongs to the hero.\n  /// Ensure that skill tokens belong to the hero OR to the current helper (SIP-001)\n  function decodeAndCheckAttackInfo(\n    IItemController ic,\n    IHeroController heroController,\n    bytes memory data,\n    address heroToken,\n    uint heroId\n  ) internal view returns (IFightCalculator.AttackInfo memory) {\n    (IFightCalculator.AttackInfo memory attackInfo) = abi.decode(data, (IFightCalculator.AttackInfo));\n\n    if (uint(attackInfo.attackType) == 0) revert IAppErrors.UnknownAttackType(uint(attackInfo.attackType));\n\n    if (attackInfo.attackToken != address(0)) {\n      (address h, uint hId) = ic.equippedOn(attackInfo.attackToken, attackInfo.attackTokenId);\n      if (heroToken != h || hId != heroId) revert IAppErrors.NotYourAttackItem();\n    }\n\n    (address helperHeroToken, uint helperHeroId) = heroController.heroReinforcementHelp(heroToken, heroId);\n    for (uint i; i < attackInfo.skillTokens.length; ++i) {\n      (address h, uint hId) = ic.equippedOn(attackInfo.skillTokens[i], attackInfo.skillTokenIds[i]);\n      if (\n        (heroToken != h || hId != heroId)\n        && ((helperHeroToken == address(0)) || (helperHeroToken != h || helperHeroId != hId))\n      ) revert IAppErrors.NotYourBuffItem();\n    }\n\n    return attackInfo;\n  }\n\n  /// @dev MAX_AMPLIFIER value will means +100% to all attributes\n  ///      slowly increase monsters power from 10% of the target supply\n  function monsterMultiplier(uint totalSupply) internal pure returns (int32) {\n    if(totalSupply < _TOTAL_SUPPLY_BASE / 10) {\n      return 0;\n    }\n\n    return int32(int((uint(_MAX_AMPLIFIER) * totalSupply) / _TOTAL_SUPPLY_BASE));\n  }\n\n  function getMonsterMultiplier(IController controller) internal view returns (int32) {\n    uint totalSupply = IERC20(controller.gameToken()).totalSupply();\n    return monsterMultiplier(totalSupply);\n  }\n\n  function amplifyMonsterAttribute(int32 value, uint32 amplifier, int32 dungeonMultiplier) internal pure returns (int32) {\n    if (value == 0) {\n      return 0;\n    }\n    return value +\n      int32(\n        (int(value) * int(uint(amplifier)) / int(uint(_MAX_AMPLIFIER)))\n        + (int(value) * int(dungeonMultiplier) / int(uint(_MAX_AMPLIFIER)))\n      );\n  }\n\n  /// @dev A wrapper around {CalcLib.pseudoRandom} to pass it as param (to be able to implement unit tests}\n  function _pseudoRandom(uint max) internal view returns (uint) {\n    return CalcLib.pseudoRandom(max);\n  }\n\n  /// @notice Amplify values of the attributes and of the experience\n  ///         using randomly generated {amplifier} and {dungeonMultiplier}.\n  ///         Attributes = amplify(ids, values), experience = amplify(baseExperience)\n  function generateMonsterAttributes(\n    uint8[] memory ids,\n    int32[] memory values,\n    uint32 amplifier,\n    int32 dungeonMultiplier,\n    uint32 baseExperience\n  ) internal pure returns (\n    int32[] memory attributes,\n    uint32 experience\n  ) {\n    // reduce random\n    amplifier = amplifier / 4;\n\n    attributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\n    for (uint i; i < ids.length; ++i) {\n      attributes[ids[i]] = amplifyMonsterAttribute(values[i], amplifier, dungeonMultiplier);\n    }\n    experience = uint32(amplifyMonsterAttribute(int32(baseExperience), amplifier, dungeonMultiplier));\n  }\n\n  function _calcDmg(int32 heroLifeBefore, int32 heroLifeAfter) internal pure returns (int32 damage) {\n    return heroLifeAfter == 0\n      ? heroLifeBefore\n      : heroLifeBefore - CalcLib.minI32(heroLifeAfter, heroLifeBefore);\n  }\n\n  function _getMonsterCounterIndex(uint32 objectId) internal pure returns (bytes32) {\n    return bytes32(abi.encodePacked(\"MONSTER_\", StringLib._toString(uint(objectId))));\n  }\n  //endregion ------------------------ Utils\n\n\n}\n"
    },
    "contracts/lib/PackingLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IItemController.sol\";\nimport \"../interfaces/IStatController.sol\";\n\nlibrary PackingLib {\n\n  error TooHighValue(uint value);\n  error OutOfBounds(uint index, uint length);\n  error UnexpectedValue(uint expected, uint actual);\n  error WrongValue(uint newValue, uint actual);\n  error LengthsMismatch();\n  error IntOutOfRange(int value);\n  error ZeroValue();\n  /// @notice packCustomDataChange requires an input string with two zero bytes at the beginning\n  ///         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\n  /// This error happens if these bytes are not zero\n  error IncompatibleInputString();\n\n  //////////////////////////\n  // ---- PACKING LOGIC ----\n  //////////////////////////\n\n  //region ------------------------------------ COMMON\n\n  function packNftId(address token, uint id) internal pure returns (bytes32 serialized) {\n    if (id > uint(type(uint64).max)) revert TooHighValue(id);\n    serialized = bytes32(uint(uint160(token)));\n    serialized |= bytes32(uint(uint64(id))) << 160;\n  }\n\n  function unpackNftId(bytes32 data) internal pure returns (address token, uint id) {\n    token = address(uint160(uint(data)));\n    id = uint(data) >> 160;\n  }\n\n  function packAddressWithAmount(address token, uint amount) internal pure returns (bytes32 data) {\n    if (amount > uint(type(uint96).max)) revert TooHighValue(amount);\n    data = bytes32(uint(uint160(token)));\n    data |= bytes32(uint(uint96(amount))) << 160;\n  }\n\n  function unpackAddressWithAmount(bytes32 data) internal pure returns (address token, uint amount) {\n    token = address(uint160(uint(data)));\n    amount = uint(data) >> 160;\n  }\n\n  function packItemMintInfo(address item, uint32 chance) internal pure returns (bytes32 data) {\n    data = bytes32(uint(uint160(item)));\n    data |= bytes32(uint(chance)) << 160;\n  }\n\n  function unpackItemMintInfo(bytes32 data) internal pure returns (address item, uint32 chance) {\n    item = address(uint160(uint(data)));\n    chance = uint32(uint(data) >> 160);\n  }\n\n  /// @param customDataIndex We assume, that two lowest bytes of this string are always zero\n  /// So, the string looks like following: 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\n  /// Last 2 bytes will be used to encode {value}\n  function packCustomDataChange(bytes32 customDataIndex, int16 value) internal pure returns (bytes32 data) {\n    if (uint(customDataIndex) != (uint(customDataIndex) >> 16) << 16) revert IncompatibleInputString();\n    data = bytes32(uint(customDataIndex));\n    data |= bytes32(uint(uint16(value)));\n  }\n\n  function unpackCustomDataChange(bytes32 data) internal pure returns (bytes32 customDataIndex, int16 value) {\n    customDataIndex = bytes32((uint(data) >> 16) << 16);\n    value = int16(int(uint(uint16(uint(data)))));\n  }\n\n  /// @dev min(uint64) + max(uint64) + isHeroData/isMandatory(uint8)\n  function packCustomDataRequirements(uint64 min, uint64 max, bool key) internal pure returns (bytes32 data) {\n    data = bytes32(uint(min));\n    data |= bytes32(uint(max)) << 64;\n    data |= bytes32(uint(key ? uint8(1) : uint8(0))) << (64 + 64);\n  }\n\n  function unpackCustomDataRequirements(bytes32 data) internal pure returns (uint64 min, uint64 max, bool key) {\n    min = uint64(uint(data));\n    max = uint64(uint(data) >> 64);\n    key = uint8(uint(data) >> (64 + 64)) == uint8(1);\n  }\n\n  function packStatsChange(\n    uint32 experience,\n    int32 heal,\n    int32 manaRegen,\n    int32 lifeChancesRecovered,\n    int32 damage,\n    int32 manaConsumed\n  ) internal pure returns (bytes32 data) {\n    data = bytes32(uint(experience));\n    data |= bytes32(uint(uint32(heal))) << 32;\n    data |= bytes32(uint(uint32(manaRegen))) << (32 + 32);\n    data |= bytes32(uint(uint32(lifeChancesRecovered))) << (32 + 32 + 32);\n    data |= bytes32(uint(uint32(damage))) << (32 + 32 + 32 + 32);\n    data |= bytes32(uint(uint32(manaConsumed))) << (32 + 32 + 32 + 32 + 32);\n  }\n\n  function unpackStatsChange(bytes32 data) internal pure returns (\n    uint32 experience,\n    int32 heal,\n    int32 manaRegen,\n    int32 lifeChancesRecovered,\n    int32 damage,\n    int32 manaConsumed\n  ) {\n    experience = uint32(uint(data));\n    heal = int32(int(uint(data) >> 32));\n    manaRegen = int32(int(uint(data) >> (32 + 32)));\n    lifeChancesRecovered = int32(int(uint(data) >> (32 + 32 + 32)));\n    damage = int32(int(uint(data) >> (32 + 32 + 32 + 32)));\n    manaConsumed = int32(int(uint(data) >> (32 + 32 + 32 + 32 + 32)));\n  }\n  //endregion ------------------------------------ COMMON\n\n  //region ------------------------------------ WORLD/BATTLEFIELD MAP\n\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) internal pure returns (bytes32 packedData) {\n    packedData = bytes32(bytes20(objectAddress));\n    packedData |= bytes32(uint(objectId) << 32);\n    packedData |= bytes32(uint(objectType) << 24);\n  }\n\n  function unpackMapObject(bytes32 packedData) internal pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\n    objectAddress = address(bytes20(packedData));\n    objectId = uint64(uint(packedData) >> 32);\n    objectType = uint8(uint(packedData) >> 24);\n  }\n\n  function packCoordinate(uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\n    packedData = bytes32(uint(x));\n    packedData |= bytes32(uint(y) << 128);\n  }\n\n  function unpackCoordinate(bytes32 packedData) internal pure returns (uint128 x, uint128 y) {\n    x = uint128(uint(packedData));\n    y = uint128(uint(packedData) >> 128);\n  }\n\n  /// @param x Assume x <= max uint64\n  /// @param y Assume y <= max uint64\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\n    // 256 => 128 + 128;\n    // 1) 128 is used for biomeMapFieldId, territoryNumber and probably other fields in the future\n    // 2) 128 is used to store x, y as uint64, uint64\n\n    // we will use uint64 for coordinates assuming it is more than enough for biome map\n    packedData = bytes32(uint(biomeMapFieldId));\n    packedData |= bytes32(uint(territoryNumber) << (8));\n    packedData |= bytes32(uint(uint64(x)) << 128);\n    packedData |= bytes32(uint(uint64(y)) << (64 + 128));\n  }\n\n  function unpackBattlefieldId(bytes32 packedData) internal pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\n    biomeMapFieldId = uint8(uint(packedData));\n    territoryNumber = uint8(uint(packedData) >> (8));\n    x = uint128(uint64(uint(packedData) >> (128)));\n    y = uint128(uint64(uint(packedData) >> (64 + 128)));\n  }\n  //endregion ------------------------------------ WORLD/BATTLEFIELD MAP\n\n  //region ------------------------------------ REINFORCEMENT\n\n  function packReinforcementHeroInfo(uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) internal pure returns (bytes32 packedData) {\n    packedData = bytes32(uint(biome));\n    packedData |= bytes32(uint(score) << 8);\n    packedData |= bytes32(uint(fee) << (8 + 128));\n    packedData |= bytes32(uint(stakeTs) << (8 + 128 + 8));\n  }\n\n  function unpackReinforcementHeroInfo(bytes32 packedData) internal pure returns (uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) {\n    biome = uint8(uint(packedData));\n    score = uint128(uint(packedData) >> 8);\n    fee = uint8(uint(packedData) >> (8 + 128));\n    stakeTs = uint64(uint(packedData) >> (8 + 128 + 8));\n  }\n  //endregion ------------------------------------ REINFORCEMENT\n\n  //region ------------------------------------ DUNGEON\n\n  function packDungeonKey(address heroAdr, uint80 heroId, uint16 dungLogicNum) internal pure returns (bytes32 data) {\n    data = bytes32(uint(uint160(heroAdr)));\n    data |= bytes32(uint(heroId)) << 160;\n    data |= bytes32(uint(dungLogicNum)) << (160 + 80);\n  }\n\n  function unpackDungeonKey(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 dungLogicNum) {\n    heroAdr = address(uint160(uint(data)));\n    heroId = uint80(uint(data) >> 160);\n    dungLogicNum = uint16(uint(data) >> (160 + 80));\n  }\n\n  // --- GAME OBJECTS ---\n\n  function packIterationKey(address heroAdr, uint64 heroId, uint32 objId) internal pure returns (bytes32 data) {\n    data = bytes32(uint(uint160(heroAdr)));\n    data |= bytes32(uint(heroId)) << 160;\n    data |= bytes32(uint(objId)) << (160 + 64);\n  }\n\n  function unpackIterationKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint32 objId) {\n    heroAdr = address(uint160(uint(data)));\n    heroId = uint64(uint(data) >> 160);\n    objId = uint32(uint(data) >> (160 + 64));\n  }\n\n  function packMonsterStats(\n    uint8 level,\n    uint8 race,\n    uint32 experience,\n    uint8 maxDropItems\n  ) internal pure returns (bytes32 data) {\n    data = bytes32(uint(level));\n    data |= bytes32(uint(race)) << 8;\n    data |= bytes32(uint(experience)) << (8 + 8);\n    data |= bytes32(uint(maxDropItems)) << (8 + 8 + 32);\n  }\n\n  function unpackMonsterStats(bytes32 data) internal pure returns (\n    uint8 level,\n    uint8 race,\n    uint32 experience,\n    uint8 maxDropItems\n  ) {\n    level = uint8(uint(data));\n    race = uint8(uint(data) >> 8);\n    experience = uint32(uint(data) >> (8 + 8));\n    maxDropItems = uint8(uint(data) >> (8 + 8 + 32));\n  }\n\n  function packAttackInfo(\n    address attackToken,\n    uint64 attackTokenId,\n    uint8 attackType\n  ) internal pure returns (bytes32 data) {\n    data = bytes32(uint(uint160(attackToken)));\n    data |= bytes32(uint(attackTokenId)) << 160;\n    data |= bytes32(uint(attackType)) << (160 + 64);\n  }\n\n  function unpackAttackInfo(bytes32 data) internal pure returns (\n    address attackToken,\n    uint64 attackTokenId,\n    uint8 attackType\n  ) {\n    attackToken = address(uint160(uint(data)));\n    attackTokenId = uint64(uint(data) >> 160);\n    attackType = uint8(uint(data) >> (160 + 64));\n  }\n\n  function packPlayedObjKey(address heroAdr, uint64 heroId, uint8 oType, uint8 biome) internal pure returns (bytes32 data) {\n    data = bytes32(uint(uint160(heroAdr)));\n    data |= bytes32(uint(heroId)) << 160;\n    data |= bytes32(uint(oType)) << (160 + 64);\n    data |= bytes32(uint(biome)) << (160 + 64 + 8);\n  }\n\n  function unpackPlayedObjKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint8 oType, uint8 biome) {\n    heroAdr = address(uint160(uint(data)));\n    heroId = uint64(uint(data) >> 160);\n    oType = uint8(uint(data) >> (160 + 64));\n    biome = uint8(uint(data) >> (160 + 64 + 8));\n  }\n\n  function packGeneratedMonster(bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) internal pure returns (bytes32 data) {\n    data = bytes32(uint(uint8(generated ? 1 : 0)));\n    data |= bytes32(uint(amplifier)) << 8;\n    data |= bytes32(uint(uint32(hp))) << (8 + 32);\n    data |= bytes32(uint(turnCounter)) << (8 + 32 + 32);\n  }\n\n  function unpackGeneratedMonster(bytes32 data) internal pure returns (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) {\n    generated = uint8(uint(data)) == uint8(1);\n    amplifier = uint32(uint(data) >> 8);\n    hp = int32(int(uint(data) >> (8 + 32)));\n    turnCounter = uint8(uint(data) >> (8 + 32 + 32));\n  }\n  //endregion ------------------------------------ DUNGEON\n\n  //region ------------------------------------ ITEMS\n\n  /// @notice itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\n  /// @param itemType This is ItemType enum\n  function packItemMeta(\n    uint8 itemMetaType,\n    uint8 itemLvl,\n    uint8 itemType,\n    uint16 baseDurability,\n    uint8 defaultRarity,\n    uint8 minAttr,\n    uint8 maxAttr,\n    uint32 manaCost,\n    IStatController.CoreAttributes memory req\n  ) internal pure returns (bytes32 data) {\n    data = bytes32(uint(itemMetaType));\n    data |= bytes32(uint(itemLvl)) << 8;\n    data |= bytes32(uint(itemType)) << (8 + 8);\n    data |= bytes32(uint(baseDurability)) << (8 + 8 + 8);\n    data |= bytes32(uint(defaultRarity)) << (8 + 8 + 8 + 16);\n    data |= bytes32(uint(minAttr)) << (8 + 8 + 8 + 16 + 8);\n    data |= bytes32(uint(maxAttr)) << (8 + 8 + 8 + 16 + 8 + 8);\n    data |= bytes32(uint(manaCost)) << (8 + 8 + 8 + 16 + 8 + 8 + 8);\n    data |= bytes32(uint(int(req.strength))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32);\n    data |= bytes32(uint(int(req.dexterity))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32);\n    data |= bytes32(uint(int(req.vitality))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32);\n    data |= bytes32(uint(int(req.energy))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32);\n  }\n\n  function unpackItemMeta(bytes32 data) internal pure returns (IItemController.ItemMeta memory) {\n    IItemController.ItemMeta memory result;\n\n    result.itemMetaType = uint8(uint(data));\n    result.itemLevel = uint8(uint(data) >> 8);\n    result.itemType = IItemController.ItemType(uint8(uint(data) >> (8 + 8)));\n    result.baseDurability = uint16(uint(data) >> (8 + 8 + 8));\n    result.defaultRarity = uint8(uint(data) >> (8 + 8 + 8 + 16));\n    result.minRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8));\n    result.maxRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8));\n    result.manaCost = uint32(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8));\n    result.requirements.strength = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32)));\n    result.requirements.dexterity = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32)));\n    result.requirements.vitality = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32)));\n    result.requirements.energy = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32)));\n\n    return result;\n  }\n\n  function packItemGenerateInfo(uint8 id, int32 min, int32 max, uint32 chance) internal pure returns (bytes32 data) {\n    data = bytes32(uint(id));\n    data |= bytes32(uint(uint32(min))) << 8;\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\n    data |= bytes32(uint(chance)) << (8 + 32 + 32);\n  }\n\n  function unpackItemGenerateInfo(bytes32 data) internal pure returns (uint8 id, int32 min, int32 max, uint32 chance) {\n    id = uint8(uint(data));\n    min = int32(int(uint(data) >> 8));\n    max = int32(int(uint(data) >> (8 + 32)));\n    chance = uint32(uint(data) >> (8 + 32 + 32));\n  }\n\n  function packItemAttackInfo(\n    uint8 attackType,\n    int32 min,\n    int32 max,\n    int32 factorStr,\n    int32 factorDex,\n    int32 factorVit,\n    int32 factorEng\n  ) internal pure returns (bytes32 data) {\n    data = bytes32(uint(attackType));\n    data |= bytes32(uint(uint32(min))) << 8;\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\n    data |= bytes32(uint(int(factorStr))) << (8 + 32 + 32);\n    data |= bytes32(uint(int(factorDex))) << (8 + 32 + 32 + 32);\n    data |= bytes32(uint(int(factorVit))) << (8 + 32 + 32 + 32 + 32);\n    data |= bytes32(uint(int(factorEng))) << (8 + 32 + 32 + 32 + 32 + 32);\n  }\n\n  function unpackItemAttackInfo(bytes32 data) internal pure returns (\n    uint8 attackType,\n    int32 min,\n    int32 max,\n    int32 factorStr,\n    int32 factorDex,\n    int32 factorVit,\n    int32 factorEng\n  ) {\n    attackType = uint8(uint(data));\n    min = int32(int(uint(data) >> 8));\n    max = int32(int(uint(data) >> (8 + 32)));\n    factorStr = int32(int(uint(data) >> (8 + 32 + 32)));\n    factorDex = int32(int(uint(data) >> (8 + 32 + 32 + 32)));\n    factorVit = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32)));\n    factorEng = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32 + 32)));\n  }\n\n  function packItemInfo(uint8 rarity, uint8 augmentationLevel, uint16 durability) internal pure returns (bytes32 data) {\n    data = bytes32(uint(rarity));\n    data |= bytes32(uint(augmentationLevel)) << 8;\n    data |= bytes32(uint(durability)) << (8 + 8);\n  }\n\n  function unpackItemInfo(bytes32 data) internal pure returns (uint8 rarity, uint8 augmentationLevel, uint16 durability) {\n    rarity = uint8(uint(data));\n    augmentationLevel = uint8(uint(data) >> 8);\n    durability = uint16(uint(data) >> (8 + 8));\n  }\n  //endregion ------------------------------------ ITEMS\n\n  //region ------------------------------------ STORIES\n\n  function packStoryPageId(uint16 storyId, uint16 pageId, uint8 heroClass) internal pure returns (bytes32 data) {\n    data = bytes32(uint(storyId));\n    data |= bytes32(uint(pageId)) << 16;\n    data |= bytes32(uint(heroClass)) << (16 + 16);\n  }\n\n  function unpackStoryPageId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass) {\n    storyId = uint16(uint(data));\n    pageId = uint16(uint(data) >> 16);\n    heroClass = uint8(uint(data) >> (16 + 16));\n  }\n\n  function packStoryAnswerId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) internal pure returns (bytes32 data) {\n    data = bytes32(uint(storyId));\n    data |= bytes32(uint(pageId)) << 16;\n    data |= bytes32(uint(heroClass)) << (16 + 16);\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\n  }\n\n  function unpackStoryAnswerId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) {\n    storyId = uint16(uint(data));\n    pageId = uint16(uint(data) >> 16);\n    heroClass = uint8(uint(data) >> (16 + 16));\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\n  }\n\n  function packStoryNextPagesId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) internal pure returns (bytes32 data) {\n    data = bytes32(uint(storyId));\n    data |= bytes32(uint(pageId)) << 16;\n    data |= bytes32(uint(heroClass)) << (16 + 16);\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\n    data |= bytes32(uint(resultId)) << (16 + 16 + 8 + 16);\n  }\n\n  function unpackStoryNextPagesId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) {\n    storyId = uint16(uint(data));\n    pageId = uint16(uint(data) >> 16);\n    heroClass = uint8(uint(data) >> (16 + 16));\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\n    resultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\n  }\n\n  function packStoryAttributeRequirement(uint8 attributeIndex, int32 value, bool isCore) internal pure returns (bytes32 data) {\n    data = bytes32(uint(attributeIndex));\n    data |= bytes32(uint(uint32(value))) << 8;\n    data |= bytes32(uint(isCore ? uint8(1) : uint8(0))) << (8 + 32);\n  }\n\n  function unpackStoryAttributeRequirement(bytes32 data) internal pure returns (uint8 attributeIndex, int32 value, bool isCore) {\n    attributeIndex = uint8(uint(data));\n    value = int32(int(uint(data) >> 8));\n    isCore = uint8(uint(data) >> (8 + 32)) == uint8(1);\n  }\n\n  function packStoryItemRequirement(address item, bool requireItemBurn, bool requireItemEquipped) internal pure returns (bytes32 data) {\n    data = bytes32(uint(uint160(item)));\n    data |= bytes32(uint(requireItemBurn ? uint8(1) : uint8(0))) << 160;\n    data |= bytes32(uint(requireItemEquipped ? uint8(1) : uint8(0))) << (160 + 8);\n  }\n\n  function unpackStoryItemRequirement(bytes32 data) internal pure returns (address item, bool requireItemBurn, bool requireItemEquipped) {\n    item = address(uint160(uint(data)));\n    requireItemBurn = uint8(uint(data) >> 160) == uint8(1);\n    requireItemEquipped = uint8(uint(data) >> (160 + 8)) == uint8(1);\n  }\n\n  /// @dev max amount is 309,485,009 for token with 18 decimals\n  function packStoryTokenRequirement(address token, uint88 amount, bool requireTransfer) internal pure returns (bytes32 data) {\n    data = bytes32(uint(uint160(token)));\n    data |= bytes32(uint(amount)) << 160;\n    data |= bytes32(uint(requireTransfer ? uint8(1) : uint8(0))) << (160 + 88);\n  }\n\n  function unpackStoryTokenRequirement(bytes32 data) internal pure returns (address token, uint88 amount, bool requireTransfer) {\n    token = address(uint160(uint(data)));\n    amount = uint88(uint(data) >> 160);\n    requireTransfer = uint8(uint(data) >> (160 + 88)) == uint8(1);\n  }\n\n  function packStoryCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) internal pure returns (bytes32 data) {\n    data = bytes32(uint(storyId));\n    data |= bytes32(uint(pageId)) << 16;\n    data |= bytes32(uint(heroClass)) << (16 + 16);\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\n    data |= bytes32(uint(customDataResultId)) << (16 + 16 + 8 + 16);\n  }\n\n  function unpackStoryCustomDataResult(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) {\n    storyId = uint16(uint(data));\n    pageId = uint16(uint(data) >> 16);\n    heroClass = uint8(uint(data) >> (16 + 16));\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\n    customDataResultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\n  }\n\n  function packStoryHeroState(uint16 pageId, uint40 heroLastActionTS) internal pure returns (bytes32 data) {\n    data = bytes32(uint(pageId));\n    data |= bytes32(uint(heroLastActionTS)) << 16;\n  }\n\n  function unpackStoryHeroState(bytes32 data) internal pure returns (uint16 pageId, uint40 heroLastActionTS) {\n    pageId = uint16(uint(data));\n    heroLastActionTS = uint40(uint(data) >> 16);\n  }\n\n  function packStoryHeroStateId(address heroAdr, uint80 heroId, uint16 storyId) internal pure returns (bytes32 data) {\n    data = bytes32(uint(uint160(heroAdr)));\n    data |= bytes32(uint(heroId)) << 160;\n    data |= bytes32(uint(storyId)) << (160 + 80);\n  }\n\n  function unpackStoryHeroStateId(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 storyId) {\n    heroAdr = address(uint160(uint(data)));\n    heroId = uint80(uint(data) >> 160);\n    storyId = uint16(uint(data) >> (160 + 80));\n  }\n\n  function packStorySimpleRequirement(uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) internal pure returns (bytes32 data) {\n    data = bytes32(uint(randomRequirement));\n    data |= bytes32(uint(delayRequirement)) << 32;\n    data |= bytes32(uint(isFinalAnswer ? uint8(1) : uint8(0))) << (32 + 32);\n  }\n\n  function unpackStorySimpleRequirement(bytes32 data) internal pure returns (uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) {\n    randomRequirement = uint32(uint(data));\n    delayRequirement = uint32(uint(data) >> 32);\n    isFinalAnswer = uint8(uint(data) >> (32 + 32)) == uint8(1);\n  }\n\n  function packBreakInfo(uint8 slot, uint64 chance, bool stopIfBroken) internal pure returns (bytes32 data) {\n    data = bytes32(uint(slot));\n    data |= bytes32(uint(chance)) << 8;\n    data |= bytes32(uint(stopIfBroken ? uint8(1) : uint8(0))) << (8 + 64);\n  }\n\n  function unpackBreakInfo(bytes32 data) internal pure returns (uint8 slot, uint64 chance, bool stopIfBurned) {\n    slot = uint8(uint(data));\n    chance = uint64(uint(data) >> 8);\n    stopIfBurned = uint8(uint(data) >> (8 + 64)) == uint8(1);\n  }\n  //endregion ------------------------------------ STORIES\n\n  ////////////////////////////////////////////////////////////////////////////////////\n  // ---- ARRAYS LOGIC ----\n  ////////////////////////////////////////////////////////////////////////////////////\n\n  //region ------------------------------------ SIMPLE ARRAYS\n\n\n  function packUint8Array(uint8[] memory data) internal pure returns (bytes32) {\n    uint len = data.length;\n    if (len > 32) revert OutOfBounds(len, 32);\n    bytes32 result;\n    for (uint i = 0; i < len; i++) {\n      result |= bytes32(uint(data[i])) << (i * 8);\n    }\n    return result;\n  }\n\n  /// @notice Simple faster version of {packUint8Array} for small number of items\n  ///         It allows to exclude dynamic array creation.\n  function packUint8Array3(uint8 a, uint8 b, uint8 c) internal pure returns (bytes32) {\n    bytes32 result = bytes32(uint(a));\n    result |= bytes32(uint(b)) << (1 * 8);\n    result |= bytes32(uint(c)) << (2 * 8);\n    return result;\n  }\n\n\n  function unpackUint8Array(bytes32 data) internal pure returns (uint8[] memory) {\n    uint8[] memory result = new uint8[](32);\n    for (uint i = 0; i < 32; i++) {\n      result[i] = uint8(uint(data) >> (i * 8));\n    }\n    return result;\n  }\n\n  /// @notice Simple faster version of {unpackUint8Array} for small number of items\n  ///         It allows to exclude only first 3 values\n  function unpackUint8Array3(bytes32 data) internal pure returns (uint8 a, uint8 b, uint8 c) {\n    a = uint8(uint(data));\n    b = uint8(uint(data) >> (1 * 8));\n    c = uint8(uint(data) >> (2 * 8));\n  }\n\n  function changeUnit8ArrayWithCheck(bytes32 data, uint index, uint8 value, uint8 expectedPrevValue) internal pure returns (bytes32 newData) {\n    uint8[] memory arr = unpackUint8Array(data);\n    if (arr[index] != expectedPrevValue) revert UnexpectedValue(uint(expectedPrevValue), uint(arr[index]));\n    arr[index] = value;\n    return packUint8Array(arr);\n  }\n\n  function packInt32Array(int32[] memory data) internal pure returns (bytes32) {\n    uint len = data.length;\n    if (len > 8) revert OutOfBounds(len, 8);\n    bytes32 result;\n    for (uint i; i < len; i++) {\n      result |= bytes32(uint(uint32(data[i]))) << (i * 32);\n    }\n    return result;\n  }\n\n  function unpackInt32Array(bytes32 data) internal pure returns (int32[] memory) {\n    int32[] memory result = new int32[](8);\n    for (uint i = 0; i < 8; i++) {\n      result[i] = int32(int(uint(data) >> (i * 32)));\n    }\n    return result;\n  }\n\n  function packUint32Array(uint32[] memory data) internal pure returns (bytes32) {\n    uint len = data.length;\n    if (len > 8) revert OutOfBounds(len, 8);\n    bytes32 result;\n    for (uint i = 0; i < len; i++) {\n      result |= bytes32(uint(data[i])) << (i * 32);\n    }\n    return result;\n  }\n\n  function unpackUint32Array(bytes32 data) internal pure returns (uint32[] memory) {\n    uint32[] memory result = new uint32[](8);\n    for (uint i = 0; i < 8; i++) {\n      result[i] = uint32(uint(data) >> (i * 32));\n    }\n    return result;\n  }\n  //endregion ------------------------------------ SIMPLE ARRAYS\n\n  //region ------------------------------------ COMPLEX ARRAYS\n\n  // We should represent arrays without concrete size.\n  // For this reason we must not revert on out of bounds but return zero value instead.\n\n  // we need it for properly unpack packed arrays with ids\n//  function getInt32AsInt24(bytes32[] memory arr, uint idx) internal pure returns (int32) {\n//    if (idx / 8 >= arr.length) {\n//      return int32(0);\n//    }\n//    return int32(int24(int(uint(arr[idx / 8]) >> ((idx % 8) * 32))));\n//  }\n\n  // we need it for properly unpack packed arrays with ids\n//  function getUnit8From32Step(bytes32[] memory arr, uint idx) internal pure returns (uint8) {\n//    if (idx / 8 >= arr.length) {\n//      return uint8(0);\n//    }\n//    return uint8(uint(arr[idx / 8]) >> ((idx % 8) * 32 + 24));\n//  }\n\n  function getInt32Memory(bytes32[] memory arr, uint idx) internal pure returns (int32) {\n    if (idx / 8 >= arr.length) {\n      return int32(0);\n    }\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\n  }\n\n  function getInt32(bytes32[] storage arr, uint idx) internal view returns (int32) {\n    // additional gas usage, but we should not revert on out of bounds\n    if (idx / 8 >= arr.length) {\n      return int32(0);\n    }\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\n  }\n\n  function setInt32(bytes32[] storage arr, uint idx, int32 value) internal {\n    uint pos = idx / 8;\n    uint shift = (idx % 8) * 32;\n\n    uint curLength = arr.length;\n    if (pos >= curLength) {\n      arr.push(0);\n      for (uint i = curLength; i < pos; ++i) {\n        arr.push(0);\n      }\n    }\n\n    arr[pos] = bytes32(uint(arr[pos]) & ~(uint(0xffffffff) << shift) | (uint(uint32(value)) & 0xffffffff) << shift);\n  }\n\n  /// @notice Increment {idx}-th item on {value}\n  function changeInt32(bytes32[] storage arr, uint idx, int32 value) internal returns (int32 newValue, int32 change) {\n    int32 cur = int32(int(getInt32(arr, idx)));\n    int newValueI = int(cur) + int(value);\n    newValue = int32(newValueI);\n    change = int32(newValueI - int(cur));\n\n    setInt32(arr, idx, newValue);\n  }\n\n  function toInt32Array(bytes32[] memory arr, uint size) internal pure returns (int32[] memory) {\n    int32[] memory result = new int32[](size);\n    for (uint i = 0; i < arr.length; i++) {\n      for (uint j; j < 8; ++j) {\n        uint idx = i * 8 + j;\n        if (idx >= size) break;\n        result[idx] = getInt32Memory(arr, idx);\n      }\n    }\n    return result;\n  }\n\n  /// @dev pack int32 array into bytes32 array\n  function toBytes32Array(int32[] memory arr) internal pure returns (bytes32[] memory) {\n    uint size = arr.length / 8 + 1;\n    bytes32[] memory result = new bytes32[](size);\n    for (uint i; i < size; ++i) {\n      for (uint j; j < 8; ++j) {\n        uint idx = i * 8 + j;\n        if (idx >= arr.length) break;\n        result[i] |= bytes32(uint(uint32(arr[idx]))) << (j * 32);\n      }\n    }\n    return result;\n  }\n\n  /// @dev pack int32 array into bytes32 array using last 8bytes for ids\n  ///      we can not use zero values coz will not able to properly unpack it later\n  function toBytes32ArrayWithIds(int32[] memory arr, uint8[] memory ids) internal pure returns (bytes32[] memory) {\n    if (arr.length != ids.length) revert LengthsMismatch();\n\n    uint size = arr.length / 8 + 1;\n    bytes32[] memory result = new bytes32[](size);\n    for (uint i; i < size; ++i) {\n      for (uint j; j < 8; ++j) {\n        uint idx = i * 8 + j;\n        if (idx >= arr.length) break;\n\n//        console.log(\"toBytes32ArrayWithIds id: %s, value: %s%s\", ids[idx], arr[idx] >= 0 ? '' : '-', arr[idx] >= 0 ? uint(int(arr[idx])) : uint(int(-arr[idx])));\n\n        if (arr[idx] > type(int24).max || arr[idx] < type(int24).min) revert IntOutOfRange(int(arr[idx]));\n        if (arr[idx] == 0) revert ZeroValue();\n        result[i] |= bytes32(uint(uint24(int24(arr[idx])))) << (j * 32);\n        result[i] |= bytes32(uint(ids[idx])) << (j * 32 + 24);\n      }\n    }\n    return result;\n  }\n\n  /// @dev we do not know exact size of array, assume zero values is not acceptable for this array\n  function toInt32ArrayWithIds(bytes32[] memory arr) internal pure returns (int32[] memory values, uint8[] memory ids) {\n    uint len = arr.length;\n    uint size = len * 8;\n    int32[] memory valuesTmp = new int32[](size);\n    uint8[] memory idsTmp = new uint8[](size);\n    uint counter;\n    for (uint i = 0; i < len; i++) {\n      for (uint j; j < 8; ++j) {\n        uint idx = i * 8 + j;\n        // if (idx >= size) break;  // it looks like a useless check\n        valuesTmp[idx] = int32(int24(int(uint(arr[i]) >> (j * 32)))); // getInt32AsInt24(arr, idx);\n        idsTmp[idx] = uint8(uint(arr[i]) >> (j * 32 + 24)); // getUnit8From32Step(arr, idx);\n        if (valuesTmp[idx] == 0) {\n          break;\n        }\n        counter++;\n      }\n    }\n\n    values = new int32[](counter);\n    ids = new uint8[](counter);\n    for (uint i; i < counter; ++i) {\n      values[i] = valuesTmp[i];\n      ids[i] = idsTmp[i];\n    }\n  }\n  //endregion ------------------------------------ COMPLEX ARRAYS\n\n}\n"
    },
    "contracts/lib/ReinforcementControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IDungeonFactory.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IHeroController.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IReinforcementController.sol\";\nimport \"../lib/CalcLib.sol\";\nimport \"../lib/PackingLib.sol\";\nimport \"../openzeppelin/Math.sol\";\n\nlibrary ReinforcementControllerLib {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n  using PackingLib for bytes32;\n  using PackingLib for address;\n  using PackingLib for uint8[];\n\n  //region ------------------------ CONSTANTS\n\n  /// @dev keccak256(abi.encode(uint256(keccak256(\"reinforcement.controller.main\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0x5a053c541e08c6bd7dfc3042a100e83af246544a23ecda1a47bf22b441b00c00;\n  uint internal constant _SEARCH_WINDOW = 100;\n  int32 internal constant _ATTRIBUTES_RATIO = 20;\n  uint internal constant _FEE_MIN = 10;\n  uint internal constant _TO_HELPER_RATIO_MAX = 50;\n  uint internal constant _STAKE_REDUCE_DELAY = 7 days;\n  uint internal constant _DELAY_FACTOR = 2;\n  uint internal constant _SIP001_COUNT_REQUIRED_SKILLS = 3;\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ VIEWS\n\n  function _S() internal pure returns (IReinforcementController.MainState storage s) {\n    assembly {\n      s.slot := MAIN_STORAGE_LOCATION\n    }\n    return s;\n  }\n\n  function minLevel() internal view returns (uint8 _minLevel) {\n    (_minLevel,) = unpackConfig(_S().config);\n    return _minLevel;\n  }\n\n  function minLifeChances() internal view returns (uint8 _minLifeChances) {\n    (, _minLifeChances) = unpackConfig(_S().config);\n    return _minLifeChances;\n  }\n\n  function toHelperRatio(address heroToken, uint heroId) internal view returns (uint) {\n    return heroInfo(heroToken, heroId).fee;\n  }\n\n  function heroInfo(address heroToken, uint heroId) internal view returns (IReinforcementController.HeroInfo memory) {\n    return unpackHeroInfo(_S()._stakedHeroes[heroToken.packNftId(heroId)]);\n  }\n\n  function isStaked(address heroToken, uint heroId) internal view returns (bool) {\n    return heroInfo(heroToken, heroId).biome != 0;\n  }\n\n  function maxScore(uint biome) internal view returns (uint) {\n    return _S().maxScore[biome];\n  }\n\n  function earned(address heroToken, uint heroId) internal view returns (\n    address[] memory tokens,\n    uint[] memory amounts,\n    address[] memory nfts,\n    uint[] memory ids\n  ){\n    EnumerableMap.AddressToUintMap storage erc20Rewards = _S()._heroTokenRewards[heroToken.packNftId(heroId)];\n    uint length = erc20Rewards.length();\n    tokens = new address[](length);\n    amounts = new uint[](length);\n    for (uint i; i < length; ++i) {\n      (tokens[i], amounts[i]) = erc20Rewards.at(i);\n    }\n\n    bytes32[] storage nftRewards = _S()._heroNftRewards[heroToken.packNftId(heroId)];\n    length = nftRewards.length;\n    nfts = new address[](length);\n    ids = new uint[](length);\n    for (uint i; i < length; ++i) {\n      (nfts[i], ids[i]) = PackingLib.unpackNftId(nftRewards[i]);\n    }\n  }\n\n  function heroScoreAdjusted(address heroToken, uint heroId) internal view returns (uint) {\n    IReinforcementController.HeroInfo memory info = unpackHeroInfo(_S()._stakedHeroes[heroToken.packNftId(heroId)]);\n    if (info.stakeTs > block.timestamp) {\n      return 0;\n    }\n    uint time = block.timestamp - info.stakeTs;\n    if (time > _STAKE_REDUCE_DELAY) {\n      time -= _STAKE_REDUCE_DELAY;\n    } else {\n      // if staked less then delay ago hero has 100% scores\n      return info.score;\n    }\n    if (time > _STAKE_REDUCE_DELAY * _DELAY_FACTOR) {\n      // if hero staked more than delay*2 days return zero\n      return 0;\n    }\n\n    return info.score * (_STAKE_REDUCE_DELAY * _DELAY_FACTOR - time) / (_STAKE_REDUCE_DELAY * _DELAY_FACTOR);\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ GOV ACTIONS\n\n  function setMinLevel(bool isGovernance, uint8 value) internal {\n    if (!isGovernance) revert IAppErrors.NotGovernance(msg.sender);\n\n    (, uint8 _minLifeChances) = unpackConfig(_S().config);\n    _S().config = packConfig(value, _minLifeChances);\n\n    emit IApplicationEvents.MinLevelChanged(value);\n  }\n\n  function setMinLifeChances(bool isGovernance, uint8 value) internal {\n    if (!isGovernance) revert IAppErrors.NotGovernance(msg.sender);\n\n    (uint8 _minLevel,) = unpackConfig(_S().config);\n    _S().config = packConfig(_minLevel, value);\n\n    emit IApplicationEvents.MinLifeChancesChanged(value);\n  }\n\n  //endregion ------------------------ GOV ACTIONS\n\n  //region ------------------------ USER ACTIONS\n\n  /// @notice Mark the hero as staked in _stakedHeroes and _internalIdsByBiomes\n  /// @param fee [0..._TO_HELPER_RATIO_MAX], higher fee => less score\n  function stakeHero(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId, uint8 fee) internal {\n    IReinforcementController.MainState storage s = _S();\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\n    if (IERC721(heroToken).ownerOf(heroId) != msgSender) revert IAppErrors.ErrorNotHeroOwner(heroToken, msgSender);\n\n    IHeroController hc = IHeroController(controller.heroController());\n    if (hc.heroClass(heroToken) == 0) revert IAppErrors.ErrorHeroIsNotRegistered(heroToken);\n\n    if (IDungeonFactory(controller.dungeonFactory()).currentDungeon(heroToken, heroId) != 0) revert IAppErrors.HeroInDungeon();\n    if (isStaked(heroToken, heroId)) revert IAppErrors.AlreadyStaked();\n    if (fee > _TO_HELPER_RATIO_MAX) revert IAppErrors.MaxFee(fee);\n    if (fee < _FEE_MIN) revert IAppErrors.MinFee(fee);\n\n    IStatController statController = IStatController(controller.statController());\n\n    {\n      IStatController.ChangeableStats memory stats = statController.heroStats(heroToken, heroId);\n      (uint8 _minLevel, uint8 _minLifeChances) = unpackConfig(s.config);\n      if (stats.level < _minLevel || stats.lifeChances < _minLifeChances) revert IAppErrors.StakeHeroNotStats();\n      if (stats.lifeChances == 0) revert IAppErrors.ErrorHeroIsDead(heroToken, heroId); // for the case _minLifeChances == 0\n    }\n\n    { // Reinforcement requires 3 skills, see https://discord.com/channels/1134537718039318608/1236334562024620092\n      uint8[] memory busySlots = statController.heroItemSlots(heroToken, heroId);\n      uint counter = 0;\n      if (busySlots.length >= _SIP001_COUNT_REQUIRED_SKILLS) {\n        for (uint i; i < busySlots.length; ++i) {\n          if (\n            (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_1))\n            || (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_2))\n            || (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_3))\n          ) counter++;\n        }\n      }\n      if (counter < _SIP001_COUNT_REQUIRED_SKILLS) revert IAppErrors.ErrorReinforcementRequiresThreeSkills();\n    }\n\n    uint8 biome = hc.heroBiome(heroToken, heroId);\n    uint score = hc.score(heroToken, heroId);\n\n    // score bonus for discount\n    score += score * (_TO_HELPER_RATIO_MAX - fee) / 10;\n    EnumerableSet.Bytes32Set storage internalIds = s._internalIdsByBiomes[biome];\n\n    internalIds.add(heroToken.packNftId(heroId));\n\n    s._stakedHeroes[heroToken.packNftId(heroId)] = packHeroInfo(IReinforcementController.HeroInfo({\n      biome: biome,\n      score: score,\n      fee: fee,\n      stakeTs: uint64(block.timestamp)\n    }));\n\n    emit IApplicationEvents.HeroStaked(heroToken, heroId, biome, score);\n  }\n\n  /// @notice Reverse operation for {stakeHero}\n  function withdrawHero(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId) internal {\n    IReinforcementController.MainState storage s = _S();\n\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\n    if (IERC721(heroToken).ownerOf(heroId) != msgSender) revert IAppErrors.ErrorNotHeroOwner(heroToken, msgSender);\n    if (IHeroController(controller.heroController()).heroClass(heroToken) == 0) revert IAppErrors.ErrorHeroIsNotRegistered(heroToken);\n\n    IReinforcementController.HeroInfo memory _heroInfo = unpackHeroInfo(s._stakedHeroes[heroToken.packNftId(heroId)]);\n    if (_heroInfo.biome == 0) revert IAppErrors.NotStaked();\n\n    s._internalIdsByBiomes[_heroInfo.biome].remove(heroToken.packNftId(heroId));\n    delete s._stakedHeroes[heroToken.packNftId(heroId)];\n\n    emit IApplicationEvents.HeroWithdraw(heroToken, heroId);\n  }\n\n  struct AskHeroContext {\n    address heroToken;\n    uint heroId;\n    uint length;\n    uint random;\n    uint floor;\n    uint idx;\n    uint loops;\n    uint i;\n  }\n\n  /// @dev It's view like function but we need to touch slots in oracle function.\n  function askHero(IController controller, uint biome) internal returns (\n    address heroToken,\n    uint heroId,\n    int32[] memory attributes\n  ) {\n    AskHeroContext memory c;\n    {\n      IOracle oracle = IOracle(controller.oracle());\n      EnumerableSet.Bytes32Set storage internalIds = _S()._internalIdsByBiomes[biome];\n      c.length = internalIds.length();\n      if (c.length == 0) revert IAppErrors.NoStakedHeroes();\n\n      // oracle doesn't allow to pass maxValue = 0, so length == 1 is the special case below\n      c.idx = c.length == 1 ? 0 : oracle.getRandomNumber(c.length - 1, 0);\n\n      c.loops = Math.min(_SEARCH_WINDOW, c.length);\n\n      address[] memory heroes = new address[](c.loops);\n      uint[] memory heroIds = new uint[](c.loops);\n      uint[] memory heroScores = new uint[](c.loops);\n      uint totalWeight;\n\n      for (; c.i < c.loops; ++c.i) {\n        if (c.idx >= c.length) {\n          c.idx = 0;\n        }\n        (c.heroToken, c.heroId) = internalIds.at(c.idx).unpackNftId();\n\n        uint s = heroScoreAdjusted(c.heroToken, c.heroId);\n\n        // make a snapshot from staked heroes\n        heroes[c.i] = c.heroToken;\n        heroIds[c.i] = c.heroId;\n        // increase chance to be called for heroes with higher scores\n        heroScores[c.i] = s ** 3;\n        totalWeight += heroScores[c.i];\n\n        c.idx++;\n      }\n\n      c.random = oracle.getRandomNumber(1e18, 0);\n      c.floor = Math.min(totalWeight, c.random % totalWeight);\n\n      // roulette wheel selection\n      for(c.i = 0; c.i < c.loops; ++c.i) {\n        if (c.floor < heroScores[c.i]) {\n          c.heroToken = heroes[c.i];\n          c.heroId = heroIds[c.i];\n          break;\n        } else {\n          c.floor -= heroScores[c.i];\n        }\n      }\n\n\n      if (c.heroToken == address(0) || c.heroId == 0) revert IAppErrors.NoStakedHeroes();\n    }\n    {\n      IStatController sc = IStatController(controller.statController());\n      uint[] memory indexes = new uint[](12);\n\n      indexes[0] = uint(IStatController.ATTRIBUTES.STRENGTH);\n      indexes[1] = uint(IStatController.ATTRIBUTES.DEXTERITY);\n      indexes[2] = uint(IStatController.ATTRIBUTES.VITALITY);\n      indexes[3] = uint(IStatController.ATTRIBUTES.ENERGY);\n      indexes[4] = uint(IStatController.ATTRIBUTES.DAMAGE_MIN);\n      indexes[5] = uint(IStatController.ATTRIBUTES.DAMAGE_MAX);\n      indexes[6] = uint(IStatController.ATTRIBUTES.ATTACK_RATING);\n      indexes[7] = uint(IStatController.ATTRIBUTES.DEFENSE);\n      indexes[8] = uint(IStatController.ATTRIBUTES.BLOCK_RATING);\n      indexes[9] = uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE);\n      indexes[10] = uint(IStatController.ATTRIBUTES.COLD_RESISTANCE);\n      indexes[11] = uint(IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE);\n\n      attributes = _generateReinforcementAttributes(sc, indexes, c.heroToken, c.heroId);\n    }\n    emit IApplicationEvents.HeroAsk(c.heroToken, c.heroId);\n\n    return (c.heroToken, c.heroId, attributes);\n  }\n\n  /// @dev Only for dungeon. Assume the tokens already sent to this contract.\n  function registerTokenReward(IController controller, address heroToken, uint heroId, address token, uint amount) internal {\n    if (controller.dungeonFactory() != msg.sender) revert IAppErrors.ErrorNotDungeonFactory(msg.sender);\n\n    EnumerableMap.AddressToUintMap storage rewards = _S()._heroTokenRewards[heroToken.packNftId(heroId)];\n\n    (,uint existAmount) = rewards.tryGet(token);\n    rewards.set(token, existAmount + amount);\n\n    emit IApplicationEvents.TokenRewardRegistered(heroToken, heroId, token, amount, existAmount + amount);\n  }\n\n  /// @dev Only for dungeon. Assume the NFT already sent to this contract.\n  function registerNftReward(IController controller, address heroToken, uint heroId, address token, uint tokenId) internal {\n    if (controller.dungeonFactory() != msg.sender) revert IAppErrors.ErrorNotDungeonFactory(msg.sender);\n\n    _S()._heroNftRewards[heroToken.packNftId(heroId)].push(token.packNftId(tokenId));\n\n    emit IApplicationEvents.NftRewardRegistered(heroToken, heroId, token, tokenId);\n  }\n\n  function claimAll(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId) internal {\n    if (IERC721(heroToken).ownerOf(heroId) != msgSender) revert IAppErrors.ErrorNotHeroOwner(heroToken, msgSender);\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\n\n    _claimAllTokenRewards(heroToken, heroId, msgSender);\n    _claimAllNftRewards(heroToken, heroId, msgSender);\n  }\n\n  function claimNft(\n    bool isEoa,\n    IController controller,\n    address msgSender,\n    address heroToken,\n    uint heroId,\n    uint countNft\n  ) internal {\n    if (IERC721(heroToken).ownerOf(heroId) != msgSender) revert IAppErrors.ErrorNotHeroOwner(heroToken, msgSender);\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\n\n    _claimNftRewards(heroToken, heroId, msgSender, countNft);\n  }\n  //endregion ------------------------ USER ACTIONS\n\n  //region ------------------------ Internal logic\n  /// @notice Claim all rewards from {_heroTokenRewards} to {recipient}, remove data from {_heroTokenRewards}\n  function _claimAllTokenRewards(address heroToken, uint heroId, address recipient) internal {\n    EnumerableMap.AddressToUintMap storage rewards = _S()._heroTokenRewards[heroToken.packNftId(heroId)];\n    uint length = rewards.length();\n    address[] memory tokens = new address[](length);\n    for (uint i; i < length; ++i) {\n      (address token, uint amount) = rewards.at(i);\n      IERC20(token).transfer(recipient, amount);\n      emit IApplicationEvents.ClaimedToken(heroToken, heroId, token, amount, recipient);\n\n      tokens[i] = token;\n    }\n\n    // need to remove after the ordered reading for handle all elements, just remove the struct will not work coz contains mapping inside\n    for (uint i; i < length; ++i) {\n      rewards.remove(tokens[i]);\n    }\n  }\n\n  function _claimAllNftRewards(address heroToken, uint heroId, address recipient) internal {\n    bytes32[] storage rewards = _S()._heroNftRewards[heroToken.packNftId(heroId)];\n    uint length = rewards.length;\n    for (uint i; i < length; ++i) {\n      (address token, uint id) = rewards[i].unpackNftId();\n      IERC721(token).safeTransferFrom(address(this), recipient, id);\n      emit IApplicationEvents.ClaimedItem(heroToken, heroId, token, id, recipient);\n    }\n    // a simple array can be just deleted\n    delete _S()._heroNftRewards[heroToken.packNftId(heroId)];\n  }\n\n  /// @notice Claim last {countNft} NFTs and remove them from {_heroNftRewards}\n  function _claimNftRewards(address heroToken, uint heroId, address recipient, uint countNft) internal {\n    bytes32[] storage rewards = _S()._heroNftRewards[heroToken.packNftId(heroId)];\n\n    uint length = rewards.length;\n    uint indexLastToDelete = countNft >= length\n      ? 0\n      : length - countNft;\n\n    while (length != indexLastToDelete) {\n      (address token, uint id) = rewards[length - 1].unpackNftId();\n      IERC721(token).safeTransferFrom(address(this), recipient, id);\n      emit IApplicationEvents.ClaimedItem(heroToken, heroId, token, id, recipient);\n      length--;\n\n      // if we are going to remove all items we can just delete all items at the end\n      // otherwise we should pop the items one by one\n      if (indexLastToDelete != 0) {\n        rewards.pop();\n      }\n    }\n\n    if (length == 0) {\n      delete _S()._heroNftRewards[heroToken.packNftId(heroId)];\n    }\n  }\n\n  function _generateReinforcementAttributes(IStatController sc, uint[] memory indexes, address heroToken, uint heroId)\n  internal view returns (int32[] memory attributes) {\n    attributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\n    for (uint i; i < indexes.length; ++i) {\n      attributes[indexes[i]] = CalcLib.max32(sc.heroAttribute(heroToken, heroId, indexes[i]) * _ATTRIBUTES_RATIO / 100, 1);\n    }\n  }\n  //endregion ------------------------ Internal logic\n\n  //region ------------------------ Packing utils\n\n  function packHeroInfo(IReinforcementController.HeroInfo memory info) internal pure returns (bytes32) {\n    return PackingLib.packReinforcementHeroInfo(info.biome, uint128(info.score), info.fee, info.stakeTs);\n  }\n\n  function unpackHeroInfo(bytes32 packed) internal pure returns (IReinforcementController.HeroInfo memory info) {\n    (info.biome, info.score, info.fee, info.stakeTs) = PackingLib.unpackReinforcementHeroInfo(packed);\n    return info;\n  }\n\n  function packConfig(uint8 minLevel_, uint8 minLifeChances_) internal pure returns (bytes32) {\n    return PackingLib.packUint8Array3(minLevel_, minLifeChances_, 0);\n  }\n\n  function unpackConfig(bytes32 packed) internal pure returns (uint8 minLevel_, uint8 minLifeChances_) {\n    (minLevel_, minLifeChances_,) = PackingLib.unpackUint8Array3(packed);\n  }\n\n  //endregion ------------------------ Packing utils\n\n}\n"
    },
    "contracts/lib/ScoreLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/IStatController.sol\";\nimport \"./CalcLib.sol\";\n\nlibrary ScoreLib {\n  using CalcLib for int32;\n\n  // core\n  uint public constant STRENGTH = 100;\n  uint public constant DEXTERITY = 100;\n  uint public constant VITALITY = 100;\n  uint public constant ENERGY = 100;\n\n  // attributes\n  uint public constant MELEE_DAMAGE = 10;\n  uint public constant ATTACK_RATING = 3;\n  uint public constant DEFENCE = 10;\n  uint public constant BLOCK_RATING = 500;\n  uint public constant LIFE = 10;\n  uint public constant MANA = 10;\n\n  uint public constant LIFE_CHANCES = 10_000;\n  uint public constant MAGIC_FIND = 300;\n  uint public constant CRITICAL_HIT = 150;\n  uint public constant DMG_FACTOR = 200;\n\n  uint public constant AR_FACTOR = 200;\n  uint public constant LIFE_STOLEN_PER_HIT = 1000;\n  uint public constant MANA_AFTER_KILL = 1000;\n  uint public constant DAMAGE_REDUCTION = 500;\n  uint public constant REFLECT_DAMAGE = 250;\n  uint public constant RESIST_TO_STATUSES = 70;\n\n  // resistance\n  uint public constant ELEMENT_RESIST = 100;\n\n  // race specific attributes\n  uint public constant RACE_SPECIFIC = 20;\n\n  // statuses\n  uint public constant STATUSES = 100;\n\n  // items\n  uint public constant DURABILITY_SCORE = 1;\n\n  // hero\n  uint public constant HERO_LEVEL_SCORE = 1000;\n\n  /// @param isForReinforcement If true calculate score using 12 main attributes only. Otherwise use all attributes.\n  function attributesScore(int32[] memory attributes, bool isForReinforcement) internal pure returns (uint) {\n    uint result;\n    {\n      result += (attributes[uint(IStatController.ATTRIBUTES.STRENGTH)]).toUint() * STRENGTH\n        + (attributes[uint(IStatController.ATTRIBUTES.DEXTERITY)]).toUint() * DEXTERITY\n        + (attributes[uint(IStatController.ATTRIBUTES.VITALITY)]).toUint() * VITALITY\n        + (attributes[uint(IStatController.ATTRIBUTES.ENERGY)]).toUint() * ENERGY\n        + (attributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)]).toUint() * ATTACK_RATING\n        + (attributes[uint(IStatController.ATTRIBUTES.DEFENSE)]).toUint() * DEFENCE\n        + (attributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)]).toUint() * BLOCK_RATING\n        + Math.average(attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)].toUint(), attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)].toUint()) * MELEE_DAMAGE\n      ;\n    }\n    {\n      result +=\n        (attributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)]).toUint() * ELEMENT_RESIST\n        + (attributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)]).toUint() * ELEMENT_RESIST\n        + (attributes[uint(IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE)]).toUint() * ELEMENT_RESIST;\n    }\n\n    if (! isForReinforcement) {\n      {\n        result +=\n          (attributes[uint(IStatController.ATTRIBUTES.LIFE)]).toUint() * LIFE\n          + (attributes[uint(IStatController.ATTRIBUTES.MANA)]).toUint() * MANA;\n      }\n      {\n        result +=\n          (attributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_HUMAN)]).toUint() * RACE_SPECIFIC\n          + (attributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_UNDEAD)]).toUint() * RACE_SPECIFIC\n          + (attributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_DAEMON)]).toUint() * RACE_SPECIFIC\n          + (attributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_BEAST)]).toUint() * RACE_SPECIFIC\n          + (attributes[uint(IStatController.ATTRIBUTES.DEF_AGAINST_HUMAN)]).toUint() * RACE_SPECIFIC\n          + (attributes[uint(IStatController.ATTRIBUTES.DEF_AGAINST_UNDEAD)]).toUint() * RACE_SPECIFIC\n          + (attributes[uint(IStatController.ATTRIBUTES.DEF_AGAINST_DAEMON)]).toUint() * RACE_SPECIFIC\n          + (attributes[uint(IStatController.ATTRIBUTES.DEF_AGAINST_BEAST)]).toUint() * RACE_SPECIFIC;\n      }\n      {\n        result +=\n          (attributes[uint(IStatController.ATTRIBUTES.STUN)]).toUint() * STATUSES\n          + (attributes[uint(IStatController.ATTRIBUTES.BURN)]).toUint() * STATUSES\n          + (attributes[uint(IStatController.ATTRIBUTES.FREEZE)]).toUint() * STATUSES\n          + (attributes[uint(IStatController.ATTRIBUTES.CONFUSE)]).toUint() * STATUSES\n          + (attributes[uint(IStatController.ATTRIBUTES.CURSE)]).toUint() * STATUSES\n          + (attributes[uint(IStatController.ATTRIBUTES.POISON)]).toUint() * STATUSES;\n      }\n      {\n        result +=\n          (attributes[uint(IStatController.ATTRIBUTES.LIFE_CHANCES)]).toUint() * LIFE_CHANCES\n          + (attributes[uint(IStatController.ATTRIBUTES.MAGIC_FIND)]).toUint() * MAGIC_FIND\n          + (attributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)]).toUint() * CRITICAL_HIT\n          + (attributes[uint(IStatController.ATTRIBUTES.MELEE_DMG_FACTOR)]).toUint() * DMG_FACTOR\n          + (attributes[uint(IStatController.ATTRIBUTES.FIRE_DMG_FACTOR)]).toUint() * DMG_FACTOR\n          + (attributes[uint(IStatController.ATTRIBUTES.COLD_DMG_FACTOR)]).toUint() * DMG_FACTOR\n          + (attributes[uint(IStatController.ATTRIBUTES.LIGHTNING_DMG_FACTOR)]).toUint() * DMG_FACTOR;\n      }\n      {\n        result +=\n          (attributes[uint(IStatController.ATTRIBUTES.AR_FACTOR)]).toUint() * AR_FACTOR\n          + (attributes[uint(IStatController.ATTRIBUTES.LIFE_STOLEN_PER_HIT)]).toUint() * LIFE_STOLEN_PER_HIT\n          + (attributes[uint(IStatController.ATTRIBUTES.MANA_AFTER_KILL)]).toUint() * MANA_AFTER_KILL\n          + (attributes[uint(IStatController.ATTRIBUTES.DAMAGE_REDUCTION)]).toUint() * DAMAGE_REDUCTION\n          + (attributes[uint(IStatController.ATTRIBUTES.REFLECT_DAMAGE_MELEE)]).toUint() * REFLECT_DAMAGE\n          + (attributes[uint(IStatController.ATTRIBUTES.REFLECT_DAMAGE_MAGIC)]).toUint() * REFLECT_DAMAGE\n          + (attributes[uint(IStatController.ATTRIBUTES.RESIST_TO_STATUSES)]).toUint() * RESIST_TO_STATUSES;\n      }\n    }\n    return result;\n  }\n\n  function itemScore(int32[] memory attributes, uint16 baseDurability) internal pure returns (uint) {\n    return attributesScore(attributes, false) + baseDurability * DURABILITY_SCORE;\n  }\n\n  function heroScore(int32[] memory attributes, uint level) internal pure returns (uint) {\n    return attributesScore(attributes, true) + level * HERO_LEVEL_SCORE;\n  }\n\n}\n"
    },
    "contracts/lib/SlotsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\n/// @author bogdoslav\nlibrary SlotsLib {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant SLOT_LIB_VERSION = \"1.0.0\";\n\n  // ************* GETTERS *******************\n\n  /// @dev Gets a slot as bytes32\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as an address\n  function getAddress(bytes32 slot) internal view returns (address result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as uint256\n  function getUint(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  // ************* ARRAY GETTERS *******************\n\n  /// @dev Gets an array length\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot array by index as address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  // ************* SETTERS *******************\n\n  /// @dev Sets a slot with bytes32\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, bytes32 value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with address\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, address value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with uint\n  function set(bytes32 slot, uint value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n}\n"
    },
    "contracts/lib/StatControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/Math.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../interfaces/IItemController.sol\";\nimport \"../interfaces/IStatController.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../lib/StatLib.sol\";\n\n/// @notice Implementation of StatController\nlibrary StatControllerLib {\n  using StatLib for uint;\n  using StatLib for uint[];\n  using StatLib for uint32;\n  using StatLib for int32;\n  using StatLib for int32;\n  using CalcLib for uint;\n  using CalcLib for int;\n  using CalcLib for int32;\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using PackingLib for bytes32[];\n  using PackingLib for bytes32;\n  using PackingLib for int32;\n  using PackingLib for uint32;\n\n  //region ------------------------ Constants\n  /// @dev keccak256(abi.encode(uint256(keccak256(\"stat.controller.main\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0xca9e8235a410bd2656fc43f888ab589425034944963c2881072ee821e700e600;\n\n  int32 public constant LEVEL_UP_SUM = 5;\n  bytes32 public constant KARMA_HASH = bytes32(\"KARMA\");\n  bytes32 public constant HERO_CLASS_HASH = bytes32(\"HERO_CLASS\");\n\n  /// @notice Custom data of the hero. Value is incremented on every life-chance lost\n  bytes32 public constant DEATH_COUNT_HASH = bytes32(\"DEATH_COUNT\");\n  //endregion ------------------------ Constants\n\n  //region ------------------------ RESTRICTIONS\n\n  function onlyRegisteredContract(IController controller_) internal view {\n    address sender = msg.sender;\n    if (\n      controller_.heroController() != sender\n      && controller_.itemController() != sender\n      && controller_.dungeonFactory() != sender\n      && controller_.storyController() != sender\n      && controller_.gameObjectController() != sender\n    ) revert IAppErrors.ErrorForbidden(sender);\n  }\n\n  function onlyItemController(IController controller_) internal view {\n    if (controller_.itemController() != msg.sender) revert IAppErrors.ErrorNotItemController(msg.sender);\n  }\n\n  function onlyHeroController(IController controller_) internal view {\n    if (controller_.heroController() != msg.sender) revert IAppErrors.ErrorNotHeroController(msg.sender);\n  }\n  //endregion ------------------------ RESTRICTIONS\n\n  //region ------------------------ VIEWS\n  function _S() internal pure returns (IStatController.MainState storage s) {\n    assembly {\n      s.slot := MAIN_STORAGE_LOCATION\n    }\n    return s;\n  }\n\n  function heroAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (int32[] memory) {\n    return PackingLib.toInt32Array(s.heroTotalAttributes[PackingLib.packNftId(token, tokenId)], uint(IStatController.ATTRIBUTES.END_SLOT));\n  }\n\n  function heroBonusAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (int32[] memory) {\n    return PackingLib.toInt32Array(s.heroBonusAttributes[PackingLib.packNftId(token, tokenId)], uint(IStatController.ATTRIBUTES.END_SLOT));\n  }\n\n  function heroTemporallyAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (int32[] memory) {\n    return PackingLib.toInt32Array(s.heroTemporallyAttributes[PackingLib.packNftId(token, tokenId)], uint(IStatController.ATTRIBUTES.END_SLOT));\n  }\n\n\n  function heroAttributesLength(address /*token*/, uint /*tokenId*/) internal pure returns (uint) {\n    return uint(IStatController.ATTRIBUTES.END_SLOT);\n  }\n\n  function heroAttribute(IStatController.MainState storage s, address token, uint tokenId, uint index) internal view returns (int32) {\n    return PackingLib.getInt32(s.heroTotalAttributes[PackingLib.packNftId(token, tokenId)], index);\n  }\n\n  function heroBaseAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (\n    IStatController.CoreAttributes memory core\n  ) {\n    int32[] memory data = PackingLib.unpackInt32Array(s._heroCore[PackingLib.packNftId(token, tokenId)]);\n    core = IStatController.CoreAttributes({\n      strength: int32(data[0]),\n      dexterity: int32(data[1]),\n      vitality: int32(data[2]),\n      energy: int32(data[3])\n    });\n  }\n\n  function heroCustomData(IStatController.MainState storage s, address token, uint tokenId, bytes32 index) internal view returns (uint) {\n    return s.heroCustomData[PackingLib.packNftId(token, tokenId)][index];\n  }\n\n  function globalCustomData(IStatController.MainState storage s, bytes32 index) internal view returns (uint) {\n    return s.globalCustomData[index];\n  }\n\n  function heroStats(IStatController.MainState storage s, address token, uint tokenId) internal view returns (\n    IStatController.ChangeableStats memory result\n  ) {\n    uint32[] memory data = PackingLib.unpackUint32Array(s.heroStats[PackingLib.packNftId(token, tokenId)]);\n    result = IStatController.ChangeableStats({\n      level: uint32(data[0]),\n      experience: uint32(data[1]),\n      life: uint32(data[2]),\n      mana: uint32(data[3]),\n      lifeChances: uint32(data[4])\n    });\n  }\n\n  function heroItemSlot(IStatController.MainState storage s, address heroToken, uint64 heroTokenId, uint8 itemSlot) internal view returns (\n    bytes32 nftPacked\n  ) {\n    return s.heroSlots[PackingLib.packMapObject(heroToken, heroTokenId, itemSlot)];\n  }\n\n  /// @return Return list of indices of the busy item slots for the given hero\n  function heroItemSlots(IStatController.MainState storage s, address heroToken, uint heroTokenId) internal view returns (\n    uint8[] memory\n  ) {\n    uint8[] memory slots = PackingLib.unpackUint8Array(s.heroBusySlots[PackingLib.packNftId(heroToken, heroTokenId)]);\n\n    uint8[] memory busySlotsNumbers = new uint8[](slots.length);\n    uint counter;\n\n    for (uint8 i; i < uint8(slots.length); ++i) {\n      if (slots[i] != 0) {\n        busySlotsNumbers[counter] = i;\n        counter++;\n      }\n    }\n\n    uint8[] memory result = new uint8[](counter);\n\n    for (uint i; i < counter; ++i) {\n      result[i] = busySlotsNumbers[i];\n    }\n\n    return result;\n  }\n\n  function isHeroAlive(IStatController.MainState storage s, address heroToken, uint heroTokenId) internal view returns (bool) {\n    return heroStats(s, heroToken, heroTokenId).lifeChances != 0;\n  }\n\n  function isConsumableUsed(IStatController.MainState storage s, address heroToken, uint heroTokenId, address item) internal view returns (bool) {\n    return s.usedConsumables[PackingLib.packNftId(heroToken, heroTokenId)].contains(item);\n  }\n\n  /// @notice Calculate totalAttributes + all attributes of the items specified in {info}\n  function buffHero(\n    IStatController.MainState storage s,\n    IController c,\n    IStatController.BuffInfo memory info\n  ) internal view returns (\n    int32[] memory dest,\n    int32 manaSum\n  ) {\n    uint length = info.buffTokens.length;\n    if (length == 0) {\n      return (heroAttributes(s, info.heroToken, info.heroTokenId), 0);\n    }\n\n    IItemController ic = IItemController(c.itemController());\n\n    int32[] memory buffAttributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\n    address[] memory usedTokens = new address[](length);\n\n    for (uint i; i < length; ++i) {\n\n      // we should ignore the same skills\n      bool used;\n      for(uint j; j < i; ++j) {\n        if (usedTokens[j] == info.buffTokens[i]) {\n          used = true;\n          break;\n        }\n      }\n      if(used) {\n        continue;\n      }\n\n\n      manaSum += int32(ic.itemMeta(info.buffTokens[i]).manaCost);\n      (int32[] memory values, uint8[] memory ids) = ic.casterAttributes(info.buffTokens[i], info.buffTokenIds[i]);\n      StatLib.attributesAdd(buffAttributes, StatLib.valuesToFullAttributesArray(values, ids));\n      usedTokens[i] = info.buffTokens[i];\n    }\n\n    int32[] memory totalAttributes = StatLib.attributesAdd(heroAttributes(s, info.heroToken, info.heroTokenId), buffAttributes);\n\n    StatLib.attributesAdd(buffAttributes, heroBonusAttributes(s, info.heroToken, info.heroTokenId));\n    StatLib.attributesAdd(buffAttributes, heroTemporallyAttributes(s, info.heroToken, info.heroTokenId));\n\n    return (\n      StatLib.updateCoreDependAttributesInMemory(\n        totalAttributes,\n        buffAttributes,\n        IHeroController(c.heroController()).heroClass(info.heroToken),\n        info.heroLevel\n      ),\n      manaSum\n    );\n  }\n\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ PURE\n\n  function isItemTypeEligibleToItemSlot(uint itemType, uint itemSlot) internal pure returns (bool) {\n    // Consumable items not eligible\n    if (itemType == 0 || itemSlot == 0) {\n      return false;\n    }\n    // items with type before 5 mapped 1 to 1\n    if (itemType <= uint(IItemController.ItemType.AMULET)) {\n      return itemSlot == itemType;\n    }\n    if (itemType == uint(IItemController.ItemType.RING)) {\n      return itemSlot == uint(IStatController.ItemSlots.RIGHT_RING)\n        || itemSlot == uint(IStatController.ItemSlots.LEFT_RING);\n    }\n    if (itemType == uint(IItemController.ItemType.BOOTS)) {\n      return itemSlot == uint(IStatController.ItemSlots.BOOTS);\n    }\n    if (itemType == uint(IItemController.ItemType.ONE_HAND)) {\n      return itemSlot == uint(IStatController.ItemSlots.RIGHT_HAND);\n    }\n    if (itemType == uint(IItemController.ItemType.OFF_HAND)) {\n      return itemSlot == uint(IStatController.ItemSlots.LEFT_HAND);\n    }\n    if (itemType == uint(IItemController.ItemType.TWO_HAND)) {\n      return itemSlot == uint(IStatController.ItemSlots.TWO_HAND);\n    }\n    if (itemType == uint(IItemController.ItemType.SKILL)) {\n      return itemSlot == uint(IStatController.ItemSlots.SKILL_1)\n      || itemSlot == uint(IStatController.ItemSlots.SKILL_2)\n        || itemSlot == uint(IStatController.ItemSlots.SKILL_3);\n    }\n    // unknown types\n    return false;\n  }\n\n  /// @notice How much experience is required to go from the {level} to the next level\n  function levelUpExperienceRequired(uint32 level) internal pure returns (uint) {\n    if (level == 0 || level >= StatLib.MAX_LEVEL) return 0;\n    return level == uint32(1)\n      ? StatLib.levelExperience(level)\n      : StatLib.levelExperience(level) - StatLib.levelExperience(level - uint32(1));\n  }\n\n  //endregion ------------------------ PURE\n\n  //region ------------------------ ACTIONS\n\n  /// @notice Initialize new hero, set up custom data, core data, changeable stats by default value\n  /// @param heroClass [1..6], see StatLib.initHeroXXX\n  function initNewHero(\n    IStatController.MainState storage s,\n    IController c,\n    address heroToken,\n    uint heroTokenId,\n    uint heroClass\n  ) internal {\n    StatControllerLib.onlyHeroController(c);\n\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    _initNewHeroCore(s, heroPackedId, heroClass);\n\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\n    uint32[] memory baseStats = StatLib.initAttributes(totalAttributes, heroClass, 1, heroClass.initialHero().core);\n\n    _initChangeableStats(s, heroPackedId, baseStats);\n    emit IApplicationEvents.NewHeroInited(heroToken, heroTokenId, IStatController.ChangeableStats({\n      level: 1,\n      experience: 0,\n      life: baseStats[0],\n      mana: baseStats[1],\n      lifeChances: baseStats[2]\n    }));\n\n    // --- init predefined custom hero data\n\n    mapping(bytes32 => uint) storage customData = s.heroCustomData[heroPackedId];\n\n    // set initial karma\n    customData[KARMA_HASH] = 1000;\n    emit IApplicationEvents.HeroCustomDataChanged(heroToken, heroTokenId, KARMA_HASH, 1000);\n\n    // set hero class as parameter for stories\n    customData[HERO_CLASS_HASH] = heroClass;\n    emit IApplicationEvents.HeroCustomDataChanged(heroToken, heroTokenId, HERO_CLASS_HASH, heroClass);\n\n    // set death count value\n    // customData[DEATH_COUNT_HASH] is initialized by 0 by default\n    emit IApplicationEvents.HeroCustomDataChanged(heroToken, heroTokenId, DEATH_COUNT_HASH, 0);\n  }\n\n  function _initNewHeroCore(IStatController.MainState storage s, bytes32 heroPackedId, uint heroClass) internal {\n    IStatController.CoreAttributes memory initialCore = heroClass.initialHero().core;\n    int32[] memory arr = new int32[](4);\n\n    arr[0] = int32(initialCore.strength);\n    arr[1] = int32(initialCore.dexterity);\n    arr[2] = int32(initialCore.vitality);\n    arr[3] = int32(initialCore.energy);\n\n    s._heroCore[heroPackedId] = PackingLib.packInt32Array(arr);\n  }\n\n  function _initChangeableStats(IStatController.MainState storage s, bytes32 heroPackedId, uint32[] memory baseStats) internal {\n    _changeChangeableStats(s, heroPackedId, 1, 0, baseStats[0], baseStats[1], baseStats[2]);\n  }\n\n  function _changeChangeableStats(\n    IStatController.MainState storage s,\n    bytes32 heroPackedId,\n    uint32 level,\n    uint32 experience,\n    uint32 life,\n    uint32 mana,\n    uint32 lifeChances\n  ) internal {\n    if(lifeChances != 0 && life == 0) {\n      life = 1;\n    }\n    uint32[] memory data = new uint32[](5);\n    data[0] = level;\n    data[1] = experience;\n    data[2] = life;\n    data[3] = mana;\n    data[4] = lifeChances;\n\n    s.heroStats[heroPackedId] = PackingLib.packUint32Array(data);\n  }\n\n  /// @notice Add/remove the item to/from the hero\n  function changeHeroItemSlot(\n    IStatController.MainState storage s,\n    IController controller,\n    address heroToken,\n    uint64 heroTokenId,\n    uint itemType,\n    uint8 itemSlot,\n    address itemToken,\n    uint itemTokenId,\n    bool equip\n  ) internal {\n    StatControllerLib.onlyItemController(controller);\n    if (!StatControllerLib.isItemTypeEligibleToItemSlot(itemType, itemSlot)) revert IAppErrors.ErrorItemNotEligibleForTheSlot(itemType, itemSlot);\n\n    // if we are going to take an item by two hands, we need both hands free.\n    // if we are going to use only one hand, we shouldn't keep anything by two hands\n    if (itemSlot == uint(IStatController.ItemSlots.TWO_HAND)) {\n      if (heroItemSlot(s, heroToken, heroTokenId, uint8(IStatController.ItemSlots.RIGHT_HAND)) != bytes32(0)\n        || heroItemSlot(s, heroToken, heroTokenId, uint8(IStatController.ItemSlots.LEFT_HAND)) != bytes32(0)) {\n        revert IAppErrors.ErrorItemSlotBusyHand(itemSlot);\n      }\n    }\n    if (itemSlot == uint(IStatController.ItemSlots.RIGHT_HAND) || itemSlot == uint(IStatController.ItemSlots.LEFT_HAND)) {\n      if (heroItemSlot(s, heroToken, heroTokenId, uint8(IStatController.ItemSlots.TWO_HAND)) != bytes32(0)) {\n        revert IAppErrors.ErrorItemSlotBusyHand(itemSlot);\n      }\n    }\n\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    (address equippedItem, uint equippedItemId) = PackingLib.unpackNftId(heroItemSlot(s, heroToken, heroTokenId, itemSlot));\n    if (equip) {\n      if (equippedItem != address(0)) revert IAppErrors.ErrorItemSlotBusy();\n\n      s.heroSlots[PackingLib.packMapObject(heroToken, uint64(heroTokenId), itemSlot)] = PackingLib.packNftId(itemToken, itemTokenId);\n      s.heroBusySlots[heroPackedId] = PackingLib.changeUnit8ArrayWithCheck(s.heroBusySlots[heroPackedId], itemSlot, 1, 0);\n    } else {\n      if (equippedItem != itemToken || equippedItemId != itemTokenId) revert IAppErrors.ErrorItemNotInSlot();\n\n      delete s.heroSlots[PackingLib.packMapObject(heroToken, uint64(heroTokenId), itemSlot)];\n      s.heroBusySlots[heroPackedId] = PackingLib.changeUnit8ArrayWithCheck(s.heroBusySlots[heroPackedId], itemSlot, 0, 1);\n    }\n\n    emit IApplicationEvents.HeroItemSlotChanged(heroToken, heroTokenId, itemType, itemSlot, itemToken, itemTokenId, equip, msg.sender);\n  }\n\n  /// @notice Increase or decrease stats (life, mana, lifeChances). Experience can be increased only.\n  function changeCurrentStats(\n    IStatController.MainState storage s,\n    IController c,\n    address heroToken,\n    uint heroTokenId,\n    IStatController.ChangeableStats memory change,\n    bool increase\n  ) internal {\n    StatControllerLib.onlyRegisteredContract(c);\n\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    IStatController.ChangeableStats memory currentStats = heroStats(s, heroToken, heroTokenId);\n\n    uint32 life = currentStats.life;\n    uint32 mana = currentStats.mana;\n    uint32 lifeChances = currentStats.lifeChances;\n\n    if (increase) {\n      bytes32[] storage attrs = s.heroTotalAttributes[heroPackedId];\n      int32 maxLife = attrs.getInt32(uint(IStatController.ATTRIBUTES.LIFE));\n      int32 maxMana = attrs.getInt32(uint(IStatController.ATTRIBUTES.MANA));\n      int32 maxLC = attrs.getInt32(uint(IStatController.ATTRIBUTES.LIFE_CHANCES));\n\n      currentStats.experience += change.experience;\n      life = uint32(Math.min(maxLife.toUint(), uint(life + change.life)));\n      mana = uint32(Math.min(maxMana.toUint(), uint(mana + change.mana)));\n      lifeChances = uint32(Math.min(maxLC.toUint(), uint(lifeChances + change.lifeChances)));\n    } else {\n      if (change.experience != 0) revert IAppErrors.ErrorExperienceMustNotDecrease();\n      life = life > change.life ? life - change.life : 0;\n      lifeChances = lifeChances > change.lifeChances ? lifeChances - change.lifeChances : 0;\n      mana = mana > change.mana ? mana - change.mana : 0;\n    }\n\n    _changeChangeableStats(s, heroPackedId, currentStats.level, currentStats.experience, life, mana, lifeChances);\n    emit IApplicationEvents.CurrentStatsChanged(heroToken, heroTokenId, change, increase, msg.sender);\n  }\n\n  /// @notice Mark consumable {item} as used\n  function registerConsumableUsage(\n    IStatController.MainState storage s,\n    IController c,\n    address heroToken,\n    uint heroTokenId,\n    address item\n  ) internal {\n    StatControllerLib.onlyRegisteredContract(c);\n\n    if (!s.usedConsumables[PackingLib.packNftId(heroToken, heroTokenId)].add(item)) revert IAppErrors.ErrorConsumableItemIsUsed(item);\n    emit IApplicationEvents.ConsumableUsed(heroToken, heroTokenId, item);\n  }\n\n  /// @notice Clear all consumable items of the given hero\n  function clearUsedConsumables(\n    IStatController.MainState storage s,\n    IController c,\n    address heroToken,\n    uint heroTokenId\n  ) internal {\n    StatControllerLib.onlyRegisteredContract(c);\n\n    EnumerableSet.AddressSet storage items = s.usedConsumables[PackingLib.packNftId(heroToken, heroTokenId)];\n\n    uint length = items.length();\n\n    for (uint i; i < length; ++i) {\n      // we are removing the first element, so it's safe to use in cycle\n      address item = items.at(0);\n      if (!items.remove(item)) revert IAppErrors.ErrorCannotRemoveItemFromMap();\n      emit IApplicationEvents.RemoveConsumableUsage(heroToken, heroTokenId, item);\n    }\n  }\n\n  /// @notice Increase or decrease values of the given attributes, any attributes are allowed.\n  /// @dev If a core attribute is changed than depended attributes are recalculated\n  function changeBonusAttributes(\n    IStatController.MainState storage s,\n    IController c,\n    IStatController.ChangeAttributesInfo memory info\n  ) internal {\n    StatControllerLib.onlyRegisteredContract(c);\n    bytes32 heroPackedId = PackingLib.packNftId(info.heroToken, info.heroTokenId);\n\n    IStatController.ChangeableStats memory stats = heroStats(s, info.heroToken, info.heroTokenId);\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\n    (bytes32[] storage bonusMain, bytes32[] storage bonusExtra) = info.temporally\n      ? (s.heroTemporallyAttributes[heroPackedId], s.heroBonusAttributes[heroPackedId])\n      : (s.heroBonusAttributes[heroPackedId], s.heroTemporallyAttributes[heroPackedId]);\n\n    int32[] memory cachedTotalAttrChanged = new int32[](info.changeAttributes.length);\n    for (uint i; i < info.changeAttributes.length; ++i) {\n      int32 change = info.changeAttributes[i];\n      if (change != 0) {\n        int32 newTotalValue;\n\n        if (info.add) {\n          bonusMain.changeInt32(i, change);\n          newTotalValue = totalAttributes.getInt32(i) + change;\n        } else {\n          bonusMain.changeInt32(i, - change);\n          newTotalValue = totalAttributes.getInt32(i) - change;\n        }\n\n        // todo in some cases value stored here to totalAttributes will be overwritten below by updateCoreDependAttributes\n        // it happens if core attribute is changed AND it's depend attribute is change too\n        // values of the depend attribute will be overwritten by updateCoreDependAttributes\n        // fix it together with PACKED WRITING\n        totalAttributes.setInt32(i, newTotalValue);\n        cachedTotalAttrChanged[i] = newTotalValue;\n      }\n    }\n\n    _updateCoreDependAttributes(c, totalAttributes, bonusMain, bonusExtra, stats, info.heroToken, cachedTotalAttrChanged, info.changeAttributes);\n    _compareStatsWithAttributes(s, heroPackedId, totalAttributes, stats);\n\n    emit IApplicationEvents.BonusAttributesChanged(info.heroToken, info.heroTokenId, info.add, info.temporally, msg.sender);\n  }\n\n  /// @dev Make sure we don't have life/mana more than total attributes after decreasing\n  function _compareStatsWithAttributes(\n    IStatController.MainState storage s,\n    bytes32 heroPackedId,\n    bytes32[] storage totalAttributes,\n    IStatController.ChangeableStats memory curStats\n  ) internal {\n    uint life = totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.LIFE)).toUint();\n    uint mana = totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.MANA)).toUint();\n    bool changed;\n    if (life < curStats.life) {\n      curStats.life = uint32(Math.min(life, curStats.life));\n      changed = true;\n    }\n    if (mana < curStats.mana) {\n      curStats.mana = uint32(Math.min(mana, curStats.mana));\n      changed = true;\n    }\n    if (changed) {\n      _changeChangeableStats(s,\n        heroPackedId,\n        curStats.level,\n        curStats.experience,\n        curStats.life,\n        curStats.mana,\n        curStats.lifeChances\n      );\n    }\n  }\n\n  function clearTemporallyAttributes(\n    IStatController.MainState storage s,\n    IController c,\n    address heroToken,\n    uint heroTokenId\n  ) internal {\n    StatControllerLib.onlyRegisteredContract(c);\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n\n    bytes32[] memory tmpBonuses = s.heroTemporallyAttributes[heroPackedId];\n\n    IStatController.ChangeableStats memory stats = heroStats(s, heroToken, heroTokenId);\n    bytes32[] storage bonus = s.heroBonusAttributes[heroPackedId];\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\n\n    int32[] memory baseValues = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\n    int32[] memory tmpBonusesUnpacked = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\n    for (uint i; i < uint(IStatController.ATTRIBUTES.END_SLOT); ++i) {\n      int32 value = tmpBonuses.getInt32Memory(i);\n      if (value != int32(0)) {\n        (baseValues[i],) = totalAttributes.changeInt32(i, - int32(uint32(value)));\n        tmpBonusesUnpacked[i] = value;\n      }\n    }\n\n    delete s.heroTemporallyAttributes[heroPackedId];\n\n    bytes32[] storage tmpBonusesStorage = s.heroTemporallyAttributes[heroPackedId];\n\n    _updateCoreDependAttributes(c, totalAttributes, bonus, tmpBonusesStorage, stats, heroToken, baseValues, tmpBonusesUnpacked);\n    _compareStatsWithAttributes(s, heroPackedId, totalAttributes, stats);\n\n    emit IApplicationEvents.TemporallyAttributesCleared(heroToken, heroTokenId, msg.sender);\n  }\n\n  /// @dev Update depend-values for all changed attributes\n  function _updateCoreDependAttributes(\n    IController c,\n    bytes32[] storage totalAttributes,\n    bytes32[] storage bonusMain,\n    bytes32[] storage bonusExtra,\n    IStatController.ChangeableStats memory stats,\n    address heroToken,\n    int32[] memory baseValues,\n    int32[] memory changed\n  ) internal {\n    // handle core depend attributes in the second loop, totalAttributes should be updated together\n    uint len = changed.length;\n    for (uint i; i < len; ++i) {\n      // depend-values should be recalculated if corresponded core value is changed (even if it's equal to 0 now)\n      if (changed[i] != 0) {\n        StatLib.updateCoreDependAttributes(c, totalAttributes, bonusMain, bonusExtra, stats, i, heroToken, baseValues[i]);\n      }\n    }\n  }\n\n  function levelUp(\n    IStatController.MainState storage s,\n    IController c,\n    address heroToken,\n    uint heroTokenId,\n    uint heroClass,\n    IStatController.CoreAttributes memory change\n  ) internal returns (uint newLvl) {\n    StatControllerLib.onlyHeroController(c);\n\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    if (change.strength + change.dexterity + change.vitality + change.energy != LEVEL_UP_SUM) revert IAppErrors.ErrorWrongLevelUpSum();\n\n    IStatController.ChangeableStats memory currentStats = heroStats(s, heroToken, heroTokenId);\n\n    if (currentStats.level >= StatLib.MAX_LEVEL) revert IAppErrors.ErrorMaxLevel();\n    if (currentStats.level.levelExperience() > currentStats.experience) revert IAppErrors.ErrorNotEnoughExperience();\n    currentStats.level++;\n\n    {\n      int32[] memory data = PackingLib.unpackInt32Array(s._heroCore[heroPackedId]);\n\n      data[0] += change.strength;\n      data[1] += change.dexterity;\n      data[2] += change.vitality;\n      data[3] += change.energy;\n\n      s._heroCore[heroPackedId] = PackingLib.packInt32Array(data);\n    }\n\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\n    {\n      bytes32[] storage bonus = s.heroBonusAttributes[heroPackedId];\n      bytes32[] storage bonusTmp = s.heroTemporallyAttributes[heroPackedId];\n\n      // update\n      _addCoreToTotal(\n        c,\n        totalAttributes,\n        bonus,\n        bonusTmp,\n        currentStats,\n        heroToken,\n        change.strength,\n        uint(IStatController.ATTRIBUTES.STRENGTH)\n      );\n      _addCoreToTotal(\n        c,\n        totalAttributes,\n        bonus,\n        bonusTmp,\n        currentStats,\n        heroToken,\n        change.dexterity,\n        uint(IStatController.ATTRIBUTES.DEXTERITY)\n      );\n      _addCoreToTotal(\n        c,\n        totalAttributes,\n        bonus,\n        bonusTmp,\n        currentStats,\n        heroToken,\n        change.vitality,\n        uint(IStatController.ATTRIBUTES.VITALITY)\n      );\n      _addCoreToTotal(\n        c,\n        totalAttributes,\n        bonus,\n        bonusTmp,\n        currentStats,\n        heroToken,\n        change.energy,\n        uint(IStatController.ATTRIBUTES.ENERGY)\n      );\n    }\n\n    // setup new level and restore life/mana\n    currentStats.life = uint32(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.LIFE)).toUint());\n    currentStats.mana = uint32(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.MANA)).toUint());\n\n    _changeChangeableStats(\n      s,\n      heroPackedId,\n      currentStats.level,\n      currentStats.experience,\n      currentStats.life,\n      currentStats.mana,\n      currentStats.lifeChances\n    );\n\n    emit IApplicationEvents.LevelUp(heroToken, heroTokenId, heroClass, change);\n\n    return currentStats.level;\n  }\n\n  /// @notice scb-1009: Update current values of Life and mana during reinforcement as following:\n  /// Reinforcement increases max value of life/mana on DELTA, current value of life/mana is increased on DELTA too\n  /// @param prevAttributes Hero attributes before reinforcement\n  function restoreLifeAndMana(\n    IStatController.MainState storage s,\n    IController c,\n    address heroToken,\n    uint heroTokenId,\n    int32[] memory prevAttributes\n  ) internal {\n    StatControllerLib.onlyHeroController(c);\n\n    IStatController.ChangeableStats memory currentStats = heroStats(s, heroToken, heroTokenId);\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n\n    // assume here that totalAttributes were already updated during reinforcement\n    // and so max values of life and mana were increased on delta1 and delta2\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\n\n    // now increase current values of life and mana on delta1 and delta2 too\n    currentStats.life += _getPositiveDelta(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.LIFE)), prevAttributes[uint(IStatController.ATTRIBUTES.LIFE)]);\n    currentStats.mana += _getPositiveDelta(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.MANA)), prevAttributes[uint(IStatController.ATTRIBUTES.MANA)]);\n\n    _changeChangeableStats(\n      s,\n      heroPackedId,\n      currentStats.level,\n      currentStats.experience,\n      currentStats.life,\n      currentStats.mana,\n      currentStats.lifeChances\n    );\n  }\n\n  function _getPositiveDelta(int32 a, int32 b) internal pure returns (uint32) {\n    return a < b\n      ? 0\n      : uint32(uint(int(a - b)));\n  }\n\n  function _addCoreToTotal(\n    IController c,\n    bytes32[] storage totalAttributes,\n    bytes32[] storage bonus,\n    bytes32[] storage bonusTmp,\n    IStatController.ChangeableStats memory stats,\n    address heroToken,\n    int32 changeValue,\n    uint attrIndex\n  ) internal {\n    if (changeValue != 0) {\n      (int32 newValue,) = totalAttributes.changeInt32(attrIndex, int32(uint32(changeValue)));\n      StatLib.updateCoreDependAttributes(c, totalAttributes, bonus, bonusTmp, stats, attrIndex, heroToken, newValue);\n    }\n  }\n\n  function setHeroCustomData(\n    IStatController.MainState storage s,\n    IController c,\n    address token,\n    uint tokenId,\n    bytes32 index,\n    uint value\n  ) internal {\n    StatControllerLib.onlyRegisteredContract(c);\n\n    if (index == KARMA_HASH && value == 0) {\n      revert IAppErrors.ErrorZeroKarmaNotAllowed();\n    }\n\n    s.heroCustomData[PackingLib.packNftId(token, tokenId)][index] = value;\n\n    emit IApplicationEvents.HeroCustomDataChanged(token, tokenId, index, value);\n  }\n\n  function setGlobalCustomData(\n    IStatController.MainState storage s,\n    IController c,\n    bytes32 index,\n    uint value\n  ) internal {\n    StatControllerLib.onlyRegisteredContract(c);\n\n    s.globalCustomData[index] = value;\n\n    emit IApplicationEvents.GlobalCustomDataChanged(index, value);\n  }\n  //endregion ------------------------ ACTIONS\n}\n"
    },
    "contracts/lib/StatLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IStatController.sol\";\nimport \"../interfaces/IHeroController.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"./CalcLib.sol\";\nimport \"./PackingLib.sol\";\n\nlibrary StatLib {\n  using PackingLib for bytes32[];\n  using PackingLib for bytes32;\n  using PackingLib for uint32[];\n  using PackingLib for int32[];\n  using CalcLib for int32;\n\n  //region --------------------------- Constants\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant STAT_LIB_VERSION = \"1.0.0\";\n  uint32 public constant MAX_LEVEL = 99;\n\n  uint public constant BASE_EXPERIENCE = 100_000;\n  uint public constant BIOME_LEVEL_STEP = 5;\n  uint internal constant _MAX_AMPLIFIER = 1e18;\n  uint private constant _PRECISION = 1e18;\n\n  /// @dev Assume MAX_BIOME * BIOME_LEVEL_STEP < MAX_LEVEL + 1, see dungeonTreasuryReward\n  uint public constant MAX_POSSIBLE_BIOME = 19;\n  //endregion --------------------------- Constants\n\n  //region --------------------------- Data types\n\n  struct BaseMultiplier {\n    uint minDamage;\n    uint maxDamage;\n    uint attackRating;\n    uint defense;\n    uint blockRating;\n    uint life;\n    uint mana;\n  }\n\n  struct LevelUp {\n    uint life;\n    uint mana;\n  }\n\n  struct InitialHero {\n    IStatController.CoreAttributes core;\n    BaseMultiplier multiplier;\n    LevelUp levelUp;\n    int32 baseLifeChances;\n  }\n\n  enum HeroClasses {\n    UNKNOWN,\n    THRALL,\n    SAVAGE,\n    MAGE,\n    ASSASSIN,\n    GHOST,\n    HAMMERGINA,\n    END_SLOT\n  }\n  //endregion --------------------------- Data types\n\n  //region --------------------------- BASE\n\n  // --- HERO 1 (Slave) ---\n\n  function initialHero1() internal pure returns (InitialHero memory) {\n    return InitialHero({\n      core: IStatController.CoreAttributes({\n      strength: 15,\n      dexterity: 15,\n      vitality: 30,\n      energy: 10\n    }),\n\n      multiplier: BaseMultiplier({\n      minDamage: 0.1e18,\n      maxDamage: 0.2e18,\n      attackRating: 2e18,\n      defense: 2e18,\n      blockRating: 0.1e18,\n      life: 1.5e18,\n      mana: 0.5e18\n    }),\n\n      levelUp: LevelUp({\n      life: 2e18,\n      mana: 1e18\n    }),\n\n      baseLifeChances: 5\n    });\n  }\n\n  // --- HERO 2 (Spata) ---\n\n  function initialHero2() internal pure returns (InitialHero memory) {\n    return InitialHero({\n      core: IStatController.CoreAttributes({\n      strength: 30,\n      dexterity: 5,\n      vitality: 25,\n      energy: 10\n    }),\n\n      multiplier: BaseMultiplier({\n      minDamage: 0.15e18,\n      maxDamage: 0.25e18,\n      attackRating: 2e18,\n      defense: 1e18,\n      blockRating: 0.08e18,\n      life: 1.3e18,\n      mana: 0.5e18\n    }),\n\n      levelUp: LevelUp({\n      life: 1.8e18,\n      mana: 1e18\n    }),\n\n      baseLifeChances: 5\n    });\n  }\n\n  // --- HERO 3 (Decidia) ---\n\n  function initialHero3() internal pure returns (InitialHero memory) {\n    return InitialHero({\n      core: IStatController.CoreAttributes({\n      strength: 10,\n      dexterity: 15,\n      vitality: 20,\n      energy: 25\n    }),\n\n      multiplier: BaseMultiplier({\n      minDamage: 0.1e18,\n      maxDamage: 0.2e18,\n      attackRating: 2e18,\n      defense: 1e18,\n      blockRating: 0.1e18,\n      life: 1e18,\n      mana: 2e18\n    }),\n\n      levelUp: LevelUp({\n      life: 1.3e18,\n      mana: 2e18\n    }),\n\n      baseLifeChances: 5\n    });\n  }\n\n  // --- HERO 4 (Innatus) ---\n\n  function initialHero4() internal pure returns (InitialHero memory) {\n    return InitialHero({\n      core: IStatController.CoreAttributes({\n      strength: 15,\n      dexterity: 25,\n      vitality: 15,\n      energy: 15\n    }),\n\n      multiplier: BaseMultiplier({\n      minDamage: 0.1e18,\n      maxDamage: 0.2e18,\n      attackRating: 4e18,\n      defense: 3e18,\n      blockRating: 0.2e18,\n      life: 1.2e18,\n      mana: 1e18\n    }),\n\n      levelUp: LevelUp({\n      life: 1.7e18,\n      mana: 1.5e18\n    }),\n\n      baseLifeChances: 5\n    });\n  }\n\n  // --- HERO 5 (F2P) ---\n\n  function initialHero5() internal pure returns (InitialHero memory) {\n    return InitialHero({\n      core: IStatController.CoreAttributes({\n      strength: 20,\n      dexterity: 20,\n      vitality: 20,\n      energy: 10\n    }),\n\n      multiplier: BaseMultiplier({\n      minDamage: 0.15e18,\n      maxDamage: 0.25e18,\n      attackRating: 3e18,\n      defense: 2.5e18,\n      blockRating: 0.15e18,\n      life: 1.5e18,\n      mana: 1.5e18\n    }),\n\n      levelUp: LevelUp({\n      life: 1.5e18,\n      mana: 1.5e18\n    }),\n\n      baseLifeChances: 1\n    });\n  }\n\n  // --- HERO 6 (F2P) HAMMERGINA ---\n\n  function initialHero6() internal pure returns (InitialHero memory) {\n    return InitialHero({\n      core: IStatController.CoreAttributes({\n      strength: 50,\n      dexterity: 30,\n      vitality: 50,\n      energy: 15\n    }),\n\n      multiplier: BaseMultiplier({\n      minDamage: 0.2e18,\n      maxDamage: 0.3e18,\n      attackRating: 5e18,\n      defense: 3e18,\n      blockRating: 0.15e18,\n      life: 2e18,\n      mana: 2e18\n    }),\n\n      levelUp: LevelUp({\n      life: 1.7e18,\n      mana: 1.5e18\n    }),\n\n      baseLifeChances: 1\n    });\n  }\n\n  // ------\n\n  function initialHero(uint heroClass) internal pure returns (InitialHero memory) {\n    if (heroClass == 1) {\n      return initialHero1();\n    } else if (heroClass == 2) {\n      return initialHero2();\n    } else if (heroClass == 3) {\n      return initialHero3();\n    } else if (heroClass == 4) {\n      return initialHero4();\n    } else if (heroClass == 5) {\n      return initialHero5();\n    } else if (heroClass == 6) {\n      return initialHero6();\n    } else {\n      revert IAppErrors.UnknownHeroClass(heroClass);\n    }\n  }\n  //endregion --------------------------- BASE\n\n  //region --------------------------- CALCULATIONS\n\n  function minDamage(int32 strength, uint heroClass) internal pure returns (int32) {\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.minDamage / _PRECISION));\n  }\n\n  function maxDamage(int32 strength, uint heroClass) internal pure returns (int32){\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.maxDamage / _PRECISION));\n  }\n\n  function attackRating(int32 dexterity, uint heroClass) internal pure returns (int32){\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.attackRating / _PRECISION));\n  }\n\n  function defense(int32 dexterity, uint heroClass) internal pure returns (int32){\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.defense / _PRECISION));\n  }\n\n  function blockRating(int32 dexterity, uint heroClass) internal pure returns (int32){\n    return int32(int(Math.min((dexterity.toUint() * initialHero(heroClass).multiplier.blockRating / _PRECISION), 75)));\n  }\n\n  function life(int32 vitality, uint heroClass, uint32 level) internal pure returns (int32){\n    return int32(int(\n      (vitality.toUint() * initialHero(heroClass).multiplier.life / _PRECISION)\n      + (uint(level) * initialHero(heroClass).levelUp.life / _PRECISION)\n    ));\n  }\n\n  function mana(int32 energy, uint heroClass, uint32 level) internal pure returns (int32){\n    return int32(int(\n      (energy.toUint() * initialHero(heroClass).multiplier.mana / _PRECISION)\n      + (uint(level) * initialHero(heroClass).levelUp.mana / _PRECISION)\n    ));\n  }\n\n  function lifeChances(uint heroClass, uint32 /*level*/) internal pure returns (int32){\n    return initialHero(heroClass).baseLifeChances;\n  }\n\n  function levelExperience(uint32 level) internal pure returns (uint32) {\n    if (level == 0 || level >= MAX_LEVEL) {\n      return 0;\n    }\n    return uint32(uint(level) * BASE_EXPERIENCE * (67e17 - CalcLib.log2((uint(MAX_LEVEL - level + 2)) * 1e18)) / 1e18);\n  }\n\n  function chanceToHit(\n    uint attackersAttackRating,\n    uint defendersDefenceRating,\n    uint attackersLevel,\n    uint defendersLevel,\n    uint arFactor\n  ) internal pure returns (uint) {\n    attackersAttackRating += attackersAttackRating * arFactor / 100;\n    uint x = Math.max(attackersAttackRating, 1);\n    uint y = Math.max(attackersAttackRating + defendersDefenceRating, 1);\n    uint z = attackersLevel;\n    uint k = defendersLevel / 2;\n    uint xy = x * 1e18 / y;\n    uint zk = z * 1e18 / (attackersLevel + k);\n    uint base = 2 * xy * zk / 1e18;\n    return Math.max(Math.min(base, 0.95e18), 0.2e18);\n  }\n\n  function experienceToLvl(uint experience, uint startFromLevel) internal pure returns (uint level) {\n    level = startFromLevel;\n    for (; level < MAX_LEVEL;) {\n      if (levelExperience(uint32(level)) >= experience) {\n        break;\n      }\n      unchecked{++level;}\n    }\n  }\n\n  function expPerMonster(uint32 monsterExp, uint monsterRarity, uint32 heroExp, uint32 heroCurrentLvl, uint monsterBiome) internal pure returns (uint32) {\n    uint heroLvl = experienceToLvl(uint(heroExp), uint(heroCurrentLvl));\n    uint heroBiome = heroLvl / StatLib.BIOME_LEVEL_STEP + 1;\n    uint base = uint(monsterExp) + uint(monsterExp) * monsterRarity / _MAX_AMPLIFIER;\n\n    // reduce exp if hero not in his biome\n    if (heroBiome > monsterBiome) {\n      base = base / (2 ** (heroBiome - monsterBiome));\n    }\n    return uint32(base);\n  }\n\n  /// @notice Allow to calculate delta param for {mintDropChance}\n  function mintDropChanceDelta(uint experience, uint startFromLevel, uint monsterBiome) internal pure returns (uint) {\n    uint heroBiome = StatLib.experienceToLvl(experience, startFromLevel) / StatLib.BIOME_LEVEL_STEP + 1;\n    return heroBiome > monsterBiome ? 2**(heroBiome - monsterBiome) : 0;\n  }\n\n  function initAttributes(\n    bytes32[] storage attributes,\n    uint heroClass,\n    uint32 level,\n    IStatController.CoreAttributes memory base\n  ) internal returns (uint32[] memory result) {\n\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.STRENGTH), base.strength);\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEXTERITY), base.dexterity);\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.VITALITY), base.vitality);\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ENERGY), base.energy);\n\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN), minDamage(base.strength, heroClass));\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX), maxDamage(base.strength, heroClass));\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING), attackRating(base.dexterity, heroClass));\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE), defense(base.dexterity, heroClass));\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING), blockRating(base.dexterity, heroClass));\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE), life(base.vitality, heroClass, level));\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA), mana(base.energy, heroClass, level));\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE_CHANCES), lifeChances(heroClass, level));\n\n    result = new uint32[](3);\n    result[0] = uint32(life(base.vitality, heroClass, level).toUint());\n    result[1] = uint32(mana(base.energy, heroClass, level).toUint());\n    result[2] = uint32(lifeChances(heroClass, uint32(level)).toUint());\n  }\n\n  function updateCoreDependAttributesInMemory(\n    int32[] memory attributes,\n    int32[] memory bonus,\n    uint heroClass,\n    uint32 level\n  ) internal pure returns (int32[] memory) {\n    int32 strength = attributes[uint(IStatController.ATTRIBUTES.STRENGTH)];\n    int32 dexterity = attributes[uint(IStatController.ATTRIBUTES.DEXTERITY)];\n    int32 vitality = attributes[uint(IStatController.ATTRIBUTES.VITALITY)];\n    int32 energy = attributes[uint(IStatController.ATTRIBUTES.ENERGY)];\n\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] = minDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)];\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] = maxDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)];\n    attributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] = attackRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.ATTACK_RATING)];\n    attributes[uint(IStatController.ATTRIBUTES.DEFENSE)] = defense(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DEFENSE)];\n    attributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] = blockRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.BLOCK_RATING)];\n    attributes[uint(IStatController.ATTRIBUTES.LIFE)] = life(vitality, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.LIFE)];\n    attributes[uint(IStatController.ATTRIBUTES.MANA)] = mana(energy, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.MANA)];\n    return attributes;\n  }\n\n  function updateCoreDependAttributes(\n    IController controller,\n    bytes32[] storage attributes,\n    bytes32[] storage bonusMain,\n    bytes32[] storage bonusExtra,\n    IStatController.ChangeableStats memory _heroStats,\n    uint index,\n    address heroToken,\n    int32 base\n  ) internal {\n    uint heroClass = IHeroController(controller.heroController()).heroClass(heroToken);\n    if (index == uint(IStatController.ATTRIBUTES.STRENGTH)) {\n\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN),\n        StatLib.minDamage(base, heroClass)\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\n      );\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX),\n        StatLib.maxDamage(base, heroClass)\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\n      );\n    } else if (index == uint(IStatController.ATTRIBUTES.DEXTERITY)) {\n\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING),\n        StatLib.attackRating(base, heroClass)\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\n      );\n\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE),\n        StatLib.defense(base, heroClass)\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\n      );\n\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING),\n        StatLib.blockRating(base, heroClass)\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\n      );\n    } else if (index == uint(IStatController.ATTRIBUTES.VITALITY)) {\n\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE),\n        StatLib.life(base, heroClass, _heroStats.level)\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\n      );\n    } else if (index == uint(IStatController.ATTRIBUTES.ENERGY)) {\n\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA),\n        StatLib.mana(base, heroClass, _heroStats.level)\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.MANA))\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.MANA))\n      );\n    }\n  }\n\n  function attributesAdd(int32[] memory base, int32[] memory add) internal pure returns (int32[] memory) {\n    unchecked{\n      for (uint i; i < base.length; ++i) {\n        base[i] += add[i];\n      }\n    }\n    return base;\n  }\n\n// Currently this function is not used\n//  function attributesRemove(int32[] memory base, int32[] memory remove) internal pure returns (int32[] memory) {\n//    unchecked{\n//      for (uint i; i < base.length; ++i) {\n//        base[i] = CalcLib.minusWithMinFloorI32(base[i], remove[i]);\n//      }\n//    }\n//    return base;\n//  }\n\n  function packChangeableStats(IStatController.ChangeableStats memory stats) internal pure returns (bytes32) {\n    uint32[] memory cData = new uint32[](5);\n    cData[0] = stats.level;\n    cData[1] = stats.experience;\n    cData[2] = stats.life;\n    cData[3] = stats.mana;\n    cData[4] = stats.lifeChances;\n\n    return cData.packUint32Array();\n  }\n\n  function unpackChangeableStats(bytes32 data) internal pure returns (IStatController.ChangeableStats memory result) {\n    uint32[] memory cData = data.unpackUint32Array();\n    return IStatController.ChangeableStats({\n      level: cData[0],\n      experience: cData[1],\n      life: cData[2],\n      mana: cData[3],\n      lifeChances: cData[4]\n    });\n  }\n\n  function bytesToFullAttributesArray(bytes32[] memory attributes) internal pure returns (int32[] memory result) {\n    (int32[] memory values, uint8[] memory ids) = attributes.toInt32ArrayWithIds();\n    return valuesToFullAttributesArray(values, ids);\n  }\n\n  function valuesToFullAttributesArray(int32[] memory values, uint8[] memory ids) internal pure returns (int32[] memory result) {\n    result = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\n    for (uint i; i < values.length; ++i) {\n      int32 value = values[i];\n      if (value != 0) {\n        result[ids[i]] = value;\n      }\n    }\n  }\n  //endregion --------------------------- CALCULATIONS\n\n}\n"
    },
    "contracts/lib/StoryControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\nimport \"../proxy/Controllable.sol\";\nimport \"../interfaces/IStoryController.sol\";\nimport \"../interfaces/IStatController.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IGOC.sol\";\nimport \"../interfaces/IHeroController.sol\";\nimport \"../lib/StoryLib.sol\";\nimport \"../lib/PackingLib.sol\";\nimport \"../lib/StorySetupLib.sol\";\n\n\nlibrary StoryControllerLib {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using CalcLib for uint;\n  using PackingLib for bytes32;\n  using PackingLib for uint16;\n  using PackingLib for uint8;\n  using PackingLib for address;\n  using PackingLib for uint32[];\n  using PackingLib for uint32;\n  using PackingLib for uint64;\n  using PackingLib for int32[];\n  using PackingLib for int32;\n\n\n  //region ------------------------ CONSTANTS\n  /// @dev keccak256(abi.encode(uint256(keccak256(\"story.controller.main\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0x1fbca2ab9841348cca3f2687c48325e9989a76ad929b9970d1c11e233677cf00;\n  //endregion ------------------------ CONSTANTS\n\n\n  //region ------------------------ Restrictions\n  function onlyDeployer(IController controller) internal view {\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\n  }\n  //endregion ------------------------ Restrictions\n\n  //region ------------------------ VIEWS\n\n\n  function _S() internal pure returns (IStoryController.MainState storage s) {\n    assembly {\n      s.slot := MAIN_STORAGE_LOCATION\n    }\n    return s;\n  }\n\n  function idToStory(uint16 storyId) internal view returns (uint32) {\n    return _S().idToStory[storyId];\n  }\n\n  function storyBuildHash(uint16 storyId) internal view returns (uint) {\n    return _S().storyBuildHash[storyId];\n  }\n\n  function heroPage(address hero, uint80 heroId, uint16 storyId) internal view returns (uint16 pageId) {\n    (pageId,) = _S().heroState[hero.packStoryHeroStateId(heroId, storyId)].unpackStoryHeroState();\n  }\n\n  function storyIds(uint32 objectId) internal view returns (uint16) {\n    return _S().storyIds[objectId];\n  }\n\n  function registeredStories(uint32 objectId) internal view returns (bool) {\n    return _S().registeredStories[objectId];\n  }\n\n  function allStoryPagesLength(uint16 storyId) internal view returns (uint) {\n    return _S().allStoryPages[storyId].length();\n  }\n\n  function allStoryPages(uint16 storyId, uint index) internal view returns (uint) {\n    return _S().allStoryPages[storyId].at(index);\n  }\n\n  function allStoryAnswersLength(uint16 storyId) internal view returns (uint) {\n    return _S().allStoryAnswers[storyId].length();\n  }\n\n  function allStoryAnswers(uint16 storyId, uint index) internal view returns (bytes32) {\n    return _S().allStoryAnswers[storyId].at(index);\n  }\n\n  /// @notice Get list of answers for the current page stored in the hero state\n  /// @return List of answers for the (page, heroClass). If the list is empty return default answers for (page, 0)\n  function currentHeroAnswers(IController controller, uint16 storyId, address hero, uint80 heroId) internal view returns (\n    bytes32[] memory\n  ) {\n    IHeroController hc = IHeroController(controller.heroController());\n\n    (uint16 pageId,) = _S().heroState[hero.packStoryHeroStateId(heroId, storyId)].unpackStoryHeroState();\n    bytes32[] memory heroAnswers = _S().answers[storyId.packStoryPageId(pageId, hc.heroClass(hero))];\n\n    if (heroAnswers.length == 0) {\n      heroAnswers = _S().answers[storyId.packStoryPageId(pageId, 0)];\n    }\n\n    if (heroAnswers.length != 0) {\n      // shuffle answers using Fisher–Yates shuffle algorithm\n      for (uint i; i < heroAnswers.length - 1; i++) {\n        uint randomIndex = CalcLib.pseudoRandomInRange(i, heroAnswers.length - 1);\n        (heroAnswers[randomIndex], heroAnswers[i]) = (heroAnswers[i], heroAnswers[randomIndex]);\n      }\n    }\n\n    return heroAnswers;\n  }\n\n  function isStoryAvailableForHero(IController controller, uint32 objectId, address heroToken, uint heroTokenId) internal view returns (bool) {\n    return StoryLib.isStoryAvailableForHero(_S(), _S().storyIds[objectId], heroToken, heroTokenId, controller.statController());\n  }\n\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ SETTERS\n\n  function setAllStoryFields(IController controller, IStoryController.StoryMetaInfo calldata meta) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setAllStoryFields(_S(), meta);\n  }\n\n  function setBurnItemsMeta(\n    IController controller,\n    uint16 storyId,\n    IStoryController.AnswerBurnRandomItemMeta calldata meta\n  ) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setBurnItemsMeta(_S(), storyId, meta);\n  }\n\n  function setNextObjRewriteMeta(IController controller, uint16 storyId, IStoryController.NextObjRewriteMeta calldata meta) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setNextObjRewriteMeta(_S(), storyId, meta);\n  }\n\n  function setAnswersMeta(\n    IController controller,\n    uint16 storyId,\n    uint16[] calldata answerPageIds,\n    uint8[] calldata answerHeroClasses,\n    uint16[] calldata answerIds\n  ) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setAnswersMeta(_S(), storyId, answerPageIds, answerHeroClasses, answerIds);\n  }\n\n  function setAnswerNextPageMeta(IController controller, uint16 storyId, IStoryController.AnswerNextPageMeta calldata meta) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setAnswerNextPageMeta(_S(), storyId, meta);\n  }\n\n  function setAnswerAttributeRequirements(IController controller, uint16 storyId, IStoryController.AnswerAttributeRequirementsMeta calldata meta) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setAnswerAttributeRequirements(_S(), storyId, meta);\n  }\n\n  function setAnswerItemRequirements(IController controller, uint16 storyId, IStoryController.AnswerItemRequirementsMeta calldata meta) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setAnswerItemRequirements(_S(), storyId, meta);\n  }\n\n  function setAnswerTokenRequirementsMeta(IController controller, uint16 storyId, IStoryController.AnswerTokenRequirementsMeta calldata meta) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setAnswerTokenRequirementsMeta(_S(), storyId, meta);\n  }\n\n  function setAnswerAttributes(IController controller, uint16 storyId, IStoryController.AnswerAttributesMeta calldata meta) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setAnswerAttributes(_S(), storyId, meta);\n  }\n\n  function setAnswerHeroCustomDataRequirementMeta(IController controller, uint16 storyId, IStoryController.AnswerCustomDataMeta calldata meta) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setAnswerHeroCustomDataRequirementMeta(_S(), storyId, meta);\n  }\n\n  function setAnswerGlobalCustomDataRequirementMeta(IController controller, uint16 storyId, IStoryController.AnswerCustomDataMeta calldata meta) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setAnswerGlobalCustomDataRequirementMeta(_S(), storyId, meta);\n\n  }\n\n  function setSuccessInfo(IController controller, uint16 storyId, IStoryController.AnswerResultMeta calldata meta) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setSuccessInfo(_S(), storyId, meta);\n  }\n\n  function setFailInfo(IController controller, uint16 storyId, IStoryController.AnswerResultMeta calldata meta) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setFailInfo(_S(), storyId, meta);\n  }\n\n  function setCustomDataResult(\n    IController controller,\n    uint16 storyId,\n    IStoryController.AnswerCustomDataResultMeta calldata meta,\n    IStoryController.CustomDataResult type_\n  ) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setCustomDataResult(_S(), storyId, meta, type_);\n  }\n\n  function setStoryCustomDataRequirements(\n    IController controller,\n    uint16 storyId,\n    bytes32[] calldata requiredCustomDataIndex,\n    uint64[] calldata requiredCustomDataMinValue,\n    uint64[] calldata requiredCustomDataMaxValue,\n    bool[] calldata requiredCustomDataIsHero,\n    uint minLevel\n  ) internal {\n    onlyDeployer(controller);\n    StorySetupLib.setStoryCustomDataRequirements(_S(), storyId, requiredCustomDataIndex, requiredCustomDataMinValue, requiredCustomDataMaxValue, requiredCustomDataIsHero, minLevel);\n  }\n\n  function finalizeStoryRegistration(IController controller, uint16 storyId, uint32 objectId, uint buildHash) internal {\n    onlyDeployer(controller);\n    StorySetupLib.finalizeStoryRegistration(_S(), storyId, objectId, buildHash);\n  }\n  //endregion ------------------------ SETTERS\n\n  //region ------------------------ CHANGE META\n\n  function removeStory(IController controller, uint32 objectId) internal {\n    onlyDeployer(controller);\n    StorySetupLib.removeStory(_S(), objectId);\n  }\n\n  function removeStoryPagesMeta(IController controller, uint16 storyId, uint maxIterations) internal {\n    onlyDeployer(controller);\n    StorySetupLib.removeStoryPagesMeta(_S(), storyId, maxIterations);\n  }\n\n  function removeStoryAnswersMeta(IController controller, uint16 storyId, uint maxIterations) internal {\n    onlyDeployer(controller);\n    StorySetupLib.removeStoryAnswersMeta(_S(), storyId, maxIterations);\n  }\n  //endregion ------------------------ CHANGE META\n\n  //region ------------------------ MAIN LOGIC\n\n  function storyAction(\n    IController controller,\n    address sender,\n    uint64 dungeonId,\n    uint32 objectId,\n    uint stageId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 biome,\n    uint iteration,\n    bytes memory data\n  ) internal returns (IGOC.ActionResult memory result) {\n    if (controller.gameObjectController() != msg.sender) revert IAppErrors.ErrorNotObjectController(msg.sender);\n\n    IStatController statController = IStatController(controller.statController());\n    IStoryController.StoryActionContext memory context = IStoryController.StoryActionContext({\n      sender: sender,\n      dungeonId: dungeonId,\n      objectId: objectId,\n      storyId: _S().storyIds[objectId],\n      stageId: stageId,\n      controller: controller,\n      statController: statController,\n      heroToken: heroToken,\n      heroTokenId: uint80(heroTokenId),\n      heroClass: 0,\n      storyIdFromAnswerHash: 0,\n      pageIdFromAnswerHash: 0,\n      heroClassFromAnswerHash: 0,\n      answerNumber: 0,\n      answerIdHash: _decodeAnswerId(data),\n      pageId: 0,\n      heroLastActionTS: 0,\n      answerAttributes: bytes32(0),\n      heroStats: statController.heroStats(heroToken, heroTokenId),\n      biome: biome,\n      oracle: IOracle(controller.oracle()),\n      iteration: iteration,\n      heroController: IHeroController(controller.heroController()),\n      itemController: IItemController(controller.itemController())\n    });\n\n    if (context.storyId == 0) revert IAppErrors.ZeroStoryIdStoryAction();\n\n    context.heroClass = context.heroController.heroClass(heroToken);\n    context.answerAttributes = _S().answerAttributes[context.answerIdHash];\n\n    (context.pageId, context.heroLastActionTS) = _S().heroState[heroToken.packStoryHeroStateId(uint80(heroTokenId), context.storyId)].unpackStoryHeroState();\n\n    (context.storyIdFromAnswerHash,\n      context.pageIdFromAnswerHash,\n      context.heroClassFromAnswerHash,\n      context.answerNumber\n    ) = context.answerIdHash.unpackStoryAnswerId();\n\n    result = _handleAnswer(context, currentHeroAnswers(controller, context.storyId, heroToken, uint80(heroTokenId)));\n  }\n\n  /// @param heroAnswers Full list of possible answers (to be able to check that the answer belongs to the list)\n  function _handleAnswer(IStoryController.StoryActionContext memory context, bytes32[] memory heroAnswers) internal returns (\n    IGOC.ActionResult memory results\n  ) {\n    IStoryController.MainState storage s = _S();\n\n    if (heroAnswers.length == 0) {\n      results.objectId = context.objectId;\n      results.heroTokenId = context.heroTokenId;\n      results.heroToken = context.heroToken;\n      results.completed = true;\n    } else {\n      // check ids only if answer exists, for empty answers we can accept empty answer hash from user\n      if (context.storyId != context.storyIdFromAnswerHash) revert IAppErrors.AnswerStoryIdMismatch(context.storyId, context.storyIdFromAnswerHash);\n      if (context.pageId != context.pageIdFromAnswerHash) revert IAppErrors.AnswerPageIdMismatch(context.pageId, context.pageIdFromAnswerHash);\n\n      // ensure that the given answer belongs to the list of the available answers\n      StoryLib.checkAnswerIndexValid(heroAnswers, context.answerIdHash);\n      (,, bool finalAnswer) = context.answerAttributes.unpackStorySimpleRequirement();\n\n      // check answer requirements, burn items, transfer tokens and so on\n      IStoryController.AnswerResultId answerResult = StoryLib.checkAnswer(context, s);\n\n      // break randomly selected items\n      StoryLib.breakItem(context, s);\n\n      // handle answer - refresh states\n      uint16 nextPage;\n      uint16[] memory nextPages;\n      (results, nextPage, nextPages) = StoryLib.handleAnswer(answerResult, s, context);\n\n      if (finalAnswer || nextPages.length == 0) {\n        results.completed = true;\n      } else {\n        s.heroState[context.heroToken.packStoryHeroStateId(context.heroTokenId, context.storyId)] = nextPage.packStoryHeroState(uint40(block.timestamp));\n      }\n    }\n\n    if (results.completed) {\n      results.rewriteNextObject = StoryLib.finishStory(context, s);\n    }\n\n    return results;\n  }\n  //endregion ------------------------ MAIN LOGIC\n\n  //region ------------------------ Utils\n  function _decodeAnswerId(bytes memory data) internal pure returns (bytes32 answerId) {\n    (answerId) = abi.decode(data, (bytes32));\n  }\n  //endregion ------------------------ Utils\n\n}\n"
    },
    "contracts/lib/StoryLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IStoryController.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IGOC.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC721Enumerable.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../lib/CalcLib.sol\";\nimport \"../lib/PackingLib.sol\";\nimport \"../lib/ItemLib.sol\";\nimport \"../lib/StringLib.sol\";\n\nlibrary StoryLib {\n  using CalcLib for uint;\n  using PackingLib for address;\n  using PackingLib for uint16;\n  using PackingLib for bytes32;\n  using PackingLib for bytes32[];\n\n  //region ------------------------ Constants\n  /// @notice Max number of items that can be minted per iteration in the stories\n  uint internal constant MAX_MINTED_ITEMS_PER_ITERATION = 3;\n  //endregion ------------------------ Constants\n\n  //region ------------------------ Story logic\n\n  /// @notice Make action, increment STORY_XXX hero custom data if the dungeon is completed / hero is killed\n  function action(IGOC.ActionContext memory ctx, uint16 storyId) internal returns (IGOC.ActionResult memory result) {\n    if (storyId == 0) revert IAppErrors.ZeroStoryIdAction();\n\n    result = IStoryController(ctx.controller.storyController()).storyAction(\n      ctx.sender,\n      ctx.dungeonId,\n      ctx.objectId,\n      ctx.stageId,\n      ctx.heroToken,\n      ctx.heroTokenId,\n      ctx.biome,\n      ctx.iteration,\n      ctx.data\n    );\n\n    if (result.completed || result.kill) {\n      IStatController statController = IStatController(ctx.controller.statController());\n      bytes32 index = _getStoryIndex(storyId);\n      uint curValue = statController.heroCustomData(ctx.heroToken, ctx.heroTokenId, index);\n      statController.setHeroCustomData(ctx.heroToken, ctx.heroTokenId, index, curValue + 1);\n    }\n  }\n\n  /// @notice Check if the story is available for the hero\n  /// The story is available if hero level fits to requirements\n  /// and if the hero/global custom data requirements are met (current value is inside of [min, max])\n  function isStoryAvailableForHero(\n    IStoryController.MainState storage s,\n    uint16 storyId,\n    address heroToken,\n    uint heroTokenId,\n    address statController\n  ) internal view returns (bool) {\n    uint reqLvl = s.storyRequiredLevel[storyId];\n    if (reqLvl != 0 && IStatController(statController).heroStats(heroToken, heroTokenId).level < reqLvl) {\n      return false;\n    }\n\n    IStoryController.CustomDataRequirementRangePacked[] storage allData = s.storyRequiredHeroData[storyId];\n    uint len = allData.length;\n    for (uint i; i < len; ++i) {\n      IStoryController.CustomDataRequirementRangePacked memory data = allData[i];\n\n      if (data.index == bytes32(0)) continue;\n\n      (uint64 min, uint64 max, bool isHeroData) = data.data.unpackCustomDataRequirements();\n\n      uint value = isHeroData\n        ? IStatController(statController).heroCustomData(heroToken, heroTokenId, data.index)\n        : IStatController(statController).globalCustomData(data.index);\n\n      if (value < uint(min) || value > uint(max)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /// @notice Update bonus attributes, refresh hero states, initialize and return results\n  /// @param mintItemsData Source for _mintRandomItems, random item (max 1, probably 0) is selected and put to results\n  /// @param mintItems_ Function _mintRandomItems is passed here. Parameter is required to make unit tests.\n  function handleResult(\n    IStoryController.StoryActionContext memory context,\n    bytes32[] memory attributesChanges,\n    bytes32 statsChanges,\n    bytes32[] memory mintItemsData,\n    function (IStoryController.StoryActionContext memory, bytes32[] memory) internal returns (address[] memory) mintItems_\n  ) internal returns (IGOC.ActionResult memory result) {\n    result.heroToken = context.heroToken;\n    result.heroTokenId = context.heroTokenId;\n    result.objectId = context.objectId;\n\n    int32[] memory attributes = _generateAttributes(attributesChanges);\n\n    if (attributes.length != 0) {\n      context.statController.changeBonusAttributes(IStatController.ChangeAttributesInfo({\n        heroToken: context.heroToken,\n        heroTokenId: context.heroTokenId,\n        changeAttributes: attributes,\n        add: true,\n        temporally: true\n      }));\n      // changeBonusAttributes can change life and mana, so we need to refresh hero stats. It's safer to do it always\n      context.heroStats = context.statController.heroStats(context.heroToken, context.heroTokenId);\n      emit IApplicationEvents.StoryChangeAttributes(\n        context.objectId,\n        context.heroToken,\n        context.heroTokenId,\n        context.dungeonId,\n        context.storyId,\n        context.stageId,\n        context.iteration,\n        attributes\n      );\n    }\n\n    IStoryController.StatsChange memory statsToChange = _generateStats(statsChanges);\n\n    if (statsToChange.heal != 0) {\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.LIFE));\n      result.heal = max * statsToChange.heal / 100;\n    }\n\n    if (statsToChange.manaRegen != 0) {\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.MANA));\n      result.manaRegen = max * statsToChange.manaRegen / 100;\n    }\n\n    if (statsToChange.damage != 0) {\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.LIFE));\n      result.damage = max * statsToChange.damage / 100;\n\n      if (int32(context.heroStats.life) <= result.damage) {\n        result.kill = true;\n      }\n    }\n\n    if (statsToChange.manaConsumed != 0) {\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.MANA));\n      result.manaConsumed = CalcLib.minI32(max * statsToChange.manaConsumed / 100, int32(context.heroStats.mana));\n    }\n\n    result.experience = statsToChange.experience;\n    result.lifeChancesRecovered = statsToChange.lifeChancesRecovered;\n\n    if (mintItemsData.length != 0) {\n      result.mintItems = mintItems_(context, mintItemsData);\n    }\n    return result;\n  }\n\n  /// @notice Put data from {heroCustomDatas} and {globalCustomDatas} to {statController}\n  function handleCustomDataResult(\n    IStoryController.StoryActionContext memory context,\n    bytes32[] memory heroCustomDatas,\n    bytes32[] memory globalCustomDatas\n  ) internal {\n    uint len = heroCustomDatas.length;\n    for (uint i; i < len; ++i) {\n\n      (bytes32 customDataIndex, int16 value) = heroCustomDatas[i].unpackCustomDataChange();\n\n      if (customDataIndex != 0) {\n        uint curValue = context.statController.heroCustomData(context.heroToken, context.heroTokenId, customDataIndex);\n        context.statController.setHeroCustomData(\n          context.heroToken,\n          context.heroTokenId,\n          customDataIndex,\n          value == 0\n            ? 0\n            : value > 0\n              ? curValue + uint(int(value))\n              : curValue.minusWithZeroFloor(uint(int(- value)))\n        );\n      }\n    }\n\n    len = globalCustomDatas.length;\n    for (uint i; i < len; ++i) {\n\n      (bytes32 customDataIndex, int16 value) = globalCustomDatas[i].unpackCustomDataChange();\n\n      if (customDataIndex != 0) {\n        uint curValue = context.statController.globalCustomData(customDataIndex);\n        context.statController.setGlobalCustomData(\n          customDataIndex,\n          value == 0\n            ? 0\n            : value > 0\n              ? curValue + uint(int(value))\n              : curValue.minusWithZeroFloor(uint(int(- value)))\n        );\n      }\n    }\n  }\n\n  /// @notice SIP-003: Randomly select one or several items, break them and increase their fragility by 1%.\n  function breakItem(IStoryController.StoryActionContext memory context, IStoryController.MainState storage s) internal {\n\n    bytes32[] storage breakInfos = s.burnItem[context.answerIdHash];\n    uint length = breakInfos.length;\n\n    for (uint i; i < length; ++i) {\n      (uint8 slot, uint64 chance, bool stopIfBroken) = breakInfos[i].unpackBreakInfo();\n\n      if (chance != 0 && context.oracle.getRandomNumberInRange(0, 100, 0) <= uint(chance)) {\n        uint8[] memory busySlots = context.statController.heroItemSlots(context.heroToken, context.heroTokenId);\n\n        uint lenBusySlots = busySlots.length;\n        if (lenBusySlots != 0) {\n          uint busySlotIndex;\n          bool itemExist;\n          if (slot == 0) {\n            busySlotIndex = context.oracle.getRandomNumberInRange(0, lenBusySlots - 1, 0);\n            itemExist = true;\n          } else {\n            for (uint j; j < lenBusySlots; ++j) {\n              if (busySlots[j] == slot) {\n                busySlotIndex = j;\n                itemExist = true;\n                break;\n              }\n            }\n          }\n\n          if (itemExist) {\n            // SIP-003: don't burn item but break it\n            _breakItemInHeroSlot(context, busySlots[busySlotIndex]);\n            if (stopIfBroken) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /// @notice Update internal hero state, generate {result}\n  /// @param context We update some fields in place, so memory, not calldata here\n  function handleAnswer(\n    IStoryController.AnswerResultId answerResultId,\n    IStoryController.MainState storage s,\n    IStoryController.StoryActionContext memory context\n  ) external returns (\n    IGOC.ActionResult memory result,\n    uint16 nextPage,\n    uint16[] memory nextPages\n  ) {\n    return _handleAnswer(answerResultId, s, context, _mintRandomItems);\n  }\n\n  /// @notice Update internal hero state, generate {result}\n  /// @param context We update some fields in place, so memory, not calldata here\n  /// @param mintItems_ Function _mintRandomItems is passed here. Parameter is required to make unit tests.\n  function _handleAnswer(\n    IStoryController.AnswerResultId answerResultId,\n    IStoryController.MainState storage s,\n    IStoryController.StoryActionContext memory context,\n    function (IStoryController.StoryActionContext memory, bytes32[] memory) internal returns (address[] memory) mintItems_\n  ) internal returns (\n    IGOC.ActionResult memory result,\n    uint16 nextPage,\n    uint16[] memory nextPages\n  ) {\n    result.objectId = context.objectId;\n    result.heroTokenId = context.heroTokenId;\n    result.heroToken = context.heroToken;\n\n    nextPages = s.nextPageIds[context.storyId.packStoryNextPagesId(\n      context.pageId,\n      context.heroClassFromAnswerHash,\n      context.answerNumber,\n      uint8(answerResultId)\n    )];\n    nextPage = _getNextPage(context.oracle, nextPages);\n\n    // number of items that can be minted inside single iteration in the story is limited\n    // if the max is reached the minting is silently skipped\n    // we assume here, that mintItems_ mints only 1 item so it's not necessary to limit number of minted items inside mintItems_\n    uint mintedInIteration = _getMintedInIteration(s, context);\n\n    if (answerResultId == IStoryController.AnswerResultId.SUCCESS) {\n      result = handleResult(\n        context,\n        s.successInfoAttributes[context.answerIdHash],\n        s.successInfoStats[context.answerIdHash],\n        mintedInIteration < MAX_MINTED_ITEMS_PER_ITERATION ? s.successInfoMintItems[context.answerIdHash] : new bytes32[](0),\n        mintItems_\n      );\n\n      handleCustomDataResult(\n        context,\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\n          context.pageId,\n          context.heroClassFromAnswerHash,\n          context.answerNumber,\n          uint8(IStoryController.CustomDataResult.HERO_SUCCESS)\n        )],\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\n          context.pageId,\n          context.heroClassFromAnswerHash,\n          context.answerNumber,\n          uint8(IStoryController.CustomDataResult.GLOBAL_SUCCESS)\n        )]\n      );\n    } else {\n      result = handleResult(\n        context,\n        s.failInfoAttributes[context.answerIdHash],\n        s.failInfoStats[context.answerIdHash],\n        mintedInIteration < MAX_MINTED_ITEMS_PER_ITERATION ? s.failInfoMintItems[context.answerIdHash] : new bytes32[](0),\n        mintItems_\n      );\n\n      handleCustomDataResult(\n        context,\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\n          context.pageId,\n          context.heroClassFromAnswerHash,\n          context.answerNumber,\n          uint8(IStoryController.CustomDataResult.HERO_FAIL)\n        )],\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\n          context.pageId,\n          context.heroClassFromAnswerHash,\n          context.answerNumber,\n          uint8(IStoryController.CustomDataResult.GLOBAL_FAIL)\n        )]\n      );\n    }\n\n    if (result.mintItems.length != 0) {\n      _setMintedInIteration(s, context, mintedInIteration + result.mintItems.length);\n    }\n  }\n\n  /// @notice Check if the user has already minted an item within the current iteration of the story.\n  /// if the item is already minted any additional minting should be skipped without revert\n  function _getMintedInIteration(IStoryController.MainState storage s, IStoryController.StoryActionContext memory context)\n  internal view returns (uint countMintedItems) {\n    return s.mintedInIteration[context.heroToken.packStoryHeroStateId(context.heroTokenId, context.storyId)][context.iteration];\n  }\n\n  /// @notice Mark that the user has already minted an item within the current iteration of the story\n  /// Only minting of the single item is allowed per iteration\n  function _setMintedInIteration(\n    IStoryController.MainState storage s,\n    IStoryController.StoryActionContext memory context,\n    uint newCountMintedItems\n  ) internal {\n    s.mintedInIteration[context.heroToken.packStoryHeroStateId(context.heroTokenId, context.storyId)][context.iteration] = newCountMintedItems;\n  }\n\n\n  /// @notice Revert if {heroAnswers} doesn't contain {answerIdHash}\n  function checkAnswerIndexValid(bytes32[] memory heroAnswers, bytes32 answerIdHash) internal pure {\n    uint len = heroAnswers.length;\n    for (uint i; i < len; ++i) {\n      if (heroAnswers[i] == answerIdHash) return;\n    }\n    revert IAppErrors.NotAnswer();\n  }\n\n  /// @notice Clear heroState for the current story\n  /// @return nextObjs Default nextObjectsRewrite for the current page (values for 0 hero class)\n  function finishStory(IStoryController.StoryActionContext memory ctx, IStoryController.MainState storage s) internal returns (\n    uint32[] memory nextObjs\n  ) {\n    delete s.heroState[ctx.heroToken.packStoryHeroStateId(ctx.heroTokenId, ctx.storyId)];\n    // It's not necessary to clear mintedInIteration because for each hero each object has a sequence of iterations\n    // that is not reset on changing dungeons\n\n    return s.nextObjectsRewrite[ctx.storyId.packStoryPageId(ctx.pageId, 0)];\n  }\n\n  //endregion ------------------------ Story logic\n\n  //region ------------------------ Internal utils for story logic\n\n  /// @dev This function is made separate to simplify unit testing\n  function _mintRandomItems(IStoryController.StoryActionContext memory context, bytes32[] memory mintItemsData) internal returns (\n    address[] memory\n  ) {\n    uint len = mintItemsData.length;\n    address[] memory mintItems = new address[](len);\n    uint32[] memory mintItemsChances = new uint32[](len);\n    for (uint i; i < len; ++i) {\n      (mintItems[i], mintItemsChances[i]) = mintItemsData[i].unpackItemMintInfo();\n    }\n\n    return ItemLib.mintRandomItems(ItemLib.MintItemInfo({\n      mintItems: mintItems,\n      mintItemsChances: mintItemsChances,\n      amplifier: 0,\n      seed: 0,\n      oracle: context.oracle,\n      magicFind: 0,\n      destroyItems: 0,\n      maxItems: 1, // MINT ONLY 1 ITEM!\n      mintDropChanceDelta: StatLib.mintDropChanceDelta(context.heroStats.experience, uint8(context.heroStats.level), context.biome)\n    }));\n  }\n\n  /// @param attributesChanges Values+ids packed using toBytes32ArrayWithIds\n  function _generateAttributes(bytes32[] memory attributesChanges) internal pure returns (int32[] memory attributes) {\n    if (attributesChanges.length != 0) {\n      (int32[] memory values, uint8[] memory ids) = attributesChanges.toInt32ArrayWithIds();\n      uint len = ids.length;\n      if (len != 0) {\n        attributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\n        for (uint i; i < len; ++i) {\n          int32 value = values[i];\n          attributes[ids[i]] = value;\n        }\n      }\n    }\n\n    return attributes;\n  }\n\n  function _generateStats(bytes32 statsChanges) internal pure returns (IStoryController.StatsChange memory change) {\n    (\n      change.experience,\n      change.heal,\n      change.manaRegen,\n      change.lifeChancesRecovered,\n      change.damage,\n      change.manaConsumed\n    ) = statsChanges.unpackStatsChange();\n\n    return change;\n  }\n\n  /// @notice Break the item from the given {slot} (i.e. reduce item's durability to 0) and take it off\n  /// Broken item is taken off also.\n  function _breakItemInHeroSlot(IStoryController.StoryActionContext memory ctx, uint8 slot) internal {\n    (address itemAdr, uint itemId) = ctx.statController.heroItemSlot(ctx.heroToken, uint64(ctx.heroTokenId), slot).unpackNftId();\n\n    // take off the broken item and mark it as broken\n    ctx.itemController.takeOffDirectly(itemAdr, itemId, ctx.heroToken, ctx.heroTokenId, slot, ctx.sender, true);\n\n    // add 1% of fragility\n    ctx.itemController.incBrokenItemFragility(itemAdr, itemId);\n\n    emit IApplicationEvents.ItemBroken(\n      ctx.heroToken,\n      ctx.heroTokenId,\n      ctx.dungeonId,\n      ctx.objectId,\n      itemAdr,\n      itemId,\n      ctx.stageId,\n      ctx.iteration\n    );\n  }\n\n  function _getNextPage(IOracle oracle, uint16[] memory pages) internal returns (uint16) {\n    if (pages.length == 0) {\n      return 0;\n    }\n    if (pages.length == 1) {\n      return pages[0];\n    }\n    return pages[oracle.getRandomNumberInRange(0, pages.length - 1, 0)];\n  }\n\n  function _getStoryIndex(uint16 storyId) internal pure returns (bytes32) {\n    return bytes32(abi.encodePacked(\"STORY_\", StringLib._toString(storyId)));\n  }\n  //endregion ------------------------ Internal utils for story logic\n\n  //region ------------------------ Check answers\n\n  function checkAnswer(\n    IStoryController.StoryActionContext memory context,\n    IStoryController.MainState storage s\n  ) external returns (IStoryController.AnswerResultId result) {\n    result = checkAnswerAttributes(context, context.answerIdHash, s);\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\n      result = checkAnswerItems(context, context.answerIdHash, s);\n    }\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\n      result = checkAnswerTokens(context, context.answerIdHash, s);\n    }\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\n      result = checkAnswerDelay(context);\n    }\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\n      result = checkAnswerHeroCustomData(context, context.answerIdHash, s);\n    }\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\n      result = checkAnswerGlobalCustomData(context, context.answerIdHash, s);\n    }\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\n      result = checkAnswerRandom(context);\n    }\n  }\n\n  /// @notice Check if hero attribute values meet attribute requirements for the given answer\n  function checkAnswerAttributes(\n    IStoryController.StoryActionContext memory context,\n    bytes32 answerIndex,\n    IStoryController.MainState storage s\n  ) internal view returns (IStoryController.AnswerResultId) {\n    bytes32[] storage reqs = s.attributeRequirements[answerIndex];\n    uint length = reqs.length;\n\n    for (uint i; i < length; ++i) {\n      (uint8 attributeIndex, int32 value, bool isCore) = reqs[i].unpackStoryAttributeRequirement();\n      if (isCore) {\n        IStatController.CoreAttributes memory base = context.statController.heroBaseAttributes(context.heroToken, context.heroTokenId);\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.STRENGTH) && base.strength < value) {\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\n        }\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.DEXTERITY) && base.dexterity < value) {\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\n        }\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.VITALITY) && base.vitality < value) {\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\n        }\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.ENERGY) && base.energy < value) {\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\n        }\n      } else {\n        int32 attr = context.statController.heroAttribute(context.heroToken, context.heroTokenId, attributeIndex);\n        if (attr < value) {\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\n        }\n      }\n    }\n\n    return IStoryController.AnswerResultId.SUCCESS;\n  }\n\n  /// @notice Check item requirements for the given answer, check following issues:\n  /// 1) For equipped item: check if it is on balance\n  /// 2) For not equipped item: burn first owned item if requireItemBurn OR check that not equipped item is on balance\n  function checkAnswerItems(\n    IStoryController.StoryActionContext memory context,\n    bytes32 answerIndex,\n    IStoryController.MainState storage s\n  ) internal returns (IStoryController.AnswerResultId) {\n\n    bytes32[] storage reqs = s.itemRequirements[answerIndex];\n    uint length = reqs.length;\n\n    for (uint i; i < length; ++i) {\n      (address item, bool requireItemBurn, bool requireItemEquipped) = reqs[i].unpackStoryItemRequirement();\n\n      // equipped item is on balance of the heroToken, not on balance of the sender\n      if (requireItemEquipped && IERC721Enumerable(item).balanceOf(context.heroToken) == 0) {\n        revert IAppErrors.NotItem1();\n      }\n\n      if (requireItemBurn) {\n        _burnFirstOwnedItem(context, item);\n      }\n\n      if (!requireItemEquipped && !requireItemBurn) {\n        if (IERC721Enumerable(item).balanceOf(context.sender) == 0) revert IAppErrors.NotItem2();\n      }\n\n    }\n    return IStoryController.AnswerResultId.SUCCESS;\n  }\n\n  /// @notice burn first owned item and generate event\n  /// @dev Use separate function to workaround stack too deep\n  function _burnFirstOwnedItem(IStoryController.StoryActionContext memory context, address item) internal {\n    uint itemId = IERC721Enumerable(item).tokenOfOwnerByIndex(context.sender, 0);\n    context.itemController.destroy(item, itemId); // destroy reverts if the item is equipped\n\n    emit IApplicationEvents.NotEquippedItemBurned(\n      context.heroToken,\n      context.heroTokenId,\n      context.dungeonId,\n      context.storyId,\n      item,\n      itemId,\n      context.stageId,\n      context.iteration\n    );\n  }\n\n  /// @notice Ensure that the sender has enough amounts of the required tokens, send fees to the treasury\n  function checkAnswerTokens(\n    IStoryController.StoryActionContext memory context,\n    bytes32 answerIndex,\n    IStoryController.MainState storage s\n  ) internal returns (IStoryController.AnswerResultId) {\n    bytes32[] memory reqs = s.tokenRequirements[answerIndex];\n    uint length = reqs.length;\n    for (uint i; i < length; ++i) {\n      (address token, uint88 amount, bool requireTransfer) = reqs[i].unpackStoryTokenRequirement();\n\n      if (amount != 0) {\n        uint balance = IERC20(token).balanceOf(context.sender);\n        if (balance < uint(amount)) revert IAppErrors.NotEnoughAmount(balance, uint(amount));\n\n        if (requireTransfer) {\n          address treasury = context.controller.treasury();\n          IERC20(token).transferFrom(context.sender, address(this), uint(amount));\n          IERC20(token).approve(treasury, type(uint).max);\n          ITreasury(treasury).sendFee(token, uint(amount), IItemController.FeeType.STORY);\n        }\n      }\n    }\n    return IStoryController.AnswerResultId.SUCCESS;\n  }\n\n  /// @notice Generate error randomly\n  function checkAnswerRandom(IStoryController.StoryActionContext memory context) internal returns (IStoryController.AnswerResultId) {\n    (uint32 random,,) = context.answerAttributes.unpackStorySimpleRequirement();\n\n    if (random != 0 && random < 100) {\n      if (context.oracle.getRandomNumber(100, 0) > uint(random)) {\n        return IStoryController.AnswerResultId.RANDOM_FAIL;\n      }\n    } else if (random > 100) {\n      revert IAppErrors.NotRandom(random);\n    }\n\n    return IStoryController.AnswerResultId.SUCCESS;\n  }\n\n  /// @notice Ensure that the answer was given fast enough\n  function checkAnswerDelay(IStoryController.StoryActionContext memory context) internal view returns (IStoryController.AnswerResultId) {\n\n    (,uint32 delay,) = context.answerAttributes.unpackStorySimpleRequirement();\n\n    if (delay != 0) {\n      uint lastCall = uint(context.heroLastActionTS);\n      if (lastCall != 0 && lastCall < block.timestamp && block.timestamp - lastCall > uint(delay)) {\n        return IStoryController.AnswerResultId.DELAY_FAIL;\n      }\n    }\n\n    return IStoryController.AnswerResultId.SUCCESS;\n  }\n\n  function checkAnswerHeroCustomData(\n    IStoryController.StoryActionContext memory context,\n    bytes32 answerIndex,\n    IStoryController.MainState storage s\n  ) internal view returns (IStoryController.AnswerResultId) {\n    return _checkAnswerCustomData(context, s.heroCustomDataRequirement[answerIndex], true);\n  }\n\n  function checkAnswerGlobalCustomData(\n    IStoryController.StoryActionContext memory context,\n    bytes32 answerIndex,\n    IStoryController.MainState storage s\n  ) internal view returns (IStoryController.AnswerResultId) {\n    return _checkAnswerCustomData(context, s.globalCustomDataRequirement[answerIndex], false);\n  }\n\n  function _checkAnswerCustomData(\n    IStoryController.StoryActionContext memory context,\n    IStoryController.CustomDataRequirementPacked[] memory datas,\n    bool heroCustomData\n  ) internal view returns (IStoryController.AnswerResultId) {\n    uint len = datas.length;\n    for (uint i; i < len; ++i) {\n      IStoryController.CustomDataRequirementPacked memory data = datas[i];\n\n      if (data.index != 0) {\n        (uint valueMin, uint valueMax, bool mandatory) = data.data.unpackCustomDataRequirements();\n        uint heroValue = heroCustomData\n          ? context.statController.heroCustomData(context.heroToken, context.heroTokenId, data.index)\n          : context.statController.globalCustomData(data.index);\n\n        if (heroValue < valueMin || heroValue > valueMax) {\n          if (mandatory) {\n            if (heroCustomData) {\n              revert IAppErrors.NotHeroData();\n            } else {\n              revert IAppErrors.NotGlobalData();\n            }\n          } else {\n            return heroCustomData\n              ? IStoryController.AnswerResultId.HERO_CUSTOM_DATA_FAIL\n              : IStoryController.AnswerResultId.GLOBAL_CUSTOM_DATA_FAIL;\n          }\n        }\n      }\n    }\n\n    return IStoryController.AnswerResultId.SUCCESS;\n  }\n\n  //endregion ------------------------ Check answers\n}\n"
    },
    "contracts/lib/StorySetupLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IStoryController.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../lib/PackingLib.sol\";\nimport \"../lib/StatLib.sol\";\n\nlibrary StorySetupLib {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using PackingLib for bytes32;\n  using PackingLib for uint16;\n  using PackingLib for uint8;\n  using PackingLib for address;\n  using PackingLib for uint32[];\n  using PackingLib for uint32;\n  using PackingLib for uint64;\n  using PackingLib for int32[];\n  using PackingLib for int32;\n\n  //region ------------------ Data types\n  struct RemoveStoryContext {\n    uint8 heroClass;\n    uint8 answerResultId;\n    uint8 customDataResultId;\n    uint16 storyId;\n    uint16 pageId;\n    uint16 answerNum;\n    uint len;\n    uint[] tmpPages;\n    bytes32 answerId;\n    bytes32[] tmpAnswers;\n  }\n  //endregion ------------------ Data types\n\n  //region ------------------ Set story fields\n\n  function setAllStoryFields(IStoryController.MainState storage s, IStoryController.StoryMetaInfo memory meta) external {\n    setBurnItemsMeta(s, meta.storyId, meta.answerBurnRandomItemMeta);\n    setNextObjRewriteMeta(s, meta.storyId, meta.nextObjRewriteMeta);\n    setAnswersMeta(\n      s,\n      meta.storyId,\n      meta.answersMeta.answerPageIds,\n      meta.answersMeta.answerHeroClasses,\n      meta.answersMeta.answerIds\n    );\n    setAnswerNextPageMeta(s, meta.storyId, meta.answerNextPage);\n    setAnswerAttributeRequirements(s, meta.storyId, meta.answerAttributeRequirements);\n    setAnswerItemRequirements(s, meta.storyId, meta.answerItemRequirements);\n    setAnswerTokenRequirementsMeta(s, meta.storyId, meta.answerTokenRequirements);\n    setAnswerAttributes(s, meta.storyId, meta.answerAttributes);\n    setAnswerHeroCustomDataRequirementMeta(s, meta.storyId, meta.answerHeroCustomDataRequirement);\n    setAnswerGlobalCustomDataRequirementMeta(s, meta.storyId, meta.answerGlobalCustomDataRequirement);\n\n    setSuccessInfo(s, meta.storyId, meta.successInfo);\n    setFailInfo(s, meta.storyId, meta.failInfo);\n\n    setCustomDataResult(s, meta.storyId, meta.successHeroCustomData, IStoryController.CustomDataResult.HERO_SUCCESS);\n    setCustomDataResult(s, meta.storyId, meta.failHeroCustomData, IStoryController.CustomDataResult.HERO_FAIL);\n    setCustomDataResult(s, meta.storyId, meta.successGlobalCustomData, IStoryController.CustomDataResult.GLOBAL_SUCCESS);\n    setCustomDataResult(s, meta.storyId, meta.failGlobalCustomData, IStoryController.CustomDataResult.GLOBAL_FAIL);\n\n    setStoryCustomDataRequirements(\n      s,\n      meta.storyId,\n      meta.requiredCustomDataIndex,\n      meta.requiredCustomDataMinValue,\n      meta.requiredCustomDataMaxValue,\n      meta.requiredCustomDataIsHero,\n      meta.minLevel\n    );\n\n  }\n\n  /// @dev Since SIP-003 the burning is replaced by breaking\n  function setBurnItemsMeta(\n    IStoryController.MainState storage s,\n    uint16 storyId,\n    IStoryController.AnswerBurnRandomItemMeta memory meta\n  ) public {\n    unchecked {\n      uint len = meta.pageId.length;\n      for (uint i; i < len; ++i) {\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\n        if (answerPackedId != bytes32(0)) {\n\n          bytes32[] storage answersBurn = s.burnItem[answerPackedId];\n\n          for (uint j; j < meta.slots[i].length; ++j) {\n            bytes32 d = meta.slots[i][j].packBreakInfo(meta.chances[i][j], meta.isStopIfBurnt[i][j]);\n            if (d != bytes32(0)) {\n              answersBurn.push(d);\n            }\n          }\n        }\n      }\n    }\n\n    emit IApplicationEvents.SetBurnItemsMeta(storyId, meta);\n  }\n\n  function setNextObjRewriteMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.NextObjRewriteMeta memory meta) public {\n    unchecked {\n      uint len = meta.nextObjPageIds.length;\n      for (uint i; i < len; ++i) {\n        registerPage(s, storyId, meta.nextObjPageIds[i]);\n        bytes32 id = storyId.packStoryPageId(meta.nextObjPageIds[i], meta.nextObjHeroClasses[i]);\n        s.nextObjectsRewrite[id] = meta.nextObjIds[i];\n      }\n    }\n\n    emit IApplicationEvents.SetNextObjRewriteMeta(storyId, meta);\n  }\n\n  function setAnswersMeta(\n    IStoryController.MainState storage s,\n    uint16 storyId,\n    uint16[] memory answerPageIds,\n    uint8[] memory answerHeroClasses,\n    uint16[] memory answerIds\n  ) public {\n    unchecked {\n      uint len = answerPageIds.length;\n      for (uint i; i < len; ++i) {\n        registerPage(s, storyId, answerPageIds[i]);\n\n        bytes32[] storage answersHashes = s.answers[storyId.packStoryPageId(answerPageIds[i], answerHeroClasses[i])];\n\n        bytes32 answerPackedId = _registerAnswer(s, storyId, answerPageIds[i], answerHeroClasses[i], answerIds[i]);\n        if (answerPackedId != bytes32(0)) {\n          answersHashes.push(answerPackedId);\n        }\n      }\n    }\n\n    emit IApplicationEvents.SetAnswersMeta(storyId, answerPageIds, answerHeroClasses, answerIds);\n  }\n\n  function setAnswerNextPageMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerNextPageMeta memory meta) public {\n    unchecked {\n      uint len = meta.pageId.length;\n      for (uint i; i < len; ++i) {\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\n        if (answerPackedId != bytes32(0)) {\n          bytes32 pagePackedId = storyId.packStoryNextPagesId(\n            meta.pageId[i],\n            meta.heroClass[i],\n            meta.answerId[i],\n            meta.answerResultIds[i]\n          );\n          // pagePackedId cannot be 0 here because answerPackedId is not 0\n          s.nextPageIds[pagePackedId] = meta.answerNextPageIds[i];\n        }\n      }\n    }\n\n    emit IApplicationEvents.SetAnswerNextPageMeta(storyId, meta);\n  }\n\n  function setAnswerAttributeRequirements(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerAttributeRequirementsMeta memory meta) public {\n    unchecked {\n      uint len = meta.pageId.length;\n      for (uint i; i < len; ++i) {\n\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\n        if (answerPackedId != bytes32(0)) {\n          bytes32[] storage attrs = s.attributeRequirements[answerPackedId];\n\n          for (uint j; j < meta.cores[i].length; ++j) {\n            bytes32 attributeRequirementsPacked = meta.ids[i][j].packStoryAttributeRequirement(\n              meta.values[i][j],\n              meta.cores[i][j]\n            );\n\n            if (attributeRequirementsPacked != bytes32(0)) {\n              attrs.push(attributeRequirementsPacked);\n            }\n          }\n        }\n      }\n    }\n\n    emit IApplicationEvents.SetAnswerAttributeRequirements(storyId, meta);\n  }\n\n  function setAnswerItemRequirements(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerItemRequirementsMeta memory meta) public {\n    unchecked {\n      uint len = meta.pageId.length;\n      for (uint i; i < len; ++i) {\n\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\n        if (answerPackedId != bytes32(0)) {\n          bytes32[] storage attrs = s.itemRequirements[answerPackedId];\n\n          for (uint j; j < meta.requireItems[i].length; ++j) {\n            bytes32 d = meta.requireItems[i][j].packStoryItemRequirement(\n              meta.requireItemBurn[i][j],\n              meta.requireItemEquipped[i][j]);\n\n            if (d != bytes32(0)) {\n              attrs.push(d);\n            }\n          }\n        }\n      }\n    }\n\n    emit IApplicationEvents.SetAnswerItemRequirements(storyId, meta);\n  }\n\n  function setAnswerTokenRequirementsMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerTokenRequirementsMeta memory meta) public {\n    unchecked {\n      uint len = meta.pageId.length;\n      for (uint i; i < len; ++i) {\n\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\n        if (answerPackedId != bytes32(0)) {\n          bytes32[] storage attrs = s.tokenRequirements[answerPackedId];\n\n          for (uint j; j < meta.requireToken[i].length; ++j) {\n            bytes32 d = meta.requireToken[i][j].packStoryTokenRequirement(\n              meta.requireAmount[i][j],\n              meta.requireTransfer[i][j]\n            );\n            if (d != bytes32(0)) {\n              attrs.push(d);\n            }\n          }\n        }\n      }\n    }\n\n    emit IApplicationEvents.SetAnswerTokenRequirementsMeta(storyId, meta);\n  }\n\n  function setAnswerAttributes(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerAttributesMeta memory meta) public {\n    unchecked {\n      uint len = meta.pageId.length;\n      for (uint i; i < len; ++i) {\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\n        if (answerPackedId != bytes32(0)) {\n          bytes32 data = meta.randomRequirements[i].packStorySimpleRequirement(\n            meta.delayRequirements[i],\n            meta.isFinalAnswer[i]\n          );\n\n          if (data != bytes32(0)) {\n            s.answerAttributes[answerPackedId] = data;\n          }\n        }\n      }\n    }\n\n    emit IApplicationEvents.SetAnswerAttributes(storyId, meta);\n  }\n\n  function setAnswerHeroCustomDataRequirementMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerCustomDataMeta memory meta) public {\n    _setCustomDataRequirementMeta(s, storyId, meta, s.heroCustomDataRequirement);\n    emit IApplicationEvents.SetAnswerHeroCustomDataRequirementMeta(storyId, meta);\n  }\n\n  function setAnswerGlobalCustomDataRequirementMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerCustomDataMeta memory meta) public {\n    _setCustomDataRequirementMeta(s, storyId, meta, s.globalCustomDataRequirement);\n    emit IApplicationEvents.SetAnswerGlobalCustomDataRequirementMeta(storyId, meta);\n  }\n\n  function setStoryCustomDataRequirements(\n    IStoryController.MainState storage s,\n    uint16 storyId,\n    bytes32[] memory requiredCustomDataIndex,\n    uint64[] memory requiredCustomDataMinValue,\n    uint64[] memory requiredCustomDataMaxValue,\n    bool[] memory requiredCustomDataIsHero,\n    uint minLevel\n  ) public {\n    s.storyRequiredLevel[storyId] = minLevel;\n    emit IApplicationEvents.StoryRequiredLevel(storyId, minLevel);\n\n    IStoryController.CustomDataRequirementRangePacked[] storage allData = s.storyRequiredHeroData[storyId];\n\n    for (uint i; i < requiredCustomDataIndex.length; ++i) {\n      allData.push(IStoryController.CustomDataRequirementRangePacked({\n        index: requiredCustomDataIndex[i],\n        data: requiredCustomDataMinValue[i].packCustomDataRequirements(\n          requiredCustomDataMaxValue[i],\n          requiredCustomDataIsHero[i]\n        )\n      }));\n\n      emit IApplicationEvents.StoryCustomDataRequirements(storyId, requiredCustomDataIndex[i], requiredCustomDataMinValue[i], requiredCustomDataMaxValue[i], requiredCustomDataIsHero[i]);\n    }\n  }\n\n  function setSuccessInfo(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerResultMeta memory meta) public {\n    _setInfo(s, storyId, meta, s.successInfoAttributes, s.successInfoStats, s.successInfoMintItems);\n    emit IApplicationEvents.SetSuccessInfo(storyId, meta);\n  }\n\n  function setFailInfo(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerResultMeta memory meta) public {\n    _setInfo(s, storyId, meta, s.failInfoAttributes, s.failInfoStats, s.failInfoMintItems);\n    emit IApplicationEvents.SetFailInfo(storyId, meta);\n  }\n\n  function setCustomDataResult(\n    IStoryController.MainState storage s,\n    uint16 storyId,\n    IStoryController.AnswerCustomDataResultMeta memory meta,\n    IStoryController.CustomDataResult type_\n  ) public {\n    unchecked {\n      uint len = meta.pageId.length;\n      for (uint i; i < len; ++i) {\n        if (_registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]) != bytes32(0)) {\n          bytes32 answerPackedIdWithType = storyId.packStoryCustomDataResult(\n            meta.pageId[i],\n            meta.heroClass[i],\n            meta.answerId[i],\n            uint8(type_)\n          );\n\n          bytes32[] storage arr = s.customDataResult[answerPackedIdWithType];\n          for (uint j; j < meta.dataIndexes[i].length; ++j) {\n            arr.push(meta.dataIndexes[i][j].packCustomDataChange(meta.dataValues[i][j]));\n          }\n        }\n      }\n    }\n\n    emit IApplicationEvents.SetCustomDataResult(storyId, meta, type_);\n  }\n\n  function finalizeStoryRegistration(\n    IStoryController.MainState storage s,\n    uint16 storyId,\n    uint32 objectId,\n    uint buildHash\n  ) external {\n    // it's not necessary to remove previously stored data here\n    // we assume, that old data is already removed completely before registering new data\n\n    s.registeredStories[objectId] = true;\n    // store new used id\n    s._usedStoryIds[storyId] = true;\n    // register new id for story\n    s.storyIds[objectId] = storyId;\n    s.idToStory[storyId] = objectId;\n    s.storyBuildHash[storyId] = buildHash;\n\n    emit IApplicationEvents.StoryFinalized(objectId, storyId);\n  }\n  //endregion ------------------ Set story fields\n\n  //region ------------------ Utils to set story fields\n  function _registerAnswer(IStoryController.MainState storage s,  uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId)\n  internal returns (bytes32 answerPackedId) {\n    answerPackedId = storyId.packStoryAnswerId(pageId, heroClass, answerId);\n    if (answerPackedId != bytes32(0)) {\n      registerAnswer(s, storyId, answerPackedId);\n    }\n  }\n\n  /// @param map Either heroCustomDataRequirement or globalCustomDataRequirement\n  function _setCustomDataRequirementMeta(\n    IStoryController.MainState storage s,\n    uint16 storyId,\n    IStoryController.AnswerCustomDataMeta memory meta,\n    mapping(bytes32 => IStoryController.CustomDataRequirementPacked[]) storage map\n  ) internal {\n    unchecked {\n      uint len = meta.pageId.length;\n      for (uint i; i < len; ++i) {\n\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\n        if (answerPackedId != bytes32(0)) {\n          IStoryController.CustomDataRequirementPacked[] storage arr = map[answerPackedId];\n\n          bytes32[] memory dataIndexes = meta.dataIndexes[i];\n          bool[] memory mandatory = meta.mandatory[i];\n          uint64[] memory dataValuesMin = meta.dataValuesMin[i];\n          uint64[] memory dataValuesMax = meta.dataValuesMax[i];\n\n          for (uint j; j < dataIndexes.length; ++j) {\n            arr.push(\n              IStoryController.CustomDataRequirementPacked({\n                index: dataIndexes[j],\n                data: dataValuesMin[j].packCustomDataRequirements(dataValuesMax[j], mandatory[j])\n              })\n            );\n          }\n        }\n      }\n    }\n  }\n\n  function _setInfo(\n    IStoryController.MainState storage s,\n    uint16 storyId,\n    IStoryController.AnswerResultMeta memory meta,\n    mapping(bytes32 => bytes32[]) storage infoAttributes,\n    mapping(bytes32 => bytes32) storage infoStats,\n    mapping(bytes32 => bytes32[]) storage infoMintItems\n  ) public {\n    unchecked {\n      uint len = meta.pageId.length;\n      for (uint i; i < len; ++i) {\n\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\n        if (answerPackedId != bytes32(0)) {\n          if (meta.attributeIds[i].length != 0) {\n            infoAttributes[answerPackedId] = meta.attributeValues[i].toBytes32ArrayWithIds(meta.attributeIds[i]);\n          }\n\n          bytes32 stats = PackingLib.packStatsChange(\n            meta.experience[i],\n            meta.heal[i],\n            meta.manaRegen[i],\n            meta.lifeChancesRecovered[i],\n            meta.damage[i],\n            meta.manaConsumed[i]\n          );\n          if (stats != bytes32(0)) {\n            infoStats[answerPackedId] = stats;\n          }\n\n          uint lenItems = meta.mintItems[i].length;\n          if (lenItems != 0) {\n            bytes32[] memory items = new bytes32[](lenItems);\n            for (uint j; j < lenItems; ++j) {\n              items[j] = meta.mintItems[i][j].packItemMintInfo(meta.mintItemsChances[i][j]);\n            }\n            infoMintItems[answerPackedId] = items;\n          }\n        }\n      }\n    }\n  }\n  //endregion ------------------ Utils to set story fields\n\n  //region ------------------ Remove logic\n  // WE MUST REMOVE ALL EXIST META!\n  // otherwise we will still have meta for story id and will totally mess data\n  function removeStory(IStoryController.MainState storage s, uint32 objectId) external {\n    if (s.storyIds[objectId] == 0 || !s.registeredStories[objectId]) revert IAppErrors.ZeroStoryIdRemoveStory();\n\n    uint16 storyId = s.storyIds[objectId];\n    delete s._usedStoryIds[storyId];\n    delete s.storyIds[objectId];\n    delete s.idToStory[storyId];\n    delete s.registeredStories[objectId];\n    delete s.storyBuildHash[storyId];\n\n    delete s.storyRequiredHeroData[storyId];\n    delete s.storyRequiredLevel[storyId];\n\n\n    emit IApplicationEvents.StoryRemoved(objectId, storyId);\n  }\n\n  function removeStoryPagesMeta(IStoryController.MainState storage s, uint16 storyId, uint maxIterations) external {\n    RemoveStoryContext memory ctx;\n    ctx.storyId = storyId;\n\n    // --- clean all data related to pages ---\n\n    EnumerableSet.UintSet storage allPages = s.allStoryPages[ctx.storyId];\n    ctx.len = allPages.length();\n    if (ctx.len > maxIterations) {\n      ctx.len = maxIterations;\n    }\n    ctx.tmpPages = new uint[](ctx.len);\n\n    for (uint i; i < ctx.len; ++i) {\n      ctx.tmpPages[i] = allPages.at(i);\n      ctx.pageId = uint16(ctx.tmpPages[i]);\n\n      // zero hero class means all classes\n      for (ctx.heroClass = 0; ctx.heroClass < uint(StatLib.HeroClasses.END_SLOT); ++ctx.heroClass) {\n        delete s.answers[ctx.storyId.packStoryPageId(ctx.pageId, ctx.heroClass)];\n        delete s.nextObjectsRewrite[ctx.storyId.packStoryPageId(ctx.pageId, ctx.heroClass)];\n      }\n    }\n\n    // remove all pages\n    for (uint i; i < ctx.tmpPages.length; ++i) {\n      if (!allPages.remove(ctx.tmpPages[i])) {\n        revert IAppErrors.PageNotRemovedError(ctx.tmpPages[i]);\n      }\n    }\n  }\n\n  function removeStoryAnswersMeta(IStoryController.MainState storage s, uint16 storyId, uint maxIterations) external {\n    RemoveStoryContext memory ctx;\n    ctx.storyId = storyId;\n\n    // --- clean all data related to answers ---\n\n    EnumerableSet.Bytes32Set storage allAnswers = s.allStoryAnswers[ctx.storyId];\n    ctx.len = allAnswers.length();\n    if (ctx.len > maxIterations) {\n      ctx.len = maxIterations;\n    }\n    ctx.tmpAnswers = new bytes32[](ctx.len);\n\n    for (uint i; i < ctx.len; ++i) {\n      ctx.answerId = allAnswers.at(i);\n      ctx.tmpAnswers[i] = ctx.answerId;\n\n      (, ctx.pageId, ctx.heroClass, ctx.answerNum) = ctx.answerId.unpackStoryAnswerId();\n\n      delete s.answerAttributes[ctx.answerId];\n      delete s.attributeRequirements[ctx.answerId];\n      delete s.itemRequirements[ctx.answerId];\n      delete s.tokenRequirements[ctx.answerId];\n      delete s.heroCustomDataRequirement[ctx.answerId];\n      delete s.globalCustomDataRequirement[ctx.answerId];\n      delete s.successInfoAttributes[ctx.answerId];\n      delete s.successInfoStats[ctx.answerId];\n      delete s.successInfoMintItems[ctx.answerId];\n      delete s.failInfoAttributes[ctx.answerId];\n      delete s.failInfoStats[ctx.answerId];\n      delete s.failInfoMintItems[ctx.answerId];\n      delete s.burnItem[ctx.answerId];\n\n      for (ctx.answerResultId = 0; ctx.answerResultId < uint(IStoryController.AnswerResultId.END_SLOT); ++ctx.answerResultId) {\n        delete s.nextPageIds[ctx.storyId.packStoryNextPagesId(\n          ctx.pageId,\n          ctx.heroClass,\n          ctx.answerNum,\n          ctx.answerResultId\n        )];\n      }\n\n      // we assume here, that CustomDataResultId.UNKNOWN = 0 shouldn't be used, so we can skip delete for it\n      for (ctx.customDataResultId = 1; ctx.customDataResultId < uint(IStoryController.CustomDataResult.END_SLOT); ++ctx.customDataResultId) {\n        delete s.customDataResult[ctx.storyId.packStoryCustomDataResult(\n          ctx.pageId,\n          ctx.heroClass,\n          ctx.answerNum,\n          ctx.customDataResultId\n        )];\n      }\n    }\n\n    // ATTENTION! need to remove items one by one from sets\n\n    // remove all answers\n    for (uint i; i < ctx.tmpAnswers.length; ++i) {\n      allAnswers.remove(ctx.tmpAnswers[i]);\n    }\n  }\n  //endregion ------------------ Remove logic\n\n  //region ------------------ Utils\n  function registerAnswer(IStoryController.MainState storage s, uint16 storyId, bytes32 answerId) internal {\n    s.allStoryAnswers[storyId].add(answerId);\n  }\n\n  function registerPage(IStoryController.MainState storage s, uint16 storyId, uint16 pageId) internal {\n    s.allStoryPages[storyId].add(pageId);\n  }\n  //endregion ------------------ Utils\n}\n"
    },
    "contracts/lib/StringLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n\nlibrary StringLib {\n\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n  function toString(uint value) external pure returns (string memory) {\n    return _toString(value);\n  }\n\n  function _toString(uint value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0\";\n    }\n    uint temp = value;\n    uint digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  function toAsciiString(address x) external pure returns (string memory) {\n    return _toAsciiString(x);\n  }\n\n  function _toAsciiString(address x) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = _char(hi);\n      s[2 * i + 1] = _char(lo);\n    }\n    return string(s);\n  }\n\n  function char(bytes1 b) external pure returns (bytes1 c) {\n    return _char(b);\n  }\n\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n    else return bytes1(uint8(b) + 0x57);\n  }\n\n  function concat(string memory a, string memory b) internal pure returns (string memory) {\n    return string(abi.encodePacked(a, b));\n  }\n\n  function isASCIILettersOnly(string memory str) internal pure returns (bool) {\n    bytes memory b = bytes(str);\n    for (uint i = 0; i < b.length; i++) {\n      if (uint8(b[i]) < 32 || uint8(b[i]) > 127) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "contracts/lib/TreasuryLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../proxy/Controllable.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IGameToken.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IAppErrors.sol\";\n\nlibrary TreasuryLib {\n  //region ------------------------ CONSTANTS\n  uint public constant AUGMENT_GOV_FEE = 50;\n  uint public constant REPAIR_GOV_FEE = 50;\n  //endregion ------------------------ CONSTANTS\n\n  //region ------------------------ RESTRICTIONS\n\n  function onlyDungeonFactory(IController controller) internal view {\n    if (controller.dungeonFactory() != msg.sender) revert IAppErrors.ErrorNotDungeonFactory(msg.sender);\n  }\n  //endregion ------------------------ RESTRICTIONS\n\n  //region ------------------------ VIEWS\n\n  function balanceOfToken(address token) internal view returns (uint) {\n    return IERC20(token).balanceOf(address(this));\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ ACTIONS\n\n  /// @notice Send {amount} of the {token} to the {dungeon}\n  function sendToDungeon(IController controller, address dungeon, address token, uint amount) internal {\n    onlyDungeonFactory(controller);\n    uint bal = IERC20(token).balanceOf(address(this));\n    if (bal == 0 || amount > bal) revert IAppErrors.NotEnoughBalance();\n    IERC20(token).transfer(dungeon, amount);\n    emit IApplicationEvents.AssetsSentToDungeon(dungeon, token, amount);\n  }\n\n  /// @dev Assume approve. Move fee to treasury and governance from msg.sender.\n  ///      Anyone can call\n  function sendFee(IController controller, address token, uint amount, IItemController.FeeType feeType) internal {\n\n    uint dividerGovFee = 100;\n    if (feeType == IItemController.FeeType.REPAIR) {\n      dividerGovFee = REPAIR_GOV_FEE;\n    } else if (feeType == IItemController.FeeType.AUGMENT) {\n      dividerGovFee = AUGMENT_GOV_FEE;\n    }\n\n    uint toGov = amount * dividerGovFee / 100;\n    uint toTreasury = amount - toGov;\n    if (toTreasury != 0) {\n      address gameToken = controller.gameToken();\n      if (gameToken == token) {\n        IERC20(token).transferFrom(msg.sender, address(this), toTreasury);\n        // for game token always burn treasury part\n        IGameToken(gameToken).burn(toTreasury);\n      } else {\n        IERC20(token).transferFrom(msg.sender, address(this), toTreasury);\n      }\n    }\n    if (toGov != 0) {\n      IERC20(token).transferFrom(msg.sender, address(controller), toGov);\n    }\n  }\n  //endregion ------------------------ ACTIONS\n\n}\n"
    },
    "contracts/lib/UserControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IHeroTokensVault.sol\";\nimport \"../interfaces/IUserController.sol\";\nimport \"../lib/StringLib.sol\";\nimport \"../solady/DateTimeLib.sol\";\nimport \"./ItemLib.sol\";\n\nlibrary UserControllerLib {\n  //region ------------------------ Constants\n  /// @dev keccak256(abi.encode(uint256(keccak256(\"user.controller.main\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant USER_CONTROLLER_STORAGE_LOCATION = 0xb1ab856820591f650019ba94531c31db134c614288dc690130c9f2a4ef554800;\n  /// @notice User should pass 3 dungeons to complete daily activity\n  uint internal constant DAILY_ACTIVITY_DUNGEONS_THRESHOLD = 3;\n  /// @notice Count of completed daily activities required to complete weekly activity\n  uint internal constant WEEKLY_ACTIVITY_THRESHOLD = 7;\n  /// @notice Default value of renaming fee, in game token, decimals 18\n  uint internal constant FEE_RENAMING_DEFAULT_VALUE = 1000e18;\n  //endregion ------------------------ Constants\n\n  //region ------------------------ Restrictions\n  function _onlyEoa(bool isEoa) internal pure {\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\n  }\n\n  function _onlyDungeonFactory(IController controller, address msgSender) internal view {\n    if (controller.dungeonFactory() != msgSender) revert IAppErrors.ErrorNotDungeonFactory(msgSender);\n  }\n\n  function _onlyGovernance(IController controller, address msgSender) internal view {\n    if (controller.governance() != msgSender) revert IAppErrors.NotGovernance(msgSender);\n  }\n\n  function _onlyDeployer(IController controller, address msgSender) internal view {\n    if (!controller.isDeployer(msgSender)) revert IAppErrors.ErrorNotDeployer(msgSender);\n  }\n  //endregion ------------------------ Restrictions\n\n  //region ------------------------ Storage\n\n  function _S() internal pure returns (IUserController.MainState storage s) {\n    assembly {\n      s.slot := USER_CONTROLLER_STORAGE_LOCATION\n    }\n    return s;\n  }\n  //endregion ------------------------ Storage\n\n  //region ------------------------ View\n  function getUserAccountName(address user) internal view returns (string memory) {\n    return _S().userAccountName[user];\n  }\n\n  function nameToUserAccount(string memory name) internal view returns (address) {\n    return _S().nameToUserAccount[name];\n  }\n\n  function getUserActivity(address user) internal view returns (IUserController.UserActivity memory) {\n    return _S().userActivity[user];\n  }\n\n  function getCounterLootBoxes(address user) internal view returns (uint32 dailyCounter, uint32 weeklyCounter) {\n    IUserController.EarnedLootBoxes memory data = _S().counterLootBoxes[user];\n    return (data.dailyCounter, data.weeklyCounter);\n  }\n\n  function getLootBoxConfig(uint lootBoxKind) internal view returns (\n    address[] memory mintItems,\n    uint32[] memory mintItemsChances,\n    uint maxDropItems\n  ) {\n    IUserController.LootBoxConfig memory config = _S().lootBoxConfig[IUserController.LootBoxKind(lootBoxKind)];\n    return (config.mintItems, config.mintItemsChances, config.maxDropItems);\n  }\n\n  function getFeeRenaming() internal view returns (uint) {\n    return _S().feeRenaming;\n  }\n  //endregion ------------------------ View\n\n  //region ------------------------ ACTIONS\n  /// @notice Set name of user account (free) or rename user account (feeRenaming is paid)\n  function setUserName(bool isEoa, IController controller, address msgSender, string memory userAccountName) internal {\n    _onlyEoa(isEoa);\n\n    if (_S().nameToUserAccount[userAccountName] != address(0)) revert IAppErrors.NameTaken();\n    if (bytes(userAccountName).length >= 20) revert IAppErrors.TooBigName();\n    if (!StringLib.isASCIILettersOnly(userAccountName)) revert IAppErrors.WrongSymbolsInTheName();\n\n    // Empty name means that user hasn't assigned name yet. First assignment is free, renaming is paid.\n    if (bytes(userAccountName).length == 0) revert IAppErrors.EmptyNameNotAllowed();\n    string memory oldName = _S().userAccountName[msgSender];\n    if (bytes(oldName).length != 0) {\n      uint feeRenaming = _S().feeRenaming;\n      if (feeRenaming != 0) {\n        address token = controller.gameToken();\n        IHeroTokensVault(IHeroController(controller.heroController()).heroTokensVault()).process(token, feeRenaming, msgSender);\n      }\n      delete _S().nameToUserAccount[oldName];\n    }\n\n    _S().userAccountName[msgSender] = userAccountName;\n    _S().nameToUserAccount[userAccountName] = msgSender;\n\n    emit IApplicationEvents.SetUserName(msgSender, userAccountName);\n  }\n\n  /// @notice Use either daily or weekly loot box depending on value of {lootBoxKind}\n  /// @param msgSender EOA\n  /// @param nextPrng_ CalcLib.nextPrng or test routine\n  /// @param mintRandomItems_ ItemLib._mintRandomItems or test routine\n  function openLootBox(\n    IController controller,\n    address msgSender,\n    IUserController.LootBoxKind lootBoxKind,\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_,\n    function (\n      ItemLib.MintItemInfo memory,\n      function (LibPRNG.PRNG memory, uint) internal view returns (uint)\n    ) internal returns (address[] memory) mintRandomItems_\n  ) internal {\n    IUserController.EarnedLootBoxes memory data = _S().counterLootBoxes[msgSender];\n    if (\n      (lootBoxKind == IUserController.LootBoxKind.WEEKLY_1 && data.weeklyCounter == 0)\n      || (lootBoxKind == IUserController.LootBoxKind.DAILY_0 && data.dailyCounter == 0)\n      || (lootBoxKind >= IUserController.LootBoxKind.END_SLOT)\n    ) {\n      revert IAppErrors.NoAvailableLootBox(msgSender, uint(lootBoxKind));\n    }\n\n    // apply daily/weekly loot box\n    IUserController.LootBoxConfig memory config = _S().lootBoxConfig[lootBoxKind];\n    address[] memory mintItems = mintRandomItems_(\n      ItemLib.MintItemInfo({\n        seed: 0,\n        oracle: IOracle(controller.oracle()),\n\n        mintItems: config.mintItems,\n        mintItemsChances: config.mintItemsChances,\n        maxItems: uint8(config.maxDropItems),\n\n        amplifier: 0, // don't increase chances\n        magicFind: 0, // don't increase chances\n        destroyItems: 0, // don't reduce chances\n        mintDropChanceDelta: 0 // don't reduce chances\n      }),\n      nextPrng_\n    );\n\n    // mint dropped items if any\n    uint[] memory itemTokenIds;\n\n    uint len = mintItems.length;\n    if (len != 0) {\n      IItemController ic = IItemController(controller.itemController());\n      itemTokenIds = new uint[](len);\n\n      // mint items to the user\n      for (uint i; i < len; ++i) {\n        itemTokenIds[i] = ic.mint(mintItems[i], msgSender);\n      }\n    }\n\n    // reduce the counter of available loot boxes\n    if (lootBoxKind == IUserController.LootBoxKind.WEEKLY_1) {\n      data.weeklyCounter--;\n    } else {\n      data.dailyCounter--;\n    }\n\n    _S().counterLootBoxes[msgSender] = data;\n\n    emit IApplicationEvents.LootBoxOpened(msgSender, uint(lootBoxKind), mintItems, itemTokenIds);\n  }\n\n  function setLootBoxConfig(IController controller, address msgSender, uint lootBoxKind, IUserController.LootBoxConfig memory config) internal {\n    _onlyDeployer(controller, msgSender);\n\n    _S().lootBoxConfig[IUserController.LootBoxKind(lootBoxKind)] = config;\n    emit IApplicationEvents.LootBoxConfigChanged(lootBoxKind, config.mintItems, config.mintItemsChances, config.maxDropItems);\n  }\n\n  /// @notice Set fee for renaming user accounts. Game token, value 0 is allowed.\n  function setFeeRenaming(IController controller, address msgSender, uint feeRenaming) internal {\n    _onlyGovernance(controller, msgSender);\n    _S().feeRenaming = feeRenaming;\n\n    emit IApplicationEvents.SetFeeRenaming(feeRenaming);\n  }\n  //endregion ------------------------ ACTIONS\n\n  //region ------------------------ IUserController\n  /// @notice Register daily activity - a dungeon was passed\n  /// @param user Owner of the hero who has passed the dungeon\n  /// @param msgSender Dungeon factory only\n  /// @param user EOA\n  /// @param blockTimestamp block.timestamp (param is used for test purposes)\n  /// @param dailyActivityThreshold DAILY_ACTIVITY_DUNGEONS_THRESHOLD, for tests\n  /// @param weeklyActivityThreshold WEEKLY_ACTIVITY_THRESHOLD, for tests\n  function registerPassedDungeon(\n    IController controller,\n    address msgSender,\n    address user,\n    uint blockTimestamp,\n    uint dailyActivityThreshold,\n    uint weeklyActivityThreshold\n  ) internal {\n    _onlyDungeonFactory(controller, msgSender);\n\n    IUserController.UserActivity memory userActivity = _S().userActivity[user];\n    uint32 epochDay = uint32(blockTimestamp / 86400);\n    if (epochDay != userActivity.epochDay) {\n      userActivity.epochDay = epochDay;\n      userActivity.counterPassedDungeons = 0;\n      userActivity.counterPvp = 0;\n      userActivity.dailyLootBoxReceived = false;\n    }\n\n    uint32 epochWeek = getEpochWeek(epochDay);\n    if (epochWeek != userActivity.epochWeek) {\n      userActivity.weeklyLootBoxReceived = false;\n      userActivity.dailyActivities = 0;\n      userActivity.epochWeek = 0;\n    }\n\n    if (!userActivity.dailyLootBoxReceived) {\n      userActivity.counterPassedDungeons += 1;\n      if (userActivity.counterPassedDungeons == dailyActivityThreshold) {\n        // daily activity is completed, add small loot box\n        IUserController.EarnedLootBoxes memory earned = _S().counterLootBoxes[user];\n        earned.dailyCounter += 1;\n        userActivity.dailyLootBoxReceived = true;\n\n        if (epochWeek == userActivity.epochWeek) {\n          // continue current week\n          userActivity.dailyActivities += 1;\n          if (userActivity.dailyActivities == weeklyActivityThreshold && !userActivity.weeklyLootBoxReceived) {\n            userActivity.weeklyLootBoxReceived = true;\n            earned.weeklyCounter += 1;\n          }\n        } else {\n          // start new week\n          userActivity.dailyActivities = 1;\n          userActivity.epochWeek = epochWeek;\n          userActivity.weeklyLootBoxReceived = false;\n        }\n\n        _S().counterLootBoxes[user] = earned;\n\n        emit IApplicationEvents.ActivityCompleted(user, userActivity.dailyLootBoxReceived, userActivity.weeklyLootBoxReceived);\n      }\n    }\n\n    _S().userActivity[user] = userActivity;\n  }\n\n  /// @notice Register daily activity - PvP was made\n  /// @param user Owner of the hero who has taken participation in the PvP\n  function registerPvP(IController controller, address msgSender, address user, bool isWinner) internal {\n    // todo after implementation of PvP\n  }\n  //endregion ------------------------ IUserController\n\n  //region ------------------------ Utils\n  /// @notice Calculate week for the given day. Assume that first day of the week is Monday\n  function getEpochWeek(uint epochDay) internal pure returns (uint32) {\n    return uint32((epochDay + 3) / 7); // + 3 to move start of the first week to Monday 1969-12-29\n  }\n  //endregion ------------------------ Utils\n\n}\n"
    },
    "contracts/nft/HeroBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../nft/NftBase.sol\";\nimport \"../openzeppelin/ERC721Holder.sol\";\nimport \"../interfaces/IHero.sol\";\nimport \"../interfaces/IHeroController.sol\";\nimport \"../interfaces/IStatController.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\n\ncontract HeroBase is NftBase, IHero, ERC721Holder {\n\n  //region ------------------------ Data types and constants\n  /// @custom:storage-location erc7201:hero.base.storage\n  struct HeroBaseStorage {\n    mapping(uint => string) _heroUriByStatus;\n  }\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant override VERSION = \"2.0.1\";\n  // keccak256(abi.encode(uint256(keccak256(\"hero.base.storage\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant HeroBaseStorageLocation = 0xc546abf9ed7c8d4a6ded82a0edfd8f66c8300256eba0932933c3d559a091ea00;\n  uint public constant KILL_PENALTY = 70;\n  //endregion ------------------------ Data types and constants\n\n  //region ------------------------ Initializer\n\n  function init(\n    string memory name_,\n    string memory symbol_,\n    address controller_,\n    string memory uri\n  ) external initializer {\n    __NftBase_init(name_, symbol_, controller_, uri);\n  }\n  //endregion ------------------------ Initializer\n\n  //region ------------------------ Restrictions\n\n  function _beforeTokenTransfer(uint heroId) internal view override {\n    if (\n      ! IHeroController(IController(controller()).heroController()).isAllowedToTransfer(address(this), heroId)\n    ) revert IAppErrors.TokenTransferNotAllowed();\n  }\n  //endregion ------------------------ Restrictions\n\n  //region ------------------------ Views\n\n  function _getHeroBaseStorage() private pure returns (HeroBaseStorage storage $) {\n    assembly {\n      $.slot := HeroBaseStorageLocation\n    }\n    return $;\n  }\n\n  function isHero() external pure override returns (bool) {\n    return true;\n  }\n\n  /// @dev Every 10 levels we can show uniq img\n  function _specificURI(uint heroId) internal view override returns (string memory) {\n    uint level = IStatController(IController(controller()).statController()).heroStats(address(this), heroId).level;\n    if (level / 10 == 0) {\n      return \"\";\n    }\n    return _getHeroBaseStorage()._heroUriByStatus[level / 10];\n  }\n  //endregion ------------------------ Views\n\n  //region ------------------------ Governance actions\n\n  /// @dev Every 10 levels we can show uniq img\n  function setHeroUriByStatus(string memory uri, uint statusLvl) external {\n    onlyDeployer();\n\n    _getHeroBaseStorage()._heroUriByStatus[statusLvl] = uri;\n\n    emit IApplicationEvents.HeroUriByStatusChanged(uri, statusLvl);\n  }\n  //endregion ------------------------ Governance actions\n\n  //region ------------------------ IHero actions\n\n  function mintFor(address recipient) external override returns (uint heroId) {\n    if (IController(controller()).heroController() != msg.sender) revert IAppErrors.ErrorNotHeroController(msg.sender);\n\n    heroId = _incrementAndGetId();\n    _safeMint(recipient, heroId);\n\n    emit IApplicationEvents.HeroMinted(heroId);\n  }\n\n  function burn(uint heroId) external override {\n    if (IController(controller()).heroController() != msg.sender) revert IAppErrors.ErrorNotHeroController(msg.sender);\n\n    _burn(heroId);\n\n    emit IApplicationEvents.HeroBurned(heroId);\n  }\n  //endregion ------------------------ IHero actions\n\n}\n"
    },
    "contracts/nft/ItemBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"./NftBase.sol\";\nimport \"../interfaces/IItem.sol\";\nimport \"../interfaces/IItemController.sol\";\n\n/// @title ItemBase implementation.\n///        All game logic should be placed in dedicated controllers.\ncontract ItemBase is NftBase, IItem {\n\n  //region ------------------------ Data types and constants\n\n  /// @custom:storage-location erc7201:item.base.storage\n  struct ItemBaseStorage {\n    mapping(uint8 => string) itemUriByRarity;\n  }\n\n  /// @notice Version of the contract\n  string public constant VERSION = \"2.0.0\";\n  // keccak256(abi.encode(uint256(keccak256(\"item.base.storage\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant ItemBaseStorageLocation = 0x2dd41482e37d186fdf6545c563673785f2bcb485d6039f6c172d58b496a6e000;\n  //endregion ------------------------ Data types and constants\n\n  //region ------------------------ Initializer\n\n  function init(\n    address controller_,\n    string memory name_,\n    string memory symbol_,\n    string memory uri_\n  ) external initializer {\n    __NftBase_init(name_, symbol_, controller_, uri_);\n  }\n  //endregion ------------------------ Initializer\n\n  //region ------------------------ Restrictions\n\n  function onlyItemController(address itemController, address sender) internal pure {\n    if (itemController != sender) revert IAppErrors.ErrorNotItemController(sender);\n  }\n\n  function _beforeTokenTransfer(uint tokenId) internal view override {\n    if (\n      !IItemController(IController(controller()).itemController()).isAllowedToTransfer(address(this), tokenId)\n    ) revert IAppErrors.EquippedItemIsNotAllowedToTransfer(tokenId);\n  }\n  //endregion ------------------------ Restrictions\n\n  //region ------------------------ Views\n\n  function _getItemBaseStorage() private pure returns (ItemBaseStorage storage $) {\n    assembly {\n      $.slot := ItemBaseStorageLocation\n    }\n    return $;\n  }\n\n  function isItem() external pure override returns (bool) {\n    return true;\n  }\n\n  function _specificURI(uint tokenId) internal view override returns (string memory) {\n    IItemController ic = IItemController(IController(controller()).itemController());\n    return _getItemBaseStorage().itemUriByRarity[uint8(ic.itemInfo(address(this), tokenId).rarity)];\n  }\n  //endregion ------------------------ Views\n\n  //region ------------------------ Gov actions\n\n  function setItemUriByRarity(string memory uri, uint8 rarity) external {\n    onlyDeployer();\n\n    _getItemBaseStorage().itemUriByRarity[rarity] = uri;\n    emit IApplicationEvents.UriByRarityChanged(uri, rarity);\n  }\n  //endregion ------------------------ Gov actions\n\n  //region ------------------------ Actions\n\n  function mintFor(address recipient) external override returns (uint tokenId) {\n    onlyItemController(IController(controller()).itemController(), msg.sender);\n\n    tokenId = _incrementAndGetId();\n    _safeMint(recipient, tokenId);\n\n    emit IApplicationEvents.ItemMinted(tokenId);\n  }\n\n  /// @dev Some stories can destroy items\n  function burn(uint tokenId) external override {\n    onlyItemController(IController(controller()).itemController(), msg.sender);\n\n    _burn(tokenId);\n\n    emit IApplicationEvents.ItemBurned(tokenId);\n  }\n\n  /// @dev Controller can transfer item from one address to another.\n  ///      It must be performed only with properly check requirements.\n  function controlledTransfer(address from, address to, uint tokenId) external override {\n    onlyItemController(IController(controller()).itemController(), msg.sender);\n\n    _safeTransfer(from, to, tokenId);\n  }\n  //endregion ------------------------ Actions\n\n}\n"
    },
    "contracts/nft/NftBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/ERC721EnumerableUpgradeable.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../proxy/Controllable.sol\";\n\nabstract contract NftBase is ERC721EnumerableUpgradeable, Controllable {\n\n  //region ------------------------ Data types and constants\n  /// @custom:storage-location erc7201:nft.base.storage\n  struct NftBaseStorage {\n    uint idCounter;\n    string baseUri;\n    mapping(uint => string) uniqueUri;\n  }\n\n  // keccak256(abi.encode(uint256(keccak256(\"nft.base.storage\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant NftBaseStorageLocation = 0xda2932ada77a3c8131d8c171a8679090714572b6a41aff2e2186c297ac0f5500;\n  //endregion ------------------------ Data types and constants\n\n  //region ------------------------ Initializer\n\n  function __NftBase_init(\n    string memory name_,\n    string memory symbol_,\n    address controller_,\n    string memory uri\n  ) internal onlyInitializing {\n    _init(name_, symbol_, controller_, uri);\n  }\n\n  function _init(\n    string memory name_,\n    string memory symbol_,\n    address controller_,\n    string memory uri\n  ) private {\n    __ERC721_init(name_, symbol_);\n    __Controllable_init(controller_);\n    _getNftBaseStorage().idCounter = 1;\n    _getNftBaseStorage().baseUri = uri;\n    emit IApplicationEvents.BaseUriChanged(uri);\n  }\n\n  function _incrementAndGetId() internal returns (uint){\n    uint id = _getNftBaseStorage().idCounter;\n    // we are using uint64 id, so higher value will overflow in the game logic\n    if (id + 1 >= uint(type(uint64).max)) revert IAppErrors.IdOverflow(id);\n    _getNftBaseStorage().idCounter = id + 1;\n    return id;\n  }\n  //endregion ------------------------ Initializer\n\n  //region ------------------------ Restrictions\n  function onlyDeployer() internal view {\n    if (! IController(controller()).isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\n  }\n  //endregion ------------------------ Restrictions\n\n  //region ------------------------ Views\n\n  function _getNftBaseStorage() private pure returns (NftBaseStorage storage $) {\n    assembly {\n      $.slot := NftBaseStorageLocation\n    }\n    return $;\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    return _getNftBaseStorage().baseUri;\n  }\n\n  function exists(uint tokenId) external view returns (bool) {\n    return _ownerOf(tokenId) != address(0);\n  }\n\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\n    if (tokenId > _getNftBaseStorage().idCounter) revert IAppErrors.NotExistToken(tokenId);\n\n    // unique uri used for concrete tokenId\n    string memory uniqueURI = _getNftBaseStorage().uniqueUri[tokenId];\n    if (bytes(uniqueURI).length != 0) {\n      return uniqueURI;\n    }\n\n    // specific token uri used for group of ids based on nft internal logic (such as item rarity)\n    string memory specificURI = _specificURI(tokenId);\n    if (bytes(specificURI).length != 0) {\n      return specificURI;\n    }\n    return _baseURI();\n  }\n\n  function _specificURI(uint) internal view virtual returns (string memory) {\n    return \"\";\n  }\n\n  function baseURI() external view returns (string memory) {\n    return _baseURI();\n  }\n  //endregion ------------------------ Views\n\n  //region ------------------------ Gov actions\n\n  function setUniqueUri(uint tokenId, string memory uri) external {\n    onlyDeployer();\n    _getNftBaseStorage().uniqueUri[tokenId] = uri;\n    emit IApplicationEvents.UniqueUriChanged(tokenId, uri);\n  }\n\n  function setBaseUri(string memory value) external {\n    onlyDeployer();\n    _getNftBaseStorage().baseUri = value;\n    emit IApplicationEvents.BaseUriChanged(value);\n  }\n  //endregion ------------------------ Gov actions\n\n  //region ------------------------ Internal logic\n\n  function _beforeTokenTransfer(uint tokenId) internal virtual {\n    // noop\n  }\n\n  function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n    _beforeTokenTransfer(tokenId);\n    return super._update(to, tokenId, auth);\n  }\n  //endregion ------------------------ Internal logic\n\n}\n"
    },
    "contracts/openzeppelin/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n  enum RecoverError {\n    NoError,\n    InvalidSignature,\n    InvalidSignatureLength,\n    InvalidSignatureS\n  }\n\n  /**\n   * @dev The signature derives the `address(0)`.\n     */\n  error ECDSAInvalidSignature();\n\n  /**\n   * @dev The signature has an invalid length.\n     */\n  error ECDSAInvalidSignatureLength(uint256 length);\n\n  /**\n   * @dev The signature has an S value that is in the upper half order.\n     */\n  error ECDSAInvalidSignatureS(bytes32 s);\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n  function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      return tryRecover(hash, v, r, s);\n    } else {\n      return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n  function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n    (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n    _throwError(error, errorArg);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\n     */\n  function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n    unchecked {\n      bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    // We do not check for an overflow here since the shift operation results in 0 or 1.\n      uint8 v = uint8((uint256(vs) >> 255) + 27);\n      return tryRecover(hash, v, r, s);\n    }\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n  function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n    (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n    _throwError(error, errorArg);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n  function tryRecover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address, RecoverError, bytes32) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      return (address(0), RecoverError.InvalidSignatureS, s);\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    if (signer == address(0)) {\n      return (address(0), RecoverError.InvalidSignature, bytes32(0));\n    }\n\n    return (signer, RecoverError.NoError, bytes32(0));\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n  function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n    (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n    _throwError(error, errorArg);\n    return recovered;\n  }\n\n  /**\n   * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n  function _throwError(RecoverError error, bytes32 errorArg) private pure {\n    if (error == RecoverError.NoError) {\n      return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n      revert ECDSAInvalidSignature();\n    } else if (error == RecoverError.InvalidSignatureLength) {\n      revert ECDSAInvalidSignatureLength(uint256(errorArg));\n    } else if (error == RecoverError.InvalidSignatureS) {\n      revert ECDSAInvalidSignatureS(errorArg);\n    }\n  }\n}\n"
    },
    "contracts/openzeppelin/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n\n  // To implement this library for multiple types with as little code repetition as possible, we write it in\n  // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n  // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n  // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n  /**\n   * @dev Query for a nonexistent map key.\n     */\n  error EnumerableMapNonexistentKey(bytes32 key);\n\n  struct Bytes32ToBytes32Map {\n    // Storage of keys\n    EnumerableSet.Bytes32Set _keys;\n    mapping(bytes32 key => bytes32) _values;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n    map._values[key] = value;\n    return map._keys.add(key);\n  }\n\n  /**\n   * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n    delete map._values[key];\n    return map._keys.remove(key);\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n    return map._keys.contains(key);\n  }\n\n  /**\n   * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n    return map._keys.length();\n  }\n\n  /**\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n    bytes32 key = map._keys.at(index);\n    return (key, map._values[key]);\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n    bytes32 value = map._values[key];\n    if (value == bytes32(0)) {\n      return (contains(map, key), bytes32(0));\n    } else {\n      return (true, value);\n    }\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    if (value == 0 && !contains(map, key)) {\n      revert EnumerableMapNonexistentKey(key);\n    }\n    return value;\n  }\n\n  /**\n   * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n    return map._keys.values();\n  }\n\n  // UintToUintMap\n\n  struct UintToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n    return set(map._inner, bytes32(key), bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n    return remove(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n    return contains(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(UintToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (uint256(key), uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(key)));\n  }\n\n  /**\n   * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n    bytes32[] memory store = keys(map._inner);\n    uint256[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintToAddressMap\n\n  struct UintToAddressMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n    return remove(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n    return contains(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (uint256(key), address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n    return (success, address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\n  }\n\n  /**\n   * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n    bytes32[] memory store = keys(map._inner);\n    uint256[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // AddressToUintMap\n\n  struct AddressToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n    return remove(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n    return contains(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (address(uint160(uint256(key))), uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n  }\n\n  /**\n   * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n    bytes32[] memory store = keys(map._inner);\n    address[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // Bytes32ToUintMap\n\n  struct Bytes32ToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n    return set(map._inner, key, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n    return remove(map._inner, key);\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n    return contains(map._inner, key);\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (key, uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, key);\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n    return uint256(get(map._inner, key));\n  }\n\n  /**\n   * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n    bytes32[] memory store = keys(map._inner);\n    bytes32[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "contracts/openzeppelin/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position is the index of the value in the `values` array plus 1.\n    // Position 0 is used to mean a value is not in the set.\n    mapping(bytes32 value => uint256) _positions;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._positions[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We cache the value's position to prevent multiple reads from the same storage slot\n    uint256 position = set._positions[value];\n\n    if (position != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 valueIndex = position - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (valueIndex != lastIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the lastValue to the index where the value to delete is\n        set._values[valueIndex] = lastValue;\n        // Update the tracked position of the lastValue (that was just moved)\n        set._positions[lastValue] = position;\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the tracked position for the deleted slot\n      delete set._positions[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._positions[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n     */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    bytes32[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "contracts/openzeppelin/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n     */\n  function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "contracts/openzeppelin/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"../interfaces/IERC20Errors.sol\";\nimport \"../relay/ERC2771Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the ERC may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is ERC2771Context, IERC20, IERC20Metadata, IERC20Errors {\n  mapping(address account => uint256) private _balances;\n\n  mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n     */\n  function name() public view virtual returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n  function symbol() public view virtual returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n  function decimals() public view virtual returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n     */\n  function totalSupply() public view virtual returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n     */\n  function balanceOf(address account) public view virtual returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n  function transfer(address to, uint256 value) public virtual returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, value);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n     */\n  function allowance(address owner, address spender) public view virtual returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n  function approve(address spender, uint256 value) public virtual returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the ERC. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n  function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, value);\n    _transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n  function _transfer(address from, address to, uint256 value) internal {\n    if (from == address(0)) {\n      revert ERC20InvalidSender(address(0));\n    }\n    if (to == address(0)) {\n      revert ERC20InvalidReceiver(address(0));\n    }\n    _update(from, to, value);\n  }\n\n  /**\n   * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n  function _update(address from, address to, uint256 value) internal virtual {\n    if (from == address(0)) {\n      // Overflow check required: The rest of the code assumes that totalSupply never overflows\n      _totalSupply += value;\n    } else {\n      uint256 fromBalance = _balances[from];\n      if (fromBalance < value) {\n        revert ERC20InsufficientBalance(from, fromBalance, value);\n      }\n      unchecked {\n      // Overflow not possible: value <= fromBalance <= totalSupply.\n        _balances[from] = fromBalance - value;\n      }\n    }\n\n    if (to == address(0)) {\n      unchecked {\n      // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n        _totalSupply -= value;\n      }\n    } else {\n      unchecked {\n      // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n        _balances[to] += value;\n      }\n    }\n\n    emit Transfer(from, to, value);\n  }\n\n  /**\n   * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n  function _mint(address account, uint256 value) internal {\n    if (account == address(0)) {\n      revert ERC20InvalidReceiver(address(0));\n    }\n    _update(address(0), account, value);\n  }\n\n  /**\n   * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n  function _burn(address account, uint256 value) internal {\n    if (account == address(0)) {\n      revert ERC20InvalidSender(address(0));\n    }\n    _update(account, address(0), value);\n  }\n\n  /**\n   * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n  function _approve(address owner, address spender, uint256 value) internal {\n    _approve(owner, spender, value, true);\n  }\n\n  /**\n   * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n  function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n    if (owner == address(0)) {\n      revert ERC20InvalidApprover(address(0));\n    }\n    if (spender == address(0)) {\n      revert ERC20InvalidSpender(address(0));\n    }\n    _allowances[owner][spender] = value;\n    if (emitEvent) {\n      emit Approval(owner, spender, value);\n    }\n  }\n\n  /**\n   * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n  function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      if (currentAllowance < value) {\n        revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n      }\n      unchecked {\n        _approve(owner, spender, currentAllowance - value, false);\n      }\n    }\n  }\n}\n"
    },
    "contracts/openzeppelin/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport \"./ERC721Upgradeable.sol\";\nimport \"../interfaces/IERC721Enumerable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the ERC that adds enumerability\n * of all the token ids in the contract as well as all token ids owned by each account.\n *\n * CAUTION: {ERC721} extensions that implement custom `balanceOf` logic, such as {ERC721Consecutive},\n * interfere with enumerability and should not be used together with {ERC721Enumerable}.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721Enumerable {\n  /// @custom:storage-location erc7201:openzeppelin.storage.ERC721Enumerable\n  struct ERC721EnumerableStorage {\n    mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n    mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n\n    uint256[] _allTokens;\n    mapping(uint256 tokenId => uint256) _allTokensIndex;\n  }\n\n  // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721Enumerable\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n\n  function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n    assembly {\n      $.slot := ERC721EnumerableStorageLocation\n    }\n    return $;\n  }\n\n  /**\n   * @dev An `owner`'s token query was out of bounds for `index`.\n     *\n     * NOTE: The owner being `address(0)` indicates a global out of bounds index.\n     */\n  error ERC721OutOfBoundsIndex(address owner, uint256 index);\n\n  /**\n   * @dev Batch mint is not allowed.\n     */\n  error ERC721EnumerableForbiddenBatchMint();\n\n  function __ERC721Enumerable_init() internal onlyInitializing {\n  }\n\n  function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n  }\n  /**\n   * @dev See {IERC165-supportsInterface}.\n     */\n  function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n    return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n  function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n    ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n    if (index >= balanceOf(owner)) {\n      revert ERC721OutOfBoundsIndex(owner, index);\n    }\n    return $._ownedTokens[owner][index];\n  }\n\n  /**\n   * @dev See {IERC721Enumerable-totalSupply}.\n     */\n  function totalSupply() public view virtual returns (uint256) {\n    ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n    return $._allTokens.length;\n  }\n\n  /**\n   * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n  function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n    ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n    if (index >= totalSupply()) {\n      revert ERC721OutOfBoundsIndex(address(0), index);\n    }\n    return $._allTokens[index];\n  }\n\n  /**\n   * @dev See {ERC721-_update}.\n     */\n  function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n    address previousOwner = super._update(to, tokenId, auth);\n\n    if (previousOwner == address(0)) {\n      _addTokenToAllTokensEnumeration(tokenId);\n    } else if (previousOwner != to) {\n      _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n    }\n    if (to == address(0)) {\n      _removeTokenFromAllTokensEnumeration(tokenId);\n    } else if (previousOwner != to) {\n      _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    return previousOwner;\n  }\n\n  /**\n   * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n  function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n    ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n    uint256 length = balanceOf(to) - 1;\n    $._ownedTokens[to][length] = tokenId;\n    $._ownedTokensIndex[tokenId] = length;\n  }\n\n  /**\n   * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n  function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n    ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n    $._allTokensIndex[tokenId] = $._allTokens.length;\n    $._allTokens.push(tokenId);\n  }\n\n  /**\n   * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n  function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n    ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n    // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n    // then delete the last slot (swap and pop).\n\n    uint256 lastTokenIndex = balanceOf(from);\n    uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n\n    // When the token to delete is the last token, the swap operation is unnecessary\n    if (tokenIndex != lastTokenIndex) {\n      uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n\n      $._ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n      $._ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n    }\n\n    // This also deletes the contents at the last position of the array\n    delete $._ownedTokensIndex[tokenId];\n    delete $._ownedTokens[from][lastTokenIndex];\n  }\n\n  /**\n   * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n  function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n    ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n    // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n    // then delete the last slot (swap and pop).\n\n    uint256 lastTokenIndex = $._allTokens.length - 1;\n    uint256 tokenIndex = $._allTokensIndex[tokenId];\n\n    // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n    // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n    // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n    uint256 lastTokenId = $._allTokens[lastTokenIndex];\n\n    $._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n    $._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n    // This also deletes the contents at the last position of the array\n    delete $._allTokensIndex[tokenId];\n    $._allTokens.pop();\n  }\n\n  /**\n   * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch\n   */\n  function _increaseBalance(address account, uint128 amount) internal virtual override {\n    if (amount > 0) {\n      revert ERC721EnumerableForbiddenBatchMint();\n    }\n    super._increaseBalance(account, amount);\n  }\n}\n"
    },
    "contracts/openzeppelin/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n  /**\n   * @dev See {IERC721Receiver-onERC721Received}.\n   *\n   * Always returns `IERC721Receiver.onERC721Received.selector`.\n   */\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) public virtual override returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n}\n"
    },
    "contracts/openzeppelin/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IERC721Receiver.sol\";\nimport \"../interfaces/IERC721Metadata.sol\";\nimport \"../interfaces/IERC721Errors.sol\";\nimport \"./Strings.sol\";\nimport \"./ERC165.sol\";\nimport \"./Initializable.sol\";\nimport \"../relay/ERC2771Context.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC-721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721Upgradeable is Initializable, ERC2771Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n  using Strings for uint256;\n\n  /// @custom:storage-location erc7201:openzeppelin.storage.ERC721\n  struct ERC721Storage {\n    // Token name\n    string _name;\n\n    // Token symbol\n    string _symbol;\n\n    mapping(uint256 tokenId => address) _owners;\n\n    mapping(address owner => uint256) _balances;\n\n    mapping(uint256 tokenId => address) _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n  }\n\n  // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n\n  function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n    assembly {\n      $.slot := ERC721StorageLocation\n    }\n    return $;\n  }\n\n  /**\n   * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n  function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n    __ERC721_init_unchained(name_, symbol_);\n  }\n\n  function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n    ERC721Storage storage $ = _getERC721Storage();\n    $._name = name_;\n    $._symbol = symbol_;\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n     */\n  function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n    return\n      interfaceId == type(IERC721).interfaceId ||\n      interfaceId == type(IERC721Metadata).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev See {IERC721-balanceOf}.\n     */\n  function balanceOf(address owner) public view virtual returns (uint256) {\n    ERC721Storage storage $ = _getERC721Storage();\n    if (owner == address(0)) {\n      revert ERC721InvalidOwner(address(0));\n    }\n    return $._balances[owner];\n  }\n\n  /**\n   * @dev See {IERC721-ownerOf}.\n     */\n  function ownerOf(uint256 tokenId) public view virtual returns (address) {\n    return _requireOwned(tokenId);\n  }\n\n  /**\n   * @dev See {IERC721Metadata-name}.\n     */\n  function name() public view virtual returns (string memory) {\n    ERC721Storage storage $ = _getERC721Storage();\n    return $._name;\n  }\n\n  /**\n   * @dev See {IERC721Metadata-symbol}.\n     */\n  function symbol() public view virtual returns (string memory) {\n    ERC721Storage storage $ = _getERC721Storage();\n    return $._symbol;\n  }\n\n  /**\n   * @dev See {IERC721Metadata-tokenURI}.\n     */\n  function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n    _requireOwned(tokenId);\n\n    string memory baseURI = _baseURI();\n    return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n  }\n\n  /**\n   * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n  function _baseURI() internal view virtual returns (string memory) {\n    return \"\";\n  }\n\n  /**\n   * @dev See {IERC721-approve}.\n     */\n  function approve(address to, uint256 tokenId) public virtual {\n    _approve(to, tokenId, _msgSender());\n  }\n\n  /**\n   * @dev See {IERC721-getApproved}.\n     */\n  function getApproved(uint256 tokenId) public view virtual returns (address) {\n    _requireOwned(tokenId);\n\n    return _getApproved(tokenId);\n  }\n\n  /**\n   * @dev See {IERC721-setApprovalForAll}.\n     */\n  function setApprovalForAll(address operator, bool approved) public virtual {\n    _setApprovalForAll(_msgSender(), operator, approved);\n  }\n\n  /**\n   * @dev See {IERC721-isApprovedForAll}.\n     */\n  function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n    ERC721Storage storage $ = _getERC721Storage();\n    return $._operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev See {IERC721-transferFrom}.\n     */\n  function transferFrom(address from, address to, uint256 tokenId) public virtual {\n    if (to == address(0)) {\n      revert ERC721InvalidReceiver(address(0));\n    }\n    // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n    // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n    address previousOwner = _update(to, tokenId, _msgSender());\n    if (previousOwner != from) {\n      revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n    }\n  }\n\n  /**\n   * @dev See {IERC721-safeTransferFrom}.\n     */\n  function safeTransferFrom(address from, address to, uint256 tokenId) public {\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev See {IERC721-safeTransferFrom}.\n     */\n  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n    transferFrom(from, to, tokenId);\n    _checkOnERC721Received(from, to, tokenId, data);\n  }\n\n  /**\n   * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n  function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n    ERC721Storage storage $ = _getERC721Storage();\n    return $._owners[tokenId];\n  }\n\n  /**\n   * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n  function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n    ERC721Storage storage $ = _getERC721Storage();\n    return $._tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n  function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n    return\n      spender != address(0) &&\n      (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n  }\n\n  /**\n   * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n  function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n    if (!_isAuthorized(owner, spender, tokenId)) {\n      if (owner == address(0)) {\n        revert ERC721NonexistentToken(tokenId);\n      } else {\n        revert ERC721InsufficientApproval(spender, tokenId);\n      }\n    }\n  }\n\n  /**\n   * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n  function _increaseBalance(address account, uint128 value) internal virtual {\n    ERC721Storage storage $ = _getERC721Storage();\n    unchecked {\n      $._balances[account] += value;\n    }\n  }\n\n  /**\n   * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n  function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n    ERC721Storage storage $ = _getERC721Storage();\n    address from = _ownerOf(tokenId);\n\n    // Perform (optional) operator check\n    if (auth != address(0)) {\n      _checkAuthorized(from, auth, tokenId);\n    }\n\n    // Execute the update\n    if (from != address(0)) {\n      // Clear approval. No need to re-authorize or emit the Approval event\n      _approve(address(0), tokenId, address(0), false);\n\n      unchecked {\n        $._balances[from] -= 1;\n      }\n    }\n\n    if (to != address(0)) {\n      unchecked {\n        $._balances[to] += 1;\n      }\n    }\n\n    $._owners[tokenId] = to;\n\n    emit Transfer(from, to, tokenId);\n\n    return from;\n  }\n\n  /**\n   * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n  function _mint(address to, uint256 tokenId) internal {\n    if (to == address(0)) {\n      revert ERC721InvalidReceiver(address(0));\n    }\n    address previousOwner = _update(to, tokenId, address(0));\n    if (previousOwner != address(0)) {\n      revert ERC721InvalidSender(address(0));\n    }\n  }\n\n  /**\n   * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n  function _safeMint(address to, uint256 tokenId) internal {\n    _safeMint(to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n  function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n    _mint(to, tokenId);\n    _checkOnERC721Received(address(0), to, tokenId, data);\n  }\n\n  /**\n   * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n  function _burn(uint256 tokenId) internal {\n    address previousOwner = _update(address(0), tokenId, address(0));\n    if (previousOwner == address(0)) {\n      revert ERC721NonexistentToken(tokenId);\n    }\n  }\n\n  /**\n   * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n  function _transfer(address from, address to, uint256 tokenId) internal {\n    if (to == address(0)) {\n      revert ERC721InvalidReceiver(address(0));\n    }\n    address previousOwner = _update(to, tokenId, address(0));\n    if (previousOwner == address(0)) {\n      revert ERC721NonexistentToken(tokenId);\n    } else if (previousOwner != from) {\n      revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n    }\n  }\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC-721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n  function _safeTransfer(address from, address to, uint256 tokenId) internal {\n    _safeTransfer(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n  function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n    _transfer(from, to, tokenId);\n    _checkOnERC721Received(from, to, tokenId, data);\n  }\n\n  /**\n   * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n  function _approve(address to, uint256 tokenId, address auth) internal {\n    _approve(to, tokenId, auth, true);\n  }\n\n  /**\n   * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n  function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n    ERC721Storage storage $ = _getERC721Storage();\n    // Avoid reading the owner unless necessary\n    if (emitEvent || auth != address(0)) {\n      address owner = _requireOwned(tokenId);\n\n      // We do not use _isAuthorized because single-token approvals should not be able to call approve\n      if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n        revert ERC721InvalidApprover(auth);\n      }\n\n      if (emitEvent) {\n        emit Approval(owner, to, tokenId);\n      }\n    }\n\n    $._tokenApprovals[tokenId] = to;\n  }\n\n  /**\n   * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n  function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n    ERC721Storage storage $ = _getERC721Storage();\n    if (operator == address(0)) {\n      revert ERC721InvalidOperator(operator);\n    }\n    $._operatorApprovals[owner][operator] = approved;\n    emit ApprovalForAll(owner, operator, approved);\n  }\n\n  /**\n   * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n  function _requireOwned(uint256 tokenId) internal view returns (address) {\n    address owner = _ownerOf(tokenId);\n    if (owner == address(0)) {\n      revert ERC721NonexistentToken(tokenId);\n    }\n    return owner;\n  }\n\n  /**\n   * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n  function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n    if (to.code.length > 0) {\n      try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n        if (retval != IERC721Receiver.onERC721Received.selector) {\n          revert ERC721InvalidReceiver(to);\n        }\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert ERC721InvalidReceiver(to);\n        } else {\n          /// @solidity memory-safe-assembly\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    }\n  }\n}\n"
    },
    "contracts/openzeppelin/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n  /**\n   * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n  struct InitializableStorage {\n    /**\n     * @dev Indicates that the contract has been initialized.\n         */\n    uint64 _initialized;\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n         */\n    bool _initializing;\n  }\n\n  // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n  /**\n   * @dev The contract is already initialized.\n     */\n  error InvalidInitialization();\n\n  /**\n   * @dev The contract is not initializing.\n     */\n  error NotInitializing();\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n  event Initialized(uint64 version);\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier initializer() {\n    // solhint-disable-next-line var-name-mixedcase\n    InitializableStorage storage $ = _getInitializableStorage();\n\n    // Cache values to avoid duplicated sloads\n    bool isTopLevelCall = !$._initializing;\n    uint64 initialized = $._initialized;\n\n    // Allowed calls:\n    // - initialSetup: the contract is not in the initializing state and no previous version was\n    //                 initialized\n    // - construction: the contract is initialized at version 1 (no reininitialization) and the\n    //                 current contract is just being deployed\n    bool initialSetup = initialized == 0 && isTopLevelCall;\n    bool construction = initialized == 1 && address(this).code.length == 0;\n\n    if (!initialSetup && !construction) {\n      revert InvalidInitialization();\n    }\n    $._initialized = 1;\n    if (isTopLevelCall) {\n      $._initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      $._initializing = false;\n      emit Initialized(1);\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier reinitializer(uint64 version) {\n    // solhint-disable-next-line var-name-mixedcase\n    InitializableStorage storage $ = _getInitializableStorage();\n\n    if ($._initializing || $._initialized >= version) {\n      revert InvalidInitialization();\n    }\n    $._initialized = version;\n    $._initializing = true;\n    _;\n    $._initializing = false;\n    emit Initialized(version);\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n  modifier onlyInitializing() {\n    _checkInitializing();\n    _;\n  }\n\n  /**\n   * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n  function _checkInitializing() internal view virtual {\n    if (!_isInitializing()) {\n      revert NotInitializing();\n    }\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n  function _disableInitializers() internal virtual {\n    // solhint-disable-next-line var-name-mixedcase\n    InitializableStorage storage $ = _getInitializableStorage();\n\n    if ($._initializing) {\n      revert InvalidInitialization();\n    }\n    if ($._initialized != type(uint64).max) {\n      $._initialized = type(uint64).max;\n      emit Initialized(type(uint64).max);\n    }\n  }\n\n  /**\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n  function _getInitializedVersion() internal view returns (uint64) {\n    return _getInitializableStorage()._initialized;\n  }\n\n  /**\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n  function _isInitializing() internal view returns (bool) {\n    return _getInitializableStorage()._initializing;\n  }\n\n  /**\n   * @dev Returns a pointer to the storage namespace.\n     */\n  // solhint-disable-next-line var-name-mixedcase\n  function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n    assembly {\n      $.slot := INITIALIZABLE_STORAGE\n    }\n  }\n}\n"
    },
    "contracts/openzeppelin/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n\n  /**\n    * @dev Muldiv operation overflow.\n   */\n  error MathOverflowedMulDiv();\n\n  enum Rounding {\n    Floor, // Toward negative infinity\n    Ceil, // Toward positive infinity\n    Trunc, // Toward zero\n    Expand // Away from zero\n  }\n\n  /**\n   * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n    unchecked {\n      uint256 c = a + b;\n      if (c < a) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n  function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n    unchecked {\n      if (b > a) return (false, 0);\n      return (true, a - b);\n    }\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n    unchecked {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n      if (a == 0) return (true, 0);\n      uint256 c = a * b;\n      if (c / a != b) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a / b);\n    }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a % b);\n    }\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n     */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n     */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (b == 0) {\n      // Guarantee the same behavior as in a regular Solidity division.\n      return a / b;\n    }\n\n    // The following calculation ensures accurate ceiling division without overflow.\n    // Since a is non-zero, (a - 1) / b will not overflow.\n    // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n    // but the largest value we can obtain is type(uint256).max - 1, which happens\n    // when a = type(uint256).max and b = 1.\n    unchecked {\n      return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n    unchecked {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n      uint256 prod0 = x * y; // Least significant 256 bits of the product\n      uint256 prod1; // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(x, y, not(0))\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n    // Handle non-overflow cases, 256 by 256 division.\n      if (prod1 == 0) {\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n        // The surrounding unchecked block does not change this fact.\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n        return prod0 / denominator;\n      }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n      if (denominator <= prod1) {\n        revert MathOverflowedMulDiv();\n      }\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n      uint256 remainder;\n      assembly {\n      // Compute remainder using mulmod.\n        remainder := mulmod(x, y, denominator)\n\n      // Subtract 256 bit number from 512 bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n    // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n      uint256 twos = denominator & (0 - denominator);\n      assembly {\n      // Divide denominator by twos.\n        denominator := div(denominator, twos)\n\n      // Divide [prod1 prod0] by twos.\n        prod0 := div(prod0, twos)\n\n      // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n\n    // Shift in bits from prod1 into prod0.\n      prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n    // four bits. That is, denominator * inv = 1 mod 2^4.\n      uint256 inverse = (3 * denominator) ^ 2;\n\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n    // works in modular arithmetic, doubling the correct bits in each step.\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n      result = prod0 * inverse;\n      return result;\n    }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n    unchecked {\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      return min(result, a / result);\n    }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = sqrt(a);\n      return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >> 128 > 0) {\n        value >>= 128;\n        result += 128;\n      }\n      if (value >> 64 > 0) {\n        value >>= 64;\n        result += 64;\n      }\n      if (value >> 32 > 0) {\n        value >>= 32;\n        result += 32;\n      }\n      if (value >> 16 > 0) {\n        value >>= 16;\n        result += 16;\n      }\n      if (value >> 8 > 0) {\n        value >>= 8;\n        result += 8;\n      }\n      if (value >> 4 > 0) {\n        value >>= 4;\n        result += 4;\n      }\n      if (value >> 2 > 0) {\n        value >>= 2;\n        result += 2;\n      }\n      if (value >> 1 > 0) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log2(value);\n      return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >= 10 ** 64) {\n        value /= 10 ** 64;\n        result += 64;\n      }\n      if (value >= 10 ** 32) {\n        value /= 10 ** 32;\n        result += 32;\n      }\n      if (value >= 10 ** 16) {\n        value /= 10 ** 16;\n        result += 16;\n      }\n      if (value >= 10 ** 8) {\n        value /= 10 ** 8;\n        result += 8;\n      }\n      if (value >= 10 ** 4) {\n        value /= 10 ** 4;\n        result += 4;\n      }\n      if (value >= 10 ** 2) {\n        value /= 10 ** 2;\n        result += 2;\n      }\n      if (value >= 10 ** 1) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log10(value);\n      return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >> 128 > 0) {\n        value >>= 128;\n        result += 16;\n      }\n      if (value >> 64 > 0) {\n        value >>= 64;\n        result += 8;\n      }\n      if (value >> 32 > 0) {\n        value >>= 32;\n        result += 4;\n      }\n      if (value >> 16 > 0) {\n        value >>= 16;\n        result += 2;\n      }\n      if (value >> 8 > 0) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log256(value);\n      return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n  function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n    return uint8(rounding) % 2 == 1;\n  }\n\n}\n"
    },
    "contracts/openzeppelin/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n  /**\n   *@dev The multiproof provided is not valid.\n     */\n  error MerkleProofInvalidMultiproof();\n\n  /**\n   * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n  function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n    return processProof(proof, leaf) == root;\n  }\n\n  /**\n   * @dev Calldata version of {verify}\n     */\n  function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n    return processProofCalldata(proof, leaf) == root;\n  }\n\n  /**\n   * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n  function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n      computedHash = _hashPair(computedHash, proof[i]);\n    }\n    return computedHash;\n  }\n\n  /**\n   * @dev Calldata version of {processProof}\n     */\n  function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n      computedHash = _hashPair(computedHash, proof[i]);\n    }\n    return computedHash;\n  }\n\n  /**\n   * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n  function multiProofVerify(\n    bytes32[] memory proof,\n    bool[] memory proofFlags,\n    bytes32 root,\n    bytes32[] memory leaves\n  ) internal pure returns (bool) {\n    return processMultiProof(proof, proofFlags, leaves) == root;\n  }\n\n  /**\n   * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n  function multiProofVerifyCalldata(\n    bytes32[] calldata proof,\n    bool[] calldata proofFlags,\n    bytes32 root,\n    bytes32[] memory leaves\n  ) internal pure returns (bool) {\n    return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n  }\n\n  /**\n   * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n  function processMultiProof(\n    bytes32[] memory proof,\n    bool[] memory proofFlags,\n    bytes32[] memory leaves\n  ) internal pure returns (bytes32 merkleRoot) {\n    // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n    // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n    // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n    // the Merkle tree.\n    uint256 leavesLen = leaves.length;\n    uint256 proofLen = proof.length;\n    uint256 totalHashes = proofFlags.length;\n\n    // Check proof validity.\n    if (leavesLen + proofLen != totalHashes + 1) {\n      revert MerkleProofInvalidMultiproof();\n    }\n\n    // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n    // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n    bytes32[] memory hashes = new bytes32[](totalHashes);\n    uint256 leafPos = 0;\n    uint256 hashPos = 0;\n    uint256 proofPos = 0;\n    // At each step, we compute the next hash using two values:\n    // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n    //   get the next hash.\n    // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n    //   `proof` array.\n    for (uint256 i = 0; i < totalHashes; i++) {\n      bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      bytes32 b = proofFlags[i]\n        ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n        : proof[proofPos++];\n      hashes[i] = _hashPair(a, b);\n    }\n\n    if (totalHashes > 0) {\n      if (proofPos != proofLen) {\n        revert MerkleProofInvalidMultiproof();\n      }\n      unchecked {\n        return hashes[totalHashes - 1];\n      }\n    } else if (leavesLen > 0) {\n      return leaves[0];\n    } else {\n      return proof[0];\n    }\n  }\n\n  /**\n   * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n  function processMultiProofCalldata(\n    bytes32[] calldata proof,\n    bool[] calldata proofFlags,\n    bytes32[] memory leaves\n  ) internal pure returns (bytes32 merkleRoot) {\n    // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n    // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n    // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n    // the Merkle tree.\n    uint256 leavesLen = leaves.length;\n    uint256 proofLen = proof.length;\n    uint256 totalHashes = proofFlags.length;\n\n    // Check proof validity.\n    if (leavesLen + proofLen != totalHashes + 1) {\n      revert MerkleProofInvalidMultiproof();\n    }\n\n    // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n    // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n    bytes32[] memory hashes = new bytes32[](totalHashes);\n    uint256 leafPos = 0;\n    uint256 hashPos = 0;\n    uint256 proofPos = 0;\n    // At each step, we compute the next hash using two values:\n    // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n    //   get the next hash.\n    // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n    //   `proof` array.\n    for (uint256 i = 0; i < totalHashes; i++) {\n      bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      bytes32 b = proofFlags[i]\n        ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n        : proof[proofPos++];\n      hashes[i] = _hashPair(a, b);\n    }\n\n    if (totalHashes > 0) {\n      if (proofPos != proofLen) {\n        revert MerkleProofInvalidMultiproof();\n      }\n      unchecked {\n        return hashes[totalHashes - 1];\n      }\n    } else if (leavesLen > 0) {\n      return leaves[0];\n    } else {\n      return proof[0];\n    }\n  }\n\n  /**\n   * @dev Sorts the pair (a, b) and hashes the result.\n     */\n  function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n    return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n  }\n\n  /**\n   * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n  function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x00, a)\n      mstore(0x20, b)\n      value := keccak256(0x00, 0x40)\n    }\n  }\n}\n"
    },
    "contracts/openzeppelin/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n   *\n   * This function does not return to its internall call site, it will return directly to the external caller.\n   */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n    // Copy msg.data. We take full control of memory in this inline assembly\n    // block because it will not return to Solidity code. We overwrite the\n    // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n    // Call the implementation.\n    // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n    // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return (0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n   *\n   * This function does not return to its internall call site, it will return directly to the external caller.\n   */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n   * is empty.\n   */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n   * call, or as part of the Solidity `fallback` or `receive` functions.\n   *\n   * If overriden should call `super._beforeFallback()`.\n   */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/openzeppelin/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n  /**\n   * @dev Returns the largest of two signed numbers.\n     */\n  function max(int256 a, int256 b) internal pure returns (int256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two signed numbers.\n     */\n  function min(int256 a, int256 b) internal pure returns (int256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n  function average(int256 a, int256 b) internal pure returns (int256) {\n    // Formula from the book \"Hacker's Delight\"\n    int256 x = (a & b) + ((a ^ b) >> 1);\n    return x + (int256(uint256(x) >> 255) & (a ^ b));\n  }\n\n  /**\n   * @dev Returns the absolute unsigned value of a signed value.\n     */\n  function abs(int256 n) internal pure returns (uint256) {\n    unchecked {\n    // must be unchecked in order to support `n = type(int256).min`\n      return uint256(n >= 0 ? n : -n);\n    }\n  }\n}\n"
    },
    "contracts/openzeppelin/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport \"./Math.sol\";\nimport \"./SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n  uint8 private constant ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev The `value` string doesn't fit in the specified `length`.\n     */\n  error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n  function toString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n      uint256 length = Math.log10(value) + 1;\n      string memory buffer = new string(length);\n      uint256 ptr;\n    /// @solidity memory-safe-assembly\n      assembly {\n        ptr := add(buffer, add(32, length))\n      }\n      while (true) {\n        ptr--;\n        /// @solidity memory-safe-assembly\n        assembly {\n          mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n        }\n        value /= 10;\n        if (value == 0) break;\n      }\n      return buffer;\n    }\n  }\n\n  /**\n   * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n  function toStringSigned(int256 value) internal pure returns (string memory) {\n    return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n      return toHexString(value, Math.log256(value) + 1);\n    }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    uint256 localValue = value;\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = HEX_DIGITS[localValue & 0xf];\n      localValue >>= 4;\n    }\n    if (localValue != 0) {\n      revert StringsInsufficientHexLength(value, length);\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n  }\n\n  /**\n   * @dev Returns true if the two strings are equal.\n     */\n  function equal(string memory a, string memory b) internal pure returns (bool) {\n    return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n  }\n}\n"
    },
    "contracts/proxy/Controllable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../lib/SlotsLib.sol\";\n\n/// @title Implement basic functionality for any contract that require strict control\n/// @dev Can be used with upgradeable pattern.\n///      Require call __Controllable_init() in any case.\n/// @author belbix\nabstract contract Controllable is Initializable, IControllable {\n  using SlotsLib for bytes32;\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant CONTROLLABLE_VERSION = \"1.0.0\";\n\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.controller\")) - 1);\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created\")) - 1);\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created_block\")) - 1);\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.revision\")) - 1);\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.prev_logic\")) - 1);\n\n  event ContractInitialized(address controller, uint ts, uint block);\n  event RevisionIncreased(uint value, address oldLogic);\n\n  // init implementation contract\n  constructor() initializer {}\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  ///         Save block.timestamp in the \"created\" variable\n  /// @dev Use it only once after first logic setup\n  /// @param controller_ Controller address\n  function __Controllable_init(address controller_) internal onlyInitializing {\n    _init(controller_);\n  }\n\n  function _init(address controller_) private {\n    require(controller_ != address(0), \"Zero controller\");\n    _CONTROLLER_SLOT.set(controller_);\n    _CREATED_SLOT.set(block.timestamp);\n    _CREATED_BLOCK_SLOT.set(block.number);\n    emit ContractInitialized(controller_, block.timestamp, block.number);\n  }\n\n  /// @dev Return true if given address is controller\n  function isController(address value_) public override view returns (bool) {\n    return value_ == controller();\n  }\n\n  /// @notice Return true if given address is setup as governance in Controller\n  function isGovernance(address value_) public override view returns (bool) {\n    return IController(controller()).governance() == value_;\n  }\n\n  /// @dev Contract upgrade counter\n  function revision() external view override returns (uint) {\n    return _REVISION_SLOT.getUint();\n  }\n\n  /// @dev Previous logic implementation\n  function previousImplementation() external view override returns (address) {\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\n  }\n\n  // ************* SETTERS/GETTERS *******************\n\n  /// @notice Return controller address saved in the contract slot\n  function controller() public view override returns (address) {\n    return _CONTROLLER_SLOT.getAddress();\n  }\n\n  /// @notice Return creation timestamp\n  /// @return Creation timestamp\n  function created() external view override returns (uint256) {\n    return _CREATED_SLOT.getUint();\n  }\n\n  /// @notice Return creation block number\n  /// @return Creation block number\n  function createdBlock() external override view returns (uint256) {\n    return _CREATED_BLOCK_SLOT.getUint();\n  }\n\n  /// @dev Revision should be increased on each contract upgrade\n  function increaseRevision(address oldLogic) external override {\n    require(msg.sender == address(this), \"Increase revision forbidden\");\n    uint r = _REVISION_SLOT.getUint() + 1;\n    _REVISION_SLOT.set(r);\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\n    emit RevisionIncreased(r, oldLogic);\n  }\n\n}\n"
    },
    "contracts/proxy/ProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\n\nimport \"./UpgradeableProxy.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\n\n/// @title EIP1967 Upgradable proxy implementation.\n/// @dev Only Controller has access and should implement time-lock for upgrade action.\n/// @author belbix\ncontract ProxyControlled is UpgradeableProxy, IProxyControlled {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant PROXY_CONTROLLED_VERSION = \"1.0.0\";\n\n\n  constructor(address _logic) UpgradeableProxy(_logic) {\n    //make sure that given logic is controllable\n    require(IControllable(_logic).created() >= 0);\n  }\n\n  /// @notice Upgrade contract logic\n  /// @dev Upgrade allowed only for Controller and should be done only after time-lock period\n  /// @param newImplementation_ Implementation address\n  function upgrade(address newImplementation_) external override {\n    require(IControllable(address(this)).isController(msg.sender), \"Proxy: Forbidden\");\n    IControllable(address(this)).increaseRevision(_implementation());\n    _upgradeTo(newImplementation_);\n    // the new contract must have the same ABI and you must have the power to change it again\n    require(IControllable(address(this)).isController(msg.sender), \"Proxy: Wrong implementation\");\n  }\n\n  /// @notice Return current logic implementation\n  function implementation() external override view returns (address) {\n    return _implementation();\n  }\n}\n"
    },
    "contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/Proxy.sol\";\n\n/// @title OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/proxy/UpgradeableProxy.sol\n/// @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n///      implementation address that can be changed. This address is stored in storage in the location specified by\n///      https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n///      implementation behind the proxy.\n///      Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n///      {TransparentUpgradeableProxy}.\nabstract contract UpgradeableProxy is Proxy {\n\n  /// @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n  ///      If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n  ///      function call, and allows initializating the storage of the proxy like a Solidity constructor.\n  constructor(address _logic) payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    _setImplementation(_logic);\n  }\n\n  /// @dev Emitted when the implementation is upgraded.\n  event Upgraded(address indexed implementation);\n\n  ///@dev Storage slot with the address of the current implementation.\n  ///     This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n  ///     validated in the constructor.\n  bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /// @dev Returns the current implementation address.\n  function _implementation() internal view virtual override returns (address impl) {\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /// @dev Upgrades the proxy to a new implementation.\n  ///      Emits an {Upgraded} event.\n  function _upgradeTo(address newImplementation) internal virtual {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /// @dev Stores a new address in the EIP1967 implementation slot.\n  function _setImplementation(address newImplementation) private {\n    require(newImplementation.code.length != 0, \"UpgradeableProxy: new implementation is not a contract\");\n\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "contracts/relay/ERC20Wrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/ERC20.sol\";\n\ncontract ERC20Wrapper is ERC20 {\n\n  address public immutable asset;\n\n  constructor(string memory name_, string memory symbol_, address _asset) ERC20(name_, symbol_){\n    asset = _asset;\n  }\n\n  function mint(address to, uint amount) external {\n    _mint(to, amount);\n    ERC20(asset).transferFrom(msg.sender, address(this), amount);\n  }\n\n  function burn(address from, uint amount) external {\n    _burn(from, amount);\n    ERC20(asset).transfer(from, amount);\n  }\n\n}\n"
    },
    "contracts/relay/ERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.1;\n\nimport \"../interfaces/IAppErrors.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n */\n// based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol\nabstract contract ERC2771Context {\n  // for whitelist new relayers need to add new constants and update proxies\n  address private constant GELATO_RELAY_1_BALANCE_ERC_2771 = 0xd8253782c45a12053594b9deB72d8e8aB2Fca54c;\n  address private constant SACRA_RELAY = 0x52CEba41Da235Af367bFC0b0cCd3314cb901bB5F;\n\n  function isTrustedForwarder(address forwarder) public view virtual returns (bool){\n    return forwarder == GELATO_RELAY_1_BALANCE_ERC_2771 || forwarder == SACRA_RELAY;\n  }\n\n  function _msgSender() internal view virtual returns (address sender) {\n    if (isTrustedForwarder(msg.sender)) {\n      // The assembly code is more direct than the Solidity version using `abi.decode`.\n      /// @solidity memory-safe-assembly\n      assembly {\n        sender := shr(96, calldataload(sub(calldatasize(), 20)))\n      }\n      return sender;\n    } else {\n      return msg.sender;\n    }\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    if (isTrustedForwarder(msg.sender)) {\n      return msg.data[: msg.data.length - 20];\n    } else {\n      return msg.data;\n    }\n  }\n\n  /// @notice Return true if given address is not a smart contract but a wallet address.\n  /// @dev It is not 100% guarantee after EIP-3074 implementation, use it as an additional check.\n  /// @return true if the address is a wallet.\n  function _isNotSmartContract() internal view returns (bool) {\n    return isTrustedForwarder(msg.sender) || msg.sender == tx.origin;\n  }\n\n  function onlyEOA() internal view {\n    if (!_isNotSmartContract()) {\n      revert IAppErrors.NotEOA(msg.sender);\n    }\n  }\n}\n"
    },
    "contracts/relay/SacraRelay.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../openzeppelin/ECDSA.sol\";\nimport \"../interfaces/IAppErrors.sol\";\n\n/// @title Sacra relay contract\ncontract SacraRelay {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  //region ------------------------ Data types\n  /// @notice Relay call with user signature verification for ERC 2771 compliance\n  struct CallWithERC2771 {\n    uint chainId;\n    address target;\n    bytes data;\n    address user;\n    uint userNonce;\n    uint userDeadline;\n  }\n  //endregion ------------------------ Data types\n\n  //region ------------------------ Constants\n\n  string public constant NAME = \"SacraRelay\";\n  string public constant VERSION = \"1.0.1\";\n  uint public immutable DELEGATION_DEADLINE = 1 weeks;\n  bytes32 public immutable DOMAIN_SEPARATOR;\n  bytes32 public constant CALL_ERC2771_TYPEHASH =\n  keccak256(\n    bytes(\n      \"CallERC2771(uint256 chainId,address target,bytes data,address user,uint256 userNonce,uint256 userDeadline)\"\n    )\n  );\n\n  //endregion ------------------------ Constants\n\n  //region ------------------------ Variables\n\n  /// @dev Suppose to be the game governance\n  address public owner;\n  /// @dev Allowed EOAs to call game contract on behalf of users\n  EnumerableSet.AddressSet private _operators;\n  /// @dev Allowance is a sequence of numbers where any non zero value means that operator is allowed to call game contract on behalf of user\n  mapping(address => bool) public allowance;\n  /// @dev Nonce for each user to prevent tx duplication\n  mapping(address => uint) public userTxNonce;\n  /// @dev User => Delegator. A user can allow another EOA to call any game action on behalf of him\n  mapping(address => address) public delegatedCallers;\n  /// @dev Delegator => Deadline for delegation\n  mapping(address => uint) public delegatedDeadline;\n\n  //endregion ------------------------ Variables\n\n  //region ------------------------ Events\n  event CalledFromOperator(CallWithERC2771 callData);\n  event CalledFromDelegator(CallWithERC2771 callData);\n  //endregion ------------------------ Events\n\n  //region ------------------------ Constructor\n\n  constructor(address owner_) {\n    owner = owner_;\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\n          bytes(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n          )\n        ),\n        keccak256(bytes(NAME)),\n        keccak256(bytes(VERSION)),\n        block.chainid,\n        address(this)\n      )\n    );\n  }\n\n  //endregion ------------------------ Constructor\n\n  //region ------------------------ Views\n\n  /// @dev Get all operators\n  function operatorsList() external view returns (address[] memory) {\n    return _operators.values();\n  }\n\n  /// @dev Get user info\n  function userInfo(address user) external view returns (uint nonce, bool allowed, address delegator, uint delegatorDeadline) {\n    delegator = delegatedCallers[user];\n    return (userTxNonce[user], allowance[user], delegator, delegatedDeadline[delegator]);\n  }\n\n  //endregion ------------------------ Views\n\n  //region ------------------------ Owner actions\n\n  /// @dev Change owner of this contract\n  function changeOwner(address newOwner) external {\n    if (msg.sender != owner) revert IAppErrors.SacraRelayNotOwner();\n    owner = newOwner;\n  }\n\n  /// @dev Add or remove operator\n  function changeOperator(address operator, bool add) external {\n    if (msg.sender != owner) revert IAppErrors.SacraRelayNotOwner();\n    if (add) {\n      _operators.add(operator);\n    } else {\n      _operators.remove(operator);\n    }\n  }\n  //endregion ------------------------ Owner actions\n\n  //region ------------------------ Main logic\n  /// @dev Approve or disapprove operator to call game contract on behalf of users\n  function approve(bool status) external {\n    allowance[msg.sender] = status;\n  }\n\n  /// @dev Allow to call game contract on behalf of user for given EOA.\n  ///      Zero delegator address means that user revoke permission for this EOA.\n  ///      A user can refuel his delegator by sending some ether with this call.\n  function delegate(address delegator) external payable {\n    address oldDelegator = delegatedCallers[msg.sender];\n    delegatedCallers[msg.sender] = delegator;\n\n    delete delegatedDeadline[oldDelegator];\n    delegatedDeadline[delegator] = block.timestamp + DELEGATION_DEADLINE;\n\n    if (msg.value > 0) {\n      payable(delegator).transfer(msg.value);\n    }\n  }\n\n  /// @dev Close delegation for user.\n  ///      Delegator can send back ether to user with this call.\n  function closeDelegation(address user) external payable {\n    if (delegatedCallers[user] != msg.sender) revert IAppErrors.SacraRelayNotDelegator();\n    delete delegatedCallers[user];\n    delete delegatedDeadline[msg.sender];\n\n    if (msg.value > 0) {\n      payable(user).transfer(msg.value);\n    }\n  }\n\n  /// @dev Call from delegator. No user signature required.\n  ///      We assume delegator is under control of user.\n  function callFromDelegator(CallWithERC2771 calldata callInfo) external {\n    if (delegatedCallers[callInfo.user] != msg.sender) revert IAppErrors.SacraRelayNotDelegator();\n    if (callInfo.chainId != block.chainid) revert IAppErrors.SacraRelayInvalidChainId(callInfo.chainId, block.chainid);\n\n    uint _userTxNonce = userTxNonce[callInfo.user];\n    if (callInfo.userNonce != _userTxNonce) revert IAppErrors.SacraRelayInvalidNonce(callInfo.userNonce, _userTxNonce);\n    if (callInfo.userDeadline != 0 && callInfo.userDeadline < block.timestamp) revert IAppErrors.SacraRelayDeadline();\n    if (delegatedDeadline[msg.sender] < block.timestamp) revert IAppErrors.SacraRelayDelegationExpired();\n\n    userTxNonce[callInfo.user] = _userTxNonce + 1;\n\n    _revertingContractCall(callInfo.target, _encodeERC2771Context(callInfo.data, callInfo.user), \"SacraRelay.DelegatedCall\");\n\n    emit CalledFromDelegator(callInfo);\n  }\n\n  /// @dev Call game contract on behalf of user. Require user signature for every call.\n  function callFromOperator(CallWithERC2771 calldata callInfo, bytes calldata userSignature_) external {\n    if (!_operators.contains(msg.sender)) revert IAppErrors.SacraRelayNotOperator();\n    if (callInfo.chainId != block.chainid) revert IAppErrors.SacraRelayInvalidChainId(callInfo.chainId, block.chainid);\n\n    // a user should allow this contract to call game contracts on behalf of him\n    if (!allowance[callInfo.user]) revert IAppErrors.SacraRelayNotAllowed();\n\n    uint _userTxNonce = userTxNonce[callInfo.user];\n    if (callInfo.userNonce != _userTxNonce) revert IAppErrors.SacraRelayInvalidNonce(callInfo.userNonce, _userTxNonce);\n    if (callInfo.userDeadline != 0 && callInfo.userDeadline < block.timestamp) revert IAppErrors.SacraRelayDeadline();\n\n    // Verify user's signature\n    _requireCallERC2771Signature(callInfo, userSignature_);\n\n    userTxNonce[callInfo.user] = _userTxNonce + 1;\n\n    _revertingContractCall(callInfo.target, _encodeERC2771Context(callInfo.data, callInfo.user), \"SacraRelay.CallERC2771\");\n\n    emit CalledFromOperator(callInfo);\n  }\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ Internal logic\n  /// @dev from GelatoCallUtils\n  function _revertingContractCall(\n    address _contract,\n    bytes memory _data,\n    string memory _errorMsg\n  ) internal returns (bytes memory returnData) {\n    bool success;\n    (success, returnData) = _contract.call(_data);\n\n    // solhint-disable-next-line max-line-length\n    // https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f9b6fc3fdab7aca33a9cfa8837c5cd7f67e176be/contracts/utils/AddressUpgradeable.sol#L177\n    if (success) {\n      if (returnData.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        if (!_isContract(_contract)) revert IAppErrors.SacraRelayCallToNotContract(_contract, _errorMsg);\n      }\n    } else {\n      _revertWithError(returnData, _errorMsg);\n    }\n  }\n\n  /// @dev NOT SECURE CHECK! Just for more clear error messages\n  function _isContract(address account) internal view returns (bool) {\n    return account.code.length > 0;\n  }\n\n  function _revertWithError(bytes memory _bytes, string memory _tracingInfo) internal pure {\n    // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n    if (_bytes.length % 32 == 4) {\n      bytes4 selector;\n      assembly {\n        selector := mload(add(0x20, _bytes))\n      }\n      if (selector == 0x08c379a0) {\n        // Function selector for Error(string)\n        assembly {\n          _bytes := add(_bytes, 68)\n        }\n        revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\n      } else {\n        revert IAppErrors.SacraRelayNoErrorSelector(selector, _tracingInfo);\n      }\n    } else {\n      revert IAppErrors.SacraRelayUnexpectedReturnData(_bytes, _tracingInfo);\n    }\n  }\n\n  /// @dev vanilla ERC2771 context encoding\n  function _encodeERC2771Context(bytes calldata _data, address _msgSender) pure internal returns (bytes memory){\n    return abi.encodePacked(_data, _msgSender);\n  }\n\n  function _requireCallERC2771Signature(CallWithERC2771 calldata callInfo, bytes calldata signature_) internal view returns (bytes32 digest) {\n    digest = keccak256(\n      abi.encodePacked(\n        \"\\x19\\x01\",\n        DOMAIN_SEPARATOR,\n        keccak256(_abiEncodeCallERC2771(callInfo))\n      )\n    );\n\n    (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(digest, signature_);\n    if (error != ECDSA.RecoverError.NoError || recovered != callInfo.user) revert IAppErrors.SacraRelayInvalidSignature();\n  }\n\n  function _abiEncodeCallERC2771(CallWithERC2771 calldata callInfo) internal pure returns (bytes memory){\n    return abi.encode(\n      CALL_ERC2771_TYPEHASH,\n      callInfo.chainId,\n      callInfo.target,\n      keccak256(callInfo.data),\n      callInfo.user,\n      callInfo.userNonce,\n      callInfo.userDeadline\n    );\n  }\n  //endregion ------------------------ Internal logic\n\n  receive() external payable {}\n}\n"
    },
    "contracts/solady/DateTimeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for date time operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/DateTimeLib.sol)\n/// @author Modified from BokkyPooBahsDateTimeLibrary (https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary)\n/// @dev\n/// Conventions:\n/// --------------------------------------------------------------------+\n/// Unit      | Range                | Notes                            |\n/// --------------------------------------------------------------------|\n/// timestamp | 0..0x1e18549868c76ff | Unix timestamp.                  |\n/// epochDay  | 0..0x16d3e098039     | Days since 1970-01-01.           |\n/// year      | 1970..0xffffffff     | Gregorian calendar year.         |\n/// month     | 1..12                | Gregorian calendar month.        |\n/// day       | 1..31                | Gregorian calendar day of month. |\n/// weekday   | 1..7                 | The day of the week (1-indexed). |\n/// --------------------------------------------------------------------+\n/// All timestamps of days are rounded down to 00:00:00 UTC.\nlibrary DateTimeLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Weekdays are 1-indexed, adhering to ISO 8601.\n\n    uint256 internal constant MON = 1;\n    uint256 internal constant TUE = 2;\n    uint256 internal constant WED = 3;\n    uint256 internal constant THU = 4;\n    uint256 internal constant FRI = 5;\n    uint256 internal constant SAT = 6;\n    uint256 internal constant SUN = 7;\n\n    // Months and days of months are 1-indexed, adhering to ISO 8601.\n\n    uint256 internal constant JAN = 1;\n    uint256 internal constant FEB = 2;\n    uint256 internal constant MAR = 3;\n    uint256 internal constant APR = 4;\n    uint256 internal constant MAY = 5;\n    uint256 internal constant JUN = 6;\n    uint256 internal constant JUL = 7;\n    uint256 internal constant AUG = 8;\n    uint256 internal constant SEP = 9;\n    uint256 internal constant OCT = 10;\n    uint256 internal constant NOV = 11;\n    uint256 internal constant DEC = 12;\n\n    // These limits are large enough for most practical purposes.\n    // Inputs that exceed these limits result in undefined behavior.\n\n    uint256 internal constant MAX_SUPPORTED_YEAR = 0xffffffff;\n    uint256 internal constant MAX_SUPPORTED_EPOCH_DAY = 0x16d3e098039;\n    uint256 internal constant MAX_SUPPORTED_TIMESTAMP = 0x1e18549868c76ff;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    DATE TIME OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of days since 1970-01-01 from (`year`,`month`,`day`).\n    /// See: https://howardhinnant.github.io/date_algorithms.html\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToEpochDay(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 epochDay)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            year := sub(year, lt(month, 3))\n            let doy := add(shr(11, add(mul(62719, mod(add(month, 9), 12)), 769)), day)\n            let yoe := mod(year, 400)\n            let doe := sub(add(add(mul(yoe, 365), shr(2, yoe)), doy), div(yoe, 100))\n            epochDay := sub(add(mul(div(year, 400), 146097), doe), 719469)\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the number of days since 1970-01-01.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDays} to check if the inputs is supported.\n    function epochDayToDate(uint256 epochDay)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            epochDay := add(epochDay, 719468)\n            let doe := mod(epochDay, 146097)\n            let yoe :=\n                div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n            let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n            let mp := div(add(mul(5, doy), 2), 153)\n            day := add(sub(doy, shr(11, add(mul(mp, 62719), 769))), 1)\n            month := byte(mp, shl(160, 0x030405060708090a0b0c0102))\n            year := add(add(yoe, mul(div(epochDay, 146097), 400)), lt(month, 3))\n        }\n    }\n\n    /// @dev Returns the unix timestamp from (`year`,`month`,`day`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToTimestamp(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        (year, month, day) = epochDayToDate(timestamp / 86400);\n    }\n\n    /// @dev Returns the unix timestamp from\n    /// (`year`,`month`,`day`,`hour`,`minute`,`second`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDateTime} to check if the inputs are supported.\n    function dateTimeToTimestamp(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400 + hour * 3600 + minute * 60 + second;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`,`hour`,`minute`,`second`)\n    /// from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        unchecked {\n            (year, month, day) = epochDayToDate(timestamp / 86400);\n            uint256 secs = timestamp % 86400;\n            hour = secs / 3600;\n            secs = secs % 3600;\n            minute = secs / 60;\n            second = secs % 60;\n        }\n    }\n\n    /// @dev Returns if the `year` is leap.\n    function isLeapYear(uint256 year) internal pure returns (bool leap) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leap := iszero(and(add(mul(iszero(mod(year, 25)), 12), 3), year))\n        }\n    }\n\n    /// @dev Returns number of days in given `month` of `year`.\n    function daysInMonth(uint256 year, uint256 month) internal pure returns (uint256 result) {\n        bool flag = isLeapYear(year);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `daysInMonths = [31,28,31,30,31,30,31,31,30,31,30,31]`.\n            // `result = daysInMonths[month - 1] + isLeapYear(year)`.\n            result :=\n                add(byte(month, shl(152, 0x1f1c1f1e1f1e1f1f1e1f1e1f)), and(eq(month, 2), flag))\n        }\n    }\n\n    /// @dev Returns the weekday from the unix timestamp.\n    /// Monday: 1, Tuesday: 2, ....., Sunday: 7.\n    function weekday(uint256 timestamp) internal pure returns (uint256 result) {\n        unchecked {\n            result = ((timestamp / 86400 + 3) % 7) + 1;\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`) is a supported date.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    function isSupportedDate(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (bool result)\n    {\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result :=\n                and(\n                    lt(sub(year, 1970), sub(MAX_SUPPORTED_YEAR, 1969)),\n                    and(lt(sub(month, 1), 12), lt(sub(day, 1), md))\n                )\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`,`hour`,`minute`,`second`) is a supported date time.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    /// - `hour < 24`.\n    /// - `minute < 60`.\n    /// - `second < 60`.\n    function isSupportedDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool result) {\n        if (isSupportedDate(year, month, day)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := and(lt(hour, 24), and(lt(minute, 60), lt(second, 60)))\n            }\n        }\n    }\n\n    /// @dev Returns if `epochDay` is a supported unix epoch day.\n    function isSupportedEpochDay(uint256 epochDay) internal pure returns (bool result) {\n        unchecked {\n            result = epochDay < MAX_SUPPORTED_EPOCH_DAY + 1;\n        }\n    }\n\n    /// @dev Returns if `timestamp` is a supported unix timestamp.\n    function isSupportedTimestamp(uint256 timestamp) internal pure returns (bool result) {\n        unchecked {\n            result = timestamp < MAX_SUPPORTED_TIMESTAMP + 1;\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the given `n`th weekday `wd`, in `month` of `year`.\n    /// Example: 3rd Friday of Feb 2022 is `nthWeekdayInMonthOfYearTimestamp(2022, 2, 3, 5)`\n    /// Note: `n` is 1-indexed for traditional consistency.\n    /// Invalid weekdays (i.e. `wd == 0 || wd > 7`) result in undefined behavior.\n    function nthWeekdayInMonthOfYearTimestamp(uint256 year, uint256 month, uint256 n, uint256 wd)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        uint256 d = dateToEpochDay(year, month, 1);\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let diff := sub(wd, add(mod(add(d, 3), 7), 1))\n            let date := add(mul(sub(n, 1), 7), add(mul(gt(diff, 6), 7), diff))\n            result := mul(mul(86400, add(date, d)), and(lt(date, md), iszero(iszero(n))))\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the most recent Monday.\n    function mondayTimestamp(uint256 timestamp) internal pure returns (uint256 result) {\n        uint256 t = timestamp;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let day := div(t, 86400)\n            result := mul(mul(sub(day, mod(add(day, 3), 7)), 86400), gt(t, 345599))\n        }\n    }\n\n    /// @dev Returns whether the unix timestamp falls on a Saturday or Sunday.\n    /// To check whether it is a week day, just take the negation of the result.\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool result) {\n        result = weekday(timestamp) > FRI;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              DATE TIME ARITHMETIC OPERATIONS               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Adds `numYears` to the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year + numYears, month, day, timestamp);\n    }\n\n    /// @dev Adds `numMonths` to the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        month = _sub(month + numMonths, 1);\n        result = _offsetted(year + month / 12, _add(month % 12, 1), day, timestamp);\n    }\n\n    /// @dev Adds `numDays` to the unix timestamp, and returns the result.\n    function addDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp + numDays * 86400;\n    }\n\n    /// @dev Adds `numHours` to the unix timestamp, and returns the result.\n    function addHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp + numHours * 3600;\n    }\n\n    /// @dev Adds `numMinutes` to the unix timestamp, and returns the result.\n    function addMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numMinutes * 60;\n    }\n\n    /// @dev Adds `numSeconds` to the unix timestamp, and returns the result.\n    function addSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numSeconds;\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year - numYears, month, day, timestamp);\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        uint256 yearMonth = _totalMonths(year, month) - _add(numMonths, 1);\n        result = _offsetted(yearMonth / 12, _add(yearMonth % 12, 1), day, timestamp);\n    }\n\n    /// @dev Subtracts `numDays` from the unix timestamp, and returns the result.\n    function subDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp - numDays * 86400;\n    }\n\n    /// @dev Subtracts `numHours` from the unix timestamp, and returns the result.\n    function subHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp - numHours * 3600;\n    }\n\n    /// @dev Subtracts `numMinutes` from the unix timestamp, and returns the result.\n    function subMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numMinutes * 60;\n    }\n\n    /// @dev Subtracts `numSeconds` from the unix timestamp, and returns the result.\n    function subSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numSeconds;\n    }\n\n    /// @dev Returns the difference in Gregorian calendar years\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a year,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar years\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear,,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear,,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(toYear, fromYear);\n    }\n\n    /// @dev Returns the difference in Gregorian calendar months\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a month,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar months.\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear, uint256 fromMonth,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear, uint256 toMonth,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(_totalMonths(toYear, toMonth), _totalMonths(fromYear, fromMonth));\n    }\n\n    /// @dev Returns the difference in days between `fromTimestamp` and `toTimestamp`.\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 86400;\n    }\n\n    /// @dev Returns the difference in hours between `fromTimestamp` and `toTimestamp`.\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 3600;\n    }\n\n    /// @dev Returns the difference in minutes between `fromTimestamp` and `toTimestamp`.\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 60;\n    }\n\n    /// @dev Returns the difference in seconds between `fromTimestamp` and `toTimestamp`.\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = toTimestamp - fromTimestamp;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unchecked arithmetic for computing the total number of months.\n    function _totalMonths(uint256 numYears, uint256 numMonths)\n        private\n        pure\n        returns (uint256 total)\n    {\n        unchecked {\n            total = numYears * 12 + numMonths;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for adding two numbers.\n    function _add(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a + b;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for subtracting two numbers.\n    function _sub(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a - b;\n        }\n    }\n\n    /// @dev Returns the offsetted timestamp.\n    function _offsetted(uint256 year, uint256 month, uint256 day, uint256 timestamp)\n        private\n        pure\n        returns (uint256 result)\n    {\n        uint256 dm = daysInMonth(year, month);\n        if (day >= dm) {\n            day = dm;\n        }\n        result = dateToEpochDay(year, month, day) * 86400 + (timestamp % 86400);\n    }\n}\n"
    },
    "contracts/solady/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(and(iszero(iszero(y)), eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) ≈ 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s ≈ 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549…`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            int256 wad = int256(WAD);\n            int256 p = x;\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (w >> 63 == 0) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == 0) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != 0);\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c != 0) {\n                int256 t = w | 1;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    x := sdiv(mul(x, wad), t)\n                }\n                x = (t * (wad + lnWad(x)));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    w := sdiv(x, add(wad, t))\n                }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                // 512-bit multiply `[p1 p0] = x * y`.\n                // Compute the product mod `2**256` and mod `2**256 - 1`\n                // then use the Chinese Remainder Theorem to reconstruct\n                // the 512 bit result. The result is stored in two 256\n                // variables such that `product = p1 * 2**256 + p0`.\n\n                // Least significant 256 bits of the product.\n                result := mul(x, y) // Temporarily use `result` as `p0` to save gas.\n                let mm := mulmod(x, y, not(0))\n                // Most significant 256 bits of the product.\n                let p1 := sub(mm, add(result, lt(mm, result)))\n\n                // Handle non-overflow cases, 256 by 256 division.\n                if iszero(p1) {\n                    if iszero(d) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    result := div(result, d)\n                    break\n                }\n\n                // Make sure the result is less than `2**256`. Also prevents `d == 0`.\n                if iszero(gt(d, p1)) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n\n                /*------------------- 512 by 256 division --------------------*/\n\n                // Make division exact by subtracting the remainder from `[p1 p0]`.\n                // Compute remainder using mulmod.\n                let r := mulmod(x, y, d)\n                // `t` is the least significant bit of `d`.\n                // Always greater or equal to 1.\n                let t := and(d, sub(0, d))\n                // Divide `d` by `t`, which is a power of two.\n                d := div(d, t)\n                // Invert `d mod 2**256`\n                // Now that `d` is an odd number, it has an inverse\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                // Compute the inverse by starting with a seed that is correct\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                let inv := xor(2, mul(3, d))\n                // Now use Newton-Raphson iteration to improve the precision.\n                // Thanks to Hensel's lifting lemma, this also works in modular\n                // arithmetic, doubling the correct bits in each step.\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                result :=\n                    mul(\n                        // Divide [p1 p0] by the factors of two.\n                        // Shift in bits from `p1` into `p0`. For this we need\n                        // to flip `t` such that it is `2**256 / t`.\n                        or(\n                            mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)),\n                            div(sub(result, r), t)\n                        ),\n                        // inverse mod 2**256\n                        mul(inv, sub(2, mul(d, inv)))\n                    )\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        result = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                result := add(result, 1)\n                if iszero(result) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if iszero(iszero(x)) {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = 10 ** 9;\n            if (x <= type(uint256).max / 10 ** 36 - 1) {\n                x *= 10 ** 18;\n                z = 1;\n            }\n            z *= sqrt(x);\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`.\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = 10 ** 12;\n            if (x <= (type(uint256).max / 10 ** 36) * 10 ** 18 - 1) {\n                if (x >= type(uint256).max / 10 ** 36) {\n                    x *= 10 ** 18;\n                    z = 10 ** 6;\n                } else {\n                    x *= 10 ** 36;\n                    z = 1;\n                }\n            }\n            z *= cbrt(x);\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for { result := 1 } x { x := sub(x, 1) } { result := mul(result, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(sar(255, x), add(sar(255, x), x))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(mul(xor(sub(y, x), sub(x, y)), sgt(x, y)), sub(y, x))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"
    },
    "contracts/solady/LibPRNG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for generating pseudorandom numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\n/// @author LazyShuffler based on NextShuffler by aschlosberg (divergencearran)\n/// (https://github.com/divergencetech/ethier/blob/main/contracts/random/NextShuffler.sol)\nlibrary LibPRNG {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The initial length must be greater than zero and less than `2**32 - 1`.\n    error InvalidInitialLazyShufflerLength();\n\n    /// @dev The new length must not be less than the current length.\n    error InvalidNewLazyShufflerLength();\n\n    /// @dev The lazy shuffler has not been initialized.\n    error LazyShufflerNotInitialized();\n\n    /// @dev Cannot double initialize the lazy shuffler.\n    error LazyShufflerAlreadyInitialized();\n\n    /// @dev The lazy shuffle has finished.\n    error LazyShuffleFinished();\n\n    /// @dev The queried index is out of bounds.\n    error LazyShufflerGetOutOfBounds();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev A pseudorandom number state in memory.\n    struct PRNG {\n        uint256 state;\n    }\n\n    /// @dev A lazy Fisher-Yates shuffler for a range `[0..n)` in storage.\n    struct LazyShuffler {\n        // Bits Layout:\n        // - [0..31]    `numShuffled`\n        // - [32..223]  `permutationSlot`\n        // - [224..255] `length`\n        uint256 _state;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         OPERATIONS                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Seeds the `prng` with `state`.\n    function seed(PRNG memory prng, uint256 state) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(prng, state)\n        }\n    }\n\n    /// @dev Returns the next pseudorandom uint256.\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\n        // We simply use `keccak256` for a great balance between\n        // runtime gas costs, bytecode size, and statistical properties.\n        //\n        // A high-quality LCG with a 32-byte state\n        // is only about 30% more gas efficient during runtime,\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\n        // when this function is inlined.\n        //\n        // Using this method is about 2x more efficient than\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n        }\n    }\n\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\n    /// between 0 (inclusive) and `upper` (exclusive).\n    /// If your modulus is big, this method is recommended\n    /// for uniform sampling to avoid modulo bias.\n    /// For uniform sampling across all uint256 values,\n    /// or for small enough moduli such that the bias is neligible,\n    /// use {next} instead.\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := keccak256(prng, 0x20)\n                mstore(prng, result)\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\n            }\n            result := mod(result, upper)\n        }\n    }\n\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n\n                    {\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                let b := add(a, 0x01)\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let o := mod(shr(128, r), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n\n                    {\n                        let o := mod(and(r, mask), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns a sample from the standard normal distribution denominated in `WAD`.\n    function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\n            // The chance of drawing a sample outside 10 σ from the standard normal distribution\n            // is ≈ 0.000000000000000000000015, which is insignificant for most practical purposes.\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\n            let s := 0x1000000000000000100000000000000010000000000000001\n            let r1 := mulmod(result, a, n)\n            let r2 := mulmod(r1, a, n)\n            let r3 := mulmod(r2, a, n)\n            // forgefmt: disable-next-item\n            result := sub(sar(96, mul(26614938895861601847173011183,\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\n        }\n    }\n\n    /// @dev Returns a sample from the unit exponential distribution denominated in `WAD`.\n    function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\n            // Gas usage varies, starting from about 172+ gas.\n            let r := keccak256(prng, 0x20)\n            mstore(prng, r)\n            let p := shl(129, r)\n            let w := shl(1, r)\n            if iszero(gt(w, p)) {\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\n                for {} 1 {} {\n                    r := mulmod(r, a, n)\n                    if iszero(lt(shl(129, r), w)) {\n                        r := mulmod(r, a, n)\n                        result := add(1000000000000000000, result)\n                        w := shl(1, r)\n                        p := shl(129, r)\n                        if iszero(lt(w, p)) { break }\n                        continue\n                    }\n                    w := shl(1, r)\n                    if iszero(lt(w, shl(129, r))) { break }\n                }\n            }\n            result := add(div(p, shl(129, 170141183460469231732)), result)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*       STORAGE-BASED RANGE LAZY SHUFFLING OPERATIONS        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Initializes the state for lazy-shuffling the range `[0..n)`.\n    /// Reverts if `n == 0 || n >= 2**32 - 1`.\n    /// Reverts if `$` has already been initialized.\n    /// If you need to reduce the length after initialization, just use a fresh new `$`.\n    function initialize(LazyShuffler storage $, uint256 n) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\n                revert(0x1c, 0x04)\n            }\n            if sload($.slot) {\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, $.slot)\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\n        }\n    }\n\n    /// @dev Increases the length of `$`.\n    /// Reverts if `$` has not been initialized.\n    function grow(LazyShuffler storage $, uint256 n) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            // If the new length is smaller than the old length, revert.\n            if lt(n, shr(224, state)) {\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\n        }\n    }\n\n    /// @dev Restarts the shuffler by setting `numShuffled` to zero,\n    /// such that all elements can be drawn again.\n    /// Restarting does NOT clear the internal permutation, nor changes the length.\n    /// Even with the same sequence of randomness, reshuffling can yield different results.\n    function restart(LazyShuffler storage $) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot)\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore($.slot, shl(32, shr(32, state)))\n        }\n    }\n\n    /// @dev Returns the number of elements that have been shuffled.\n    function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(0xffffffff, sload($.slot))\n        }\n    }\n\n    /// @dev Returns the length of `$`.\n    /// Returns zero if `$` is not initialized, else a non-zero value less than `2**32 - 1`.\n    function length(LazyShuffler storage $) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(224, sload($.slot))\n        }\n    }\n\n    /// @dev Returns if `$` has been initialized.\n    function initialized(LazyShuffler storage $) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(iszero(sload($.slot)))\n        }\n    }\n\n    /// @dev Returns if there are any more elements left to shuffle.\n    /// Reverts if `$` is not initialized.\n    function finished(LazyShuffler storage $) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            result := eq(shr(224, state), and(0xffffffff, state))\n        }\n    }\n\n    /// @dev Returns the current value stored at `index`, accounting for all historical shuffling.\n    /// Reverts if `index` is greater than or equal to the `length` of `$`.\n    function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            let n := shr(224, state) // Length of `$`.\n            if iszero(lt(index, n)) {\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\n                revert(0x1c, 0x04)\n            }\n            let u32 := gt(n, 0xfffe)\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\n            result := and(m, shr(o, sload(s)))\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\n        }\n    }\n\n    /// @dev Does a single Fisher-Yates shuffle step, increments the `numShuffled` in `$`,\n    /// and returns the next value in the shuffled range.\n    /// `randomness` can be taken from a good-enough source, or a higher quality source like VRF.\n    /// Reverts if there are no more values to shuffle, which includes the case if `$` is not initialized.\n    function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function _get(u32_, state_, i_) -> _value {\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\n                _value := and(m_, shr(o_, sload(s_)))\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\n            }\n            function _set(u32_, state_, i_, value_) {\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\n                let v_ := sload(s_) // Bucket slot value.\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\n            }\n            let state := sload($.slot) // The packed value at `$`.\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\n            let n := shr(224, state) // Length of `$`.\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\n            if iszero(remainder) {\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\n            chosen := _get(gt(n, 0xfffe), state, index)\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\n        }\n    }\n}\n"
    },
    "contracts/test/facades/FacadeCalcLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/CalcLib.sol\";\n\ncontract FacadeCalcLib {\n  mapping(uint => uint) internal _maxToRandom;\n\n  //region ------------------------ For tests\n  function setRandom(uint maxValue, uint value) external {\n    _maxToRandom[maxValue] = value;\n  }\n\n  function randomForTests(uint maxValue) internal view returns (uint) {\n    return _maxToRandom[maxValue];\n  }\n\n  //endregion ------------------------ For tests\n\n\n  //region ------------------------ Math\n  function minI32(int32 a, int32 b) external pure returns (int32) {\n    return CalcLib.minI32(a, b);\n  }\n\n  function max32(int32 a, int32 b) external pure returns (int32) {\n    return CalcLib.max32(a, b);\n  }\n\n  function absDiff(int32 a, int32 b) external pure returns (uint32) {\n    return CalcLib.absDiff(a, b);\n  }\n\n  function sqrt(uint x) external pure returns (uint z) {\n    return CalcLib.sqrt(x);\n  }\n\n  function log2(uint256 x) external pure returns (uint256 result) {\n    return CalcLib.log2(x);\n  }\n\n  function mostSignificantBit(uint256 x) external pure returns (uint256 msb) {\n    return CalcLib.mostSignificantBit(x);\n  }\n\n  //endregion ------------------------ Math\n\n\n  //region ------------------------ To XXX\n  function toUint(int32 a) external pure returns (uint) {\n    return CalcLib.toUint(a);\n  }\n\n  function toInt32(uint a) external pure returns (int32) {\n    return CalcLib.toInt32(a);\n  }\n  //endregion ------------------------ To XXX\n\n\n  //region ------------------------ Random\n  /// @dev Simplified pseudo-random for minor functionality\n  function pseudoRandom(uint maxValue) external view returns (uint) {\n    return CalcLib.pseudoRandom(maxValue);\n  }\n\n  function pseudoRandomUint32(uint32 maxValue) external view returns (uint32) {\n    return CalcLib.pseudoRandomUint32(maxValue);\n  }\n\n  /// @notice pseudoRandomUint32 with customizable pseudoRandom()\n  function pseudoRandomUint32Flex(uint32 maxValue) external view returns (uint32) {\n    return CalcLib.pseudoRandomUint32Flex(maxValue, randomForTests);\n  }\n\n  function pseudoRandomInt32(int32 maxValue) external view returns (int32) {\n    return CalcLib.pseudoRandomInt32(maxValue);\n  }\n\n  /// @dev Simplified pseudo-random for minor functionality\n  function pseudoRandomWithSeed(uint maxValue, uint seed) external view returns (uint) {\n    return CalcLib.pseudoRandomWithSeed(maxValue, seed);\n  }\n\n  /// @dev Simplified pseudo-random for minor functionality, in range\n  function pseudoRandomInRange(uint min, uint max) external view returns (uint) {\n    return CalcLib.pseudoRandomInRange(min, max);\n  }\n\n  /// @dev Simplified pseudo-random for minor functionality, in range\n  ///      Equal to pseudoRandomInRange(min, max, pseudoRandom)\n  function pseudoRandomInRangeFlex(uint min, uint max) external view returns (uint) {\n    return CalcLib.pseudoRandomInRangeFlex(min, max, randomForTests);\n  }\n  //endregion ------------------------ Random\n\n\n  //region ------------------------ Minus, plus\n  function minusWithZeroFloor(uint a, uint b) external pure returns (uint) {\n    return CalcLib.minusWithZeroFloor(a, b);\n  }\n\n  function minusWithMinFloorI32(int32 a, int32 b) external pure returns (int32) {\n    return CalcLib.minusWithMinFloorI32(a, b);\n  }\n\n  function plusWithMaxFloor32(int32 a, int32 b) external pure returns (int32) {\n    return CalcLib.plusWithMaxFloor32(a, b);\n  }\n  //endregion ------------------------ Minus, plus\n}\n"
    },
    "contracts/test/facades/FacadeControllerContextLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport {IController} from \"../../interfaces/IController.sol\";\nimport {IOracle} from \"../../interfaces/IOracle.sol\";\nimport {IStatController} from \"../../interfaces/IStatController.sol\";\nimport {IStoryController} from \"../../interfaces/IStoryController.sol\";\nimport {ITreasury} from \"../../interfaces/ITreasury.sol\";\nimport {IDungeonFactory} from \"../../interfaces/IDungeonFactory.sol\";\nimport {IReinforcementController} from \"../../interfaces/IReinforcementController.sol\";\nimport {IGameToken} from \"../../interfaces/IGameToken.sol\";\nimport {IGOC} from \"../../interfaces/IGOC.sol\";\nimport {IItemController} from \"../../interfaces/IItemController.sol\";\nimport {IHeroController} from \"../../interfaces/IHeroController.sol\";\nimport \"../../lib/ControllerContextLib.sol\";\n\ncontract FacadeControllerContextLib {\n  function init(IController controller) external pure returns (ControllerContextLib.ControllerContext memory cc) {\n    return ControllerContextLib.init(controller);\n  }\n\n  function getStatController(ControllerContextLib.ControllerContext memory cc) external view returns (\n    IStatController dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getStatController(cc);\n    return (dest, cc);\n  }\n\n  function getStoryController(ControllerContextLib.ControllerContext memory cc) external view returns (\n    IStoryController dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getStoryController(cc);\n    return (dest, cc);\n  }\n\n  function getOracle(ControllerContextLib.ControllerContext memory cc) external view returns (\n    IOracle dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getOracle(cc);\n    return (dest, cc);\n  }\n\n  function getTreasury(ControllerContextLib.ControllerContext memory cc) external view returns (\n    ITreasury dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getTreasury(cc);\n    return (dest, cc);\n  }\n\n  function getDungeonFactory(ControllerContextLib.ControllerContext memory cc) external view returns (\n    IDungeonFactory dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getDungeonFactory(cc);\n    return (dest, cc);\n  }\n\n  function getGameObjectController(ControllerContextLib.ControllerContext memory cc) external view returns (\n    IGOC dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getGameObjectController(cc);\n    return (dest, cc);\n  }\n\n  function getReinforcementController(ControllerContextLib.ControllerContext memory cc) external view returns (\n    IReinforcementController dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getReinforcementController(cc);\n    return (dest, cc);\n  }\n\n  function getItemController(ControllerContextLib.ControllerContext memory cc) external view returns (\n    IItemController dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getItemController(cc);\n    return (dest, cc);\n  }\n\n  function getHeroController(ControllerContextLib.ControllerContext memory cc) external view returns (\n    IHeroController dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getHeroController(cc);\n    return (dest, cc);\n  }\n\n  function getGameToken(ControllerContextLib.ControllerContext memory cc) external view returns (\n    IGameToken dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getGameToken(cc);\n    return (dest, cc);\n  }\n\n  function getUserController(ControllerContextLib.ControllerContext memory cc) external view returns (\n    IUserController dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getUserController(cc);\n    return (dest, cc);\n  }\n\n  function getGuildController(ControllerContextLib.ControllerContext memory cc) external view returns (\n    IGuildController dest,\n    ControllerContextLib.ControllerContext memory\n  ) {\n    dest = ControllerContextLib.getGuildController(cc);\n    return (dest, cc);\n  }\n}"
    },
    "contracts/test/facades/FacadeControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/ControllerLib.sol\";\n\ncontract FacadeController {\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(this);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n  //region ------------------------ For tests\n  function setMainStateDirectly1(\n    address governance_,\n    address futureGovernance_,\n    address statController_,\n    address storyController_,\n    address oracle_,\n    address treasury_,\n    address dungeonFactory_,\n    address gameObjectController_,\n    address reinforcementController_,\n    address itemController_,\n    address heroController_\n  ) external {\n    ControllerLib._S().governance = governance_;\n    ControllerLib._S().futureGovernance = futureGovernance_;\n    ControllerLib._S().statController = statController_;\n    ControllerLib._S().storyController = storyController_;\n    ControllerLib._S().oracle = oracle_;\n    ControllerLib._S().treasury = treasury_;\n    ControllerLib._S().dungeonFactory = dungeonFactory_;\n    ControllerLib._S().gameObjectController = gameObjectController_;\n    ControllerLib._S().reinforcementController = reinforcementController_;\n    ControllerLib._S().itemController = itemController_;\n    ControllerLib._S().heroController = heroController_;\n  }\n  function setMainStateDirectly2(\n    address gameToken_,\n    bool onPause_,\n    address userController_,\n    address guildController_\n  ) external {\n    ControllerLib._S().gameToken = gameToken_;\n    ControllerLib._S().onPause = onPause_;\n    ControllerLib._S().userController = userController_;\n    ControllerLib._S().guildController = guildController_;\n  }\n  function setMainStateDeployerDirectly(address eoa, uint eligibilityTime_) external {\n    ControllerLib._S().deployers[eoa] = eligibilityTime_;\n  }\n  function setValidTreasuryTokensDirectly(address token, bool isValid) external {\n    ControllerLib._S().validTreasuryTokens[token] = isValid;\n  }\n  //endregion ------------------------ For tests\n\n  //region ------------------------ Views\n  function isDeployer(address adr) external view returns (bool) {\n    return ControllerLib.isDeployer(adr);\n  }\n\n  function governance() external view returns (address) {\n    return ControllerLib.governance();\n  }\n\n  function futureGovernance() external view returns (address) {\n    return ControllerLib.futureGovernance();\n  }\n\n  function statController() external view returns (address) {\n    return ControllerLib.statController();\n  }\n\n  function storyController() external view returns (address) {\n    return ControllerLib.storyController();\n  }\n\n  function oracle() external view returns (address) {\n    return ControllerLib.oracle();\n  }\n\n  function treasury() external view returns (address) {\n    return ControllerLib.treasury();\n  }\n\n  function dungeonFactory() external view returns (address) {\n    return ControllerLib.dungeonFactory();\n  }\n\n  function gameObjectController() external view returns (address) {\n    return ControllerLib.gameObjectController();\n  }\n\n  function reinforcementController() external view returns (address) {\n    return ControllerLib.reinforcementController();\n  }\n\n  function itemController() external view returns (address) {\n    return ControllerLib.itemController();\n  }\n\n  function heroController() external view returns (address) {\n    return ControllerLib.heroController();\n  }\n\n  function gameToken() external view returns (address) {\n    return ControllerLib.gameToken();\n  }\n\n  function validTreasuryTokens(address token) external view returns (bool) {\n    return ControllerLib.validTreasuryTokens(token);\n  }\n\n  function onPause() external view returns (bool) {\n    return ControllerLib.onPause();\n  }\n\n  function userController() external view returns (address) {\n    return ControllerLib.userController();\n  }\n\n  function guildController() external view returns (address) {\n    return ControllerLib.guildController();\n  }\n  //endregion ------------------------ Views\n\n  //region ------------------------ Gov actions - setters\n  function changePause(bool value) external {\n    ControllerLib.changePause(value);\n  }\n\n  function offerGovernance(address newGov) external {\n    ControllerLib.offerGovernance(newGov);\n  }\n\n  function acceptGovernance() external {\n    ControllerLib.acceptGovernance();\n  }\n\n  function setStatController(address value) external {\n    ControllerLib.setStatController(value);\n  }\n\n  function setStoryController(address value) external {\n    ControllerLib.setStoryController(value);\n  }\n\n  function setGameObjectController(address value) external {\n    ControllerLib.setGameObjectController(value);\n  }\n\n  function setReinforcementController(address value) external {\n    ControllerLib.setReinforcementController(value);\n  }\n\n  function setOracle(address value) external {\n    ControllerLib.setOracle(value);\n  }\n\n  function setTreasury(address value) external {\n    ControllerLib.setTreasury(value);\n  }\n\n  function setItemController(address value) external {\n    ControllerLib.setItemController(value);\n  }\n\n  function setHeroController(address value) external {\n    ControllerLib.setHeroController(value);\n  }\n\n  function setGameToken(address value) external {\n    ControllerLib.setGameToken(value);\n  }\n\n  function setDungeonFactory(address value) external {\n    ControllerLib.setDungeonFactory(value);\n  }\n\n  function changeDeployer(address eoa, bool remove) external {\n    ControllerLib.changeDeployer(eoa, remove);\n  }\n\n  function setUserController(address value) external {\n    ControllerLib.setUserController(value);\n  }\n\n  function setGuildController(address value) external {\n    ControllerLib.setGuildController(value);\n  }\n  //endregion ------------------------ Gov actions - setters\n\n  //region ------------------------ Gov actions - others\n\n  function updateProxies(address[] memory proxies, address newLogic) external {\n    ControllerLib.updateProxies(proxies, newLogic);\n  }\n\n  function claimToGovernance(address token) external {\n    ControllerLib.claimToGovernance(token);\n  }\n  //endregion ------------------------ Gov actions - others\n\n  //region ------------------------ REGISTER ACTIONS\n\n  function changeTreasuryTokenStatus(address token, bool status) external {\n    ControllerLib.changeTreasuryTokenStatus(token, status);\n  }\n  //endregion ------------------------ REGISTER ACTIONS\n}\n"
    },
    "contracts/test/facades/FacadeDungeonFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/DungeonFactoryLib.sol\";\nimport \"../../openzeppelin/EnumerableSet.sol\";\nimport {DungeonFactory} from \"../../core/DungeonFactory.sol\";\n\n/// @notice Lightweight wrapper around DungeonFactory to improve coverage of the core contract\ncontract FacadeDungeonFactory is DungeonFactory {\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  /// @notice Two functions were combine to single one to reduce size\n  function setMaxBiomeCompletedAddFreeDungeons(bytes32 packedHeroId, uint8 biome, uint value) external {\n    DungeonFactoryLib._S().maxBiomeCompleted[packedHeroId] = biome;\n    DungeonFactoryLib._S().freeDungeons[biome].add(value);\n  }\n\n  /// @param packedMapObject hero + heroId + biome (packMapObject)\n  function setIsBiomeBoss(bytes32 packedMapObject) external {\n    DungeonFactoryLib._S().bossCompleted[packedMapObject] = true;\n  }\n\n  /// @notice Two functions were combine to single one to reduce size\n  function initEnterOpenObjectTest(\n    IDungeonFactory.DungeonAttributes calldata value,\n    uint64 dungeonId,\n    uint16 dungNum,\n    uint8 stages,\n    uint32[] memory uniqObjects,\n    address heroToken,\n    uint heroTokenId\n  ) external {\n    DungeonFactoryLib._S().dungeonAttributes[dungNum] = value;\n    DungeonFactoryLib._S().dungeonStatuses[dungeonId].dungeonId = dungeonId;\n    DungeonFactoryLib._S().dungeonStatuses[dungeonId].dungNum = dungNum;\n    DungeonFactoryLib._S().dungeonStatuses[dungeonId].stages = stages;\n    DungeonFactoryLib._S().dungeonStatuses[dungeonId].uniqObjects = uniqObjects;\n    DungeonFactoryLib._S().dungeonStatuses[dungeonId].heroToken = heroToken;\n    DungeonFactoryLib._S().dungeonStatuses[dungeonId].heroTokenId = heroTokenId;\n\n    if (heroTokenId != 0) {\n      // we need following data for test openObject only\n      DungeonFactoryLib._S().heroCurrentDungeon[PackingLib.packNftId(heroToken, heroTokenId)] = dungeonId;\n    }\n  }\n}"
    },
    "contracts/test/facades/FacadeDungeonFactoryLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/PackingLib.sol\";\nimport \"../../lib/DungeonFactoryLib.sol\";\nimport \"../../interfaces/IItemController.sol\";\nimport \"../../interfaces/IAppErrors.sol\";\n\ncontract FacadeDungeonFactoryLib is IAppErrors {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n  IController internal _controller;\n\n  function _s() internal pure returns (IDungeonFactory.MainState storage) {\n    return DungeonLib._S();\n  }\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n  //region ------------------------ Initialization of _s()\n\n  function initFreeDungeons(uint key, uint[] memory values) external {\n    for (uint i = 0; i < values.length; ++i) {\n      _s().freeDungeons[key].add(values[i]);\n    }\n  }\n\n  function extractFreeDungeons(uint8 dungBiome) external view returns (uint[] memory dungIds) {\n    dungIds = new uint[](_s().freeDungeons[dungBiome].length());\n    for (uint i = 0; i < _s().freeDungeons[dungBiome].length(); ++i) {\n      dungIds[i] = _s().freeDungeons[dungBiome].at(i);\n    }\n  }\n\n  function initBossCompleted(address heroToken, uint64 heroTokenId, uint8 heroBiome, bool completed) external {\n    bytes32 key = PackingLib.packMapObject(heroToken, uint64(heroTokenId), heroBiome);\n    _s().bossCompleted[key] = completed;\n  }\n\n  function initMaxBiomeCompleted(address heroToken, uint64 heroTokenId, uint8 biome) external {\n    bytes32 key = PackingLib.packNftId(heroToken, uint64(heroTokenId));\n    _s().maxBiomeCompleted[key] = biome;\n  }\n\n  function initAllSpecificDungeons(uint[] memory values) external {\n    for (uint i = 0; i < values.length; ++i) {\n      _s().allSpecificDungeons.add(values[i]);\n    }\n  }\n\n  function initAllSpecificDungeonsForBiome(uint8 biome, uint[] memory values) external {\n    for (uint i = 0; i < values.length; ++i) {\n      _s().dungeonsLogicByBiome[biome].add(values[i]);\n    }\n  }\n\n  function initDungeonCounter(uint64 dungeonCounter_) external {\n    _s().dungeonCounter = dungeonCounter_;\n  }\n\n  function initDungeonAttributes(uint16 dungNum, IDungeonFactory.DungeonAttributes memory value) external {\n    _s().dungeonAttributes[dungNum] = value;\n  }\n\n  function initDungeonStatuses(\n    uint64 dungeonId,\n    uint16 dungNum,\n    bool isCompleted,\n    address heroToken,\n    uint heroTokenId,\n    uint32 currentObject,\n    uint8 currentStage,\n    bytes32[] memory treasuryItems,\n    uint8 stages,\n    uint32[] memory uniqObjects\n  ) external {\n    _s().dungeonStatuses[dungeonId].dungeonId = dungeonId;\n    _s().dungeonStatuses[dungeonId].dungNum = dungNum;\n    _s().dungeonStatuses[dungeonId].isCompleted = isCompleted;\n    _s().dungeonStatuses[dungeonId].heroToken = heroToken;\n    _s().dungeonStatuses[dungeonId].heroTokenId = heroTokenId;\n    _s().dungeonStatuses[dungeonId].currentObject = currentObject;\n    _s().dungeonStatuses[dungeonId].currentStage = currentStage;\n    _s().dungeonStatuses[dungeonId].treasuryItems = treasuryItems;\n    _s().dungeonStatuses[dungeonId].stages = stages;\n    _s().dungeonStatuses[dungeonId].uniqObjects = uniqObjects;\n  }\n\n  function extractDungAttributes(uint16 dungNum) external view returns (\n    uint8 stages,\n    uint8 biome,\n    uint32[] memory uniqObjects,\n    bytes32 minMaxLevel,\n    bytes32[] memory requiredCustomDataIndex,\n    bytes32[] memory requiredCustomDataValue,\n    bytes32[] memory objTypesByStages,\n    uint32[][] memory objChancesByStages\n  ) {\n    IDungeonFactory.DungeonAttributes memory da = _s().dungeonAttributes[dungNum];\n    return (\n      da.stages,\n      da.biome,\n      da.uniqObjects,\n      da.minMaxLevel,\n      da.requiredCustomDataIndex,\n      da.requiredCustomDataValue,\n      da.info.objTypesByStages,\n      da.info.objChancesByStages\n    );\n  }\n\n  function extractMaxBiome() external view returns (uint) {\n    return _s().maxBiome;\n  }\n\n  function extractDungeonsLogicByBiome(uint8 biome, uint16 dungNum) external view returns (bool) {\n    return _s().dungeonsLogicByBiome[biome].contains(dungNum);\n  }\n\n  function extractDungeonSpecific(uint8 specReqBiome, uint8 specReqHeroClass) external view returns (uint16) {\n    return _s().dungeonSpecific[DungeonLib._toUint8PackedArray(specReqBiome, specReqHeroClass)];\n  }\n\n  function extractAllSpecificDungeons(uint16 dungNum) external view returns (bool) {\n    return _s().allSpecificDungeons.contains(dungNum);\n  }\n\n  function extractMinLevelForTreasury(address token) external view returns (uint) {\n    return _s().minLevelForTreasury[token];\n  }\n\n  function isBossCompleted(address heroToken, uint64 heroTokenId, uint8 heroBiome) external view returns (bool) {\n    bytes32 key = PackingLib.packMapObject(heroToken, uint64(heroTokenId), heroBiome);\n    return _s().bossCompleted[key];\n  }\n\n  function setHeroCurrentDungeon(address heroToken, uint heroTokenId, uint64 dungId) external {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    _s().heroCurrentDungeon[heroPackedId] = dungId;\n  }\n  function extractHeroCurrentDungeon(address heroToken, uint heroTokenId) external view returns (uint64) {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    return _s().heroCurrentDungeon[heroPackedId];\n  }\n\n  function extractTreasureTokens(uint64 dungId, address treasureToken) external view returns (uint treasureAmount) {\n    if (_s().dungeonStatuses[dungId].treasuryTokens.contains(treasureToken)) {\n      return _s().dungeonStatuses[dungId].treasuryTokens.get(treasureToken);\n    } else {\n      return type(uint).max;\n    }\n  }\n\n  function initDungeonSpecific(uint8 specReqBiome, uint8 specReqHeroClass, uint16 specificDungeon) external {\n    _s().dungeonSpecific[PackingLib.packUint8Array3(specReqBiome, specReqHeroClass, 0)] = specificDungeon;\n  }\n\n  //endregion ------------------------ Initialization of _s()\n\n  //region ------------------------ VIEWS\n\n  function dungeonAttributes(uint16 dungLogicNum) external view returns (IDungeonFactory.DungeonAttributes memory) {\n    return DungeonFactoryLib.dungeonAttributes(dungLogicNum);\n  }\n  function dungeonStatus(uint64 dungeonId) external view returns (\n    uint16 dungNum,\n    bool isCompleted,\n    address heroToken,\n    uint heroTokenId,\n    uint32 currentObject,\n    uint8 currentObjIndex,\n    address[] memory treasuryTokens,\n    uint[] memory treasuryTokensAmounts,\n    bytes32[] memory treasuryItems,\n    uint8 stages,\n    uint32[] memory uniqObjects\n  ) {\n    return DungeonFactoryLib.dungeonStatus(dungeonId);\n  }\n\n  function dungeonCounter() external view returns (uint64) {\n    return DungeonFactoryLib.dungeonCounter();\n  }\n\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8) {\n    return DungeonFactoryLib.maxBiomeCompleted(heroToken, heroTokenId);\n  }\n\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64) {\n    return DungeonFactoryLib.currentDungeon(heroToken, heroTokenId);\n  }\n\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result) {\n    return DungeonFactoryLib.skillSlotsForDurabilityReduction(heroToken, heroTokenId);\n  }\n\n  function freeDungeonsByLevelLength(uint biome) external view returns (uint) {\n    return DungeonFactoryLib.freeDungeonsByLevelLength(biome);\n  }\n\n  function freeDungeonsByLevel(uint index, uint biome) external view returns (uint64) {\n    return DungeonFactoryLib.freeDungeonsByLevel(index, biome);\n  }\n\n  function getDungeonTreasuryAmount(address token, uint heroLevel, uint biome) public view returns (\n    uint totalAmount,\n    uint amountForDungeon,\n    uint mintAmount\n  ) {\n    return DungeonFactoryLib.getDungeonTreasuryAmount(_controller, token, heroLevel, biome);\n  }\n\n  /// @dev Easily get info should given hero fight with boss in the current biome or not.\n  function isBiomeBoss(address heroToken, uint heroTokenId) external view returns (bool) {\n    return DungeonFactoryLib.isBiomeBoss(_controller, heroToken, heroTokenId);\n  }\n\n  function _getBossCompletedIndex(uint8 heroBiome) external pure returns (bytes32) {\n    return DungeonFactoryLib._getBossCompletedIndex(heroBiome);\n  }\n\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ ACTIONS\n\n  function launch(bool isNotSmartContract_, address msgSender, address heroToken, uint heroTokenId, address treasuryToken) external returns (uint64 dungeonId) {\n    return DungeonFactoryLib.launch(isNotSmartContract_, _controller, msgSender, heroToken, heroTokenId, treasuryToken);\n  }\n\n  function launchForNewHero(address msgSender, address heroToken, uint heroTokenId) external returns (uint64 dungeonId) {\n    return DungeonFactoryLib.launchForNewHero(_controller, msgSender, heroToken, heroTokenId);\n  }\n\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external {\n    DungeonFactoryLib.setBossCompleted(_controller, objectId, heroToken, heroTokenId, heroBiome);\n  }\n  //endregion ------------------------ ACTIONS\n\n  //region ------------------------ USER ACTIONS\n  function enter(bool isNotSmartContract_, address msgSender_, uint64 dungId, address heroToken_, uint heroTokenId_) external {\n    DungeonFactoryLib.enter(isNotSmartContract_, _controller, msgSender_, dungId, heroToken_, heroTokenId_);\n  }\n\n  function openObject(bool isNotSmartContract_, address msgSender_, uint64 dungId) external {\n    DungeonFactoryLib.openObject(isNotSmartContract_, _controller, msgSender_, dungId);\n  }\n\n  function objectAction(bool isNotSmartContract_, address msgSender_, uint64 dungId, bytes memory data) external {\n    DungeonFactoryLib.objectAction(isNotSmartContract_, _controller, msgSender_, dungId, data);\n  }\n\n  function exit(bool isNotSmartContract_, address msgSender_, uint64 dungId, bool claim) external {\n    DungeonFactoryLib.exit(isNotSmartContract_, _controller, msgSender_, dungId, claim);\n  }\n  //endregion ------------------------ USER ACTIONS\n\n  //region ------------------------ DUNGEON LOGIC - INTERNAL LOGIC\n\n  function _generateObject(uint64 dungeonId, uint stage, uint16 dungNum, IGOC goc, address heroToken, uint heroTokenId)\n  external returns (uint32 objectId) {\n    IDungeonFactory.DungeonStatus storage dungStatus = _s().dungeonStatuses[dungeonId];\n    IDungeonFactory.DungeonAttributes storage da = _s().dungeonAttributes[dungNum];\n    return DungeonFactoryLib._generateObject(da, dungStatus, stage, goc, heroToken, heroTokenId);\n  }\n\n  function _clear(uint8 biome, uint64 dungId) external {\n    DungeonFactoryLib._clear(_s().dungeonStatuses[dungId], biome, dungId);\n  }\n\n  /// @notice Check: hero is registered, not dead, in the dungeon, sender is the owner, the dungeon is not completed\n  /// @return heroToken Token of the hero who is in the dungeon\n  /// @return heroTokenId Token ID of the hero who is in the dungeon\n  function _checkCurrentHero(uint64 dungeonId, address msgSender) external view returns (address heroToken, uint heroTokenId) {\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(_controller);\n    return DungeonFactoryLib._checkCurrentHero(_s().dungeonStatuses[dungeonId], msgSender, cc);\n  }\n\n  function _addFreeDungeon(uint8 biome, uint64 dungeonId) external {\n    DungeonFactoryLib._addFreeDungeon(biome, dungeonId);\n  }\n  //endregion ------------------------ DUNGEON LOGIC - INTERNAL LOGIC\n\n  /// @dev Set eligible hero level for treasury tokens\n  function setMinLevelForTreasury(address token, uint heroLevel) external {\n    DungeonFactoryLib.setMinLevelForTreasury(_controller, token, heroLevel);\n  }\n}\n\n"
    },
    "contracts/test/facades/FacadeDungeonFactoryLibGovActions.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/PackingLib.sol\";\nimport \"../../lib/DungeonFactoryLib.sol\";\nimport \"../../interfaces/IItemController.sol\";\nimport \"../../interfaces/IAppErrors.sol\";\n\ncontract FacadeDungeonFactoryLibGovActions is IAppErrors {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n  IController internal _controller;\n\n  function _s() internal pure returns (IDungeonFactory.MainState storage) {\n    return DungeonLib._S();\n  }\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n\n  //region ------------------------ for tests\n  function initFreeDungeons(uint key, uint[] memory values) external {\n    for (uint i = 0; i < values.length; ++i) {\n      _s().freeDungeons[key].add(values[i]);\n    }\n  }\n\n  function extractFreeDungeons(uint8 dungBiome) external view returns (uint[] memory dungIds) {\n    dungIds = new uint[](_s().freeDungeons[dungBiome].length());\n    for (uint i = 0; i < _s().freeDungeons[dungBiome].length(); ++i) {\n      dungIds[i] = _s().freeDungeons[dungBiome].at(i);\n    }\n  }\n\n  function initBossCompleted(address heroToken, uint64 heroTokenId, uint8 heroBiome, bool completed) external {\n    bytes32 key = PackingLib.packMapObject(heroToken, uint64(heroTokenId), heroBiome);\n    _s().bossCompleted[key] = completed;\n  }\n\n  function initMaxBiomeCompleted(address heroToken, uint64 heroTokenId, uint8 biome) external {\n    bytes32 key = PackingLib.packNftId(heroToken, uint64(heroTokenId));\n    _s().maxBiomeCompleted[key] = biome;\n  }\n\n  function initAllSpecificDungeons(uint[] memory values) external {\n    for (uint i = 0; i < values.length; ++i) {\n      _s().allSpecificDungeons.add(values[i]);\n    }\n  }\n\n  function initAllSpecificDungeonsForBiome(uint8 biome, uint[] memory values) external {\n    for (uint i = 0; i < values.length; ++i) {\n      _s().dungeonsLogicByBiome[biome].add(values[i]);\n    }\n  }\n\n  function initDungeonCounter(uint64 dungeonCounter_) external {\n    _s().dungeonCounter = dungeonCounter_;\n  }\n\n  function initDungeonAttributes(uint16 dungNum, IDungeonFactory.DungeonAttributes memory value) external {\n    _s().dungeonAttributes[dungNum] = value;\n  }\n\n  function initDungeonStatuses(\n    uint64 dungeonId,\n    uint16 dungNum,\n    bool isCompleted,\n    address heroToken,\n    uint heroTokenId,\n    uint32 currentObject,\n    uint8 currentStage,\n    bytes32[] memory treasuryItems,\n    uint8 stages,\n    uint32[] memory uniqObjects\n  ) external {\n    _s().dungeonStatuses[dungeonId].dungeonId = dungeonId;\n    _s().dungeonStatuses[dungeonId].dungNum = dungNum;\n    _s().dungeonStatuses[dungeonId].isCompleted = isCompleted;\n    _s().dungeonStatuses[dungeonId].heroToken = heroToken;\n    _s().dungeonStatuses[dungeonId].heroTokenId = heroTokenId;\n    _s().dungeonStatuses[dungeonId].currentObject = currentObject;\n    _s().dungeonStatuses[dungeonId].currentStage = currentStage;\n    _s().dungeonStatuses[dungeonId].treasuryItems = treasuryItems;\n    _s().dungeonStatuses[dungeonId].stages = stages;\n    _s().dungeonStatuses[dungeonId].uniqObjects = uniqObjects;\n  }\n\n  function extractDungAttributes(uint16 dungNum) external view returns (\n    uint8 stages,\n    uint8 biome,\n    uint32[] memory uniqObjects,\n    bytes32 minMaxLevel,\n    bytes32[] memory requiredCustomDataIndex,\n    bytes32[] memory requiredCustomDataValue,\n    bytes32[] memory objTypesByStages,\n    uint32[][] memory objChancesByStages\n  ) {\n    IDungeonFactory.DungeonAttributes memory da = _s().dungeonAttributes[dungNum];\n    return (\n      da.stages,\n      da.biome,\n      da.uniqObjects,\n      da.minMaxLevel,\n      da.requiredCustomDataIndex,\n      da.requiredCustomDataValue,\n      da.info.objTypesByStages,\n      da.info.objChancesByStages\n    );\n  }\n\n  function extractMaxBiome() external view returns (uint) {\n    return _s().maxBiome;\n  }\n\n  function extractDungeonsLogicByBiome(uint8 biome, uint16 dungNum) external view returns (bool) {\n    return _s().dungeonsLogicByBiome[biome].contains(dungNum);\n  }\n\n  function extractDungeonSpecific(uint8 specReqBiome, uint8 specReqHeroClass) external view returns (uint16) {\n    return _s().dungeonSpecific[DungeonLib._toUint8PackedArray(specReqBiome, specReqHeroClass)];\n  }\n\n  function extractAllSpecificDungeons(uint16 dungNum) external view returns (bool) {\n    return _s().allSpecificDungeons.contains(dungNum);\n  }\n\n  function extractMinLevelForTreasury(address token) external view returns (uint) {\n    return _s().minLevelForTreasury[token];\n  }\n\n  function isBossCompleted(address heroToken, uint64 heroTokenId, uint8 heroBiome) external view returns (bool) {\n    bytes32 key = PackingLib.packMapObject(heroToken, uint64(heroTokenId), heroBiome);\n    return _s().bossCompleted[key];\n  }\n\n  function setHeroCurrentDungeon(address heroToken, uint heroTokenId, uint64 dungId) external {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    _s().heroCurrentDungeon[heroPackedId] = dungId;\n  }\n  function extractHeroCurrentDungeon(address heroToken, uint heroTokenId) external view returns (uint64) {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    return _s().heroCurrentDungeon[heroPackedId];\n  }\n\n  function extractTreasureTokens(uint64 dungId, address treasureToken) external view returns (uint treasureAmount) {\n    if (_s().dungeonStatuses[dungId].treasuryTokens.contains(treasureToken)) {\n      return _s().dungeonStatuses[dungId].treasuryTokens.get(treasureToken);\n    } else {\n      return type(uint).max;\n    }\n  }\n\n  function initDungeonSpecific(uint8 specReqBiome, uint8 specReqHeroClass, uint16 specificDungeon) external {\n    _s().dungeonSpecific[PackingLib.packUint8Array3(specReqBiome, specReqHeroClass, 0)] = specificDungeon;\n  }\n  //endregion ------------------------ for tests\n\n  function dungeonStatus(uint64 dungeonId) external view returns (\n    uint16 dungNum,\n    bool isCompleted,\n    address heroToken,\n    uint heroTokenId,\n    uint32 currentObject,\n    uint8 currentObjIndex,\n    address[] memory treasuryTokens,\n    uint[] memory treasuryTokensAmounts,\n    bytes32[] memory treasuryItems,\n    uint8 stages,\n    uint32[] memory uniqObjects\n  ) {\n    return DungeonFactoryLib.dungeonStatus(dungeonId);\n  }\n\n\n  //region ------------------------ GOV ACTIONS\n\n  function registerDungeonLogic(\n    uint16 dungNum,\n    uint8 biome,\n    IDungeonFactory.DungeonGenerateInfo calldata genInfo,\n    uint8 heroLevel,\n    uint8 heroClass,\n    bool isSpecific\n  ) external {\n    DungeonFactoryLib.registerDungeonLogic(_controller, dungNum, biome, genInfo, heroLevel, heroClass, isSpecific);\n  }\n\n  function removeDungeonLogic(uint16 dungLogicId, uint8 heroLevel, uint8 heroClass) external {\n    DungeonFactoryLib.removeDungeonLogic(_controller, dungLogicId, heroLevel, heroClass);\n  }\n\n  /// @dev Set eligible hero level for treasury tokens\n  function setMinLevelForTreasury(address token, uint heroLevel) external {\n    DungeonFactoryLib.setMinLevelForTreasury(_controller, token, heroLevel);\n  }\n\n  /// @dev Governance can drop hero from dungeon in emergency case\n  function emergencyExit(uint64 dungId) external {\n    DungeonFactoryLib.emergencyExit(_controller, dungId);\n  }\n  //endregion ------------------------ GOV ACTIONS\n}\n\n"
    },
    "contracts/test/facades/FacadeDungeonLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../openzeppelin/EnumerableMap.sol\";\nimport \"../../interfaces/IDungeonFactory.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IHeroController.sol\";\nimport \"../../interfaces/IStatController.sol\";\nimport \"../../interfaces/IAppErrors.sol\";\nimport \"../../lib/DungeonLib.sol\";\nimport \"../../lib/DungeonFactoryLib.sol\";\n\n/// @dev We need IAppErrors to correctly handle custom errors in the tests\ncontract FacadeDungeonLib is IAppErrors {\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  IController internal _controller;\n\n  function _s() internal pure returns (IDungeonFactory.MainState storage) {\n    return DungeonLib._S();\n  }\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n\n  //region ------------------------ Init\n  function setTreasuryTokenValue(uint64 dungId, address token, uint value) external {\n    DungeonLib._S().dungeonStatuses[dungId].treasuryTokens.set(token, value);\n  }\n  function getTreasuryTokenValue(uint64 dungId, address token) external view returns (uint) {\n    if (DungeonLib._S().dungeonStatuses[dungId].treasuryTokens.contains(token)) {\n      return DungeonLib._S().dungeonStatuses[dungId].treasuryTokens.get(token);\n    } else {\n      return type(uint).max;\n    }\n  }\n  function setTreasureItem(uint64 dungId, address item, uint itemId) external {\n    DungeonLib._S().dungeonStatuses[dungId].treasuryItems.push(PackingLib.packNftId(item, itemId));\n  }\n\n  function getTreasuryItems(uint64 dungId) external view returns (\n    address[] memory tokens,\n    uint[] memory ids\n  ) {\n    bytes32[] storage treasuryItems = DungeonLib._S().dungeonStatuses[dungId].treasuryItems;\n    tokens = new address[](treasuryItems.length);\n    ids = new uint[](treasuryItems.length);\n\n    for (uint i = 0; i < treasuryItems.length; ++i) {\n      (address token, uint id) = PackingLib.unpackNftId(treasuryItems[i]);\n      tokens[i] = token;\n      ids[i] = id;\n    }\n  }\n\n  function getTreasuryTokens(uint64 dungId) external view returns (\n    address[] memory tokens,\n    uint[] memory values\n  ) {\n    EnumerableMap.AddressToUintMap storage treasuryTokens = DungeonLib._S().dungeonStatuses[dungId].treasuryTokens;\n    tokens = new address[](treasuryTokens.length());\n    values = new uint[](treasuryTokens.length());\n\n    for (uint i = 0; i < tokens.length; ++i) {\n      (address token, uint value) = treasuryTokens.at(i);\n      tokens[i] = token;\n      values[i] = value;\n    }\n  }\n\n  function setAllSpecificDungeons(uint16 dungNum) external {\n    DungeonLib._S().allSpecificDungeons.add(dungNum);\n  }\n\n  function getSpecificDungeonCompleted(address heroToken, uint64 heroTokenId, uint16 dungNum) external view returns (bool) {\n    return DungeonLib._S().specificDungeonCompleted[PackingLib.packDungeonKey(heroToken, heroTokenId, dungNum)];\n  }\n\n  function extractSkillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory) {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    bytes32 out = _s().skillSlotsForDurabilityReduction[heroPackedId];\n\n    return PackingLib.unpackUint8Array(out);\n  }\n\n  function initDungeonAttributes(uint16 dungNum, IDungeonFactory.DungeonAttributes memory value) external {\n    _s().dungeonAttributes[dungNum] = value;\n  }\n\n  function initDungeonStatuses(\n    uint64 dungeonId,\n    uint16 dungNum,\n    bool isCompleted,\n    address heroToken,\n    uint heroTokenId,\n    uint32 currentObject,\n    uint8 currentStage,\n    bytes32[] memory treasuryItems,\n    uint8 stages,\n    uint32[] memory uniqObjects\n  ) external {\n    IDungeonFactory.DungeonStatus storage __dungStatus = _s().dungeonStatuses[dungeonId];\n    __dungStatus.dungeonId = dungeonId;\n    __dungStatus.dungNum = dungNum;\n    __dungStatus.isCompleted = isCompleted;\n    __dungStatus.heroToken = heroToken;\n    __dungStatus.heroTokenId = heroTokenId;\n    __dungStatus.currentObject = currentObject;\n    __dungStatus.currentStage = currentStage;\n    __dungStatus.treasuryItems = treasuryItems;\n    __dungStatus.stages = stages;\n    __dungStatus.uniqObjects = uniqObjects;\n  }\n\n  function extractDungeonStatus(uint64 dungeonId) external view returns (\n    uint16 dungNum,\n    bool isCompleted,\n    address heroToken,\n    uint heroTokenId,\n    uint32 currentObject,\n    uint8 currentStage,\n    address[] memory treasuryTokens,\n    uint[] memory treasuryTokensAmounts,\n    bytes32[] memory treasuryItems,\n    uint8 stages,\n    uint32[] memory uniqObjects\n  ) {\n    return DungeonFactoryLib.dungeonStatus(dungeonId);\n  }\n\n  function initFreeDungeons(uint8 dungBiome, uint dungId) external {\n    _s().freeDungeons[dungBiome].add(dungId);\n  }\n\n  function extractFreeDungeons(uint8 dungBiome) external view returns (uint[] memory dungIds) {\n    dungIds = new uint[](_s().freeDungeons[dungBiome].length());\n    for (uint i = 0; i < _s().freeDungeons[dungBiome].length(); ++i) {\n      dungIds[i] = _s().freeDungeons[dungBiome].at(i);\n    }\n  }\n\n  function setHeroCurrentDungeon(address heroToken, uint heroTokenId, uint64 dungId) external {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    _s().heroCurrentDungeon[heroPackedId] = dungId;\n  }\n  function extractHeroCurrentDungeon(address heroToken, uint heroTokenId) external view returns (uint64) {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    return _s().heroCurrentDungeon[heroPackedId];\n  }\n\n  function initDungeonSpecific(uint8 heroLevel, uint8 heroClass, uint16 specificDungeon) external {\n    uint8 level = heroLevel == 0\n      ? 0\n      : heroLevel / uint8(StatLib.BIOME_LEVEL_STEP) + 1;\n    _s().dungeonSpecific[PackingLib.packUint8Array3(level, heroClass, 0)] = specificDungeon;\n  }\n\n  function initSpecificDungeonCompleted(address heroToken, uint heroTokenId, uint16 dungNum, bool completed) external {\n    bytes32 key = PackingLib.packDungeonKey(heroToken, uint80(heroTokenId), dungNum);\n    _s().specificDungeonCompleted[key] = completed;\n  }\n\n  function initDungeonsLogicByBiome(uint8 biome, uint[] memory dungNums) external {\n    for (uint i = 0; i < dungNums.length; ++i) {\n      _s().dungeonsLogicByBiome[biome].add(dungNums[i]);\n    }\n  }\n\n  function initMinLevelForTreasury(address token, uint8 level) external {\n    _s().minLevelForTreasury[token] = level;\n  }\n\n  function initMaxBiome(uint8 maxBiome) external {\n    _s().maxBiome = maxBiome;\n  }\n\n  function minLevelForTreasury(address token) external view returns (uint level) {\n    return _s().minLevelForTreasury[token];\n  }\n  //endregion ------------------------ Init\n\n\n  //region ------------------------ Common\n  function dungeonTreasuryReward(address token, uint maxAvailableBiome, uint treasuryBalance, uint heroLevel, uint dungeonBiome) external view returns (uint) {\n    return DungeonLib.dungeonTreasuryReward(token, maxAvailableBiome, treasuryBalance, heroLevel, dungeonBiome);\n  }\n  //endregion ------------------------ Common\n\n  //region ------------------------ Main logic\n\n  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  // Main logic is moved to FacadeDungeonLibMain\n  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ ENTER/EXIT\n\n  function _enter(uint64 dungId, address heroToken_, uint heroTokenId_) external {\n    IDungeonFactory.DungeonStatus storage dungStatus = _s().dungeonStatuses[dungId];\n    uint16 dungNum = dungStatus.dungNum;\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(_controller);\n    DungeonLib._enter(cc, dungStatus, _s().dungeonAttributes[dungNum], dungNum, dungId, heroToken_, heroTokenId_);\n  }\n\n  function isDungeonEligibleForHero(\n    uint16 dungNum,\n    uint8 heroLevel,\n    address heroToken,\n    uint heroTokenId\n  ) external view returns (bool) {\n    return DungeonLib.isDungeonEligibleForHero(_s(), IStatController(_controller.statController()), dungNum, heroLevel, heroToken, heroTokenId);\n  }\n\n  function getDungeonLogic(uint8 heroLevel, address heroToken, uint heroTokenId, uint random) external view returns (uint16) {\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(_controller);\n    return DungeonLib.getDungeonLogic(_s(), cc, heroLevel, heroToken, heroTokenId, random);\n  }\n\n  function exitDungeon(uint64 dungId, bool claim, address msgSender) external {\n    DungeonLib.exitDungeon(_controller, dungId, claim, msgSender);\n  }\n\n  function emergencyExit(uint64 dungId) external {\n    DungeonLib.emergencyExit(_controller, dungId);\n  }\n\n  function _getSkillSlotsForHero(address heroToken, uint heroTokenId) external view returns (\n    address[3] memory skillSlotAdr,\n    uint[3] memory skillSlotIds\n  ) {\n    return DungeonLib._getSkillSlotsForHero(IStatController(_controller.statController()), heroToken, heroTokenId);\n  }\n\n  /// @dev mark skill slots for durability reduction\n  function markSkillSlotsForDurabilityReduction(bytes memory data, address heroToken, uint heroTokenId) external {\n    return DungeonLib._markSkillSlotsForDurabilityReduction(\n      _s(),\n      IStatController(_controller.statController()),\n      IItemController(_controller.itemController()),\n      data,\n      heroToken,\n      heroTokenId\n    );\n  }\n\n  /// @dev clear all skill slots marks\n  function releaseSkillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external {\n    return DungeonLib._releaseSkillSlotsForDurabilityReduction(_s(), heroToken, heroTokenId);\n  }\n  //endregion ------------------------ ENTER/EXIT\n\n  //region ------------------------ CLAIM\n\n  function _claimAll(\n    address msgSender,\n    uint64 dungId,\n    address heroToken,\n    uint heroTokenId,\n    address heroPayToken\n  ) external {\n    IDungeonFactory.DungeonStatus storage dungStatus = _s().dungeonStatuses[dungId];\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(_controller);\n    DungeonLib._claimAll(cc, msgSender, dungId, dungStatus, heroToken, heroTokenId, heroPayToken);\n  }\n\n  function _claimToken(\n    uint64 dungId,\n    DungeonLib.ClaimContext memory context,\n    address token,\n    uint amount\n  ) external returns (\n    address contextGameToken,\n    address contextReinforcementController,\n    address contextOracle\n  ) {\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(_controller);\n    DungeonLib._claimToken(\n      _s().dungeonStatuses[dungId].treasuryTokens,\n      context,\n      cc,\n      token,\n      amount\n    );\n    return (address(cc.gameToken), address(cc.reinforcementController), address(cc.oracle));\n  }\n\n  function _claimItem(\n    DungeonLib.ClaimContext memory context,\n    address token,\n    uint tokenId\n  ) external returns (\n    address contextReinforcementController,\n    address contextOracle\n  ) {\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(_controller);\n    DungeonLib._claimItem(context, cc, token, tokenId);\n    return (address(cc.reinforcementController), address(cc.oracle));\n  }\n  //endregion ------------------------ CLAIM\n\n  //region ------------------------ Utils\n  function _toUint8PackedArray(uint8 val0, uint8 val1) external pure returns (bytes32 key) {\n    return DungeonLib._toUint8PackedArray(val0, val1);\n  }\n\n  function _toUint8ArrayWithoutZeroes(bytes32 data) external pure returns (uint8[] memory result) {\n    return DungeonLib._toUint8ArrayWithoutZeroes(data);\n  }\n  //endregion ------------------------ Utils\n\n}\n"
    },
    "contracts/test/facades/FacadeDungeonLibMain.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../openzeppelin/EnumerableMap.sol\";\nimport \"../../interfaces/IDungeonFactory.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IHeroController.sol\";\nimport \"../../interfaces/IStatController.sol\";\nimport \"../../interfaces/IAppErrors.sol\";\nimport \"../../lib/DungeonLib.sol\";\nimport \"../../lib/DungeonFactoryLib.sol\";\n\n/// @dev We need IAppErrors to correctly handle custom errors in the tests\ncontract FacadeDungeonLibMain is IAppErrors {\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  IController internal _controller;\n\n  function _s() internal pure returns (IDungeonFactory.MainState storage) {\n    return DungeonLib._S();\n  }\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n  //region ------------------------ Init\n  function setTreasuryTokenValue(uint64 dungId, address token, uint value) external {\n    DungeonLib._S().dungeonStatuses[dungId].treasuryTokens.set(token, value);\n  }\n  function getTreasuryTokenValue(uint64 dungId, address token) external view returns (uint) {\n    if (DungeonLib._S().dungeonStatuses[dungId].treasuryTokens.contains(token)) {\n      return DungeonLib._S().dungeonStatuses[dungId].treasuryTokens.get(token);\n    } else {\n      return type(uint).max;\n    }\n  }\n  function setTreasureItem(uint64 dungId, address item, uint itemId) external {\n    DungeonLib._S().dungeonStatuses[dungId].treasuryItems.push(PackingLib.packNftId(item, itemId));\n  }\n\n  function getTreasuryItems(uint64 dungId) external view returns (\n    address[] memory tokens,\n    uint[] memory ids\n  ) {\n    bytes32[] storage treasuryItems = DungeonLib._S().dungeonStatuses[dungId].treasuryItems;\n    tokens = new address[](treasuryItems.length);\n    ids = new uint[](treasuryItems.length);\n\n    for (uint i = 0; i < treasuryItems.length; ++i) {\n      (address token, uint id) = PackingLib.unpackNftId(treasuryItems[i]);\n      tokens[i] = token;\n      ids[i] = id;\n    }\n  }\n\n  function getTreasuryTokens(uint64 dungId) external view returns (\n    address[] memory tokens,\n    uint[] memory values\n  ) {\n    EnumerableMap.AddressToUintMap storage treasuryTokens = DungeonLib._S().dungeonStatuses[dungId].treasuryTokens;\n    tokens = new address[](treasuryTokens.length());\n    values = new uint[](treasuryTokens.length());\n\n    for (uint i = 0; i < tokens.length; ++i) {\n      (address token, uint value) = treasuryTokens.at(i);\n      tokens[i] = token;\n      values[i] = value;\n    }\n  }\n\n  function setAllSpecificDungeons(uint16 dungNum) external {\n    DungeonLib._S().allSpecificDungeons.add(dungNum);\n  }\n\n  function getSpecificDungeonCompleted(address heroToken, uint64 heroTokenId, uint16 dungNum) external view returns (bool) {\n    return DungeonLib._S().specificDungeonCompleted[PackingLib.packDungeonKey(heroToken, heroTokenId, dungNum)];\n  }\n\n  function extractSkillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory) {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    bytes32 out = _s().skillSlotsForDurabilityReduction[heroPackedId];\n\n    return PackingLib.unpackUint8Array(out);\n  }\n\n  function setSkillSlotsForDurabilityReduction(address heroToken, uint heroTokenId, uint8[] memory data) external {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    _s().skillSlotsForDurabilityReduction[heroPackedId] = PackingLib.packUint8Array(data);\n  }\n\n  function initDungeonAttributes(uint16 dungNum, IDungeonFactory.DungeonAttributes memory value) external {\n    _s().dungeonAttributes[dungNum] = value;\n  }\n\n  function initDungeonStatuses(\n    uint64 dungeonId,\n    uint16 dungNum,\n    bool isCompleted,\n    address heroToken,\n    uint heroTokenId,\n    uint32 currentObject,\n    uint8 currentStage,\n    bytes32[] memory treasuryItems,\n    uint8 stages,\n    uint32[] memory uniqObjects\n  ) external {\n    IDungeonFactory.DungeonStatus storage __dungStatus = _s().dungeonStatuses[dungeonId];\n    __dungStatus.dungeonId = dungeonId;\n    __dungStatus.dungNum = dungNum;\n    __dungStatus.isCompleted = isCompleted;\n    __dungStatus.heroToken = heroToken;\n    __dungStatus.heroTokenId = heroTokenId;\n    __dungStatus.currentObject = currentObject;\n    __dungStatus.currentStage = currentStage;\n    __dungStatus.treasuryItems = treasuryItems;\n    __dungStatus.stages = stages;\n    __dungStatus.uniqObjects = uniqObjects;\n  }\n\n  function extractDungeonStatus(uint64 dungeonId) external view returns (\n    uint16 dungNum,\n    bool isCompleted,\n    address heroToken,\n    uint heroTokenId,\n    uint32 currentObject,\n    uint8 currentStage,\n    address[] memory treasuryTokens,\n    uint[] memory treasuryTokensAmounts,\n    bytes32[] memory treasuryItems,\n    uint8 stages,\n    uint32[] memory uniqObjects\n  ) {\n    return DungeonFactoryLib.dungeonStatus(dungeonId);\n  }\n\n  function initFreeDungeons(uint8 dungBiome, uint dungId) external {\n    _s().freeDungeons[dungBiome].add(dungId);\n  }\n\n  function extractFreeDungeons(uint8 dungBiome) external view returns (uint[] memory dungIds) {\n    dungIds = new uint[](_s().freeDungeons[dungBiome].length());\n    for (uint i = 0; i < _s().freeDungeons[dungBiome].length(); ++i) {\n      dungIds[i] = _s().freeDungeons[dungBiome].at(i);\n    }\n  }\n\n  function setHeroCurrentDungeon(address heroToken, uint heroTokenId, uint64 dungId) external {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    _s().heroCurrentDungeon[heroPackedId] = dungId;\n  }\n  function extractHeroCurrentDungeon(address heroToken, uint heroTokenId) external view returns (uint64) {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    return _s().heroCurrentDungeon[heroPackedId];\n  }\n\n\n  function initMinLevelForTreasury(address token, uint8 level) external {\n    _s().minLevelForTreasury[token] = level;\n  }\n\n  function initMaxBiome(uint8 maxBiome) external {\n    _s().maxBiome = maxBiome;\n  }\n  //endregion ------------------------ Init\n\n  //region ------------------------ Main logic\n\n  function objectAction(\n    uint64 dungId,\n    address msgSender,\n    bytes memory data,\n    uint32 _currentObject\n  ) external returns (\n    bool isCompleted,\n    uint currentStage,\n    uint32 currentObject,\n    bool clear\n  ) {\n    IDungeonFactory.DungeonStatus storage dungStatus = _s().dungeonStatuses[dungId];\n    return DungeonLib.objectAction(dungStatus, _s().dungeonAttributes[dungStatus.dungNum], dungId, msgSender, data, _controller, _currentObject);\n  }\n\n  function _objectAction(DungeonLib.ObjectActionInternalData memory context) external returns (\n    bool isCompleted,\n    uint currentStage,\n    uint32 currentObject,\n    bool clear\n  ) {\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(_controller);\n    IDungeonFactory.DungeonStatus storage dungStatus = _s().dungeonStatuses[context.dungId];\n    return DungeonLib._objectAction(context, dungStatus, _s().dungeonAttributes[dungStatus.dungNum], cc);\n  }\n\n  function _killHero(uint64 dungId, address heroToken_, uint _heroTokenId) external {\n    return DungeonLib._killHero(IHeroController(_controller.heroController()), dungId, heroToken_, _heroTokenId,\n      DungeonLib._S().dungeonStatuses[dungId].treasuryItems\n    );\n  }\n\n  /// @dev Not necessary to call if a hero is dead\n  function _afterObjCompleteForSurvivedHero(DungeonLib.ObjectActionInternalData memory context) external {\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(_controller);\n    return DungeonLib._afterObjCompleteForSurvivedHero(context, cc);\n  }\n\n  function _nextRoomOrComplete(\n    DungeonLib.ObjectActionInternalData memory context,\n    uint curStages\n  ) external returns (\n    bool isCompleted,\n    uint currentStage,\n    uint32 currentObj\n  ) {\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(_controller);\n    return DungeonLib._nextRoomOrComplete(\n      context,\n      cc,\n      _s().dungeonStatuses[context.dungId],\n      curStages,\n      DungeonLib._S().dungeonStatuses[context.dungId].treasuryTokens\n    );\n  }\n\n  function _increaseChangeableStats(address _heroToken, uint _heroTokenId, IGOC.ActionResult memory result) external {\n    return DungeonLib._increaseChangeableStats(IStatController(_controller.statController()), _heroToken, _heroTokenId, result);\n  }\n\n  function _decreaseChangeableStats(address _heroToken, uint _heroTokenId, IGOC.ActionResult memory result) external {\n    return DungeonLib._decreaseChangeableStats(IStatController(_controller.statController()), _heroToken, _heroTokenId, result);\n  }\n\n  function _reduceLifeChances(address _heroToken, uint _heroTokenId, uint32 curLife, uint32 curMana) external {\n    return DungeonLib._reduceLifeChances(IStatController(_controller.statController()), _heroToken, _heroTokenId, curLife, curMana);\n  }\n\n  function _mintItems(DungeonLib.ObjectActionInternalData memory context) external {\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(_controller);\n    return DungeonLib._mintItems(context, cc, DungeonLib._S().dungeonStatuses[context.dungId].treasuryItems);\n  }\n\n  function _registerTreasuryToken(uint64 dungId, address rewardToken, uint amount) external {\n    return DungeonLib._registerTreasuryToken(rewardToken, DungeonLib._S().dungeonStatuses[dungId].treasuryTokens, amount);\n  }\n  //endregion ------------------------ Main logic\n\n}"
    },
    "contracts/test/facades/FacadeEventLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\nimport \"../../interfaces/IStatController.sol\";\nimport \"../../interfaces/IOracle.sol\";\nimport \"../../interfaces/IGOC.sol\";\nimport \"../../lib/EventLib.sol\";\n\ncontract FacadeEventLib {\n  IGOC.EventInfo internal _info;\n  IController internal _controller;\n\n  mapping(uint => uint) private _pseudoRandomValue;\n  mapping(uint => mapping(uint => uint)) private _pseudoRandomValueWithSeed;\n  bool private _useRealPseudoRandom;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n  //region ------------------------ For tests\n  function getInfo() external view returns (IGOC.EventInfo memory) {\n    return _info;\n  }\n\n  function setPseudoRandomForTests(uint max, uint value) external {\n    _pseudoRandomValue[max] = value;\n  }\n\n  function _pseudoNextPrng(LibPRNG.PRNG memory, uint max) internal view returns (uint) {\n    return _pseudoRandomValue[max];\n  }\n\n  function _pseudoRandomForTests(uint max) internal view returns (uint) {\n    return _useRealPseudoRandom\n      ? CalcLib.pseudoRandom(max)\n      : _pseudoRandomValue[max];\n  }\n\n  function setUseRealPseudoRandom() external {\n    _useRealPseudoRandom = true;\n  }\n\n  function setPseudoRandomWithSeedForTests(uint max, uint seed, uint value) external {\n    _pseudoRandomValueWithSeed[max][seed] = value;\n  }\n\n  function _pseudoRandomWithSeedForTests(uint max, uint seed) internal view returns (uint) {\n    return _pseudoRandomValueWithSeed[max][seed];\n  }\n\n  //endregion ------------------------ For tests\n\n  //region ------------------------ Main logic\n\n  function action(IGOC.ActionContext memory ctx) external returns (IGOC.ActionResult memory) {\n    return EventLib.action(ctx, _info);\n  }\n\n  function eventRegInfoToInfo(IGOC.EventRegInfo calldata regInfo) external {\n    return EventLib.eventRegInfoToInfo(regInfo, _info);\n  }\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ Internal logic\n  function _eventAcceptResult(IGOC.ActionContext calldata ctx) external returns (IGOC.ActionResult memory) {\n    return EventLib._eventAcceptResult(ctx, _info);\n  }\n\n  function _noActionResult() external pure returns (IGOC.ActionResult memory) {\n    return EventLib._noActionResult();\n  }\n\n  function _generate(IGOC.ActionContext calldata ctx) external returns (IStatController.ActionInternalInfo memory) {\n    return EventLib._generate(ctx, _info, IStatController(_controller.statController()));\n  }\n\n  function _mintRandomItem(IGOC.ActionContext calldata ctx) external returns (address[] memory) {\n    return EventLib._mintRandomItem(\n      ctx,\n      _info,\n      IOracle(_controller.oracle()),\n      IStatController(_controller.statController()),\n      _pseudoNextPrng\n    );\n  }\n  //endregion ------------------------ Internal logic\n}"
    },
    "contracts/test/facades/FacadeFightLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IStatController.sol\";\nimport \"../../interfaces/IItemController.sol\";\nimport \"../../interfaces/IFightCalculator.sol\";\nimport \"../../interfaces/IApplicationEvents.sol\";\nimport \"../../lib/FightLib.sol\";\nimport \"../../lib/PackingLib.sol\";\n\ncontract FacadeFightLib is IApplicationEvents {\n  IController private _controller;\n  mapping(uint => uint) private _pseudoRandomValue;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n  //region ------------------------ For tests\n  function setPseudoRandomForTests(uint max, uint value) external {\n    _pseudoRandomValue[max] = value;\n  }\n\n  function _pseudoRandomForTests(uint max) internal view returns (uint) {\n    return _pseudoRandomValue[max];\n  }\n  //endregion ------------------------ For tests\n\n  //region ------------------------ Main logic\n  function fight(IFightCalculator.FightCall memory callData, address msgSender) external returns (\n    IFightCalculator.FightResult memory\n  ) {\n    return FightLib.fight(IItemController(_controller.itemController()), callData, msgSender, _pseudoRandomForTests);\n  }\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ High level of internal logic\n  function fightProcessing(IFightCalculator.FightInfoInternal memory fResult) external view returns (\n    IFightCalculator.FightInfoInternal memory\n  ) {\n    FightLib.fightProcessing(fResult, _pseudoRandomForTests);\n    return fResult;\n  }\n\n  function processAttack(\n    IFightCalculator.FightInfoInternal memory fResult,\n    bool isA\n  ) external view returns (FightLib.AttackResult memory attackResult) {\n    return FightLib.processAttack(fResult, isA, _pseudoRandomForTests);\n  }\n  //endregion ------------------------ High level of internal logic\n\n  //region ------------------------ Internal logic\n\n  function prepareFightInternalInfo(\n    IFightCalculator.FighterInfo memory fighterA,\n    IFightCalculator.FighterInfo memory fighterB\n  ) external view returns (IFightCalculator.FightInfoInternal memory fInfo) {\n    return FightLib.prepareFightInternalInfo(IItemController(_controller.itemController()), fighterA, fighterB);\n  }\n\n  function statusChance(\n    IFightCalculator.FighterInfo memory attackerInfo,\n    IItemController.AttackInfo memory attackerMA,\n    IStatController.ATTRIBUTES index,\n    int32 resist\n  ) external view returns (bool) {\n    return FightLib.statusChance(attackerInfo, attackerMA, index, resist, _pseudoRandomForTests);\n  }\n\n  function magicDamageCalculation(\n    IFightCalculator.FighterInfo memory attackerInfo,\n    IFightCalculator.FighterInfo memory defenderInfo,\n    IItemController.AttackInfo memory magicAttack,\n    int32 defenderHealth\n  ) external view returns (FightLib.AttackResult memory attackResult) {\n    return FightLib.magicDamageCalculation(attackerInfo, defenderInfo, magicAttack, defenderHealth, _pseudoRandomForTests);\n  }\n\n  function meleeDamageCalculation(\n    IFightCalculator.FighterInfo memory attackerInfo,\n    IFightCalculator.FighterInfo memory defenderInfo,\n    int32 defenderHealth\n  ) external view returns (FightLib.AttackResult memory attackResult) {\n    return FightLib.meleeDamageCalculation(attackerInfo, defenderInfo, defenderHealth, _pseudoRandomForTests);\n  }\n\n\n  //endregion ------------------------ Internal logic\n\n  //region ------------------------ Pure utils\n  function reduceAttributesByStatuses(\n    int32[] memory targetAttributes,\n    IFightCalculator.Statuses memory statuses,\n    int32[] memory casterAttributes\n  ) external pure returns (\n    int32[] memory targetAttributesOut,\n    int32[] memory casterAttributesOut\n  ) {\n    FightLib.reduceAttributesByStatuses(targetAttributes, statuses, casterAttributes);\n    return (targetAttributes, casterAttributes);\n  }\n\n  function increaseRaceDmg(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo, uint defenderRace) external pure returns (int32){\n    return FightLib.increaseRaceDmg(dmg, attackerInfo, defenderRace);\n  }\n\n  function increaseMeleeDmgByFactor(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo) external pure returns (int32){\n    return FightLib.increaseMeleeDmgByFactor(dmg, attackerInfo);\n  }\n\n  function increaseMagicDmgByFactor(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo, IItemController.AttackType aType) external pure returns (int32) {\n    return FightLib.increaseMagicDmgByFactor(dmg, attackerInfo, aType);\n  }\n\n  function decreaseRaceDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo, uint attackerRace) external pure returns (int32) {\n    return FightLib.decreaseRaceDmg(dmg, defenderInfo, attackerRace);\n  }\n\n  function decreaseDmgByDmgReduction(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) external pure returns (int32) {\n    return FightLib.decreaseDmgByDmgReduction(dmg, defenderInfo);\n  }\n\n  function reduceHp(\n    FightLib.AttackResult memory firstAttack,\n    FightLib.AttackResult memory secondAttack,\n    IFightCalculator.Fighter memory firstFighter,\n    IFightCalculator.Fighter memory secondFighter\n  ) external pure returns (\n    IFightCalculator.Fighter memory firstFighterOut,\n    IFightCalculator.Fighter memory secondFighterOut\n  ) {\n    FightLib.reduceHp(firstAttack, secondAttack, firstFighter, secondFighter);\n    return (firstFighter, secondFighter);\n  }\n\n  function stealLife(\n    IFightCalculator.Fighter memory fighter,\n    FightLib.AttackResult memory attackResult\n  ) external pure returns (\n    IFightCalculator.Fighter memory\n  ) {\n    FightLib.stealLife(fighter, attackResult);\n    return fighter;\n  }\n\n  function setStatuses(IFightCalculator.FightInfoInternal memory fResult, bool isA) external view returns (\n    IFightCalculator.FightInfoInternal memory\n  ){\n    FightLib.setStatuses(fResult, isA, _pseudoRandomForTests);\n    return fResult;\n  }\n\n  function calcFirstHit(IFightCalculator.FightInfoInternal memory fInfo) external pure returns (bool aFirst){\n    return FightLib.calcFirstHit(fInfo);\n  }\n\n  function skipTurn(IFightCalculator.FightInfoInternal memory fResult, bool isA) external pure returns (bool) {\n    return FightLib.skipTurn(fResult, isA);\n  }\n\n  function poisonDmg(int32 health, IFightCalculator.Statuses memory statuses) external pure returns (int32){\n    return FightLib.poisonDmg(health, statuses);\n  }\n\n  function isAttackerFaster(\n    IFightCalculator.FighterInfo memory fighterAInfo,\n    IFightCalculator.FighterInfo memory fighterBInfo\n  ) external pure returns (bool) {\n    return FightLib.isAttackerFaster(fighterAInfo, fighterBInfo);\n  }\n\n  function lifeStolenPerHit(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo) external pure returns (int32) {\n    return FightLib.lifeStolenPerHit(dmg, attackerInfo);\n  }\n\n  function reflectMeleeDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) external pure returns (int32){\n    return FightLib.reflectMeleeDmg(dmg, defenderInfo);\n  }\n\n  function reflectMagicDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) external pure returns (int32){\n    return FightLib.reflectMagicDmg(dmg, defenderInfo);\n  }\n\n  function _getChance(\n    IFightCalculator.FighterInfo memory attackerInfo,\n    IItemController.AttackType aType,\n    IStatController.ATTRIBUTES index,\n    int32 resist\n  ) external pure returns (int32 chance) {\n    return FightLib._getChance(attackerInfo, aType, index, resist);\n  }\n  //endregion ------------------------ Pure utils\n\n  //region ------------------------ SIP-002\n  function getReducedValue(uint y0, uint x, uint k) external pure returns (uint) {\n    return FightLib.getReducedValue(y0, x, k);\n  }\n\n  function adjustAttributes(int32[] memory attributes) external pure returns (int32[] memory) {\n    FightLib.adjustAttributes(attributes);\n    return attributes;\n  }\n  //endregion ------------------------ SIP-002\n\n}\n"
    },
    "contracts/test/facades/FacadeGameObjectControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../openzeppelin/EnumerableMap.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IStatController.sol\";\nimport \"../../lib/GOCLib.sol\";\nimport \"../../lib/PackingLib.sol\";\nimport \"../../lib/GameObjectControllerLib.sol\";\nimport {GameObjectController} from \"../../core/GameObjectController.sol\";\n\n/// @dev We need IAppErrors to correctly handle custom errors in the tests\ncontract FacadeGameObjectControllerLib is GameObjectController {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using PackingLib for address;\n\n  function _s() internal pure returns (IGOC.MainState storage) {\n    return GameObjectControllerLib._S();\n  }\n\n  //region ------------------------ For tests\n  function setFightDelay(uint delay) external {\n    _s().fightDelay = delay;\n  }\n  function setLastHeroFightTs(bytes32 packedHeroId, uint timestamp) external {\n    _s().lastHeroFightTs[packedHeroId] = timestamp;\n  }\n  function setIteration(bytes32 packedIterationKey, uint value) external {\n    _s().iterations[packedIterationKey] = value;\n  }\n  function getIterationByKey(bytes32 key) external view returns (uint) {\n    return _s().iterations[key];\n  }\n\n  function setObjects(bytes32 packedObjectMeta, uint[] calldata values) external {\n    EnumerableSet.UintSet storage _objects = _s().objectIds[packedObjectMeta];\n    for (uint i = 0; i < values.length; ++i) {\n      _objects.add(values[i]);\n    }\n  }\n\n  function packMonsterInfo(uint32 objectId, IGOC.MonsterGenInfo calldata mInfo) external {\n    MonsterLib.packMonsterInfo(mInfo, _s().monsterInfos[objectId]);\n  }\n  //endregion ------------------------ For tests\n\n  //region ------------------------ Utils\n\n  /// @notice Generate object ID using (biome, subType, id)\n  /// @param biome Biome to which the object belongs. [1..99]\n  /// @param subType Subtype of the object, see IGOC.ObjectSubType.XXX. [1..99]\n  /// @param id Id of the event / story / monster. [1..10_000]\n  function _genObjectId(uint8 biome, uint8 subType, uint16 id) external pure returns (uint32 objectId) {\n    return GameObjectControllerLib._genObjectId(biome, subType, id);\n  }\n\n  function _registerMetaId(uint8 biome, IGOC.ObjectSubType subType, uint16 id) external returns (uint32 objectId) {\n    return GameObjectControllerLib._registerMetaId(biome, subType, id);\n  }\n\n  function _checkAndRefreshFightTs(address hero, uint heroId) external {\n    return GameObjectControllerLib._checkAndRefreshFightTs(hero, heroId);\n  }\n\n  function _increaseIteration(address heroToken, uint heroTokenId, uint32 objId) external returns (uint iteration) {\n    return GameObjectControllerLib._increaseIteration(heroToken, heroTokenId, objId);\n  }\n\n  function _iterationKey(address heroToken, uint heroTokenId, uint32 objId) external pure returns (bytes32) {\n    return GameObjectControllerLib._iterationKey(heroToken, heroTokenId, objId);\n  }\n\n  function _checkMintItems(address[] memory mintItems_, uint32[] memory mintItemsChances_) external pure {\n    return GameObjectControllerLib._checkMintItems(mintItems_, mintItemsChances_);\n  }\n  //endregion ------------------------ Utils\n}"
    },
    "contracts/test/facades/FacadeGocLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../openzeppelin/EnumerableMap.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IStatController.sol\";\nimport \"../../interfaces/IAppErrors.sol\";\nimport \"../../lib/GOCLib.sol\";\nimport \"../../lib/GameObjectControllerLib.sol\";\n\n/// @dev We need IAppErrors to correctly handle custom errors in the tests\ncontract FacadeGocLib is IAppErrors {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using PackingLib for address;\n\n  IController private _controller;\n  mapping(uint => uint) private _pseudoRandomValue;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n\n  //region ------------------------ For tests\n  function setPseudoRandomForTests(uint max, uint value) external {\n    _pseudoRandomValue[max] = value;\n  }\n\n  function _pseudoRandomForTests(uint max) internal view returns (uint) {\n    return _pseudoRandomValue[max];\n  }\n  //endregion ------------------------ For tests\n\n  //region --------------------------------- Access\n  function _getMapItems(EnumerableSet.UintSet storage map) internal view returns (uint[] memory values) {\n    values = new uint[](map.length());\n\n    for (uint i = 0; i < map.length(); ++i) {\n      values[i] = map.at(i);\n    }\n  }\n\n  function _setMapItems(EnumerableSet.UintSet storage map, uint[] memory values) internal {\n    for (uint i = 0; i < values.length; ++i) {\n      map.add(values[i]);\n    }\n  }\n\n  function getPlayed(address heroToken, uint64 heroTokenId, uint8 cType, uint8 biome) external view returns (uint[] memory values) {\n    EnumerableSet.UintSet storage _played = _s().playedObjects[PackingLib.packPlayedObjKey(heroToken, heroTokenId, cType, biome)];\n    return _getMapItems(_played);\n  }\n  function setPlayed(address heroToken, uint64 heroTokenId, uint8 cType, uint8 biome, uint[] memory values) external {\n    EnumerableSet.UintSet storage _played = _s().playedObjects[PackingLib.packPlayedObjKey(heroToken, heroTokenId, cType, biome)];\n    return _setMapItems(_played, values);\n  }\n\n  function getObjects(uint8 cType, uint8 biome) external view returns (uint[] memory values) {\n    EnumerableSet.UintSet storage _objects = _s().objectIds[GOCLib.packObjectMeta(biome, cType)];\n    return _getMapItems(_objects);\n  }\n  function setObjects(uint8 cType, uint8 biome, uint[] memory values) external {\n    EnumerableSet.UintSet storage _objects = _s().objectIds[GOCLib.packObjectMeta(biome, cType)];\n    return _setMapItems(_objects, values);\n  }\n//endregion --------------------------------- Access\n\n//region --------------------------------- GOCLib\n  function _s() internal pure returns (IGOC.MainState storage) {\n    return GameObjectControllerLib._S();\n  }\n\n  /// @dev Chances in range 0-1e9\n  function getRandomObject(\n    uint8[] memory cTypes,\n    uint32[] memory chances,\n    uint8 biome,\n    address heroToken,\n    uint heroTokenId\n  ) external returns (uint32 objectId) {\n    return GOCLib.getRandomObject(_s(), IStoryController(_controller.storyController()), cTypes, chances, biome, heroToken, heroTokenId);\n  }\n\n  function _getObjectType(uint8[] memory cTypes, uint32[] memory chances) external view returns (uint8 cType) {\n    return GOCLib._getObjectType(cTypes, chances, _pseudoRandomForTests);\n  }\n\n  function _searchObject(\n    uint cLength,\n    uint objArrayIdx,\n    bool skipPlayed,\n    address heroToken,\n    uint heroTokenId,\n    uint8 cType,\n    uint8 biome\n  ) external returns (uint32 objectId) {\n    EnumerableSet.UintSet storage _played = _s().playedObjects[PackingLib.packPlayedObjKey(heroToken, uint64(heroTokenId), cType, biome)];\n    EnumerableSet.UintSet storage _objects = _s().objectIds[GOCLib.packObjectMeta(biome, cType)];\n    return GOCLib._searchObject(IStoryController(_controller.storyController()), cLength, _objects, _played, objArrayIdx, skipPlayed, heroToken, heroTokenId, cType);\n  }\n\n  function _clearPlayedObjects(address heroToken, uint64 heroTokenId, uint8 cType, uint8 biome) external {\n    EnumerableSet.UintSet storage _played = _s().playedObjects[PackingLib.packPlayedObjKey(heroToken, heroTokenId, cType, biome)];\n    return GOCLib._clearPlayedObjects(_played);\n  }\n\n  function isAvailableForHero(uint32 objId, uint8 objectSubType, address hero, uint heroId) public view returns (bool) {\n    return GOCLib.isAvailableForHero(IStoryController(_controller.storyController()), objId, objectSubType, hero, heroId);\n  }\n\n  function packObjectMeta(uint8 biome, uint8 oType) external pure returns (bytes32){\n    return GOCLib.packObjectMeta(biome, oType);\n  }\n\n  function unpackObjectMeta(bytes32 data) external pure returns (uint8 biome, uint8 oType){\n    return GOCLib.unpackObjectMeta(data);\n  }\n\n  function getObjectTypeBySubType(IGOC.ObjectSubType subType) public pure returns (IGOC.ObjectType) {\n    return GOCLib.getObjectTypeBySubType(subType);\n  }\n//endregion --------------------------------- GOCLib\n}\n"
    },
    "contracts/test/facades/FacadeGuildControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/GuildControllerLib.sol\";\n\ncontract FacadeGuildControllerLib {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  IController internal _controller;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n  //region ------------------------ For tests purposes\n  function getGuildControllerStorageLocation() external pure returns(bytes32) {\n    return keccak256(abi.encode(uint256(keccak256(\"guild.controller.main\")) - 1)) & ~bytes32(uint256(0xff));\n  }\n\n  function _setGuildData(uint guildId, IGuildController.GuildData memory guildData) external {\n    GuildControllerLib._S().guildData[guildId] = guildData;\n    GuildControllerLib._S().nameToGuild[guildData.guildName] = guildId;\n  }\n\n  function _setGuildMembers(uint guildId, address[] memory members) external {\n    for (uint i; i < members.length; ++i) {\n      GuildControllerLib._S().members[guildId].add(members[i]);\n      GuildControllerLib._S().memberToGuild[members[i]] = guildId;\n    }\n  }\n\n  function _setRights(address member, uint rights) external {\n    GuildControllerLib._S().rights[member] = rights;\n  }\n\n  //endregion ------------------------ For tests purposes\n\n  //region ------------------------ VIEWS\n  function counterGuildIds() external view returns (uint) {\n    return GuildControllerLib.counterGuildIds();\n  }\n\n  function getGuildData(uint guildId) external view returns (IGuildController.GuildData memory) {\n    return GuildControllerLib.getGuildData(guildId);\n  }\n\n  function getGuildByName(string memory name) external view returns (uint guildId) {\n    return GuildControllerLib.getGuildByName(name);\n  }\n\n  function memberOf(address user) external view returns (uint guildId) {\n    return GuildControllerLib.memberOf(user);\n  }\n\n  function guildMembers(uint guildId) external view returns (address[] memory) {\n    return GuildControllerLib.guildMembers(guildId);\n  }\n\n  function getRights(address user) external view returns (uint) {\n    return GuildControllerLib.getRights(user);\n  }\n\n  function isPeacefulRelation(uint guildId, uint guildId2) external view returns (bool) {\n    return GuildControllerLib.isPeacefulRelation(guildId, guildId2);\n  }\n\n  function getBiomeOwner(uint8 biome) external view returns (uint guildId) {\n    return GuildControllerLib.getBiomeOwner(biome);\n  }\n\n  function getBaseFee() external pure returns (uint) {\n    return GuildControllerLib.BASE_FEE;\n  }\n\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ ACTIONS\n\n  /// @notice Generate id for new guild, increment id-counter\n  function _generateGuildId() external returns (uint uid) {\n    return GuildControllerLib._generateGuildId();\n  }\n\n  /// @notice Create new guild, return ID of the new guild\n  function createGuild(bool isEoa, address msgSender, string memory name, string memory urlLogo) external returns (uint) {\n    return GuildControllerLib.createGuild(isEoa, _controller, msgSender, name, urlLogo);\n  }\n\n  /// @notice Add new member to the guild to which msgSender belongs\n  function addGuildMember(address msgSender, address newUser, uint maskRights) external {\n    GuildControllerLib.addGuildMember(msgSender, newUser, maskRights);\n  }\n\n  /// @notice Edit roles of the given member of the guild to which msgSender belongs\n  function changeRoles(address msgSender, address user, uint maskRights) external {\n    GuildControllerLib.changeRoles(msgSender, user, maskRights);\n  }\n\n  /// @notice Remove given member from the guild to which msgSender belongs\n  /// @dev To delete the guild the owner should remove all members and remove himself at the end\n  function removeGuildMember(address msgSender, address userToRemove) external {\n    GuildControllerLib.removeGuildMember(msgSender, userToRemove);\n  }\n\n  /// @notice Increment level of the guild, pay BASE_FEE * new level\n  function guildLevelUp(address msgSender) external {\n    GuildControllerLib.guildLevelUp(_controller, msgSender);\n  }\n\n  /// @notice Rename the guild, pay BASE_FEE * new level\n  function rename(address msgSender, string memory newGuildName) external {\n    GuildControllerLib.rename(_controller, msgSender, newGuildName);\n  }\n\n  function setRelation(address msgSender, uint otherGuildId, bool peace) external {\n    GuildControllerLib.setRelation(msgSender, otherGuildId, peace);\n  }\n\n  //endregion ------------------------ ACTIONS\n\n  //region ------------------------ Internal logic\n  function _checkPermissions(address user, IGuildController.GuildRightBits right) external view returns (uint guildId, uint rights) {\n    return GuildControllerLib._checkPermissions(user, right);\n  }\n\n  function _getMaxMembersNumber(uint8 guildLevel) external pure returns (uint) {\n    return GuildControllerLib._getMaxMembersNumber(guildLevel);\n  }\n\n  /// @notice Generate unique pair key for (G1, G2). Guarantee that F(G1, G2) == F(G2, G1)\n  function _getGuildsPairKey(uint guildId1, uint guildId2) external pure returns (bytes32) {\n    return GuildControllerLib._getGuildsPairKey(guildId1, guildId2);\n  }\n  //endregion ------------------------ Internal logic\n}\n"
    },
    "contracts/test/facades/FacadeHeroControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\nimport \"../../lib/PackingLib.sol\";\nimport \"../../lib/HeroLib.sol\";\nimport \"../../lib/HeroControllerLib.sol\";\nimport \"../../core/HeroController.sol\";\n\n/// @notice Provide access to HeroControllerLib and HeroLib\ncontract FacadeHeroControllerLib is HeroController {\n  //region ------------------------ For tests\n  function _S() internal pure returns (IHeroController.MainState storage) {\n    return HeroLib._S();\n  }\n\n  function setNameToHero(string memory heroName_, address heroToken, uint heroId) external {\n    _S().nameToHero[heroName_] = PackingLib.packNftId(heroToken, heroId);\n  }\n\n  function setReinforcementHero(address hero, uint heroId, address helpHero, uint helpHeroId) external {\n    _S().reinforcementHero[PackingLib.packNftId(hero, heroId)] = PackingLib.packNftId(helpHero, helpHeroId);\n  }\n\n  function getReinforcementHero(address hero, uint heroId) external view returns(\n    address helpHero,\n    uint helpHeroId\n  ) {\n    return PackingLib.unpackNftId(_S().reinforcementHero[PackingLib.packNftId(hero, heroId)]);\n  }\n\n  function setHeroBiome(address hero, uint heroId, uint8 biome) external {\n    _S().heroBiome[PackingLib.packNftId(hero, heroId)] = biome;\n  }\n\n  function getReinforcementHeroAttributes(address hero, uint heroId) external view returns(int32[] memory) {\n    return PackingLib.toInt32Array(\n      _S().reinforcementHeroAttributes[PackingLib.packNftId(hero, heroId)],\n      uint(IStatController.ATTRIBUTES.END_SLOT)\n    );\n  }\n\n  function setReinforcementHeroAttributes(address hero, uint heroId, int32[] memory helpAttributes) external {\n    _S().reinforcementHeroAttributes[PackingLib.packNftId(hero, heroId)] = PackingLib.toBytes32Array(helpAttributes);\n  }\n  //endregion ------------------------ For tests\n\n  //region ------------------------ User actions: create, setBiome, levelUp\n\n  function __create(address msgSender, address hero, string calldata heroName_, bool enter) external returns (uint) {\n    return HeroControllerLib.create(IController(controller()), msgSender, hero, heroName_, enter);\n  }\n\n  function __createWithRefCode(bool isEoa, address msgSender, address hero, string calldata heroName_, string memory refCode, bool enter) external returns (uint) {\n    return HeroControllerLib.createWithRefCode(isEoa, IController(controller()), msgSender, hero, heroName_, refCode, enter);\n  }\n\n  function __setBiome(bool isEoa, address msgSender, address hero, uint heroId, uint8 biome) external {\n    return HeroControllerLib.setBiome(isEoa, IController(controller()), msgSender, hero, heroId, biome);\n  }\n\n  function __levelUp(bool isEoa, address msgSender, address hero, uint heroId, IStatController.CoreAttributes memory change) external {\n    return HeroControllerLib.levelUp(isEoa, IController(controller()), msgSender, hero, heroId, change);\n  }\n  //endregion ------------------------ User actions: create, setBiome, levelUp\n\n  //region ------------------------ User actions: reinforcement\n  function __askReinforcement(bool isEoa, address msgSender, address hero, uint heroId) external {\n    return HeroControllerLib.askReinforcement(isEoa, IController(controller()), msgSender, hero, heroId);\n  }\n\n  function __releaseReinforcement(address msgSender, address hero, uint heroId) external returns (address helperToken, uint helperId) {\n    return HeroControllerLib.releaseReinforcement(IController(controller()), msgSender, hero, heroId);\n  }\n  //endregion ------------------------ User actions: reinforcement\n\n  //region ------------------------ Kill\n  /// @return dropItems List of items (packed: item NFT address + item id)\n  function __kill(address msgSender, address hero, uint heroId) external returns (bytes32[] memory dropItems) {\n    return HeroControllerLib.kill(IController(controller()), msgSender, hero, heroId);\n  }\n  //endregion ------------------------ Kill\n\n  //region ------------------------ HeroLib\n  function _takeOffAll(address hero, uint heroId, address recipient, bool broken)\n  external returns (bytes32[] memory items) {\n    return HeroLib._takeOffAll(\n      IItemController(IController(controller()).itemController()),\n      IStatController(IController(controller()).statController()),\n      hero,\n      heroId,\n      recipient,\n      broken\n    );\n  }\n\n  function isASCIILettersOnly(string memory str) external pure returns (bool) {\n    return StringLib.isASCIILettersOnly(str);\n  }\n  //endregion ------------------------ HeroLib\n\n}"
    },
    "contracts/test/facades/FacadeItemController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/ItemStatsLib.sol\";\nimport \"../../core/ItemController.sol\";\n\n/// @notice Lightweight wrapper around ItemController to be able to test some function in core ItemController contract\ncontract FacadeItemController is ItemController {\n  /// @param packedItemId packNftId(item, itemId)\n  /// @param arrayWithIds Result of toBytes32ArrayWithIds\n  function setItemAttributes(bytes32 packedItemId, bytes32[] memory arrayWithIds) external {\n    ItemStatsLib._S()._itemAttributes[packedItemId] = arrayWithIds;\n  }\n\n  function setItemFragility(bytes32 packedItemId, uint fragility) external {\n    ItemStatsLib._S().itemFragility[packedItemId] = fragility;\n  }\n}"
    },
    "contracts/test/facades/FacadeItemLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IItemController.sol\";\nimport \"../../lib/ItemLib.sol\";\nimport \"../../lib/ItemStatsLib.sol\";\nimport \"hardhat/console.sol\";\n\ncontract FacadeItemLib is IAppErrors {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  IController internal _controller;\n  mapping(uint => uint) private _pseudoRandomValue;\n  mapping(uint => mapping(uint => uint)) private _pseudoRandomValueWithSeed;\n  bool private _useRealPseudoRandom;\n  bool private _useRealPrng;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n\n  //region ------------------------ For tests\n  function _S() internal pure returns (IItemController.MainState storage s) {\n    return ItemStatsLib._S();\n  }\n\n  function setPseudoRandomForTests(uint max, uint value) external {\n    _pseudoRandomValue[max] = value;\n  }\n\n  function _pseudoNextPrng(LibPRNG.PRNG memory prng, uint max) internal view returns (uint) {\n    if (_useRealPrng) {\n      return LibPRNG.next(prng);\n    } else {\n      return _pseudoRandomValue[max];\n    }\n  }\n\n  function _pseudoRandomForTests(uint max) internal view returns (uint) {\n    return _useRealPseudoRandom\n      ? CalcLib.pseudoRandom(max)\n      : _pseudoRandomValue[max];\n  }\n\n  function setUseRealPseudoRandom() external {\n    _useRealPseudoRandom = true;\n    _useRealPrng = true;\n  }\n\n  function setPseudoRandomWithSeedForTests(uint max, uint seed, uint value) external {\n    _pseudoRandomValueWithSeed[max][seed] = value;\n  }\n\n  function _pseudoRandomWithSeedForTests(uint max, uint seed) internal view returns (uint) {\n    return _pseudoRandomValueWithSeed[max][seed];\n  }\n\n  function setItemMeta(address item, IItemController.ItemMeta memory meta) external {\n    _S().itemMeta[item] = ItemLib.packItemMeta(meta);\n  }\n\n  function setGenerateInfoAttributes(address item, IItemController.ItemGenerateInfo memory info) external {\n    _S().generateInfoAttributes[item] = ItemLib.packItemGenerateInfo(info);\n  }\n\n  function getItemAttributes(address item, uint itemId) external view returns (\n    int32[] memory values,\n    uint8[] memory ids\n  ) {\n    return PackingLib.toInt32ArrayWithIds(_S()._itemAttributes[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function getItemInfo(address item, uint itemId) external view returns (\n    uint8 itemRarity,\n    uint8 augmentationLevel,\n    uint16 durability\n  ) {\n    return PackingLib.unpackItemInfo(_S().itemInfo[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function setGenerateInfoAttack(address item, IItemController.AttackInfo memory attackInfo) external {\n    _S().generateInfoAttack[item] = ItemLib.packItemAttackInfo(attackInfo);\n  }\n\n  function setGenerateAttributes(address item, IItemController.ItemGenerateInfo memory data, bool caster) external {\n    (caster ? _S().generateInfoCasterAttributes : _S().generateInfoTargetAttributes)[item] = ItemLib.packItemGenerateInfo(data);\n  }\n\n  function itemAttackInfo(address item, uint itemId) external view returns (IItemController.AttackInfo memory info) {\n    return ItemLib.unpackItemAttackInfo(_S()._itemAttackInfo[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function getItemAttributesCasterTarget(address item, uint itemId, bool caster) external view returns (\n    uint8[] memory ids,\n    int32[] memory values\n  ) {\n    (values, ids) = PackingLib.toInt32ArrayWithIds((caster ? _S()._itemCasterAttributes : _S()._itemTargetAttributes)[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function addItemToItems(address item) external {\n    _S().items.add(item);\n  }\n\n  function isItemInItems(address item) external view returns (bool) {\n    return _S().items.contains(item);\n  }\n  //endregion ------------------------ For tests\n\n  //region ------------------------ Main logic\n  function mintNewItem(address sender, address item, address recipient) external returns (uint itemId) {\n    return ItemLib.mintNewItem(_S(), _controller, sender, item, recipient);\n  }\n\n  function mintRandomItems(ItemLib.MintItemInfo memory info) external returns (address[] memory) {\n    return ItemLib.mintRandomItems(info);\n  }\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ Internal logic\n  function _mintRandomItems(\n    ItemLib.MintItemInfo memory info\n  ) external returns (address[] memory) {\n    return ItemLib._mintRandomItems(info, _pseudoNextPrng);\n  }\n\n  function _generateAttributes(\n    IItemController.ItemGenerateInfo memory info,\n    IItemController.ItemMeta memory meta\n  ) external view returns (\n    uint8[] memory ids,\n    int32[] memory values,\n    IItemController.ItemRarity itemRarity\n  ) {\n    return ItemLib._generateAttributes(info, meta, _pseudoRandomForTests);\n  }\n\n  function generateSimpleAttributes(IItemController.ItemGenerateInfo memory info, bool maxChance) external view returns (\n    uint8[] memory ids,\n    int32[] memory values\n  ) {\n    return ItemLib._generateSimpleAttributes(info, maxChance, _pseudoRandomForTests);\n  }\n\n  function _generateMissingRandomAttributes(\n    IItemController.ItemGenerateInfo memory info,\n    uint8 minRandomAttributes,\n    ItemLib.GenerateAttributesContext memory ctx\n  ) external view returns (\n    ItemLib.GenerateAttributesContext memory\n  ) {\n    ItemLib._generateMissingRandomAttributes(info, minRandomAttributes, ctx, _pseudoRandomForTests);\n    return ctx;\n  }\n\n  function _prepareAttributes(\n    IItemController.ItemGenerateInfo memory info,\n    uint8 maxRandomAttributes,\n    ItemLib.GenerateAttributesContext memory ctx\n  ) external view returns (ItemLib.GenerateAttributesContext memory) {\n    ctx.ids = new uint8[](info.ids.length);\n    ctx.values = new int32[](info.ids.length);\n    ctx.usedIndexes = new bool[](info.ids.length);\n    ItemLib._prepareAttributes(info, maxRandomAttributes, ctx, _pseudoRandomForTests);\n    return ctx;\n  }\n\n  function _setupNewAttributes(address item, uint itemId) external returns (\n    IItemController.ItemMeta memory meta,\n    uint8[] memory ids,\n    int32[] memory values,\n    IItemController.ItemRarity itemRarity\n  ){\n    return ItemLib._setupNewAttributes(_S(), item, itemId, _pseudoRandomForTests);\n  }\n\n  function _setupNewAttackItem(address item, uint itemId) external returns (bytes32 attackInfo) {\n    return ItemLib._setupNewAttackItem(_S(), item, itemId);\n  }\n\n  function _setupNewBuffItem(address item, uint itemId) external returns (\n    uint8[] memory casterIds,\n    int32[] memory casterValues,\n    uint8[] memory targetIds,\n    int32[] memory targetValues\n  ){\n    return ItemLib._setupNewBuffItem(_S(), item, itemId, _pseudoRandomForTests);\n  }\n\n  //endregion ------------------------ Internal logic\n\n  //region ------------------------ Internal utils\n  function _generateAttribute(int32 min, int32 max, uint32 chance) external view returns (int32 attr, uint rnd) {\n    return ItemLib._generateAttribute(min, max, chance, _pseudoRandomForTests);\n  }\n\n  function _calculateRarity(uint randomSum, uint chancesSum, uint attrCounter, uint maxAttr) external pure returns (\n    IItemController.ItemRarity\n  ) {\n    return ItemLib._calculateRarity(randomSum, chancesSum, attrCounter, maxAttr);\n  }\n\n  function _shuffleInfo(IItemController.ItemGenerateInfo memory info) external view returns (\n    IItemController.ItemGenerateInfo memory infoOut\n  ) {\n    ItemLib._shuffleInfo(info, _pseudoRandomForTests);\n    return info;\n  }\n\n  function _shuffleIndices(uint countItems) external view returns (uint[] memory indices) {\n    return ItemLib._shuffleIndices(countItems, _pseudoRandomForTests);\n  }\n  //endregion ------------------------ Internal utils\n\n  //region ------------------------ PACKING\n\n  function packItemGenerateInfo(IItemController.ItemGenerateInfo memory info) external pure returns (bytes32[] memory result) {\n    return ItemLib.packItemGenerateInfo(info);\n  }\n\n  function unpackItemGenerateInfo(\n    bytes32[] memory gen\n  ) external pure returns (IItemController.ItemGenerateInfo memory) {\n    return ItemLib.unpackItemGenerateInfo(gen);\n  }\n\n  function packItemMeta(IItemController.ItemMeta memory meta) external pure returns (bytes32) {\n    return ItemLib.packItemMeta(meta);\n  }\n\n  function unpackedItemMeta(bytes32 meta) external pure returns (IItemController.ItemMeta memory result) {\n    return ItemLib.unpackedItemMeta(meta);\n  }\n\n  function packItemInfo(IItemController.ItemInfo memory info) external pure returns (bytes32) {\n    return ItemLib.packItemInfo(info);\n  }\n\n  function unpackedItemInfo(bytes32 info) external pure returns (IItemController.ItemInfo memory result) {\n    return ItemLib.unpackedItemInfo(info);\n  }\n\n  function packItemAttackInfo(IItemController.AttackInfo memory info) external pure returns (bytes32) {\n    return ItemLib.packItemAttackInfo(info);\n  }\n\n  function unpackItemAttackInfo(bytes32 info) external pure returns (IItemController.AttackInfo memory result) {\n    return ItemLib.unpackItemAttackInfo(info);\n  }\n  //endregion ------------------------ PACKING\n}"
    },
    "contracts/test/facades/FacadeItemStatsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\nimport \"../../lib/PackingLib.sol\";\nimport \"../../lib/ItemStatsLib.sol\";\n\ncontract FacadeItemStatsLib is IAppErrors {\n  IController internal _controller;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n  //region ------------------------ For tests\n  function _S() internal pure returns (IItemController.MainState storage s) {\n    return ItemStatsLib._S();\n  }\n\n  function setGenerateAttributes(address item, bytes32[] memory data, bool caster) external {\n    (caster ? _S().generateInfoCasterAttributes : _S().generateInfoTargetAttributes)[item] = data;\n  }\n\n  function setItemMeta(address item, IItemController.ItemMeta memory meta) external {\n    _S().itemMeta[item] = ItemLib.packItemMeta(meta);\n  }\n\n  function setItemInfo(address item, uint itemId, IItemController.ItemInfo memory info) external {\n    _S().itemInfo[PackingLib.packNftId(item, itemId)] = ItemLib.packItemInfo(info);\n  }\n\n  function setEquipped(address item, uint itemId, bytes32 value) external {\n    _S().equippedOn[PackingLib.packNftId(item, itemId)] = value;\n  }\n\n  function setItemAttributes(address item, uint itemId, int32[] memory values, uint8[] memory ids) external {\n    _S()._itemAttributes[PackingLib.packNftId(item, itemId)] = PackingLib.toBytes32ArrayWithIds(values, ids);\n  }\n\n  function setAugmentInfo(address item, address token, uint amount) external {\n    _S().augmentInfo[item] = PackingLib.packAddressWithAmount(token, amount);\n  }\n\n  function getItemAttributesCasterTarget(address item, uint itemId, bool caster) external view returns (\n    uint8[] memory ids,\n    int32[] memory values\n  ) {\n    (values, ids) = PackingLib.toInt32ArrayWithIds((caster ? _S()._itemCasterAttributes : _S()._itemTargetAttributes)[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function setItemAttributesCasterTarget(address item, uint itemId, int32[] memory values, uint8[] memory ids, bool caster) external {\n    (\n      caster ? _S()._itemCasterAttributes : _S()._itemTargetAttributes)[PackingLib.packNftId(item, itemId)\n    ] = PackingLib.toBytes32ArrayWithIds(values, ids);\n  }\n\n\n  function getItemAttributes(address item, uint itemId) external view returns (\n    uint8[] memory ids,\n    int32[] memory values\n  ) {\n    (values, ids) = ItemStatsLib.itemAttributes(item, itemId);\n  }\n\n  function setItemAttackInfo(address item, uint itemId, IItemController.AttackInfo memory info) external {\n    _S()._itemAttackInfo[PackingLib.packNftId(item, itemId)] = ItemLib.packItemAttackInfo(info);\n  }\n\n  function setItemConsumableStats(address item, IStatController.ChangeableStats memory data) external {\n    _S().itemConsumableStats[item] = StatLib.packChangeableStats(data);\n  }\n  function setItemConsumableAttributes(address item, uint8[] memory ids, int32[] memory values) external {\n    _S()._itemConsumableAttributes[item] = PackingLib.toBytes32ArrayWithIds(values, ids);\n  }\n  function setConsumableActionMask(address item, uint mask) external {\n    _S()._consumableActionMask[item] = mask;\n  }\n\n  //endregion ------------------------ For tests\n\n  //region ------------------------ REGISTER\n\n  // Following functions were moved to FacadItemLib to fix too-big-size of FacadeItemStatsLib\n\n//  function registerItem(address msgSender, address item, IItemController.RegisterItemParams memory info) external {\n//    return ItemStatsLib.registerItem(_controller, msgSender, item, info);\n//  }\n\n//  function removeItem(address msgSender, address item) external {\n//    return ItemStatsLib.removeItem(_controller, msgSender, item);\n//  }\n  //endregion ------------------------ REGISTER\n\n  //region ------------------------ EQUIP\n\n  function isItemEquipped(address item, uint itemId) external view returns (bool) {\n    return ItemStatsLib.isItemEquipped(_S(), item, itemId);\n  }\n\n  function equipMany(\n    bool isEoa,\n    address msgSender,\n    address heroToken,\n    uint heroTokenId,\n    address[] calldata items,\n    uint[] calldata tokenIds,\n    uint8[] calldata itemSlots\n  ) external {\n    return ItemStatsLib.equipMany(isEoa, _controller, msgSender, heroToken, heroTokenId, items, tokenIds, itemSlots);\n  }\n\n  function _checkRequirements(address heroToken, uint heroTokenId, IStatController.CoreAttributes memory requirements) external view {\n    return ItemStatsLib._checkRequirements(IStatController(_controller.statController()), heroToken, heroTokenId, requirements);\n  }\n  //endregion ------------------------ EQUIP\n\n  //region ------------------------ TAKE OFF\n\n  function takeOffMany(\n    bool isEoa,\n    address msgSender,\n    address heroToken,\n    uint heroTokenId,\n    address[] calldata items,\n    uint[] calldata tokenIds,\n    uint8[] calldata itemSlots\n  ) external {\n    ItemStatsLib.takeOffMany(isEoa, _controller, msgSender, heroToken, heroTokenId, items, tokenIds, itemSlots);\n  }\n\n  function takeOffDirectly(\n    address item,\n    uint itemId,\n    address hero,\n    uint heroId,\n    uint8 itemSlot,\n    address destination,\n    bool broken\n  ) external {\n    ItemStatsLib.takeOffDirectly(_controller, item, itemId, hero, heroId, itemSlot, destination, broken);\n  }\n\n  function _takeOff(\n    address item,\n    uint itemId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 itemSlot,\n    address destination,\n    bool broken\n  ) external {\n    ItemStatsLib._takeOff(_S(), IStatController(_controller.statController()), item, itemId, heroToken, heroTokenId, itemSlot, destination, broken);\n  }\n  //endregion ------------------------ TAKE OFF\n\n  //region ------------------------ REPAIR and AUGMENT\n\n  // repairDurability is moved to FacadeItemStatsLibRegister\n\n//  function repairDurability(bool isEoa, address msgSender, address item, uint itemId, uint consumedItemId) external {\n//    return ItemStatsLib.repairDurability(isEoa, _controller, msgSender, item, itemId, consumedItemId, _pseudoRandomForTests);\n//  }\n\n  function augment(bool isEoa, address msgSender, address item, uint itemId, uint consumedItemId) external {\n    return ItemStatsLib.augment(isEoa, _controller, msgSender, item, itemId, consumedItemId);\n  }\n\n  function augmentAttributes(bytes32[] memory packedAttr, bool ignoreNegative) external pure returns (int32[] memory values, uint8[] memory ids){\n    return ItemStatsLib._augmentAttributes(packedAttr, ignoreNegative);\n  }\n\n  function augmentAttribute(int32 value) external pure returns (int32) {\n    return ItemStatsLib._augmentAttribute(value);\n  }\n  //endregion ------------------------ REPAIR and AUGMENT\n\n  //region ------------------------ REDUCE DURABILITY\n\n  function reduceEquippedItemsDurability(address msgSender, address hero, uint heroId, uint8 biome) external {\n    return ItemStatsLib.reduceEquippedItemsDurability(_controller, msgSender, hero, heroId, biome);\n  }\n\n  function _reduceDurabilityForItem(address item, uint itemId, uint biome) external returns (uint16 newDurability) {\n    return ItemStatsLib._reduceDurabilityForItem(_S(), item, itemId, biome);\n  }\n\n  function calcReduceDurability(uint biome, uint currentDurability, uint8 itemLevel_, IItemController.ItemType itemType_)\n  external pure returns (uint) {\n    return ItemStatsLib._calcReduceDurability(biome, currentDurability, itemLevel_, itemType_);\n  }\n  //endregion ------------------------ REDUCE DURABILITY\n\n  //region ------------------------ DESTROY\n\n  function destroy(address msgSender, address item, uint itemId) external {\n    ItemStatsLib.destroy(_controller, msgSender, item, itemId);\n  }\n\n  function _destroy(address item, uint itemId) external {\n    ItemStatsLib._destroy(item, itemId);\n  }\n  //endregion ------------------------ DESTROY\n\n  //region ------------------------ FEE\n\n  function _sendFee(address item, address msgSender, IItemController.FeeType feeType) external {\n    ItemStatsLib._sendFee(_S(), _controller, item, msgSender, feeType);\n  }\n  //endregion ------------------------ FEE\n\n  //region ------------------------ USE\n\n  function use(bool isEoa, address msgSender, address item, uint itemId, address heroToken, uint heroTokenId) external {\n    ItemStatsLib.use(isEoa, _controller, msgSender, item, itemId, heroToken, heroTokenId);\n  }\n  //endregion ------------------------ USE\n\n  //region ------------------------ VIEWS\n  function itemByIndex(uint idx) external view returns (address) {\n    return ItemStatsLib.itemByIndex(idx);\n  }\n\n  function itemsLength() external view returns (uint) {\n    return ItemStatsLib.itemsLength();\n  }\n\n  function itemMeta(address item) external view returns (IItemController.ItemMeta memory meta) {\n    return ItemStatsLib.itemMeta(item);\n  }\n\n  function augmentInfo(address item) external view returns (address token, uint amount) {\n    return ItemStatsLib.augmentInfo(item);\n  }\n\n  function genAttributeInfo(address item) external view returns (IItemController.ItemGenerateInfo memory info) {\n    return ItemStatsLib.genAttributeInfo(item);\n  }\n\n  function genCasterAttributeInfo(address item) external view returns (IItemController.ItemGenerateInfo memory info) {\n    return ItemStatsLib.genCasterAttributeInfo(item);\n  }\n\n  function genTargetAttributeInfo(address item) external view returns (IItemController.ItemGenerateInfo memory info) {\n    return ItemStatsLib.genTargetAttributeInfo(item);\n  }\n\n  function genAttackInfo(address item) external view returns (IItemController.AttackInfo memory info) {\n    return ItemStatsLib.genAttackInfo(item);\n  }\n\n  function itemInfo(address item, uint itemId) external view returns (IItemController.ItemInfo memory info) {\n    return ItemStatsLib.itemInfo(item, itemId);\n  }\n\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId) {\n    return ItemStatsLib.equippedOn(item, itemId);\n  }\n\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids) {\n    return ItemStatsLib.itemAttributes(item, itemId);\n  }\n\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids) {\n    return ItemStatsLib.consumableAttributes(item);\n  }\n\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats) {\n    return ItemStatsLib.consumableStats(item);\n  }\n\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids) {\n    return ItemStatsLib.casterAttributes(item, itemId);\n  }\n\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids) {\n    return ItemStatsLib.targetAttributes(item, itemId);\n  }\n\n  function itemAttackInfo(address item, uint itemId) external view returns (IItemController.AttackInfo memory info) {\n    return ItemStatsLib.itemAttackInfo(item, itemId);\n  }\n\n  function score(address item, uint itemId) external view returns (uint) {\n    return ItemStatsLib.score(item, itemId);\n  }\n\n  function isAllowedToTransfer(address item, uint itemId) external view returns (bool) {\n    return ItemStatsLib.isAllowedToTransfer(item, itemId);\n  }\n\n  function consumableActionMask(address item) external view returns (uint) {\n    return ItemStatsLib.consumableActionMask(item);\n  }\n  //endregion ------------------------ VIEWS\n}"
    },
    "contracts/test/facades/FacadeItemStatsLibRegister.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IItemController.sol\";\nimport \"../../lib/ItemLib.sol\";\nimport \"../../lib/ItemStatsLib.sol\";\nimport \"hardhat/console.sol\";\n\ncontract FacadeItemStatsLibRegister is IAppErrors {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  IController internal _controller;\n  mapping(uint => uint) private _pseudoRandomValue;\n  mapping(uint => mapping(uint => uint)) private _pseudoRandomValueWithSeed;\n  bool private _useRealPseudoRandom;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n\n  //region ------------------------ For tests\n  function _S() internal pure returns (IItemController.MainState storage s) {\n    return ItemStatsLib._S();\n  }\n\n  function setPseudoRandomForTests(uint max, uint value) external {\n    _pseudoRandomValue[max] = value;\n  }\n\n  function _pseudoRandomForTests(uint max) internal view returns (uint) {\n    return _useRealPseudoRandom\n      ? CalcLib.pseudoRandom(max)\n      : _pseudoRandomValue[max];\n  }\n\n  function setUseRealPseudoRandom() external {\n    _useRealPseudoRandom = true;\n  }\n\n  function setPseudoRandomWithSeedForTests(uint max, uint seed, uint value) external {\n    _pseudoRandomValueWithSeed[max][seed] = value;\n  }\n\n  function _pseudoRandomWithSeedForTests(uint max, uint seed) internal view returns (uint) {\n    return _pseudoRandomValueWithSeed[max][seed];\n  }\n\n  function setItemMeta(address item, IItemController.ItemMeta memory meta) external {\n    _S().itemMeta[item] = ItemLib.packItemMeta(meta);\n  }\n\n  function getItemMeta(address item) external view returns (IItemController.ItemMeta memory meta) {\n    return ItemLib.unpackedItemMeta(_S().itemMeta[item]);\n  }\n\n  function getAugmentInfo(address item) external view returns (address token, uint amount) {\n    return ItemStatsLib.augmentInfo(item);\n  }\n\n  function setGenerateInfoAttributes(address item, IItemController.ItemGenerateInfo memory info) external {\n    _S().generateInfoAttributes[item] = ItemLib.packItemGenerateInfo(info);\n  }\n\n  function getGenerateInfoAttributes(address item) external view returns (IItemController.ItemGenerateInfo memory info) {\n    return ItemStatsLib.genAttributeInfo(item);\n  }\n\n  function getItemAttributes(address item, uint itemId) external view returns (\n    int32[] memory values,\n    uint8[] memory ids\n  ) {\n    return ItemStatsLib.itemAttributes(item, itemId);\n  }\n\n  function getItemInfo(address item, uint itemId) external view returns (\n    uint8 itemRarity,\n    uint8 augmentationLevel,\n    uint16 durability\n  ) {\n    return PackingLib.unpackItemInfo(_S().itemInfo[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function setGenerateInfoAttack(address item, IItemController.AttackInfo memory attackInfo) external {\n    _S().generateInfoAttack[item] = ItemLib.packItemAttackInfo(attackInfo);\n  }\n\n  function setGenerateAttributes(address item, IItemController.ItemGenerateInfo memory data, bool caster) external {\n    (caster ? _S().generateInfoCasterAttributes : _S().generateInfoTargetAttributes)[item] = ItemLib.packItemGenerateInfo(data);\n  }\n\n  function getGenerateAttributes(address item, bool caster) external view returns (IItemController.ItemGenerateInfo memory info) {\n    return caster\n      ? ItemStatsLib.genCasterAttributeInfo(item)\n      : ItemStatsLib.genTargetAttributeInfo(item);\n  }\n\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats) {\n    return StatLib.unpackChangeableStats(_S().itemConsumableStats[item]);\n  }\n\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids) {\n    return ItemStatsLib.consumableAttributes(item);\n  }\n\n  function itemAttackInfo(address item, uint itemId) external view returns (IItemController.AttackInfo memory info) {\n    return ItemLib.unpackItemAttackInfo(_S()._itemAttackInfo[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function genAttackInfo(address item) external view returns (IItemController.AttackInfo memory info) {\n    return ItemStatsLib.genAttackInfo(item);\n  }\n\n  function getItemAttributesCasterTarget(address item, uint itemId, bool caster) external view returns (\n    uint8[] memory ids,\n    int32[] memory values\n  ) {\n    (values, ids) = PackingLib.toInt32ArrayWithIds((caster ? _S()._itemCasterAttributes : _S()._itemTargetAttributes)[PackingLib.packNftId(item, itemId)]);\n  }\n\n  function addItemToItems(address item) external {\n    _S().items.add(item);\n  }\n\n  function isItemInItems(address item) external view returns (bool) {\n    return _S().items.contains(item);\n  }\n\n  function consumableActionMask(address item) external view returns (uint) {\n    return ItemStatsLib.consumableActionMask(item);\n  }\n\n  function setAugmentInfo(address item, address token, uint amount) external {\n    _S().augmentInfo[item] = PackingLib.packAddressWithAmount(token, amount);\n  }\n\n  function setItemInfo(address item, uint itemId, IItemController.ItemInfo memory info) external {\n    _S().itemInfo[PackingLib.packNftId(item, itemId)] = ItemLib.packItemInfo(info);\n  }\n\n  function setEquipped(address item, uint itemId, bytes32 value) external {\n    _S().equippedOn[PackingLib.packNftId(item, itemId)] = value;\n  }\n\n  function itemInfo(address item, uint itemId) external view returns (IItemController.ItemInfo memory info) {\n    return ItemStatsLib.itemInfo(item, itemId);\n  }\n\n  function setItemFragility(address item, uint itemId, uint value) external {\n    _S().itemFragility[PackingLib.packNftId(item, itemId)] = value;\n  }\n  //endregion ------------------------ For tests\n\n  //region ------------------------ ItemStatsLib.REGISTER\n  function registerItem(address msgSender, address item, IItemController.RegisterItemParams calldata info) external {\n    return ItemStatsLib.registerItem(_controller, msgSender, item, info);\n  }\n\n  function removeItem(address msgSender, address item) external {\n    return ItemStatsLib.removeItem(_controller, msgSender, item);\n  }\n  //endregion ------------------------ ItemStatsLib.REGISTER\n\n  //region ------------------------ REPAIR and AUGMENT\n\n  function repairDurability(bool isEoa, address msgSender, address item, uint itemId, uint consumedItemId) external {\n    return ItemStatsLib._repairDurability(isEoa, _controller, msgSender, item, itemId, consumedItemId, _pseudoRandomForTests);\n  }\n  //endregion ------------------------ REPAIR and AUGMENT\n\n  //region ------------------------ SIP-003: Item fragility\n  function itemFragility(address item, uint itemId) external view returns (uint) {\n    return ItemStatsLib.itemFragility(item, itemId);\n  }\n\n  function addItemFragility(address item, uint itemId, uint portion) external {\n    ItemStatsLib._addItemFragility(item, itemId, portion);\n  }\n\n  function incBrokenItemFragility(address item, uint itemId) external {\n    ItemStatsLib.incBrokenItemFragility(IController(_controller), item, itemId);\n  }\n  //endregion ------------------------ SIP-003: Item fragility\n}"
    },
    "contracts/test/facades/FacadeMonsterLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IStatController.sol\";\nimport \"../../interfaces/IItemController.sol\";\nimport \"../../interfaces/IFightCalculator.sol\";\nimport \"../../interfaces/IApplicationEvents.sol\";\nimport \"../../interfaces/IGOC.sol\";\nimport \"../../lib/FightLib.sol\";\nimport \"../../lib/PackingLib.sol\";\nimport \"../../lib/MonsterLib.sol\";\nimport \"hardhat/console.sol\";\n\ncontract FacadeMonsterLib is IApplicationEvents {\n  IController private _controller;\n  IGOC.MonsterInfo internal _mInfo;\n  mapping(uint => uint) private _pseudoRandomValue;\n  mapping(uint => mapping(uint => uint)) private _pseudoRandomValueWithSeed;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n  //region ------------------------ For tests\n  function setPseudoRandomForTests(uint max, uint value) external {\n    _pseudoRandomValue[max] = value;\n  }\n\n  function _pseudoRandomForTests(uint max) internal view returns (uint) {\n    return _pseudoRandomValue[max];\n  }\n\n  function _pseudoNextPrng(LibPRNG.PRNG memory, uint max) internal view returns (uint) {\n    return _pseudoRandomValue[max];\n  }\n\n  function setPseudoRandomWithSeedForTests(uint max, uint seed, uint value) external {\n    _pseudoRandomValueWithSeed[max][seed] = value;\n  }\n\n  function _pseudoRandomWithSeedForTests(uint max, uint seed) internal view returns (uint) {\n    return _pseudoRandomValueWithSeed[max][seed];\n  }\n\n  function setGeneratedMonsters(address heroToken, uint heroTokenId, uint iteration, IGOC.GeneratedMonster memory gen) external {\n    bytes32 data = PackingLib.packGeneratedMonster(gen.generated, gen.amplifier, gen.hp, gen.turnCounter);\n    _mInfo._generatedMonsters[PackingLib.packNftId(heroToken, heroTokenId)][iteration] = data;\n  }\n\n  function getGeneratedMonsters(address heroToken, uint heroTokenId, uint iteration) external view returns (IGOC.GeneratedMonster memory gen) {\n    bytes32 data = _mInfo._generatedMonsters[PackingLib.packNftId(heroToken, heroTokenId)][iteration];\n    (gen.generated, gen.amplifier, gen.hp, gen.turnCounter) = PackingLib.unpackGeneratedMonster(data);\n    return gen;\n  }\n\n  //endregion ------------------------ For tests\n\n  //region ------------------------ Main logic\n  function initialGeneration(address heroToken, uint heroTokenId, uint iteration, uint totalSupply) external {\n    return MonsterLib.initialGeneration(_mInfo, heroToken, heroTokenId, iteration, totalSupply);\n  }\n\n  function action(IGOC.ActionContext memory ctx) external returns (IGOC.ActionResult memory result, uint8 turn) {\n    return MonsterLib.action(ctx, _mInfo);\n  }\n\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ Internal calculations\n\n  function _postFight(\n    IGOC.ActionContext memory ctx,\n    MonsterLib.AdrContext memory adrCtx,\n    MonsterLib.FightInternalInfo memory fInfo,\n    IGOC.MonsterGenInfo memory genInfo,\n    IGOC.GeneratedMonster memory gen\n  ) external returns (\n    IGOC.ActionResult memory result,\n    IGOC.GeneratedMonster memory genOut\n  ) {\n    result = MonsterLib._postFight(_mInfo, ctx, adrCtx, fInfo, genInfo, gen);\n    return (result, gen);\n  }\n\n  function _initialGeneration(address heroToken, uint heroTokenId, uint iteration, uint totalSupply) external {\n    return MonsterLib._initialGeneration(_mInfo, heroToken, heroTokenId, iteration, _pseudoRandomForTests, totalSupply);\n  }\n\n  function _bossDefeated(MonsterLib.AdrContext memory adrCtx, IGOC.ActionContext memory ctx) external {\n    return MonsterLib._bossDefeated(adrCtx, ctx);\n  }\n\n  function _collectHeroFighterInfo(\n    IFightCalculator.AttackInfo memory attackInfo,\n    MonsterLib.AdrContext memory adrContext\n  ) external view returns (IFightCalculator.FighterInfo memory fInfo, int32 manaConsumed) {\n    return MonsterLib._collectHeroFighterInfo(attackInfo, adrContext);\n  }\n\n  function _buffAndGetHeroAttributes(\n    uint level,\n    IFightCalculator.AttackInfo memory attackInfo,\n    MonsterLib.AdrContext memory context\n  ) external view returns (int32[] memory heroAttributes, int32 manaConsumed) {\n    return MonsterLib._buffAndGetHeroAttributes(level, attackInfo, context);\n  }\n\n  function _debuff(\n    int32[] memory attributes,\n    IFightCalculator.AttackInfo memory heroAttackInfo,\n    MonsterLib.AdrContext memory context\n  ) external view returns (\n    int32[] memory\n  ) {\n    MonsterLib._debuff(attributes, heroAttackInfo, context);\n    return attributes;\n  }\n\n  function _collectMonsterFighterInfo(\n    uint8 biome,\n    uint totalSupply,\n    IGOC.GeneratedMonster memory gen,\n    IFightCalculator.AttackInfo memory heroAttackInfo,\n    uint heroLevel,\n    MonsterLib.AdrContext memory adrCtx\n  ) external view returns (\n    IFightCalculator.FighterInfo memory fighterInfo,\n    uint32 rarity,\n    IGOC.MonsterGenInfo memory genInfo\n  ) {\n    return MonsterLib._collectMonsterFighterInfo(IGOC.MultiplierInfo(biome, totalSupply), _mInfo, gen, heroAttackInfo, heroLevel, adrCtx, _pseudoRandomForTests);\n  }\n\n  /////////////////////////////////////////////////////////////////\n  ///\n  /// function _fight is moved to FacadeMonsterLibFight because of size limitations\n  ///\n  /////////////////////////////////////////////////////////////////\n\n  function _calcDmg(int32 heroLifeBefore, int32 heroLifeAfter) external pure returns (int32 damage) {\n    return MonsterLib._calcDmg(heroLifeBefore, heroLifeAfter);\n  }\n\n  function _generateMonsterInfo(\n    uint32 amplifier,\n    int32 dungeonMultiplier,\n    uint heroLevel,\n    uint biome\n  ) external view returns (\n    int32[] memory attributes,\n    uint32 level,\n    uint32 experience,\n    IFightCalculator.AttackInfo memory attackInfo,\n    IGOC.MonsterGenInfo memory info\n  ) {\n    return MonsterLib._generateMonsterInfo(_mInfo, amplifier, dungeonMultiplier, heroLevel, biome, _pseudoRandomForTests);\n  }\n\n  function _mintRandomItems(\n    MonsterLib.FightInternalInfo memory fInfo,\n    IGOC.ActionContext memory ctx,\n    IGOC.MonsterGenInfo memory genInfo\n  ) external returns (address[] memory) {\n    return MonsterLib._mintRandomItems(fInfo, ctx, genInfo, _pseudoNextPrng);\n  }\n\n  function generateMonsterAttributes(\n    uint8[] memory ids,\n    int32[] memory values,\n    uint32 amplifier,\n    int32 dungeonMultiplier,\n    uint32 baseExperience\n  ) external pure returns (int32[] memory attributes, uint32 experience) {\n    return MonsterLib.generateMonsterAttributes(ids, values, amplifier, dungeonMultiplier, baseExperience);\n  }\n\n  //endregion ------------------------ Internal calculations\n\n  //region ------------------------ Utils\n\n  function _context(IGOC.ActionContext memory ctx) external view returns (MonsterLib.AdrContext memory context) {\n    return MonsterLib._context(ctx);\n  }\n\n  function packGeneratedMonster(IGOC.GeneratedMonster memory gen) external pure returns (bytes32) {\n    return MonsterLib.packGeneratedMonster(gen);\n  }\n\n  function unpackGeneratedMonster(bytes32 gen) external pure returns (IGOC.GeneratedMonster memory result) {\n    return MonsterLib.unpackGeneratedMonster(gen);\n  }\n\n  function packMonsterInfo(IGOC.MonsterGenInfo calldata mInfo) external {\n    MonsterLib.packMonsterInfo(mInfo, _mInfo);\n  }\n\n  function unpackMonsterInfo() external view returns (IGOC.MonsterGenInfo memory result) {\n    return MonsterLib.unpackMonsterInfo(_mInfo);\n  }\n\n  function decodeAndCheckAttackInfo(bytes memory data, address heroToken, uint heroId) external view returns (IFightCalculator.AttackInfo memory) {\n    return MonsterLib.decodeAndCheckAttackInfo(\n      IItemController(_controller.itemController()),\n      IHeroController(_controller.heroController()),\n      data,\n      heroToken,\n      heroId\n    );\n  }\n\n  function amplifyMonsterAttribute(int32 value, uint32 amplifier, int32 dungeonMultiplier) external pure returns (int32) {\n    return MonsterLib.amplifyMonsterAttribute(value, amplifier, dungeonMultiplier);\n  }\n\n  function _getMonsterCounterIndex(uint32 objectId) external pure returns (bytes32) {\n    return MonsterLib._getMonsterCounterIndex(objectId);\n  }\n\n  function monsterMultiplier(uint totalSupply) external pure returns (int32) {\n    return MonsterLib.monsterMultiplier(totalSupply);\n  }\n  //endregion ------------------------ Utils\n\n}\n"
    },
    "contracts/test/facades/FacadeMonsterLibFight.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IItemController.sol\";\nimport \"../../interfaces/IFightCalculator.sol\";\nimport \"../../interfaces/IApplicationEvents.sol\";\nimport \"../../interfaces/IGOC.sol\";\nimport \"../../lib/FightLib.sol\";\nimport \"../../lib/PackingLib.sol\";\nimport \"../../lib/MonsterLib.sol\";\n\n/// @dev Access to _fight function (it was moved away from FacadeMonsterLib because of size limitations)\ncontract FacadeMonsterLibFight is IApplicationEvents {\n  struct FightForTestDataCalled {\n    IItemController ic;\n    IFightCalculator.FightCall callData;\n    address msgSender;\n    uint randomResult;\n  }\n\n  struct FightForTestDataSettings {\n    uint maxRandom;\n    IFightCalculator.FightResult results;\n  }\n\n  IGOC.MonsterInfo internal _mInfo;\n  mapping(uint => uint) private _pseudoRandomValue;\n  IController private _controller;\n\n  FightForTestDataSettings private _settings;\n  FightForTestDataCalled private _callResults;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n\n  //region ------------------------ For tests\n  function setPseudoRandomForTests(uint max, uint value) external {\n    _pseudoRandomValue[max] = value;\n  }\n\n  function _pseudoRandomForTests(uint max) internal view returns (uint) {\n    return _pseudoRandomValue[max];\n  }\n\n  function setFightForTest(uint maxRandom, IFightCalculator.FightResult memory results) external {\n    _settings = FightForTestDataSettings({maxRandom: maxRandom, results: results});\n  }\n\n  function fightForTests(\n    IItemController ic,\n    IFightCalculator.FightCall memory callData,\n    address msgSender,\n    function (uint) internal view returns (uint) random_\n  ) internal returns (\n    IFightCalculator.FightResult memory\n  ) {\n    _callResults = FightForTestDataCalled({\n      ic: ic,\n      callData: IFightCalculator.FightCall({\n        fighterA: callData.fighterA,\n        fighterB: callData.fighterB,\n        heroId: callData.heroId,\n        dungeonId: callData.dungeonId,\n        objectId: callData.objectId,\n        heroAdr: callData.heroAdr,\n        stageId: callData.stageId,\n        iteration: callData.iteration,\n        turn: callData.turn\n      }),\n      msgSender: msgSender,\n      randomResult: random_(_settings.maxRandom)\n    });\n    return _settings.results;\n  }\n\n  function getFightCallResults() external view returns (\n    IItemController ic,\n    IFightCalculator.FightCall memory callData,\n    uint randomResult\n  ) {\n    return (_callResults.ic, _callResults.callData, _callResults.randomResult);\n  }\n\n  function setGeneratedMonsters(address heroToken, uint heroTokenId, uint iteration, IGOC.GeneratedMonster memory gen) external {\n    bytes32 data = PackingLib.packGeneratedMonster(gen.generated, gen.amplifier, gen.hp, gen.turnCounter);\n    _mInfo._generatedMonsters[PackingLib.packNftId(heroToken, heroTokenId)][iteration] = data;\n  }\n\n  //endregion ------------------------ For tests\n\n  function _fight(\n    IGOC.ActionContext memory ctx,\n    IGOC.GeneratedMonster memory gen,\n    MonsterLib.AdrContext memory adrCtx\n  ) external returns (MonsterLib.FightInternalInfo memory fInfo, IGOC.MonsterGenInfo memory info){\n    return MonsterLib._fight(ctx, _mInfo, gen, adrCtx, _pseudoRandomForTests, fightForTests);\n  }\n\n  function _action(IGOC.ActionContext memory ctx) external returns (IGOC.ActionResult memory result, uint8 turn) {\n    return MonsterLib._action(ctx, _mInfo, _pseudoRandomForTests, fightForTests);\n  }\n\n  function packMonsterInfo(IGOC.MonsterGenInfo calldata mInfo) external {\n    MonsterLib.packMonsterInfo(mInfo, _mInfo);\n  }\n}"
    },
    "contracts/test/facades/FacadePackingLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/PackingLib.sol\";\nimport \"../../interfaces/IItemController.sol\";\n\ncontract FacadePackingLib {\n  bytes32[] public arr;\n  function setArr(bytes32[] memory data) external {\n    arr = data;\n  }\n  function getArr() external view returns (bytes32[] memory dest) {\n    dest = new bytes32[](arr.length);\n    for (uint i = 0; i < arr.length; ++i) {\n      dest[i] = arr[i];\n    }\n  }\n\n\n  function packNftId(address token, uint id) external pure returns (bytes32 serialized) {\n    return PackingLib.packNftId(token, id);\n\n  }\n\n  function unpackNftId(bytes32 data) external pure returns (address token, uint id) {\n    return PackingLib.unpackNftId(data);\n  }\n\n  function packAddressWithAmount(address token, uint amount) external pure returns (bytes32 data) {\n    return PackingLib.packAddressWithAmount(token, amount);\n  }\n\n  function unpackAddressWithAmount(bytes32 data) external pure returns (address token, uint amount) {\n    return PackingLib.unpackAddressWithAmount(data);\n  }\n\n  function packItemMintInfo(address item, uint32 chance) external pure returns (bytes32 data) {\n    return PackingLib.packItemMintInfo(item, chance);\n  }\n\n  function unpackItemMintInfo(bytes32 data) external pure returns (address item, uint32 chance) {\n    return PackingLib.unpackItemMintInfo(data);\n  }\n\n  function packCustomDataChange(bytes32 customDataIndex, int16 value) external pure returns (bytes32 data) {\n    return PackingLib.packCustomDataChange(customDataIndex, value);\n  }\n\n  function unpackCustomDataChange(bytes32 data) external pure returns (bytes32 customDataIndex, int16 value) {\n    return PackingLib.unpackCustomDataChange(data);\n  }\n\n  function packCustomDataRequirements(uint64 min, uint64 max, bool key) external pure returns (bytes32 data) {\n    return PackingLib.packCustomDataRequirements(min, max, key);\n  }\n\n  function unpackCustomDataRequirements(bytes32 data) external pure returns (uint64 min, uint64 max, bool key) {\n    return PackingLib.unpackCustomDataRequirements(data);\n  }\n\n  function packStatsChange(uint32 experience, int32 heal, int32 manaRegen, int32 lifeChancesRecovered, int32 damage, int32 manaConsumed) external pure returns (bytes32 data) {\n    return PackingLib.packStatsChange(experience, heal, manaRegen, lifeChancesRecovered, damage, manaConsumed);\n  }\n\n  function unpackStatsChange(bytes32 data) external pure returns (uint32 experience, int32 heal, int32 manaRegen, int32 lifeChancesRecovered, int32 damage, int32 manaConsumed) {\n    return PackingLib.unpackStatsChange(data);\n  }\n\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) external pure returns (bytes32 packedData) {\n    return PackingLib.packMapObject(objectAddress, objectId, objectType);\n  }\n\n  function unpackMapObject(bytes32 packedData) external pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\n    return PackingLib.unpackMapObject(packedData);\n  }\n\n  function packCoordinate(uint128 x, uint128 y) external pure returns (bytes32 packedData) {\n    return PackingLib.packCoordinate(x, y);\n  }\n\n  function unpackCoordinate(bytes32 packedData) external pure returns (uint128 x, uint128 y) {\n    return PackingLib.unpackCoordinate(packedData);\n  }\n\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) external pure returns (bytes32 packedData) {\n    return PackingLib.packBattlefieldId(biomeMapFieldId, territoryNumber, x, y);\n  }\n\n  function unpackBattlefieldId(bytes32 packedData) external pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\n    return PackingLib.unpackBattlefieldId(packedData);\n  }\n\n  function packReinforcementHeroInfo(uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) external pure returns (bytes32 packedData) {\n    return PackingLib.packReinforcementHeroInfo(biome, score, fee, stakeTs);\n  }\n\n  function unpackReinforcementHeroInfo(bytes32 packedData) external pure returns (uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) {\n    return PackingLib.unpackReinforcementHeroInfo(packedData);\n  }\n\n\n  function packDungeonKey(address heroAdr, uint80 heroId, uint16 dungLogicNum) external pure returns (bytes32 data) {\n    return PackingLib.packDungeonKey(heroAdr, heroId, dungLogicNum);\n  }\n\n  function unpackDungeonKey(bytes32 data) external pure returns (address heroAdr, uint80 heroId, uint16 dungLogicNum) {\n    return PackingLib.unpackDungeonKey(data);\n  }\n\n  function packIterationKey(address heroAdr, uint64 heroId, uint32 objId) external pure returns (bytes32 data) {\n    return PackingLib.packIterationKey(heroAdr, heroId, objId);\n  }\n\n  function unpackIterationKey(bytes32 data) external pure returns (address heroAdr, uint64 heroId, uint32 objId) {\n    return PackingLib.unpackIterationKey(data);\n  }\n\n  function packMonsterStats(uint8 level, uint8 race, uint32 experience, uint8 maxDropItems) external pure returns (bytes32 data) {\n    return PackingLib.packMonsterStats(level, race, experience, maxDropItems);\n  }\n\n  function unpackMonsterStats(bytes32 data) external pure returns (uint8 level, uint8 race, uint32 experience, uint8 maxDropItems) {\n    return PackingLib.unpackMonsterStats(data);\n  }\n\n  function packAttackInfo(address attackToken, uint64 attackTokenId, uint8 attackType) external pure returns (bytes32 data) {\n    return PackingLib.packAttackInfo(attackToken, attackTokenId, attackType);\n  }\n\n  function unpackAttackInfo(bytes32 data) external pure returns (address attackToken, uint64 attackTokenId, uint8 attackType) {\n    return PackingLib.unpackAttackInfo(data);\n  }\n\n  function packPlayedObjKey(address heroAdr, uint64 heroId, uint8 oType, uint8 biome) external pure returns (bytes32 data) {\n    return PackingLib.packPlayedObjKey(heroAdr, heroId, oType, biome);\n  }\n\n  function unpackPlayedObjKey(bytes32 data) external pure returns (address heroAdr, uint64 heroId, uint8 oType, uint8 biome) {\n    return PackingLib.unpackPlayedObjKey(data);\n  }\n\n  function packGeneratedMonster(bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) external pure returns (bytes32 data) {\n    return PackingLib.packGeneratedMonster(generated, amplifier, hp, turnCounter);\n  }\n\n  function unpackGeneratedMonster(bytes32 data) external pure returns (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) {\n    return PackingLib.unpackGeneratedMonster(data);\n  }\n\n  function packItemMeta(uint8 itemMetaType, uint8 itemLvl, uint8 itemType, uint16 baseDurability, uint8 defaultRarity,\n    uint8 minAttr, uint8 maxAttr, uint32 manaCost, IStatController.CoreAttributes memory req) external pure returns (bytes32 data) {\n    return PackingLib.packItemMeta(itemMetaType, itemLvl, itemType, baseDurability, defaultRarity, minAttr, maxAttr, manaCost, req);\n  }\n\n  function unpackItemMeta(bytes32 data) external pure returns (IItemController.ItemMeta memory result) {\n    return PackingLib.unpackItemMeta(data);\n  }\n\n  function packItemGenerateInfo(uint8 id, int32 min, int32 max, uint32 chance) external pure returns (bytes32 data) {\n    return PackingLib.packItemGenerateInfo(id, min, max, chance);\n  }\n\n  function unpackItemGenerateInfo(bytes32 data) external pure returns (uint8 id, int32 min, int32 max, uint32 chance) {\n    return PackingLib.unpackItemGenerateInfo(data);\n  }\n\n  function packItemAttackInfo(uint8 attackType, int32 min, int32 max, int32 factorStr, int32 factorDex, int32 factorVit, int32 factorEng) external pure returns (bytes32 data) {\n    return PackingLib.packItemAttackInfo(attackType, min, max, factorStr, factorDex, factorVit, factorEng);\n  }\n\n  function unpackItemAttackInfo(bytes32 data) external pure returns (uint8 attackType, int32 min, int32 max, int32 factorStr, int32 factorDex, int32 factorVit, int32 factorEng) {\n    return PackingLib.unpackItemAttackInfo(data);\n  }\n\n  function packItemInfo(uint8 rarity, uint8 augmentationLevel, uint16 durability) external pure returns (bytes32 data) {\n    return PackingLib.packItemInfo(rarity, augmentationLevel, durability);\n  }\n\n  function unpackItemInfo(bytes32 data) external pure returns (uint8 rarity, uint8 augmentationLevel, uint16 durability) {\n    return PackingLib.unpackItemInfo(data);\n  }\n\n  function packStoryPageId(uint16 storyId, uint16 pageId, uint8 heroClass) external pure returns (bytes32 data) {\n    return PackingLib.packStoryPageId(storyId, pageId, heroClass);\n  }\n\n  function unpackStoryPageId(bytes32 data) external pure returns (uint16 storyId, uint16 pageId, uint8 heroClass) {\n    return PackingLib.unpackStoryPageId(data);\n  }\n\n  function packStoryAnswerId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) external pure returns (bytes32 data) {\n    return PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n  }\n\n  function unpackStoryAnswerId(bytes32 data) external pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) {\n    return PackingLib.unpackStoryAnswerId(data);\n  }\n\n  function packStoryNextPagesId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) external pure returns (bytes32 data) {\n    return PackingLib.packStoryNextPagesId(storyId, pageId, heroClass, answerId, resultId);\n  }\n\n  function unpackStoryNextPagesId(bytes32 data) external pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) {\n    return PackingLib.unpackStoryNextPagesId(data);\n  }\n\n  function packStoryAttributeRequirement(uint8 attributeIndex, int32 value, bool isCore) external pure returns (bytes32 data) {\n    return PackingLib.packStoryAttributeRequirement(attributeIndex, value, isCore);\n  }\n\n  function unpackStoryAttributeRequirement(bytes32 data) external pure returns (uint8 attributeIndex, int32 value, bool isCore) {\n    return PackingLib.unpackStoryAttributeRequirement(data);\n  }\n\n  function packStoryItemRequirement(address item, bool requireItemBurn, bool requireItemEquipped) external pure returns (bytes32 data) {\n    return PackingLib.packStoryItemRequirement(item, requireItemBurn, requireItemEquipped);\n  }\n\n  function unpackStoryItemRequirement(bytes32 data) external pure returns (address item, bool requireItemBurn, bool requireItemEquipped) {\n    return PackingLib.unpackStoryItemRequirement(data);\n  }\n\n  function packStoryTokenRequirement(address token, uint88 amount, bool requireTransfer) external pure returns (bytes32 data) {\n    return PackingLib.packStoryTokenRequirement(token, amount, requireTransfer);\n  }\n\n  function unpackStoryTokenRequirement(bytes32 data) external pure returns (address token, uint88 amount, bool requireTransfer) {\n    return PackingLib.unpackStoryTokenRequirement(data);\n  }\n\n  function packStoryCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) external pure returns (bytes32 data) {\n    return PackingLib.packStoryCustomDataResult(storyId, pageId, heroClass, answerId, customDataResultId);\n  }\n\n  function unpackStoryCustomDataResult(bytes32 data) external pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) {\n    return PackingLib.unpackStoryCustomDataResult(data);\n  }\n\n  function packStoryHeroState(uint16 pageId, uint40 heroLastActionTS) external pure returns (bytes32 data) {\n    return PackingLib.packStoryHeroState(pageId, heroLastActionTS);\n  }\n\n  function unpackStoryHeroState(bytes32 data) external pure returns (uint16 pageId, uint40 heroLastActionTS) {\n    return PackingLib.unpackStoryHeroState(data);\n  }\n\n  function packStoryHeroStateId(address heroAdr, uint80 heroId, uint16 storyId) external pure returns (bytes32 data) {\n    return PackingLib.packStoryHeroStateId(heroAdr, heroId, storyId);\n  }\n\n  function unpackStoryHeroStateId(bytes32 data) external pure returns (address heroAdr, uint80 heroId, uint16 storyId) {\n    return PackingLib.unpackStoryHeroStateId(data);\n  }\n\n  function packStorySimpleRequirement(uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) external pure returns (bytes32 data) {\n    return PackingLib.packStorySimpleRequirement(randomRequirement, delayRequirement, isFinalAnswer);\n  }\n\n  function unpackStorySimpleRequirement(bytes32 data) external pure returns (uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) {\n    return PackingLib.unpackStorySimpleRequirement(data);\n  }\n\n  function packBreakInfo(uint8 slot, uint64 chance, bool stopIfBurned) external pure returns (bytes32 data) {\n    return PackingLib.packBreakInfo(slot, chance, stopIfBurned);\n  }\n\n  function unpackBreakInfo(bytes32 data) external pure returns (uint8 slot, uint64 chance, bool stopIfBurned) {\n    return PackingLib.unpackBreakInfo(data);\n  }\n\n  function packUint8Array(uint8[] memory data) external pure returns (bytes32) {\n    return PackingLib.packUint8Array(data);\n  }\n\n  function packUint8Array3(uint8 a, uint8 b, uint8 c) external pure returns (bytes32) {\n    return PackingLib.packUint8Array3(a, b, c);\n  }\n\n  function unpackUint8Array(bytes32 data) external pure returns (uint8[] memory) {\n    return PackingLib.unpackUint8Array(data);\n  }\n\n  function unpackUint8Array3(bytes32 data) external pure returns (uint8 a, uint8 b, uint8 c) {\n    return PackingLib.unpackUint8Array3(data);\n  }\n\n  function changeUnit8ArrayWithCheck(bytes32 data, uint index, uint8 value, uint8 expectedPrevValue) external pure returns (bytes32 newData) {\n    return PackingLib.changeUnit8ArrayWithCheck(data, index, value, expectedPrevValue);\n  }\n\n  function packInt32Array(int32[] memory data) external pure returns (bytes32) {\n    return PackingLib.packInt32Array(data);\n  }\n\n  function unpackInt32Array(bytes32 data) external pure returns (int32[] memory) {\n    return PackingLib.unpackInt32Array(data);\n  }\n\n  function packUint32Array(uint32[] memory data) external pure returns (bytes32) {\n    return PackingLib.packUint32Array(data);\n  }\n\n  function unpackUint32Array(bytes32 data) external pure returns (uint32[] memory) {\n    return PackingLib.unpackUint32Array(data);\n  }\n\n//  function getInt32AsInt24(bytes32[] memory arr_, uint idx) external pure returns (int32) {\n//    return PackingLib.getInt32AsInt24(arr_, idx);\n//  }\n//\n//  function getUnit8From32Step(bytes32[] memory arr_, uint idx) external pure returns (uint8) {\n//    return PackingLib.getUnit8From32Step(arr_, idx);\n//  }\n\n  function getInt32Memory(bytes32[] memory arr_, uint idx) external pure returns (int32) {\n    return PackingLib.getInt32Memory(arr_, idx);\n  }\n\n  function getInt32(uint idx) external view returns (int32) {\n    return PackingLib.getInt32(arr, idx);\n  }\n\n  function setInt32(uint idx, int32 value) external {\n    return PackingLib.setInt32(arr, idx, value);\n  }\n\n  function changeInt32(uint idx, int32 value) external returns (int32 newValue, int32 change) {\n    return PackingLib.changeInt32(arr, idx, value);\n  }\n\n  function toInt32Array(bytes32[] memory arr_, uint size) external pure returns (int32[] memory data) {\n    return PackingLib.toInt32Array(arr_, size);\n  }\n\n  function toBytes32Array(int32[] memory arr_) external pure returns (bytes32[] memory data) {\n    return PackingLib.toBytes32Array(arr_);\n  }\n\n  function toBytes32ArrayWithIds(int32[] memory arr_, uint8[] memory ids) external pure returns (bytes32[] memory data) {\n    return PackingLib.toBytes32ArrayWithIds(arr_, ids);\n  }\n\n  function toInt32ArrayWithIds(bytes32[] memory arr_) external pure returns (int32[] memory valuesOut, uint8[] memory idsOut) {\n    return PackingLib.toInt32ArrayWithIds(arr_);\n  }\n}"
    },
    "contracts/test/facades/FacadeReinforcementControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IAppErrors.sol\";\nimport \"../../interfaces/IReinforcementController.sol\";\nimport \"../../lib/ReinforcementControllerLib.sol\";\nimport \"../../lib/PackingLib.sol\";\nimport {ReinforcementController} from \"../../core/ReinforcementController.sol\";\n\n/// @dev We need IAppErrors to correctly handle custom errors in the tests\ncontract FacadeReinforcementControllerLib is ReinforcementController {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n  //region ------------------------ For tests\n  function _S() internal pure returns (IReinforcementController.MainState storage s) {\n    return ReinforcementControllerLib._S();\n  }\n  function setHeroTokenRewards(address heroToken, uint heroId, address token, uint amount) external {\n    _S()._heroTokenRewards[PackingLib.packNftId(heroToken, heroId)].set(token, amount);\n  }\n  function getHeroTokenRewards(address heroToken, uint heroId, uint index) external view returns (address, uint) {\n    return _S()._heroTokenRewards[PackingLib.packNftId(heroToken, heroId)].at(index);\n  }\n  function getHeroTokenRewardsLength(address heroToken, uint heroId) external view returns (uint) {\n    return _S()._heroTokenRewards[PackingLib.packNftId(heroToken, heroId)].length();\n  }\n  function setHeroNftRewards(address heroToken, uint heroId, address token, uint amount) external {\n    _S()._heroNftRewards[PackingLib.packNftId(heroToken, heroId)].push(PackingLib.packNftId(token, amount));\n  }\n  function getHeroNftRewards(address heroToken, uint heroId) external view returns (bytes32[] memory) {\n    return _S()._heroNftRewards[PackingLib.packNftId(heroToken, heroId)];\n  }\n  function setConfig(uint8 minLevel_, uint8 minLifeChances_) external {\n    _S().config = ReinforcementControllerLib.packConfig(minLevel_, minLifeChances_);\n  }\n  function getConfig() external view returns (uint8 minLevel_, uint8 minLifeChances_) {\n    return ReinforcementControllerLib.unpackConfig(_S().config);\n  }\n  function setStaked(address heroToken, uint heroId, uint8 biome, uint score, uint8 fee, uint64 blockTimestamp) external {\n    _S()._stakedHeroes[PackingLib.packNftId(heroToken, heroId)] = ReinforcementControllerLib.packHeroInfo(\n      IReinforcementController.HeroInfo({\n        biome: biome,\n        score: score,\n        fee: fee,\n        stakeTs: blockTimestamp == 0 ? uint64(block.timestamp) : blockTimestamp\n      })\n    );\n  }\n  function addToInternalIdsByBiomes(address heroToken, uint heroId, uint8 biome) external {\n    _S()._internalIdsByBiomes[biome].add(PackingLib.packNftId(heroToken, heroId));\n  }\n  function getInternalIdsByBiomes(address heroToken, uint heroId, uint8 biome) external view returns (bool) {\n    return _S()._internalIdsByBiomes[biome].contains(PackingLib.packNftId(heroToken, heroId));\n  }\n  function setMaxScore(uint8 biome, uint score) external {\n    _S().maxScore[biome] = score;\n  }\n  //endregion ------------------------ For tests\n\n  //region ------------------------ Internal logic\n  function _claimAllTokenRewards(address heroToken, uint heroId, address recipient) external {\n    return ReinforcementControllerLib._claimAllTokenRewards(heroToken, heroId, recipient);\n  }\n\n  function _claimAllNftRewards(address heroToken, uint heroId, address recipient) external {\n    return ReinforcementControllerLib._claimAllNftRewards(heroToken, heroId, recipient);\n  }\n\n  function _claimNftRewards(address heroToken, uint heroId, address recipient, uint countNft) external {\n    return ReinforcementControllerLib._claimNftRewards(heroToken, heroId, recipient, countNft);\n  }\n\n  function _generateReinforcementAttributes(uint[] memory indexes, address heroToken, uint heroId) external view returns (\n    int32[] memory attributes\n  ) {\n    return ReinforcementControllerLib._generateReinforcementAttributes(\n      IStatController(IController(controller()).statController()),\n      indexes,\n      heroToken,\n      heroId\n    );\n  }\n  //endregion ------------------------ Internal logic\n\n  //region ------------------------ Packing utils\n\n  function packHeroInfo(IReinforcementController.HeroInfo memory info) external pure returns (bytes32) {\n    return ReinforcementControllerLib.packHeroInfo(info);\n  }\n\n  function unpackHeroInfo(bytes32 packed) external pure returns (IReinforcementController.HeroInfo memory info) {\n    return ReinforcementControllerLib.unpackHeroInfo(packed);\n  }\n\n  function packConfig(uint8 minLevel_, uint8 minLifeChances_) external pure returns (bytes32) {\n    return ReinforcementControllerLib.packConfig(minLevel_, minLifeChances_);\n  }\n\n  function unpackConfig(bytes32 packed) external pure returns (uint8 minLevel_, uint8 minLifeChances_) {\n    return ReinforcementControllerLib.unpackConfig(packed);\n  }\n\n  //endregion ------------------------ Packing utils\n\n  //region ------------------------ USER ACTIONS for tests\n\n  function __stakeHero(bool isEoa, address msgSender, address heroToken, uint heroId, uint8 fee) external {\n    ReinforcementControllerLib.stakeHero(isEoa, IController(controller()), msgSender, heroToken, heroId, fee);\n  }\n\n  function __withdrawHero(bool isEoa, address msgSender, address heroToken, uint heroId) external {\n    ReinforcementControllerLib.withdrawHero(isEoa, IController(controller()), msgSender, heroToken, heroId);\n  }\n\n  function __claimAll(bool isEoa, address msgSender, address heroToken, uint heroId) external {\n    ReinforcementControllerLib.claimAll(isEoa, IController(controller()), msgSender, heroToken, heroId);\n  }\n\n  function __claimNft(bool isEoa, address msgSender, address heroToken, uint heroId, uint countNft) external {\n    ReinforcementControllerLib.claimNft(isEoa, IController(controller()), msgSender, heroToken, heroId, countNft);\n  }\n\n\n  //endregion ------------------------ USER ACTIONS for tests\n}\n"
    },
    "contracts/test/facades/FacadeScoreLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\nimport \"../../lib/ScoreLib.sol\";\n\ncontract FacadeScoreLib is IAppErrors {\n  function attributesScore(int32[] memory attributes, bool isForReinforcement) external pure returns (uint) {\n    return ScoreLib.attributesScore(attributes, isForReinforcement);\n  }\n\n  function itemScore(int32[] memory attributes, uint16 baseDurability) external pure returns (uint) {\n    return ScoreLib.itemScore(attributes, baseDurability);\n  }\n\n  function heroScore(int32[] memory attributes, uint level) external pure returns (uint) {\n    return ScoreLib.heroScore(attributes, level);\n  }\n}\n"
    },
    "contracts/test/facades/FacadeStatController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../openzeppelin/EnumerableSet.sol\";\nimport \"../../lib/StatControllerLib.sol\";\nimport \"../../core/StatController.sol\";\n\n/// @notice Lightweight wrapper around StatController to be able to test some function in core StatController contract\ncontract FacadeStatController is StatController {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @param packedHeroId packNftId(heroToken, heroTokenId)\n  function addIsConsumableUsed(bytes32 packedHeroId, address item) external {\n    StatControllerLib._S().usedConsumables[packedHeroId].add(item);\n  }\n}"
    },
    "contracts/test/facades/FacadeStatControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/StatControllerLib.sol\";\nimport \"../../interfaces/IStatController.sol\";\nimport \"../../openzeppelin/EnumerableSet.sol\";\n\ncontract FacadeStatControllerLib {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  IController internal _controller;\n  /// @dev To test _compareStatsWithAttributes\n  bytes32[] internal totalAttributes;\n\n  function _S() internal pure returns (IStatController.MainState storage s) {\n    return StatControllerLib._S();\n  }\n\n  //region ------------------------ For tests\n  function setHeroTotalAttributes(bytes32 key, bytes32[] memory value) external {\n    _S().heroTotalAttributes[key] = value;\n  }\n  //endregion ------------------------ For tests\n\n  //region ------------------------ Constants\n  function getLevelUpSum() external pure returns (int32) {\n    return StatControllerLib.LEVEL_UP_SUM;\n  }\n  function getKarmaHash() external pure returns (bytes32) {\n    return StatControllerLib.KARMA_HASH;\n  }\n  function getClassHash() external pure returns (bytes32) {\n    return StatControllerLib.HERO_CLASS_HASH;\n  }\n  //endregion ------------------------ Constants\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() public view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n  //region ------------------------ Initialization of _s\n  function initHeroStats(bytes32 key, bytes32 value) external {\n    _S().heroStats[key] = value;\n  }\n  function setHeroItemSlot(address heroToken, uint64 heroTokenId, uint8 itemSlot, address itemToken, uint itemTokenId) external {\n    _S().heroSlots[PackingLib.packMapObject(heroToken, heroTokenId, itemSlot)] = PackingLib.packNftId(itemToken, itemTokenId);\n  }\n  //endregion ------------------------ Initialization of _s\n\n  //region ------------------------ Get values of _s\n  function getHeroTotalAttributes(bytes32 key) external view returns (bytes32[] memory) {\n    return _S().heroTotalAttributes[key];\n  }\n  function getHeroCore(bytes32 key) external view returns (int32[] memory) {\n    return PackingLib.unpackInt32Array(_S()._heroCore[key]);\n  }\n  function getHeroItemSlot(bytes32 key) external view returns (address itemToken, uint itemTokenId) {\n    return PackingLib.unpackNftId(_S().heroSlots[key]);\n  }\n  function getUsedConsumables(bytes32 key) external view returns (address[] memory dest) {\n    uint len = _S().usedConsumables[key].length();\n    dest = new address[](len);\n    for (uint i = 0; i < len; ++i) {\n      dest[i] = _S().usedConsumables[key].at(i);\n    }\n    return dest;\n  }\n  function getHeroCustomData(bytes32 key1, bytes32 key2) external view returns (uint) {\n    return _S().heroCustomData[key1][key2];\n  }\n  //endregion ------------------------ Get values of _s\n\n  //region ------------------------ RESTRICTIONS\n\n  function onlyRegisteredContract() external view {\n    StatControllerLib.onlyRegisteredContract(_controller);\n  }\n\n  function onlyItemController() external view {\n    StatControllerLib.onlyItemController(_controller);\n  }\n\n  function onlyHeroController() external view {\n    StatControllerLib.onlyHeroController(_controller);\n  }\n  //endregion ------------------------ RESTRICTIONS\n\n\n  //region ------------------------ PURE\n  function isItemTypeEligibleToItemSlot(uint itemType, uint itemSlot) external pure returns (bool) {\n    return StatControllerLib.isItemTypeEligibleToItemSlot(itemType, itemSlot);\n  }\n\n  function levelUpExperienceRequired(uint32 level) external pure returns (uint) {\n    return StatControllerLib.levelUpExperienceRequired(level);\n  }\n\n  /// @dev Required to test _levelUpExperienceRequired\n  function levelExperience(uint32 level) external pure returns (uint32) {\n    return StatLib.levelExperience(level);\n  }\n  //endregion ------------------------ PURE\n\n  //region ------------------------ VIEWS\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory) {\n    return StatControllerLib.heroAttributes(_S(), token, tokenId);\n  }\n\n  function heroBonusAttributes(address token, uint tokenId) external view returns (int32[] memory) {\n    return StatControllerLib.heroBonusAttributes(_S(), token, tokenId);\n  }\n\n  function heroTemporallyAttributes(address token, uint tokenId) external view returns (int32[] memory) {\n    return StatControllerLib.heroTemporallyAttributes(_S(), token, tokenId);\n  }\n\n  function heroAttributesLength(address token, uint tokenId) external pure returns (uint) {\n    return StatControllerLib.heroAttributesLength(token, tokenId);\n  }\n\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32) {\n    return StatControllerLib.heroAttribute(_S(), token, tokenId, index);\n  }\n\n  function heroBaseAttributes(address token, uint tokenId) external view returns (IStatController.CoreAttributes memory core) {\n    return StatControllerLib.heroBaseAttributes(_S(), token, tokenId);\n  }\n\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint) {\n    return StatControllerLib.heroCustomData(_S(), token, tokenId, index);\n  }\n\n  function globalCustomData(bytes32 index) external view returns (uint) {\n    return StatControllerLib.globalCustomData(_S(), index);\n  }\n\n  function heroStats(address token, uint tokenId) external view returns (IStatController.ChangeableStats memory result) {\n    return StatControllerLib.heroStats(_S(), token, tokenId);\n  }\n\n  function heroItemSlot(address heroToken, uint64 heroTokenId, uint8 itemSlot) external view returns (bytes32 nftPacked) {\n    return StatControllerLib.heroItemSlot(_S(), heroToken, heroTokenId, itemSlot);\n  }\n\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory) {\n    return StatControllerLib.heroItemSlots(_S(), heroToken, heroTokenId);\n  }\n\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool) {\n    return StatControllerLib.isHeroAlive(_S(), heroToken, heroTokenId);\n  }\n\n  function isConsumableUsed(address heroToken, uint heroTokenId, address item) external view returns (bool) {\n    return StatControllerLib.isConsumableUsed(_S(), heroToken, heroTokenId, item);\n  }\n\n  function buffHero(IStatController.BuffInfo memory info) external view returns (int32[] memory, int32) {\n    return StatControllerLib.buffHero(_S(), IController(_controller), info);\n  }\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ ACTIONS\n\n  function initNewHero(address heroToken, uint heroTokenId, uint heroClass) external {\n    return StatControllerLib.initNewHero(_S(), IController(_controller), heroToken, heroTokenId, heroClass);\n  }\n\n  function changeHeroItemSlot(\n    address heroToken,\n    uint64 heroTokenId,\n    uint itemType,\n    uint8 itemSlot,\n    address itemToken,\n    uint itemTokenId,\n    bool equip\n  ) external {\n    return StatControllerLib.changeHeroItemSlot(\n      _S(),\n      IController(_controller),\n      heroToken,\n      heroTokenId,\n      itemType,\n      itemSlot,\n      itemToken,\n      itemTokenId,\n      equip\n    );\n  }\n\n  function changeCurrentStats(\n    address heroToken,\n    uint heroTokenId,\n    IStatController.ChangeableStats memory change,\n    bool increase\n  ) external {\n    return StatControllerLib.changeCurrentStats(\n      _S(),\n      IController(_controller),\n      heroToken,\n      heroTokenId,\n      change,\n      increase\n    );\n  }\n\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external {\n    return StatControllerLib.registerConsumableUsage(_S(), IController(controller()), heroToken, heroTokenId, item);\n  }\n\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external {\n    return StatControllerLib.clearUsedConsumables(_S(), IController(controller()), heroToken, heroTokenId);\n  }\n\n  function changeBonusAttributes(IStatController.ChangeAttributesInfo memory info) external {\n    return StatControllerLib.changeBonusAttributes(_S(), IController(controller()), info);\n  }\n\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external {\n    return StatControllerLib.clearTemporallyAttributes(_S(), IController(controller()), heroToken, heroTokenId);\n  }\n\n  function levelUp(\n    address heroToken,\n    uint heroTokenId,\n    uint heroClass,\n    IStatController.CoreAttributes memory change\n  ) external returns (uint newLvl) {\n    return StatControllerLib.levelUp(_S(), IController(controller()), heroToken, heroTokenId, heroClass, change);\n  }\n\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external {\n    return StatControllerLib.setHeroCustomData(_S(), IController(controller()), token, tokenId, index, value);\n  }\n\n  function setGlobalCustomData(bytes32 index, uint value) external {\n    return StatControllerLib.setGlobalCustomData(_S(), IController(controller()), index, value);\n  }\n\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external {\n    StatControllerLib.restoreLifeAndMana(_S(), IController(controller()), heroToken, heroTokenId, prevAttributes);\n  }\n  //endregion ------------------------ ACTIONS\n\n  //region ------------------------ _compareStatsWithAttributes\n  function _setTotalAttributeValue(uint attributeIndex, int32 value) external {\n    PackingLib.setInt32(totalAttributes, attributeIndex, value);\n  }\n  function _compareStatsWithAttributes(\n    address heroToken,\n    uint heroTokenId,\n    IStatController.ChangeableStats memory curStats\n  ) external {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    StatControllerLib._compareStatsWithAttributes(_S(), heroPackedId, totalAttributes, curStats);\n  }\n\n  //endregion ------------------------ _compareStatsWithAttributes\n\n  function _changeChangeableStats(\n    bytes32 heroPackedId,\n    uint32 level,\n    uint32 experience,\n    uint32 life,\n    uint32 mana,\n    uint32 lifeChances\n  ) external {\n    StatControllerLib._changeChangeableStats(_S(), heroPackedId, level, experience, life, mana, lifeChances);\n  }\n}\n"
    },
    "contracts/test/facades/FacadeStatControllerLibExtra.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/StatControllerLib.sol\";\nimport \"../../interfaces/IStatController.sol\";\nimport \"../../openzeppelin/EnumerableSet.sol\";\nimport {StatController} from \"../../core/StatController.sol\";\n\ncontract FacadeStatControllerLibExtra {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @dev To test _compareStatsWithAttributes\n  bytes32[] internal totalAttributes;\n  IController internal _controller;\n\n  function _S() internal pure returns (IStatController.MainState storage s) {\n    return StatControllerLib._S();\n  }\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n  //region ------------------------ For tests\n  function initNewHero(address heroToken, uint heroTokenId, uint heroClass) external {\n    return StatControllerLib.initNewHero(StatControllerLib._S(), _controller, heroToken, heroTokenId, heroClass);\n  }\n\n  function heroStats(address token, uint tokenId) external view returns (IStatController.ChangeableStats memory result) {\n    return StatControllerLib.heroStats(StatControllerLib._S(), token, tokenId);\n  }\n\n  //endregion ------------------------ For tests\n\n\n  //region ------------------------ Constants\n  function getLevelUpSum() external pure returns (int32) {\n    return StatControllerLib.LEVEL_UP_SUM;\n  }\n  function getKarmaHash() external pure returns (bytes32) {\n    return StatControllerLib.KARMA_HASH;\n  }\n  function getClassHash() external pure returns (bytes32) {\n    return StatControllerLib.HERO_CLASS_HASH;\n  }\n  //endregion ------------------------ Constants\n\n  //region ------------------------ RESTRICTIONS\n\n  function onlyRegisteredContract() external view {\n    StatControllerLib.onlyRegisteredContract(_controller);\n  }\n\n  function onlyItemController() external view {\n    StatControllerLib.onlyItemController(_controller);\n  }\n\n  function onlyHeroController() external view {\n    StatControllerLib.onlyHeroController(_controller);\n  }\n  //endregion ------------------------ RESTRICTIONS\n\n  //region ------------------------ PURE\n  function isItemTypeEligibleToItemSlot(uint itemType, uint itemSlot) external pure returns (bool) {\n    return StatControllerLib.isItemTypeEligibleToItemSlot(itemType, itemSlot);\n  }\n\n  function levelUpExperienceRequired(uint32 level) external pure returns (uint) {\n    return StatControllerLib.levelUpExperienceRequired(level);\n  }\n\n  /// @dev Required to test _levelUpExperienceRequired\n  function levelExperience(uint32 level) external pure returns (uint32) {\n    return StatLib.levelExperience(level);\n  }\n  //endregion ------------------------ PURE\n\n  //region ------------------------ _compareStatsWithAttributes\n  function _setTotalAttributeValue(uint attributeIndex, int32 value) external {\n    PackingLib.setInt32(totalAttributes, attributeIndex, value);\n  }\n  function _compareStatsWithAttributes(\n    address heroToken,\n    uint heroTokenId,\n    IStatController.ChangeableStats memory curStats\n  ) external {\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\n    StatControllerLib._compareStatsWithAttributes(_S(), heroPackedId, totalAttributes, curStats);\n  }\n\n  //endregion ------------------------ _compareStatsWithAttributes\n\n\n}\n"
    },
    "contracts/test/facades/FacadeStatLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/StatLib.sol\";\n\ncontract FacadeStatLib {\n  bytes32[] internal _attributes;\n  bytes32[] internal _bonusMain;\n  bytes32[] internal _bonusExtra;\n\n  function initialHero1() external pure returns (StatLib.InitialHero memory) {\n    return StatLib.initialHero1();\n  }\n\n  function initialHero2() external pure returns (StatLib.InitialHero memory) {\n    return StatLib.initialHero2();\n  }\n\n  function initialHero3() external pure returns (StatLib.InitialHero memory) {\n    return StatLib.initialHero3();\n  }\n\n  function initialHero4() external pure returns (StatLib.InitialHero memory) {\n    return StatLib.initialHero4();\n  }\n\n  function initialHero5() external pure returns (StatLib.InitialHero memory) {\n    return StatLib.initialHero5();\n  }\n\n  function initialHero(uint heroClass) external pure returns (StatLib.InitialHero memory) {\n    return StatLib.initialHero(heroClass);\n  }\n\n  function life(int32 vitality, uint heroClass, uint32 level) external pure returns (int32) {\n    return StatLib.life(vitality, heroClass, level);\n  }\n\n  function mana(int32 energy, uint heroClass, uint32 level) external pure returns (int32){\n    return StatLib.mana(energy, heroClass, level);\n  }\n\n  function lifeChances(uint heroClass, uint32 level) external pure returns (int32){\n    return StatLib.lifeChances(heroClass, level);\n  }\n\n  function levelExperience(uint32 level) external pure returns (uint32) {\n    return StatLib.levelExperience(level);\n  }\n\n  function chanceToHit(\n    uint attackersAttackRating,\n    uint defendersDefenceRating,\n    uint attackersLevel,\n    uint defendersLevel,\n    uint arFactor\n  ) external pure returns (uint) {\n    return StatLib.chanceToHit(attackersAttackRating, defendersDefenceRating, attackersLevel, defendersLevel, arFactor);\n  }\n\n  function experienceToLvl(uint experience, uint startFromLevel) external pure returns (uint level) {\n    return StatLib.experienceToLvl(experience, startFromLevel);\n  }\n\n  function expPerMonster(uint32 monsterExp, uint monsterRarity, uint32 heroExp, uint32 heroCurrentLvl, uint monsterBiome) external pure returns (uint32) {\n    return StatLib.expPerMonster(monsterExp, monsterRarity, heroExp, heroCurrentLvl, monsterBiome);\n  }\n\n  function mintDropChanceDelta(uint experience, uint startFromLevel, uint monsterBiome) external pure returns (uint) {\n    return StatLib.mintDropChanceDelta(experience, startFromLevel, monsterBiome);\n  }\n\n  function initAttributes(\n    bytes32[] memory attributes,\n    uint heroClass,\n    uint32 level,\n    IStatController.CoreAttributes memory base\n  ) external returns (uint32[] memory result, bytes32[] memory attributesOut) {\n    _attributes = attributes;\n    result = StatLib.initAttributes(_attributes, heroClass, level, base);\n    attributesOut = _attributes;\n  }\n\n  function updateCoreDependAttributesInMemory(\n    int32[] memory attributes,\n    int32[] memory bonus,\n    uint heroClass,\n    uint32 level\n  ) external pure returns (int32[] memory) {\n    return StatLib.updateCoreDependAttributesInMemory(attributes, bonus, heroClass, level);\n  }\n\n  function updateCoreDependAttributes(\n    IController controller,\n    bytes32[] memory attributes,\n    bytes32[] memory bonusMain,\n    bytes32[] memory bonusExtra,\n    IStatController.ChangeableStats memory heroStats,\n    uint index,\n    address heroToken,\n    int32 base\n  ) external returns (\n    bytes32[] memory attributesOut,\n    bytes32[] memory bonusMainOut,\n    bytes32[] memory bonusExtraOut\n  ) {\n    _attributes = attributes;\n    _bonusMain = bonusMain;\n    _bonusExtra = bonusExtra;\n    StatLib.updateCoreDependAttributes(controller, _attributes, _bonusMain, _bonusExtra, heroStats, index, heroToken, base);\n    attributesOut = _attributes;\n    bonusMainOut = _bonusMain;\n    bonusExtraOut = _bonusExtra;\n  }\n\n  function attributesAdd(int32[] memory base, int32[] memory add) external pure returns (int32[] memory) {\n    return StatLib.attributesAdd(base, add);\n  }\n\n//  function attributesRemove(int32[] memory base, int32[] memory remove) external pure returns (int32[] memory) {\n//    return StatLib.attributesRemove(base, remove);\n//  }\n\n  function packChangeableStats(IStatController.ChangeableStats memory stats) external pure returns (bytes32) {\n    return StatLib.packChangeableStats(stats);\n  }\n\n  function unpackChangeableStats(bytes32 data) external pure returns (IStatController.ChangeableStats memory result) {\n    return StatLib.unpackChangeableStats(data);\n  }\n\n  function bytesToFullAttributesArray(bytes32[] memory attributes_) external pure returns (int32[] memory result) {\n    return StatLib.bytesToFullAttributesArray(attributes_);\n  }\n\n  function valuesToFullAttributesArray(int32[] memory values, uint8[] memory ids) external pure returns (int32[] memory result) {\n    return StatLib.valuesToFullAttributesArray(values, ids);\n  }\n\n  function minDamage(int32 strength, uint heroClass) external pure returns (int32) {\n    return StatLib.minDamage(strength, heroClass);\n  }\n\n  function maxDamage(int32 strength, uint heroClass) external pure returns (int32) {\n    return StatLib.maxDamage(strength, heroClass);\n  }\n\n  function attackRating(int32 dexterity, uint heroClass) external pure returns (int32) {\n    return StatLib.attackRating(dexterity, heroClass);\n  }\n\n  function defense(int32 dexterity, uint heroClass) external pure returns (int32) {\n    return StatLib.defense(dexterity, heroClass);\n  }\n}"
    },
    "contracts/test/facades/FacadeStoryControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IStoryController.sol\";\nimport \"../../interfaces/IGOC.sol\";\nimport \"../../lib/StoryControllerLib.sol\";\n\ncontract FacadeStoryControllerLib is IAppErrors {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  IController internal _controller;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n\n  //region ------------------------ For tests\n  function _S() internal pure returns (IStoryController.MainState storage s) {\n    return StoryControllerLib._S();\n  }\n\n  function setStoryRequiredLevel(uint16 storyId, uint requiredLevel) external {\n    _S().storyRequiredLevel[storyId] = requiredLevel;\n  }\n\n  function setStoryRequiredHeroData(uint16 storyId, bytes32 index, uint64 min, uint64 max, bool key) external {\n    bytes32 data = PackingLib.packCustomDataRequirements(min, max, key);\n    _S().storyRequiredHeroData[storyId].push(IStoryController.CustomDataRequirementRangePacked({\n      index: index,\n      data: data\n    }));\n  }\n\n  function addBurnItem(bytes32 answerIdHash, uint8 slot, uint64 chance, bool stopIfBurned) external {\n    _S().burnItem[answerIdHash].push(PackingLib.packBreakInfo(slot, chance, stopIfBurned));\n  }\n\n  function setNextPageIds(bytes32 pagePackedId, uint16[] memory values) external {\n    _S().nextPageIds[pagePackedId] = values;\n  }\n\n  function setInfoAttributesAndItems(\n    uint16 storyId,\n    uint16 pageId,\n    uint8 heroClass,\n    uint16 answerId,\n    bool success,\n    uint8[] memory attributeIds,\n    int32[] memory attributeValues,\n    address[] memory mintItems,\n    uint32[] memory mintItemsChances\n  ) external {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n\n    (success\n      ? _S().successInfoAttributes\n      : _S().failInfoAttributes\n    )[answerPackedId] = PackingLib.toBytes32ArrayWithIds(attributeValues, attributeIds);\n\n    bytes32[] storage infoMintItems = success\n      ? _S().successInfoMintItems[answerPackedId]\n      : _S().failInfoMintItems[answerPackedId];\n\n    uint len = mintItems.length;\n    for (uint i = 0; i < len; ++i) {\n      infoMintItems.push(PackingLib.packItemMintInfo(mintItems[i], mintItemsChances[i]));\n    }\n  }\n\n  function setInfoStats(\n    bytes32 answerPackedId,\n    uint32 experience,\n    int32 heal,\n    int32 manaRegen,\n    int32 lifeChancesRecovered,\n    int32 damage,\n    int32 manaConsumed,\n    bool success\n  ) external {\n    (success ? _S().successInfoStats : _S().failInfoStats)[answerPackedId] = PackingLib.packStatsChange(\n      experience, heal, manaRegen, lifeChancesRecovered, damage, manaConsumed\n    );\n  }\n\n  function setAttributeRequirements(bytes32 answerPackedId, uint8 attributeIndex, int32 value, bool isCore) external {\n    bytes32 data = PackingLib.packStoryAttributeRequirement(attributeIndex, value, isCore);\n    _S().attributeRequirements[answerPackedId].push(data);\n  }\n\n  function setStoryTokenRequirements(bytes32 answerPackedId, address token, uint88 amount, bool requireTransfer) external {\n    bytes32 data = PackingLib.packStoryTokenRequirement(token, amount, requireTransfer);\n    _S().tokenRequirements[answerPackedId].push(data);\n  }\n\n  function setItemRequirements(bytes32 answerPackedId, address item, bool requireItemBurn, bool requireItemEquipped) external {\n    bytes32 data = PackingLib.packStoryItemRequirement(item, requireItemBurn, requireItemEquipped);\n    _S().itemRequirements[answerPackedId].push(data);\n  }\n\n  function setHeroCustomDataRequirement(\n    bytes32 answerPackedId,\n    bool globalCustomData,\n    bytes32 index,\n    uint64 min,\n    uint64 max,\n    bool mandatory\n  ) external {\n    IStoryController.CustomDataRequirementPacked[] storage arr = globalCustomData\n      ? _S().globalCustomDataRequirement[answerPackedId]\n      : _S().heroCustomDataRequirement[answerPackedId];\n\n    arr.push(IStoryController.CustomDataRequirementPacked({\n      data: PackingLib.packCustomDataRequirements(min, max, mandatory),\n      index: index\n    }));\n  }\n\n  function setNextObjectsRewrite(uint16 storyId, uint16 pageId, uint8 heroClass, uint32[] memory values) external {\n    bytes32 key = PackingLib.packStoryPageId(storyId, pageId, heroClass);\n    _S().nextObjectsRewrite[key] = values;\n  }\n\n  function setHeroState(address heroToken, uint80 heroTokenId, uint16 storyId, bytes32 value) external {\n    bytes32 key = PackingLib.packStoryHeroStateId(heroToken, heroTokenId, storyId);\n    _S().heroState[key] = value;\n  }\n\n  function getHeroState(address heroToken, uint80 heroTokenId, uint16 storyId) external view returns (bytes32 data) {\n    bytes32 key = PackingLib.packStoryHeroStateId(heroToken, heroTokenId, storyId);\n    return _S().heroState[key];\n  }\n\n  function setStoryIds(uint32 objectId, uint16 storyId) external {\n    _S().storyIds[objectId] = storyId;\n  }\n\n  function setIdToStory(uint16 storyId, uint32 objectId) external {\n    _S().idToStory[storyId] = objectId;\n  }\n\n  function addAnswer(uint16 storyId, uint16 pageId, uint8 heroClass, bytes32 answer) external {\n    _S().answers[PackingLib.packStoryPageId(storyId, pageId, heroClass)].push(answer);\n  }\n\n  function setStoryRegistrationInfo(uint32 objectId, uint16 storyIds_, bool registered) external {\n    _S().storyIds[objectId] = storyIds_;\n    _S().registeredStories[objectId] = registered;\n  }\n\n  function registerPage(uint16 storyId, uint16 pageId) external {\n    StorySetupLib.registerPage(_S(), storyId, pageId);\n  }\n\n  function registerAnswer(uint16 storyId, bytes32 answerId) external {\n    StorySetupLib.registerAnswer(_S(), storyId, answerId);\n  }\n\n  function getCountStoryPages(uint16 storyId) external view returns (uint) {\n    return _S().allStoryPages[storyId].length();\n  }\n\n  function getCountStoryAnswers(uint16 storyId) external view returns (uint) {\n    return _S().allStoryAnswers[storyId].length();\n  }\n\n  function addAllStoryPages(uint16 storyId, uint page) external {\n    _S().allStoryPages[storyId].add(page);\n  }\n\n  function addAllStoryAnswers(uint16 storyId, bytes32 answer) external {\n    _S().allStoryAnswers[storyId].add(answer);\n  }\n\n  function setCustomDataResult(\n    uint16 storyId,\n    IStoryController.AnswerCustomDataResultMeta calldata meta,\n    IStoryController.CustomDataResult type_\n  ) external {\n    StorySetupLib.setCustomDataResult(_S(), storyId, meta, type_);\n  }\n  //endregion ------------------------ For tests\n\n  //region ------------------------ VIEWS\n  function idToStory(uint16 storyId) external view returns (uint32) {\n    return StoryControllerLib.idToStory(storyId);\n  }\n\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId) {\n    return StoryControllerLib.heroPage(hero, heroId, storyId);\n  }\n\n  function storyIds(uint32 objectId) external view returns (uint16) {\n    return StoryControllerLib.storyIds(objectId);\n  }\n\n  function registeredStories(uint32 objectId) external view returns (bool) {\n    return StoryControllerLib.registeredStories(objectId);\n  }\n\n  function allStoryPagesLength(uint16 storyId) external view returns (uint) {\n    return StoryControllerLib.allStoryPagesLength(storyId);\n  }\n\n  function allStoryPages(uint16 storyId, uint index) external view returns (uint) {\n    return StoryControllerLib.allStoryPages(storyId, index);\n  }\n\n  function allStoryAnswersLength(uint16 storyId) external view returns (uint) {\n    return StoryControllerLib.allStoryAnswersLength(storyId);\n  }\n\n  function allStoryAnswers(uint16 storyId, uint index) external view returns (bytes32) {\n    return StoryControllerLib.allStoryAnswers(storyId, index);\n  }\n\n  function currentHeroAnswers(uint16 storyId, address hero, uint80 heroId) public view returns (bytes32[] memory) {\n    return StoryControllerLib.currentHeroAnswers(_controller, storyId, hero, heroId);\n  }\n\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool) {\n    return StoryControllerLib.isStoryAvailableForHero(_controller, objectId, heroToken, heroTokenId);\n  }\n\n  //endregion ------------------------ VIEWS\n\n  //region ------------------------ CHANGE META\n\n  function removeStory(uint32 objectId) external {\n    StoryControllerLib.removeStory(_controller, objectId);\n  }\n\n  function removeStoryPagesMeta(uint16 storyId, uint maxIterations) external {\n    StoryControllerLib.removeStoryPagesMeta(_controller, storyId, maxIterations);\n  }\n\n  function removeStoryAnswersMeta(uint16 storyId, uint maxIterations) external {\n    StoryControllerLib.removeStoryAnswersMeta(_controller, storyId, maxIterations);\n  }\n  //endregion ------------------------ CHANGE META\n\n  //region ------------------------ MAIN LOGIC\n\n  function storyAction(\n    address sender,\n    uint64 dungeonId,\n    uint32 objectId,\n    uint stageId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 biome,\n    uint iteration,\n    bytes memory data\n  ) external returns (\n    IGOC.ActionResult memory result\n  ) {\n    return StoryControllerLib.storyAction(\n      _controller,\n      sender,\n      dungeonId,\n      objectId,\n      stageId,\n      heroToken,\n      heroTokenId,\n      biome,\n      iteration,\n      data\n    );\n  }\n\n  function _handleAnswer(\n    IStoryController.StoryActionContext memory context,\n    bytes32[] memory heroAnswers\n  ) external returns (\n    IGOC.ActionResult memory returnResult\n  ) {\n    return StoryControllerLib._handleAnswer(context, heroAnswers);\n  }\n\n  //endregion ------------------------ MAIN LOGIC\n\n  //region ------------------------ SETTERS\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  // Setters section is implemented in FacadeStoryControllerLibSetters\n  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  //endregion ------------------------ SETTERS\n\n\n}\n"
    },
    "contracts/test/facades/FacadeStoryControllerLibSetters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"./FacadeStorySetupBase.sol\";\n\ncontract FacadeStoryControllerLibSetters is FacadeStorySetupBase {\n  IController internal _controller;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n\n  //region ------------------------ SETTERS\n\n  function setAllStoryFields(IStoryController.StoryMetaInfo calldata meta) external {\n    StoryControllerLib.setAllStoryFields(_controller, meta);\n  }\n\n  function setBurnItemsMeta(uint16 storyId, IStoryController.AnswerBurnRandomItemMeta calldata meta) external {\n    StoryControllerLib.setBurnItemsMeta(_controller, storyId, meta);\n  }\n\n  function setNextObjRewriteMeta(uint16 storyId, IStoryController.NextObjRewriteMeta calldata meta) external {\n    StoryControllerLib.setNextObjRewriteMeta(_controller, storyId, meta);\n  }\n\n  function setAnswersMeta(\n    uint16 storyId,\n    uint16[] calldata answerPageIds,\n    uint8[] calldata answerHeroClasses,\n    uint16[] calldata answerIds\n  ) external {\n    StoryControllerLib.setAnswersMeta(_controller, storyId, answerPageIds, answerHeroClasses, answerIds);\n  }\n\n  function setAnswerNextPageMeta(uint16 storyId, IStoryController.AnswerNextPageMeta calldata meta) external {\n    StoryControllerLib.setAnswerNextPageMeta(_controller, storyId, meta);\n  }\n\n  function setAnswerAttributeRequirements(uint16 storyId, IStoryController.AnswerAttributeRequirementsMeta calldata meta) external {\n    StoryControllerLib.setAnswerAttributeRequirements(_controller, storyId, meta);\n  }\n\n  function setAnswerItemRequirements(uint16 storyId, IStoryController.AnswerItemRequirementsMeta calldata meta) external {\n    StoryControllerLib.setAnswerItemRequirements(_controller, storyId, meta);\n  }\n\n  function setAnswerTokenRequirementsMeta(uint16 storyId, IStoryController.AnswerTokenRequirementsMeta calldata meta) external {\n    StoryControllerLib.setAnswerTokenRequirementsMeta(_controller, storyId, meta);\n  }\n\n  function setAnswerAttributes(uint16 storyId, IStoryController.AnswerAttributesMeta calldata meta) external {\n    StoryControllerLib.setAnswerAttributes(_controller, storyId, meta);\n  }\n\n  function setAnswerHeroCustomDataRequirementMeta(uint16 storyId, IStoryController.AnswerCustomDataMeta calldata meta) external {\n    StoryControllerLib.setAnswerHeroCustomDataRequirementMeta(_controller, storyId, meta);\n  }\n\n  function setAnswerGlobalCustomDataRequirementMeta(uint16 storyId, IStoryController.AnswerCustomDataMeta calldata meta) external {\n    StoryControllerLib.setAnswerGlobalCustomDataRequirementMeta(_controller, storyId, meta);\n  }\n\n  function setSuccessInfo(uint16 storyId, IStoryController.AnswerResultMeta calldata meta) external {\n    StoryControllerLib.setSuccessInfo(_controller, storyId, meta);\n  }\n\n  function setFailInfo(uint16 storyId, IStoryController.AnswerResultMeta calldata meta) external {\n    StoryControllerLib.setFailInfo(_controller, storyId, meta);\n  }\n\n  function setCustomDataResult(uint16 storyId, IStoryController.AnswerCustomDataResultMeta calldata meta, IStoryController.CustomDataResult type_) external {\n    StoryControllerLib.setCustomDataResult(_controller, storyId, meta, type_);\n  }\n\n  function setStoryCustomDataRequirements(\n    uint16 storyId,\n    bytes32[] calldata requiredCustomDataIndex,\n    uint64[] calldata requiredCustomDataMinValue,\n    uint64[] calldata requiredCustomDataMaxValue,\n    bool[] calldata requiredCustomDataIsHero,\n    uint minLevel\n  ) external {\n    StoryControllerLib.setStoryCustomDataRequirements(\n      _controller,\n      storyId,\n      requiredCustomDataIndex,\n      requiredCustomDataMinValue,\n      requiredCustomDataMaxValue,\n      requiredCustomDataIsHero,\n      minLevel\n    );\n  }\n\n  function finalizeStoryRegistration(uint16 storyId, uint32 objectId, uint buildHash) external {\n    StoryControllerLib.finalizeStoryRegistration(_controller, storyId, objectId, buildHash);\n  }\n  //endregion ------------------------ SETTERS\n}\n"
    },
    "contracts/test/facades/FacadeStoryLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IStoryController.sol\";\nimport \"../../interfaces/IGOC.sol\";\nimport \"../../interfaces/IOracle.sol\";\nimport \"../../interfaces/IAppErrors.sol\";\nimport \"../../lib/StoryLib.sol\";\nimport \"../../lib/StoryControllerLib.sol\";\nimport \"../../lib/PackingLib.sol\";\n\ncontract FacadeStoryLib is IAppErrors {\n  struct MintRandomItemsMockLastCallResults {\n    uint8 biome;\n    address oracle;\n    uint32 experience;\n    uint32 level;\n    bytes32[] mintItemsData;\n  }\n  MintRandomItemsMockLastCallResults private _mintRandomItemsMockLastCallResults;\n  address[] private _mintRandomItemsMockReturn;\n  IController private _controller;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n\n  //region ------------------------ For tests\n  function _S() internal pure returns (IStoryController.MainState storage s) {\n    return StoryControllerLib._S();\n  }\n\n  function setStoryRequiredLevel(uint16 storyId, uint requiredLevel) external {\n    _S().storyRequiredLevel[storyId] = requiredLevel;\n  }\n\n  function setStoryRequiredHeroData(uint16 storyId, bytes32 index, uint64 min, uint64 max, bool key) external {\n    bytes32 data = PackingLib.packCustomDataRequirements(min, max, key);\n    _S().storyRequiredHeroData[storyId].push(IStoryController.CustomDataRequirementRangePacked({\n      index: index,\n      data: data\n    }));\n  }\n\n  function addBurnItem(bytes32 answerIdHash, uint8 slot, uint64 chance, bool stopIfBurned) external {\n    _S().burnItem[answerIdHash].push(PackingLib.packBreakInfo(slot, chance, stopIfBurned));\n  }\n\n  function setNextPageIds(bytes32 pagePackedId, uint16[] memory values) external {\n    _S().nextPageIds[pagePackedId] = values;\n  }\n\n  function setInfoAttributesAndItems(\n    uint16 storyId,\n    uint16 pageId,\n    uint8 heroClass,\n    uint16 answerId,\n    bool success,\n    uint8[] memory attributeIds,\n    int32[] memory attributeValues,\n    address[] memory mintItems,\n    uint32[] memory mintItemsChances\n  ) external {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n\n    (success\n      ? _S().successInfoAttributes\n      : _S().failInfoAttributes\n    )[answerPackedId] = PackingLib.toBytes32ArrayWithIds(attributeValues, attributeIds);\n\n    bytes32[] storage infoMintItems = success\n      ? _S().successInfoMintItems[answerPackedId]\n      : _S().failInfoMintItems[answerPackedId];\n\n      uint len = mintItems.length;\n      for (uint i = 0; i < len; ++i) {\n        infoMintItems.push(PackingLib.packItemMintInfo(mintItems[i], mintItemsChances[i]));\n      }\n  }\n\n  function setInfoStats(\n    bytes32 answerPackedId,\n    uint32 experience,\n    int32 heal,\n    int32 manaRegen,\n    int32 lifeChancesRecovered,\n    int32 damage,\n    int32 manaConsumed,\n    bool success\n  ) external {\n    (success ? _S().successInfoStats : _S().failInfoStats)[answerPackedId] = PackingLib.packStatsChange(\n      experience, heal, manaRegen, lifeChancesRecovered, damage, manaConsumed\n    );\n  }\n\n  function setCustomDataResult(\n    uint16 storyId,\n    IStoryController.AnswerCustomDataResultMeta calldata meta,\n    IStoryController.CustomDataResult type_\n  ) external {\n    StorySetupLib.setCustomDataResult(_S(), storyId, meta, type_);\n  }\n\n  function setAttributeRequirements(bytes32 answerPackedId, uint8 attributeIndex, int32 value, bool isCore) external {\n    bytes32 data = PackingLib.packStoryAttributeRequirement(attributeIndex, value, isCore);\n    _S().attributeRequirements[answerPackedId].push(data);\n  }\n\n  function setStoryTokenRequirements(bytes32 answerPackedId, address token, uint88 amount, bool requireTransfer) external {\n    bytes32 data = PackingLib.packStoryTokenRequirement(token, amount, requireTransfer);\n    _S().tokenRequirements[answerPackedId].push(data);\n  }\n\n  function setItemRequirements(bytes32 answerPackedId, address item, bool requireItemBurn, bool requireItemEquipped) external {\n    bytes32 data = PackingLib.packStoryItemRequirement(item, requireItemBurn, requireItemEquipped);\n    _S().itemRequirements[answerPackedId].push(data);\n  }\n\n  function setHeroCustomDataRequirement(\n    bytes32 answerPackedId,\n    bool globalCustomData,\n    bytes32 index,\n    uint64 min,\n    uint64 max,\n    bool mandatory\n  ) external {\n    IStoryController.CustomDataRequirementPacked[] storage arr = globalCustomData\n      ? _S().globalCustomDataRequirement[answerPackedId]\n      : _S().heroCustomDataRequirement[answerPackedId];\n\n    arr.push(IStoryController.CustomDataRequirementPacked({\n      data: PackingLib.packCustomDataRequirements(min, max, mandatory),\n      index: index\n    }));\n  }\n\n  function setHeroState(address heroToken, uint80 heroTokenId, uint16 storyId, bytes32 value) external {\n    bytes32 key = PackingLib.packStoryHeroStateId(heroToken, heroTokenId, storyId);\n    _S().heroState[key] = value;\n  }\n\n  function getHeroState(address heroToken, uint80 heroTokenId, uint16 storyId) external view returns (bytes32 data) {\n    bytes32 key = PackingLib.packStoryHeroStateId(heroToken, heroTokenId, storyId);\n    return _S().heroState[key];\n  }\n\n  function setNextObjectsRewrite(uint16 storyId, uint16 pageId, uint8 heroClass, uint32[] memory values) external {\n    bytes32 key = PackingLib.packStoryPageId(storyId, pageId, heroClass);\n    _S().nextObjectsRewrite[key] = values;\n  }\n\n  function _mintedInIteration(address heroToken, uint heroTokenId, uint16 storyId, uint iteration) external view returns (uint) {\n    bytes32 key = PackingLib.packStoryHeroStateId(heroToken, uint80(heroTokenId), storyId);\n    return _S().mintedInIteration[key][iteration];\n  }\n\n  //endregion ------------------------ For tests\n\n\n  //region ------------------------ Story logic\n\n  function action(IGOC.ActionContext memory ctx, uint16 storyId) external returns (IGOC.ActionResult memory result) {\n    return StoryLib.action(ctx, storyId);\n  }\n\n  function isStoryAvailableForHero(uint16 storyId, address heroToken, uint heroTokenId) external view returns (bool) {\n    return StoryLib.isStoryAvailableForHero(_S(), storyId, heroToken, heroTokenId, _controller.statController());\n  }\n\n  function handleResult(\n    IStoryController.StoryActionContext memory context,\n    bytes32[] memory attributesChanges,\n    bytes32 statsChanges,\n    bytes32[] memory mintItemsData\n  ) external returns (\n    IGOC.ActionResult memory results,\n    IStatController.ChangeableStats memory updatedHeroStats\n  ) {\n    results = StoryLib.handleResult(context, attributesChanges, statsChanges, mintItemsData, _mintRandomItemsMock);\n    updatedHeroStats = context.heroStats;\n  }\n\n  function _mintRandomItemsMock(\n    IStoryController.StoryActionContext memory context,\n    bytes32[] memory mintItemsData\n  ) internal returns (\n    address[] memory mintItems\n  ){\n    _mintRandomItemsMockLastCallResults = MintRandomItemsMockLastCallResults({\n      biome: context.biome,\n      oracle: address(context.oracle),\n      experience : context.heroStats.experience,\n      level: context.heroStats.level,\n      mintItemsData: mintItemsData\n    });\n    return _mintRandomItemsMockReturn;\n  }\n\n  function setMintRandomItemsMockReturn(address[] memory mintItems) external {\n    _mintRandomItemsMockReturn = mintItems;\n  }\n\n  function getMintRandomItemsMockLastCallResults() external view returns(\n    uint8 biome,\n    address oracle,\n    uint32 experience,\n    uint32 level,\n    bytes32[] memory mintItemsData\n  ) {\n    MintRandomItemsMockLastCallResults memory r = _mintRandomItemsMockLastCallResults;\n    return (r.biome, r.oracle, r.experience, r.level, r.mintItemsData);\n  }\n\n  function clearMintRandomItemsMockLastCallResults() external {\n    MintRandomItemsMockLastCallResults memory empty;\n    _mintRandomItemsMockLastCallResults = empty;\n  }\n\n  function _generateAttributes(bytes32[] memory attributesChanges) external pure returns (int32[] memory attributes) {\n    return StoryLib._generateAttributes(attributesChanges);\n  }\n\n  function _generateStats(bytes32 statsChanges) external pure returns (IStoryController.StatsChange memory change) {\n    return StoryLib._generateStats(statsChanges);\n  }\n\n  function handleCustomDataResult(\n    IStoryController.StoryActionContext memory context,\n    bytes32[] memory heroCustomDatas,\n    bytes32[] memory globalCustomDatas\n  ) external {\n    return StoryLib.handleCustomDataResult(context, heroCustomDatas, globalCustomDatas);\n  }\n\n  function breakItem(IStoryController.StoryActionContext memory context) external {\n    return StoryLib.breakItem(context, _S());\n  }\n\n  function _breakItemInHeroSlot(IStoryController.StoryActionContext memory context, uint8 slot) external {\n    return StoryLib._breakItemInHeroSlot(context, slot);\n  }\n\n  function finishStory(IStoryController.StoryActionContext memory context) external returns (\n    uint32[] memory nextObjs\n  ) {\n    return StoryLib.finishStory(context, _S());\n  }\n\n  function handleAnswer(\n    IStoryController.AnswerResultId answerResultId,\n    IStoryController.StoryActionContext memory context\n  ) external returns (IGOC.ActionResult memory returnResult, uint16 nextPage, uint16[] memory nextPages) {\n    return StoryLib._handleAnswer(answerResultId, _S(), context, _mintRandomItemsMock);\n  }\n\n  function getNextPage(IOracle oracle, uint16[] memory pages) external returns (uint16) {\n    return StoryLib._getNextPage(oracle, pages);\n  }\n\n  function checkAnswerIndexValid(bytes32[] memory heroAnswers, bytes32 answerIdHash) external pure {\n    return StoryLib.checkAnswerIndexValid(heroAnswers, answerIdHash);\n  }\n\n  //endregion ------------------------ Story logic\n\n//region ------------------------ Check answers\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// see FacadeStoryLibCheckAnswers\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//endregion ------------------------ Check answers\n\n  //region ------------------------ Utils\n  function _getStoryIndex(uint16 storyId) external pure returns (bytes32) {\n    return StoryLib._getStoryIndex(storyId);\n  }\n\n  //endregion ------------------------ Utils\n}"
    },
    "contracts/test/facades/FacadeStoryLibCheckAnswers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IStoryController.sol\";\nimport \"../../interfaces/IGOC.sol\";\nimport \"../../interfaces/IOracle.sol\";\nimport \"../../interfaces/IAppErrors.sol\";\nimport \"../../lib/StoryLib.sol\";\nimport \"../../lib/StoryControllerLib.sol\";\nimport \"../../lib/PackingLib.sol\";\n\ncontract FacadeStoryLibCheckAnswers is IAppErrors {\n  struct MintRandomItemsMockLastCallResults {\n    uint8 biome;\n    address oracle;\n    uint32 experience;\n    uint32 level;\n    bytes32[] mintItemsData;\n  }\n  MintRandomItemsMockLastCallResults private _mintRandomItemsMockLastCallResults;\n  address[] private _mintRandomItemsMockReturn;\n  IController private _controller;\n\n  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n  function controller() external view returns (address) {\n    return address(_controller);\n  }\n  function setController(address controller_) external {\n    _controller = IController(controller_);\n  }\n  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n\n  //region ------------------------ For tests\n  function _S() internal pure returns (IStoryController.MainState storage s) {\n    return StoryControllerLib._S();\n  }\n\n  function setStoryRequiredLevel(uint16 storyId, uint requiredLevel) external {\n    _S().storyRequiredLevel[storyId] = requiredLevel;\n  }\n\n  function setStoryRequiredHeroData(uint16 storyId, bytes32 index, uint64 min, uint64 max, bool key) external {\n    bytes32 data = PackingLib.packCustomDataRequirements(min, max, key);\n    _S().storyRequiredHeroData[storyId].push(IStoryController.CustomDataRequirementRangePacked({\n      index: index,\n      data: data\n    }));\n  }\n\n  function addBurnItem(bytes32 answerIdHash, uint8 slot, uint64 chance, bool stopIfBurned) external {\n    _S().burnItem[answerIdHash].push(PackingLib.packBreakInfo(slot, chance, stopIfBurned));\n  }\n\n  function setNextPageIds(bytes32 pagePackedId, uint16[] memory values) external {\n    _S().nextPageIds[pagePackedId] = values;\n  }\n\n  function setInfoAttributesAndItems(\n    uint16 storyId,\n    uint16 pageId,\n    uint8 heroClass,\n    uint16 answerId,\n    bool success,\n    uint8[] memory attributeIds,\n    int32[] memory attributeValues,\n    address[] memory mintItems,\n    uint32[] memory mintItemsChances\n  ) external {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n\n    (success\n      ? _S().successInfoAttributes\n      : _S().failInfoAttributes\n    )[answerPackedId] = PackingLib.toBytes32ArrayWithIds(attributeValues, attributeIds);\n\n    bytes32[] storage infoMintItems = success\n      ? _S().successInfoMintItems[answerPackedId]\n      : _S().failInfoMintItems[answerPackedId];\n\n      uint len = mintItems.length;\n      for (uint i = 0; i < len; ++i) {\n        infoMintItems.push(PackingLib.packItemMintInfo(mintItems[i], mintItemsChances[i]));\n      }\n  }\n\n  function setInfoStats(\n    bytes32 answerPackedId,\n    uint32 experience,\n    int32 heal,\n    int32 manaRegen,\n    int32 lifeChancesRecovered,\n    int32 damage,\n    int32 manaConsumed,\n    bool success\n  ) external {\n    (success ? _S().successInfoStats : _S().failInfoStats)[answerPackedId] = PackingLib.packStatsChange(\n      experience, heal, manaRegen, lifeChancesRecovered, damage, manaConsumed\n    );\n  }\n\n  function setCustomDataResult(\n    uint16 storyId,\n    IStoryController.AnswerCustomDataResultMeta calldata meta,\n    IStoryController.CustomDataResult type_\n  ) external {\n    StorySetupLib.setCustomDataResult(_S(), storyId, meta, type_);\n  }\n\n  function setAttributeRequirements(bytes32 answerPackedId, uint8 attributeIndex, int32 value, bool isCore) external {\n    bytes32 data = PackingLib.packStoryAttributeRequirement(attributeIndex, value, isCore);\n    _S().attributeRequirements[answerPackedId].push(data);\n  }\n\n  function setStoryTokenRequirements(bytes32 answerPackedId, address token, uint88 amount, bool requireTransfer) external {\n    bytes32 data = PackingLib.packStoryTokenRequirement(token, amount, requireTransfer);\n    _S().tokenRequirements[answerPackedId].push(data);\n  }\n\n  function setItemRequirements(bytes32 answerPackedId, address item, bool requireItemBurn, bool requireItemEquipped) external {\n    bytes32 data = PackingLib.packStoryItemRequirement(item, requireItemBurn, requireItemEquipped);\n    _S().itemRequirements[answerPackedId].push(data);\n  }\n\n  function setHeroCustomDataRequirement(\n    bytes32 answerPackedId,\n    bool globalCustomData,\n    bytes32 index,\n    uint64 min,\n    uint64 max,\n    bool mandatory\n  ) external {\n    IStoryController.CustomDataRequirementPacked[] storage arr = globalCustomData\n      ? _S().globalCustomDataRequirement[answerPackedId]\n      : _S().heroCustomDataRequirement[answerPackedId];\n\n    arr.push(IStoryController.CustomDataRequirementPacked({\n      data: PackingLib.packCustomDataRequirements(min, max, mandatory),\n      index: index\n    }));\n  }\n\n  function setHeroState(address heroToken, uint80 heroTokenId, uint16 storyId, bytes32 value) external {\n    bytes32 key = PackingLib.packStoryHeroStateId(heroToken, heroTokenId, storyId);\n    _S().heroState[key] = value;\n  }\n\n  function getHeroState(address heroToken, uint80 heroTokenId, uint16 storyId) external view returns (bytes32 data) {\n    bytes32 key = PackingLib.packStoryHeroStateId(heroToken, heroTokenId, storyId);\n    return _S().heroState[key];\n  }\n\n\n  function setNextObjectsRewrite(uint16 storyId, uint16 pageId, uint8 heroClass, uint32[] memory values) external {\n    bytes32 key = PackingLib.packStoryPageId(storyId, pageId, heroClass);\n    _S().nextObjectsRewrite[key] = values;\n  }\n  //endregion ------------------------ For tests\n\n\n  //region ------------------------ Check answers\n\n  function checkAnswer(IStoryController.StoryActionContext memory context) external returns (IStoryController.AnswerResultId result) {\n    return StoryLib.checkAnswer(context, _S());\n  }\n\n  function checkAnswerAttributes(IStoryController.StoryActionContext memory context, bytes32 answerIndex) external view returns (\n    IStoryController.AnswerResultId\n  ) {\n    return StoryLib.checkAnswerAttributes(context, answerIndex, _S());\n  }\n\n  function checkAnswerItems(IStoryController.StoryActionContext memory context, bytes32 answerIndex) external returns (\n    IStoryController.AnswerResultId\n  ) {\n    return StoryLib.checkAnswerItems(context, answerIndex, _S());\n  }\n\n  function checkAnswerTokens(IStoryController.StoryActionContext memory context, bytes32 answerIndex) external returns (\n    IStoryController.AnswerResultId\n  ) {\n    return StoryLib.checkAnswerTokens(context, answerIndex, _S());\n  }\n\n  function checkAnswerRandom(IStoryController.StoryActionContext memory context) external returns (IStoryController.AnswerResultId) {\n    return StoryLib.checkAnswerRandom(context);\n  }\n\n  function checkAnswerDelay(IStoryController.StoryActionContext memory context) external view returns (IStoryController.AnswerResultId) {\n    return StoryLib.checkAnswerDelay(context);\n  }\n\n  function checkAnswerHeroCustomData(IStoryController.StoryActionContext memory context, bytes32 answerIndex) external view returns (\n    IStoryController.AnswerResultId\n  ) {\n    return StoryLib.checkAnswerHeroCustomData(context, answerIndex, _S());\n  }\n\n  function checkAnswerGlobalCustomData(IStoryController.StoryActionContext memory context, bytes32 answerIndex) external view returns (\n    IStoryController.AnswerResultId\n  ) {\n    return StoryLib.checkAnswerGlobalCustomData(context, answerIndex, _S());\n  }\n\n  //endregion ------------------------ Check answers\n}"
    },
    "contracts/test/facades/FacadeStorySetupBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IStoryController.sol\";\nimport \"../../interfaces/IGOC.sol\";\nimport \"../../interfaces/IOracle.sol\";\nimport \"../../interfaces/IAppErrors.sol\";\nimport \"../../lib/StorySetupLib.sol\";\nimport \"../../lib/StoryControllerLib.sol\";\nimport \"../../lib/PackingLib.sol\";\n\nabstract contract FacadeStorySetupBase is IAppErrors {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  //region ------------------------ For tests\n  function _S() internal pure returns (IStoryController.MainState storage s) {\n    return StoryControllerLib._S();\n  }\n\n  function _getMapItems(EnumerableSet.Bytes32Set storage map) internal view returns (bytes32[] memory values) {\n    values = new bytes32[](map.length());\n\n    for (uint i = 0; i < map.length(); ++i) {\n      values[i] = map.at(i);\n    }\n  }\n\n  function _getMapItems(EnumerableSet.UintSet storage map) internal view returns (uint[] memory values) {\n    values = new uint[](map.length());\n\n    for (uint i = 0; i < map.length(); ++i) {\n      values[i] = map.at(i);\n    }\n  }\n\n  function getBurnItems(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) external view returns (\n    uint8[] memory slots,\n    uint64[] memory chances,\n    bool[] memory stopIfBurned\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    bytes32[] memory answersBurn = _S().burnItem[answerPackedId];\n\n    slots = new uint8[](answersBurn.length);\n    chances = new uint64[](answersBurn.length);\n    stopIfBurned = new bool[](answersBurn.length);\n\n    for (uint i = 0; i < answersBurn.length; ++i) {\n      (slots[i], chances[i], stopIfBurned[i]) = PackingLib.unpackBreakInfo(answersBurn[i]);\n    }\n  }\n\n  function getAllStoryAnswers(uint16 storyId) external view returns (bytes32[] memory answers) {\n    return _getMapItems(_S().allStoryAnswers[storyId]);\n  }\n\n  function getAllStoryPages(uint16 storyId) external view returns (uint[] memory answers) {\n    return _getMapItems(_S().allStoryPages[storyId]);\n  }\n\n  function getAnswers(uint16 storyId, uint16 pageId, uint8 heroClass) external view returns (bytes32[] memory answers) {\n    bytes32 id = PackingLib.packStoryPageId(storyId, pageId, heroClass);\n    return _S().answers[id];\n  }\n\n  function getNextObjectsRewrite(uint16 storyId, uint16 pageId, uint8 heroClass) external view returns (uint32[] memory nextObjIds) {\n    bytes32 id = PackingLib.packStoryPageId(storyId, pageId, heroClass);\n    return _S().nextObjectsRewrite[id];\n  }\n\n  function getNextPageIds(bytes32 pagePackedId) external view returns (uint16[] memory) {\n    return _S().nextPageIds[pagePackedId];\n  }\n\n  function getAttributeRequirements(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) external view returns (\n    uint8[] memory attributeIndices,\n    int32[] memory values,\n    bool[] memory isCores\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    bytes32[] storage attrs = _S().attributeRequirements[answerPackedId];\n\n    attributeIndices = new uint8[](attrs.length);\n    values = new int32[](attrs.length);\n    isCores = new bool[](attrs.length);\n\n    for (uint i = 0; i < attrs.length; ++i) {\n      (attributeIndices[i], values[i], isCores[i]) = PackingLib.unpackStoryAttributeRequirement(attrs[i]);\n    }\n  }\n\n  function getAnswerItemRequirements(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) external view returns (\n    address[] memory items,\n    bool[] memory requireItemBurn,\n    bool[] memory requireItemEquipped\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    bytes32[] storage attrs = _S().itemRequirements[answerPackedId];\n\n    items = new address[](attrs.length);\n    requireItemBurn = new bool[](attrs.length);\n    requireItemEquipped = new bool[](attrs.length);\n\n    for (uint i = 0; i < attrs.length; ++i) {\n      (items[i], requireItemBurn[i], requireItemEquipped[i]) = PackingLib.unpackStoryItemRequirement(attrs[i]);\n    }\n  }\n\n  function getAnswerTokenRequirements(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) external view returns (\n    address[] memory tokens,\n    uint88[] memory amounts,\n    bool[] memory requireTransfers\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    bytes32[] storage attrs = _S().tokenRequirements[answerPackedId];\n\n    tokens = new address[](attrs.length);\n    amounts = new uint88[](attrs.length);\n    requireTransfers = new bool[](attrs.length);\n\n    for (uint i = 0; i < attrs.length; ++i) {\n      (tokens[i], amounts[i], requireTransfers[i]) = PackingLib.unpackStoryTokenRequirement(attrs[i]);\n    }\n  }\n\n  function getAnswerAttributes(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) external view returns (\n    uint32 randomRequirements,\n    uint32 delayRequirements,\n    bool isFinalAnswer\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    bytes32 data = _S().answerAttributes[answerPackedId];\n\n    (randomRequirements, delayRequirements, isFinalAnswer) = PackingLib.unpackStorySimpleRequirement(data);\n  }\n\n  function getHeroCustomDataRequirement(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, bool globalCustomData) external view returns (\n    bytes32[] memory indices,\n    bool[] memory mandatory,\n    uint64[] memory min,\n    uint64[] memory max\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    IStoryController.CustomDataRequirementPacked[] storage arr = globalCustomData\n      ? _S().globalCustomDataRequirement[answerPackedId]\n      : _S().heroCustomDataRequirement[answerPackedId];\n\n    indices = new bytes32[](arr.length);\n    mandatory = new bool[](arr.length);\n    max = new uint64[](arr.length);\n    min = new uint64[](arr.length);\n\n    for (uint i = 0; i < arr.length; ++i) {\n      indices[i] = arr[i].index;\n      (min[i], max[i], mandatory[i]) = PackingLib.unpackCustomDataRequirements(arr[i].data);\n    }\n  }\n\n  function getInfoAttributesAndItems(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, bool success) external view returns (\n    uint8[] memory attributeIds,\n    int32[] memory attributeValues,\n    address[] memory mintItems,\n    uint32[] memory mintItemsChances\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n\n    {\n      bytes32[] storage infoAttributes = success\n        ? _S().successInfoAttributes[answerPackedId]\n        : _S().failInfoAttributes[answerPackedId];\n      attributeIds = new uint8[](infoAttributes.length);\n      (attributeValues, attributeIds) = PackingLib.toInt32ArrayWithIds(infoAttributes);\n    }\n\n    {\n      bytes32[] storage infoMintItems = success\n        ? _S().successInfoMintItems[answerPackedId]\n        : _S().failInfoMintItems[answerPackedId];\n      uint len = infoMintItems.length;\n      mintItems = new address[](len);\n      mintItemsChances = new uint32[](len);\n      for (uint i = 0; i < len; ++i) {\n        (mintItems[i], mintItemsChances[i]) = PackingLib.unpackItemMintInfo(infoMintItems[i]);\n      }\n    }\n  }\n\n  function getInfoStats(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, bool success) external view returns (\n    uint32 experience,\n    int32 heal,\n    int32 manaRegen,\n    int32 lifeChancesRecovered,\n    int32 damage,\n    int32 manaConsumed\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    (experience, heal, manaRegen, lifeChancesRecovered, damage, manaConsumed) = PackingLib.unpackStatsChange(\n      success\n        ? _S().successInfoStats[answerPackedId]\n        : _S().failInfoStats[answerPackedId]\n    );\n  }\n\n  function getCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 type_) external view returns (\n    bytes32[] memory dataIndices,\n    int16[] memory dataValues\n  ) {\n    bytes32 answerPackedIdWithType = PackingLib.packStoryCustomDataResult(storyId, pageId, heroClass, answerId, type_);\n    bytes32[] storage arr = _S().customDataResult[answerPackedIdWithType];\n\n    dataIndices = new bytes32[](arr.length);\n    dataValues = new int16[](arr.length);\n\n    for (uint i; i < arr.length; ++i) {\n      (dataIndices[i], dataValues[i]) = PackingLib.unpackCustomDataChange(arr[i]);\n    }\n  }\n\n  function getStoryRequiredHeroData(uint16 storyId) external view returns (\n    bytes32[] memory indices,\n    bool[] memory mandatory,\n    uint64[] memory min,\n    uint64[] memory max,\n    uint storyRequiredLevel\n  ) {\n    IStoryController.CustomDataRequirementRangePacked[] storage arr = _S().storyRequiredHeroData[storyId];\n\n    indices = new bytes32[](arr.length);\n    mandatory = new bool[](arr.length);\n    max = new uint64[](arr.length);\n    min = new uint64[](arr.length);\n\n    for (uint i = 0; i < arr.length; ++i) {\n      indices[i] = arr[i].index;\n      (min[i], max[i], mandatory[i]) = PackingLib.unpackCustomDataRequirements(arr[i].data);\n    }\n\n    storyRequiredLevel = _S().storyRequiredLevel[storyId];\n  }\n\n  function getStoryRegistrationInfo(uint16 storyId, uint32 objectId) external view returns (\n    uint32 idToStory,\n    uint16 storyIds\n  ) {\n    idToStory = _S().idToStory[storyId]; // object id\n    storyIds = _S().storyIds[objectId]; // story id by object id\n  }\n\n  function setStoryRegistrationInfo(uint32 objectId, uint16 storyIds, bool registered) external {\n    _S().storyIds[objectId] = storyIds;\n    _S().registeredStories[objectId] = registered;\n  }\n\n  //endregion ------------------------ For tests\n\n}"
    },
    "contracts/test/facades/FacadeStorySetupBaseLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IStoryController.sol\";\nimport \"../../interfaces/IGOC.sol\";\nimport \"../../interfaces/IOracle.sol\";\nimport \"../../interfaces/IAppErrors.sol\";\nimport \"../../lib/StorySetupLib.sol\";\nimport \"../../lib/StoryControllerLib.sol\";\nimport \"../../lib/PackingLib.sol\";\n\nlibrary FacadeStorySetupBaseLib {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  function getStoryData(IStoryController.MainState storage s, uint16 storyId) external view returns (\n    bytes32[] memory answers,\n    uint[] memory pages\n  ) {\n    return (getAllStoryAnswers(s, storyId), getAllStoryPages(s, storyId));\n  }\n\n  //region ------------------------ For tests\n  function _getMapItems(EnumerableSet.Bytes32Set storage map) internal view returns (bytes32[] memory values) {\n    values = new bytes32[](map.length());\n\n    for (uint i = 0; i < map.length(); ++i) {\n      values[i] = map.at(i);\n    }\n  }\n\n  function _getMapItems(EnumerableSet.UintSet storage map) internal view returns (uint[] memory values) {\n    values = new uint[](map.length());\n\n    for (uint i = 0; i < map.length(); ++i) {\n      values[i] = map.at(i);\n    }\n  }\n\n  function getBurnItems(IStoryController.MainState storage s, uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) external view returns (\n    uint8[] memory slots,\n    uint64[] memory chances,\n    bool[] memory stopIfBurned\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    bytes32[] memory answersBurn = s.burnItem[answerPackedId];\n\n    slots = new uint8[](answersBurn.length);\n    chances = new uint64[](answersBurn.length);\n    stopIfBurned = new bool[](answersBurn.length);\n\n    for (uint i = 0; i < answersBurn.length; ++i) {\n      (slots[i], chances[i], stopIfBurned[i]) = PackingLib.unpackBreakInfo(answersBurn[i]);\n    }\n  }\n\n  function getAllStoryAnswers(IStoryController.MainState storage s, uint16 storyId) internal view returns (bytes32[] memory answers) {\n    return _getMapItems(s.allStoryAnswers[storyId]);\n  }\n\n  function getAllStoryPages(IStoryController.MainState storage s, uint16 storyId) internal view returns (uint[] memory pages) {\n    return _getMapItems(s.allStoryPages[storyId]);\n  }\n\n  function getAnswers(IStoryController.MainState storage s, uint16 storyId, uint16 pageId, uint8 heroClass) internal view returns (bytes32[] memory answers) {\n    bytes32 id = PackingLib.packStoryPageId(storyId, pageId, heroClass);\n    return s.answers[id];\n  }\n\n  function getNextObjectsRewrite(IStoryController.MainState storage s, uint16 storyId, uint16 pageId, uint8 heroClass) internal view returns (uint32[] memory nextObjIds) {\n    bytes32 id = PackingLib.packStoryPageId(storyId, pageId, heroClass);\n    return s.nextObjectsRewrite[id];\n  }\n\n  function getNextPageIds(IStoryController.MainState storage s, bytes32 pagePackedId) internal view returns (uint16[] memory) {\n    return s.nextPageIds[pagePackedId];\n  }\n\n  function getAttributeRequirements(IStoryController.MainState storage s, uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) external view returns (\n    uint8[] memory attributeIndices,\n    int32[] memory values,\n    bool[] memory isCores\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    bytes32[] storage attrs = s.attributeRequirements[answerPackedId];\n\n    attributeIndices = new uint8[](attrs.length);\n    values = new int32[](attrs.length);\n    isCores = new bool[](attrs.length);\n\n    for (uint i = 0; i < attrs.length; ++i) {\n      (attributeIndices[i], values[i], isCores[i]) = PackingLib.unpackStoryAttributeRequirement(attrs[i]);\n    }\n  }\n\n  function getAnswerItemRequirements(IStoryController.MainState storage s, uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) external view returns (\n    address[] memory items,\n    bool[] memory requireItemBurn,\n    bool[] memory requireItemEquipped\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    bytes32[] storage attrs = s.itemRequirements[answerPackedId];\n\n    items = new address[](attrs.length);\n    requireItemBurn = new bool[](attrs.length);\n    requireItemEquipped = new bool[](attrs.length);\n\n    for (uint i = 0; i < attrs.length; ++i) {\n      (items[i], requireItemBurn[i], requireItemEquipped[i]) = PackingLib.unpackStoryItemRequirement(attrs[i]);\n    }\n  }\n\n  function getAnswerTokenRequirements(IStoryController.MainState storage s, uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) external view returns (\n    address[] memory tokens,\n    uint88[] memory amounts,\n    bool[] memory requireTransfers\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    bytes32[] storage attrs = s.tokenRequirements[answerPackedId];\n\n    tokens = new address[](attrs.length);\n    amounts = new uint88[](attrs.length);\n    requireTransfers = new bool[](attrs.length);\n\n    for (uint i = 0; i < attrs.length; ++i) {\n      (tokens[i], amounts[i], requireTransfers[i]) = PackingLib.unpackStoryTokenRequirement(attrs[i]);\n    }\n  }\n\n  function getAnswerAttributes(IStoryController.MainState storage s, uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) external view returns (\n    uint32 randomRequirements,\n    uint32 delayRequirements,\n    bool isFinalAnswer\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    bytes32 data = s.answerAttributes[answerPackedId];\n\n    (randomRequirements, delayRequirements, isFinalAnswer) = PackingLib.unpackStorySimpleRequirement(data);\n  }\n\n  function getHeroCustomDataRequirement(IStoryController.MainState storage s, uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, bool globalCustomData) external view returns (\n    bytes32[] memory indices,\n    bool[] memory mandatory,\n    uint64[] memory min,\n    uint64[] memory max\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    IStoryController.CustomDataRequirementPacked[] storage arr = globalCustomData\n      ? s.globalCustomDataRequirement[answerPackedId]\n      : s.heroCustomDataRequirement[answerPackedId];\n\n    indices = new bytes32[](arr.length);\n    mandatory = new bool[](arr.length);\n    max = new uint64[](arr.length);\n    min = new uint64[](arr.length);\n\n    for (uint i = 0; i < arr.length; ++i) {\n      indices[i] = arr[i].index;\n      (min[i], max[i], mandatory[i]) = PackingLib.unpackCustomDataRequirements(arr[i].data);\n    }\n  }\n\n  function getInfoAttributesAndItems(IStoryController.MainState storage s, uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, bool success) external view returns (\n    uint8[] memory attributeIds,\n    int32[] memory attributeValues,\n    address[] memory mintItems,\n    uint32[] memory mintItemsChances\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n\n    {\n      bytes32[] storage infoAttributes = success\n        ? s.successInfoAttributes[answerPackedId]\n        : s.failInfoAttributes[answerPackedId];\n      attributeIds = new uint8[](infoAttributes.length);\n      (attributeValues, attributeIds) = PackingLib.toInt32ArrayWithIds(infoAttributes);\n    }\n\n    {\n      bytes32[] storage infoMintItems = success\n        ? s.successInfoMintItems[answerPackedId]\n        : s.failInfoMintItems[answerPackedId];\n      uint len = infoMintItems.length;\n      mintItems = new address[](len);\n      mintItemsChances = new uint32[](len);\n      for (uint i = 0; i < len; ++i) {\n        (mintItems[i], mintItemsChances[i]) = PackingLib.unpackItemMintInfo(infoMintItems[i]);\n      }\n    }\n  }\n\n  function getInfoStats(IStoryController.MainState storage s, uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, bool success) external view returns (\n    uint32 experience,\n    int32 heal,\n    int32 manaRegen,\n    int32 lifeChancesRecovered,\n    int32 damage,\n    int32 manaConsumed\n  ) {\n    bytes32 answerPackedId = PackingLib.packStoryAnswerId(storyId, pageId, heroClass, answerId);\n    (experience, heal, manaRegen, lifeChancesRecovered, damage, manaConsumed) = PackingLib.unpackStatsChange(\n      success\n        ? s.successInfoStats[answerPackedId]\n        : s.failInfoStats[answerPackedId]\n    );\n  }\n\n  function getCustomDataResult(IStoryController.MainState storage s, uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 type_) external view returns (\n    bytes32[] memory dataIndices,\n    int16[] memory dataValues\n  ) {\n    bytes32 answerPackedIdWithType = PackingLib.packStoryCustomDataResult(storyId, pageId, heroClass, answerId, type_);\n    bytes32[] storage arr = s.customDataResult[answerPackedIdWithType];\n\n    dataIndices = new bytes32[](arr.length);\n    dataValues = new int16[](arr.length);\n\n    for (uint i; i < arr.length; ++i) {\n      (dataIndices[i], dataValues[i]) = PackingLib.unpackCustomDataChange(arr[i]);\n    }\n  }\n\n  function getStoryRequiredHeroData(IStoryController.MainState storage s, uint16 storyId) external view returns (\n    bytes32[] memory indices,\n    bool[] memory mandatory,\n    uint64[] memory min,\n    uint64[] memory max,\n    uint storyRequiredLevel\n  ) {\n    IStoryController.CustomDataRequirementRangePacked[] storage arr = s.storyRequiredHeroData[storyId];\n\n    indices = new bytes32[](arr.length);\n    mandatory = new bool[](arr.length);\n    max = new uint64[](arr.length);\n    min = new uint64[](arr.length);\n\n    for (uint i = 0; i < arr.length; ++i) {\n      indices[i] = arr[i].index;\n      (min[i], max[i], mandatory[i]) = PackingLib.unpackCustomDataRequirements(arr[i].data);\n    }\n\n    storyRequiredLevel = s.storyRequiredLevel[storyId];\n  }\n\n  function getStoryRegistrationInfo(IStoryController.MainState storage s, uint16 storyId, uint32 objectId) internal view returns (\n    uint32 idToStory,\n    uint16 storyIds\n  ) {\n    idToStory = s.idToStory[storyId]; // object id\n    storyIds = s.storyIds[objectId]; // story id by object id\n  }\n\n  function setStoryRegistrationInfo(IStoryController.MainState storage s, uint32 objectId, uint16 storyIds, bool registered) internal {\n    s.storyIds[objectId] = storyIds;\n    s.registeredStories[objectId] = registered;\n  }\n\n  //endregion ------------------------ For tests\n\n}"
    },
    "contracts/test/facades/FacadeStorySetupLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IStoryController.sol\";\nimport \"../../interfaces/IGOC.sol\";\nimport \"../../interfaces/IAppErrors.sol\";\nimport \"../../lib/StorySetupLib.sol\";\nimport \"../../lib/StoryControllerLib.sol\";\nimport \"../../lib/PackingLib.sol\";\nimport \"hardhat/console.sol\";\nimport \"./FacadeStorySetupBase.sol\";\n\ncontract FacadeStorySetupLib is IAppErrors, FacadeStorySetupBase {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  //region ------------------ For tests\n  function storyBuildHash(uint16 storyId) external view returns(uint) {\n    return StoryControllerLib.storyBuildHash(storyId);\n  }\n  //region ------------------ For tests\n\n\n  //region ------------------ Set story fields\n  function setAllStoryFields(IStoryController.StoryMetaInfo calldata meta) external {\n    StorySetupLib.setAllStoryFields(_S(), meta);\n  }\n\n  function setBurnItemsMeta(uint16 storyId, IStoryController.AnswerBurnRandomItemMeta calldata meta) external {\n    StorySetupLib.setBurnItemsMeta(_S(), storyId, meta);\n  }\n\n  function setNextObjRewriteMeta(uint16 storyId, IStoryController.NextObjRewriteMeta calldata meta) external {\n    StorySetupLib.setNextObjRewriteMeta(_S(), storyId, meta);\n  }\n\n  function setAnswersMeta(\n    uint16 storyId,\n    uint16[] calldata answerPageIds,\n    uint8[] calldata answerHeroClasses,\n    uint16[] calldata answerIds\n  ) external {\n    StorySetupLib.setAnswersMeta(_S(), storyId, answerPageIds, answerHeroClasses, answerIds);\n  }\n\n  function setAnswerNextPageMeta(uint16 storyId, IStoryController.AnswerNextPageMeta calldata meta) external {\n    StorySetupLib.setAnswerNextPageMeta(_S(), storyId, meta);\n  }\n\n  function setAnswerAttributeRequirements(uint16 storyId, IStoryController.AnswerAttributeRequirementsMeta calldata meta) external {\n    StorySetupLib.setAnswerAttributeRequirements(_S(), storyId, meta);\n  }\n\n  function setAnswerItemRequirements(uint16 storyId, IStoryController.AnswerItemRequirementsMeta calldata meta) external {\n    StorySetupLib.setAnswerItemRequirements(_S(), storyId, meta);\n  }\n\n  function setAnswerTokenRequirementsMeta(uint16 storyId, IStoryController.AnswerTokenRequirementsMeta calldata meta) external {\n    StorySetupLib.setAnswerTokenRequirementsMeta(_S(), storyId, meta);\n  }\n\n  function setAnswerAttributes(uint16 storyId, IStoryController.AnswerAttributesMeta calldata meta) external {\n    StorySetupLib.setAnswerAttributes(_S(), storyId, meta);\n  }\n\n  function setAnswerHeroCustomDataRequirementMeta(uint16 storyId, IStoryController.AnswerCustomDataMeta calldata meta) external {\n    StorySetupLib.setAnswerHeroCustomDataRequirementMeta(_S(), storyId, meta);\n  }\n\n  function setAnswerGlobalCustomDataRequirementMeta(uint16 storyId, IStoryController.AnswerCustomDataMeta calldata meta) external {\n    StorySetupLib.setAnswerGlobalCustomDataRequirementMeta(_S(), storyId, meta);\n  }\n\n  function setSuccessInfo(uint16 storyId, IStoryController.AnswerResultMeta calldata meta) external {\n    StorySetupLib.setSuccessInfo(_S(), storyId, meta);\n  }\n\n  function setFailInfo(uint16 storyId, IStoryController.AnswerResultMeta calldata meta) external {\n    StorySetupLib.setFailInfo(_S(), storyId, meta);\n  }\n\n  function setCustomDataResult(\n    uint16 storyId,\n    IStoryController.AnswerCustomDataResultMeta calldata meta,\n    IStoryController.CustomDataResult type_\n  ) external {\n    StorySetupLib.setCustomDataResult(_S(), storyId, meta, type_);\n  }\n\n  function setStoryCustomDataRequirements(\n    uint16 storyId,\n    bytes32[] calldata requiredCustomDataIndex,\n    uint64[] calldata requiredCustomDataMinValue,\n    uint64[] calldata requiredCustomDataMaxValue,\n    bool[] calldata requiredCustomDataIsHero,\n    uint minLevel\n  ) external {\n    StorySetupLib.setStoryCustomDataRequirements(_S(), storyId, requiredCustomDataIndex, requiredCustomDataMinValue, requiredCustomDataMaxValue, requiredCustomDataIsHero, minLevel);\n  }\n\n  function finalizeStoryRegistration(uint16 storyId, uint32 objectId, uint buildHash) external {\n    StorySetupLib.finalizeStoryRegistration(_S(), storyId, objectId, buildHash);\n  }\n  //endregion ------------------ Set story fields\n\n  //region ------------------ Remove logic\n  function removeStory(uint32 objectId) external {\n    StorySetupLib.removeStory(_S(), objectId);\n  }\n\n  function removeStoryPagesMeta(uint16 storyId, uint maxIterations) external {\n    StorySetupLib.removeStoryPagesMeta(_S(), storyId, maxIterations);\n  }\n\n  function removeStoryAnswersMeta(uint16 storyId, uint maxIterations) external {\n    StorySetupLib.removeStoryAnswersMeta(_S(), storyId, maxIterations);\n  }\n  //endregion ------------------ Remove logic\n\n  //region ------------------ Utils\n  function registerAnswer(uint16 storyId, bytes32 answerId) external {\n    StorySetupLib.registerAnswer(_S(), storyId, answerId);\n  }\n\n  function registerPage(uint16 storyId, uint16 pageId) external {\n    StorySetupLib.registerPage(_S(), storyId, pageId);\n  }\n  //endregion ------------------ Utils\n\n}\n"
    },
    "contracts/test/facades/FacadeStringLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/StringLib.sol\";\n\ncontract FacadeStringLib {\n  function testToString(uint value) external pure returns (string memory) {\n    return StringLib.toString(value);\n  }\n\n  function toAsciiString(address x) external pure returns (string memory) {\n    return StringLib.toAsciiString(x);\n  }\n\n  function char(bytes1 b) external pure returns (bytes1 c) {\n    return StringLib.char(b);\n  }\n\n  function concat(string memory a, string memory b) external pure returns (string memory) {\n    return StringLib.concat(a, b);\n  }\n\n  function getBytes1(uint8 value) external pure returns (bytes1) {\n    return bytes1(value);\n  }\n}"
    },
    "contracts/test/facades/FacadeUserControllerLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/UserControllerLib.sol\";\nimport \"../../core/UserController.sol\";\n\ncontract FacadeUserControllerLib is UserController {\n//  IController internal _controller;\n  mapping(uint => uint) private _pseudoRandomValue;\n  bool private _useRealPseudoRandom;\n  bool private _useRealPrng;\n  bool private _useRealMintRandomItems;\n  address[] private _mintRandomItemsTestResults;\n  ItemLib.MintItemInfo private _infoPassedToMintRandomItems;\n\n//  //region ------------------------ IControllable (all contracts allow to receive controller through this)\n//  function controller() external view returns (address) {\n//    return address(_controller);\n//  }\n//  function setController(address controller_) external {\n//    _controller = IController(controller_);\n//  }\n//  //endregion ------------------------ IControllable (all contracts allow to receive controller through this)\n\n  //region ------------------------ For test purposes\n  function setPseudoRandomForTests(uint max, uint value) external {\n    _pseudoRandomValue[max] = value;\n  }\n\n  function _pseudoNextPrng(LibPRNG.PRNG memory prng, uint max) internal view returns (uint) {\n    if (_useRealPrng) {\n      return LibPRNG.next(prng);\n    } else {\n      return _pseudoRandomValue[max];\n    }\n  }\n\n  function _setUserAccountName(address user, string memory name) external {\n    UserControllerLib._S().userAccountName[user] = name;\n    UserControllerLib._S().nameToUserAccount[name] = user;\n  }\n\n  function _setCounterLootBoxes(address user, IUserController.EarnedLootBoxes memory data) external {\n    UserControllerLib._S().counterLootBoxes[user] = data;\n  }\n\n  function getUserControllerStorageLocation() external pure returns(bytes32) {\n    return keccak256(abi.encode(uint256(keccak256(\"user.controller.main\")) - 1)) & ~bytes32(uint256(0xff));\n  }\n\n  function setUpMintRandomItems(bool useReal, address[] memory testResults) external {\n    _useRealMintRandomItems = useReal;\n    _mintRandomItemsTestResults = testResults;\n  }\n\n  function getInfoPassedToMintRandomItems() external view returns (ItemLib.MintItemInfo memory) {\n    return _infoPassedToMintRandomItems;\n  }\n\n  function testMintRandomItems(\n    ItemLib.MintItemInfo memory info,\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\n  ) internal returns (address[] memory) {\n    if (_useRealMintRandomItems) {\n      return ItemLib._mintRandomItems(info, nextPrng_);\n    } else {\n      _infoPassedToMintRandomItems = info;\n      return _mintRandomItemsTestResults;\n    }\n  }\n  //endregion ------------------------ For test purposes\n\n  //region ------------------------ ACTIONS\n  function __setUserName(bool isEoa, address _msgSender, string memory name) external {\n    UserControllerLib.setUserName(isEoa, IController(controller()), _msgSender, name);\n  }\n\n  function __openLootBox(address _msgSender, uint lootBoxKind) external {\n    UserControllerLib.openLootBox(\n      IController(controller()),\n      _msgSender,\n      IUserController.LootBoxKind(lootBoxKind),\n      _pseudoNextPrng,\n      testMintRandomItems // set _mintRandomItemsTestResults = true to use real _mintRandomItems\n    );\n  }\n\n  function __setLootBoxConfig(uint lootBoxKind, address _msgSender, IUserController.LootBoxConfig memory config) external {\n    UserControllerLib.setLootBoxConfig(IController(controller()), _msgSender, lootBoxKind, config);\n  }\n\n  function __setFeeRenaming(address _msgSender, uint fee) external {\n    UserControllerLib.setFeeRenaming(IController(controller()), _msgSender, fee);\n  }\n  //endregion ------------------------ ACTIONS\n\n  //region ------------------------ IUserController\n  function __registerPassedDungeon(\n    address _msgSender,\n    address user,\n    uint blockTimestamp,\n    uint dailyActivityThreshold,\n    uint weeklyActivityThreshold\n  ) external {\n    UserControllerLib.registerPassedDungeon(\n      IController(controller()),\n      _msgSender,\n      user,\n      blockTimestamp,\n      dailyActivityThreshold,\n      weeklyActivityThreshold\n    );\n  }\n\n  function __registerPvP(address _msgSender, address user, bool isWinner) external {\n    UserControllerLib.registerPvP(IController(controller()), _msgSender, user, isWinner);\n  }\n\n  function getEpochWeek(uint epochDay) external pure returns (uint) {\n    return UserControllerLib.getEpochWeek(epochDay);\n  }\n  //endregion ------------------------ IUserController\n}\n"
    },
    "contracts/test/Faucet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../relay/ERC2771Context.sol\";\n\ncontract Faucet is ERC2771Context{\n\n  uint public constant BASE_ETH_VALUE = 1e18;\n  uint public constant TARGET_ETH_BALANCE = 1000e18;\n\n  address public immutable token;\n\n  constructor(address token_) {\n    token = token_;\n  }\n\n  function getToken() external payable {\n    require(msg.value != 0, 'zero value');\n\n    address _token = token;\n    uint ethBalance = address(this).balance;\n    if (ethBalance == 0) {\n      ethBalance = 1;\n    }\n    uint tokenBalance = IERC20(_token).balanceOf(address(this));\n    if (tokenBalance == 0) {\n      tokenBalance = 1;\n    }\n\n    uint out = getAmountOut(msg.value, ethBalance - msg.value, tokenBalance);\n    require(out != 0, '!out');\n    require(tokenBalance >= out, '!balance');\n    IERC20(_token).transfer(_msgSender(), out);\n  }\n\n  function refuel(uint amount) external {\n    address _token = token;\n    uint ethBalance = address(this).balance;\n    if (ethBalance == 0) {\n      ethBalance = 1;\n    }\n    uint tokenBalance = IERC20(_token).balanceOf(address(this));\n    if (tokenBalance == 0) {\n      tokenBalance = 1;\n    }\n\n    uint out = getAmountOut(amount, tokenBalance, ethBalance);\n\n    require(out != 0, '!out');\n    require(ethBalance >= out, '!balance');\n\n    IERC20(_token).transferFrom(_msgSender(), address(this), amount);\n\n    payable(_msgSender()).transfer(out);\n  }\n\n  function priceTokenToEth(uint ethersIn) public view returns (uint) {\n    uint ethBalance = address(this).balance;\n    if (ethBalance == 0) {\n      ethBalance = 1;\n    }\n    uint tokenBalance = IERC20(token).balanceOf(address(this));\n    if (tokenBalance == 0) {\n      tokenBalance = 1;\n    }\n    return getAmountOut(ethersIn, ethBalance, tokenBalance);\n  }\n\n  function priceEthToToken(uint tokenIn) public view returns (uint) {\n    uint ethBalance = address(this).balance;\n    if (ethBalance == 0) {\n      ethBalance = 1;\n    }\n    uint tokenBalance = IERC20(token).balanceOf(address(this));\n    if (tokenBalance == 0) {\n      tokenBalance = 1;\n    }\n    return getAmountOut(tokenIn, tokenBalance, ethBalance);\n  }\n\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure returns (uint amountOut) {\n    require(amountIn > 0, 'INSUFFICIENT_INPUT_AMOUNT');\n    require(reserveIn > 0 && reserveOut > 0, 'INSUFFICIENT_LIQUIDITY');\n    amountOut = (amountIn * reserveOut) / (reserveIn + amountIn);\n  }\n\n  receive() external payable {}\n\n}\n"
    },
    "contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/ERC20.sol\";\n\n\ncontract MockERC20 is ERC20 {\n\n  address public immutable owner;\n\n  constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_){\n    owner = msg.sender;\n  }\n\n  function mint(address to, uint amount) external {\n    require(msg.sender == owner, '!owner');\n    _mint(to, amount);\n  }\n\n  function burn(uint amount) external returns (bool) {\n    require(balanceOf(msg.sender) >= amount, '!balance');\n    _burn(msg.sender, amount);\n    return true;\n  }\n\n}\n"
    },
    "contracts/test/MockERC721.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/ERC721Upgradeable.sol\";\nimport {ERC721EnumerableUpgradeable} from \"../openzeppelin/ERC721EnumerableUpgradeable.sol\";\n\n\ncontract MockERC721 is ERC721EnumerableUpgradeable {\n  uint internal _counter;\n  address public immutable owner;\n\n  constructor(string memory name_, string memory symbol_) initializer {\n    __ERC721_init(name_, symbol_);\n    owner = msg.sender;\n    _counter = 4000;\n  }\n\n  function mint(address receiver) public returns (uint256) {\n    uint counter = _counter;\n    _counter++;\n\n    _mint(receiver, counter);\n    _update(receiver, counter, address(0));\n    return counter;\n  }\n}\n"
    },
    "contracts/test/mocks/DungeonFactoryMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/PackingLib.sol\";\n\ncontract DungeonFactoryMock {\n  mapping(bytes32 => uint64) internal _currentDungeon;\n  mapping(bytes32 => uint8) internal _maxBiomeCompleted;\n  mapping(uint => bool) internal _setBossCompleted;\n  mapping(uint => uint8[]) internal _skillSlotsForDurabilityReductionData;\n\n  function setCurrentDungeon(address heroToken, uint heroTokenId, uint64 currentDungeon_) external {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    _currentDungeon[key] = currentDungeon_;\n  }\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64) {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    return _currentDungeon[key];\n  }\n\n  function setMaxBiomeCompleted(address heroToken, uint heroTokenId, uint8 value) external {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    _maxBiomeCompleted[key] = value;\n  }\n\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8) {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    return _maxBiomeCompleted[key];\n  }\n\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external {\n    uint key = uint(keccak256(abi.encodePacked(objectId, heroToken, heroTokenId, heroBiome)));\n    _setBossCompleted[key] = true;\n  }\n\n  function isSetBossCompletedCalled(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome)\n  external view returns (bool) {\n    uint key = uint(keccak256(abi.encodePacked(objectId, heroToken, heroTokenId, heroBiome)));\n    return _setBossCompleted[key];\n  }\n\n  function setSkillSlotsForDurabilityReduction(address heroToken, uint heroTokenId, uint8[] memory skillSlots) external {\n    uint key = uint(keccak256(abi.encodePacked(heroToken, heroTokenId)));\n    _skillSlotsForDurabilityReductionData[key] = skillSlots;\n  }\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (\n    uint8[] memory result\n  ) {\n    uint key = uint(keccak256(abi.encodePacked(heroToken, heroTokenId)));\n    return _skillSlotsForDurabilityReductionData[key];\n  }\n}"
    },
    "contracts/test/mocks/ERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\ncontract ERC721Mock {\n  mapping(uint256 => address) internal _owners;\n  function setOnwerOf(uint256 tokenId, address owner_) external {\n    _owners[tokenId] = owner_;\n  }\n  function ownerOf(uint256 tokenId) external view returns (address owner) {\n    return _owners[tokenId];\n  }\n}"
    },
    "contracts/test/mocks/GameTokenMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../openzeppelin/ERC20.sol\";\n\ncontract GameTokenMock is ERC20 {\n  address public minter;\n  address public owner;\n  uint public burnedAmount;\n  uint public mintedAmount;\n\n  constructor() ERC20(\"SACRA token\", \"SACRA\"){\n    owner = msg.sender;\n  }\n\n  function mint(address to, uint amount) external {\n    // require(msg.sender == owner, '!owner');\n    _mint(to, amount);\n    mintedAmount += amount;\n  }\n\n  function burn(uint amount) external returns (bool) {\n    require(balanceOf(msg.sender) >= amount, '!balance');\n    _burn(msg.sender, amount);\n    burnedAmount += amount;\n    return true;\n  }\n\n  function setMinter(address minter_) external {\n    minter = minter_;\n  }\n}\n"
    },
    "contracts/test/mocks/GOCMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IGOC.sol\";\n\ncontract GOCMock {\n\n  mapping(uint => IGOC.ActionResult) internal _actionResults;\n  mapping(uint => uint32) internal _getRandomObjects;\n  mapping(uint => bool) internal _battleObjects;\n  mapping(uint => bool) internal _openCalled;\n\n  function setAction(\n    address sender,\n    uint64 dungeonId,\n    uint32 objectId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 stageId,\n    bytes memory data,\n    IGOC.ActionResult memory results\n  ) external {\n    uint key = uint(keccak256(abi.encodePacked(\n      sender, dungeonId, objectId, heroToken, heroTokenId, stageId, data\n    )));\n    _actionResults[key] = results;\n  }\n\n  function action(\n    address sender,\n    uint64 dungeonId,\n    uint32 objectId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 stageId,\n    bytes memory data\n  ) external view returns (IGOC.ActionResult memory) {\n    uint key = uint(keccak256(abi.encodePacked(\n      sender, dungeonId, objectId, heroToken, heroTokenId, stageId, data\n    )));\n    return _actionResults[key];\n  }\n\n  function setIsBattleObject(uint32 objectId) external {\n    _battleObjects[objectId] = true;\n  }\n\n  function isBattleObject(uint32 objectId) external view returns (bool) {\n    return _battleObjects[objectId];\n  }\n\n  function getRandomObject(\n    uint8[] memory cTypes,\n    uint32[] memory chances,\n    uint8 biomeLevel,\n    address heroToken,\n    uint heroTokenId\n  ) external view returns (uint32 objectId) {\n    uint key = uint(keccak256(abi.encodePacked(\n      cTypes, chances, biomeLevel, heroToken, heroTokenId\n    )));\n    return _getRandomObjects[key];\n  }\n\n  function setGetRandomObject(\n    uint8[] memory cTypes,\n    uint32[] memory chances,\n    uint8 biomeLevel,\n    address heroToken,\n    uint heroTokenId,\n    uint32 objectId\n  ) external {\n    uint key = uint(keccak256(abi.encodePacked(\n      cTypes, chances, biomeLevel, heroToken, heroTokenId\n    )));\n    _getRandomObjects[key] = objectId;\n  }\n\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint) {\n    uint key = uint(keccak256(abi.encodePacked(heroToken, heroTokenId, objectId)));\n    _openCalled[key] = true;\n    return 0;\n  }\n\n  function isOpenCalled(address heroToken, uint heroTokenId, uint32 objectId) external view returns (bool) {\n    uint key = uint(keccak256(abi.encodePacked(heroToken, heroTokenId, objectId)));\n    return _openCalled[key];\n  }\n}\n"
    },
    "contracts/test/mocks/HeroControllerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\nimport \"../../lib/PackingLib.sol\";\n\n\ncontract HeroControllerMock {\n  struct KillData {\n    bytes32[] dropItems;\n    uint dropTokenAmount;\n    address dropToken;\n  }\n\n  mapping(address => uint8) private _heroClasses;\n  mapping(bytes32 => KillData) private _kills;\n  mapping(address => address) private _payTokens;\n  mapping(bytes32 => uint8) private _heroBioms;\n  mapping(bytes32 => bytes32) private _HeroReinforcementHelps;\n  mapping(bytes32 => bool) private _releaseReinforcementCalled;\n  mapping(bytes32 => bool) private _killIsCalled;\n  mapping(bytes32 => uint) private _scores;\n  mapping(uint => bool) internal _allowedToTransfer;\n  address private _heroTokensVault;\n  mapping(bytes32 => uint) private _create;\n\n  function setHeroClass(address hero, uint8 heroClass_) external {\n    _heroClasses[hero] = heroClass_;\n  }\n\n  function heroClass(address hero) external view returns (uint8) {\n    return _heroClasses[hero];\n  }\n\n  function setKill(address hero, uint heroId, bytes32[] memory dropItems, uint dropTokenAmount, address dropToken) external {\n    bytes32 key = PackingLib.packNftId(hero, heroId);\n    _kills[key] = KillData({dropItems: dropItems, dropTokenAmount: dropTokenAmount, dropToken: dropToken});\n  }\n\n  function isKillCalled(address hero, uint heroId) external view returns (bool) {\n    bytes32 key = PackingLib.packNftId(hero, heroId);\n    return _killIsCalled[key];\n  }\n\n  function kill(address hero, uint heroId) external returns (\n    bytes32[] memory dropItems,\n    uint dropTokenAmount,\n    address dropToken\n  ) {\n    bytes32 key = PackingLib.packNftId(hero, heroId);\n    _killIsCalled[key] = true;\n    return (_kills[key].dropItems, _kills[key].dropTokenAmount, _kills[key].dropToken);\n  }\n\n  function setPayToken(address payToken, address heroToken) external {\n    _payTokens[heroToken] = payToken;\n  }\n\n  function payTokenInfo(address heroToken) external view returns (address, uint) {\n    return (_payTokens[heroToken], 0);\n  }\n\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId) {\n    _releaseReinforcementCalled[PackingLib.packNftId(hero, heroId)] = true;\n    return (helperToken, helperId);\n  }\n  function isReleaseReinforcementCalled(address hero, uint heroId) external view returns (bool) {\n    return _releaseReinforcementCalled[PackingLib.packNftId(hero, heroId)];\n  }\n\n  function setHeroBiome(address hero, uint heroId, uint8 biome) external {\n    bytes32 key = PackingLib.packNftId(hero, heroId);\n    _heroBioms[key] = biome;\n  }\n\n  function heroBiome(address hero, uint heroId) external view returns (uint8) {\n    bytes32 key = PackingLib.packNftId(hero, heroId);\n    return _heroBioms[key];\n  }\n\n  function setHeroReinforcementHelp(address hero, uint heroId, address helperHeroToken, uint helperHeroId) external {\n    bytes32 key = PackingLib.packNftId(hero, heroId);\n    bytes32 value = PackingLib.packNftId(helperHeroToken, helperHeroId);\n    _HeroReinforcementHelps[key] = value;\n  }\n\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (\n    address helperHeroToken,\n    uint helperHeroId\n  ) {\n    bytes32 key = PackingLib.packNftId(hero, heroId);\n    bytes32 value = _HeroReinforcementHelps[key];\n    return PackingLib.unpackNftId(value);\n  }\n\n  function score(address hero, uint heroId) external view returns (uint) {\n    bytes32 key = PackingLib.packNftId(hero, heroId);\n    return _scores[key];\n  }\n\n  function setScore(address hero, uint heroId, uint score_) external {\n    bytes32 key = PackingLib.packNftId(hero, heroId);\n    _scores[key] = score_;\n  }\n\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool) {\n    uint key = uint(keccak256(abi.encodePacked(hero, heroId)));\n    return _allowedToTransfer[key];\n  }\n\n  function setAllowedToTransfer(address hero, uint heroId) external {\n    uint key = uint(keccak256(abi.encodePacked(hero, heroId)));\n    _allowedToTransfer[key] = true;\n  }\n\n  function setHeroTokensVault(address heroTokensVault_) external {\n    _heroTokensVault = heroTokensVault_;\n  }\n  function heroTokensVault() external view returns (address) {\n    return _heroTokensVault;\n  }\n\n  function setCreate(address hero, string memory heroName, bool enter, uint tokenId) external {\n    bytes32 key = keccak256(abi.encodePacked(hero, heroName, enter));\n    _create[key] = tokenId;\n  }\n\n  function create(address hero, string memory heroName, bool enter) external view returns (uint) {\n    bytes32 key = keccak256(abi.encodePacked(hero, heroName, enter));\n    return _create[key];\n  }\n}"
    },
    "contracts/test/mocks/HeroMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\ncontract HeroMock {\n  mapping(address => uint) internal _mintFor;\n  mapping(uint => address) internal _owner;\n  uint public burnLastCall;\n\n  function setMintFor(address recipient, uint tokenId) external {\n    _mintFor[recipient] = tokenId;\n  }\n\n  function mintFor(address recipient) external view returns (uint tokenId) {\n    return _mintFor[recipient];\n  }\n\n  function setOwner(uint tokenId, address owner_) external {\n    _owner[tokenId] = owner_;\n  }\n\n  function ownerOf(uint tokenId) external view returns (address owner) {\n    return _owner[tokenId];\n  }\n\n  function burn(uint tokenId) external {\n    burnLastCall = tokenId;\n  }\n}"
    },
    "contracts/test/mocks/HeroTokensVaultMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\ncontract HeroTokensVaultMock {\n  struct ProcessData {\n    address token;\n    uint amount;\n    address from;\n  }\n\n  ProcessData public processLastCall;\n\n  function process(address token, uint amount, address from) external {\n    processLastCall = ProcessData({\n      token: token,\n      amount: amount,\n      from: from\n    });\n  }\n}"
    },
    "contracts/test/mocks/ItemControllerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/PackingLib.sol\";\nimport \"../../interfaces/IItemController.sol\";\nimport {IFightCalculator} from \"../../interfaces/IFightCalculator.sol\";\n\ncontract ItemControllerMock {\n  struct DataAttributes {\n    int32[] values;\n    uint8[] ids;\n  }\n  mapping(bytes32 => DataAttributes) private _casterAttributes;\n  mapping(bytes32 => DataAttributes) private _targetAttributes;\n  mapping(address => IItemController.ItemMeta) private _metas;\n  mapping(bytes32 => bool) internal _destroyed;\n  mapping(address => mapping(address => uint)) internal _itemIdsToMint;\n  mapping(uint => bool) internal _reduceDurabilityCalled;\n  mapping(uint => bool) internal _takeOffDirectlyCalled;\n  mapping(uint => IItemController.AttackInfo) internal _AttackInfo;\n  mapping(uint => bytes32) internal _equippedOn;\n  mapping(uint => IItemController.ItemInfo) internal _info;\n  mapping(uint => bool) internal _allowedToTransfer;\n  mapping(bytes32 packedItem => uint fragility) internal _itemFragility;\n  mapping(bytes32 packedItem => bool) internal _incBrokenItemCalled;\n\n  function setCasterAttributes(address item, uint itemId, int32[] memory values, uint8[] memory ids) external {\n    bytes32 key = PackingLib.packNftId(item, itemId);\n    _casterAttributes[key] = DataAttributes({\n      values: values,\n      ids: ids\n    });\n  }\n\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids) {\n    bytes32 key = PackingLib.packNftId(item, itemId);\n    DataAttributes memory data = _casterAttributes[key];\n    return (data.values, data.ids);\n  }\n\n  function setTargetAttributes(address item, uint itemId, int32[] memory values, uint8[] memory ids) external {\n    bytes32 key = PackingLib.packNftId(item, itemId);\n    _targetAttributes[key] = DataAttributes({\n      values: values,\n      ids: ids\n    });\n  }\n\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids) {\n    bytes32 key = PackingLib.packNftId(item, itemId);\n    DataAttributes memory data = _targetAttributes[key];\n    return (data.values, data.ids);\n  }\n\n  function setItemMeta(address item, IItemController.ItemMeta memory meta) external {\n    _metas[item] = meta;\n  }\n\n  function itemMeta(address item) external view returns (IItemController.ItemMeta memory meta) {\n    return _metas[item];\n  }\n\n  function destroy(address nft, uint nftId) external {\n    bytes32 key = PackingLib.packNftId(nft, nftId);\n    _destroyed[key] = true;\n  }\n\n  function isDestroyed(address nft, uint nftId) external view returns (bool) {\n    bytes32 key = PackingLib.packNftId(nft, nftId);\n    return _destroyed[key];\n  }\n\n  function setMint(address item, address recipient, uint itemId) external {\n    _itemIdsToMint[item][recipient] = itemId;\n  }\n  function mint(address item, address recipient) external view returns (uint itemId) {\n    return _itemIdsToMint[item][recipient];\n  }\n\n  function reduceDurability(address hero, uint heroId, uint8 biome) external {\n    uint key = uint(keccak256(abi.encodePacked(hero, heroId, biome)));\n    _reduceDurabilityCalled[key] = true;\n  }\n\n  function isReduceDurabilityCalled(address hero, uint heroId, uint8 biome) external view returns (bool) {\n    uint key = uint(keccak256(abi.encodePacked(hero, heroId, biome)));\n    return _reduceDurabilityCalled[key];\n  }\n\n  function takeOffDirectly(\n    address item,\n    uint itemId,\n    address hero,\n    uint heroId,\n    uint8 itemSlot,\n    address destination,\n    bool broken\n  ) external {\n    uint key = uint(keccak256(abi.encodePacked(item, itemId, hero, heroId, itemSlot, destination, broken)));\n    _takeOffDirectlyCalled[key] = true;\n  }\n\n  function isTakeOffDirectlyCalled(\n    address item,\n    uint itemId,\n    address hero,\n    uint heroId,\n    uint8 itemSlot,\n    address destination,\n    bool broken\n  ) external view returns (bool) {\n    uint key = uint(keccak256(abi.encodePacked(item, itemId, hero, heroId, itemSlot, destination, broken)));\n    return _takeOffDirectlyCalled[key];\n  }\n\n  function setItemAttackInfo(address item, uint itemId, IItemController.AttackInfo memory info) external {\n    uint key = uint(keccak256(abi.encodePacked(item, itemId)));\n    _AttackInfo[key] = info;\n  }\n\n  function itemAttackInfo(address item, uint itemId) external view returns (\n    IItemController.AttackInfo memory info\n  ) {\n    uint key = uint(keccak256(abi.encodePacked(item, itemId)));\n    return  _AttackInfo[key];\n  }\n\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId) {\n    uint key = uint(keccak256(abi.encodePacked(item, itemId)));\n    return PackingLib.unpackNftId(_equippedOn[key]);\n  }\n\n  function setEquippedOn(address item, uint itemId, address hero, uint heroId) external {\n    uint key = uint(keccak256(abi.encodePacked(item, itemId)));\n    _equippedOn[key] = PackingLib.packNftId(hero, heroId);\n  }\n\n  function itemInfo(address item, uint itemId) external view returns (IItemController.ItemInfo memory info) {\n    uint key = uint(keccak256(abi.encodePacked(item, itemId)));\n    return _info[key];\n  }\n\n  function setItemInfo(address item, uint itemId, IItemController.ItemInfo memory info) external {\n    uint key = uint(keccak256(abi.encodePacked(item, itemId)));\n    _info[key] = info;\n  }\n\n  function isAllowedToTransfer(address item, uint itemId) external view returns (bool) {\n    uint key = uint(keccak256(abi.encodePacked(item, itemId)));\n    return _allowedToTransfer[key];\n  }\n\n  function setAllowedToTransfer(address item, uint itemId) external {\n    uint key = uint(keccak256(abi.encodePacked(item, itemId)));\n    _allowedToTransfer[key] = true;\n  }\n\n  //region ------------------------ SIP-003: Item fragility\n  function _setItemFragility(address item, uint itemId, uint value) external {\n    bytes32 key = keccak256(abi.encodePacked(item, itemId));\n    _itemFragility[key] = value;\n  }\n\n  function itemFragility(address item, uint itemId) external view returns (uint) {\n    bytes32 key = keccak256(abi.encodePacked(item, itemId));\n    return _itemFragility[key];\n  }\n\n  function addItemFragility(address item, uint itemId, uint portion) external {\n    bytes32 key = keccak256(abi.encodePacked(item, itemId));\n    _itemFragility[key] += portion;\n  }\n\n  function isIncBrokenItemCalled(address item, uint itemId) external view returns (bool) {\n    bytes32 key = keccak256(abi.encodePacked(item, itemId));\n    return _incBrokenItemCalled[key];\n  }\n\n  function incBrokenItemFragility(address item, uint itemId) external {\n    bytes32 key = keccak256(abi.encodePacked(item, itemId));\n    _incBrokenItemCalled[key] = true;\n  }\n  //endregion ------------------------ SIP-003: Item fragility\n}"
    },
    "contracts/test/mocks/ItemMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\ninterface IsItemEquippedChecker {\n  function isItemEquipped(address item, uint itemId) external view returns (bool);\n}\n\ncontract ItemMock {\n  mapping(address => uint) internal _mintFor;\n  mapping(uint => address) internal _owner;\n  mapping(bytes32 => bool) internal _controlledTransferCalled;\n  /// @notice Allow to check if the item is equipped\n  /// Function controlledTransfer must be called in expected state (the item must be equipped or unequipped)\n  IsItemEquippedChecker internal _checker;\n  mapping(uint => bool) internal _isBurnCalled;\n\n  function setMintFor(address recipient, uint tokenId) external {\n    _mintFor[recipient] = tokenId;\n  }\n\n  function mintFor(address recipient) external view returns (uint tokenId) {\n    return _mintFor[recipient];\n  }\n\n  function setOwner(uint tokenId, address owner_) external {\n    _owner[tokenId] = owner_;\n  }\n\n  function ownerOf(uint tokenId) external view returns (address owner) {\n    return _owner[tokenId];\n  }\n\n  function controlledTransfer(address from, address to, uint tokenId) external {\n    bytes32 key = keccak256(abi.encodePacked(from, to, tokenId, _checker.isItemEquipped(address(this), tokenId)));\n    _controlledTransferCalled[key] = true;\n  }\n\n  function setItemEquippedChecker(IsItemEquippedChecker checker) external {\n    _checker = checker;\n  }\n\n  function isControlledTransferCalled(\n    address from,\n    address to,\n    uint tokenId,\n    bool equipped\n  ) external view returns (bool) {\n    bytes32 key = keccak256(abi.encodePacked(from, to, tokenId, equipped));\n    return _controlledTransferCalled[key];\n  }\n\n  function burn(uint tokenId) external {\n    _isBurnCalled[tokenId] = true;\n  }\n\n  function isBurnCalled(uint tokenId) external view returns (bool) {\n    return _isBurnCalled[tokenId];\n  }\n}"
    },
    "contracts/test/mocks/MinterMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IERC20.sol\";\nimport \"./GameTokenMock.sol\";\n\ncontract MinterMock {\n  struct MintDungeonRewardInputParams {\n    uint64 dungeonId;\n    uint dungeonBiomeLevel;\n    uint heroLevel;\n  }\n\n  MintDungeonRewardInputParams internal _mintDungeonRewardCall;\n  mapping(uint => uint) internal _amountForDungeon;\n  uint internal _amountToMint;\n  GameTokenMock internal _token;\n\n  function mintDungeonRewardCalled() external view returns (uint64 dungeonId, uint dungeonBiomeLevel, uint heroLevel) {\n    return (\n      _mintDungeonRewardCall.dungeonId,\n      _mintDungeonRewardCall.dungeonBiomeLevel,\n      _mintDungeonRewardCall.heroLevel\n    );\n  }\n\n  function setAmountToMint(address token, uint amount) external {\n    _amountToMint = amount;\n    _token = GameTokenMock(token);\n  }\n\n  function mintDungeonReward(uint64 dungeonId, uint dungeonBiomeLevel, uint heroLevel) external returns (uint amount) {\n    _mintDungeonRewardCall = MintDungeonRewardInputParams({\n      dungeonId: dungeonId,\n      dungeonBiomeLevel: dungeonBiomeLevel,\n      heroLevel: heroLevel\n    });\n    amount = _amountToMint;\n    if (amount != 0) {\n      _token.mint(msg.sender, amount);\n    }\n  }\n\n  function setAmountForDungeon(uint dungeonBiomeLevel, uint heroLevel, uint amount) external {\n    uint key = uint(keccak256(abi.encodePacked(dungeonBiomeLevel, heroLevel)));\n    _amountForDungeon[key] = amount;\n  }\n\n  function amountForDungeon(uint dungeonBiomeLevel, uint heroLevel) external view returns (uint) {\n    uint key = uint(keccak256(abi.encodePacked(dungeonBiomeLevel, heroLevel)));\n    return _amountForDungeon[key];\n  }\n}"
    },
    "contracts/test/mocks/OracleMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\ncontract OracleMock {\n  /// @notice min => max => seed => value\n  mapping(uint => mapping(uint => mapping(uint => uint))) internal _value;\n  bool internal _takeSeedAndMaxIntoAccount;\n\n  function setRandom(uint value) external {\n    _value[0][0][0] = value;\n    _takeSeedAndMaxIntoAccount = false;\n  }\n\n  function setRandomFull(uint value, uint min, uint max, uint seed) external {\n    _value[min][max][seed] = value;\n    _takeSeedAndMaxIntoAccount = true;\n  }\n\n\n  function getRandomNumber(uint max, uint seed) external view returns (uint) {\n    if (_takeSeedAndMaxIntoAccount) {\n      return _value[0][max][seed];\n    } else {\n      return _value[0][0][0];\n    }\n  }\n\n  function getRandomNumberInRange(uint min, uint max, uint seed) external view returns (uint) {\n    if (_takeSeedAndMaxIntoAccount) {\n      return _value[min][max][seed];\n    } else {\n      return _value[0][0][0];\n    }\n  }\n\n}"
    },
    "contracts/test/mocks/OracleSeriesRandomMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\ncontract OracleSeriesRandomMock {\n  mapping(uint => uint[]) internal _randoms;\n  mapping(uint => uint) internal _indices;\n\n  function setRandoms(uint max, uint[] memory values) external {\n    _randoms[max] = values;\n  }\n\n  function getRandomNumber(uint max, uint seed) external returns (uint) {\n    seed;\n    uint index = _indices[max];\n    uint[] memory list = _randoms[max];\n    _indices[max] = index + 1;\n\n    return list[index % list.length];\n  }\n}"
    },
    "contracts/test/mocks/ProxyControlledMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\ncontract ProxyControlledMock {\n  address public newImplementation;\n  function upgrade(address newImplementation_) external {\n    newImplementation = newImplementation_;\n  }\n}"
    },
    "contracts/test/mocks/ReinforcementControllerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../lib/PackingLib.sol\";\nimport \"../../interfaces/IERC721Receiver.sol\";\n\ncontract ReinforcementControllerMock is IERC721Receiver {\n  struct DataRegisterTokenReward {\n    address heroToken;\n    uint heroId;\n    uint amount;\n  }\n  struct DataRegisterNftReward {\n    address heroToken;\n    uint heroId;\n  }\n  struct AskHeroData {\n    address heroToken;\n    uint heroId;\n    int32[] attributes;\n  }\n  mapping(address => DataRegisterTokenReward) internal _registerTokenRewards;\n  mapping(bytes32 => DataRegisterNftReward) internal _registerNftRewards;\n  mapping(bytes32 => uint8) internal _helperRatios;\n  mapping(bytes32 => bool) internal _isStaked;\n  mapping(uint => AskHeroData) internal _askHero;\n\n  function registerTokenReward(address heroToken, uint heroId, address token, uint amount) external {\n    _registerTokenRewards[token] = DataRegisterTokenReward({\n      heroToken : heroToken,\n      heroId : heroId,\n      amount : amount\n    });\n  }\n\n  function getDataRegisterTokenReward(address token) external view returns (address heroToken, uint heroId, uint amount) {\n    return (_registerTokenRewards[token].heroToken, _registerTokenRewards[token].heroId, _registerTokenRewards[token].amount);\n  }\n\n  function registerNftReward(address heroToken, uint heroId, address nft, uint nftId) external {\n    bytes32 key = PackingLib.packNftId(nft, nftId);\n    _registerNftRewards[key] = DataRegisterNftReward({\n      heroToken : heroToken,\n      heroId : heroId\n    });\n  }\n  function getDataRegisterNftReward(address nft, uint nftId) external view returns (address heroToken, uint heroId) {\n    bytes32 key = PackingLib.packNftId(nft, nftId);\n    return (_registerNftRewards[key].heroToken, _registerNftRewards[key].heroId);\n  }\n\n  /**\n   * @dev See {IERC721Receiver-onERC721Received}.\n   *\n   * Always returns `IERC721Receiver.onERC721Received.selector`.\n   */\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) public virtual override returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n\n  function setHelperRatio(address heroToken, uint heroId, uint8 helperRatio) external {\n    bytes32 key = PackingLib.packNftId(heroToken, heroId);\n    _helperRatios[key] = helperRatio;\n  }\n  function toHelperRatio(address heroToken, uint heroId) external view returns (uint) {\n    bytes32 key = PackingLib.packNftId(heroToken, heroId);\n    return _helperRatios[key];\n  }\n\n  function setIsStaked(address heroToken, uint heroId, bool staked) external {\n    bytes32 key = PackingLib.packNftId(heroToken, heroId);\n    _isStaked[key] = staked;\n  }\n\n  function isStaked(address heroToken, uint heroId) external view returns (bool) {\n    bytes32 key = PackingLib.packNftId(heroToken, heroId);\n    return _isStaked[key];\n  }\n\n  function setAskHero(\n    uint biome,\n    address heroToken,\n    uint heroId,\n    int32[] memory attributes\n  ) external {\n    _askHero[biome] = AskHeroData({\n      heroToken : heroToken,\n      heroId : heroId,\n      attributes : attributes\n    });\n  }\n\n  function askHero(uint biome) external view returns (\n    address heroToken,\n    uint heroId,\n    int32[] memory attributes\n  ) {\n    AskHeroData memory data = _askHero[biome];\n    return (data.heroToken, data.heroId, data.attributes);\n  }\n}\n\n"
    },
    "contracts/test/mocks/SacraRelayTarget.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\nimport \"../../lib/PackingLib.sol\";\n\n/// @notice Contract called by SacraRelay\ncontract SacraRelayTarget {\n  error ErrorF2();\n\n  struct F1Data {\n    uint value1;\n    bool value2;\n    address sender;\n    address msgSender;\n  }\n  F1Data public f1data;\n  address public trustedForwarder;\n\n  constructor(address trustedForwarder_) {\n    trustedForwarder = trustedForwarder_;\n  }\n\n  function f1(uint value1_, bool value2_) external {\n    f1data.value1 = value1_;\n    f1data.value2 = value2_;\n    f1data.sender = msg.sender;\n    f1data.msgSender = _msgSender();\n  }\n\n  function fWithReturn(uint value1_, bool value2_) external returns (uint) {\n    f1data.value1 = value1_;\n    f1data.value2 = value2_;\n    f1data.sender = msg.sender;\n    f1data.msgSender = _msgSender();\n    return value1_;\n  }\n\n  function funcRevertPanic(uint) external pure {\n    assert(false);\n  }\n\n  function funcRevertCustomError(uint) external pure {\n    revert ErrorF2();\n  }\n\n  function funcRevert(uint) external pure {\n    revert(\"SacraRelayTargetError\");\n  }\n\n  function _msgSender() internal view virtual returns (address sender) {\n    if (msg.sender == trustedForwarder) {\n      // The assembly code is more direct than the Solidity version using `abi.decode`.\n      /// @solidity memory-safe-assembly\n      assembly {\n        sender := shr(96, calldataload(sub(calldatasize(), 20)))\n      }\n      return sender;\n    } else {\n      return msg.sender;\n    }\n  }\n\n}"
    },
    "contracts/test/mocks/StatControllerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\nimport \"../../lib/PackingLib.sol\";\n\ncontract StatControllerMock {\n  struct CurrentStatsChanges {\n    IStatController.ChangeableStats change;\n    bool increase;\n  }\n\n  struct BuffHeroData {\n    int32[] attributes;\n    int32 manaConsumed;\n  }\n\n  struct DataChangeBonusAttributes {\n    bool changeStats;\n    IStatController.ChangeableStats heroStats;\n  }\n\n  struct InitNewHeroData {\n    address token;\n    uint tokenId;\n    uint heroClass;\n  }\n\n  mapping(bytes32 => uint8[]) private _heroItemSlots;\n  mapping(bytes32 => mapping(uint8 => bytes32)) private _heroItemSlot;\n  mapping(bytes32 => CurrentStatsChanges) private _currentStatChanges;\n  mapping(bytes32 => mapping(bool => CurrentStatsChanges)) private _currentStatChangesForDirection;\n  mapping(bytes32 => IStatController.ChangeableStats) private _heroStats;\n  mapping(bytes32 => mapping(bytes32 => uint)) private _heroCustomData;\n  mapping(bytes32 => uint) private _heroGlobalData;\n  mapping(bytes32 => bool) private _clearTemporallyAttributesCalled;\n  mapping(bytes32 => bool) private _isHeroAlive;\n  mapping(bytes32 => BuffHeroData) private _buffHeroData;\n  mapping(bytes32 => DataChangeBonusAttributes) private _changeBonusAttributes;\n  mapping(uint => int32) private _heroAttribute;\n  mapping(uint => IStatController.CoreAttributes) private _heroBaseAttributes;\n  mapping(uint => int32[]) private _heroAttributes;\n  mapping(bytes32 => uint) private _levelUp;\n  mapping(bytes32 => bool) private _isClearUsedConsumablesCalled;\n  mapping(bytes32 => bool) private _isChangeHeroItemSlotCalled;\n  mapping(bytes32 => bool) private _isRegisterConsumableUsageCalled;\n\n  InitNewHeroData public initNewHeroLastCall;\n  IStatController.ChangeAttributesInfo internal _changeBonusAttributesLastCall;\n  mapping(bytes32 => bool) private _isChangeBonusAttributesCalled;\n  mapping(bytes32 => bool) private _isRestoreLifeAndManaCalled;\n\n  function setHeroAttribute(address token, uint tokenId, uint index, int32 value) external {\n    uint key = uint(keccak256(abi.encodePacked(token, tokenId, index)));\n    _heroAttribute[key] = value;\n  }\n\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32) {\n    uint key = uint(keccak256(abi.encodePacked(token, tokenId, index)));\n    return _heroAttribute[key];\n  }\n\n  function setHeroAttributes(address token, uint tokenId, int32[] memory values) external {\n    uint key = uint(keccak256(abi.encodePacked(token, tokenId)));\n    _heroAttributes[key] = values;\n  }\n\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory) {\n    uint key = uint(keccak256(abi.encodePacked(token, tokenId)));\n    return _heroAttributes[key];\n  }\n\n  function setHeroBaseAttributes(address token, uint tokenId, IStatController.CoreAttributes memory values) external {\n    uint key = uint(keccak256(abi.encodePacked(token, tokenId)));\n    _heroBaseAttributes[key] = values;\n  }\n\n  function heroBaseAttributes(address token, uint tokenId) external view returns (IStatController.CoreAttributes memory) {\n    uint key = uint(keccak256(abi.encodePacked(token, tokenId)));\n    return _heroBaseAttributes[key];\n  }\n\n\n  function setHeroItemSlots(address heroToken, uint heroTokenId, uint8[] memory attrIndices) external {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    _heroItemSlots[key] = attrIndices;\n  }\n\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory) {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    return _heroItemSlots[key];\n  }\n\n  function setHeroItemSlot(address heroToken, uint heroTokenId, uint8 itemSlot, bytes32 nftPacked) external {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    _heroItemSlot[key][itemSlot] = nftPacked;\n  }\n\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked) {\n    bytes32 key = PackingLib.packNftId(token, tokenId);\n    return _heroItemSlot[key][itemSlot];\n  }\n\n  function changeCurrentStats(address token, uint tokenId, IStatController.ChangeableStats memory change, bool increase) external {\n    bytes32 key = PackingLib.packNftId(token, tokenId);\n    _currentStatChanges[key] = CurrentStatsChanges({change: change, increase: increase});\n    _currentStatChangesForDirection[key][increase] = CurrentStatsChanges({change: change, increase: increase});\n  }\n\n  function getCurrentStatsChanges(address token, uint tokenId) external view returns (IStatController.ChangeableStats memory change, bool increase) {\n    bytes32 key = PackingLib.packNftId(token, tokenId);\n    return (_currentStatChanges[key].change, _currentStatChanges[key].increase);\n  }\n\n  function getCurrentStatsChangesForDirection(address token, uint tokenId, bool increase) external view returns (IStatController.ChangeableStats memory change) {\n    bytes32 key = PackingLib.packNftId(token, tokenId);\n    return _currentStatChangesForDirection[key][increase].change;\n  }\n\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external {\n    bytes32 key = PackingLib.packNftId(token, tokenId);\n    _heroCustomData[key][index] = value;\n  }\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint) {\n    bytes32 key = PackingLib.packNftId(token, tokenId);\n    return _heroCustomData[key][index];\n  }\n\n  function setGlobalCustomData(bytes32 index, uint value) external {\n    _heroGlobalData[index] = value;\n  }\n  function globalCustomData(bytes32 index) external view returns (uint) {\n    return _heroGlobalData[index];\n  }\n\n  function heroStats(address token, uint tokenId) external view returns (IStatController.ChangeableStats memory) {\n    bytes32 key = PackingLib.packNftId(token, tokenId);\n    return _heroStats[key];\n  }\n\n  function setHeroStats(address token, uint tokenId, IStatController.ChangeableStats memory data) external {\n    bytes32 key = PackingLib.packNftId(token, tokenId);\n    _heroStats[key] = data;\n  }\n\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    _clearTemporallyAttributesCalled[key] = true;\n  }\n\n  function isClearTemporallyAttributesCalled(address heroToken, uint heroTokenId) external view returns (bool) {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    return _clearTemporallyAttributesCalled[key];\n  }\n\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool) {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    return _isHeroAlive[key];\n  }\n\n  function setIsHeroAlive(address heroToken, uint heroTokenId, bool alive) external {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    _isHeroAlive[key] = alive;\n  }\n\n  function setBuffHero(\n    address heroToken,\n    uint heroTokenId,\n    uint level,\n    address[] memory skillTokens,\n    uint[] memory skillTokenIds,\n    int32[] memory attributes,\n    int32 manaConsumed\n  ) external {\n    bytes32 key = bytes32(abi.encodePacked(heroToken, heroTokenId, level));\n    for (uint i = 0; i < skillTokens.length; ++i) {\n      key = bytes32(abi.encodePacked(skillTokens[i], skillTokenIds[i], key));\n    }\n\n    _buffHeroData[key] = BuffHeroData({attributes: attributes, manaConsumed: manaConsumed});\n  }\n\n  function buffHero(IStatController.BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed) {\n    bytes32 key = bytes32(abi.encodePacked(info.heroToken, info.heroTokenId, info.heroLevel));\n    for (uint i = 0; i < info.buffTokens.length; ++i) {\n      key = bytes32(abi.encodePacked(info.buffTokens[i], info.buffTokenIds[i], key));\n    }\n\n    BuffHeroData memory ret = _buffHeroData[key];\n    return (ret.attributes, ret.manaConsumed);\n  }\n\n  function _getKeyForInfo(IStatController.ChangeAttributesInfo memory info) internal pure returns (bytes32) {\n    bytes memory key = abi.encodePacked(info.heroToken, info.heroTokenId, info.add, info.temporally, info.changeAttributes);\n//    for (uint i = 0; i < info.changeAttributes.length; ++i) {\n//      key = abi.encodePacked(key, info.changeAttributes[i]);\n//      console.log(\"_getKeyForInfo.keccak256\", uint(keccak256(key)), i);\n//    }\n    return keccak256(key);\n  }\n  function setChangeBonusAttributesChangeStats(IStatController.ChangeAttributesInfo memory info, IStatController.ChangeableStats memory heroStats_) external {\n    bytes32 key = _getKeyForInfo(info);\n    _changeBonusAttributes[key] = DataChangeBonusAttributes({\n      changeStats: true,\n      heroStats: heroStats_\n    });\n  }\n\n  function changeBonusAttributes(IStatController.ChangeAttributesInfo memory info) external {\n    _changeBonusAttributesLastCall = info;\n    bytes32 key = _getKeyForInfo(info);\n    DataChangeBonusAttributes memory data = _changeBonusAttributes[key];\n    if (data.changeStats) {\n      bytes32 key0 = PackingLib.packNftId(info.heroToken, info.heroTokenId);\n      _heroStats[key0] = data.heroStats;\n    }\n    _isChangeBonusAttributesCalled[key] = true;\n  }\n\n  function isChangeBonusAttributesCalled(IStatController.ChangeAttributesInfo memory info) external view returns (bool) {\n    return _isChangeBonusAttributesCalled[_getKeyForInfo(info)];\n  }\n\n  function initNewHero(address token, uint tokenId, uint heroClass) external {\n    initNewHeroLastCall = InitNewHeroData({\n      token: token,\n      tokenId: tokenId,\n      heroClass: heroClass\n    });\n  }\n\n\n  function setLevelUp(address token, uint tokenId, uint heroClass, IStatController.CoreAttributes memory change, uint newLvl) external {\n    bytes32 key = keccak256(abi.encodePacked(token, tokenId, heroClass, change.vitality, change.strength, change.energy, change.dexterity));\n    _levelUp[key] = newLvl;\n  }\n\n  function levelUp(address token, uint tokenId, uint heroClass, IStatController.CoreAttributes memory change) external view returns (\n    uint newLvl\n  ) {\n    bytes32 key = keccak256(abi.encodePacked(token, tokenId, heroClass, change.vitality, change.strength, change.energy, change.dexterity));\n    return _levelUp[key];\n  }\n\n  function changeBonusAttributesLastCall() external view returns(\n    address heroToken,\n    uint heroTokenId,\n    int32[] memory changeAttributes,\n    bool add,\n    bool temporally\n  ) {\n    IStatController.ChangeAttributesInfo memory d = _changeBonusAttributesLastCall;\n    return (d.heroToken, d.heroTokenId, d.changeAttributes, d.add, d.temporally);\n  }\n\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external {\n    bytes32 key = PackingLib.packNftId(heroToken, heroTokenId);\n    _isClearUsedConsumablesCalled[key] = true;\n  }\n\n  function isClearUsedConsumablesCalled(address heroToken, uint heroTokenId) external view returns (bool) {\n    return _isClearUsedConsumablesCalled[PackingLib.packNftId(heroToken, heroTokenId)];\n  }\n\n  function changeHeroItemSlot(\n    address heroToken,\n    uint64 heroTokenId,\n    uint itemType,\n    uint8 itemSlot,\n    address itemToken,\n    uint itemTokenId,\n    bool equip\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(heroToken, heroTokenId, itemType, itemSlot, itemToken, itemTokenId, equip));\n    _isChangeHeroItemSlotCalled[key] = true;\n  }\n\n  function isChangeHeroItemSlotCalled(\n    address heroToken,\n    uint64 heroTokenId,\n    uint itemType,\n    uint8 itemSlot,\n    address itemToken,\n    uint itemTokenId,\n    bool equip\n  ) external view returns (bool) {\n    bytes32 key = keccak256(abi.encodePacked(heroToken, heroTokenId, itemType, itemSlot, itemToken, itemTokenId, equip));\n    return _isChangeHeroItemSlotCalled[key];\n  }\n\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external {\n    bytes32 key = keccak256(abi.encodePacked(heroToken, heroTokenId, item));\n    _isRegisterConsumableUsageCalled[key] = true;\n  }\n\n  function isRegisterConsumableUsageCalled(address heroToken, uint heroTokenId, address item) external view returns (bool) {\n    bytes32 key = keccak256(abi.encodePacked(heroToken, heroTokenId, item));\n    return _isRegisterConsumableUsageCalled[key];\n  }\n\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external {\n    bytes32 key = keccak256(abi.encodePacked(heroToken, heroTokenId, prevAttributes));\n    _isRestoreLifeAndManaCalled[key] = true;\n  }\n\n  function isRestoreLifeAndManaCalled(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external view returns (bool) {\n    bytes32 key = keccak256(abi.encodePacked(heroToken, heroTokenId, prevAttributes));\n    return _isRestoreLifeAndManaCalled[key];\n  }\n}\n"
    },
    "contracts/test/mocks/StoryControllerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\nimport \"../../lib/PackingLib.sol\";\nimport \"hardhat/console.sol\";\n\ncontract StoryControllerMock {\n  mapping(uint => bool) internal _isStoryAvailableForHero;\n  mapping(uint => IGOC.ActionResult) internal _storyActionResults;\n\n  function setIsStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external {\n//    console.log(\"setIsStoryAvailableForHero\", objectId);\n    uint key = uint(keccak256(abi.encodePacked(objectId, heroToken, heroTokenId)));\n//    console.log(\"setIsStoryAvailableForHero.key\", key);\n    _isStoryAvailableForHero[key] = true;\n  }\n\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool) {\n//    console.log(\"isStoryAvailableForHero\", objectId);\n    uint key = uint(keccak256(abi.encodePacked(objectId, heroToken, heroTokenId)));\n//    console.log(\"isStoryAvailableForHero.key\", key);\n//    console.log(\"isStoryAvailableForHero\", _isStoryAvailableForHero[key]);\n    return _isStoryAvailableForHero[key];\n  }\n\n  function setStoryAction(\n    uint64 dungeonId,\n    uint32 objectId,\n    uint stageId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 biome,\n    IGOC.ActionResult memory results\n  ) external {\n    uint key = uint(keccak256(abi.encodePacked(dungeonId, objectId, stageId, heroToken, heroTokenId, biome)));\n    _storyActionResults[key] = results;\n  }\n\n  function storyAction(\n    address sender,\n    uint64 dungeonId,\n    uint32 objectId,\n    uint stageId,\n    address heroToken,\n    uint heroTokenId,\n    uint8 biome,\n    uint iteration,\n    bytes memory data\n  ) external view returns (IGOC.ActionResult memory) {\n    sender;\n    iteration;\n    data;\n    uint key = uint(keccak256(abi.encodePacked(dungeonId, objectId, stageId, heroToken, heroTokenId, biome)));\n    return _storyActionResults[key];\n  }\n}\n"
    },
    "contracts/test/mocks/TreasuryMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IItemController.sol\";\nimport \"../../interfaces/IERC20.sol\";\n\ncontract TreasuryMock {\n  mapping(address => uint) internal _balances;\n  mapping(uint => uint) internal _sendToDungeonAmounts;\n  mapping(bytes32 => bool) internal _isSendFeeCalled;\n\n  function setBalanceOfToken(address token, uint amount) external {\n    _balances[token] = amount;\n  }\n\n  function balanceOfToken(address token) external view returns (uint) {\n    return _balances[token];\n  }\n\n  function getAmountSentToDungeon(address dungeon, address token) external view returns (uint){\n    uint key = uint(keccak256(abi.encodePacked(dungeon, token)));\n    return _sendToDungeonAmounts[key];\n  }\n\n  function sendToDungeon(address dungeon, address token, uint amount) external {\n    uint key = uint(keccak256(abi.encodePacked(dungeon, token)));\n    _sendToDungeonAmounts[key] = amount;\n  }\n\n  function sendFee(address token, uint amount, IItemController.FeeType feeType) external {\n    bytes32 key = keccak256(abi.encodePacked(token, amount, uint(feeType)));\n    IERC20(token).transferFrom(msg.sender, address(this), amount);\n    _isSendFeeCalled[key] = true;\n  }\n\n  function isSendFeeCalled(address token, uint amount, IItemController.FeeType feeType) external view returns (bool) {\n    bytes32 key = keccak256(abi.encodePacked(token, amount, uint(feeType)));\n    return _isSendFeeCalled[key];\n  }\n}"
    },
    "contracts/test/mocks/UserControllerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../interfaces/IUserController.sol\";\n\ncontract UserControllerMock is IUserController {\n  mapping(address user => uint countPassedDungeons) public passedDungeons;\n  mapping(address user => uint countPvp) public pvp;\n\n  function registerPassedDungeon(address user) external {\n    passedDungeons[user] += 1;\n  }\n\n  function registerPvP(address user, bool isWinner) external {\n    isWinner;\n    pvp[user] += 1;\n  }\n}"
    },
    "contracts/test/nft/FacadeHeroBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport {HeroBase} from \"../../nft/HeroBase.sol\";\n\ncontract FacadeHeroBase is HeroBase {\n\n  //region ------------------------ For tests\n  struct HeroBaseStorageCopy {\n    mapping(uint => string) _heroUriByStatus;\n  }\n  bytes32 private constant HeroBaseStorageLocation = 0xc546abf9ed7c8d4a6ded82a0edfd8f66c8300256eba0932933c3d559a091ea00;\n\n  struct NftBaseStorageCopy {\n    uint idCounter;\n    string baseUri;\n    mapping(uint => string) uniqueUri;\n  }\n\n  bytes32 private constant NftBaseStorageLocation = 0xda2932ada77a3c8131d8c171a8679090714572b6a41aff2e2186c297ac0f5500;\n\n  constructor(\n    address controller_,\n    string memory name_,\n    string memory symbol_,\n    string memory uri_\n  ) initializer {\n    __NftBase_init(name_, symbol_, controller_, uri_);\n  }\n\n  function _S() private pure returns (HeroBaseStorageCopy storage $) {\n    assembly {\n      $.slot := HeroBaseStorageLocation\n    }\n    return $;\n  }\n\n  function _sBase() private pure returns (NftBaseStorageCopy storage $) {\n    assembly {\n      $.slot := NftBaseStorageLocation\n    }\n    return $;\n  }\n\n  function setCounter(uint counter) external {\n    _sBase().idCounter = counter;\n  }\n\n  function getCounter() external view returns (uint) {\n    return _sBase().idCounter;\n  }\n\n  //endregion ------------------------ For tests\n}"
    },
    "contracts/test/nft/FacadeItemBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport {ItemBase} from \"../../nft/ItemBase.sol\";\n\ncontract FacadeItemBase is ItemBase {\n\n  //region ------------------------ For tests\n  struct ItemBaseStorageCopy {\n    mapping(uint8 => string) itemUriByRarity;\n  }\n\n  bytes32 private constant ItemBaseStorageLocation = 0x2dd41482e37d186fdf6545c563673785f2bcb485d6039f6c172d58b496a6e000;\n\n  struct NftBaseStorageCopy {\n    uint idCounter;\n    string baseUri;\n    mapping(uint => string) uniqueUri;\n  }\n\n  bytes32 private constant NftBaseStorageLocation = 0xda2932ada77a3c8131d8c171a8679090714572b6a41aff2e2186c297ac0f5500;\n\n  constructor(\n    address controller_,\n    string memory name_,\n    string memory symbol_,\n    string memory uri_\n  ) initializer {\n    __NftBase_init(name_, symbol_, controller_, uri_);\n  }\n\n  function _S() private pure returns (ItemBaseStorageCopy storage $) {\n    assembly {\n      $.slot := ItemBaseStorageLocation\n    }\n    return $;\n  }\n\n  function _sBase() private pure returns (NftBaseStorageCopy storage $) {\n    assembly {\n      $.slot := NftBaseStorageLocation\n    }\n    return $;\n  }\n\n  function setCounter(uint counter) external {\n    _sBase().idCounter = counter;\n  }\n\n  function getCounter() external view returns (uint) {\n    return _sBase().idCounter;\n  }\n\n  //endregion ------------------------ For tests\n}"
    },
    "contracts/test/nft/FacadeNftBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport \"../../nft/NftBase.sol\";\n\ncontract FacadeNftBase is NftBase {\n  string internal _specificURIValue;\n\n  //region ------------------------ Initializer\n\n  constructor(\n    address controller_,\n    string memory name_,\n    string memory symbol_,\n    string memory uri_\n  ) initializer {\n    __NftBase_init(name_, symbol_, controller_, uri_);\n  }\n  //endregion ------------------------ Initializer\n\n  //region ------------------------ For tests\n  struct NftBaseStorageCopy {\n    uint idCounter;\n    string baseUri;\n    mapping(uint => string) uniqueUri;\n  }\n\n  string public constant override VERSION = \"2.0.0\";\n  bytes32 private constant NftBaseStorageLocation = 0xda2932ada77a3c8131d8c171a8679090714572b6a41aff2e2186c297ac0f5500;\n\n  function _S() private pure returns (NftBaseStorageCopy storage $) {\n    assembly {\n      $.slot := NftBaseStorageLocation\n    }\n    return $;\n  }\n\n  function setCounter(uint counter) external {\n    _S().idCounter = counter;\n  }\n\n  function getCounter() external view returns (uint) {\n    return _S().idCounter;\n  }\n\n  function testMint(address recipient) external returns (uint tokenId) {\n    tokenId = _incrementAndGetId();\n    _safeMint(recipient, tokenId);\n  }\n\n  function testBurn(uint tokenId) external {\n    _burn(tokenId);\n  }\n\n  function testIncrementAndGetId() external returns (uint) {\n    return _incrementAndGetId();\n  }\n\n  function getUniqueUriDirect(uint tokenId) external view returns (string memory uri) {\n    return _S().uniqueUri[tokenId];\n  }\n\n  function setSpecificUriValue(string memory uri) external {\n    _specificURIValue = uri;\n  }\n\n  function getSpecificURI(uint param) external view returns (string memory) {\n    return super._specificURI(param);\n  }\n  //endregion ------------------------ For tests\n\n  function _specificURI(uint) internal view override returns (string memory) {\n    return _specificURIValue;\n  }\n}"
    },
    "contracts/test/PackingLibMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../lib/PackingLib.sol\";\nimport \"../interfaces/IItemController.sol\";\n\ncontract PackingLibMock {\n\n  bytes32[] public array32;\n\n  //////////////////////////\n  //  ITEMS\n  //////////////////////////\n\n  function packItemMetadata(\n    uint8 itemMetaType,\n    uint8 itemLvl,\n    uint8 itemType,\n    uint16 baseDurability,\n    uint8 defaultRarity,\n    uint8 minAttr,\n    uint8 maxAttr,\n    uint32 manaCost,\n    IStatController.CoreAttributes memory req\n  ) external pure returns (bytes32) {\n    return PackingLib.packItemMeta(\n      itemMetaType,\n      itemLvl,\n      itemType,\n      baseDurability,\n      defaultRarity,\n      minAttr,\n      maxAttr,\n      manaCost,\n      req\n    );\n  }\n\n  function unpackItemMeta(bytes32 data) external pure returns (IItemController.ItemMeta memory result) {\n    return PackingLib.unpackItemMeta(data);\n  }\n\n  //////////////////////////\n  //  MAP\n  //////////////////////////\n\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) public pure returns (bytes32 packedData) {\n    return PackingLib.packMapObject(objectAddress, objectId, objectType);\n  }\n\n  function unpackMapObject(bytes32 packedData) public pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\n    return PackingLib.unpackMapObject(packedData);\n  }\n\n  function packCoordinate(uint128 x, uint128 y) public pure returns (bytes32 packedData) {\n    return PackingLib.packCoordinate(x, y);\n  }\n\n  function unpackCoordinate(bytes32 packedData) public pure returns (uint128 x, uint128 y) {\n    return PackingLib.unpackCoordinate(packedData);\n  }\n\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) public pure returns (bytes32 packedData) {\n    return PackingLib.packBattlefieldId(biomeMapFieldId, territoryNumber, x, y);\n  }\n\n  function unpackBattlefieldId(bytes32 packedData) public pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\n    return PackingLib.unpackBattlefieldId(packedData);\n  }\n\n  function packNftId(address token, uint id) public pure returns (bytes32 serialized) {\n    return PackingLib.packNftId(token, id);\n  }\n\n  function unpackNftId(bytes32 data) public pure returns (address token, uint id) {\n    return PackingLib.unpackNftId(data);\n  }\n\n  function packUint8Array(uint8[] memory data) public pure returns (bytes32) {\n    return PackingLib.packUint8Array(data);\n  }\n\n  function unpackUint8Array(bytes32 data) public pure returns (uint8[] memory) {\n    return PackingLib.unpackUint8Array(data);\n  }\n\n  function packInt32Array(int32[] memory data) public pure returns (bytes32) {\n    return PackingLib.packInt32Array(data);\n  }\n\n  function unpackInt32Array(bytes32 data) public pure returns (int32[] memory) {\n    return PackingLib.unpackInt32Array(data);\n  }\n\n  //////////////////////////\n  // ---- ARRAYS LOGIC ----\n  //////////////////////////\n\n//  function getInt32AsInt24(bytes32[] memory arr, uint idx) external pure returns (int32) {\n//    return PackingLib.getInt32AsInt24(arr, idx);\n//  }\n//\n//  function getUnit8From32Step(bytes32[] memory arr, uint idx) external pure returns (uint8) {\n//    return PackingLib.getUnit8From32Step(arr, idx);\n//  }\n\n  function getInt32Memory(bytes32[] memory arr, uint idx) external pure returns (int32) {\n    return PackingLib.getInt32Memory(arr, idx);\n  }\n\n  function getInt32(uint idx) external view returns (int32) {\n    return PackingLib.getInt32(array32, idx);\n  }\n\n  function setInt32(uint idx, int32 value) external {\n    PackingLib.setInt32(array32, idx, value);\n  }\n\n  function toInt32Array(bytes32[] memory arr, uint size) external pure returns (int32[] memory) {\n    return PackingLib.toInt32Array(arr, size);\n  }\n\n  function toBytes32Array(int32[] memory arr) external pure returns (bytes32[] memory) {\n    return PackingLib.toBytes32Array(arr);\n  }\n\n  function toBytes32ArrayWithIds(int32[] memory arr, uint8[] memory ids) external pure returns (bytes32[] memory) {\n    return PackingLib.toBytes32ArrayWithIds(arr, ids);\n  }\n\n  function toInt32ArrayWithIds(bytes32[] memory arr) external pure returns (int32[] memory values, uint8[] memory ids) {\n    return PackingLib.toInt32ArrayWithIds(arr);\n  }\n\n}\n"
    },
    "contracts/test/SlotsLibMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../lib/SlotsLib.sol\";\n\ncontract SlotsLibMock {\n  function getBytes32(bytes32 slot) public view returns (bytes32 result) {\n    return SlotsLib.getBytes32(slot);\n  }\n\n  function getAddress(bytes32 slot) public view returns (address result) {\n    return SlotsLib.getAddress(slot);\n  }\n\n  function getUint(bytes32 slot) public view returns (uint result) {\n    return SlotsLib.getUint(slot);\n  }\n\n  function arrayLength(bytes32 slot) public view returns (uint result) {\n    return SlotsLib.arrayLength(slot);\n  }\n\n  function addressAt(bytes32 slot, uint index) public view returns (address result) {\n    return SlotsLib.addressAt(slot, index);\n  }\n\n  function setBytes(bytes32 slot, bytes32 value) public {\n    return SlotsLib.set(slot, value);\n  }\n\n  function setAddress(bytes32 slot, address value) public {\n    return SlotsLib.set(slot, value);\n  }\n\n  function setUint(bytes32 slot, uint value) public {\n    return SlotsLib.set(slot, value);\n  }\n}\n"
    },
    "contracts/test/StatLibMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../lib/StatLib.sol\";\n\ncontract StatLibMock {\n\n  function minDamage(int32 strength, uint heroClass) public pure returns (int32){\n    return StatLib.minDamage(strength, heroClass);\n  }\n\n  function maxDamage(int32 strength, uint heroClass) public pure returns (int32){\n    return StatLib.maxDamage(strength, heroClass);\n  }\n\n  function attackRating(int32 dexterity, uint heroClass) public pure returns (int32){\n    return StatLib.attackRating(dexterity, heroClass);\n  }\n\n  function defense(int32 dexterity, uint heroClass) public pure returns (int32){\n    return StatLib.defense(dexterity, heroClass);\n  }\n\n  function blockRating(int32 dexterity, uint heroClass) public pure returns (int32){\n    return StatLib.blockRating(dexterity, heroClass);\n  }\n\n  function life(int32 vitality, uint heroClass, uint32 level) public pure returns (int32){\n    return StatLib.life(vitality, heroClass, level);\n  }\n\n  function mana(int32 energy, uint heroClass, uint32 level) public pure returns (int32){\n    return StatLib.mana(energy, heroClass, level);\n  }\n\n  function levelExperience(uint32 level) public pure returns (uint){\n    return StatLib.levelExperience(level);\n  }\n\n  function chanceToHit(\n    uint attackersAttackRating,\n    uint defendersDefenceRating,\n    uint attackersLevel,\n    uint defendersLevel,\n    uint arFactor\n  ) public pure returns (uint){\n    return StatLib.chanceToHit(\n      attackersAttackRating, defendersDefenceRating, attackersLevel, defendersLevel, arFactor\n    );\n  }\n}\n"
    },
    "contracts/test/TestLargeCall.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\ncontract TestLargeCall {\n\n  struct CallData {\n    bytes32[] indexes;\n    uint[] resIds;\n    uint[][] nextIds;\n  }\n\n  mapping(address => mapping(bytes32 => mapping(uint => uint[]))) public testMap;\n\n  function largeCall(CallData memory data) external {\n    unchecked {\n      for (uint i; i < data.indexes.length; ++i) {\n        testMap[msg.sender][data.indexes[i]][data.resIds[i]] = data.nextIds[i];\n      }\n    }\n  }\n\n}\n"
    },
    "contracts/test/TestLargeCall2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"./TestLargeCall.sol\";\n\ncontract TestLargeCall2 {\n\n  function largeCall2(address dest, TestLargeCall.CallData memory data) external {\n    TestLargeCall(dest).largeCall(data);\n  }\n\n}\n"
    },
    "contracts/token/GameToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\nimport \"../interfaces/IGameToken.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../relay/ERC2771Context.sol\";\n\ncontract GameToken is IGameToken, ERC2771Context {\n\n  //region ------------------------ Constants\n\n  string public constant symbol = \"SACRA\";\n  string public constant name = \"Sacra token\";\n  uint8 public constant decimals = 18;\n  //endregion ------------------------ Constants\n\n  //region ------------------------ Variables\n\n  uint public override totalSupply = 0;\n  bool public paused;\n\n  mapping(address => uint) public override balanceOf;\n  mapping(address => mapping(address => uint)) public override allowance;\n\n  address public override minter;\n  //endregion ------------------------ Variables\n\n  //region ------------------------ Constructor\n\n  constructor() {\n    minter = _msgSender();\n    _mint(_msgSender(), 0);\n  }\n  //endregion ------------------------ Constructor\n\n  //region ------------------------ Main logic\n\n  function approve(address spender_, uint value_) external override returns (bool) {\n    if (spender_ == address(0)) revert IAppErrors.ApproveToZeroAddress();\n    allowance[_msgSender()][spender_] = value_;\n    emit Approval(_msgSender(), spender_, value_);\n    return true;\n  }\n\n  function _mint(address to_, uint amount_) internal returns (bool) {\n    if (to_ == address(0)) revert IAppErrors.MintToZeroAddress();\n    require(!paused, \"Paused\");\n    balanceOf[to_] += amount_;\n    totalSupply += amount_;\n    emit Transfer(address(0x0), to_, amount_);\n    return true;\n  }\n\n  function _transfer(address from_, address to_, uint value_) internal returns (bool) {\n    if (to_ == address(0)) revert IAppErrors.TransferToZeroAddress();\n    if (paused) revert IAppErrors.ErrorPaused();\n\n    uint fromBalance = balanceOf[from_];\n    if (fromBalance < value_) revert IAppErrors.TransferAmountExceedsBalance(fromBalance, value_);\n    unchecked {\n      balanceOf[from_] = fromBalance - value_;\n    }\n\n    balanceOf[to_] += value_;\n    emit Transfer(from_, to_, value_);\n    return true;\n  }\n\n  function transfer(address to_, uint value_) external override returns (bool) {\n    return _transfer(_msgSender(), to_, value_);\n  }\n\n  function transferFrom(address from_, address to_, uint value_) external override returns (bool) {\n    address spender = _msgSender();\n    uint spenderAllowance = allowance[from_][spender];\n    if (spenderAllowance != type(uint).max) {\n      if (spenderAllowance < value_) revert IAppErrors.InsufficientAllowance();\n      unchecked {\n        uint newAllowance = spenderAllowance - value_;\n        allowance[from_][spender] = newAllowance;\n        emit Approval(from_, spender, newAllowance);\n      }\n    }\n    return _transfer(from_, to_, value_);\n  }\n\n  function burn(uint amount) external override returns (bool) {\n    address from = _msgSender();\n    uint accountBalance = balanceOf[from];\n    if (accountBalance < amount) revert IAppErrors.BurnAmountExceedsBalance();\n    unchecked {\n      balanceOf[from] = accountBalance - amount;\n    // Overflow not possible: amount <= accountBalance <= totalSupply.\n      totalSupply -= amount;\n    }\n\n    emit Transfer(from, address(0), amount);\n    return true;\n  }\n  //endregion ------------------------ Main logic\n\n  //region ------------------------ Minter actions\n\n  function mint(address account, uint amount) external override returns (bool) {\n    if (msg.sender != minter) revert IAppErrors.NotMinter(msg.sender);\n    _mint(account, amount);\n    return true;\n  }\n\n  // No checks as its meant to be once off to set minting rights to Minter\n  function setMinter(address minter_) external override {\n    if (msg.sender != minter) revert IAppErrors.NotMinter(msg.sender);\n    minter = minter_;\n    emit IApplicationEvents.MinterChanged(minter_);\n  }\n\n  function pause(bool value) external override {\n    if (msg.sender != minter) revert IAppErrors.NotMinter(msg.sender);\n    paused = value;\n    emit IApplicationEvents.ChangePauseStatus(value);\n  }\n  //endregion ------------------------ Minter actions\n}\n"
    },
    "contracts/token/Minter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/**\n            ▒▓▒  ▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▒     ▒▒▒▒▓▓▓▒▓▓▓▓▓▓▓██▓\n             ▒██▒▓▓▓▓█▓██████████████████▓  ▒▒▒▓███████████████▒\n              ▒██▒▓█████████████████████▒ ▒▓██████████▓███████\n               ▒███████████▓▒                   ▒███▓▓██████▓\n                 █████████▒                     ▒▓▒▓███████▒\n                  ███████▓      ▒▒▒▒▒▓▓█▓▒     ▓█▓████████\n                   ▒▒▒▒▒   ▒▒▒▒▓▓▓█████▒      ▓█████████▓\n                         ▒▓▓▓▒▓██████▓      ▒▓▓████████▒\n                       ▒██▓▓▓███████▒      ▒▒▓███▓████\n                        ▒███▓█████▒       ▒▒█████▓██▓\n                          ██████▓   ▒▒▒▓██▓██▓█████▒\n                           ▒▒▓▓▒   ▒██▓▒▓▓████████\n                                  ▓█████▓███████▓\n                                 ██▓▓██████████▒\n                                ▒█████████████\n                                 ███████████▓\n      ▒▓▓▓▓▓▓▒▓                  ▒█████████▒                      ▒▓▓\n    ▒▓█▒   ▒▒█▒▒                   ▓██████                       ▒▒▓▓▒\n   ▒▒█▒       ▓▒                    ▒████                       ▒▓█▓█▓▒\n   ▓▒██▓▒                             ██                       ▒▓█▓▓▓██▒\n    ▓█▓▓▓▓▓█▓▓▓▒        ▒▒▒         ▒▒▒▓▓▓▓▒▓▒▒▓▒▓▓▓▓▓▓▓▓▒    ▒▓█▒ ▒▓▒▓█▓\n     ▒▓█▓▓▓▓▓▓▓▓▓▓▒    ▒▒▒▓▒     ▒▒▒▓▓     ▓▓  ▓▓█▓   ▒▒▓▓   ▒▒█▒   ▒▓▒▓█▓\n            ▒▒▓▓▓▒▓▒  ▒▓▓▓▒█▒   ▒▒▒█▒          ▒▒█▓▒▒▒▓▓▓▒   ▓██▓▓▓▓▓▓▓███▓\n ▒            ▒▓▓█▓  ▒▓▓▓▓█▓█▓  ▒█▓▓▒          ▓▓█▓▒▓█▓▒▒   ▓█▓        ▓███▓\n▓▓▒         ▒▒▓▓█▓▒▒▓█▒   ▒▓██▓  ▓██▓▒     ▒█▓ ▓▓██   ▒▓▓▓▒▒▓█▓        ▒▓████▒\n ██▓▓▒▒▒▒▓▓███▓▒ ▒▓▓▓▓▒▒ ▒▓▓▓▓▓▓▓▒▒▒▓█▓▓▓▓█▓▓▒▒▓▓▓▓▓▒    ▒▓████▓▒     ▓▓███████▓▓▒\n*/\npragma solidity 0.8.23;\n\nimport \"../interfaces/IGameToken.sol\";\nimport \"../interfaces/IMinter.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../lib/CalcLib.sol\";\nimport \"../lib/StatLib.sol\";\nimport \"../openzeppelin/Math.sol\";\n\ncontract Minter is IMinter {\n  using CalcLib for uint;\n\n  //region ------------------------ Constants\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant VERSION = \"1.0.1\";\n\n  uint private constant _MIN_BASE = 1;\n  uint private constant _TOTAL_SUPPLY_BASE = 10_000_000e18;\n  address private constant DEAD_ADDRESS_TO_BURN = 0x000000000000000000000000000000000000dEaD;\n  //endregion ------------------------ Constants\n\n  //region ------------------------ Variables\n\n  IController public immutable controller;\n  IGameToken public immutable token;\n  mapping(uint64 => bool) public dungeonMinted;\n  bool public finalized;\n  /// @notice Token for which you can exchange the game token\n  address public myrdToken;\n\n  //endregion ------------------------ Variables\n\n  //region ------------------------ Constructors\n\n  constructor(address token_, address controller_) {\n    token = IGameToken(token_);\n    controller = IController(controller_);\n  }\n  //endregion ------------------------ Constructors\n\n  //region ------------------------ Restrictions\n\n  function onlyDungeonFactory() internal view {\n    require(controller.dungeonFactory() == msg.sender, \"Not dungeon factory\");\n  }\n\n  function onlyGovernance() internal view {\n    require(controller.governance() == msg.sender, \"Not gov\");\n  }\n  //endregion ------------------------ Restrictions\n\n  //region ------------------------ Main logic\n\n  function amountForDungeon(uint dungeonBiomeLevel, uint heroLvl) public view override returns (uint) {\n    require(dungeonBiomeLevel < 20, \"Too high biome\");\n    uint totalSupply = Math.max(token.totalSupply(), 1);\n    uint base = Math.min(Math.max(_TOTAL_SUPPLY_BASE * 1e18 / totalSupply, _MIN_BASE), 20e18);\n    base = base * (dungeonBiomeLevel ** 3) * 4;\n\n    if(dungeonBiomeLevel == 1) {\n      base = base / 10;\n    }\n\n    uint heroBiome = heroLvl / StatLib.BIOME_LEVEL_STEP + 1;\n    // reduce amount if hero not in his biome\n    if (heroBiome > dungeonBiomeLevel) {\n      base = base / (2 ** (heroBiome - dungeonBiomeLevel));\n    }\n    return base;\n  }\n\n  function mintDungeonReward(uint64 dungeonId, uint dungeonBiomeLevel, uint heroLvl) external override returns (uint amount) {\n    onlyDungeonFactory();\n    require(!dungeonMinted[dungeonId], \"Already minted\");\n\n    amount = amountForDungeon(dungeonBiomeLevel, heroLvl);\n    if (amount != 0) {\n      token.mint(msg.sender, amount);\n    }\n    dungeonMinted[dungeonId] = true;\n  }\n  //region ------------------------ Main logic\n\n  //region ------------------------ Gov actions\n\n  function transferMinter(address value) external {\n    onlyGovernance();\n    require(!finalized, \"finalized\");\n    token.setMinter(value);\n  }\n\n  function pause(bool value) external {\n    onlyGovernance();\n    token.pause(value);\n  }\n\n  /// @dev Stop possibility change minter\n  function finalize() external {\n    onlyGovernance();\n    finalized = true;\n  }\n  //endregion ------------------------ Gov actions\n\n  //region ------------------------ Minting in exchange of MYRD-token\n\n  function setMyrdToken(address myrdToken_) external {\n    onlyGovernance();\n    if (myrdToken != address(0)) revert IAppErrors.AlreadyInitialized();\n\n    myrdToken = myrdToken_;\n  }\n\n  /// @notice Mint game token in exchange to {myrdToken}, rate 1:1\n  /// @param amount Amount to mint. Assume, that the same {amount} of {myrdToken} is approved by the msg.sender\n  function mintForMyrd(uint amount) external {\n    if (myrdToken == address(0)) revert IAppErrors.NotInitialized();\n\n    if (amount != 0) {\n      IERC20(myrdToken).transferFrom(msg.sender, DEAD_ADDRESS_TO_BURN, amount);\n      token.mint(msg.sender, amount);\n    }\n  }\n  //endregion ------------------------ Minting in exchange of MYRD-token\n}\n"
    },
    "contracts/tools/DataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ncontract DataStorage {\n    mapping(address => bytes) public data;\n\n    function store(bytes calldata _data) external {\n        data[msg.sender] = _data;\n    }\n\n    function clearData() external {\n        delete data[msg.sender];\n    }\n}"
    },
    "contracts/tools/GameFaucet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\ncontract GameFaucet {\n\n  /////////////////// VARS ////////////////////\n\n  uint public constant DELAY = 1 days;\n  address public immutable owner;\n  mapping(address => bool) public operators;\n\n  mapping(address => uint) public receivedEth;\n  mapping(address => uint) public receivedEthTs;\n  uint public ethAmountLimit = 100 ether;\n\n  mapping(address => uint) public receivedToken;\n  mapping(address => uint) public receivedTokenTs;\n  uint public tokenAmountLimit = 1000 ether;\n\n  /////////////////// CONSTRUCTOR ////////////////////\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  /////////////////// MODIFIERS ////////////////////\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"!owner\");\n    _;\n  }\n\n  modifier onlyOwnerOrOperator() {\n    require(msg.sender == owner || operators[msg.sender], \"!owner && !operator\");\n    _;\n  }\n\n  /////////////////// VIEWS ////////////////////\n\n  function isEligibleForEth(address recipient) public view returns (bool) {\n    return receivedEthTs[recipient] + DELAY < block.timestamp\n    && receivedEth[recipient] < ethAmountLimit\n    && address(this).balance > 1 ether\n      && address(recipient).balance < 0.1 ether;\n  }\n\n  function isEligibleForToken(address recipient, address token) public view returns (bool) {\n    return receivedTokenTs[recipient] + DELAY < block.timestamp\n    && receivedToken[recipient] < tokenAmountLimit\n    && IERC20(token).balanceOf(address(this)) > 100 ether\n      && IERC20(token).balanceOf(recipient) < 10 ether;\n  }\n\n  function isEligibleForEthAndToken(address recipient, address token) public view returns (bool forEth, bool forToken) {\n    return (isEligibleForEth(recipient), isEligibleForToken(recipient, token));\n  }\n\n  /////////////////// GOV ACTIONS ////////////////////\n\n  function withdrawAll() public onlyOwner {\n    uint balance = address(this).balance;\n    require(balance > 0, \"No ether left to withdraw\");\n    payable(owner).transfer(balance);\n  }\n\n  function setEthAmountLimit(uint _gasAmountLimit) public onlyOwner {\n    ethAmountLimit = _gasAmountLimit;\n  }\n\n  function addOperator(address _operator) public onlyOwner {\n    operators[_operator] = true;\n  }\n\n  /////////////////// OPERATOR ACTIONS ////////////////////\n\n  function sendEthTo(address payable recipient, uint amount) public onlyOwnerOrOperator {\n    require(isEligibleForEth(recipient), \"not eligible\");\n\n    receivedEth[recipient] += amount;\n    receivedEthTs[recipient] = block.timestamp;\n\n    _sendGas(recipient, amount);\n  }\n\n  function sendTokenTo(address recipient, address token, uint amount) public onlyOwnerOrOperator {\n    require(isEligibleForToken(recipient, token), \"not eligible\");\n\n    receivedToken[recipient] += amount;\n    receivedTokenTs[recipient] = block.timestamp;\n\n    IERC20(token).transfer(recipient, amount);\n  }\n\n  function sendTo(address recipient, uint ethAmount, address token, uint tokenAmount) public onlyOwnerOrOperator {\n    if(ethAmount > 0) {\n      require(isEligibleForEth(recipient), \"not eligible\");\n\n      receivedEth[recipient] += ethAmount;\n      receivedEthTs[recipient] = block.timestamp;\n\n      _sendGas(payable(recipient), ethAmount);\n    }\n\n    if(tokenAmount > 0) {\n      require(isEligibleForToken(recipient, token), \"not eligible\");\n\n      receivedToken[recipient] += tokenAmount;\n      receivedTokenTs[recipient] = block.timestamp;\n\n      IERC20(token).transfer(recipient, tokenAmount);\n    }\n  }\n\n  /////////////////// INTERNAL ////////////////////\n\n  function _sendGas(address payable recipient, uint amount) private {\n    require(address(this).balance >= amount, \"Insufficient funds in the faucet\");\n    recipient.transfer(amount);\n  }\n\n  receive() external payable {}\n}\n"
    },
    "contracts/tools/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\n////// /nix/store/im7ll7dx8gsw2da9k5xwbf8pbjfli2hc-multicall-df1e59d/src/Multicall.sol\n/* pragma solidity >=0.5.0; */\n/* pragma experimental ABIEncoderV2; */\n\n/// @title Multicall - Aggregate results from multiple read-only function calls\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\ncontract Multicall {\n  struct Call {\n    address target;\n    bytes callData;\n  }\n\n  function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory returnData) {\n    blockNumber = block.number;\n    returnData = new bytes[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n      require(success);\n      returnData[i] = ret;\n    }\n  }\n\n  // Helper functions\n  function getEthBalance(address addr) public view returns (uint256 balance) {\n    balance = addr.balance;\n  }\n\n  function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n    blockHash = blockhash(blockNumber);\n  }\n\n  function getLastBlockHash() public view returns (bytes32 blockHash) {\n    blockHash = blockhash(block.number - 1);\n  }\n\n  function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n    timestamp = block.timestamp;\n  }\n\n  function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n    difficulty = block.difficulty;\n  }\n\n  function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n    gaslimit = block.gaslimit;\n  }\n\n  function getCurrentBlockCoinbase() public view returns (address coinbase) {\n    coinbase = block.coinbase;\n  }\n}\n"
    },
    "contracts/tools/SponsoredHero.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../openzeppelin/MerkleProof.sol\";\nimport \"../openzeppelin/ERC721Holder.sol\";\nimport \"../relay/ERC2771Context.sol\";\nimport \"../interfaces/IApplicationEvents.sol\";\nimport \"../interfaces/IHeroController.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IAppErrors.sol\";\nimport \"../interfaces/IERC721.sol\";\n\ncontract SponsoredHero is ERC2771Context, ERC721Holder {\n  //region ------------------------ Members\n  IHeroController public immutable heroController;\n  IERC20 public immutable gameToken;\n  IController public immutable controller;\n\n  /// @notice List of roots of registered merkle trees\n  /// @dev First tree is registered in constructor. Other trees can be added later using {addTree}\n  bytes32[] public merkleRoots;\n\n  /// @notice merkleRoot => claimant => started claim marker\n  mapping(bytes32 merkleRoot => mapping (address user => bool isClaimStarted)) public claimStarted;\n\n  /// @notice merkleRoot => claimant => remain available heroes (or 0 if the claim is not started)\n  /// @dev lazy initialization of first create\n  mapping(bytes32 merkleRoot => mapping (address user => uint heroesAvailable)) public heroesAvailable;\n  //endregion ------------------------ Members\n\n  //region ------------------------ Constructor\n\n  /// @dev Use {addTree} to registry first tree\n  constructor(address controller_) {\n    controller = IController(controller_);\n\n    address _gameToken = IController(controller_).gameToken();\n    gameToken = IERC20(_gameToken);\n\n    address _heroController = IController(controller_).heroController();\n    heroController = IHeroController(_heroController);\n\n    // infinity approve\n    IERC20(_gameToken).approve(IHeroController(_heroController).heroTokensVault(), type(uint256).max);\n  }\n  //endregion ------------------------ Constructor\n\n  //region ------------------------ View\n  /// @return claimStartedOut Values of is-claim-started for each registered merkle tree\n  /// @return heroesAvailableOut Count of heroes available for each registered merkle tree.\n  /// If claiming for the given tree is not started heroesAvailable is 0\n  /// because the value is initialized at the first call of create().\n  function userInfo(address user) external view returns (bool[] memory claimStartedOut, uint[] memory heroesAvailableOut) {\n    uint len = merkleRoots.length;\n    claimStartedOut = new bool[](len);\n    heroesAvailableOut = new uint[](len);\n    for (uint i; i < len; ++i) {\n      bytes32 merkleRoot = merkleRoots[i];\n      claimStartedOut[i] = claimStarted[merkleRoot][user];\n      heroesAvailableOut[i] = heroesAvailable[merkleRoot][user];\n    }\n  }\n\n  /// @notice Try to verify using the merkle tree with the given {indexTree}\n  function verify(bytes32[] memory proof, address addr, uint256 amount, uint indexTree) public view returns (bool) {\n    bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(addr, amount))));\n    return MerkleProof.verify(proof, merkleRoots[indexTree], leaf);\n  }\n\n  /// @notice Total count of registered merkle trees >= 1\n  function merkleRootsLength() external view returns (uint) {\n    return merkleRoots.length;\n  }\n  //endregion ------------------------ View\n\n  //region ------------------------ Logic\n\n  /// @notice Create new hero using. Verification is made using merkle tree with the given {indexTree}.\n  /// @notice Signer should put enough game token on balance of the contract before the call.\n  /// Simplest way to do it is to approve {heroCreationFee} amount and call {sendHeroCreationFee}\n  /// @param indexTree Index of the required tree in {merkleRoots}.\n  /// The merkle tree is selected by signer off-chain according to data received through {userInfo}.\n  function create(\n    bytes32[] memory proof,\n    uint airdroppedAmount,\n    uint indexTree,\n    address heroAddress,\n    string memory heroName_,\n    bool enter\n  ) external {\n    onlyEOA();\n\n    address user = _msgSender();\n    uint heroClass = heroController.heroClass(heroAddress);\n\n    // only 4 hero classes available (heroes 5 and 6 are free)\n    if (heroClass == 0 || heroClass >= 5) revert IAppErrors.InvalidHeroClass();\n\n    bytes32 merkleRoot = merkleRoots[indexTree];\n\n    if (claimStarted[merkleRoot][user]) {\n      uint _heroesAvailable = heroesAvailable[merkleRoot][user];\n      if (_heroesAvailable == 0) revert IAppErrors.NoHeroesAvailable();\n      heroesAvailable[merkleRoot][user] = _heroesAvailable - 1;\n    } else {\n      if (airdroppedAmount == 0) revert IAppErrors.ZeroAmount();\n\n      if (!verify(proof, user, airdroppedAmount, indexTree)) revert IAppErrors.InvalidProof();\n      claimStarted[merkleRoot][user] = true;\n      heroesAvailable[merkleRoot][user] = airdroppedAmount - 1;\n    }\n\n    uint heroId = heroController.create(heroAddress, heroName_, enter);\n\n    IERC721(heroAddress).safeTransferFrom(address(this), user, heroId);\n\n    emit IApplicationEvents.SponsoredHeroCreated(user, heroAddress, heroId, heroName_);\n  }\n\n  /// @notice Register a merkle tree\n  /// @param amount Total fee required to create all heroes from the tree.\n  /// The given amount of {gameToken} will be transferred from the signer to the balance.\n  /// Pass 0 to skip transferring.\n  function addTree(bytes32 root_, uint amount) external {\n    if (controller.governance() != msg.sender) revert IAppErrors.NotGovernance(msg.sender);\n    if (amount == 0) revert IAppErrors.ZeroAmount();\n\n    IERC20(gameToken).transferFrom(msg.sender, address(this), amount);\n\n    // don't allow to add same tree twice\n    uint len = merkleRoots.length;\n    for (uint i; i < len; ++i) {\n      if (merkleRoots[i] == root_) revert IAppErrors.AlreadyRegistered();\n    }\n\n    merkleRoots.push(root_);\n  }\n\n  function salvage(address receiver_, address token_, uint amount_) external {\n    if (controller.governance() != msg.sender) revert IAppErrors.ErrorForbidden(msg.sender);\n\n    IERC20(token_).transfer(receiver_, amount_);\n  }\n  //endregion ------------------------ Logic\n}\n"
    },
    "contracts/tools/StatReader.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.23;\n\nimport \"../lib/StatLib.sol\";\nimport \"../lib/CalcLib.sol\";\n\ncontract StatReader {\n  using CalcLib for int32;\n\n  function chanceToHit(\n    int32 attackersAttackRating,\n    int32 defendersDefenceRating,\n    int32 attackersLevel,\n    int32 defendersLevel,\n    int32 arFactor\n  ) external pure returns (uint) {\n    return StatLib.chanceToHit(\n      attackersAttackRating.toUint(),\n      defendersDefenceRating.toUint(),\n      attackersLevel.toUint(),\n      defendersLevel.toUint(),\n      arFactor.toUint()\n    );\n  }\n\n  function levelExperience(uint32 level) external pure returns (uint) {\n    return StatLib.levelExperience(level);\n  }\n\n  function minDamage(int32 strength, uint heroClass) external pure returns (int32) {\n    return StatLib.minDamage(strength, heroClass);\n  }\n\n  function experienceToLvl(uint exp, uint startFromLevel) external pure returns (uint) {\n    return StatLib.experienceToLvl(exp, startFromLevel);\n  }\n\n  function startHeroAttributes(uint heroClass) external pure returns (\n    IStatController.CoreAttributes memory,\n    StatLib.BaseMultiplier memory,\n    StatLib.LevelUp memory\n  ) {\n    StatLib.InitialHero memory h = StatLib.initialHero(heroClass);\n    return (h.core, h.multiplier, h.levelUp);\n  }\n\n  function baseLifeChances(uint heroClass) external pure returns(int32) {\n    return StatLib.initialHero(heroClass).baseLifeChances;\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.gasEstimates",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}