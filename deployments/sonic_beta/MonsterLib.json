{
  "address": "0x69d45bb1F4237b5A6fFe12Bca3Db0EeE2d06bB2D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "atype",
          "type": "uint256"
        }
      ],
      "name": "NotAType",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotMagic",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotYourAttackItem",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotYourBuffItem",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotYourDebuffItem",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "chance",
          "type": "uint32"
        }
      ],
      "name": "TooHighChance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "TooHighValue",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        }
      ],
      "name": "TooLowX",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "attackType",
          "type": "uint256"
        }
      ],
      "name": "UnknownAttackType",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "components": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int32[]",
                      "name": "fighterAttributes",
                      "type": "int32[]"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint32",
                          "name": "level",
                          "type": "uint32"
                        },
                        {
                          "internalType": "uint32",
                          "name": "experience",
                          "type": "uint32"
                        },
                        {
                          "internalType": "uint32",
                          "name": "life",
                          "type": "uint32"
                        },
                        {
                          "internalType": "uint32",
                          "name": "mana",
                          "type": "uint32"
                        },
                        {
                          "internalType": "uint32",
                          "name": "lifeChances",
                          "type": "uint32"
                        }
                      ],
                      "internalType": "struct IStatController.ChangeableStats",
                      "name": "fighterStats",
                      "type": "tuple"
                    },
                    {
                      "internalType": "enum IFightCalculator.AttackType",
                      "name": "attackType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "attackToken",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "attackTokenId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "race",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IFightCalculator.FighterInfo",
                  "name": "info",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "enum IItemController.AttackType",
                      "name": "aType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "int32",
                      "name": "min",
                      "type": "int32"
                    },
                    {
                      "internalType": "int32",
                      "name": "max",
                      "type": "int32"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int32",
                          "name": "strength",
                          "type": "int32"
                        },
                        {
                          "internalType": "int32",
                          "name": "dexterity",
                          "type": "int32"
                        },
                        {
                          "internalType": "int32",
                          "name": "vitality",
                          "type": "int32"
                        },
                        {
                          "internalType": "int32",
                          "name": "energy",
                          "type": "int32"
                        }
                      ],
                      "internalType": "struct IStatController.CoreAttributes",
                      "name": "attributeFactors",
                      "type": "tuple"
                    }
                  ],
                  "internalType": "struct IItemController.AttackInfo",
                  "name": "magicAttack",
                  "type": "tuple"
                },
                {
                  "internalType": "int32",
                  "name": "health",
                  "type": "int32"
                },
                {
                  "internalType": "int32",
                  "name": "manaConsumed",
                  "type": "int32"
                },
                {
                  "internalType": "int32",
                  "name": "damage",
                  "type": "int32"
                },
                {
                  "internalType": "int32",
                  "name": "damagePoison",
                  "type": "int32"
                },
                {
                  "internalType": "int32",
                  "name": "damageReflect",
                  "type": "int32"
                },
                {
                  "components": [
                    {
                      "internalType": "bool",
                      "name": "stun",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "burn",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "freeze",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "confuse",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "curse",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "poison",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "gotCriticalHit",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "missed",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "hitBlocked",
                      "type": "bool"
                    }
                  ],
                  "internalType": "struct IFightCalculator.Statuses",
                  "name": "statuses",
                  "type": "tuple"
                }
              ],
              "internalType": "struct IFightCalculator.Fighter",
              "name": "fighterA",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "int32[]",
                      "name": "fighterAttributes",
                      "type": "int32[]"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint32",
                          "name": "level",
                          "type": "uint32"
                        },
                        {
                          "internalType": "uint32",
                          "name": "experience",
                          "type": "uint32"
                        },
                        {
                          "internalType": "uint32",
                          "name": "life",
                          "type": "uint32"
                        },
                        {
                          "internalType": "uint32",
                          "name": "mana",
                          "type": "uint32"
                        },
                        {
                          "internalType": "uint32",
                          "name": "lifeChances",
                          "type": "uint32"
                        }
                      ],
                      "internalType": "struct IStatController.ChangeableStats",
                      "name": "fighterStats",
                      "type": "tuple"
                    },
                    {
                      "internalType": "enum IFightCalculator.AttackType",
                      "name": "attackType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "attackToken",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "attackTokenId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "race",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IFightCalculator.FighterInfo",
                  "name": "info",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "enum IItemController.AttackType",
                      "name": "aType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "int32",
                      "name": "min",
                      "type": "int32"
                    },
                    {
                      "internalType": "int32",
                      "name": "max",
                      "type": "int32"
                    },
                    {
                      "components": [
                        {
                          "internalType": "int32",
                          "name": "strength",
                          "type": "int32"
                        },
                        {
                          "internalType": "int32",
                          "name": "dexterity",
                          "type": "int32"
                        },
                        {
                          "internalType": "int32",
                          "name": "vitality",
                          "type": "int32"
                        },
                        {
                          "internalType": "int32",
                          "name": "energy",
                          "type": "int32"
                        }
                      ],
                      "internalType": "struct IStatController.CoreAttributes",
                      "name": "attributeFactors",
                      "type": "tuple"
                    }
                  ],
                  "internalType": "struct IItemController.AttackInfo",
                  "name": "magicAttack",
                  "type": "tuple"
                },
                {
                  "internalType": "int32",
                  "name": "health",
                  "type": "int32"
                },
                {
                  "internalType": "int32",
                  "name": "manaConsumed",
                  "type": "int32"
                },
                {
                  "internalType": "int32",
                  "name": "damage",
                  "type": "int32"
                },
                {
                  "internalType": "int32",
                  "name": "damagePoison",
                  "type": "int32"
                },
                {
                  "internalType": "int32",
                  "name": "damageReflect",
                  "type": "int32"
                },
                {
                  "components": [
                    {
                      "internalType": "bool",
                      "name": "stun",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "burn",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "freeze",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "confuse",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "curse",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "poison",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "gotCriticalHit",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "missed",
                      "type": "bool"
                    },
                    {
                      "internalType": "bool",
                      "name": "hitBlocked",
                      "type": "bool"
                    }
                  ],
                  "internalType": "struct IFightCalculator.Statuses",
                  "name": "statuses",
                  "type": "tuple"
                }
              ],
              "internalType": "struct IFightCalculator.Fighter",
              "name": "fighterB",
              "type": "tuple"
            }
          ],
          "indexed": false,
          "internalType": "struct IFightCalculator.FightInfoInternal",
          "name": "result",
          "type": "tuple"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "int32[]",
                  "name": "fighterAttributes",
                  "type": "int32[]"
                },
                {
                  "components": [
                    {
                      "internalType": "uint32",
                      "name": "level",
                      "type": "uint32"
                    },
                    {
                      "internalType": "uint32",
                      "name": "experience",
                      "type": "uint32"
                    },
                    {
                      "internalType": "uint32",
                      "name": "life",
                      "type": "uint32"
                    },
                    {
                      "internalType": "uint32",
                      "name": "mana",
                      "type": "uint32"
                    },
                    {
                      "internalType": "uint32",
                      "name": "lifeChances",
                      "type": "uint32"
                    }
                  ],
                  "internalType": "struct IStatController.ChangeableStats",
                  "name": "fighterStats",
                  "type": "tuple"
                },
                {
                  "internalType": "enum IFightCalculator.AttackType",
                  "name": "attackType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "attackToken",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "attackTokenId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "race",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFightCalculator.FighterInfo",
              "name": "fighterA",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "int32[]",
                  "name": "fighterAttributes",
                  "type": "int32[]"
                },
                {
                  "components": [
                    {
                      "internalType": "uint32",
                      "name": "level",
                      "type": "uint32"
                    },
                    {
                      "internalType": "uint32",
                      "name": "experience",
                      "type": "uint32"
                    },
                    {
                      "internalType": "uint32",
                      "name": "life",
                      "type": "uint32"
                    },
                    {
                      "internalType": "uint32",
                      "name": "mana",
                      "type": "uint32"
                    },
                    {
                      "internalType": "uint32",
                      "name": "lifeChances",
                      "type": "uint32"
                    }
                  ],
                  "internalType": "struct IStatController.ChangeableStats",
                  "name": "fighterStats",
                  "type": "tuple"
                },
                {
                  "internalType": "enum IFightCalculator.AttackType",
                  "name": "attackType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "attackToken",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "attackTokenId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "race",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IFightCalculator.FighterInfo",
              "name": "fighterB",
              "type": "tuple"
            },
            {
              "internalType": "uint64",
              "name": "dungeonId",
              "type": "uint64"
            },
            {
              "internalType": "uint32",
              "name": "objectId",
              "type": "uint32"
            },
            {
              "internalType": "address",
              "name": "heroAdr",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "heroId",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "stageId",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "iteration",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "turn",
              "type": "uint8"
            }
          ],
          "indexed": false,
          "internalType": "struct IFightCalculator.FightCall",
          "name": "callData",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "iteration",
          "type": "uint256"
        }
      ],
      "name": "FightResultProcessed",
      "type": "event"
    }
  ],
  "transactionHash": "0x4629b46b36b8052a4a71ec8cec4d3be3a868315512ef78c27828e6435b43f38e",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0x69d45bb1F4237b5A6fFe12Bca3Db0EeE2d06bB2D",
    "transactionIndex": 4,
    "gasUsed": "4898422",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0000559c00002e0c2fe56b6b7c5954a60654fee1218270c42a4d06cb7d511743",
    "transactionHash": "0x4629b46b36b8052a4a71ec8cec4d3be3a868315512ef78c27828e6435b43f38e",
    "logs": [],
    "blockNumber": 47270916,
    "cumulativeGasUsed": "4982422",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 17,
  "solcInputHash": "ab128610a613a12ee3464e154c92869f",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atype\",\"type\":\"uint256\"}],\"name\":\"NotAType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMagic\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotYourAttackItem\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotYourBuffItem\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotYourDebuffItem\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"chance\",\"type\":\"uint32\"}],\"name\":\"TooHighChance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TooHighValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"TooLowX\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"attackType\",\"type\":\"uint256\"}],\"name\":\"UnknownAttackType\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"int32[]\",\"name\":\"fighterAttributes\",\"type\":\"int32[]\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"life\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"mana\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lifeChances\",\"type\":\"uint32\"}],\"internalType\":\"struct IStatController.ChangeableStats\",\"name\":\"fighterStats\",\"type\":\"tuple\"},{\"internalType\":\"enum IFightCalculator.AttackType\",\"name\":\"attackType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"attackToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"attackTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"race\",\"type\":\"uint256\"}],\"internalType\":\"struct IFightCalculator.FighterInfo\",\"name\":\"info\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum IItemController.AttackType\",\"name\":\"aType\",\"type\":\"uint8\"},{\"internalType\":\"int32\",\"name\":\"min\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"max\",\"type\":\"int32\"},{\"components\":[{\"internalType\":\"int32\",\"name\":\"strength\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"dexterity\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"vitality\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"energy\",\"type\":\"int32\"}],\"internalType\":\"struct IStatController.CoreAttributes\",\"name\":\"attributeFactors\",\"type\":\"tuple\"}],\"internalType\":\"struct IItemController.AttackInfo\",\"name\":\"magicAttack\",\"type\":\"tuple\"},{\"internalType\":\"int32\",\"name\":\"health\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaConsumed\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"damage\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"damagePoison\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"damageReflect\",\"type\":\"int32\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"stun\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"burn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"freeze\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"confuse\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"curse\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"poison\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"gotCriticalHit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"missed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hitBlocked\",\"type\":\"bool\"}],\"internalType\":\"struct IFightCalculator.Statuses\",\"name\":\"statuses\",\"type\":\"tuple\"}],\"internalType\":\"struct IFightCalculator.Fighter\",\"name\":\"fighterA\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"int32[]\",\"name\":\"fighterAttributes\",\"type\":\"int32[]\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"life\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"mana\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lifeChances\",\"type\":\"uint32\"}],\"internalType\":\"struct IStatController.ChangeableStats\",\"name\":\"fighterStats\",\"type\":\"tuple\"},{\"internalType\":\"enum IFightCalculator.AttackType\",\"name\":\"attackType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"attackToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"attackTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"race\",\"type\":\"uint256\"}],\"internalType\":\"struct IFightCalculator.FighterInfo\",\"name\":\"info\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum IItemController.AttackType\",\"name\":\"aType\",\"type\":\"uint8\"},{\"internalType\":\"int32\",\"name\":\"min\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"max\",\"type\":\"int32\"},{\"components\":[{\"internalType\":\"int32\",\"name\":\"strength\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"dexterity\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"vitality\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"energy\",\"type\":\"int32\"}],\"internalType\":\"struct IStatController.CoreAttributes\",\"name\":\"attributeFactors\",\"type\":\"tuple\"}],\"internalType\":\"struct IItemController.AttackInfo\",\"name\":\"magicAttack\",\"type\":\"tuple\"},{\"internalType\":\"int32\",\"name\":\"health\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaConsumed\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"damage\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"damagePoison\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"damageReflect\",\"type\":\"int32\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"stun\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"burn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"freeze\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"confuse\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"curse\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"poison\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"gotCriticalHit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"missed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hitBlocked\",\"type\":\"bool\"}],\"internalType\":\"struct IFightCalculator.Statuses\",\"name\":\"statuses\",\"type\":\"tuple\"}],\"internalType\":\"struct IFightCalculator.Fighter\",\"name\":\"fighterB\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct IFightCalculator.FightInfoInternal\",\"name\":\"result\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"int32[]\",\"name\":\"fighterAttributes\",\"type\":\"int32[]\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"life\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"mana\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lifeChances\",\"type\":\"uint32\"}],\"internalType\":\"struct IStatController.ChangeableStats\",\"name\":\"fighterStats\",\"type\":\"tuple\"},{\"internalType\":\"enum IFightCalculator.AttackType\",\"name\":\"attackType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"attackToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"attackTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"race\",\"type\":\"uint256\"}],\"internalType\":\"struct IFightCalculator.FighterInfo\",\"name\":\"fighterA\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int32[]\",\"name\":\"fighterAttributes\",\"type\":\"int32[]\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"life\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"mana\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lifeChances\",\"type\":\"uint32\"}],\"internalType\":\"struct IStatController.ChangeableStats\",\"name\":\"fighterStats\",\"type\":\"tuple\"},{\"internalType\":\"enum IFightCalculator.AttackType\",\"name\":\"attackType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"attackToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"attackTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"race\",\"type\":\"uint256\"}],\"internalType\":\"struct IFightCalculator.FighterInfo\",\"name\":\"fighterB\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"dungeonId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"heroAdr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"stageId\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"turn\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct IFightCalculator.FightCall\",\"name\":\"callData\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"}],\"name\":\"FightResultProcessed\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"action(IGOC.ActionContext,IGOC.MonsterInfo storage)\":{\"details\":\"weird, but memory ctx is more efficient here than calldata ctx\",\"returns\":{\"result\":\"Fields objectId, heroToken, heroTokenId, iteration remain uninitialized here. Caller is responsible to set that values.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"action(IGOC.ActionContext,IGOC.MonsterInfo storage)\":{\"notice\":\"Fight, post fight, generate fight results\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lib/MonsterLib.sol\":\"MonsterLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":50},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IAppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\n/// @notice All errors of the app\\ninterface IAppErrors {\\n  error ZeroAddress();\\n  error ZeroValueNotAllowed();\\n  error LengthsMismatch();\\n  error NotEnoughBalance();\\n\\n  //region Restrictions\\n  error ErrorNotDeployer(address sender);\\n  error ErrorNotGoc();\\n  error NotGovernance(address sender);\\n  error ErrorOnlyEoa();\\n  error NotEOA(address sender);\\n  error ErrorForbidden(address sender);\\n  error ErrorNotItemController(address sender);\\n  error ErrorNotHeroController(address sender);\\n  error ErrorNotDungeonFactory(address sender);\\n  error ErrorNotObjectController(address sender);\\n  //endregion Restrictions\\n\\n  //region Hero\\n  error ErrorHeroIsNotRegistered(address heroToken);\\n  error ErrorHeroIsDead(address heroToken, uint heroTokenId);\\n  error ErrorHeroNotInDungeon();\\n  error HeroInDungeon();\\n  error ErrorNotHeroOwner(address heroToken, address msgSender);\\n  error Staked(address heroToken, uint heroId);\\n  error HeroTokensVaultAlreadySet();\\n  error NameTaken();\\n  error TooBigName();\\n  error WrongSymbolsInTheName();\\n  error NoPayToken(address token, uint payTokenAmount);\\n  error AlreadyHaveReinforcement();\\n  //endregion Hero\\n\\n  //region Dungeon\\n  error ErrorDungeonIsFreeAlready();\\n  error ErrorNoEligibleDungeons();\\n  error ErrorDungeonBusy();\\n  error ErrorNoDungeonsForBiome(uint8 heroBiome);\\n  error ErrorDungeonCompleted();\\n  error ErrorAlreadyInDungeon();\\n  error NotEnoughTokens(uint balance, uint expectedBalance);\\n  error DungeonAlreadySpecific(uint16 dungNum);\\n  error DungeonAlreadySpecific2(uint16 dungNum);\\n  error WrongSpecificDungeon();\\n  //endregion Dungeon\\n\\n  //region Items\\n  error ErrorItemNotEligibleForTheSlot(uint itemType, uint8 itemSlot);\\n  error ErrorItemSlotBusyHand(uint8 slot);\\n  error ErrorItemSlotBusy();\\n  error ErrorItemNotInSlot();\\n  error ErrorConsumableItemIsUsed(address item);\\n  error ErrorCannotRemoveItemFromMap();\\n  error ItemEquipped();\\n  error ZeroItemMetaType();\\n  error ZeroLevel();\\n  error ItemTypeChanged();\\n  error ItemMetaTypeChanged();\\n  error UnknownItem(address item);\\n  error ItemIsAlreadyEquipped(address item);\\n  error ErrorEquipForbidden();\\n  error EquipForbiddenInDungeon();\\n  error TakeOffForbiddenInDungeon();\\n  error Consumable(address item);\\n  error NotConsumable(address item);\\n  error Broken(address item);\\n  error ZeroLife();\\n  error RequirementsToItemAttributes();\\n  error NotEquipped(address item);\\n  error ZeroDurability();\\n  error ZeroAugmentation();\\n  error TooHighAgLevel(uint8 augmentationLevel);\\n  error UseForbiddenZeroPayToken();\\n  error IncorrectMinMaxAttributeRange(int32 min, int32 max);\\n  error SameIdsNotAllowed();\\n  //endregion Items\\n\\n  //region Stages\\n  error ErrorWrongStage(uint stage);\\n  error ErrorNotStages();\\n  //endregion Stages\\n\\n  //region Level\\n  error ErrorWrongLevel(uint heroLevel);\\n  error ErrorLevelTooLow(uint heroLevel);\\n  error ErrorHeroLevelStartFrom1();\\n  error ErrorWrongLevelUpSum();\\n  error ErrorMaxLevel();\\n  //endregion Level\\n\\n  //region Treasure\\n  error ErrorNotValidTreasureToken(address treasureToken);\\n  //endregion Treasure\\n\\n  //region State\\n  error ErrorPaused();\\n  error ErrorNotReady();\\n  error ErrorNotObject1();\\n  error ErrorNotObject2();\\n  error ErrorNotCompleted();\\n  //endregion State\\n\\n  //region Biome\\n  error ErrorNotBiome();\\n  error ErrorIncorrectBiome(uint biome);\\n  error TooHighBiome(uint biome);\\n  //endregion Biome\\n\\n  //region Misc\\n  error ErrorWrongMultiplier(uint multiplier);\\n  error ErrorNotEnoughMana(uint32 mana, uint requiredMana);\\n  error ErrorExperienceMustNotDecrease();\\n  error ErrorNotEnoughExperience();\\n  error ErrorNotChances();\\n  error ErrorNotEligible(address heroToken, uint16 dungNum);\\n  error ErrorZeroKarmaNotAllowed();\\n  //endregion Misc\\n\\n  //region GOC\\n  error GenObjectIdBiomeOverflow(uint8 biome);\\n  error GenObjectIdSubTypeOverflow(uint subType);\\n  error GenObjectIdIdOverflow(uint id);\\n  error UnknownObjectTypeGoc1(uint8 objectType);\\n  error UnknownObjectTypeGoc2(uint8 objectType);\\n  error UnknownObjectTypeGocLib1(uint8 objectType);\\n  error UnknownObjectTypeGocLib2(uint8 objectType);\\n  error UnknownObjectTypeForSubtype(uint8 objectSubType);\\n  error FightDelay();\\n  error ZeroChance();\\n  error TooHighChance(uint32 chance);\\n  error TooHighRandom(uint random);\\n  error EmptyObjects();\\n  error ObjectNotFound();\\n  error WrongGetObjectTypeInput();\\n  error WrongChances(uint32 chances, uint32 maxChances);\\n  //endregion GOC\\n\\n  //region Story\\n  error PageNotRemovedError(uint pageId);\\n  error NotItem1();\\n  error NotItem2();\\n  error NotRandom(uint32 random);\\n  error NotHeroData();\\n  error NotGlobalData();\\n  error ZeroStoryIdRemoveStory();\\n  error ZeroStoryIdStoryAction();\\n  error ZeroStoryIdAction();\\n  error NotEnoughAmount(uint balance, uint requiredAmount);\\n  error NotAnswer();\\n  error AnswerStoryIdMismatch(uint16 storyId, uint16 storyIdFromAnswerHash);\\n  error AnswerPageIdMismatch(uint16 pageId, uint16 pageIdFromAnswerHash);\\n  //endregion Story\\n\\n  //region FightLib\\n  error NotMagic();\\n  error NotAType(uint atype);\\n  //endregion FightLib\\n\\n  //region MonsterLib\\n  error NotYourDebuffItem();\\n  error UnknownAttackType(uint attackType);\\n  error NotYourAttackItem();\\n  error NotYourBuffItem();\\n  //endregion MonsterLib\\n\\n  //region GameToken\\n  error ApproveToZeroAddress();\\n  error MintToZeroAddress();\\n  error TransferToZeroAddress();\\n  error TransferAmountExceedsBalance(uint balance, uint value);\\n  error InsufficientAllowance();\\n  error BurnAmountExceedsBalance();\\n  error NotMinter(address sender);\\n  //endregion GameToken\\n\\n  //region NFT\\n  error TokenTransferNotAllowed();\\n  error IdOverflow(uint id);\\n  error NotExistToken(uint tokenId);\\n  error EquippedItemIsNotAllowedToTransfer(uint tokenId);\\n  //endregion NFT\\n\\n  //region CalcLib\\n  error TooLowX(uint x);\\n  //endregion CalcLib\\n\\n  //region Controller\\n  error NotFutureGovernance(address sender);\\n  //endregion Controller\\n\\n  //region Oracle\\n  error OracleWrongInput();\\n  //region Oracle\\n\\n  //region ReinforcementController\\n  error AlreadyStaked();\\n  error MaxFee(uint8 fee);\\n  error StakeHeroNotStats();\\n  error NotStaked();\\n  error NoStakedHeroes();\\n  //region ReinforcementController\\n\\n  //region SponsoredHero\\n  error InvalidHeroClass();\\n  error ZeroAmount();\\n  error InvalidProof();\\n  error NoHeroesAvailable();\\n  error AlreadyRegistered();\\n  //endregion SponsoredHero\\n\\n  //region SacraRelay\\n  error SacraRelayNotOwner();\\n  error SacraRelayNotDelegator();\\n  error SacraRelayNotOperator();\\n  error SacraRelayInvalidChainId(uint callChainId, uint blockChainId);\\n  error SacraRelayInvalidNonce(uint callNonce, uint txNonce);\\n  error SacraRelayDeadline();\\n  error SacraRelayDelegationExpired();\\n  error SacraRelayNotAllowed();\\n  error SacraRelayInvalidSignature();\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error by selector, see tests\\n  error SacraRelayNoErrorSelector(bytes4 selector, string tracingInfo);\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error manually from {errorBytes} as following:\\n  /// if (keccak256(abi.encodeWithSignature(\\\"MyError()\\\")) == keccak256(errorBytes)) { ... }\\n  error SacraRelayUnexpectedReturnData(bytes errorBytes, string tracingInfo);\\n  error SacraRelayCallToNotContract(address notContract, string tracingInfo);\\n  //endregion SacraRelay\\n\\n  //region Misc\\n  error UnknownHeroClass(uint heroClass);\\n  error AbsDiff(int32 a, int32 b);\\n  //region Misc\\n}\\n\",\"keccak256\":\"0xc27d17dbfa76c8ebb21557d83e2ca966cfdf23bff69d6f632c0bf000ec6614b6\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IApplicationEvents.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IDungeonFactory.sol\\\";\\nimport \\\"./IStoryController.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\n\\n/// @notice All events of the app\\ninterface IApplicationEvents {\\n\\n  //region ------------------ StatController\\n  event HeroItemSlotChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint itemType,\\n    uint itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip,\\n    address caller\\n  );\\n  event CurrentStatsChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats change,\\n    bool increase,\\n    address caller\\n  );\\n  event BonusAttributesChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    bool add,\\n    bool temporally,\\n    address caller\\n  );\\n  event TemporallyAttributesCleared(address heroToken, uint heroTokenId, address caller);\\n  event NewHeroInited(address heroToken, uint heroTokenId, IStatController.ChangeableStats stats);\\n  event LevelUp(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes change\\n  );\\n  event ConsumableUsed(address heroToken, uint heroTokenId, address item);\\n  event RemoveConsumableUsage(address heroToken, uint heroTokenId, address item);\\n  event HeroCustomDataChanged(address token, uint tokenId, bytes32 index, uint value);\\n  event GlobalCustomDataChanged(bytes32 index, uint value);\\n  //endregion ------------------ StatController\\n\\n  //region ------------------ DungeonFactoryController\\n  event DungeonLaunched(\\n    uint16 dungeonLogicNum,\\n    uint64 dungeonId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken,\\n    uint treasuryAmount\\n  );\\n\\n  event BossCompleted(uint32 objectId, uint biome, address hero, uint heroId);\\n  event FreeDungeonAdded(uint8 biome, uint64 dungeonId);\\n\\n  event ObjectOpened(uint64 dungId, address hero, uint id, uint32 objId, uint iteration, uint currentStage);\\n  event Clear(uint64 dungId);\\n\\n  event DungeonLogicRegistered(uint16 dungLogicId, IDungeonFactory.DungeonGenerateInfo info);\\n  event DungeonLogicRemoved(uint16 dungLogicId);\\n  event DungeonSpecificLogicRegistered(uint16 dungLogicId, uint biome, uint heroCls);\\n  event DungeonSpecificLogicRemoved(uint16 dungLogicId, uint heroLvl, uint heroCls);\\n  event DungeonRegistered(uint16 dungLogicId, uint64 dungeonId);\\n  event DungeonRemoved(uint16 dungLogicId, uint64 dungeonId);\\n  event MinLevelForTreasuryChanged(address token, uint level);\\n\\n  event ObjectAction(\\n    uint64 dungId,\\n    IGOC.ActionResult result,\\n    uint currentStage,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint newStage\\n  );\\n  /// @notice On add the item to the dungeon\\n  event AddTreasuryItem(uint64 dungId, address itemAdr, uint itemId);\\n  event AddTreasuryToken(uint64 dungId, address token, uint amount);\\n  event ClaimToken(uint64 dungId, address token, uint amount);\\n  event ClaimItem(uint64 dungId, address token, uint id);\\n\\n  event Entered(uint64 dungId, address hero, uint id);\\n  event DungeonCompleted(uint16 dungLogicNum, uint64 dungId, address hero, uint heroId);\\n  event Exit(uint64 dungId, bool claim);\\n  event FreeDungeonRemoved(uint8 biome, uint64 dungeonId);\\n  event HeroCurrentDungeonChanged(address hero, uint heroId, uint64 dungeonId);\\n  //endregion ------------------ DungeonFactoryController\\n\\n  //region ------------------ GameObjectController\\n  event EventRegistered(uint32 objectId, IGOC.EventRegInfo eventRegInfo);\\n  event StoryRegistered(uint32 objectId, uint16 storyId);\\n  event MonsterRegistered(uint32 objectId, IGOC.MonsterGenInfo monsterGenInfo);\\n  event ObjectRemoved(uint32 objectId);\\n  event ObjectResultEvent(\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    IGOC.ObjectType objectType,\\n    address hero,\\n    uint heroId,\\n    uint8 stageId,\\n    uint iteration,\\n    bytes data,\\n    IGOC.ActionResult result,\\n    uint salt\\n  );\\n  //endregion ------------------ GameObjectController\\n\\n  //region ------------------ StoryController\\n  event SetBurnItemsMeta(uint storyId, IStoryController.AnswerBurnRandomItemMeta meta);\\n  event SetNextObjRewriteMeta(uint storyId, IStoryController.NextObjRewriteMeta meta);\\n  event SetAnswersMeta(uint storyId, uint16[] answerPageIds, uint8[] answerHeroClasses, uint16[] answerIds);\\n  event SetAnswerNextPageMeta(uint storyId, IStoryController.AnswerNextPageMeta meta);\\n  event SetAnswerAttributeRequirements(uint storyId, IStoryController.AnswerAttributeRequirementsMeta meta);\\n  event SetAnswerItemRequirements(uint storyId, IStoryController.AnswerItemRequirementsMeta meta);\\n  event SetAnswerTokenRequirementsMeta(uint storyId, IStoryController.AnswerTokenRequirementsMeta meta);\\n  event SetAnswerAttributes(uint storyId, IStoryController.AnswerAttributesMeta meta);\\n  event SetAnswerHeroCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetAnswerGlobalCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetSuccessInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetFailInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetCustomDataResult(uint storyId, IStoryController.AnswerCustomDataResultMeta meta, IStoryController.CustomDataResult _type);\\n  event StoryCustomDataRequirements(uint storyId, bytes32 requiredCustomDataIndex, uint requiredCustomDataMinValue, uint requiredCustomDataMaxValue, bool requiredCustomDataIsHero);\\n  event StoryRequiredLevel(uint storyId, uint requiredLevel);\\n  event StoryFinalized(uint32 objectId, uint storyId);\\n  event StoryRemoved(uint32 objectId, uint storyId);\\n\\n  event ItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event NotEquippedItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event StoryChangeAttributes(\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    uint stageId,\\n    uint iteration,\\n    int32[] attributes\\n  );\\n  //endregion ------------------ StoryController\\n\\n  //region ------------------------ HeroController\\n  event HeroTokensVaultSet(address value);\\n  event HeroRegistered(address hero, uint8 heroClass, address payToken, uint payAmount);\\n  event HeroCreated(address hero, uint heroId, string name, address owner, string refCode);\\n  event BiomeChanged(address hero, uint heroId, uint8 biome);\\n  event LevelUp(address hero, uint heroId, address owner, IStatController.CoreAttributes change);\\n  event ReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event ReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event Killed(address hero, uint heroId, address killer, bytes32[] dropItems, uint dropTokenAmount);\\n  //endregion ------------------------ HeroController\\n\\n  //region ------------------------ FightLib\\n  event FightResultProcessed(\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    IFightCalculator.FightCall callData,\\n    uint iteration\\n  );\\n  //endregion ------------------------ FightLib\\n\\n  //region ------------------------ Oracle\\n  event Random(uint number, uint max);\\n  //endregion ------------------------ Oracle\\n\\n  //region ------------------------ Controller\\n  event OfferGovernance(address newGov);\\n  event GovernanceAccepted(address gov);\\n  event StatControllerChanged(address value);\\n  event StoryControllerChanged(address value);\\n  event GameObjectControllerChanged(address value);\\n  event ReinforcementControllerChanged(address value);\\n  event OracleChanged(address value);\\n  event TreasuryChanged(address value);\\n  event ItemControllerChanged(address value);\\n  event HeroControllerChanged(address value);\\n  event GameTokenChanged(address value);\\n  event DungeonFactoryChanged(address value);\\n  event ProxyUpdated(address proxy, address logic);\\n  event Claimed(address token, uint amount);\\n  event TokenStatusChanged(address token, bool status);\\n  //endregion ------------------------ Controller\\n\\n  //region ------------------------ HeroTokensVault\\n  event Process(address token, uint amount, address from, uint toBurn, uint toTreasury, uint toGov);\\n  //endregion ------------------------ HeroTokensVault\\n\\n  //region ------------------------ ReinforcementController\\n  event HeroStaked(address heroToken, uint heroId, uint biome, uint score);\\n  event HeroWithdraw(address heroToken, uint heroId);\\n  event HeroAsk(address heroToken, uint heroId);\\n  event TokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint totalAmount);\\n  event NftRewardRegistered(address heroToken, uint heroId, address token, uint id);\\n  event ToHelperRatioChanged(uint value);\\n  event ClaimedToken(address heroToken, uint heroId, address token, uint amount, address recipient);\\n  event ClaimedItem(address heroToken, uint heroId, address item, uint itemId, address recipient);\\n  event MinLevelChanged(uint8 value);\\n  event MinLifeChancesChanged(uint value);\\n  //endregion ------------------------ ReinforcementController\\n\\n  //region ------------------------ Treasury\\n  event AssetsSentToDungeon(address dungeon, address token, uint amount);\\n  //endregion ------------------------ Treasury\\n\\n  //region ------------------------ EventLib\\n  event EventResult(uint64 dungeonId, address heroToken, uint heroTokenId, uint8 stageId, IStatController.ActionInternalInfo gen, uint iteration);\\n  //endregion ------------------------ EventLib\\n\\n  //region ------------------------ ItemStatsLib\\n  event ItemRegistered(address item, IItemController.RegisterItemParams info);\\n  event ItemRemoved(address item);\\n  event NewItemMinted(address item, uint itemId, IItemController.MintInfo info);\\n  event Equipped(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot);\\n  event TakenOff(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot, address destination);\\n  event ItemRepaired(address item, uint itemId, uint consumedItemId, uint16 baseDurability);\\n  event Augmented(address item, uint itemId, uint consumedItemId, uint8 augLevel, IItemController.AugmentInfo info);\\n  event NotAugmented(address item, uint itemId, uint consumedItemId, uint8 augLevel);\\n  event ReduceDurability(address item, uint itemId, uint newDurability);\\n  event Used(address item, uint tokenId, address heroToken, uint heroTokenId);\\n  event Destroyed(address item, uint itemId);\\n  //endregion ------------------------ ItemStatsLib\\n\\n  //region ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n  event ChangePauseStatus(bool value);\\n  event MinterChanged(address value);\\n\\n  event UniqueUriChanged(uint id, string uri);\\n  event BaseUriChanged(string uri);\\n\\n  event HeroMinted(uint heroId);\\n  event HeroBurned(uint heroId);\\n  event HeroUriByStatusChanged(string uri, uint statusLvl);\\n\\n  event ItemMinted(uint tokenId);\\n  event ItemBurned(uint tokenId);\\n  event UriByRarityChanged(string uri, uint rarity);\\n  event SponsoredHeroCreated(address msgSender, address heroAddress, uint heroId, string heroName);\\n  //endregion ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n}\\n\",\"keccak256\":\"0x59c0edaa6af913073e0555125fcde7caac611a153b6905a101d9373b49d76705\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IController {\\n\\n  function governance() external view returns (address);\\n\\n  function statController() external view returns (address);\\n\\n  function storyController() external view returns (address);\\n\\n  function gameObjectController() external view returns (address);\\n\\n  function reinforcementController() external view returns (address);\\n\\n  function oracle() external view returns (address);\\n\\n  function treasury() external view returns (address);\\n\\n  function itemController() external view returns (address);\\n\\n  function heroController() external view returns (address);\\n\\n  function dungeonFactory() external view returns (address);\\n\\n  function gameToken() external view returns (address);\\n\\n  function validTreasuryTokens(address token) external view returns (bool);\\n\\n  function isDeployer(address adr) external view returns (bool);\\n\\n  function onPause() external view returns (bool);\\n\\n}\\n\",\"keccak256\":\"0x277b18bde00efe407b007268d6a3b6524498d1616bf9ed9521980dd0048637dc\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDungeonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IDungeonFactory {\\n\\n  /// @custom:storage-location erc7201:dungeon.factory.main\\n  struct MainState {\\n    /// @dev biome => dungeonLaunchedId\\n    mapping(uint => EnumerableSet.UintSet) freeDungeons;\\n    /// @dev hero + heroId + biome (packMapObject) -> completed\\n    mapping(bytes32 => bool) bossCompleted;\\n    /// @dev hero + heroId + dungNum (packDungeonKey) -> completed\\n    mapping(bytes32 => bool) specificDungeonCompleted;\\n    /// @notice Max biome completed by the hero\\n    /// @dev hero + heroId (nftPacked) -> max biome completed\\n    mapping(bytes32 => uint8) maxBiomeCompleted;\\n    /// @notice which dungeon the hero is currently in\\n    /// @dev hero+id => current DungeonId\\n    mapping(bytes32 => uint64) heroCurrentDungeon;\\n\\n    // ---\\n\\n    /// @notice Specific dungeon for the given pair of hero level + hero class\\n    ///         ALl specific dungeons are listed also in allSpecificDungeons\\n    /// @dev packUint8Array(specReqBiome, specReqHeroClass) => dungNum\\n    mapping(bytes32 => uint16) dungeonSpecific;\\n    /// @dev contains all specific dungNum for easy management\\n    EnumerableSet.UintSet allSpecificDungeons;\\n    /// @dev biome => dungNum\\n    mapping(uint8 => EnumerableSet.UintSet) dungeonsLogicByBiome;\\n\\n    // ---\\n\\n    /// @dev max available biome. auto-increment with new dung deploy\\n    uint8 maxBiome;\\n\\n    /// @notice Address of treasure token => min hero level required\\n    /// @dev manual threshold for treasury\\n    mapping(address => uint) minLevelForTreasury;\\n\\n    /// @notice Contains arrays for SKILL_1, SKILL_2, SKILL_3 with 0 or 1\\n    /// i.e. [0, 1, 0] means that durability of SKILL_2 should be reduced\\n    /// @dev hero + heroId => uint8[] array where idx = slotNum\\n    mapping(bytes32 => bytes32) skillSlotsForDurabilityReduction;\\n\\n    /// @notice Counter of dungeons, it's incremented on launch of a new dungeon\\n    uint64 dungeonCounter;\\n\\n    /// @dev dungNum = init attributes\\n    mapping(uint16 => DungeonAttributes) dungeonAttributes;\\n    /// @dev dungeonId => status\\n    mapping(uint64 => DungeonStatus) dungeonStatuses;\\n  }\\n\\n  struct ObjectGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    /// @dev uint8 types, packed using PackingLib.packUint8Array\\n    bytes32[] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    /// @dev uint64 chances\\n    uint32[][] objChancesByStages;\\n  }\\n\\n  struct DungeonGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    uint8[][] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    uint32[][] objChancesByStages;\\n\\n    uint32[] uniqObjects;\\n\\n    uint8 minLevel;\\n    uint8 maxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n  }\\n\\n  /// @notice Attributes of the given dungeon logic\\n  struct DungeonAttributes {\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    uint8 stages;\\n    uint8 biome;\\n\\n    /// @notice Default list of objects that should be passed in the dungeon\\n    uint32[] uniqObjects;\\n\\n    /// @dev min+max (packUint8Array)\\n    bytes32 minMaxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    /// @notice Packed DungeonGenerateInfo.requiredCustomData: MinValue, MaxValue, IsHero\\n    /// @dev min+max+isHero(packStoryCustomDataRequirements)\\n    bytes32[] requiredCustomDataValue;\\n\\n    ObjectGenerateInfo info;\\n  }\\n\\n  /// @notice Current status of the given dungeon\\n  struct DungeonStatus {\\n    uint64 dungeonId;\\n    /// @notice Dungeon logic id\\n    uint16 dungNum;\\n\\n    /// @notice True if the dungeon is completed by the hero\\n    bool isCompleted;\\n\\n    /// @notice Hero in the dungeon or 0\\n    address heroToken;\\n    uint heroTokenId;\\n    /// @notice Current object that should be passed by the hero. 0 - new object is not opened\\n    uint32 currentObject;\\n    /// @notice Current stage in the dungeon that should be passed by the hero.\\n    uint8 currentStage;\\n\\n    EnumerableMap.AddressToUintMap treasuryTokens;\\n    /// @notice All items that were minted on result of made actions\\n    bytes32[] treasuryItems;\\n\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    /// This value can be bigger than length of uniqObjects\\n    uint8 stages;\\n    /// @notice List of objects to be passed in the stage. The list can be dynamically changed during passing the stages\\n    uint32[] uniqObjects;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n\\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external returns (uint64 dungeonId);\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8);\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64);\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result);\\n\\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external;\\n\\n}\\n\",\"keccak256\":\"0x2f24028d35a06e44dc9bd096d8a1807cfa64518ebd73692a1cc479736814b741\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xa365c0e17de806f6262765ef6236512674ac8563a6ee3436e81cec7b1d87468e\",\"license\":\"MIT\"},\"contracts/interfaces/IFightCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface IFightCalculator {\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    MELEE, // 1\\n    MAGIC, // 2\\n    SLOT_3,\\n    SLOT_4,\\n    SLOT_5,\\n    SLOT_6,\\n    SLOT_7,\\n    SLOT_8,\\n    SLOT_9,\\n    SLOT_10\\n  }\\n\\n  /// @notice Attacker info: suitable both for hero and monsters\\n  struct AttackInfo {\\n    /// @notice Type of the attack\\n    /// by default, if attack token presents, it's magic attack and not-magic otherwise\\n    /// but this logic can become more complicated after introducing new attack types\\n    AttackType attackType;\\n    /// @notice NFT selected by hero for attack, it should be equip on.\\n    /// If attacker is a monster, this is a special case (stub NFT with zero ID is used)\\n    address attackToken;\\n    uint attackTokenId;\\n    address[] skillTokens;\\n    uint[] skillTokenIds;\\n  }\\n\\n  struct FighterInfo {\\n    int32[] fighterAttributes;\\n    IStatController.ChangeableStats fighterStats;\\n    AttackType attackType;\\n    address attackToken;\\n    uint attackTokenId;\\n    uint race;\\n  }\\n\\n  struct Statuses {\\n    bool stun;\\n    bool burn;\\n    bool freeze;\\n    bool confuse;\\n    bool curse;\\n    bool poison;\\n    bool gotCriticalHit;\\n    bool missed;\\n    bool hitBlocked;\\n  }\\n\\n  struct FightResult {\\n    int32 healthA;\\n    int32 healthB;\\n    int32 manaConsumedA;\\n    int32 manaConsumedB;\\n  }\\n\\n  struct FightCall {\\n    FighterInfo fighterA;\\n    FighterInfo fighterB;\\n    uint64 dungeonId;\\n    uint32 objectId;\\n    address heroAdr;\\n    uint heroId;\\n    uint8 stageId;\\n    uint iteration;\\n    uint8 turn;\\n  }\\n\\n  struct SkillSlots {\\n    bool slot1;\\n    bool slot2;\\n    bool slot3;\\n  }\\n\\n  //region ------------------------ FightLib-internal (FightInfoInternal is required by IApplicationEvents..)\\n  struct FightInfoInternal {\\n    Fighter fighterA;\\n    Fighter fighterB;\\n  }\\n\\n  struct Fighter {\\n    IFightCalculator.FighterInfo info;\\n    IItemController.AttackInfo magicAttack;\\n    int32 health;\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 damagePoison;\\n    int32 damageReflect;\\n    IFightCalculator.Statuses statuses;\\n  }\\n  //endregion ------------------------ FightLib-internal\\n\\n  function fight(FightCall memory callData) external returns (FightResult memory);\\n}\\n\",\"keccak256\":\"0xdf9ba809ea21a35a24eed12bf80e53452b0d772623d59211a35498b518eb604b\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGOC.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\n\\ninterface IGOC {\\n\\n  enum ObjectType {\\n    UNKNOWN, // 0\\n    EVENT, // 1\\n    MONSTER, // 2\\n    STORY, // 3\\n    END_SLOT\\n  }\\n\\n  enum ObjectSubType {\\n    UNKNOWN_0, // 0\\n    ENEMY_NPC_1, // 1\\n    ENEMY_NPC_SUPER_RARE_2, // 2\\n    BOSS_3, // 3\\n    SHRINE_4, // 4\\n    CHEST_5, // 5\\n    STORY_6, // 6\\n    STORY_UNIQUE_7, // 7\\n    SHRINE_UNIQUE_8, // 8\\n    CHEST_UNIQUE_9, // 9\\n    ENEMY_NPC_UNIQUE_10, // 10\\n    STORY_ON_ROAD_11, // 11\\n    STORY_UNDERGROUND_12, // 12\\n    STORY_NIGHT_CAMP_13, // 13\\n    STORY_MOUNTAIN_14, // 14\\n    STORY_WATER_15, // 15\\n    STORY_CASTLE_16, // 16\\n    STORY_HELL_17, // 17\\n    STORY_SPACE_18, // 18\\n    STORY_WOOD_19, // 19\\n    STORY_CATACOMBS_20, // 20\\n    STORY_BAD_HOUSE_21, // 21\\n    STORY_GOOD_TOWN_22, // 22\\n    STORY_BAD_TOWN_23, // 23\\n    STORY_BANDIT_CAMP_24, // 24\\n    STORY_BEAST_LAIR_25, // 25\\n    STORY_PRISON_26, // 26\\n    STORY_SWAMP_27, // 27\\n    STORY_INSIDE_28, // 28\\n    STORY_OUTSIDE_29, // 29\\n    STORY_INSIDE_RARE_30,\\n    STORY_OUTSIDE_RARE_31,\\n    ENEMY_NPC_INSIDE_32,\\n    ENEMY_NPC_INSIDE_RARE_33,\\n    ENEMY_NPC_OUTSIDE_34,\\n    ENEMY_NPC_OUTSIDE_RARE_35,\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:game.object.controller.main\\n  struct MainState {\\n\\n    /// @dev objId = biome(00) type(00) id(0000) => biome(uint8) + objType(uint8)\\n    /// Id is id of the event, story or monster.\\n    mapping(uint32 => bytes32) objectMeta;\\n\\n    /// @dev biome(uint8) + objType(uint8) => set of object id\\n    mapping(bytes32 => EnumerableSet.UintSet) objectIds;\\n\\n    /// @dev heroAdr180 + heroId64 + cType8 + biome8 => set of already played objects. Should be cleared periodically\\n    mapping(bytes32 => EnumerableSet.UintSet) playedObjects;\\n\\n    /// @dev HeroAdr(160) + heroId(uint64) + objId(uint32) => iteration count. It needs for properly emit events for every new entrance.\\n    mapping(bytes32 => uint) iterations;\\n\\n    /// @dev objId(uint32) => EventInfo\\n    mapping(uint32 => EventInfo) eventInfos;\\n\\n    /// @dev objId(uint32) => storyId\\n    mapping(uint32 => uint16) storyIds;\\n\\n    /// @dev objId(uint32) => MonsterInfo\\n    mapping(uint32 => MonsterInfo) monsterInfos;\\n\\n    /// @dev hero+id => last fight action timestamp\\n    mapping(bytes32 => uint) lastHeroFightTs;\\n\\n    /// @dev delay for user actions in fight (suppose to prevent bot actions)\\n    uint fightDelay;\\n  }\\n\\n  struct ActionResult {\\n    bool kill;\\n    bool completed;\\n    address heroToken;\\n    address[] mintItems;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n    uint32 objectId;\\n    uint32 experience;\\n    uint heroTokenId;\\n    uint iteration;\\n    uint32[] rewriteNextObject;\\n  }\\n\\n  struct EventInfo {\\n    /// @dev chance to use good or bad attributes/stats\\n    uint32 goodChance;\\n\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] goodAttributes;\\n    bytes32[] badAttributes;\\n\\n    /// @dev experience(uint32) + heal(int32) + manaRegen(int32) + lifeChancesRecovered(int32) + damage(int32) + manaConsume(int32) packStatsChange\\n    bytes32 statsChange;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n  }\\n\\n  struct MonsterInfo {\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] attributes;\\n    /// @dev level(uint8) + race(uint8) + experience(uint32) + maxDropItems(uint8) packMonsterStats\\n    bytes32 stats;\\n    /// @dev attackToken(160) + attackTokenId(uint64) + attackType(uint8) packAttackInfo\\n    bytes32 attackInfo;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n\\n    /// @dev heroAdr(160) + heroId(uint64) => iteration => GeneratedMonster packed\\n    mapping(bytes32 => mapping(uint => bytes32)) _generatedMonsters;\\n  }\\n\\n  struct MultiplierInfo {\\n    uint8 biome;\\n    uint totalSupply;\\n  }\\n\\n  struct GeneratedMonster {\\n    bool generated;\\n    uint8 turnCounter;\\n    int32 hp;\\n    uint32 amplifier;\\n  }\\n\\n  struct MonsterGenInfo {\\n    uint16 monsterId;\\n    uint8 biome;\\n    ObjectSubType subType;\\n\\n    uint8[] attributeIds;\\n    int32[] attributeValues;\\n\\n    uint8 level;\\n    uint8 race;\\n    uint32 experience;\\n    uint8 maxDropItems;\\n\\n    address attackToken;\\n    uint64 attackTokenId;\\n    uint8 attackType;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct ActionContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    uint8 biome;\\n    uint8 objectSubType;\\n    uint8 stageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint heroTokenId;\\n    uint salt;\\n    uint iteration;\\n    bytes data;\\n  }\\n\\n  struct EventRegInfo {\\n    uint8 biome;\\n    uint16 eventId;\\n    ObjectSubType subType;\\n\\n    uint32 goodChance;\\n\\n    AttributeGenerateInfo goodAttributes;\\n    AttributeGenerateInfo badAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct AttributeGenerateInfo {\\n    uint8[] ids;\\n    int32[] values;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev represent object registration if non zero values\\n  function getObjectMeta(uint32 objectId) external view returns (uint8 biome, uint8 objectSubType);\\n\\n  function isBattleObject(uint32 objectId) external view returns (bool);\\n\\n  function getRandomObject(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biomeLevel,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external returns (uint32 objectId);\\n\\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint iteration);\\n\\n  function action(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) external returns (ActionResult memory);\\n\\n}\\n\",\"keccak256\":\"0x6493b091bb99b51586b94064eea3eb60f5fa921c5a6f7e061b3c491a73b89a9e\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IHeroController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IHeroController {\\n\\n  /// @custom:storage-location erc7201:hero.controller.main\\n  struct MainState {\\n\\n    /// @dev A central place for all hero tokens\\n    address heroTokensVault;\\n\\n    /// @dev heroAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) payToken;\\n\\n    /// @dev heroAdr => heroCls8\\n    mapping(address => uint8) heroClass;\\n\\n    // ---\\n\\n    /// @dev hero+id => individual hero name\\n    mapping(bytes32 => string) heroName;\\n\\n    /// @dev name => hero+id, needs for checking uniq names\\n    mapping(string => bytes32) nameToHero;\\n\\n    // ---\\n\\n    /// @dev hero+id => biome\\n    mapping(bytes32 => uint8) heroBiome;\\n\\n    /// @dev hero+id => rein hero+id\\n    mapping(bytes32 => bytes32) reinforcementHero;\\n\\n    /// @dev hero+id => rein packed attributes\\n    mapping(bytes32 => bytes32[]) reinforcementHeroAttributes;\\n  }\\n\\n  function heroClass(address hero) external view returns (uint8);\\n\\n  function heroBiome(address hero, uint heroId) external view returns (uint8);\\n\\n  function payTokenInfo(address hero) external view returns (address token, uint amount);\\n\\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (address helperHeroToken, uint helperHeroId);\\n\\n  function score(address hero, uint heroId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool);\\n\\n  function heroTokensVault() external view returns (address);\\n\\n  // ---\\n\\n  function create(address hero, string memory heroName_, bool enter) external returns (uint);\\n\\n  function kill(address hero, uint heroId) external returns (bytes32[] memory dropItems);\\n\\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId);\\n\\n}\\n\",\"keccak256\":\"0x670ab48074f47c954a571035fb9abf04b193d524768b779047838e0990d39ef1\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItem.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IItem {\\n\\n  function isItem() external pure returns (bool);\\n\\n  function mintFor(address recipient) external returns (uint tokenId);\\n\\n  function burn(uint tokenId) external;\\n\\n  function controlledTransfer(address from, address to, uint tokenId) external;\\n}\\n\",\"keccak256\":\"0x766165af1a0ef65f8969414e165fdbc38294b5f249d280a3be272cbaa90721a7\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IItemController {\\n\\n  /// @custom:storage-location erc7201:item.controlbler.main\\n  struct MainState {\\n\\n    ////////////////// GENERATE //////////////////\\n\\n    EnumerableSet.AddressSet items;\\n\\n    /// @dev itemAdr => itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n    mapping(address => bytes32) itemMeta;\\n\\n    /// @dev itemAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) augmentInfo;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoAttributes;\\n\\n    // --- consumable ---\\n\\n    /// @dev itemAdr => ids+values (toBytes32ArrayWithIds)\\n    mapping(address => bytes32[]) _itemConsumableAttributes;\\n\\n    /// @dev itemAdr => IStatController.ChangeableStats packed int32[]\\n    mapping(address => bytes32) itemConsumableStats;\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoCasterAttributes;\\n\\n    /// @dev itemAdr => id8 + minDmg(int32) + maxDmg(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(address => bytes32) generateInfoAttack;\\n\\n    ////////////////// ITEMS INFO //////////////////\\n\\n    /// @dev itemAdr+id => itemRarity8 + augmentationLevel8 + itemDurability16\\n    mapping(bytes32 => bytes32) itemInfo;\\n\\n    /// @dev itemAdr+id => heroAdr+id\\n    mapping(bytes32 => bytes32) equippedOn;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemAttributes;\\n\\n    // --- consumable ---\\n\\n    // consumable stats unchangeable, get them by address\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemCasterAttributes;\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr+Id => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(bytes32 => bytes32) _itemAttackInfo;\\n\\n  }\\n\\n  struct RegisterItemParams {\\n    ItemMeta itemMeta;\\n    address augmentToken;\\n    uint augmentAmount;\\n    ItemGenerateInfo commonAttributes;\\n\\n    IGOC.AttributeGenerateInfo consumableAttributes;\\n    IStatController.ChangeableStats consumableStats;\\n\\n    ItemGenerateInfo casterAttributes;\\n    ItemGenerateInfo targetAttributes;\\n\\n    AttackInfo genAttackInfo;\\n  }\\n\\n  struct ItemGenerateInfo {\\n    /// @notice Attribute ids\\n    uint8[] ids;\\n    /// @notice Min value of the attribute, != 0\\n    int32[] mins;\\n    /// @notice Max value of the attribute, != 0\\n    int32[] maxs;\\n    /// @notice Chance of the selection [0..MAX_CHANCES]\\n    uint32[] chances;\\n  }\\n\\n  struct ItemMeta {\\n    uint8 itemMetaType;\\n    // Level in range 1-99. Reducing durability in low level dungeons. lvl/5+1 = biome\\n    uint8 itemLevel;\\n    IItemController.ItemType itemType;\\n    uint16 baseDurability;\\n    uint8 defaultRarity;\\n    uint32 manaCost;\\n\\n    // it doesn't include positions with 100% chance\\n    uint8 minRandomAttributes;\\n    uint8 maxRandomAttributes;\\n\\n    IStatController.CoreAttributes requirements;\\n  }\\n\\n  enum FeeType {\\n    UNKNOWN,\\n    REPAIR,\\n    AUGMENT,\\n    STORY,\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemRarity {\\n    UNKNOWN, // 0\\n    NORMAL, // 1\\n    MAGIC, // 2\\n    RARE, // 3\\n    SET, // 4\\n    UNIQUE, // 5\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemType {\\n    NO_SLOT, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    RING, // 6\\n    OFF_HAND, // 7\\n    BOOTS, // 8\\n    ONE_HAND, // 9\\n    TWO_HAND, // 10\\n    SKILL, // 11\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemMetaType {\\n    UNKNOWN, // 0\\n    COMMON, // 1\\n    ATTACK, // 2\\n    BUFF, // 3\\n    CONSUMABLE, // 4\\n\\n    END_SLOT\\n  }\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    FIRE, // 1\\n    COLD, // 2\\n    LIGHTNING, // 3\\n    CHAOS, // 4\\n\\n    END_SLOT\\n  }\\n\\n  struct AttackInfo {\\n    AttackType aType;\\n    int32 min;\\n    int32 max;\\n    // if not zero - activate attribute factor for the attribute\\n    IStatController.CoreAttributes attributeFactors;\\n  }\\n\\n  struct ItemInfo {\\n    ItemRarity rarity;\\n    uint8 augmentationLevel;\\n    uint16 durability;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct MintInfo {\\n    IItemController.ItemMeta meta;\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.ItemRarity itemRarity;\\n\\n    IItemController.AttackInfo attackInfo;\\n\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct AugmentInfo {\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.AttackInfo attackInfo;\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function itemMeta(address item) external view returns (ItemMeta memory meta);\\n\\n  function augmentInfo(address item) external view returns (address token, uint amount);\\n\\n  function genAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genCasterAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genTargetAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genAttackInfo(address item) external view returns (AttackInfo memory info);\\n\\n  function itemInfo(address item, uint itemId) external view returns (ItemInfo memory info);\\n\\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId);\\n\\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats);\\n\\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function itemAttackInfo(address item, uint itemId) external view returns (AttackInfo memory info);\\n\\n  function score(address item, uint tokenId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address item, uint tokenId) external view returns (bool);\\n\\n  // ---\\n\\n  function mint(address item, address recipient) external returns (uint itemId);\\n\\n  function reduceDurability(address hero, uint heroId, uint8 biome) external;\\n\\n  function destroy(address item, uint tokenId) external;\\n\\n  function takeOffDirectly(\\n    address item,\\n    uint itemId,\\n    address hero,\\n    uint heroId,\\n    uint8 itemSlot,\\n    address destination,\\n    bool broken\\n  ) external;\\n}\\n\",\"keccak256\":\"0x36d2a1f44e3f2308ea27ca7579d40f374efd27e8eca1737253c7b1598313d3f7\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IOracle {\\n\\n  function getRandomNumber(uint max, uint seed) external returns (uint);\\n\\n  function getRandomNumberInRange(uint min, uint max, uint seed) external returns (uint);\\n\\n}\\n\",\"keccak256\":\"0x75a2bed27cbd9be6c76b6f3e941ee5f6f55380f61cd867254a0c766fc3b71976\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStatController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStatController {\\n\\n  /// @custom:storage-location erc7201:stat.controller.main\\n  struct MainState {\\n    mapping(bytes32 => bytes32[]) heroTotalAttributes;\\n    /// @dev heroAdr+heroId => int32 packed strength, dexterity, vitality, energy\\n    mapping(bytes32 => bytes32) _heroCore;\\n    mapping(bytes32 => bytes32[]) heroBonusAttributes;\\n    mapping(bytes32 => bytes32[]) heroTemporallyAttributes;\\n    /// @dev heroAdr+heroId => uint32 packed level, experience, life, mana, lifeChances\\n    mapping(bytes32 => bytes32) heroStats;\\n    /// @dev heroAdr+heroId+itemSlot => itemAdr + itemId\\n    mapping(bytes32 => bytes32) heroSlots;\\n    /// @dev heroAdr+heroId => busy slots uint8[] packed\\n    mapping(bytes32 => bytes32) heroBusySlots;\\n    mapping(bytes32 => EnumerableSet.AddressSet) usedConsumables;\\n    mapping(bytes32 => mapping(bytes32 => uint)) heroCustomData;\\n    mapping(bytes32 => uint) globalCustomData;\\n  }\\n\\n\\n  enum ATTRIBUTES {\\n    // core\\n    STRENGTH, // 0\\n    DEXTERITY, // 1\\n    VITALITY, // 2\\n    ENERGY, // 3\\n    // attributes\\n    DAMAGE_MIN, // 4\\n    DAMAGE_MAX, // 5\\n    ATTACK_RATING, // 6\\n    DEFENSE, // 7\\n    BLOCK_RATING, // 8\\n    LIFE, // 9\\n    MANA, // 10\\n    // resistance\\n    FIRE_RESISTANCE, // 11\\n    COLD_RESISTANCE, // 12\\n    LIGHTNING_RESISTANCE, // 13\\n    // dmg against\\n    DMG_AGAINST_HUMAN, // 14\\n    DMG_AGAINST_UNDEAD, // 15\\n    DMG_AGAINST_DAEMON, // 16\\n    DMG_AGAINST_BEAST, // 17\\n\\n    // defence against\\n    DEF_AGAINST_HUMAN, // 18\\n    DEF_AGAINST_UNDEAD, // 19\\n    DEF_AGAINST_DAEMON, // 20\\n    DEF_AGAINST_BEAST, // 21\\n\\n    // --- unique, not augmentable\\n    // hero will not die until have positive chances\\n    LIFE_CHANCES, // 22\\n    // increase chance to get an item\\n    MAGIC_FIND, // 23\\n    // decrease chance to get an item\\n    DESTROY_ITEMS, // 24\\n    // percent of chance x2 dmg\\n    CRITICAL_HIT, // 25\\n    // dmg factors\\n    MELEE_DMG_FACTOR, // 26\\n    FIRE_DMG_FACTOR, // 27\\n    COLD_DMG_FACTOR, // 28\\n    LIGHTNING_DMG_FACTOR, // 29\\n    // increase attack rating on given percent\\n    AR_FACTOR, // 30\\n    // percent of damage will be converted to HP\\n    LIFE_STOLEN_PER_HIT, // 31\\n    // amount of mana restored after each battle\\n    MANA_AFTER_KILL, // 32\\n    // reduce all damage on percent after all other reductions\\n    DAMAGE_REDUCTION, // 33\\n\\n    // -- statuses\\n    // chance to stun an enemy, stunned enemy skip next hit\\n    STUN, // 34\\n    // chance burn an enemy, burned enemy will loss 50% of defence\\n    BURN, // 35\\n    // chance freeze an enemy, frozen enemy will loss 50% of MELEE damage\\n    FREEZE, // 36\\n    // chance to reduce enemy's attack rating on 50%\\n    CONFUSE, // 37\\n    // chance curse an enemy, cursed enemy will loss 50% of resistance\\n    CURSE, // 38\\n    // percent of dmg return to attacker\\n    REFLECT_DAMAGE_MELEE, // 39\\n    REFLECT_DAMAGE_MAGIC, // 40\\n    // chance to poison enemy, poisoned enemy will loss 10% of the current health\\n    POISON, // 41\\n    // reduce chance get any of uniq statuses\\n    RESIST_TO_STATUSES, // 42\\n\\n    END_SLOT // 46\\n  }\\n\\n  // possible\\n  // HEAL_FACTOR\\n\\n  struct CoreAttributes {\\n    int32 strength;\\n    int32 dexterity;\\n    int32 vitality;\\n    int32 energy;\\n  }\\n\\n  struct ChangeableStats {\\n    uint32 level;\\n    uint32 experience;\\n    uint32 life;\\n    uint32 mana;\\n    uint32 lifeChances;\\n  }\\n\\n  enum ItemSlots {\\n    UNKNOWN, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    BOOTS, // 6\\n    RIGHT_RING, // 7\\n    LEFT_RING, // 8\\n    RIGHT_HAND, // 9\\n    LEFT_HAND, // 10\\n    TWO_HAND, // 11\\n    SKILL_1, // 12\\n    SKILL_2, // 13\\n    SKILL_3, // 14\\n    END_SLOT // 15\\n  }\\n\\n  struct NftItem {\\n    address token;\\n    uint tokenId;\\n  }\\n\\n  enum Race {\\n    UNKNOWN, // 0\\n    HUMAN, // 1\\n    UNDEAD, // 2\\n    DAEMON, // 3\\n    BEAST, // 4\\n    END_SLOT // 5\\n  }\\n\\n  struct ChangeAttributesInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    int32[] changeAttributes;\\n    bool add;\\n    bool temporally;\\n  }\\n\\n  struct BuffInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    uint32 heroLevel;\\n    address[] buffTokens;\\n    uint[] buffTokenIds;\\n  }\\n\\n  /// @dev This struct is used inside event, so it's moved here from lib\\n  struct ActionInternalInfo {\\n    int32[] posAttributes;\\n    int32[] negAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintedItems;\\n  }\\n\\n  function initNewHero(address token, uint tokenId, uint heroClass) external;\\n\\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory);\\n\\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32);\\n\\n  function heroAttributesLength(address token, uint tokenId) external view returns (uint);\\n\\n  function heroBaseAttributes(address token, uint tokenId) external view returns (CoreAttributes memory);\\n\\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint);\\n\\n  function globalCustomData(bytes32 index) external view returns (uint);\\n\\n  function heroStats(address token, uint tokenId) external view returns (ChangeableStats memory);\\n\\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked);\\n\\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory);\\n\\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function levelUp(address token, uint tokenId, uint heroClass, CoreAttributes memory change) external returns (uint newLvl);\\n\\n  function changeHeroItemSlot(\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) external;\\n\\n  function changeCurrentStats(\\n    address token,\\n    uint tokenId,\\n    ChangeableStats memory change,\\n    bool increase\\n  ) external;\\n\\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external;\\n\\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external;\\n\\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external;\\n\\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external;\\n\\n  function buffHero(BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed);\\n\\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external;\\n\\n  function setGlobalCustomData(bytes32 index, uint value) external;\\n\\n}\\n\",\"keccak256\":\"0x92bcc6057f867ff0d418fd9ec397578444c5fd6244b979782c2ddd14b607a561\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStoryController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"./IController.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./IHeroController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStoryController {\\n\\n  enum AnswerResultId {\\n    UNKNOWN, // 0\\n    SUCCESS, // 1\\n    ATTRIBUTE_FAIL, // 2\\n    RANDOM_FAIL, // 3\\n    DELAY_FAIL, // 4\\n    HERO_CUSTOM_DATA_FAIL, // 5\\n    GLOBAL_CUSTOM_DATA_FAIL, // 6\\n\\n    END_SLOT\\n  }\\n\\n  enum CustomDataResult {\\n    UNKNOWN, // 0\\n    HERO_SUCCESS, // 1\\n    HERO_FAIL, // 2\\n    GLOBAL_SUCCESS, // 3\\n    GLOBAL_FAIL, // 4\\n\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:story.controller.main\\n  struct MainState {\\n\\n    // --- STORY REG INFO ---\\n\\n    /// @dev Uniq story identification.\\n    mapping(uint32 => uint16) storyIds;\\n    /// @dev Revers mapping for stories for using in the next object rewrite logic.\\n    mapping(uint16 => uint32) idToStory;\\n    /// @dev Store used ids for stories.\\n    mapping(uint16 => bool) _usedStoryIds;\\n    /// @dev Prevent register the story twice\\n    mapping(uint32 => bool) registeredStories;\\n\\n    // --- ANSWER MAPPING ---\\n\\n    /// @dev storyId => all story pages. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.UintSet) allStoryPages;\\n\\n    /// @dev storyId => all possible answers. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.Bytes32Set) allStoryAnswers;\\n\\n    /// @dev storyId + pageId + heroClass (zero is default answers) => storyId + pageId + heroClass (zero is default answers) + answerId\\n    mapping(bytes32 => bytes32[]) answers;\\n    /// @dev answerUnPackedId + answerResultId => nextPageIds (will be chosen randomly from this array)\\n    ///      where answerResultId is:\\n    ///      0 - unknown,\\n    ///      1 - success,\\n    ///      2 - attr fail\\n    ///      3 - random fail\\n    ///      4 - delay fail\\n    ///      5 - hero custom data fail\\n    ///      6 - global custom data fail\\n    ///      see COUNT_ANSWER_RESULT_IDS\\n    mapping(bytes32 => uint16[]) nextPageIds;\\n    /// @dev story + pageId + heroClass (zero is default answers) => random nextObjs (adr + id, like packed nft id)\\n    mapping(bytes32 => uint32[]) nextObjectsRewrite;\\n\\n    /// @dev answerPackedId => packed array of uint32[]\\n    ///      0 - random requirement(uint32, 1 - 99% success of this action, zero means no check)\\n    ///      1 - delay requirement(uint32, if time since the last call more than this value the check is fail, zero means no check)\\n    ///      2 - isFinalAnswer(uint8)\\n    mapping(bytes32 => bytes32) answerAttributes;\\n\\n    // --- ANSWER REQUIREMENTS ---\\n\\n    /// @dev answerPackedId => array of AttributeRequirementsPacked\\n    mapping(bytes32 => bytes32[]) attributeRequirements;\\n    /// @dev answerPackedId=> array of ItemRequirementsPacked\\n    mapping(bytes32 => bytes32[]) itemRequirements;\\n    /// @dev answerPackedId => array of TokenRequirementsPacked\\n    mapping(bytes32 => bytes32[]) tokenRequirements;\\n    /// @dev answerPackedId => custom data for hero\\n    mapping(bytes32 => CustomDataRequirementPacked[]) heroCustomDataRequirement;\\n    /// @dev answerPackedId => global custom data\\n    mapping(bytes32 => CustomDataRequirementPacked[]) globalCustomDataRequirement;\\n\\n    // --- ANSWER RESULTS ---\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) successInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) successInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) successInfoMintItems;\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) failInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) failInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) failInfoMintItems;\\n\\n    /// @dev answerUnPackedId + CustomDataResult => custom data array change\\n    ///      where CustomDataResult is\\n    ///      1 - hero success\\n    ///      2 - hero fail\\n    ///      3 - global success\\n    ///      4 - global fail\\n    ///      see COUNT_CUSTOM_DATA_RESULT_IDS\\n    mapping(bytes32 => bytes32[]) customDataResult;\\n    /// @dev answerPackedId => slot+chance+stopIfBurnt\\n    mapping(bytes32 => bytes32[]) burnItem;\\n\\n    // --- GENERAL STORY REQUIREMENTS ---\\n\\n    /// @dev story => Custom hero data requirements for a story. If exist and hero is not eligible should be not chose in a dungeon.\\n    mapping(uint => CustomDataRequirementRangePacked[]) storyRequiredHeroData;\\n    /// @dev story => Minimal level for the history. 0 means no requirements.\\n    mapping(uint => uint) storyRequiredLevel;\\n\\n    // --- HERO STATES ---\\n\\n    /// @dev hero + heroId + storyId => pageId + heroLastActionTS\\n    mapping(bytes32 => bytes32) heroState;\\n\\n    // --- OTHER ---\\n\\n    /// @dev storyId => build hash for the last update\\n    mapping(uint16 => uint) storyBuildHash;\\n  }\\n\\n  /// @dev We need to have flat structure coz Solidity can not handle arrays of structs properly\\n  struct StoryMetaInfo {\\n    uint16 storyId;\\n\\n    // --- story reqs\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n    uint minLevel;\\n\\n    // --- answer reqs\\n\\n    AnswersMeta answersMeta;\\n    AnswerNextPageMeta answerNextPage;\\n    AnswerAttributeRequirementsMeta answerAttributeRequirements;\\n    AnswerItemRequirementsMeta answerItemRequirements;\\n    AnswerTokenRequirementsMeta answerTokenRequirements;\\n    AnswerAttributesMeta answerAttributes;\\n    AnswerCustomDataMeta answerHeroCustomDataRequirement;\\n    AnswerCustomDataMeta answerGlobalCustomDataRequirement;\\n\\n    // --- answer results\\n\\n    AnswerBurnRandomItemMeta answerBurnRandomItemMeta;\\n    NextObjRewriteMeta nextObjRewriteMeta;\\n\\n    // --- story results\\n\\n    AnswerResultMeta successInfo;\\n    AnswerResultMeta failInfo;\\n\\n    AnswerCustomDataResultMeta successHeroCustomData;\\n    AnswerCustomDataResultMeta failHeroCustomData;\\n    AnswerCustomDataResultMeta successGlobalCustomData;\\n    AnswerCustomDataResultMeta failGlobalCustomData;\\n  }\\n\\n  struct NextObjRewriteMeta {\\n    uint16[] nextObjPageIds;\\n    uint8[] nextObjHeroClasses;\\n    uint32[][] nextObjIds;\\n  }\\n\\n  struct AnswersMeta {\\n    uint16[] answerPageIds;\\n    uint8[] answerHeroClasses;\\n    uint16[] answerIds;\\n  }\\n\\n  struct AnswerNextPageMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint8[] answerResultIds;\\n    uint16[][] answerNextPageIds;\\n  }\\n\\n  struct AnswerAttributeRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    bool[][] cores;\\n    uint8[][] ids;\\n    int32[][] values;\\n  }\\n\\n  struct AnswerItemRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireItems;\\n    bool[][] requireItemBurn;\\n    bool[][] requireItemEquipped;\\n  }\\n\\n  struct AnswerTokenRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireToken;\\n    uint88[][] requireAmount;\\n    bool[][] requireTransfer;\\n  }\\n\\n  struct AnswerAttributesMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint32[] randomRequirements;\\n    uint32[] delayRequirements;\\n    bool[] isFinalAnswer;\\n  }\\n\\n  struct AnswerCustomDataMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    bool[][] mandatory;\\n    uint64[][] dataValuesMin;\\n    uint64[][] dataValuesMax;\\n  }\\n\\n  struct AnswerResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    uint8[][] attributeIds;\\n    /// @dev Max value is limitied by int24, see toBytes32ArrayWithIds impl\\n    int32[][] attributeValues;\\n\\n    uint32[] experience;\\n    int32[] heal;\\n    int32[] manaRegen;\\n    int32[] lifeChancesRecovered;\\n    int32[] damage;\\n    int32[] manaConsumed;\\n\\n    address[][] mintItems;\\n    uint32[][] mintItemsChances;\\n  }\\n\\n  struct AnswerCustomDataResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    int16[][] dataValues;\\n  }\\n\\n  struct AnswerBurnRandomItemMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    /// @notice 0 - random slot\\n    uint8[][] slots;\\n    /// @notice typical chances are [0..100] (no decimals here)\\n    uint64[][] chances;\\n    bool[][] isStopIfBurnt;\\n  }\\n\\n  struct CustomDataRequirementPacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + mandatory(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct CustomDataRequirementRangePacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + isHeroData(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct StatsChange {\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n  }\\n\\n  struct StoryActionContext {\\n    uint stageId;\\n    uint iteration;\\n    bytes32 answerIdHash;\\n    bytes32 answerAttributes;\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IStatController statController;\\n    IHeroController heroController;\\n    IOracle oracle;\\n    IItemController itemController;\\n    uint8 heroClass;\\n    uint8 heroClassFromAnswerHash;\\n    uint8 biome;\\n    uint16 storyId;\\n    uint16 storyIdFromAnswerHash;\\n    uint16 pageIdFromAnswerHash;\\n    uint16 answerNumber;\\n    uint16 pageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint40 heroLastActionTS;\\n    uint80 heroTokenId;\\n    IStatController.ChangeableStats heroStats;\\n  }\\n\\n  // --- WRITE ---\\n\\n  function storyAction(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) external returns (IGOC.ActionResult memory);\\n\\n  // --- READ ---\\n\\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function idToStory(uint16 id) external view returns (uint32 objectId);\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId);\\n\\n  function storyIds(uint32 objectId) external view returns (uint16);\\n\\n  function registeredStories(uint32 objectId) external view returns (bool);\\n\\n}\\n\",\"keccak256\":\"0x6bc71b74f885c82d9949c582a49280738feed3af3704e7400d4acc1ba545f32e\",\"license\":\"BUSL-1.1\"},\"contracts/lib/CalcLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\n\\nlibrary CalcLib {\\n\\n  uint32 public constant MAX_CHANCE = 1e9;\\n\\n  function minI32(int32 a, int32 b) internal pure returns (int32) {\\n    return a < b ? a : b;\\n  }\\n\\n  function max32(int32 a, int32 b) internal pure returns (int32) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function absDiff(int32 a, int32 b) internal pure returns (uint32) {\\n    if (!((a >= 0 && b >= 0) || (a <= 0 && b <= 0))) revert IAppErrors.AbsDiff(a, b);\\n    if (a < 0) {\\n      a = - a;\\n    }\\n    if (b < 0) {\\n      b = - b;\\n    }\\n    return uint32(uint(int(a >= b ? a - b : b - a)));\\n  }\\n\\n  function toUint(int32 n) internal pure returns (uint) {\\n    if (n < 0) {\\n      return 0;\\n    }\\n    if (n <= 0) {\\n      return 0;\\n    }\\n    return uint(int(n));\\n  }\\n\\n  function toInt32(uint a) internal pure returns (int32){\\n    if (a >= uint(int(type(int32).max))) {\\n      return type(int32).max;\\n    }\\n    return int32(int(a));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandom(uint maxValue) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft()))) % (maxValue + 1));\\n  }\\n\\n  function pseudoRandomUint32(uint32 maxValue) internal view returns (uint32) {\\n    return uint32(pseudoRandom(uint(maxValue)));\\n  }\\n\\n  /// @notice Generate pseudo-random uint in the range [0..maxValue) using Solady pseudo-random function\\n  function nextPrng(LibPRNG.PRNG memory prng, uint maxValue) internal pure returns (uint) {\\n    return LibPRNG.next(prng) % maxValue;\\n  }\\n\\n  /// @notice pseudoRandomUint32 with customizable pseudoRandom()\\n  function pseudoRandomUint32Flex(\\n    uint32 maxValue,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint32) {\\n    return uint32(random_(uint(maxValue)));\\n  }\\n\\n  function pseudoRandomInt32(int32 maxValue) internal view returns (int32) {\\n    bool neg;\\n    if (maxValue < 0) {\\n      neg = true;\\n      maxValue = - maxValue;\\n    }\\n    uint32 v = uint32(pseudoRandom(uint(int(maxValue))));\\n    return neg\\n      ? - int32(int(uint(v)))\\n      : int32(int(uint(v)));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandomWithSeed(uint maxValue, uint seed) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), seed))) % (maxValue + 1));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  function pseudoRandomInRange(uint min, uint max) internal view returns (uint) {\\n    if (min >= max) {\\n      return max;\\n    }\\n    uint r = pseudoRandom(max - min);\\n    return min + r;\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  ///      Equal to pseudoRandomInRange(min, max, pseudoRandom)\\n  function pseudoRandomInRangeFlex(\\n    uint min,\\n    uint max,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint) {\\n    return min >= max ? max : min + random_(max - min);\\n  }\\n\\n  function minusWithZeroFloor(uint a, uint b) internal pure returns (uint){\\n    if (a <= b) {\\n      return 0;\\n    }\\n    return a - b;\\n  }\\n\\n  function minusWithMinFloorI32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) - int(b) < type(int32).min) {\\n      return type(int32).min;\\n    }\\n    return a - b;\\n  }\\n\\n  function plusWithMaxFloor32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) + int(b) >= type(int32).max) {\\n      return type(int32).max;\\n    }\\n    return a + b;\\n  }\\n\\n  function sqrt(uint x) internal pure returns (uint z) {\\n    assembly {\\n    // Start off with z at 1.\\n      z := 1\\n\\n    // Used below to help find a nearby power of 2.\\n      let y := x\\n\\n    // Find the lowest power of 2 that is at least sqrt(x).\\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n        y := shr(128, y) // Like dividing by 2 ** 128.\\n        z := shl(64, z) // Like multiplying by 2 ** 64.\\n      }\\n      if iszero(lt(y, 0x10000000000000000)) {\\n        y := shr(64, y) // Like dividing by 2 ** 64.\\n        z := shl(32, z) // Like multiplying by 2 ** 32.\\n      }\\n      if iszero(lt(y, 0x100000000)) {\\n        y := shr(32, y) // Like dividing by 2 ** 32.\\n        z := shl(16, z) // Like multiplying by 2 ** 16.\\n      }\\n      if iszero(lt(y, 0x10000)) {\\n        y := shr(16, y) // Like dividing by 2 ** 16.\\n        z := shl(8, z) // Like multiplying by 2 ** 8.\\n      }\\n      if iszero(lt(y, 0x100)) {\\n        y := shr(8, y) // Like dividing by 2 ** 8.\\n        z := shl(4, z) // Like multiplying by 2 ** 4.\\n      }\\n      if iszero(lt(y, 0x10)) {\\n        y := shr(4, y) // Like dividing by 2 ** 4.\\n        z := shl(2, z) // Like multiplying by 2 ** 2.\\n      }\\n      if iszero(lt(y, 0x8)) {\\n      // Equivalent to 2 ** z.\\n        z := shl(1, z)\\n      }\\n\\n    // Shifting right by 1 is like dividing by 2.\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n\\n    // Compute a rounded down version of z.\\n      let zRoundDown := div(x, z)\\n\\n    // If zRoundDown is smaller, use it.\\n      if lt(zRoundDown, z) {\\n        z := zRoundDown\\n      }\\n    }\\n  }\\n\\n  /*********************************************\\n *              PRB-MATH                      *\\n *   https://github.com/hifi-finance/prb-math *\\n **********************************************/\\n  /// @notice Calculates the binary logarithm of x.\\n  ///\\n  /// @dev Based on the iterative approximation algorithm.\\n  /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n  ///\\n  /// Requirements:\\n  /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n  ///\\n  /// Caveats:\\n  /// - The results are nor perfectly accurate to the last decimal,\\n  ///   due to the lossy precision of the iterative approximation.\\n  ///\\n  /// @param x The unsigned 60.18-decimal fixed-point number for which\\n  ///           to calculate the binary logarithm.\\n  /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n  function log2(uint256 x) internal pure returns (uint256 result) {\\n    if (x < 1e18) revert IAppErrors.TooLowX(x);\\n\\n    // Calculate the integer part of the logarithm\\n    // and add it to the result and finally calculate y = x * 2^(-n).\\n    uint256 n = mostSignificantBit(x / 1e18);\\n\\n    // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number.\\n    // The operation can't overflow because n is maximum 255 and SCALE is 1e18.\\n    uint256 rValue = n * 1e18;\\n\\n    // This is y = x * 2^(-n).\\n    uint256 y = x >> n;\\n\\n    // If y = 1, the fractional part is zero.\\n    if (y == 1e18) {\\n      return rValue;\\n    }\\n\\n    // Calculate the fractional part via the iterative approximation.\\n    // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n    for (uint256 delta = 5e17; delta > 0; delta >>= 1) {\\n      y = (y * y) / 1e18;\\n\\n      // Is y^2 > 2 and so in the range [2,4)?\\n      if (y >= 2 * 1e18) {\\n        // Add the 2^(-m) factor to the logarithm.\\n        rValue += delta;\\n\\n        // Corresponds to z/2 on Wikipedia.\\n        y >>= 1;\\n      }\\n    }\\n    return rValue;\\n  }\\n\\n  /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n  /// @dev See the note on msb in the \\\"Find First Set\\\"\\n  ///      Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n  /// @param x The uint256 number for which to find the index of the most significant bit.\\n  /// @return msb The index of the most significant bit as an uint256.\\n  //noinspection NoReturn\\n  function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n    if (x >= 2 ** 128) {\\n      x >>= 128;\\n      msb += 128;\\n    }\\n    if (x >= 2 ** 64) {\\n      x >>= 64;\\n      msb += 64;\\n    }\\n    if (x >= 2 ** 32) {\\n      x >>= 32;\\n      msb += 32;\\n    }\\n    if (x >= 2 ** 16) {\\n      x >>= 16;\\n      msb += 16;\\n    }\\n    if (x >= 2 ** 8) {\\n      x >>= 8;\\n      msb += 8;\\n    }\\n    if (x >= 2 ** 4) {\\n      x >>= 4;\\n      msb += 4;\\n    }\\n    if (x >= 2 ** 2) {\\n      x >>= 2;\\n      msb += 2;\\n    }\\n    if (x >= 2 ** 1) {\\n      // No need to shift x any more.\\n      msb += 1;\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0xd5178ce117e26987cd3cb3496e13bd2c6e7d220557ec25f771444dd2f4d2db5b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/FightLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IFightCalculator.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../lib/StatLib.sol\\\";\\nimport \\\"../lib/CalcLib.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\n\\nlibrary FightLib {\\n  using PackingLib for bytes32;\\n  using CalcLib for int32;\\n\\n  //region ------------------------ Data types\\n  struct AttackResult {\\n    int32 defenderHealth;\\n    int32 damage;\\n    int32 lifeStolen;\\n    int32 reflectDamage;\\n    uint8 critical;\\n    uint8 missed;\\n    uint8 blocked;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Constants\\n  uint internal constant MAX_FIGHT_CYCLES = 100;\\n  int32 internal constant RESISTANCE_DENOMINATOR = 100;\\n  int32 internal constant _MAX_RESIST = 90;\\n\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Main logic\\n\\n  /// @dev Items ownership must be checked before\\n  ///      it is no write actions but we need to emit an event for properly handle the battle on UI\\n  ///      return huge structs more expensive that call an event here\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests\\n  function fight(\\n    IItemController ic,\\n    IFightCalculator.FightCall memory callData,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (\\n    IFightCalculator.FightResult memory\\n  ) {\\n    IFightCalculator.FightInfoInternal memory fResult = prepareFightInternalInfo(ic, callData.fighterA, callData.fighterB);\\n\\n    fightProcessing(fResult, random_);\\n\\n    emit IApplicationEvents.FightResultProcessed(msg.sender, fResult, callData, callData.iteration);\\n\\n    return IFightCalculator.FightResult({\\n      healthA: fResult.fighterA.health,\\n      healthB: fResult.fighterB.health,\\n      manaConsumedA: fResult.fighterA.manaConsumed,\\n      manaConsumedB: fResult.fighterB.manaConsumed\\n    });\\n  }\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ High level of internal logic\\n  function fightProcessing(\\n    IFightCalculator.FightInfoInternal memory fResult,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n\\n    bool firstA = calcFirstHit(fResult);\\n\\n    setStatuses(fResult, firstA, random_);\\n    setStatuses(fResult, !firstA, random_);\\n\\n    reduceAttributesByStatuses(fResult.fighterA.info.fighterAttributes, fResult.fighterA.statuses, fResult.fighterB.info.fighterAttributes);\\n    reduceAttributesByStatuses(fResult.fighterB.info.fighterAttributes, fResult.fighterB.statuses, fResult.fighterA.info.fighterAttributes);\\n\\n    AttackResult memory resultA = processAttack(fResult, true, random_);\\n    AttackResult memory resultB = processAttack(fResult, false, random_);\\n\\n    fResult.fighterA.statuses.gotCriticalHit = resultA.critical != 0;\\n    fResult.fighterA.statuses.missed = resultA.missed != 0;\\n    fResult.fighterA.statuses.hitBlocked = resultA.blocked != 0;\\n\\n    fResult.fighterB.statuses.gotCriticalHit = resultB.critical != 0;\\n    fResult.fighterB.statuses.missed = resultB.missed != 0;\\n    fResult.fighterB.statuses.hitBlocked = resultB.blocked != 0;\\n\\n    reduceHp(\\n      firstA ? resultA : resultB,\\n      firstA ? resultB : resultA,\\n      firstA ? fResult.fighterA : fResult.fighterB,\\n      firstA ? fResult.fighterB : fResult.fighterA\\n    );\\n\\n    // restore health from stolen life\\n    stealLife(fResult.fighterA, resultA);\\n    stealLife(fResult.fighterB, resultB);\\n  }\\n\\n  function processAttack(\\n    IFightCalculator.FightInfoInternal memory fResult,\\n    bool isA,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (AttackResult memory attackResult) {\\n\\n    int32 defenderHealth = isA ? fResult.fighterB.health : fResult.fighterA.health;\\n\\n    if (skipTurn(fResult, isA)) {\\n      return AttackResult({\\n        defenderHealth: defenderHealth,\\n        damage: 0,\\n        lifeStolen: 0,\\n        reflectDamage: 0,\\n        critical: 0,\\n        missed: 0,\\n        blocked: 0\\n      });\\n    }\\n\\n    IFightCalculator.FighterInfo memory attackerInfo = isA ? fResult.fighterA.info : fResult.fighterB.info;\\n    IFightCalculator.FighterInfo memory defenderInfo = isA ? fResult.fighterB.info : fResult.fighterA.info;\\n\\n    if (attackerInfo.attackType == IFightCalculator.AttackType.MELEE) {\\n      attackResult = meleeDamageCalculation(attackerInfo, defenderInfo, defenderHealth, random_);\\n    } else if (attackerInfo.attackType == IFightCalculator.AttackType.MAGIC) {\\n      attackResult = magicDamageCalculation(\\n        attackerInfo,\\n        defenderInfo,\\n        isA ? fResult.fighterA.magicAttack : fResult.fighterB.magicAttack,\\n        defenderHealth,\\n        random_\\n      );\\n    } else {\\n      revert IAppErrors.NotAType(uint(attackerInfo.attackType));\\n    }\\n  }\\n  //endregion ------------------------ High level of internal logic\\n\\n  //region ------------------------ Internal logic\\n  function prepareFightInternalInfo(\\n    IItemController ic,\\n    IFightCalculator.FighterInfo memory fighterA,\\n    IFightCalculator.FighterInfo memory fighterB\\n  ) internal view returns (IFightCalculator.FightInfoInternal memory) {\\n    IFightCalculator.FightInfoInternal memory fInfo;\\n    _setFightData(ic, fighterA, fInfo.fighterA);\\n    _setFightData(ic, fighterB, fInfo.fighterB);\\n    return fInfo;\\n  }\\n\\n  /// @dev A part of prepareFightInternalInfo\\n  function _setFightData(\\n    IItemController ic,\\n    IFightCalculator.FighterInfo memory fighter,\\n    IFightCalculator.Fighter memory dest\\n  ) internal view {\\n    dest.info = fighter;\\n    dest.health = int32(fighter.fighterStats.life);\\n    if (fighter.attackToken != address(0)) {\\n      if (fighter.attackType != IFightCalculator.AttackType.MAGIC) revert IAppErrors.NotMagic();\\n      dest.magicAttack = ic.itemAttackInfo(fighter.attackToken, fighter.attackTokenId);\\n    }\\n    // dest.manaConsumed is 0 by default, in current implementation we don't need to change it\\n  }\\n\\n  /// @param random_ Either _pseudoRandom or pseudo-random for ut\\n  function statusChance(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IItemController.AttackInfo memory attackerMA,\\n    IStatController.ATTRIBUTES index,\\n    int32 resist,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (bool) {\\n    int32 chance = _getChance(attackerInfo, attackerMA.aType, index, resist);\\n    if (chance == 0) {\\n      return false;\\n    }\\n    if (chance >= RESISTANCE_DENOMINATOR) {\\n      return true;\\n    }\\n    return random_(RESISTANCE_DENOMINATOR.toUint()) < chance.toUint();\\n  }\\n\\n  /// @notice set fResult.fighterB.statuses (for isA = true) or fResult.fighterA.statuses (for isA = false)\\n  /// @param random_ Either _pseudoRandom or pseudo-random for ut\\n  function setStatuses(\\n    IFightCalculator.FightInfoInternal memory fResult,\\n    bool isA,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    // setStatuses is called twice one by one: first time for A, second time for B\\n    // if stun is set for A, setStatuses is skipped for B completely\\n    if (!skipTurn(fResult, isA)) {\\n      IFightCalculator.FighterInfo memory attackerInfo = isA ? fResult.fighterA.info : fResult.fighterB.info;\\n      IFightCalculator.FighterInfo memory defenderInfo = isA ? fResult.fighterB.info : fResult.fighterA.info;\\n\\n      IItemController.AttackInfo memory attackerMA = isA ? fResult.fighterA.magicAttack : fResult.fighterB.magicAttack;\\n\\n      IFightCalculator.Statuses memory statuses = isA ? fResult.fighterB.statuses : fResult.fighterA.statuses;\\n\\n      int32 resist = defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.RESIST_TO_STATUSES)];\\n\\n      statuses.stun = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.STUN, resist, random_);\\n      statuses.burn = statusChance(\\n        attackerInfo,\\n        attackerMA,\\n        IStatController.ATTRIBUTES.BURN,\\n        defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)],\\n        random_\\n      );\\n      statuses.freeze = statusChance(\\n        attackerInfo,\\n        attackerMA,\\n        IStatController.ATTRIBUTES.FREEZE,\\n        defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)],\\n        random_\\n      );\\n      statuses.confuse = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.CONFUSE, resist, random_);\\n      statuses.curse = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.CURSE, resist, random_);\\n      statuses.poison = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.POISON, resist, random_);\\n    }\\n  }\\n\\n  function magicDamageCalculation(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IFightCalculator.FighterInfo memory defenderInfo,\\n    IItemController.AttackInfo memory magicAttack,\\n    int32 defenderHealth,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (AttackResult memory attackResult) {\\n    // generate damage\\n    int32 damage = getMagicDamage(\\n      attackerInfo,\\n      magicAttack,\\n      CalcLib.pseudoRandomInRangeFlex(magicAttack.min.toUint(), magicAttack.max.toUint(), random_)\\n    );\\n    damage = increaseMagicDmgByFactor(damage, attackerInfo, magicAttack.aType);\\n    damage = increaseRaceDmg(damage, attackerInfo, defenderInfo.race);\\n    bool critical = isCriticalHit(attackerInfo, random_(RESISTANCE_DENOMINATOR.toUint()));\\n    damage = critical ? damage * 2 : damage;\\n\\n    // decrease damage\\n    damage = decreaseRaceDmg(damage, defenderInfo, attackerInfo.race);\\n    damage = decreaseDmgByDmgReduction(damage, defenderInfo);\\n\\n    if (magicAttack.aType == IItemController.AttackType.FIRE) {\\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.FIRE_RESISTANCE);\\n    } else if (magicAttack.aType == IItemController.AttackType.COLD) {\\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.COLD_RESISTANCE);\\n    } else if (magicAttack.aType == IItemController.AttackType.LIGHTNING) {\\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE);\\n    }\\n\\n    int32 defenderHealthResult = defenderHealth < damage ? int32(0) : defenderHealth - damage;\\n    damage = defenderHealth - defenderHealthResult;\\n\\n    return AttackResult({\\n      defenderHealth: defenderHealthResult,\\n      damage: damage,\\n      lifeStolen: lifeStolenPerHit(damage, attackerInfo),\\n      reflectDamage: reflectMagicDmg(damage, defenderInfo) + reflectChaos(magicAttack, attackerInfo, random_(1e18)),\\n      critical: critical ? uint8(1) : uint8(0),\\n      missed: 0,\\n      blocked: 0\\n    });\\n  }\\n\\n  function meleeDamageCalculation(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IFightCalculator.FighterInfo memory defenderInfo,\\n    int32 defenderHealth,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (AttackResult memory attackResult) {\\n    attackResult = (new AttackResult[](1))[0];\\n\\n    // generate damage\\n    int32 damage = getDamage(attackerInfo.fighterAttributes, random_);\\n    damage = increaseMeleeDmgByFactor(damage, attackerInfo);\\n    damage = increaseRaceDmg(damage, attackerInfo, defenderInfo.race);\\n    attackResult.critical = isCriticalHit(attackerInfo, random_(RESISTANCE_DENOMINATOR.toUint())) ? uint8(1) : uint8(0);\\n    damage = attackResult.critical == 0 ? damage : damage * 2;\\n\\n    // decrease damage\\n    damage = decreaseRaceDmg(damage, defenderInfo, attackerInfo.race);\\n    damage = decreaseDmgByDmgReduction(damage, defenderInfo);\\n\\n    attackResult.missed = random_(1e18) > StatLib.chanceToHit(\\n      attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)].toUint(),\\n      defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DEFENSE)].toUint(),\\n      attackerInfo.fighterStats.level,\\n      defenderInfo.fighterStats.level,\\n      attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.AR_FACTOR)].toUint()\\n    ) ? 1 : 0;\\n\\n    attackResult.blocked = (random_(100) < defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)].toUint()) ? 1 : 0;\\n\\n    if (attackResult.missed != 0 || attackResult.blocked != 0) {\\n      damage = 0;\\n    }\\n\\n    int32 defenderHealthResult = defenderHealth <= damage ? int32(0) : defenderHealth - damage;\\n    damage = defenderHealth - defenderHealthResult;\\n\\n\\n    attackResult.defenderHealth = defenderHealthResult;\\n    attackResult.damage = damage;\\n    attackResult.lifeStolen = lifeStolenPerHit(damage, attackerInfo);\\n    attackResult.reflectDamage = reflectMeleeDmg(damage, defenderInfo);\\n  }\\n\\n  function getDamage(\\n    int32[] memory attributes,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (int32) {\\n    return int32(int(CalcLib.pseudoRandomInRangeFlex(\\n      attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)].toUint(),\\n      attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)].toUint(),\\n      random_\\n    )));\\n  }\\n\\n  //endregion ------------------------ Internal logic\\n\\n  //region ------------------------ Pure utils\\n\\n  /// @notice Modify values in {targetAttributes} and {casterAttributes} according to {statuses}\\n  function reduceAttributesByStatuses(\\n    int32[] memory targetAttributes,\\n    IFightCalculator.Statuses memory statuses,\\n    int32[] memory casterAttributes\\n  ) internal pure {\\n\\n    if (statuses.burn) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.DEFENSE)] -= (targetAttributes[uint(IStatController.ATTRIBUTES.DEFENSE)] / 3);\\n      targetAttributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)] += 50;\\n      casterAttributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)] += 10;\\n      casterAttributes[uint(IStatController.ATTRIBUTES.DESTROY_ITEMS)] += 20;\\n    }\\n    if (statuses.freeze) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] -= targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] / 3;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)] += 50;\\n    }\\n    if (statuses.confuse) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] /= 2;\\n    }\\n    if (statuses.curse) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE)] /= 2;\\n    }\\n    if (statuses.stun) {\\n      casterAttributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)] += 10;\\n    }\\n    if (statuses.poison) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] /= 2;\\n    }\\n\\n  }\\n\\n  /// @notice Calculate new damage value depending on {defenderRace} and value of corresponded DMG_AGAINST_XXX attribute\\n  /// @param defenderRace See IStatController.Race\\n  /// @return Updated damage value\\n  function increaseRaceDmg(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo, uint defenderRace)\\n  internal pure returns (int32) {\\n    if (defenderRace == uint(IStatController.Race.HUMAN)) {\\n      return dmg + attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_HUMAN)] * dmg / RESISTANCE_DENOMINATOR;\\n    } else if (defenderRace == uint(IStatController.Race.UNDEAD)) {\\n      return dmg + attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_UNDEAD)] * dmg / RESISTANCE_DENOMINATOR;\\n    } else if (defenderRace == uint(IStatController.Race.DAEMON)) {\\n      return dmg + attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_DAEMON)] * dmg / RESISTANCE_DENOMINATOR;\\n    } else if (defenderRace == uint(IStatController.Race.BEAST)) {\\n      return dmg + attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_BEAST)] * dmg / RESISTANCE_DENOMINATOR;\\n    } else {\\n      return dmg;\\n    }\\n  }\\n\\n  /// @notice Decrease damage depending on {attackerRace}\\n  function decreaseRaceDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo, uint attackerRace) internal pure returns (int32) {\\n    if (attackerRace == uint(IStatController.Race.HUMAN)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_HUMAN);\\n    } else if (attackerRace == uint(IStatController.Race.UNDEAD)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_UNDEAD);\\n    } else if (attackerRace == uint(IStatController.Race.DAEMON)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_DAEMON);\\n    } else if (attackerRace == uint(IStatController.Race.BEAST)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_BEAST);\\n    } else {\\n      return dmg;\\n    }\\n  }\\n\\n  /// @notice Calculate damage after Melee-attack\\n  function increaseMeleeDmgByFactor(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo) internal pure returns (int32){\\n    return dmg + attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MELEE_DMG_FACTOR)] * dmg / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  /// @notice Calculate damage after Magic-attack\\n  function increaseMagicDmgByFactor(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo, IItemController.AttackType aType) internal pure returns (int32) {\\n    if (aType == IItemController.AttackType.FIRE) {\\n      return dmg + dmg * attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.FIRE_DMG_FACTOR)] / RESISTANCE_DENOMINATOR;\\n    } else if (aType == IItemController.AttackType.COLD) {\\n      return dmg + dmg * attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.COLD_DMG_FACTOR)] / RESISTANCE_DENOMINATOR;\\n    } else if (aType == IItemController.AttackType.LIGHTNING) {\\n      return dmg + dmg * attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.LIGHTNING_DMG_FACTOR)] / RESISTANCE_DENOMINATOR;\\n    } else {\\n      return dmg;\\n    }\\n  }\\n\\n  /// @notice Reduce damage depending on value of Damage Reduction attribute\\n  function decreaseDmgByDmgReduction(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\\n    return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DAMAGE_REDUCTION);\\n  }\\n\\n  /// @notice Calculate poison damage < {health}\\n  function poisonDmg(int32 health, IFightCalculator.Statuses memory statuses) internal pure returns (int32) {\\n    // poison should not kill\\n    if (statuses.poison && health.toUint() > 1) {\\n      // at least 1 dmg\\n      return int32(int(Math.max(health.toUint() / 10, 1)));\\n    }\\n    return 0;\\n  }\\n\\n  /// @notice Reduce health of the fighters according to attacks results, calc damagePoison, damage and damageReflect.\\n  function reduceHp(\\n    AttackResult memory firstAttack,\\n    AttackResult memory secondAttack,\\n    IFightCalculator.Fighter memory firstFighter,\\n    IFightCalculator.Fighter memory secondFighter\\n  ) internal pure {\\n    secondFighter.health = firstAttack.defenderHealth;\\n    firstFighter.damage = firstAttack.damage;\\n\\n    // hit only if second fighter survived\\n    if (secondFighter.health != 0) {\\n      firstFighter.health = secondAttack.defenderHealth;\\n      secondFighter.damage = secondAttack.damage;\\n\\n      // reflect damage from second to first\\n      secondFighter.damageReflect = (CalcLib.minI32(firstAttack.reflectDamage, firstFighter.health));\\n      firstFighter.health -= secondFighter.damageReflect;\\n\\n      // reflect damage from first to second\\n      firstFighter.damageReflect = (CalcLib.minI32(secondAttack.reflectDamage, secondFighter.health));\\n      secondFighter.health -= firstFighter.damageReflect;\\n    }\\n\\n    // poison second firstly (he got damage and statuses early)\\n    firstFighter.damagePoison = poisonDmg(secondFighter.health, secondFighter.statuses);\\n    secondFighter.health -= firstFighter.damagePoison;\\n\\n    // poison first fighter\\n    secondFighter.damagePoison = poisonDmg(firstFighter.health, firstFighter.statuses);\\n    firstFighter.health -= secondFighter.damagePoison;\\n  }\\n\\n  /// @notice Calculate life-stolen-per-hit value for the given {damage} value\\n  function lifeStolenPerHit(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo) internal pure returns (int32) {\\n    return dmg * attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.LIFE_STOLEN_PER_HIT)] / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  /// @notice Increase {fighter.health} on the value of life-stolen-per-hit (only if the health > 0)\\n  function stealLife(IFightCalculator.Fighter memory fighter, AttackResult memory attackResult) internal pure {\\n    if (fighter.health != 0) {\\n      int32 newHealth = fighter.health + attackResult.lifeStolen;\\n      int32 maxHealth = fighter.info.fighterAttributes[uint(IStatController.ATTRIBUTES.LIFE)];\\n      fighter.health = (CalcLib.minI32(newHealth, maxHealth));\\n    }\\n  }\\n\\n  function skipTurn(IFightCalculator.FightInfoInternal memory fResult, bool isA) internal pure returns (bool) {\\n    return isA ? fResult.fighterA.statuses.stun : fResult.fighterB.statuses.stun;\\n  }\\n\\n  /// @notice Detect which hero is faster and makes the hit first. Magic is faster melee.\\n  /// Otherwise first hit is made by the fighter with higher attack rating (A is selected if the ratings are equal)\\n  function calcFirstHit(IFightCalculator.FightInfoInternal memory fInfo) internal pure returns (bool aFirst){\\n    if (fInfo.fighterA.info.attackType == IFightCalculator.AttackType.MAGIC) {\\n      if (fInfo.fighterB.info.attackType == IFightCalculator.AttackType.MAGIC) {\\n        // if both fighters use magic we check attack rating\\n        aFirst = isAttackerFaster(fInfo.fighterA.info, fInfo.fighterB.info);\\n      } else {\\n        // otherwise, magic always faster than melee\\n        aFirst = true;\\n      }\\n    } else {\\n      if (fInfo.fighterB.info.attackType == IFightCalculator.AttackType.MAGIC) {\\n        // if fighter use magic he will be faster\\n        aFirst = false;\\n      } else {\\n        // otherwise, check attack rating\\n        aFirst = isAttackerFaster(fInfo.fighterA.info, fInfo.fighterB.info);\\n      }\\n    }\\n  }\\n\\n  function isAttackerFaster(\\n    IFightCalculator.FighterInfo memory fighterAInfo,\\n    IFightCalculator.FighterInfo memory fighterBInfo\\n  ) internal pure returns (bool) {\\n    return fighterAInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)]\\n      >= fighterBInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)];\\n  }\\n\\n  function reflectMeleeDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\\n    return dmg * defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.REFLECT_DAMAGE_MELEE)] / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  function reflectMagicDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\\n    return dmg * defenderInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.REFLECT_DAMAGE_MAGIC)] / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  function _getChance(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IItemController.AttackType aType,\\n    IStatController.ATTRIBUTES index,\\n    int32 resist\\n  ) internal pure returns (int32 chance) {\\n    chance = attackerInfo.fighterAttributes[uint(index)];\\n\\n    if (attackerInfo.attackType == IFightCalculator.AttackType.MAGIC) {\\n      if (index == IStatController.ATTRIBUTES.BURN && aType == IItemController.AttackType.FIRE) {\\n        chance += int32(20);\\n      }\\n      if (index == IStatController.ATTRIBUTES.FREEZE && aType == IItemController.AttackType.COLD) {\\n        chance += int32(20);\\n      }\\n      if (index == IStatController.ATTRIBUTES.CONFUSE && aType == IItemController.AttackType.LIGHTNING) {\\n        chance += int32(20);\\n      }\\n    }\\n\\n    return chance - chance * (CalcLib.minI32(resist, _MAX_RESIST)) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  /// @param randomValue Result of call _pseudoRandom, value in the range [0...RESISTANCE_DENOMINATOR)\\n  function isCriticalHit(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    uint randomValue\\n  ) internal pure returns (bool) {\\n    return randomValue < attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)].toUint();\\n  }\\n\\n  /// @param randomValue Result of call CalcLib.pseudoRandom(1e18)\\n  function reflectChaos(\\n    IItemController.AttackInfo memory magicAttack,\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    uint randomValue\\n  ) internal pure returns (int32) {\\n    return (magicAttack.aType == IItemController.AttackType.CHAOS && randomValue > 5e17)\\n      ? int32(attackerInfo.fighterStats.life) / int32(2)\\n      : int32(0);\\n  }\\n\\n  function _calcDmgInline(int32 dmg, IFightCalculator.FighterInfo memory info, IStatController.ATTRIBUTES index) internal pure returns (int32) {\\n    return dmg * (CalcLib.minI32(info.fighterAttributes[uint(index)], _MAX_RESIST)) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  function getMagicDamage(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IItemController.AttackInfo memory mAttack,\\n    uint randomValue_\\n  ) internal pure returns (int32) {\\n\\n    int32 attributeFactorResult = (attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.STRENGTH)] * mAttack.attributeFactors.strength / 100);\\n    attributeFactorResult += (attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DEXTERITY)] * mAttack.attributeFactors.dexterity / 100);\\n    attributeFactorResult += (attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.VITALITY)] * mAttack.attributeFactors.vitality / 100);\\n    attributeFactorResult += (attackerInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.ENERGY)] * mAttack.attributeFactors.energy / 100);\\n\\n    return int32(int(randomValue_)) + attributeFactorResult;\\n  }\\n\\n  //endregion ------------------------ Pure utils\\n\\n}\\n\",\"keccak256\":\"0x28859c6988ba5328aa1231ac48b5dfe1b5ddfee2a2ee87b924a3fa6a62545bfa\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ItemLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./StatLib.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IItem.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\n\\nlibrary ItemLib {\\n  using CalcLib for int32;\\n  using PackingLib for address;\\n  using PackingLib for bytes32;\\n  using PackingLib for bytes32[];\\n  using PackingLib for uint32[];\\n  using PackingLib for int32[];\\n\\n  //region ------------------------ Data types\\n  struct GenerateAttributesContext {\\n    /// @notice True if max allowed amount of random attributes were reached inside {_prepareAttributes}\\n    bool stopGenerateRandom;\\n    /// @notice Flag - attribute was generated. The array matches to info.ids\\n    bool[] usedIndexes;\\n    /// @notice Ids of the generated attributes\\n    uint8[] ids;\\n    /// @notice Randomly selected values of the generated attributes\\n    int32[] values;\\n    /// @notice Counter of the stored values into {ids} and {values}\\n    uint counter;\\n    /// @notice Total number of random attributes that were generated inside {_prepareAttributes}\\n    uint randomAttrCounter;\\n    /// @notice Total sum of all {random} values for random attributes generated in {_prepareAttributes}\\n    uint randomSum;\\n    /// @notice Total sum of all chances of the random attributes generated in {_prepareAttributes}\\n    uint chancesSum;\\n    /// @notice Total number of random attributes that can be generated\\n    uint totalRandomAttrsPossible;\\n  }\\n\\n  struct MintItemInfo {\\n    uint8 biome;\\n    uint8 heroCurrentLvl;\\n    uint8 maxItems;\\n    IOracle oracle;\\n    address[] mintItems;\\n    int32 magicFind;\\n    int32 destroyItems;\\n    uint32[] mintItemsChances;\\n    uint32 heroExp;\\n    uint amplifier;\\n    uint seed;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Main logic\\n\\n  /// @notice Mint new item, setup attributes, make extra setup if necessary (setup attack item, buff item)\\n  /// @param sender Dungeon Factory only is allowed\\n  /// @param item Item to be minted\\n  /// @param recipient The item is minted for the given recipient\\n  /// @return itemId Id of the newly minted item\\n  function mintNewItem(\\n    IItemController.MainState storage s,\\n    IController controller,\\n    address sender,\\n    address item,\\n    address recipient\\n  ) external returns (uint itemId) {\\n    if (controller.dungeonFactory() != sender) revert IAppErrors.ErrorNotDungeonFactory(sender);\\n\\n    itemId = IItem(item).mintFor(recipient);\\n\\n    IItemController.MintInfo memory info;\\n\\n    (\\n      info.meta,\\n      info.attributesIds,\\n      info.attributesValues,\\n      info.itemRarity\\n    ) = _setupNewAttributes(s, item, itemId, CalcLib.pseudoRandom);\\n\\n    // setup extra info\\n\\n    if (info.meta.itemMetaType == uint8(IItemController.ItemMetaType.ATTACK)) {\\n      info.attackInfo = unpackItemAttackInfo(_setupNewAttackItem(s, item, itemId));\\n    } else if (info.meta.itemMetaType == uint8(IItemController.ItemMetaType.BUFF)) {\\n      (\\n        info.casterIds,\\n        info.casterValues,\\n        info.targetIds,\\n        info.targetValues\\n      ) = _setupNewBuffItem(s, item, itemId, CalcLib.pseudoRandom);\\n    }\\n    // consumable stats unchangeable, get them by address\\n\\n    emit IApplicationEvents.NewItemMinted(item, itemId, info);\\n  }\\n\\n  /// @notice Mint random items, not more than {info.maxItems}\\n  function mintRandomItems(MintItemInfo memory info) internal returns (address[] memory) {\\n    return _mintRandomItems(info, CalcLib.nextPrng);\\n  }\\n\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ Internal logic\\n  /// @param nextPrng_ CalcLib.nextPrng, param is required by unit tests\\n  function _mintRandomItems(\\n    MintItemInfo memory info,\\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\\n  ) internal returns (address[] memory) {\\n    unchecked {\\n      uint len = info.mintItems.length;\\n\\n    // Fisher\\u2013Yates shuffle\\n      LibPRNG.PRNG memory prng = LibPRNG.PRNG(info.oracle.getRandomNumber(CalcLib.MAX_CHANCE, info.seed));\\n      uint[] memory indices = new uint[](len);\\n      for (uint i = 1; i < len; ++i) {\\n        indices[i] = i;\\n      }\\n      LibPRNG.shuffle(prng, indices);\\n\\n      address[] memory minted = new address[](len);\\n      uint mintedLength;\\n      uint delta = StatLib.mintDropChanceDelta(info.heroExp, info.heroCurrentLvl, info.biome);\\n      uint di = Math.min(uint(int(info.destroyItems)), 100);\\n\\n      for (uint i; i < len; ++i) {\\n        if (info.mintItemsChances[indices[i]] > CalcLib.MAX_CHANCE) {\\n          revert IAppErrors.TooHighChance(info.mintItemsChances[indices[i]]);\\n        }\\n        uint chance = StatLib.mintDropChance(info.mintItemsChances[indices[i]], info.amplifier, delta);\\n        chance += chance * uint(int(info.magicFind)) / 100;\\n        chance -= chance * di / 100;\\n\\n        // need to call random in each loop coz each minted item should have dedicated chance\\n        uint rnd = nextPrng_(prng, CalcLib.MAX_CHANCE); // randomWithSeed_(CalcLib.MAX_CHANCE, rndSeed);\\n\\n        if (chance != 0 && (chance >= CalcLib.MAX_CHANCE || rnd < chance)) {\\n          // There is no break here: the cycle is continued even if the number of the minted items reaches the max.\\n          // The reason: gas consumption of success operation must be great of equal of the gas consumption of fail op.\\n          if (mintedLength < info.maxItems) {\\n            minted[i] = info.mintItems[indices[i]];\\n            ++mintedLength;\\n          }\\n        }\\n      }\\n\\n      address[] memory mintedAdjusted = new address[](mintedLength);\\n      uint j;\\n      for (uint i; i < len; ++i) {\\n        if (minted[i] != address(0)) {\\n          mintedAdjusted[j] = minted[i];\\n          ++j;\\n        }\\n      }\\n\\n      return mintedAdjusted;\\n    }\\n  }\\n\\n  function _setupNewAttributes(\\n    IItemController.MainState storage s,\\n    address item,\\n    uint itemId,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (\\n    IItemController.ItemMeta memory meta,\\n    uint8[] memory ids,\\n    int32[] memory values,\\n    IItemController.ItemRarity itemRarity\\n  ){\\n    meta = unpackedItemMeta(s.itemMeta[item]);\\n    (ids, values, itemRarity) = _generateAttributes(unpackItemGenerateInfo(s.generateInfoAttributes[item]), meta, random_);\\n\\n    bytes32 packedItemId = item.packNftId(itemId);\\n    if (ids.length != 0) {\\n      s._itemAttributes[packedItemId] = values.toBytes32ArrayWithIds(ids);\\n    }\\n\\n    s.itemInfo[packedItemId] = PackingLib.packItemInfo(uint8(itemRarity), 0, meta.baseDurability);\\n  }\\n\\n  function _setupNewAttackItem(IItemController.MainState storage s, address item, uint itemId) internal returns (bytes32 attackInfo){\\n    // we just write data for attack item, no need to generate, it will be augmented later so need individual data for itemId\\n    attackInfo = s.generateInfoAttack[item];\\n    s._itemAttackInfo[item.packNftId(itemId)] = attackInfo;\\n  }\\n\\n  function _setupNewBuffItem(\\n    IItemController.MainState storage s,\\n    address item,\\n    uint itemId,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (\\n    uint8[] memory casterIds,\\n    int32[] memory casterValues,\\n    uint8[] memory targetIds,\\n    int32[] memory targetValues\\n  ){\\n\\n    // CASTER\\n    (casterIds, casterValues) = _generateSimpleAttributes(\\n      unpackItemGenerateInfo(s.generateInfoCasterAttributes[item]),\\n      true,\\n      random_\\n    );\\n\\n    if (casterIds.length != 0) {\\n      s._itemCasterAttributes[item.packNftId(itemId)] = casterValues.toBytes32ArrayWithIds(casterIds);\\n    }\\n\\n    // TARGET\\n    (targetIds, targetValues) = _generateSimpleAttributes(\\n      unpackItemGenerateInfo(s.generateInfoTargetAttributes[item]),\\n      true,\\n      random_\\n    );\\n\\n    if (targetIds.length != 0) {\\n      s._itemTargetAttributes[item.packNftId(itemId)] = targetValues.toBytes32ArrayWithIds(targetIds);\\n    }\\n  }\\n\\n  /// @notice Generate all mandatory attributes and try to generate required number of random attributes.\\n  /// Generate at least {info.minRandomAttributes} of random attributes if it's possible\\n  /// but not more than {info.maxRandomAttributes}. Value of each attribute is generated randomly according its chances.\\n  /// @param meta Assume, that meta.min != 0, meta.max != 0 and both meta.min and meta.min should have same sign\\n  /// because results value cannot be 0\\n  /// @return ids Ids of the attributes, zero id is allowed\\n  /// @return values Randomly generated attributes values, min <= value <= max\\n  /// @return itemRarity Rarity of the item (Either meta.defaultRarity or calculated if there is no default rarity)\\n  function _generateAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    IItemController.ItemMeta memory meta,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    uint8[] memory ids,\\n    int32[] memory values,\\n    IItemController.ItemRarity itemRarity\\n  ) {\\n    GenerateAttributesContext memory ctx;\\n\\n    uint len = info.ids.length;\\n    if (len != 0) {\\n      ctx.ids = new uint8[](len);\\n      ctx.values = new int32[](len);\\n      ctx.usedIndexes = new bool[](len);\\n\\n      // Fisher\\u2013Yates shuffle\\n      _shuffleInfo(info, random_);\\n\\n      // initialize ctx by initial values\\n      // generate all mandatory attributes, try to generate not more than {meta.maxRandomAttributes} random attributes\\n      _prepareAttributes(info, meta.maxRandomAttributes, ctx, random_);\\n\\n      // generate missing random attributes if it's necessary, ctx.counter is incremented\\n      _generateMissingRandomAttributes(info, meta.minRandomAttributes, ctx, random_);\\n\\n      itemRarity = meta.defaultRarity == 0\\n        ? _calculateRarity(ctx.randomSum, ctx.chancesSum, ctx.randomAttrCounter, meta.maxRandomAttributes)\\n        : IItemController.ItemRarity(meta.defaultRarity);\\n    } else {\\n      itemRarity = IItemController.ItemRarity.UNKNOWN;\\n    }\\n\\n    (ids, values) = _fixLengthsIdsValues(ctx.ids, ctx.values, ctx.counter);\\n  }\\n\\n  /// @notice Generate missing random attributes if necessary\\n  function _generateMissingRandomAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    uint8 minRandomAttributes,\\n    GenerateAttributesContext memory ctx,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint attrToGen = Math.min(ctx.totalRandomAttrsPossible, minRandomAttributes);\\n    if (ctx.randomAttrCounter < attrToGen && ctx.totalRandomAttrsPossible > ctx.randomAttrCounter) {\\n      // it's necessary AND possible to generate more random attributes\\n      uint possibleRemainingAttrs = ctx.totalRandomAttrsPossible - ctx.randomAttrCounter;\\n      uint remainingAttrsToGen = attrToGen - ctx.randomAttrCounter;\\n\\n      uint[] memory indicesToGen = new uint[](possibleRemainingAttrs);\\n      uint indicesToGenCounter;\\n\\n      // enumerate all attributes, add all indices of not-generated attributes to {indexesToGen}\\n      for (uint i; i < info.ids.length; ++i) {\\n        // mandatory attrs should be already generated and no need to check\\n        if (!ctx.usedIndexes[i]) {\\n          indicesToGen[indicesToGenCounter] = i;\\n          indicesToGenCounter++;\\n        }\\n      }\\n\\n      // Shuffle indices of not-generated attributes using Fisher\\u2013Yates shuffle\\n      if (possibleRemainingAttrs > 1) {\\n        for (uint i; i < possibleRemainingAttrs - 1; ++i) {\\n          uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, possibleRemainingAttrs - 1, random_);\\n          (indicesToGen[randomIndex], indicesToGen[i]) = (indicesToGen[i], indicesToGen[randomIndex]);\\n        }\\n      }\\n      // Generate necessary amount of attributes. Fist (shuffled) attributes are selected (MAX_CHANCE is used for each)\\n      for (uint i; i < remainingAttrsToGen; ++i) {\\n        uint idx = indicesToGen[i];\\n        (int32 attr,) = _generateAttribute(info.mins[idx], info.maxs[idx], CalcLib.MAX_CHANCE, random_);\\n        ctx.ids[ctx.counter] = info.ids[idx];\\n        ctx.values[ctx.counter] = attr;\\n        ctx.counter++;\\n      }\\n    }\\n  }\\n\\n  /// @notice Generate all mandatory attributes, generate not more than {meta.maxRandomAttributes} random attributes.\\n  /// Updates context:\\n  ///   {ctx.totalRandomAttrsPossible} - total number of possible random attributes\\n  ///   {ctx.randomAttrCounter} - total number of generated random attributes  <= {maxRandomAttributes}\\n  ///   {ctx.randomSum} = sum of random of all random attributes.\\n  ///   {ctx.chancesSum} = sum of chances of all random attributes.\\n  ///   {ctx.counter} = total number of generated attributes. Values of ctx.ids, ctx.values, ctx.usedIndexes are\\n  ///   initialized in the range [0...ctx.counter)\\n  /// @param ctx Empty struct but arrays ids, values and usedIndexes should be allocated for info.ids.length items\\n  function _prepareAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    uint8 maxRandomAttributes,\\n    GenerateAttributesContext memory ctx,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint len = info.ids.length;\\n    for (uint i; i < len; ++i) {\\n      if (info.chances[i] != CalcLib.MAX_CHANCE) {\\n        ctx.totalRandomAttrsPossible++;\\n      }\\n\\n      if (info.chances[i] >= CalcLib.MAX_CHANCE || !ctx.stopGenerateRandom) {\\n        (int32 attr, uint random) = _generateAttribute(info.mins[i], info.maxs[i], info.chances[i], random_);\\n//          console.log(\\\"GEN id: %s, value: %s%s\\\", _info.ids[i], attr >= 0 ? '' : '-', attr >= 0 ? uint(int(attr)) : uint(int(- attr)));\\n\\n        // count only random attributes for calc rarity\\n        if (attr != 0) {\\n\\n          if (\\n            info.chances[i] < CalcLib.MAX_CHANCE\\n            // && random != 0 // commented: random = 0 can produce crash in _generateMissingRandomAttributes\\n          ) {\\n            ctx.randomAttrCounter++;\\n            ctx.randomSum += random;\\n            ctx.chancesSum += info.chances[i];\\n          }\\n          ctx.ids[ctx.counter] = info.ids[i];\\n          ctx.values[ctx.counter] = attr;\\n          ctx.counter++;\\n          ctx.usedIndexes[i] = true;\\n        }\\n\\n        // it is a bit less fair random for attrs in the end of the list, however we assume it should be pretty rare case\\n        if (ctx.randomAttrCounter == maxRandomAttributes) {\\n          ctx.stopGenerateRandom = true;\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Shuffle info arrays using Fisher\\u2013Yates shuffle algo\\n  function _shuffleInfo(\\n    IItemController.ItemGenerateInfo memory info,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint len = info.ids.length;\\n    if (len > 1) {\\n      for (uint i; i < len - 1; i++) {\\n        uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, len - 1, random_);\\n\\n        (info.ids[randomIndex], info.ids[i]) = (info.ids[i], info.ids[randomIndex]);\\n        (info.mins[randomIndex], info.mins[i]) = (info.mins[i], info.mins[randomIndex]);\\n        (info.maxs[randomIndex], info.maxs[i]) = (info.maxs[i], info.maxs[randomIndex]);\\n        (info.chances[randomIndex], info.chances[i]) = (info.chances[i], info.chances[randomIndex]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Generate array [0,1,2.. N-1] and shuffle it using Fisher\\u2013Yates shuffle algo\\n  function _shuffleIndices(\\n    uint countItems,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint[] memory indices){\\n    indices = new uint[](countItems);\\n    for (uint i = 1; i < countItems; ++i) {\\n      indices[i] = i;\\n    }\\n    if (countItems > 1) {\\n      for (uint i; i < countItems - 1; i++) {\\n        uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, countItems - 1, random_);\\n        (indices[randomIndex], indices[i]) = (indices[i], indices[randomIndex]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Reduce lengths of {ids} and {values} to {count}\\n  function _fixLengthsIdsValues(uint8[] memory ids, int32[] memory values, uint count) internal pure returns (\\n    uint8[] memory idsOut,\\n    int32[] memory valuesOut\\n  ) {\\n    if (count == ids.length) {\\n      return (ids, values);\\n    }\\n\\n    idsOut = new uint8[](count);\\n    valuesOut = new int32[](count);\\n    for (uint i; i < count; ++i) {\\n      idsOut[i] = ids[i];\\n      valuesOut[i] = values[i];\\n    }\\n    return (idsOut, valuesOut);\\n  }\\n\\n  /// @param random_ Pass CalcLib.pseudoRandom here, param is required for unit tests. Max value is MAX_CHANCE\\n  function _generateSimpleAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    bool maxChance,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    uint8[] memory ids,\\n    int32[] memory values\\n  ) {\\n    uint len = info.ids.length;\\n    ids = new uint8[](len);\\n    values = new int32[](len);\\n\\n    uint n = 0;\\n    for (uint i; i < len; ++i) {\\n      (int32 attr,) = _generateAttribute(\\n        info.mins[i],\\n        info.maxs[i],\\n        maxChance ? CalcLib.MAX_CHANCE : info.chances[i],\\n        random_\\n      );\\n      if (attr != 0) {\\n        ids[n] = info.ids[i];\\n        values[n] = attr;\\n        ++n;\\n      }\\n    }\\n\\n    return _fixLengthsIdsValues(ids, values, n);\\n  }\\n\\n  //endregion ------------------------ Internal logic\\n\\n  //region ------------------------ Internal utils\\n  /// @param chance Chance in the range [0...MAX_CHANCE], MAX_CHANCE=1e9 means \\\"mandatory\\\" element.\\n  /// @param random_ Pass CalcLib.pseudoRandom here, param is required for unit tests\\n  /// @return attr Either 0 or min <= attr <= max\\n  /// @return rnd Random value in the range [0...MAX_CHANCE]; It's always 0 for mandatory elements\\n  function _generateAttribute(\\n    int32 min,\\n    int32 max,\\n    uint32 chance,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    int32 attr,\\n    uint rnd\\n  ) {\\n    if (chance > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighChance(chance);\\n\\n    uint diff = uint(CalcLib.absDiff(min, max));\\n\\n    if (chance < CalcLib.MAX_CHANCE) {\\n      uint32 random = CalcLib.pseudoRandomUint32Flex(CalcLib.MAX_CHANCE, random_);\\n      if (random < chance) {\\n        uint r = uint(CalcLib.MAX_CHANCE - random * (CalcLib.MAX_CHANCE / chance));\\n        int32 k = int32(int(r * diff / uint(CalcLib.MAX_CHANCE)));\\n        return (min + k, random);\\n      }\\n    } else { // chance == CalcLib.MAX_CHANCE => mandatory element\\n      if (diff == 0) {\\n        return (min, 0);\\n      } else {\\n        uint r = uint(CalcLib.pseudoRandomUint32Flex(CalcLib.MAX_CHANCE, random_));\\n        int32 k = int32(int(r % (diff + 1)));\\n\\n        // return zero random - no need to calc rarity for mandatory elements\\n        return (min + k, 0);\\n      }\\n    }\\n\\n    return (0, 0);\\n  }\\n\\n  /// @notice Calculate item rarity\\n  /// @param randomSum Total sum random values of all random attributes in ItemGenerateInfo, [0...MAX_CHANCE/attrCounter]\\n  /// @param chancesSum Total sum of all random chances in ItemGenerateInfo\\n  /// @param attrCounter Count of random attributes in ItemGenerateInfo\\n  /// @param maxAttr Index of max allowed random attribute (all attributes with higher indices are not random)\\n  /// @return item rarity\\n  function _calculateRarity(uint randomSum, uint chancesSum, uint attrCounter, uint maxAttr) internal pure returns (\\n    IItemController.ItemRarity\\n  ) {\\n    if (attrCounter == 0) {\\n      return IItemController.ItemRarity.NORMAL;\\n    }\\n\\n    uint random = randomSum / attrCounter;\\n    uint averageChance = chancesSum / attrCounter;\\n\\n    if (random > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighRandom(random);\\n\\n    if (random < averageChance / 4 && attrCounter == maxAttr) {\\n      return IItemController.ItemRarity.RARE;\\n    } else if (random < averageChance * 3 / 4) {\\n      return attrCounter > 2\\n        ? IItemController.ItemRarity.RARE\\n        : IItemController.ItemRarity.MAGIC;\\n    } else {\\n      return attrCounter > 1\\n        ? IItemController.ItemRarity.MAGIC\\n        : IItemController.ItemRarity.NORMAL;\\n    }\\n  }\\n  //endregion ------------------------ Internal utils\\n\\n  //region ------------------------ PACKING\\n\\n  function packItemGenerateInfo(IItemController.ItemGenerateInfo memory info) internal pure returns (bytes32[] memory result) {\\n    uint len = info.ids.length;\\n    if (len != info.mins.length || len != info.maxs.length || len != info.chances.length) {\\n      revert IAppErrors.LengthsMismatch();\\n    }\\n\\n    result = new bytes32[](len);\\n\\n    for (uint i; i < len; ++i) {\\n      result[i] = PackingLib.packItemGenerateInfo(info.ids[i], info.mins[i], info.maxs[i], info.chances[i]);\\n    }\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32[] memory gen) internal pure returns (\\n    IItemController.ItemGenerateInfo memory\\n  ) {\\n    uint length = gen.length;\\n\\n    uint8[] memory ids = new uint8[](length);\\n    int32[] memory mins = new int32[](length);\\n    int32[] memory maxs = new int32[](length);\\n    uint32[] memory chances = new uint32[](length);\\n\\n    for (uint i; i < length; ++i) {\\n      (ids[i], mins[i], maxs[i], chances[i]) = gen[i].unpackItemGenerateInfo();\\n    }\\n\\n    return IItemController.ItemGenerateInfo(ids, mins, maxs, chances);\\n  }\\n\\n  function packItemMeta(IItemController.ItemMeta memory meta) internal pure returns (bytes32) {\\n    return PackingLib.packItemMeta(\\n      meta.itemMetaType,\\n      meta.itemLevel,\\n      uint8(meta.itemType),\\n      meta.baseDurability,\\n      meta.defaultRarity,\\n      meta.minRandomAttributes,\\n      meta.maxRandomAttributes,\\n      meta.manaCost,\\n      meta.requirements\\n    );\\n  }\\n\\n  function unpackedItemMeta(bytes32 meta) internal pure returns (IItemController.ItemMeta memory result) {\\n    return meta.unpackItemMeta();\\n  }\\n\\n  function packItemInfo(IItemController.ItemInfo memory info) internal pure returns (bytes32) {\\n    return PackingLib.packItemInfo(uint8(info.rarity), info.augmentationLevel, info.durability);\\n  }\\n\\n  function unpackedItemInfo(bytes32 info) internal pure returns (IItemController.ItemInfo memory result) {\\n    uint8 rarity;\\n    (rarity, result.augmentationLevel, result.durability) = info.unpackItemInfo();\\n\\n    result.rarity = IItemController.ItemRarity(rarity);\\n    return result;\\n  }\\n\\n  function packItemAttackInfo(IItemController.AttackInfo memory info) internal pure returns (bytes32) {\\n    return PackingLib.packItemAttackInfo(\\n      uint8(info.aType),\\n      info.min,\\n      info.max,\\n      info.attributeFactors.strength,\\n      info.attributeFactors.dexterity,\\n      info.attributeFactors.vitality,\\n      info.attributeFactors.energy\\n    );\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 info) internal pure returns (IItemController.AttackInfo memory result) {\\n    IStatController.CoreAttributes memory fs;\\n    uint8 aType;\\n    (aType, result.min, result.max, fs.strength, fs.dexterity, fs.vitality, fs.energy) = info.unpackItemAttackInfo();\\n\\n    result.aType = IItemController.AttackType(aType);\\n    result.attributeFactors = fs;\\n\\n    return result;\\n  }\\n  //endregion ------------------------ PACKING\\n}\\n\",\"keccak256\":\"0x35be525f87553c0d2c6066c366baa6cb25ec073cdb9dab01efdd0db3b98449b1\",\"license\":\"BUSL-1.1\"},\"contracts/lib/MonsterLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\nimport \\\"./StatLib.sol\\\";\\nimport \\\"./ItemLib.sol\\\";\\nimport \\\"./StringLib.sol\\\";\\nimport \\\"./FightLib.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IFightCalculator.sol\\\";\\nimport \\\"../interfaces/IDungeonFactory.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary MonsterLib {\\n  using CalcLib for int32;\\n  using PackingLib for bytes32;\\n  using PackingLib for bytes32[];\\n  using PackingLib for uint16;\\n  using PackingLib for uint8;\\n  using PackingLib for address;\\n  using PackingLib for uint32[];\\n  using PackingLib for uint32;\\n  using PackingLib for uint64;\\n  using PackingLib for int32[];\\n  using PackingLib for int32;\\n\\n  /// @notice Max value for monster rarity and monster/dungeon multiplier\\n  uint32 internal constant _MAX_AMPLIFIER = 1e9;\\n  uint private constant _TOTAL_SUPPLY_BASE = 10_000_000e18;\\n\\n  //region ------------------------ Data types\\n  struct AdrContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IOracle oracle;\\n    IStatController statController;\\n    IItemController itemController;\\n    uint heroTokenId;\\n  }\\n\\n  struct FightInternalInfo {\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 heroLifeRegen;\\n    int32 heroHp;\\n    int32 monsterHp;\\n    uint32 monsterRarity;\\n    IFightCalculator.FighterInfo heroFightInfo;\\n    IFightCalculator.FighterInfo monsterFightInfo;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Main logic\\n\\n  function initialGeneration(IGOC.MonsterInfo storage mInfo, address heroToken, uint heroTokenId, uint iteration, uint totalSupply) internal {\\n    return _initialGeneration(mInfo, heroToken, heroTokenId, iteration, _pseudoRandom, totalSupply);\\n  }\\n\\n  /// @notice Fight, post fight, generate fight results\\n  /// @return result Fields objectId, heroToken, heroTokenId, iteration remain uninitialized here.\\n  /// Caller is responsible to set that values.\\n  /// @dev weird, but memory ctx is more efficient here than calldata ctx\\n  function action(IGOC.ActionContext memory ctx, IGOC.MonsterInfo storage mInfo) external returns (\\n    IGOC.ActionResult memory result,\\n    uint8 turn\\n  ) {\\n    return _action(ctx, mInfo, _pseudoRandom, FightLib.fight);\\n  }\\n\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ Internal calculations\\n  function _action(\\n    IGOC.ActionContext memory ctx,\\n    IGOC.MonsterInfo storage mInfo,\\n    function (uint) internal view returns (uint) random_,\\n    function(\\n      IItemController,\\n      IFightCalculator.FightCall memory,\\n      function (uint) internal view returns (uint)\\n    ) internal returns (IFightCalculator.FightResult memory) fight_\\n  ) internal returns (\\n    IGOC.ActionResult memory result,\\n    uint8 turn\\n  ) {\\n    AdrContext memory adrCtx = _context(ctx);\\n    IGOC.GeneratedMonster memory gen = unpackGeneratedMonster(mInfo._generatedMonsters[ctx.heroToken.packNftId(ctx.heroTokenId)][ctx.iteration]);\\n    turn = gen.turnCounter;\\n\\n    (FightInternalInfo memory fInfo, IGOC.MonsterGenInfo memory genInfo) = _fight(ctx, mInfo, gen, adrCtx, random_, fight_);\\n    result = _postFight(mInfo, ctx, adrCtx, fInfo, genInfo, gen);\\n  }\\n\\n  /// @dev This function was extracted from {action()} to simplify unit testing\\n  /// @param gen These values CAN BE modified in place in some cases.\\n  /// @return result Fields objectId, heroToken, heroTokenId, iteration remain uninitialized here.\\n  /// Caller is responsible to set that values.\\n  function _postFight(\\n    IGOC.MonsterInfo storage mInfo,\\n    IGOC.ActionContext memory ctx,\\n    AdrContext memory adrCtx,\\n    FightInternalInfo memory fInfo,\\n    IGOC.MonsterGenInfo memory genInfo,\\n    IGOC.GeneratedMonster memory gen\\n  ) internal returns (\\n    IGOC.ActionResult memory result\\n  ) {\\n    bytes32 heroPackedId = ctx.heroToken.packNftId(ctx.heroTokenId);\\n    if (gen.turnCounter > 100) {\\n      // instant kill hero if too long battle\\n      fInfo.heroHp = 0;\\n    }\\n\\n    bool isMonsterDead = fInfo.monsterHp == 0;\\n    bool isHeroDead = fInfo.heroHp == 0;\\n\\n    if (isMonsterDead) {\\n      _bossDefeated(adrCtx, ctx);\\n    }\\n\\n    if (isMonsterDead || isHeroDead) {\\n      if (gen.generated) {\\n        delete mInfo._generatedMonsters[heroPackedId][ctx.iteration];\\n      }\\n      adrCtx.statController.clearUsedConsumables(ctx.heroToken, ctx.heroTokenId);\\n    } else {\\n      if (gen.generated) {\\n        gen.hp = fInfo.monsterHp;\\n        gen.turnCounter = gen.turnCounter + 1;\\n      } else {\\n        // new instance of gen is created\\n        gen = IGOC.GeneratedMonster({\\n          generated: true,\\n          amplifier: fInfo.monsterRarity,\\n          hp: fInfo.monsterHp,\\n          turnCounter: 1\\n        });\\n      }\\n\\n      mInfo._generatedMonsters[heroPackedId][ctx.iteration] = packGeneratedMonster(gen);\\n    }\\n\\n    if (isMonsterDead) {\\n      bytes32 index = _getMonsterCounterIndex(ctx.objectId);\\n      uint curValue = adrCtx.statController.heroCustomData(ctx.heroToken, ctx.heroTokenId, index);\\n      adrCtx.statController.setHeroCustomData(ctx.heroToken, ctx.heroTokenId, index, curValue + 1);\\n    }\\n\\n    // --- generate result\\n    result.kill = isHeroDead;\\n    result.experience = isMonsterDead\\n      ? StatLib.expPerMonster(\\n        fInfo.monsterFightInfo.fighterStats.experience,\\n        fInfo.monsterRarity,\\n        fInfo.heroFightInfo.fighterStats.experience,\\n        fInfo.heroFightInfo.fighterStats.level,\\n        ctx.biome\\n      )\\n      : 0;\\n\\n    result.heal = fInfo.heroLifeRegen;\\n    result.manaRegen = isMonsterDead ? fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MANA_AFTER_KILL)] : int32(0);\\n    // result.lifeChancesRecovered = 0; // zero by default\\n    result.damage = fInfo.damage;\\n    result.manaConsumed = fInfo.manaConsumed;\\n    result.mintItems = isMonsterDead\\n      ? _mintRandomItems(fInfo, ctx, genInfo, CalcLib.nextPrng)\\n      : new address[](0);\\n    result.completed = isMonsterDead || isHeroDead;\\n\\n    return result;\\n  }\\n\\n  /// @notice Generate new {GeneratedMonster} and put it to {mInfo._generatedMonsters}\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...MAX_AMPLIFIER]\\n  function _initialGeneration(\\n    IGOC.MonsterInfo storage mInfo,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint iteration,\\n    function (uint) internal view returns (uint) random_,\\n    uint totalSupply\\n  ) internal {\\n    IGOC.GeneratedMonster memory gen = IGOC.GeneratedMonster({\\n      generated: true,\\n      amplifier: uint32(random_(_MAX_AMPLIFIER)),\\n      hp: 0,\\n      turnCounter: 0\\n    });\\n\\n    IGOC.MonsterGenInfo memory info = unpackMonsterInfo(mInfo);\\n\\n    (int32[] memory attributes,) = generateMonsterAttributes(\\n      info.attributeIds,\\n      info.attributeValues,\\n      gen.amplifier,\\n      monsterMultiplier(totalSupply),\\n      info.experience\\n    );\\n    gen.hp = attributes[uint(IStatController.ATTRIBUTES.LIFE)];\\n\\n    mInfo._generatedMonsters[heroToken.packNftId(heroTokenId)][iteration] = packGeneratedMonster(gen);\\n  }\\n\\n  function _bossDefeated(AdrContext memory adrCtx, IGOC.ActionContext memory ctx) internal {\\n    if (ctx.objectSubType == uint8(IGOC.ObjectSubType.BOSS_3)) {\\n      IDungeonFactory(adrCtx.controller.dungeonFactory()).setBossCompleted(ctx.objectId, ctx.heroToken, ctx.heroTokenId, ctx.biome);\\n    }\\n  }\\n\\n  function _collectHeroFighterInfo(\\n    IFightCalculator.AttackInfo memory attackInfo,\\n    AdrContext memory adrContext\\n  ) internal view returns (\\n    IFightCalculator.FighterInfo memory fInfo,\\n    int32 manaConsumed\\n  ) {\\n    IStatController.ChangeableStats memory heroStats = adrContext.statController.heroStats(adrContext.heroToken, adrContext.heroTokenId);\\n\\n    (int32[] memory heroAttributes, int32 _manaConsumed) = _buffAndGetHeroAttributes(heroStats.level, attackInfo, adrContext);\\n\\n    manaConsumed = _manaConsumed;\\n\\n    if (attackInfo.attackType == IFightCalculator.AttackType.MAGIC) {\\n      manaConsumed += int32(adrContext.itemController.itemMeta(attackInfo.attackToken).manaCost);\\n    }\\n\\n    fInfo = IFightCalculator.FighterInfo({\\n      fighterAttributes: heroAttributes,\\n      fighterStats: heroStats,\\n      attackType: attackInfo.attackType,\\n      attackToken: attackInfo.attackToken,\\n      attackTokenId: attackInfo.attackTokenId,\\n      race: uint(IStatController.Race.HUMAN)\\n    });\\n  }\\n\\n  function _buffAndGetHeroAttributes(\\n    uint level,\\n    IFightCalculator.AttackInfo memory attackInfo,\\n    AdrContext memory context\\n  ) internal view returns (\\n    int32[] memory heroAttributes,\\n    int32 manaConsumed\\n  ) {\\n    return context.statController.buffHero(IStatController.BuffInfo({\\n      heroToken: context.heroToken,\\n      heroTokenId: context.heroTokenId,\\n      heroLevel: uint32(level),\\n      buffTokens: attackInfo.skillTokens,\\n      buffTokenIds: attackInfo.skillTokenIds\\n    }));\\n  }\\n\\n  /// @notice Get skill tokens, ensure that they are equipped on, add skill-tokens target attributes to hero attributes\\n  /// @param attributes Hero attributes. These values are incremented in place\\n  function _debuff(\\n    int32[] memory attributes,\\n    IFightCalculator.AttackInfo memory heroAttackInfo,\\n    AdrContext memory context\\n  ) internal view {\\n    uint length = heroAttackInfo.skillTokens.length;\\n    for (uint i; i < length; ++i) {\\n      address token = heroAttackInfo.skillTokens[i];\\n      uint id = heroAttackInfo.skillTokenIds[i];\\n\\n      (address equippedHero, uint equippedHeroId) = context.itemController.equippedOn(token, id);\\n      if (context.heroToken != equippedHero || context.heroTokenId != equippedHeroId) revert IAppErrors.NotYourDebuffItem();\\n\\n      (int32[] memory values, uint8[] memory ids) = context.itemController.targetAttributes(token, id);\\n\\n      StatLib.attributesAdd(attributes, StatLib.valuesToFullAttributesArray(values, ids));\\n    }\\n  }\\n\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...MAX_AMPLIFIER]\\n  function _collectMonsterFighterInfo(\\n    IGOC.MultiplierInfo memory multiplierInfo,\\n    IGOC.MonsterInfo storage mInfo,\\n    IGOC.GeneratedMonster memory gen,\\n    IFightCalculator.AttackInfo memory heroAttackInfo,\\n    uint heroLevel,\\n    AdrContext memory adrCtx,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    IFightCalculator.FighterInfo memory fighterInfo,\\n    uint32 rarity,\\n    IGOC.MonsterGenInfo memory genInfo\\n  ) {\\n    IFightCalculator.AttackInfo memory attackInfo;\\n\\n    rarity = gen.generated ? gen.amplifier : uint32(random_(_MAX_AMPLIFIER));\\n    (\\n      fighterInfo.fighterAttributes,\\n      fighterInfo.fighterStats.level,\\n      fighterInfo.fighterStats.experience,\\n      attackInfo,\\n      genInfo\\n    ) = _generateMonsterInfo(mInfo, rarity, monsterMultiplier(multiplierInfo.totalSupply), heroLevel, multiplierInfo.biome, random_);\\n\\n    _debuff(fighterInfo.fighterAttributes, heroAttackInfo, adrCtx);\\n\\n    fighterInfo.fighterStats.life = gen.generated\\n      ? uint32(gen.hp)\\n      : fighterInfo.fighterStats.life = uint32(CalcLib.max32(fighterInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.LIFE)], int32(1)));\\n\\n    fighterInfo.fighterStats.mana = uint32(fighterInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MANA)]);\\n\\n    fighterInfo.attackType = attackInfo.attackType;\\n    fighterInfo.attackToken = attackInfo.attackToken;\\n    fighterInfo.attackTokenId = attackInfo.attackTokenId;\\n    fighterInfo.race = genInfo.race;\\n\\n    return (fighterInfo, rarity, genInfo);\\n  }\\n\\n  /// @param random_ Pass _pseudoRandom here, param is required to simplify unit testing\\n  /// @param fight_ Pass FightLib.fight here, param is required to simplify unit testing\\n  function _fight(\\n    IGOC.ActionContext memory ctx,\\n    IGOC.MonsterInfo storage mInfo,\\n    IGOC.GeneratedMonster memory gen,\\n    AdrContext memory adrCtx,\\n    function (uint) internal view returns (uint) random_,\\n    function(\\n      IItemController,\\n      IFightCalculator.FightCall memory,\\n      function (uint) internal view returns (uint)\\n    ) internal returns (IFightCalculator.FightResult memory) fight_\\n  ) internal returns (\\n    FightInternalInfo memory fInfo,\\n    IGOC.MonsterGenInfo memory info\\n  ) {\\n    IFightCalculator.FighterInfo memory heroFightInfo;\\n    IFightCalculator.FighterInfo memory monsterFightInfo;\\n\\n    {\\n      IFightCalculator.AttackInfo memory heroAttackInfo = decodeAndCheckAttackInfo(\\n        adrCtx.itemController,\\n        ctx.data,\\n        adrCtx.heroToken,\\n        adrCtx.heroTokenId\\n      );\\n\\n      // use fInfo.manaConsumed and fInfo.monsterRarity to story values temporally to avoid creation of additional vars\\n      (heroFightInfo, fInfo.manaConsumed) = _collectHeroFighterInfo(heroAttackInfo, adrCtx);\\n      (monsterFightInfo, fInfo.monsterRarity, info) = _collectMonsterFighterInfo(\\n        IGOC.MultiplierInfo(ctx.biome, IERC20(ctx.controller.gameToken()).totalSupply()),\\n        mInfo,\\n        gen,\\n        heroAttackInfo,\\n        heroFightInfo.fighterStats.level,\\n        adrCtx,\\n        random_\\n      );\\n    }\\n\\n    // >>> FIGHT!\\n    IFightCalculator.FightResult memory fightResult = fight_(\\n      adrCtx.itemController,\\n      IFightCalculator.FightCall({\\n        fighterA: heroFightInfo,\\n        fighterB: monsterFightInfo,\\n        dungeonId: ctx.dungeonId,\\n        objectId: ctx.objectId,\\n        heroAdr: adrCtx.heroToken,\\n        heroId: adrCtx.heroTokenId,\\n        stageId: ctx.stageId,\\n        iteration: ctx.iteration,\\n        turn: gen.turnCounter\\n      }),\\n      random_\\n    );\\n\\n    fInfo = FightInternalInfo({\\n      manaConsumed: fInfo.manaConsumed + fightResult.manaConsumedA,\\n      monsterRarity: fInfo.monsterRarity,\\n      damage: _calcDmg(int32(heroFightInfo.fighterStats.life), fightResult.healthA),\\n      heroFightInfo: heroFightInfo,\\n      monsterFightInfo: monsterFightInfo,\\n      heroLifeRegen: fightResult.healthA > int32(heroFightInfo.fighterStats.life) ? fightResult.healthA - int32(heroFightInfo.fighterStats.life) : int32(0),\\n      heroHp: fightResult.healthA,\\n      monsterHp: fightResult.healthB\\n    });\\n  }\\n\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...1e18]\\n  /// @return attributes Attributes amplified on amplifier and dungeonMultiplier\\n  /// @return level Result level in the range: [mInfo.level .. heroLevel]\\n  /// @return experience Experience amplified on amplifier and dungeonMultiplier\\n  /// @return attackInfo Attack info. For magic hero attack type monster will have melee in half hits (randomly)\\n  /// @return info Unpacked data from {mInfo}, some fields can be uninitialized, see comments to unpackMonsterInfo (!)\\n  function _generateMonsterInfo(\\n    IGOC.MonsterInfo storage mInfo,\\n    uint32 amplifier,\\n    int32 dungeonMultiplier,\\n    uint heroLevel,\\n    uint biome,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    int32[] memory attributes,\\n    uint32 level,\\n    uint32 experience,\\n    IFightCalculator.AttackInfo memory attackInfo,\\n    IGOC.MonsterGenInfo memory info\\n  ) {\\n    info = unpackMonsterInfo(mInfo);\\n\\n    level = uint32(info.level);\\n    if (level < heroLevel + 1) {\\n      level = uint32(Math.min(level + ((heroLevel - level) * 10 / 15), biome * 5));\\n    }\\n\\n    if (info.attackType == uint8(IFightCalculator.AttackType.MAGIC)) {\\n      // sometimes use melee (25% chance)\\n      uint rnd = random_(1e18);\\n      if (rnd > 0.75e18) {\\n        attackInfo.attackType = IFightCalculator.AttackType.MELEE;\\n      } else {\\n        attackInfo.attackType = IFightCalculator.AttackType.MAGIC;\\n        attackInfo.attackToken = info.attackToken;\\n        attackInfo.attackTokenId = info.attackTokenId;\\n      }\\n    } else {\\n      attackInfo.attackType = IFightCalculator.AttackType(info.attackType);\\n    }\\n\\n    (attributes, experience) = generateMonsterAttributes(\\n      info.attributeIds,\\n      info.attributeValues,\\n      amplifier,\\n      dungeonMultiplier,\\n      info.experience\\n    );\\n\\n    return (attributes, level, experience, attackInfo, info);\\n  }\\n\\n  function _mintRandomItems(\\n    FightInternalInfo memory fInfo,\\n    IGOC.ActionContext memory ctx,\\n    IGOC.MonsterGenInfo memory genInfo,\\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\\n  ) internal returns (\\n    address[] memory\\n  ) {\\n    return ItemLib._mintRandomItems(\\n      ItemLib.MintItemInfo({\\n        mintItems: genInfo.mintItems,\\n        mintItemsChances: genInfo.mintItemsChances,\\n        biome: ctx.biome,\\n        amplifier: fInfo.monsterRarity,\\n        seed: 0,\\n        oracle: IOracle(ctx.controller.oracle()),\\n        heroExp: fInfo.heroFightInfo.fighterStats.experience,\\n        heroCurrentLvl: uint8(fInfo.heroFightInfo.fighterStats.level),\\n        magicFind: fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MAGIC_FIND)],\\n        destroyItems: fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DESTROY_ITEMS)],\\n        maxItems: genInfo.maxDropItems\\n      }),\\n      nextPrng_\\n    );\\n  }\\n\\n  //endregion ------------------------ Internal calculations\\n\\n  //region ------------------------ Utils\\n\\n  function _context(IGOC.ActionContext memory ctx) internal view returns (AdrContext memory context) {\\n    context = AdrContext({\\n      sender: ctx.sender,\\n      heroToken: ctx.heroToken,\\n      heroTokenId: ctx.heroTokenId,\\n      controller: ctx.controller,\\n      oracle: IOracle(ctx.controller.oracle()),\\n      statController: IStatController(ctx.controller.statController()),\\n      itemController: IItemController(ctx.controller.itemController())\\n    });\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 gen) internal pure returns (IGOC.GeneratedMonster memory result) {\\n    (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) = gen.unpackGeneratedMonster();\\n    result = IGOC.GeneratedMonster({\\n      generated: generated,\\n      amplifier: amplifier,\\n      hp: hp,\\n      turnCounter: turnCounter\\n    });\\n  }\\n\\n  function packGeneratedMonster(IGOC.GeneratedMonster memory gen) internal pure returns (bytes32) {\\n    return PackingLib.packGeneratedMonster(gen.generated, gen.amplifier, gen.hp, gen.turnCounter);\\n  }\\n\\n  function packMonsterInfo(IGOC.MonsterGenInfo memory mInfo, IGOC.MonsterInfo storage info) internal {\\n    info.attributes = mInfo.attributeValues.toBytes32ArrayWithIds(mInfo.attributeIds);\\n    info.stats = PackingLib.packMonsterStats(mInfo.level, mInfo.race, mInfo.experience, mInfo.maxDropItems);\\n    info.attackInfo = PackingLib.packAttackInfo(mInfo.attackToken, mInfo.attackTokenId, mInfo.attackType);\\n\\n    uint len = mInfo.mintItems.length;\\n    bytes32[] memory mintItems = new bytes32[](len);\\n\\n    for (uint i; i < len; ++i) {\\n      mintItems[i] = mInfo.mintItems[i].packItemMintInfo(mInfo.mintItemsChances[i]);\\n    }\\n\\n    info.mintItems = mintItems;\\n  }\\n\\n  /// @return Attention: Following fields are not initialized: biome, subType, monsterId\\n  function unpackMonsterInfo(IGOC.MonsterInfo storage mInfo) internal view returns (IGOC.MonsterGenInfo memory) {\\n    IGOC.MonsterGenInfo memory result;\\n    (result.attributeValues, result.attributeIds) = mInfo.attributes.toInt32ArrayWithIds();\\n    (result.level, result.race, result.experience, result.maxDropItems) = mInfo.stats.unpackMonsterStats();\\n    (result.attackToken, result.attackTokenId, result.attackType) = mInfo.attackInfo.unpackAttackInfo();\\n\\n    uint len = mInfo.mintItems.length;\\n    result.mintItems = new address[](len);\\n    result.mintItemsChances = new uint32[](len);\\n\\n    for (uint i = 0; i < len; i++) {\\n      (result.mintItems[i], result.mintItemsChances[i]) = mInfo.mintItems[i].unpackItemMintInfo();\\n    }\\n\\n    // Attention: result.biome, result.subType, result.monsterId are not initialized\\n    return result;\\n  }\\n\\n  function decodeAndCheckAttackInfo(IItemController ic, bytes memory data, address heroToken, uint heroId) internal view returns (IFightCalculator.AttackInfo memory) {\\n    (IFightCalculator.AttackInfo memory attackInfo) = abi.decode(data, (IFightCalculator.AttackInfo));\\n\\n    if (uint(attackInfo.attackType) == 0) revert IAppErrors.UnknownAttackType(uint(attackInfo.attackType));\\n\\n    if (attackInfo.attackToken != address(0)) {\\n      (address h, uint hId) = ic.equippedOn(attackInfo.attackToken, attackInfo.attackTokenId);\\n      if (heroToken != h || hId != heroId) revert IAppErrors.NotYourAttackItem();\\n    }\\n\\n    for (uint i; i < attackInfo.skillTokens.length; ++i) {\\n      (address h, uint hId) = ic.equippedOn(attackInfo.skillTokens[i], attackInfo.skillTokenIds[i]);\\n      if (heroToken != h || hId != heroId) revert IAppErrors.NotYourBuffItem();\\n    }\\n\\n    return attackInfo;\\n  }\\n\\n  /// @dev MAX_AMPLIFIER value will means +100% to all attributes\\n  ///      slowly increase monsters power from 10% of the target supply\\n  function monsterMultiplier(uint totalSupply) internal pure returns (int32) {\\n    if(totalSupply < _TOTAL_SUPPLY_BASE / 10) {\\n      return 0;\\n    }\\n\\n    return int32(int((uint(_MAX_AMPLIFIER) * totalSupply) / _TOTAL_SUPPLY_BASE));\\n  }\\n\\n  function getMonsterMultiplier(IController controller) internal view returns (int32) {\\n    uint totalSupply = IERC20(controller.gameToken()).totalSupply();\\n    return monsterMultiplier(totalSupply);\\n  }\\n\\n  function amplifyMonsterAttribute(int32 value, uint32 amplifier, int32 dungeonMultiplier) internal pure returns (int32) {\\n    if (value == 0) {\\n      return 0;\\n    }\\n    return value +\\n      int32(\\n        (int(value) * int(uint(amplifier)) / int(uint(_MAX_AMPLIFIER)))\\n        + (int(value) * int(dungeonMultiplier) / int(uint(_MAX_AMPLIFIER)))\\n      );\\n  }\\n\\n  /// @dev A wrapper around {CalcLib.pseudoRandom} to pass it as param (to be able to implement unit tests}\\n  function _pseudoRandom(uint max) internal view returns (uint) {\\n    return CalcLib.pseudoRandom(max);\\n  }\\n\\n  /// @notice Amplify values of the attributes and of the experience\\n  ///         using randomly generated {amplifier} and {dungeonMultiplier}.\\n  ///         Attributes = amplify(ids, values), experience = amplify(baseExperience)\\n  function generateMonsterAttributes(\\n    uint8[] memory ids,\\n    int32[] memory values,\\n    uint32 amplifier,\\n    int32 dungeonMultiplier,\\n    uint32 baseExperience\\n  ) internal pure returns (\\n    int32[] memory attributes,\\n    uint32 experience\\n  ) {\\n    // reduce random\\n    amplifier = amplifier / 4;\\n\\n    attributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < ids.length; ++i) {\\n      attributes[ids[i]] = amplifyMonsterAttribute(values[i], amplifier, dungeonMultiplier);\\n    }\\n    experience = uint32(amplifyMonsterAttribute(int32(baseExperience), amplifier, dungeonMultiplier));\\n  }\\n\\n  function _calcDmg(int32 heroLifeBefore, int32 heroLifeAfter) internal pure returns (int32 damage) {\\n    return heroLifeAfter == 0\\n      ? heroLifeBefore\\n      : heroLifeBefore - CalcLib.minI32(heroLifeAfter, heroLifeBefore);\\n  }\\n\\n  function _getMonsterCounterIndex(uint32 objectId) internal pure returns (bytes32) {\\n    return bytes32(abi.encodePacked(\\\"MONSTER_\\\", StringLib._toString(uint(objectId))));\\n  }\\n  //endregion ------------------------ Utils\\n\\n\\n}\\n\",\"keccak256\":\"0xf4f9c00f224db5907fa3808497d6ea8381ad4964414d4cf3a2c62501f613f7ce\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PackingLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\n\\nlibrary PackingLib {\\n\\n  error TooHighValue(uint value);\\n  error OutOfBounds(uint index, uint length);\\n  error UnexpectedValue(uint expected, uint actual);\\n  error WrongValue(uint newValue, uint actual);\\n  error LengthsMismatch();\\n  error IntOutOfRange(int value);\\n  error ZeroValue();\\n  /// @notice packCustomDataChange requires an input string with two zero bytes at the beginning\\n  ///         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// This error happens if these bytes are not zero\\n  error IncompatibleInputString();\\n\\n  //////////////////////////\\n  // ---- PACKING LOGIC ----\\n  //////////////////////////\\n\\n  //region ------------------------------------ COMMON\\n\\n  function packNftId(address token, uint id) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n  }\\n\\n  function unpackNftId(bytes32 data) internal pure returns (address token, uint id) {\\n    token = address(uint160(uint(data)));\\n    id = uint(data) >> 160;\\n  }\\n\\n  function packAddressWithAmount(address token, uint amount) internal pure returns (bytes32 data) {\\n    if (amount > uint(type(uint96).max)) revert TooHighValue(amount);\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(uint96(amount))) << 160;\\n  }\\n\\n  function unpackAddressWithAmount(bytes32 data) internal pure returns (address token, uint amount) {\\n    token = address(uint160(uint(data)));\\n    amount = uint(data) >> 160;\\n  }\\n\\n  function packItemMintInfo(address item, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(chance)) << 160;\\n  }\\n\\n  function unpackItemMintInfo(bytes32 data) internal pure returns (address item, uint32 chance) {\\n    item = address(uint160(uint(data)));\\n    chance = uint32(uint(data) >> 160);\\n  }\\n\\n  /// @param customDataIndex We assume, that two lowest bytes of this string are always zero\\n  /// So, the string looks like following: 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// Last 2 bytes will be used to encode {value}\\n  function packCustomDataChange(bytes32 customDataIndex, int16 value) internal pure returns (bytes32 data) {\\n    if (uint(customDataIndex) != (uint(customDataIndex) >> 16) << 16) revert IncompatibleInputString();\\n    data = bytes32(uint(customDataIndex));\\n    data |= bytes32(uint(uint16(value)));\\n  }\\n\\n  function unpackCustomDataChange(bytes32 data) internal pure returns (bytes32 customDataIndex, int16 value) {\\n    customDataIndex = bytes32((uint(data) >> 16) << 16);\\n    value = int16(int(uint(uint16(uint(data)))));\\n  }\\n\\n  /// @dev min(uint64) + max(uint64) + isHeroData/isMandatory(uint8)\\n  function packCustomDataRequirements(uint64 min, uint64 max, bool key) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(min));\\n    data |= bytes32(uint(max)) << 64;\\n    data |= bytes32(uint(key ? uint8(1) : uint8(0))) << (64 + 64);\\n  }\\n\\n  function unpackCustomDataRequirements(bytes32 data) internal pure returns (uint64 min, uint64 max, bool key) {\\n    min = uint64(uint(data));\\n    max = uint64(uint(data) >> 64);\\n    key = uint8(uint(data) >> (64 + 64)) == uint8(1);\\n  }\\n\\n  function packStatsChange(\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(experience));\\n    data |= bytes32(uint(uint32(heal))) << 32;\\n    data |= bytes32(uint(uint32(manaRegen))) << (32 + 32);\\n    data |= bytes32(uint(uint32(lifeChancesRecovered))) << (32 + 32 + 32);\\n    data |= bytes32(uint(uint32(damage))) << (32 + 32 + 32 + 32);\\n    data |= bytes32(uint(uint32(manaConsumed))) << (32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackStatsChange(bytes32 data) internal pure returns (\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) {\\n    experience = uint32(uint(data));\\n    heal = int32(int(uint(data) >> 32));\\n    manaRegen = int32(int(uint(data) >> (32 + 32)));\\n    lifeChancesRecovered = int32(int(uint(data) >> (32 + 32 + 32)));\\n    damage = int32(int(uint(data) >> (32 + 32 + 32 + 32)));\\n    manaConsumed = int32(int(uint(data) >> (32 + 32 + 32 + 32 + 32)));\\n  }\\n  //endregion ------------------------------------ COMMON\\n\\n  //region ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(bytes20(objectAddress));\\n    packedData |= bytes32(uint(objectId) << 32);\\n    packedData |= bytes32(uint(objectType) << 24);\\n  }\\n\\n  function unpackMapObject(bytes32 packedData) internal pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\\n    objectAddress = address(bytes20(packedData));\\n    objectId = uint64(uint(packedData) >> 32);\\n    objectType = uint8(uint(packedData) >> 24);\\n  }\\n\\n  function packCoordinate(uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(x));\\n    packedData |= bytes32(uint(y) << 128);\\n  }\\n\\n  function unpackCoordinate(bytes32 packedData) internal pure returns (uint128 x, uint128 y) {\\n    x = uint128(uint(packedData));\\n    y = uint128(uint(packedData) >> 128);\\n  }\\n\\n  /// @param x Assume x <= max uint64\\n  /// @param y Assume y <= max uint64\\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    // 256 => 128 + 128;\\n    // 1) 128 is used for biomeMapFieldId, territoryNumber and probably other fields in the future\\n    // 2) 128 is used to store x, y as uint64, uint64\\n\\n    // we will use uint64 for coordinates assuming it is more than enough for biome map\\n    packedData = bytes32(uint(biomeMapFieldId));\\n    packedData |= bytes32(uint(territoryNumber) << (8));\\n    packedData |= bytes32(uint(uint64(x)) << 128);\\n    packedData |= bytes32(uint(uint64(y)) << (64 + 128));\\n  }\\n\\n  function unpackBattlefieldId(bytes32 packedData) internal pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\\n    biomeMapFieldId = uint8(uint(packedData));\\n    territoryNumber = uint8(uint(packedData) >> (8));\\n    x = uint128(uint64(uint(packedData) >> (128)));\\n    y = uint128(uint64(uint(packedData) >> (64 + 128)));\\n  }\\n  //endregion ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  //region ------------------------------------ REINFORCEMENT\\n\\n  function packReinforcementHeroInfo(uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(biome));\\n    packedData |= bytes32(uint(score) << 8);\\n    packedData |= bytes32(uint(fee) << (8 + 128));\\n    packedData |= bytes32(uint(stakeTs) << (8 + 128 + 8));\\n  }\\n\\n  function unpackReinforcementHeroInfo(bytes32 packedData) internal pure returns (uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) {\\n    biome = uint8(uint(packedData));\\n    score = uint128(uint(packedData) >> 8);\\n    fee = uint8(uint(packedData) >> (8 + 128));\\n    stakeTs = uint64(uint(packedData) >> (8 + 128 + 8));\\n  }\\n  //endregion ------------------------------------ REINFORCEMENT\\n\\n  //region ------------------------------------ DUNGEON\\n\\n  function packDungeonKey(address heroAdr, uint80 heroId, uint16 dungLogicNum) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(dungLogicNum)) << (160 + 80);\\n  }\\n\\n  function unpackDungeonKey(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 dungLogicNum) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    dungLogicNum = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  // --- GAME OBJECTS ---\\n\\n  function packIterationKey(address heroAdr, uint64 heroId, uint32 objId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(objId)) << (160 + 64);\\n  }\\n\\n  function unpackIterationKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint32 objId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    objId = uint32(uint(data) >> (160 + 64));\\n  }\\n\\n  function packMonsterStats(\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(level));\\n    data |= bytes32(uint(race)) << 8;\\n    data |= bytes32(uint(experience)) << (8 + 8);\\n    data |= bytes32(uint(maxDropItems)) << (8 + 8 + 32);\\n  }\\n\\n  function unpackMonsterStats(bytes32 data) internal pure returns (\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) {\\n    level = uint8(uint(data));\\n    race = uint8(uint(data) >> 8);\\n    experience = uint32(uint(data) >> (8 + 8));\\n    maxDropItems = uint8(uint(data) >> (8 + 8 + 32));\\n  }\\n\\n  function packAttackInfo(\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(attackToken)));\\n    data |= bytes32(uint(attackTokenId)) << 160;\\n    data |= bytes32(uint(attackType)) << (160 + 64);\\n  }\\n\\n  function unpackAttackInfo(bytes32 data) internal pure returns (\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) {\\n    attackToken = address(uint160(uint(data)));\\n    attackTokenId = uint64(uint(data) >> 160);\\n    attackType = uint8(uint(data) >> (160 + 64));\\n  }\\n\\n  function packPlayedObjKey(address heroAdr, uint64 heroId, uint8 oType, uint8 biome) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(oType)) << (160 + 64);\\n    data |= bytes32(uint(biome)) << (160 + 64 + 8);\\n  }\\n\\n  function unpackPlayedObjKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint8 oType, uint8 biome) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    oType = uint8(uint(data) >> (160 + 64));\\n    biome = uint8(uint(data) >> (160 + 64 + 8));\\n  }\\n\\n  function packGeneratedMonster(bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint8(generated ? 1 : 0)));\\n    data |= bytes32(uint(amplifier)) << 8;\\n    data |= bytes32(uint(uint32(hp))) << (8 + 32);\\n    data |= bytes32(uint(turnCounter)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 data) internal pure returns (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) {\\n    generated = uint8(uint(data)) == uint8(1);\\n    amplifier = uint32(uint(data) >> 8);\\n    hp = int32(int(uint(data) >> (8 + 32)));\\n    turnCounter = uint8(uint(data) >> (8 + 32 + 32));\\n  }\\n  //endregion ------------------------------------ DUNGEON\\n\\n  //region ------------------------------------ ITEMS\\n\\n  /// @notice itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n  /// @param itemType This is ItemType enum\\n  function packItemMeta(\\n    uint8 itemMetaType,\\n    uint8 itemLvl,\\n    uint8 itemType,\\n    uint16 baseDurability,\\n    uint8 defaultRarity,\\n    uint8 minAttr,\\n    uint8 maxAttr,\\n    uint32 manaCost,\\n    IStatController.CoreAttributes memory req\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(itemMetaType));\\n    data |= bytes32(uint(itemLvl)) << 8;\\n    data |= bytes32(uint(itemType)) << (8 + 8);\\n    data |= bytes32(uint(baseDurability)) << (8 + 8 + 8);\\n    data |= bytes32(uint(defaultRarity)) << (8 + 8 + 8 + 16);\\n    data |= bytes32(uint(minAttr)) << (8 + 8 + 8 + 16 + 8);\\n    data |= bytes32(uint(maxAttr)) << (8 + 8 + 8 + 16 + 8 + 8);\\n    data |= bytes32(uint(manaCost)) << (8 + 8 + 8 + 16 + 8 + 8 + 8);\\n    data |= bytes32(uint(int(req.strength))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32);\\n    data |= bytes32(uint(int(req.dexterity))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32);\\n    data |= bytes32(uint(int(req.vitality))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(req.energy))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemMeta(bytes32 data) internal pure returns (IItemController.ItemMeta memory) {\\n    IItemController.ItemMeta memory result;\\n\\n    result.itemMetaType = uint8(uint(data));\\n    result.itemLevel = uint8(uint(data) >> 8);\\n    result.itemType = IItemController.ItemType(uint8(uint(data) >> (8 + 8)));\\n    result.baseDurability = uint16(uint(data) >> (8 + 8 + 8));\\n    result.defaultRarity = uint8(uint(data) >> (8 + 8 + 8 + 16));\\n    result.minRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8));\\n    result.maxRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8));\\n    result.manaCost = uint32(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8));\\n    result.requirements.strength = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32)));\\n    result.requirements.dexterity = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32)));\\n    result.requirements.vitality = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32)));\\n    result.requirements.energy = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32)));\\n\\n    return result;\\n  }\\n\\n  function packItemGenerateInfo(uint8 id, int32 min, int32 max, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(id));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(chance)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32 data) internal pure returns (uint8 id, int32 min, int32 max, uint32 chance) {\\n    id = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    chance = uint32(uint(data) >> (8 + 32 + 32));\\n  }\\n\\n  function packItemAttackInfo(\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attackType));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(int(factorStr))) << (8 + 32 + 32);\\n    data |= bytes32(uint(int(factorDex))) << (8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorVit))) << (8 + 32 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorEng))) << (8 + 32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 data) internal pure returns (\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) {\\n    attackType = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    factorStr = int32(int(uint(data) >> (8 + 32 + 32)));\\n    factorDex = int32(int(uint(data) >> (8 + 32 + 32 + 32)));\\n    factorVit = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32)));\\n    factorEng = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packItemInfo(uint8 rarity, uint8 augmentationLevel, uint16 durability) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(rarity));\\n    data |= bytes32(uint(augmentationLevel)) << 8;\\n    data |= bytes32(uint(durability)) << (8 + 8);\\n  }\\n\\n  function unpackItemInfo(bytes32 data) internal pure returns (uint8 rarity, uint8 augmentationLevel, uint16 durability) {\\n    rarity = uint8(uint(data));\\n    augmentationLevel = uint8(uint(data) >> 8);\\n    durability = uint16(uint(data) >> (8 + 8));\\n  }\\n  //endregion ------------------------------------ ITEMS\\n\\n  //region ------------------------------------ STORIES\\n\\n  function packStoryPageId(uint16 storyId, uint16 pageId, uint8 heroClass) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n  }\\n\\n  function unpackStoryPageId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n  }\\n\\n  function packStoryAnswerId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n  }\\n\\n  function unpackStoryAnswerId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n  }\\n\\n  function packStoryNextPagesId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(resultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryNextPagesId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    resultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryAttributeRequirement(uint8 attributeIndex, int32 value, bool isCore) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attributeIndex));\\n    data |= bytes32(uint(uint32(value))) << 8;\\n    data |= bytes32(uint(isCore ? uint8(1) : uint8(0))) << (8 + 32);\\n  }\\n\\n  function unpackStoryAttributeRequirement(bytes32 data) internal pure returns (uint8 attributeIndex, int32 value, bool isCore) {\\n    attributeIndex = uint8(uint(data));\\n    value = int32(int(uint(data) >> 8));\\n    isCore = uint8(uint(data) >> (8 + 32)) == uint8(1);\\n  }\\n\\n  function packStoryItemRequirement(address item, bool requireItemBurn, bool requireItemEquipped) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(requireItemBurn ? uint8(1) : uint8(0))) << 160;\\n    data |= bytes32(uint(requireItemEquipped ? uint8(1) : uint8(0))) << (160 + 8);\\n  }\\n\\n  function unpackStoryItemRequirement(bytes32 data) internal pure returns (address item, bool requireItemBurn, bool requireItemEquipped) {\\n    item = address(uint160(uint(data)));\\n    requireItemBurn = uint8(uint(data) >> 160) == uint8(1);\\n    requireItemEquipped = uint8(uint(data) >> (160 + 8)) == uint8(1);\\n  }\\n\\n  /// @dev max amount is 309,485,009 for token with 18 decimals\\n  function packStoryTokenRequirement(address token, uint88 amount, bool requireTransfer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(amount)) << 160;\\n    data |= bytes32(uint(requireTransfer ? uint8(1) : uint8(0))) << (160 + 88);\\n  }\\n\\n  function unpackStoryTokenRequirement(bytes32 data) internal pure returns (address token, uint88 amount, bool requireTransfer) {\\n    token = address(uint160(uint(data)));\\n    amount = uint88(uint(data) >> 160);\\n    requireTransfer = uint8(uint(data) >> (160 + 88)) == uint8(1);\\n  }\\n\\n  function packStoryCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(customDataResultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryCustomDataResult(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    customDataResultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryHeroState(uint16 pageId, uint40 heroLastActionTS) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(pageId));\\n    data |= bytes32(uint(heroLastActionTS)) << 16;\\n  }\\n\\n  function unpackStoryHeroState(bytes32 data) internal pure returns (uint16 pageId, uint40 heroLastActionTS) {\\n    pageId = uint16(uint(data));\\n    heroLastActionTS = uint40(uint(data) >> 16);\\n  }\\n\\n  function packStoryHeroStateId(address heroAdr, uint80 heroId, uint16 storyId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(storyId)) << (160 + 80);\\n  }\\n\\n  function unpackStoryHeroStateId(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 storyId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    storyId = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  function packStorySimpleRequirement(uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(randomRequirement));\\n    data |= bytes32(uint(delayRequirement)) << 32;\\n    data |= bytes32(uint(isFinalAnswer ? uint8(1) : uint8(0))) << (32 + 32);\\n  }\\n\\n  function unpackStorySimpleRequirement(bytes32 data) internal pure returns (uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) {\\n    randomRequirement = uint32(uint(data));\\n    delayRequirement = uint32(uint(data) >> 32);\\n    isFinalAnswer = uint8(uint(data) >> (32 + 32)) == uint8(1);\\n  }\\n\\n  function packBurnInfo(uint8 slot, uint64 chance, bool stopIfBurned) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(slot));\\n    data |= bytes32(uint(chance)) << 8;\\n    data |= bytes32(uint(stopIfBurned ? uint8(1) : uint8(0))) << (8 + 64);\\n  }\\n\\n  function unpackBurnInfo(bytes32 data) internal pure returns (uint8 slot, uint64 chance, bool stopIfBurned) {\\n    slot = uint8(uint(data));\\n    chance = uint64(uint(data) >> 8);\\n    stopIfBurned = uint8(uint(data) >> (8 + 64)) == uint8(1);\\n  }\\n  //endregion ------------------------------------ STORIES\\n\\n  ////////////////////////////////////////////////////////////////////////////////////\\n  // ---- ARRAYS LOGIC ----\\n  ////////////////////////////////////////////////////////////////////////////////////\\n\\n  //region ------------------------------------ SIMPLE ARRAYS\\n\\n\\n  function packUint8Array(uint8[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 32) revert OutOfBounds(len, 32);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 8);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {packUint8Array} for small number of items\\n  ///         It allows to exclude dynamic array creation.\\n  function packUint8Array3(uint8 a, uint8 b, uint8 c) internal pure returns (bytes32) {\\n    bytes32 result = bytes32(uint(a));\\n    result |= bytes32(uint(b)) << (1 * 8);\\n    result |= bytes32(uint(c)) << (2 * 8);\\n    return result;\\n  }\\n\\n\\n  function unpackUint8Array(bytes32 data) internal pure returns (uint8[] memory) {\\n    uint8[] memory result = new uint8[](32);\\n    for (uint i = 0; i < 32; i++) {\\n      result[i] = uint8(uint(data) >> (i * 8));\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {unpackUint8Array} for small number of items\\n  ///         It allows to exclude only first 3 values\\n  function unpackUint8Array3(bytes32 data) internal pure returns (uint8 a, uint8 b, uint8 c) {\\n    a = uint8(uint(data));\\n    b = uint8(uint(data) >> (1 * 8));\\n    c = uint8(uint(data) >> (2 * 8));\\n  }\\n\\n  function changeUnit8ArrayWithCheck(bytes32 data, uint index, uint8 value, uint8 expectedPrevValue) internal pure returns (bytes32 newData) {\\n    uint8[] memory arr = unpackUint8Array(data);\\n    if (arr[index] != expectedPrevValue) revert UnexpectedValue(uint(expectedPrevValue), uint(arr[index]));\\n    arr[index] = value;\\n    return packUint8Array(arr);\\n  }\\n\\n  function packInt32Array(int32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i; i < len; i++) {\\n      result |= bytes32(uint(uint32(data[i]))) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackInt32Array(bytes32 data) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = int32(int(uint(data) >> (i * 32)));\\n    }\\n    return result;\\n  }\\n\\n  function packUint32Array(uint32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackUint32Array(bytes32 data) internal pure returns (uint32[] memory) {\\n    uint32[] memory result = new uint32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = uint32(uint(data) >> (i * 32));\\n    }\\n    return result;\\n  }\\n  //endregion ------------------------------------ SIMPLE ARRAYS\\n\\n  //region ------------------------------------ COMPLEX ARRAYS\\n\\n  // We should represent arrays without concrete size.\\n  // For this reason we must not revert on out of bounds but return zero value instead.\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getInt32AsInt24(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n//    if (idx / 8 >= arr.length) {\\n//      return int32(0);\\n//    }\\n//    return int32(int24(int(uint(arr[idx / 8]) >> ((idx % 8) * 32))));\\n//  }\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getUnit8From32Step(bytes32[] memory arr, uint idx) internal pure returns (uint8) {\\n//    if (idx / 8 >= arr.length) {\\n//      return uint8(0);\\n//    }\\n//    return uint8(uint(arr[idx / 8]) >> ((idx % 8) * 32 + 24));\\n//  }\\n\\n  function getInt32Memory(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function getInt32(bytes32[] storage arr, uint idx) internal view returns (int32) {\\n    // additional gas usage, but we should not revert on out of bounds\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function setInt32(bytes32[] storage arr, uint idx, int32 value) internal {\\n    uint pos = idx / 8;\\n    uint shift = (idx % 8) * 32;\\n\\n    uint curLength = arr.length;\\n    if (pos >= curLength) {\\n      arr.push(0);\\n      for (uint i = curLength; i < pos; ++i) {\\n        arr.push(0);\\n      }\\n    }\\n\\n    arr[pos] = bytes32(uint(arr[pos]) & ~(uint(0xffffffff) << shift) | (uint(uint32(value)) & 0xffffffff) << shift);\\n  }\\n\\n  /// @notice Increment {idx}-th item on {value}\\n  function changeInt32(bytes32[] storage arr, uint idx, int32 value) internal returns (int32 newValue, int32 change) {\\n    int32 cur = int32(int(getInt32(arr, idx)));\\n    int newValueI = int(cur) + int(value);\\n    newValue = int32(newValueI);\\n    change = int32(newValueI - int(cur));\\n\\n    setInt32(arr, idx, newValue);\\n  }\\n\\n  function toInt32Array(bytes32[] memory arr, uint size) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](size);\\n    for (uint i = 0; i < arr.length; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= size) break;\\n        result[idx] = getInt32Memory(arr, idx);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array\\n  function toBytes32Array(int32[] memory arr) internal pure returns (bytes32[] memory) {\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n        result[i] |= bytes32(uint(uint32(arr[idx]))) << (j * 32);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array using last 8bytes for ids\\n  ///      we can not use zero values coz will not able to properly unpack it later\\n  function toBytes32ArrayWithIds(int32[] memory arr, uint8[] memory ids) internal pure returns (bytes32[] memory) {\\n    if (arr.length != ids.length) revert LengthsMismatch();\\n\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n\\n//        console.log(\\\"toBytes32ArrayWithIds id: %s, value: %s%s\\\", ids[idx], arr[idx] >= 0 ? '' : '-', arr[idx] >= 0 ? uint(int(arr[idx])) : uint(int(-arr[idx])));\\n\\n        if (arr[idx] > type(int24).max || arr[idx] < type(int24).min) revert IntOutOfRange(int(arr[idx]));\\n        if (arr[idx] == 0) revert ZeroValue();\\n        result[i] |= bytes32(uint(uint24(int24(arr[idx])))) << (j * 32);\\n        result[i] |= bytes32(uint(ids[idx])) << (j * 32 + 24);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev we do not know exact size of array, assume zero values is not acceptable for this array\\n  function toInt32ArrayWithIds(bytes32[] memory arr) internal pure returns (int32[] memory values, uint8[] memory ids) {\\n    uint len = arr.length;\\n    uint size = len * 8;\\n    int32[] memory valuesTmp = new int32[](size);\\n    uint8[] memory idsTmp = new uint8[](size);\\n    uint counter;\\n    for (uint i = 0; i < len; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        // if (idx >= size) break;  // it looks like a useless check\\n        valuesTmp[idx] = int32(int24(int(uint(arr[i]) >> (j * 32)))); // getInt32AsInt24(arr, idx);\\n        idsTmp[idx] = uint8(uint(arr[i]) >> (j * 32 + 24)); // getUnit8From32Step(arr, idx);\\n        if (valuesTmp[idx] == 0) {\\n          break;\\n        }\\n        counter++;\\n      }\\n    }\\n\\n    values = new int32[](counter);\\n    ids = new uint8[](counter);\\n    for (uint i; i < counter; ++i) {\\n      values[i] = valuesTmp[i];\\n      ids[i] = idsTmp[i];\\n    }\\n  }\\n  //endregion ------------------------------------ COMPLEX ARRAYS\\n\\n}\\n\",\"keccak256\":\"0x169dec334b08b119f2b91eeb4650ab285440f7f698ad96584bf78c982d9e66ee\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StatLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\n\\nlibrary StatLib {\\n  using PackingLib for bytes32[];\\n  using PackingLib for bytes32;\\n  using PackingLib for uint32[];\\n  using PackingLib for int32[];\\n  using CalcLib for int32;\\n\\n  //region --------------------------- Constants\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant STAT_LIB_VERSION = \\\"1.0.0\\\";\\n  uint32 public constant MAX_LEVEL = 99;\\n\\n  uint public constant BASE_EXPERIENCE = 100_000;\\n  uint public constant BIOME_LEVEL_STEP = 5;\\n  uint internal constant _MAX_AMPLIFIER = 1e18;\\n  uint private constant _PRECISION = 1e18;\\n\\n  /// @dev Assume MAX_BIOME * BIOME_LEVEL_STEP < MAX_LEVEL + 1, see dungeonTreasuryReward\\n  uint public constant MAX_POSSIBLE_BIOME = 19;\\n  //endregion --------------------------- Constants\\n\\n  //region --------------------------- Data types\\n\\n  struct BaseMultiplier {\\n    uint minDamage;\\n    uint maxDamage;\\n    uint attackRating;\\n    uint defense;\\n    uint blockRating;\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct LevelUp {\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct InitialHero {\\n    IStatController.CoreAttributes core;\\n    BaseMultiplier multiplier;\\n    LevelUp levelUp;\\n    int32 baseLifeChances;\\n  }\\n\\n  enum HeroClasses {\\n    UNKNOWN,\\n    THRALL,\\n    SAVAGE,\\n    MAGE,\\n    ASSASSIN,\\n    GHOST,\\n    HAMMERGINA,\\n    END_SLOT\\n  }\\n  //endregion --------------------------- Data types\\n\\n  //region --------------------------- BASE\\n\\n  // --- HERO 1 (Slave) ---\\n\\n  function initialHero1() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 15,\\n      vitality: 30,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 2e18,\\n      blockRating: 0.1e18,\\n      life: 1.5e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 2e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 2 (Spata) ---\\n\\n  function initialHero2() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 30,\\n      dexterity: 5,\\n      vitality: 25,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: 0.25e18,\\n      attackRating: 2e18,\\n      defense: 1e18,\\n      blockRating: 0.08e18,\\n      life: 1.3e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.8e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 3 (Decidia) ---\\n\\n  function initialHero3() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 10,\\n      dexterity: 15,\\n      vitality: 20,\\n      energy: 25\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 1e18,\\n      blockRating: 0.1e18,\\n      life: 1e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.3e18,\\n      mana: 2e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 4 (Innatus) ---\\n\\n  function initialHero4() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 25,\\n      vitality: 15,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 4e18,\\n      defense: 3e18,\\n      blockRating: 0.2e18,\\n      life: 1.2e18,\\n      mana: 1e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 5 (F2P) ---\\n\\n  function initialHero5() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 20,\\n      dexterity: 20,\\n      vitality: 20,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: 0.25e18,\\n      attackRating: 3e18,\\n      defense: 2.5e18,\\n      blockRating: 0.15e18,\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // --- HERO 6 (F2P) HAMMERGINA ---\\n\\n  function initialHero6() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 50,\\n      dexterity: 30,\\n      vitality: 50,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.2e18,\\n      maxDamage: 0.3e18,\\n      attackRating: 5e18,\\n      defense: 3e18,\\n      blockRating: 0.15e18,\\n      life: 2e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // ------\\n\\n  function initialHero(uint heroClass) internal pure returns (InitialHero memory) {\\n    if (heroClass == 1) {\\n      return initialHero1();\\n    } else if (heroClass == 2) {\\n      return initialHero2();\\n    } else if (heroClass == 3) {\\n      return initialHero3();\\n    } else if (heroClass == 4) {\\n      return initialHero4();\\n    } else if (heroClass == 5) {\\n      return initialHero5();\\n    } else if (heroClass == 6) {\\n      return initialHero6();\\n    } else {\\n      revert IAppErrors.UnknownHeroClass(heroClass);\\n    }\\n  }\\n  //endregion --------------------------- BASE\\n\\n  //region --------------------------- CALCULATIONS\\n\\n  function minDamage(int32 strength, uint heroClass) internal pure returns (int32) {\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.minDamage / _PRECISION));\\n  }\\n\\n  function maxDamage(int32 strength, uint heroClass) internal pure returns (int32){\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.maxDamage / _PRECISION));\\n  }\\n\\n  function attackRating(int32 dexterity, uint heroClass) internal pure returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.attackRating / _PRECISION));\\n  }\\n\\n  function defense(int32 dexterity, uint heroClass) internal pure returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.defense / _PRECISION));\\n  }\\n\\n  function blockRating(int32 dexterity, uint heroClass) internal pure returns (int32){\\n    return int32(int(Math.min((dexterity.toUint() * initialHero(heroClass).multiplier.blockRating / _PRECISION), 75)));\\n  }\\n\\n  function life(int32 vitality, uint heroClass, uint32 level) internal pure returns (int32){\\n    return int32(int(\\n      (vitality.toUint() * initialHero(heroClass).multiplier.life / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.life / _PRECISION)\\n    ));\\n  }\\n\\n  function mana(int32 energy, uint heroClass, uint32 level) internal pure returns (int32){\\n    return int32(int(\\n      (energy.toUint() * initialHero(heroClass).multiplier.mana / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.mana / _PRECISION)\\n    ));\\n  }\\n\\n  function lifeChances(uint heroClass, uint32 /*level*/) internal pure returns (int32){\\n    return initialHero(heroClass).baseLifeChances;\\n  }\\n\\n  function levelExperience(uint32 level) internal pure returns (uint32) {\\n    if (level == 0 || level >= MAX_LEVEL) {\\n      return 0;\\n    }\\n    return uint32(uint(level) * BASE_EXPERIENCE * (67e17 - CalcLib.log2((uint(MAX_LEVEL - level + 2)) * 1e18)) / 1e18);\\n  }\\n\\n  function chanceToHit(\\n    uint attackersAttackRating,\\n    uint defendersDefenceRating,\\n    uint attackersLevel,\\n    uint defendersLevel,\\n    uint arFactor\\n  ) internal pure returns (uint) {\\n    attackersAttackRating += attackersAttackRating * arFactor / 100;\\n    uint x = Math.max(attackersAttackRating, 1);\\n    uint y = Math.max(attackersAttackRating + defendersDefenceRating, 1);\\n    uint z = attackersLevel;\\n    uint k = defendersLevel / 2;\\n    uint xy = x * 1e18 / y;\\n    uint zk = z * 1e18 / (attackersLevel + k);\\n    uint base = 2 * xy * zk / 1e18;\\n    return Math.max(Math.min(base, 0.95e18), 0.2e18);\\n  }\\n\\n  function experienceToLvl(uint experience, uint startFromLevel) internal pure returns (uint level) {\\n    level = startFromLevel;\\n    for (; level < MAX_LEVEL;) {\\n      if (levelExperience(uint32(level)) >= experience) {\\n        break;\\n      }\\n      unchecked{++level;}\\n    }\\n  }\\n\\n  function expPerMonster(uint32 monsterExp, uint monsterRarity, uint32 heroExp, uint32 heroCurrentLvl, uint monsterBiome) internal pure returns (uint32) {\\n    uint heroLvl = experienceToLvl(uint(heroExp), uint(heroCurrentLvl));\\n    uint heroBiome = heroLvl / StatLib.BIOME_LEVEL_STEP + 1;\\n    uint base = uint(monsterExp) + uint(monsterExp) * monsterRarity / _MAX_AMPLIFIER;\\n\\n    // reduce exp if hero not in his biome\\n    if (heroBiome > monsterBiome) {\\n      base = base / (2 ** (heroBiome - monsterBiome));\\n    }\\n    return uint32(base);\\n  }\\n\\n  /// @notice Allow to calculate delta param for {mintDropChance}\\n  function mintDropChanceDelta(uint experience, uint startFromLevel, uint monsterBiome) internal pure returns (uint) {\\n    uint heroBiome = StatLib.experienceToLvl(experience, startFromLevel) / StatLib.BIOME_LEVEL_STEP + 1;\\n    return heroBiome > monsterBiome ? 2**(heroBiome - monsterBiome) : 0;\\n  }\\n\\n  /// @param delta 2 ** (heroBiome - monsterBiome) or zero if heroBiome < monsterBiome, see {mintDropChanceDelta}\\n  function mintDropChance(uint baseChance, uint monsterRarity, uint delta) internal pure returns (uint) {\\n    uint chance = baseChance + baseChance * monsterRarity / _MAX_AMPLIFIER;\\n\\n    // reduce chance if hero not in his biome\\n    return delta == 0\\n      ? chance\\n      : chance / delta;\\n  }\\n\\n  function initAttributes(\\n    bytes32[] storage attributes,\\n    uint heroClass,\\n    uint32 level,\\n    IStatController.CoreAttributes memory base\\n  ) internal returns (uint32[] memory result) {\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.STRENGTH), base.strength);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEXTERITY), base.dexterity);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.VITALITY), base.vitality);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ENERGY), base.energy);\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN), minDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX), maxDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING), attackRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE), defense(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING), blockRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE), life(base.vitality, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA), mana(base.energy, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE_CHANCES), lifeChances(heroClass, level));\\n\\n    result = new uint32[](3);\\n    result[0] = uint32(life(base.vitality, heroClass, level).toUint());\\n    result[1] = uint32(mana(base.energy, heroClass, level).toUint());\\n    result[2] = uint32(lifeChances(heroClass, uint32(level)).toUint());\\n  }\\n\\n  function updateCoreDependAttributesInMemory(\\n    int32[] memory attributes,\\n    int32[] memory bonus,\\n    uint heroClass,\\n    uint32 level\\n  ) internal pure returns (int32[] memory) {\\n    int32 strength = attributes[uint(IStatController.ATTRIBUTES.STRENGTH)];\\n    int32 dexterity = attributes[uint(IStatController.ATTRIBUTES.DEXTERITY)];\\n    int32 vitality = attributes[uint(IStatController.ATTRIBUTES.VITALITY)];\\n    int32 energy = attributes[uint(IStatController.ATTRIBUTES.ENERGY)];\\n\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] = minDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)];\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] = maxDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)];\\n    attributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] = attackRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.ATTACK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.DEFENSE)] = defense(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DEFENSE)];\\n    attributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] = blockRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.BLOCK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.LIFE)] = life(vitality, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.LIFE)];\\n    attributes[uint(IStatController.ATTRIBUTES.MANA)] = mana(energy, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.MANA)];\\n    return attributes;\\n  }\\n\\n  function updateCoreDependAttributes(\\n    IController controller,\\n    bytes32[] storage attributes,\\n    bytes32[] storage bonusMain,\\n    bytes32[] storage bonusExtra,\\n    IStatController.ChangeableStats memory _heroStats,\\n    uint index,\\n    address heroToken,\\n    int32 base\\n  ) internal {\\n    uint heroClass = IHeroController(controller.heroController()).heroClass(heroToken);\\n    if (index == uint(IStatController.ATTRIBUTES.STRENGTH)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN),\\n        StatLib.minDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n      );\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX),\\n        StatLib.maxDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.DEXTERITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING),\\n        StatLib.attackRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE),\\n        StatLib.defense(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING),\\n        StatLib.blockRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.VITALITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE),\\n        StatLib.life(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.ENERGY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA),\\n        StatLib.mana(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n      );\\n    }\\n  }\\n\\n  function attributesAdd(int32[] memory base, int32[] memory add) internal pure returns (int32[] memory) {\\n    unchecked{\\n      for (uint i; i < base.length; ++i) {\\n        base[i] += add[i];\\n      }\\n    }\\n    return base;\\n  }\\n\\n// Currently this function is not used\\n//  function attributesRemove(int32[] memory base, int32[] memory remove) internal pure returns (int32[] memory) {\\n//    unchecked{\\n//      for (uint i; i < base.length; ++i) {\\n//        base[i] = CalcLib.minusWithMinFloorI32(base[i], remove[i]);\\n//      }\\n//    }\\n//    return base;\\n//  }\\n\\n  function packChangeableStats(IStatController.ChangeableStats memory stats) internal pure returns (bytes32) {\\n    uint32[] memory cData = new uint32[](5);\\n    cData[0] = stats.level;\\n    cData[1] = stats.experience;\\n    cData[2] = stats.life;\\n    cData[3] = stats.mana;\\n    cData[4] = stats.lifeChances;\\n\\n    return cData.packUint32Array();\\n  }\\n\\n  function unpackChangeableStats(bytes32 data) internal pure returns (IStatController.ChangeableStats memory result) {\\n    uint32[] memory cData = data.unpackUint32Array();\\n    return IStatController.ChangeableStats({\\n      level: cData[0],\\n      experience: cData[1],\\n      life: cData[2],\\n      mana: cData[3],\\n      lifeChances: cData[4]\\n    });\\n  }\\n\\n  function bytesToFullAttributesArray(bytes32[] memory attributes) internal pure returns (int32[] memory result) {\\n    (int32[] memory values, uint8[] memory ids) = attributes.toInt32ArrayWithIds();\\n    return valuesToFullAttributesArray(values, ids);\\n  }\\n\\n  function valuesToFullAttributesArray(int32[] memory values, uint8[] memory ids) internal pure returns (int32[] memory result) {\\n    result = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < values.length; ++i) {\\n      int32 value = values[i];\\n      if (value != 0) {\\n        result[ids[i]] = value;\\n      }\\n    }\\n  }\\n  //endregion --------------------------- CALCULATIONS\\n\\n}\\n\",\"keccak256\":\"0x7c620e54a4e0a50ebc566ef993d709d6badd2a7e366950513a7641d4414aabd6\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StringLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n\\nlibrary StringLib {\\n\\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n  function toString(uint value) external pure returns (string memory) {\\n    return _toString(value);\\n  }\\n\\n  function _toString(uint value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint temp = value;\\n    uint digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  function toAsciiString(address x) external pure returns (string memory) {\\n    return _toAsciiString(x);\\n  }\\n\\n  function _toAsciiString(address x) internal pure returns (string memory) {\\n    bytes memory s = new bytes(40);\\n    for (uint i = 0; i < 20; i++) {\\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n      bytes1 hi = bytes1(uint8(b) / 16);\\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n      s[2 * i] = _char(hi);\\n      s[2 * i + 1] = _char(lo);\\n    }\\n    return string(s);\\n  }\\n\\n  function char(bytes1 b) external pure returns (bytes1 c) {\\n    return _char(b);\\n  }\\n\\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n    else return bytes1(uint8(b) + 0x57);\\n  }\\n\\n  function concat(string memory a, string memory b) internal pure returns (string memory) {\\n    return string(abi.encodePacked(a, b));\\n  }\\n\\n}\\n\",\"keccak256\":\"0xa101d62c068dae579dda1ffa392cbf2acd2fc29a99c2efbdf53349a587b084d6\",\"license\":\"BUSL-1.1\"},\"contracts/openzeppelin/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  // To implement this library for multiple types with as little code repetition as possible, we write it in\\n  // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\\n  // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\\n  // This means that we can only create new EnumerableMaps for types that fit in bytes32.\\n\\n  /**\\n   * @dev Query for a nonexistent map key.\\n     */\\n  error EnumerableMapNonexistentKey(bytes32 key);\\n\\n  struct Bytes32ToBytes32Map {\\n    // Storage of keys\\n    EnumerableSet.Bytes32Set _keys;\\n    mapping(bytes32 key => bytes32) _values;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n    map._values[key] = value;\\n    return map._keys.add(key);\\n  }\\n\\n  /**\\n   * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n    delete map._values[key];\\n    return map._keys.remove(key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n    return map._keys.contains(key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n    return map._keys.length();\\n  }\\n\\n  /**\\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n    bytes32 key = map._keys.at(index);\\n    return (key, map._values[key]);\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == bytes32(0)) {\\n      return (contains(map, key), bytes32(0));\\n    } else {\\n      return (true, value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == 0 && !contains(map, key)) {\\n      revert EnumerableMapNonexistentKey(key);\\n    }\\n    return value;\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n    return map._keys.values();\\n  }\\n\\n  // UintToUintMap\\n\\n  struct UintToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key)));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintToAddressMap\\n\\n  struct UintToAddressMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressToUintMap\\n\\n  struct AddressToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n    return remove(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (address(uint160(uint256(key))), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // Bytes32ToUintMap\\n\\n  struct Bytes32ToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, key, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n    return remove(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n    return contains(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (key, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, key);\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, key));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x5052395b3d57e4347a977f96eba69188b4a952594afae411910995ecab5c1d05\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position is the index of the value in the `values` array plus 1.\\n    // Position 0 is used to mean a value is not in the set.\\n    mapping(bytes32 value => uint256) _positions;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._positions[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We cache the value's position to prevent multiple reads from the same storage slot\\n    uint256 position = set._positions[value];\\n\\n    if (position != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 valueIndex = position - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (valueIndex != lastIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the lastValue to the index where the value to delete is\\n        set._values[valueIndex] = lastValue;\\n        // Update the tracked position of the lastValue (that was just moved)\\n        set._positions[lastValue] = position;\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the tracked position for the deleted slot\\n      delete set._positions[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._positions[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n     */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xd5483249a7bac53a40791ade8d640831cdec526eea6b42a4db68f2ce13c008fa\",\"license\":\"MIT\"},\"contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n\\n  /**\\n    * @dev Muldiv operation overflow.\\n   */\\n  error MathOverflowedMulDiv();\\n\\n  enum Rounding {\\n    Floor, // Toward negative infinity\\n    Ceil, // Toward positive infinity\\n    Trunc, // Toward zero\\n    Expand // Away from zero\\n  }\\n\\n  /**\\n   * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      uint256 c = a + b;\\n      if (c < a) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b > a) return (false, 0);\\n      return (true, a - b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n      if (a == 0) return (true, 0);\\n      uint256 c = a * b;\\n      if (c / a != b) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a / b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a % b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (b == 0) {\\n      // Guarantee the same behavior as in a regular Solidity division.\\n      return a / b;\\n    }\\n\\n    // The following calculation ensures accurate ceiling division without overflow.\\n    // Since a is non-zero, (a - 1) / b will not overflow.\\n    // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n    // but the largest value we can obtain is type(uint256).max - 1, which happens\\n    // when a = type(uint256).max and b = 1.\\n    unchecked {\\n      return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n    unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n      uint256 prod0 = x * y; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n      if (prod1 == 0) {\\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n        // The surrounding unchecked block does not change this fact.\\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n        return prod0 / denominator;\\n      }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n      if (denominator <= prod1) {\\n        revert MathOverflowedMulDiv();\\n      }\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n      uint256 remainder;\\n      assembly {\\n      // Compute remainder using mulmod.\\n        remainder := mulmod(x, y, denominator)\\n\\n      // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n    // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n      uint256 twos = denominator & (0 - denominator);\\n      assembly {\\n      // Divide denominator by twos.\\n        denominator := div(denominator, twos)\\n\\n      // Divide [prod1 prod0] by twos.\\n        prod0 := div(prod0, twos)\\n\\n      // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n\\n    // Shift in bits from prod1 into prod0.\\n      prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n      uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n    // works in modular arithmetic, doubling the correct bits in each step.\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n      result = prod0 * inverse;\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n    unchecked {\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      return min(result, a / result);\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = sqrt(a);\\n      return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 128;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 64;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 32;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 16;\\n      }\\n      if (value >> 8 > 0) {\\n        value >>= 8;\\n        result += 8;\\n      }\\n      if (value >> 4 > 0) {\\n        value >>= 4;\\n        result += 4;\\n      }\\n      if (value >> 2 > 0) {\\n        value >>= 2;\\n        result += 2;\\n      }\\n      if (value >> 1 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log2(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >= 10 ** 64) {\\n        value /= 10 ** 64;\\n        result += 64;\\n      }\\n      if (value >= 10 ** 32) {\\n        value /= 10 ** 32;\\n        result += 32;\\n      }\\n      if (value >= 10 ** 16) {\\n        value /= 10 ** 16;\\n        result += 16;\\n      }\\n      if (value >= 10 ** 8) {\\n        value /= 10 ** 8;\\n        result += 8;\\n      }\\n      if (value >= 10 ** 4) {\\n        value /= 10 ** 4;\\n        result += 4;\\n      }\\n      if (value >= 10 ** 2) {\\n        value /= 10 ** 2;\\n        result += 2;\\n      }\\n      if (value >= 10 ** 1) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log10(value);\\n      return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 16;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 8;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 4;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 2;\\n      }\\n      if (value >> 8 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log256(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n  function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n    return uint8(rounding) % 2 == 1;\\n  }\\n\\n}\\n\",\"keccak256\":\"0x4d972e3e1d79f693b6cb42007d23c27256cb6f087392edea24b93585a822572c\",\"license\":\"MIT\"},\"contracts/solady/LibPRNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for generating pseudorandom numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\\n/// @author LazyShuffler based on NextShuffler by aschlosberg (divergencearran)\\n/// (https://github.com/divergencetech/ethier/blob/main/contracts/random/NextShuffler.sol)\\nlibrary LibPRNG {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The initial length must be greater than zero and less than `2**32 - 1`.\\n    error InvalidInitialLazyShufflerLength();\\n\\n    /// @dev The new length must not be less than the current length.\\n    error InvalidNewLazyShufflerLength();\\n\\n    /// @dev The lazy shuffler has not been initialized.\\n    error LazyShufflerNotInitialized();\\n\\n    /// @dev Cannot double initialize the lazy shuffler.\\n    error LazyShufflerAlreadyInitialized();\\n\\n    /// @dev The lazy shuffle has finished.\\n    error LazyShuffleFinished();\\n\\n    /// @dev The queried index is out of bounds.\\n    error LazyShufflerGetOutOfBounds();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pseudorandom number state in memory.\\n    struct PRNG {\\n        uint256 state;\\n    }\\n\\n    /// @dev A lazy Fisher-Yates shuffler for a range `[0..n)` in storage.\\n    struct LazyShuffler {\\n        // Bits Layout:\\n        // - [0..31]    `numShuffled`\\n        // - [32..223]  `permutationSlot`\\n        // - [224..255] `length`\\n        uint256 _state;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Seeds the `prng` with `state`.\\n    function seed(PRNG memory prng, uint256 state) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(prng, state)\\n        }\\n    }\\n\\n    /// @dev Returns the next pseudorandom uint256.\\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\\n        // We simply use `keccak256` for a great balance between\\n        // runtime gas costs, bytecode size, and statistical properties.\\n        //\\n        // A high-quality LCG with a 32-byte state\\n        // is only about 30% more gas efficient during runtime,\\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\\n        // when this function is inlined.\\n        //\\n        // Using this method is about 2x more efficient than\\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n        }\\n    }\\n\\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\\n    /// between 0 (inclusive) and `upper` (exclusive).\\n    /// If your modulus is big, this method is recommended\\n    /// for uniform sampling to avoid modulo bias.\\n    /// For uniform sampling across all uint256 values,\\n    /// or for small enough moduli such that the bias is neligible,\\n    /// use {next} instead.\\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := keccak256(prng, 0x20)\\n                mstore(prng, result)\\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\\n            }\\n            result := mod(result, upper)\\n        }\\n    }\\n\\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n\\n                    {\\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                let b := add(a, 0x01)\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let o := mod(shr(128, r), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n\\n                    {\\n                        let o := mod(and(r, mask), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the standard normal distribution denominated in `WAD`.\\n    function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\\n            // The chance of drawing a sample outside 10 \\u03c3 from the standard normal distribution\\n            // is \\u2248 0.000000000000000000000015, which is insignificant for most practical purposes.\\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\\n            let s := 0x1000000000000000100000000000000010000000000000001\\n            let r1 := mulmod(result, a, n)\\n            let r2 := mulmod(r1, a, n)\\n            let r3 := mulmod(r2, a, n)\\n            // forgefmt: disable-next-item\\n            result := sub(sar(96, mul(26614938895861601847173011183,\\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the unit exponential distribution denominated in `WAD`.\\n    function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\\n            // Gas usage varies, starting from about 172+ gas.\\n            let r := keccak256(prng, 0x20)\\n            mstore(prng, r)\\n            let p := shl(129, r)\\n            let w := shl(1, r)\\n            if iszero(gt(w, p)) {\\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n                for {} 1 {} {\\n                    r := mulmod(r, a, n)\\n                    if iszero(lt(shl(129, r), w)) {\\n                        r := mulmod(r, a, n)\\n                        result := add(1000000000000000000, result)\\n                        w := shl(1, r)\\n                        p := shl(129, r)\\n                        if iszero(lt(w, p)) { break }\\n                        continue\\n                    }\\n                    w := shl(1, r)\\n                    if iszero(lt(w, shl(129, r))) { break }\\n                }\\n            }\\n            result := add(div(p, shl(129, 170141183460469231732)), result)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*       STORAGE-BASED RANGE LAZY SHUFFLING OPERATIONS        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Initializes the state for lazy-shuffling the range `[0..n)`.\\n    /// Reverts if `n == 0 || n >= 2**32 - 1`.\\n    /// Reverts if `$` has already been initialized.\\n    /// If you need to reduce the length after initialization, just use a fresh new `$`.\\n    function initialize(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sload($.slot) {\\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, $.slot)\\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Increases the length of `$`.\\n    /// Reverts if `$` has not been initialized.\\n    function grow(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            // If the new length is smaller than the old length, revert.\\n            if lt(n, shr(224, state)) {\\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\\n        }\\n    }\\n\\n    /// @dev Restarts the shuffler by setting `numShuffled` to zero,\\n    /// such that all elements can be drawn again.\\n    /// Restarting does NOT clear the internal permutation, nor changes the length.\\n    /// Even with the same sequence of randomness, reshuffling can yield different results.\\n    function restart(LazyShuffler storage $) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot)\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, shl(32, shr(32, state)))\\n        }\\n    }\\n\\n    /// @dev Returns the number of elements that have been shuffled.\\n    function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := and(0xffffffff, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns the length of `$`.\\n    /// Returns zero if `$` is not initialized, else a non-zero value less than `2**32 - 1`.\\n    function length(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := shr(224, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns if `$` has been initialized.\\n    function initialized(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(iszero(sload($.slot)))\\n        }\\n    }\\n\\n    /// @dev Returns if there are any more elements left to shuffle.\\n    /// Reverts if `$` is not initialized.\\n    function finished(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := eq(shr(224, state), and(0xffffffff, state))\\n        }\\n    }\\n\\n    /// @dev Returns the current value stored at `index`, accounting for all historical shuffling.\\n    /// Reverts if `index` is greater than or equal to the `length` of `$`.\\n    function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            let n := shr(224, state) // Length of `$`.\\n            if iszero(lt(index, n)) {\\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let u32 := gt(n, 0xfffe)\\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\\n            result := and(m, shr(o, sload(s)))\\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\\n        }\\n    }\\n\\n    /// @dev Does a single Fisher-Yates shuffle step, increments the `numShuffled` in `$`,\\n    /// and returns the next value in the shuffled range.\\n    /// `randomness` can be taken from a good-enough source, or a higher quality source like VRF.\\n    /// Reverts if there are no more values to shuffle, which includes the case if `$` is not initialized.\\n    function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function _get(u32_, state_, i_) -> _value {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                _value := and(m_, shr(o_, sload(s_)))\\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\\n            }\\n            function _set(u32_, state_, i_, value_) {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                let v_ := sload(s_) // Bucket slot value.\\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\\n            }\\n            let state := sload($.slot) // The packed value at `$`.\\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\\n            let n := shr(224, state) // Length of `$`.\\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\\n            if iszero(remainder) {\\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\\n            chosen := _get(gt(n, 0xfffe), state, index)\\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdcb71f8dc72bb7384776154ca24d34c23e3c9bcf124bc75f0d2e379f9ebd021d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6157a26200003b600b82828239805160001a60731461002e57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c8063307800a21461003a575b600080fd5b81801561004657600080fd5b5061005a610055366004614628565b610071565b6040516100689291906147d3565b60405180910390f35b610079614171565b600061008b84846100966100a7610185565b915091509250929050565b60006100a18261028d565b92915050565b60408051608081018252600080825260208201819052918101829052606081019190915260006100e08585600001518660200151610323565b90506100ec8184610359565b7f726ea5eedb687a29deab0c52f0dfd5ffc55b2eb8fd292b6fb398a17f895d2b5e3382868760e001516040516101259493929190614bc5565b60405180910390a1604051806080016040528082600001516040015160030b815260200182602001516040015160030b815260200182600001516060015160030b815260200182602001516060015160030b8152509150505b9392505050565b61018d614171565b600080610199876104bd565b905060006102528760040160006101cb8b61010001518c602001516001600160a01b03166106a590919063ffffffff16565b8152602080820192909252604090810160009081206101408d015182528352818120548251608080820185528382528186018490528185018490526060918201939093528351928301845260ff8083166001148452604883901c1694830194909452602881901c60030b9282019290925260089190911c63ffffffff169181019190915290565b90508060200151925060008061026c8a8a85878c8c6106fa565b9150915061027e898b868585886109cc565b95505050505094509492505050565b60008160000361029f57506000919050565b6102aa826001614cf7565b4340414443423a5a604051602001610300979695949392919096875260609590951b6001600160601b0319166020870152603486019390935260548501919091526074840152609483015260b482015260d40190565b6040516020818303038152906040528051906020012060001c6100a19190614d20565b61032b6141e7565b6103336141e7565b61034285858360000151610db4565b61035185848360200151610db4565b949350505050565b600061036483610e92565b9050610371838284610f32565b61037d83821584610f32565b825180515160e0909101516020850151515161039a92919061107c565b602083015180515160e090910151845151516103b792919061107c565b60006103c5846001856113cc565b905060006103d5856000866113cc565b608080840151875160e09081015160ff928316151560c09182015260a0808801518b51840151908516151590840152818801518b518401519085161515610100918201529486015160208c0180518501519186161515918401919091529086015181518401519085161515908401529085015190519091015191161515910152905061049c836104655781610467565b825b846104725783610474565b825b85610483578760200151610486565b87515b86610492578851611522565b8860200151611522565b84516104a89083611635565b6104b6856020015182611635565b5050505050565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c08101919091526040518060e0016040528083600001516001600160a01b0316815260200183602001516001600160a01b0316815260200183604001516001600160a01b0316815260200183604001516001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa15801561057c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105a09190614d3f565b6001600160a01b0316815260200183604001516001600160a01b0316628e96916040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105ef573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106139190614d3f565b6001600160a01b0316815260200183604001516001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa158015610663573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106879190614d3f565b6001600160a01b031681526020018361010001518152509050919050565b60006001600160401b038211156106d757604051633995b34160e01b8152600481018390526024015b60405180910390fd5b5067ffffffffffffffff60a01b60a09190911b166001600160a01b039091161790565b61070261420c565b61070a614258565b6107126142ca565b61071a6142ca565b60006107398860a001518c61016001518a602001518b60c00151611696565b905061074581896118e4565b866000018160030b60030b815250819450505061085660405180604001604052808d6060015160ff1681526020018d604001516001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d99190614d3f565b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610816573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061083a9190614d5c565b8152508b8b8487602001516000015163ffffffff168d8d611a8b565b8760a0018197508263ffffffff1663ffffffff168152508294505050505060006109038860a001516040518061012001604052808681526020018581526020018e60e001516001600160401b031681526020018e60c0015163ffffffff1681526020018b602001516001600160a01b031681526020018b60c0015181526020018e60a0015160ff1681526020018e610140015181526020018c6020015160ff16815250898963ffffffff16565b9050604051806101000160405280826040015187600001516109259190614d75565b60030b81526020016109438560200151604001518460000151611c0c565b60030b815260200184602001516040015160030b836000015160030b1361096b576000610980565b60208501516040015183516109809190614d9c565b60030b8152602001826000015160030b8152602001826020015160030b81526020018660a0015163ffffffff168152602001848152602001838152509450505050965096945050505050565b6109d4614171565b60006109fb87610100015188602001516001600160a01b03166106a590919063ffffffff16565b90506064836020015160ff161115610a1557600060608601525b60808501516060860151600391820b15910b158115610a3857610a38888a611c39565b8180610a415750805b15610ae157845115610a6f57600083815260048b01602090815260408083206101408d015184529091528120555b87608001516001600160a01b0316637ac46f978a602001518b61010001516040518363ffffffff1660e01b8152600401610aaa929190614dc3565b600060405180830381600087803b158015610ac457600080fd5b505af1158015610ad8573d6000803e3d6000fd5b50505050610b72565b845115610b1257608087015160030b60408601526020850151610b05906001614ddc565b60ff166020860152610b47565b60408051608080820183526001808352602083015289015160030b9181019190915260a088015163ffffffff16606082015294505b610b5085611d44565b600084815260048c01602090815260408083206101408e015184529091529020555b8115610cb2576000610b878a60c00151611d62565b60808a015160208c01516101008d0151604051631c2aafe760e01b81526001600160a01b039283166004820152602481019190915260448101849052929350600092911690631c2aafe790606401602060405180830381865afa158015610bf2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c169190614d5c565b905089608001516001600160a01b031663184f61438c602001518d610100015185856001610c449190614cf7565b6040516001600160e01b031960e087901b1681526001600160a01b039094166004850152602484019290925260448301526064820152608401600060405180830381600087803b158015610c9757600080fd5b505af1158015610cab573d6000803e3d6000fd5b5050505050505b801515845281610cc3576000610d05565b610d058760e0015160200151602001518860a0015163ffffffff168960c0015160200151602001518a60c0015160200151600001518d6060015160ff16611d9b565b63ffffffff16610140850152604087015160030b608085015281610d2a576000610d4b565b60c087015151602081518110610d4257610d42614df5565b60200260200101515b600390810b60a08601526020880151810b60e08601528751900b61010085015281610d8457604080516000815260208101909152610d92565b610d92878a88611e3f611e54565b60608501528180610da05750805b151560208501525050509695505050505050565b818152602082015160409081015160030b9082015260608201516001600160a01b031615610e8d5760028260400151600a811115610df457610df4614917565b14610e1257604051635e7b518b60e11b815260040160405180910390fd5b6060820151608083015160405163ce11a20960e01b81526001600160a01b0386169263ce11a20992610e4692600401614dc3565b60e060405180830381865afa158015610e63573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e879190614e7d565b60208201525b505050565b6000600282515160400151600a811115610eae57610eae614917565b03610ef057600260208301515160400151600a811115610ed057610ed0614917565b03610ee8578151516020830151516100a19190611fb9565b506001919050565b600260208301515160400151600a811115610f0d57610f0d614917565b03610f1a57506000919050565b8151516020830151516100a19190611fb9565b919050565b610f3c8383612018565b610e8d57600082610f5257602084015151610f56565b8351515b9050600083610f6757845151610f6e565b6020850151515b9050600084610f8557856020015160200151610f8c565b8551602001515b9050600085610fa057865160e00151610faa565b866020015160e001515b8351909150600090602a81518110610fc457610fc4614df5565b60200260200101519050610fdc85846022848a612039565b15158252835161100e9086908590602390600b5b8151811061100057611000614df5565b60200260200101518a612039565b1515602083015283516110299086908590602490600c610ff0565b1515604083015261103e85846025848a612039565b1515606083015261105385846026848a612039565b1515608083015261106885846029848a612039565b151560a09092019190915250505050505050565b8160200151156111685760038360078151811061109b5761109b614df5565b60200260200101516110ad9190614ee3565b836007815181106110c0576110c0614df5565b602002602001018181516110d49190614d9c565b60030b905250603283600c815181106110ef576110ef614df5565b602002602001018181516111039190614d75565b60030b905250600a8160198151811061111e5761111e614df5565b602002602001018181516111329190614d75565b60030b90525060148160188151811061114d5761114d614df5565b602002602001018181516111619190614d75565b60030b9052505b8160400151156112855760028360048151811061118757611187614df5565b6020026020010181815161119b9190614ee3565b60030b9052506002836005815181106111b6576111b6614df5565b602002602001018181516111ca9190614ee3565b600390810b9091529050836006815181106111e7576111e7614df5565b60200260200101516111f99190614ee3565b8360068151811061120c5761120c614df5565b602002602001018181516112209190614d9c565b60030b90525060028360088151811061123b5761123b614df5565b6020026020010181815161124f9190614ee3565b60030b905250603283600b8151811061126a5761126a614df5565b6020026020010181815161127e9190614d75565b60030b9052505b8160600151156112bf576002836006815181106112a4576112a4614df5565b602002602001018181516112b89190614ee3565b60030b9052505b81608001511561135757600283600b815181106112de576112de614df5565b602002602001018181516112f29190614ee3565b60030b905250600283600c8151811061130d5761130d614df5565b602002602001018181516113219190614ee3565b60030b905250600283600d8151811061133c5761133c614df5565b602002602001018181516113509190614ee3565b60030b9052505b81511561138e57600a8160198151811061137357611373614df5565b602002602001018181516113879190614d75565b60030b9052505b8160a0015115610e8d576002836006815181106113ad576113ad614df5565b602002602001018181516113c19190614ee3565b60030b905250505050565b6113d4614332565b6000836113e6578451604001516113f0565b8460200151604001515b90506113fc8585612018565b15611443576040805160e08101825260039290920b8252600060208301819052908201819052606082018190526080820181905260a0820181905260c0820152905061017e565b60008461145557602086015151611459565b8551515b905060008561146a57865151611471565b6020870151515b905060018260400151600a81111561148b5761148b614917565b036114a35761149c828285886120a7565b9350611518565b60028260400151600a8111156114bb576114bb614917565b036114e65761149c8282886114d8578960200151602001516114df565b8951602001515b86896122ed565b8160400151600a8111156114fc576114fc614917565b604051630d2a62bd60e41b81526004016106ce91815260200190565b5050509392505050565b8351600390810b604083019081526020860151820b608085015251900b156115c7578251600390810b60408401908152602085015190910b60808301526060850151905161157091906124fa565b60030b60c0820181905260408301805161158b908390614d9c565b60030b905250606083015160408201516115a591906124fa565b60030b60c083018190526040820180516115c0908390614d9c565b60030b9052505b6115d981604001518260e0015161250f565b60030b60a083018190526040820180516115f4908390614d9c565b60030b905250604082015160e083015161160e919061250f565b60030b60a08201819052604083018051611629908390614d9c565b60030b90525050505050565b604082015160030b15611692576000816040015183604001516116589190614d75565b83515190915060009060098151811061167357611673614df5565b6020026020010151905061168782826124fa565b60030b604085015250505b5050565b61169e61436e565b6000848060200190518101906116b49190615018565b8051909150600a8111156116ca576116ca614917565b600003611700578051600a8111156116e4576116e4614917565b60405163f089562b60e01b81526004016106ce91815260200190565b60208101516001600160a01b0316156117d257600080876001600160a01b031663aef874fa846020015185604001516040518363ffffffff1660e01b815260040161174c929190614dc3565b6040805180830381865afa158015611768573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061178c91906150da565b91509150816001600160a01b0316866001600160a01b03161415806117b15750848114155b156117cf576040516376adf5c560e11b815260040160405180910390fd5b50505b60005b8160600151518110156118da57600080886001600160a01b031663aef874fa8560600151858151811061180a5761180a614df5565b60200260200101518660800151868151811061182857611828614df5565b60200260200101516040518363ffffffff1660e01b815260040161184d929190614dc3565b6040805180830381865afa158015611869573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061188d91906150da565b91509150816001600160a01b0316876001600160a01b03161415806118b25750858114155b156118d057604051631c927f9f60e31b815260040160405180910390fd5b50506001016117d5565b5095945050505050565b6118ec6142ca565b60008083608001516001600160a01b031663d4ac484885602001518660c001516040518363ffffffff1660e01b8152600401611929929190614dc3565b60a060405180830381865afa158015611946573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061196a9190615113565b9050600080611984836000015163ffffffff168888612564565b9450915083905060028751600a8111156119a0576119a0614917565b03611a2b5760a0860151602088015160405163415a9c6f60e11b81526001600160a01b0391821660048201529116906382b538de9060240161018060405180830381865afa1580156119f6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a1a91906151b9565b60a00151611a289085614d75565b93505b6040518060c001604052808381526020018481526020018860000151600a811115611a5857611a58614917565b81526020898101516001600160a01b0316908201526040808a015190820152606001600181525094505050509250929050565b611a936142ca565b6000611a9d614258565b611aa561436e565b8851611ac157611abc633b9aca0063ffffffff8716565b611ac7565b88606001515b9250611ae88a84611adb8e6020015161262e565b8e518b9060ff168a612679565b6020808a015163ffffffff948516918101919091529390921690925282875293509150611b169089886127f0565b8851611b5d578351611b4390600981518110611b3457611b34614df5565b602002602001015160016129a8565b602085015163ffffffff9091166040909101819052611b63565b88604001515b602085015163ffffffff9091166040909101528351600a81518110611b8a57611b8a614df5565b6020908102919091018101519085015163ffffffff90911660609091015280516040850190600a811115611bc057611bc0614917565b9081600a811115611bd357611bd3614917565b90525060208101516001600160a01b0316606085015260400151608084015260c081015160ff1660a08401529750975097945050505050565b60008160030b600014611c3257611c2382846124fa565b611c2d9084614d9c565b61017e565b5090919050565b600360ff16816080015160ff16036116925781604001516001600160a01b031663683fedf76040518163ffffffff1660e01b8152600401602060405180830381865afa158015611c8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cb19190614d3f565b60c08201516020830151610100840151606085015160405163057bd05b60e41b815263ffffffff90941660048501526001600160a01b039283166024850152604484019190915260ff16606483015291909116906357bd05b090608401600060405180830381600087803b158015611d2857600080fd5b505af1158015611d3c573d6000803e3d6000fd5b505050505050565b60006100a182600001518360600151846040015185602001516129be565b6000611d738263ffffffff16612a12565b604051602001611d839190615270565b6040516020818303038152906040526100a1906152b3565b600080611db48563ffffffff168563ffffffff16612b12565b90506000611dc36005836152da565b611dce906001614cf7565b90506000670de0b6b3a7640000611deb8963ffffffff8c166152ee565b611df591906152da565b611e059063ffffffff8b16614cf7565b905084821115611e3157611e198583615305565b611e249060026153fc565b611e2e90826152da565b90505b925050505b95945050505050565b6020822080835260009061017e908390614d20565b6060611e36604051806101600160405280866060015160ff1681526020018760c00151602001516000015160ff16815260200185610100015160ff16815260200186604001516001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa158015611ed7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611efb9190614d3f565b6001600160a01b03168152610180860151602082015260c088015151604090910190601781518110611f2f57611f2f614df5565b602002602001015160030b81526020018760c00151600001516018602b811115611f5b57611f5b614917565b81518110611f6b57611f6b614df5565b602002602001015160030b8152602001856101a0015181526020018760c00151602001516020015163ffffffff1681526020018760a0015163ffffffff168152602001600081525083612b3b565b8051600090600681518110611fd057611fd0614df5565b602002602001015160030b83600001516006602b811115611ff357611ff3614917565b8151811061200357612003614df5565b602002602001015160030b1215905092915050565b60008161202e57602083015160e001515161017e565b50505160e001515190565b60008061204c8787600001518787612fb9565b90508060030b600003612063576000915050611e36565b6064600382900b12612079576001915050611e36565b6120858160030b613112565b61209b6120926064613112565b8563ffffffff16565b10979650505050505050565b6120af614332565b60408051600180825281830190925290816020015b6120cc614332565b8152602001906001900390816120c4579050506000815181106120f1576120f1614df5565b60200260200101519050600061210b866000015184613141565b90506121178187613162565b905061212881878760a001516131a4565b90506121498661214461213b6064613112565b8663ffffffff16565b61323e565b612154576000612157565b60015b60ff16608083018190521561217657612171816002615408565b612178565b805b905061218981868860a00151613257565b905061219581866132b3565b86519091506121fd906121c59060065b815181106121b5576121b5614df5565b602002602001015160030b613112565b86516121d29060076121a5565b6020898101515190890151518a5163ffffffff92831692909116906121f890601e6121a5565b6132cb565b612212670de0b6b3a76400008563ffffffff16565b1161221e576000612221565b60015b60ff1660a083015284516122369060086121a5565b61224460648563ffffffff16565b10612250576000612253565b60015b60ff90811660c084015260a083015116151580612276575060c082015160ff1615155b1561227f575060005b60008160030b8560030b131561229e576122998286614d9c565b6122a1565b60005b90506122ad8186614d9c565b600382810b855281900b602085015291506122c882886133cb565b60030b60408401526122da8287613403565b60030b6060840152509095945050505050565b6122f5614332565b600061232a878661232561230f896020015160030b613112565b61231f8a6040015160030b613112565b88613412565b613449565b905061233b8188876000015161356d565b905061234c81888860a001516131a4565b9050600061236a886121446123616064613112565b8763ffffffff16565b9050806123775781612382565b612382826002615408565b915061239382888a60a00151613257565b915061239f82886132b3565b91506001865160058111156123b6576123b6614917565b036123d8576123c78288600b6135fd565b6123d19083614d9c565b9150612431565b6002865160058111156123ed576123ed614917565b036123fe576123c78288600c6135fd565b60038651600581111561241357612413614917565b03612431576124248288600d6135fd565b61242e9083614d9c565b91505b60008260030b8660030b1261244f5761244a8387614d9c565b612452565b60005b905061245e8187614d9c565b92506040518060e001604052808260030b81526020018460030b8152602001612487858c6133cb565b60030b81526020016124ae898c6124a9670de0b6b3a76400008b63ffffffff16565b61364e565b6124b8868c613699565b6124c29190614d75565b60030b8152602001836124d65760006124d9565b60015b60ff1681526000602082018190526040909101529998505050505050505050565b60008160030b8360030b12611c32578161017e565b60008160a00151801561252d5750600161252b8460030b613112565b115b1561255b57612554600a6125438560030b613112565b61254d91906152da565b60016136a8565b90506100a1565b50600092915050565b6060600082608001516001600160a01b03166357e9ee7b6040518060a0016040528086602001516001600160a01b031681526020018660c0015181526020018863ffffffff1681526020018760600151815260200187608001518152506040518263ffffffff1660e01b81526004016125dd9190615459565b600060405180830381865afa1580156125fa573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526126229190810190615560565b91509150935093915050565b6000612646600a6a084595161401484a0000006152da565b82101561265557506000919050565b6a084595161401484a00000061266f83633b9aca006152ee565b6100a191906152da565b606060008061268661436e565b61268e614258565b6126978b6136b7565b60a081015160ff16945090506126ae886001614cf7565b8463ffffffff16101561270857612705600f6126d063ffffffff87168b615305565b6126db90600a6152ee565b6126e591906152da565b6126f59063ffffffff8716614cf7565b6127008960056152ee565b6138d8565b93505b600260ff1681610160015160ff1603612780576000612732670de0b6b3a76400008863ffffffff16565b9050670a688906bd8b000081111561274d576001835261277a565b600283526101208201516001600160a01b031660208401526101408201516001600160401b031660408401525b506127c4565b80610160015160ff16600a81111561279a5761279a614917565b8290600a8111156127ad576127ad614917565b9081600a8111156127c0576127c0614917565b9052505b6127dd816060015182608001518c8c8560e001516138e7565b9095509250965096509650965096915050565b60608201515160005b818110156104b65760008460600151828151811061281957612819614df5565b6020026020010151905060008560800151838151811061283b5761283b614df5565b602002602001015190506000808660a001516001600160a01b031663aef874fa85856040518363ffffffff1660e01b815260040161287a929190614dc3565b6040805180830381865afa158015612896573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128ba91906150da565b91509150816001600160a01b031687602001516001600160a01b03161415806128e75750808760c0015114155b156129055760405163325e7bd360e01b815260040160405180910390fd5b6000808860a001516001600160a01b03166324e44dfc87876040518363ffffffff1660e01b815260040161293a929190614dc3565b600060405180830381865afa158015612957573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261297f91908101906155ad565b915091506129968b61299184846139ac565b613a5a565b505050505050508060010190506127f9565b60008160030b8360030b1215611c32578161017e565b6000846129cc5760006129cf565b60015b60ff1660001b905060088463ffffffff1660001b901b8117905060288363ffffffff1660001b901b8117905060488260ff1660001b901b81179050949350505050565b606081600003612a395750506040805180820190915260018152600360fc1b602082015290565b8160005b8115612a635780612a4d81615670565b9150612a5c9050600a836152da565b9150612a3d565b6000816001600160401b03811115612a7d57612a7d614472565b6040519080825280601f01601f191660200182016040528015612aa7576020820181803683370190505b5090505b841561035157612abc600183615305565b9150612ac9600a86614d20565b612ad4906030614cf7565b60f81b818381518110612ae957612ae9614df5565b60200101906001600160f81b031916908160001a905350612b0b600a866152da565b9450612aab565b805b60638110156100a15782612b2782613ab8565b63ffffffff1610156100a157600101612b14565b6080820151516040805160208101918290526060858101516101408701516337347e0560e11b909452633b9aca006024840152604483019390935292916000919081906001600160a01b0316636e68fc0a606483016020604051808303816000875af1158015612baf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612bd39190614d5c565b905290506000826001600160401b03811115612bf157612bf1614472565b604051908082528060200260200182016040528015612c1a578160200160208202803683370190505b50905060015b83811015612c4e5780828281518110612c3b57612c3b614df5565b6020908102919091010152600101612c20565b50612c598282613b4f565b6000836001600160401b03811115612c7357612c73614472565b604051908082528060200260200182016040528015612c9c578160200160208202803683370190505b509050600080612cc689610100015163ffffffff168a6020015160ff168b6000015160ff16613bca565b90506000612cdc8a60c0015160030b60646138d8565b905060005b87811015612ec757633b9aca0063ffffffff168b60e00151878381518110612d0b57612d0b614df5565b602002602001015181518110612d2357612d23614df5565b602002602001015163ffffffff161115612d94578a60e00151868281518110612d4e57612d4e614df5565b602002602001015181518110612d6657612d66614df5565b60200260200101516040516304470bfd60e21b81526004016106ce919063ffffffff91909116815260200190565b6000612de28c60e00151888481518110612db057612db0614df5565b602002602001015181518110612dc857612dc8614df5565b602002602001015163ffffffff168d610120015186613c13565b905060648c60a0015160030b820281612dfd57612dfd614d0a565b040160648382020490036000612e1b89633b9aca0063ffffffff8f16565b90508115801590612e395750633b9aca0082101580612e3957508181105b15612ebd578c6040015160ff16861015612ebd578c60800151888481518110612e6457612e64614df5565b602002602001015181518110612e7c57612e7c614df5565b6020026020010151878481518110612e9657612e96614df5565b60200260200101906001600160a01b031690816001600160a01b0316815250508560010195505b5050600101612ce1565b506000836001600160401b03811115612ee257612ee2614472565b604051908082528060200260200182016040528015612f0b578160200160208202803683370190505b5090506000805b89811015612fa85760006001600160a01b0316878281518110612f3757612f37614df5565b60200260200101516001600160a01b031614612fa057868181518110612f5f57612f5f614df5565b6020026020010151838381518110612f7957612f79614df5565b60200260200101906001600160a01b031690816001600160a01b0316815250508160010191505b600101612f12565b50909b9a5050505050505050505050565b835160009083602b811115612fd057612fd0614917565b81518110612fe057612fe0614df5565b602002602001015190506002600a811115612ffd57612ffd614917565b8560400151600a81111561301357613013614917565b036130e757602383602b81111561302c5761302c614917565b14801561304a5750600184600581111561304857613048614917565b145b1561305d5761305a601482614d75565b90505b602483602b81111561307157613071614917565b14801561308f5750600284600581111561308d5761308d614917565b145b156130a25761309f601482614d75565b90505b602583602b8111156130b6576130b6614917565b1480156130d4575060038460058111156130d2576130d2614917565b145b156130e7576130e4601482614d75565b90505b60646130f483605a6124fa565b6130fe9083615408565b6131089190614ee3565b611e369082614d9c565b6000808260030b121561312757506000919050565b60008260030b1361313a57506000919050565b5060030b90565b600061017e6131518460046121a5565b61315c8560056121a5565b84613412565b80516000906064908490601a8151811061317e5761317e614df5565b60200260200101516131909190615408565b61319a9190614ee3565b61017e9084614d75565b6000600182036131f55782516064908590600e5b815181106131c8576131c8614df5565b60200260200101516131da9190615408565b6131e49190614ee3565b6131ee9085614d75565b905061017e565b6002820361320b5782516064908590600f6131b8565b60038203613221578251606490859060106131b8565b60048203613237578251606490859060116131b8565b508261017e565b815160009061324e9060196121a5565b90911092915050565b6000600182036132775761326d848460126135fd565b6131ee9085614d9c565b6002820361328b5761326d848460136135fd565b6003820361329f5761326d848460146135fd565b600482036132375761326d848460156135fd565b60006132c1838360216135fd565b61017e9084614d9c565b600060646132d983886152ee565b6132e391906152da565b6132ed9087614cf7565b955060006132fc8760016136a8565b9050600061330d61254d888a614cf7565b905085600061331d6002886152da565b905060008361333486670de0b6b3a76400006152ee565b61333e91906152da565b9050600061334c838b614cf7565b61335e85670de0b6b3a76400006152ee565b61336891906152da565b90506000670de0b6b3a7640000826133818560026152ee565b61338b91906152ee565b61339591906152da565b90506133ba6133ac82670d2f13f7789f00006138d8565b6702c68af0bb1400006136a8565b9d9c50505050505050505050505050565b8051600090606490601f5b815181106133e6576133e6614df5565b6020026020010151846133f99190615408565b61017e9190614ee3565b805160009060649060276133d6565b600082841015613441576134326134298585615305565b8363ffffffff16565b61343c9085614cf7565b610351565b509092915050565b6060820151518351600091829160649190838151811061346b5761346b614df5565b602002602001015161347d9190615408565b6134879190614ee3565b60608501516020015186519192506064916001815181106134aa576134aa614df5565b60200260200101516134bc9190615408565b6134c69190614ee3565b6134d09082614d75565b60608501516040015186519192506064916002815181106134f3576134f3614df5565b60200260200101516135059190615408565b61350f9190614ee3565b6135199082614d75565b6060808601510151865191925060649160038151811061353b5761353b614df5565b602002602001015161354d9190615408565b6135579190614ee3565b6135619082614d75565b9050611e368184614d75565b6000600182600581111561358357613583614917565b036135b3578251606490601b5b815181106135a0576135a0614df5565b6020026020010151856131da9190615408565b60028260058111156135c7576135c7614917565b036135d8578251606490601c613590565b60038260058111156135ec576135ec614917565b03613237578251606490601d613590565b6000606461363a846000015184602b81111561361b5761361b614917565b8151811061362b5761362b614df5565b6020026020010151605a6124fa565b6136449086615408565b6103519190614ee3565b600060048451600581111561366557613665614917565b14801561367957506706f05b59d3b2000082115b613684576000610351565b60028360200151604001516103519190614ee3565b805160009060649060286133d6565b6000818311611c32578161017e565b6136bf614258565b6136c7614258565b6137228360000180548060200260200160405190810160405280929190818152602001828054801561371857602002820191906000526020600020905b815481526020019060010190808311613704575b5050505050613c54565b606083015260808201526001830154600881901c601082901c603083901c60ff90811661010086015263ffffffff90911660e085015290811660c08401521660a0820152600283015461377c60a082901c9060e083901c90565b60ff166101608401526001600160401b039081166101408401526001600160a01b0390911661012083015260038401549081908111156137be576137be614472565b6040519080825280602002602001820160405280156137e7578160200160208202803683370190505b50610180830152806001600160401b0381111561380657613806614472565b60405190808252806020026020018201604052801561382f578160200160208202803683370190505b506101a083015260005b818110156138cf5761386d85600301828154811061385957613859614df5565b90600052602060002001549060a082901c90565b846101800151838151811061388457613884614df5565b60200260200101856101a0015184815181106138a2576138a2614df5565b63ffffffff909316602093840291909101909201919091526001600160a01b039091169052600101613839565b50909392505050565b6000818310611c32578161017e565b606060006138f6600486615689565b60408051602b8082526105808201909252919650602082016105608036833701905050915060005b87518110156139945761394b87828151811061393c5761393c614df5565b60200260200101518787613f45565b8389838151811061395e5761395e614df5565b602002602001015160ff168151811061397957613979614df5565b60039290920b6020928302919091019091015260010161391e565b506139a0838686613f45565b90509550959350505050565b60408051602b8082526105808201909252606091602082016105608036833701905050905060005b8351811015613a535760008482815181106139f1576139f1614df5565b602002602001015190508060030b600014613a4a578083858481518110613a1a57613a1a614df5565b602002602001015160ff1681518110613a3557613a35614df5565b602002602001019060030b908160030b815250505b506001016139d4565b5092915050565b606060005b8351811015613ab057828181518110613a7a57613a7a614df5565b6020026020010151848281518110613a9457613a94614df5565b60209081029190910101805190910160030b9052600101613a5f565b509192915050565b600063ffffffff82161580613ad45750606363ffffffff831610155b15613ae157506000919050565b670de0b6b3a7640000613b20613af88460636156ac565b613b039060026156c9565b613b1b9063ffffffff16670de0b6b3a76400006152ee565b613fb1565b613b3290675cfb2e807b1e0000615305565b613b45620186a063ffffffff86166152ee565b61266f91906152ee565b80516000196001600160801b0382156104b6576020840193505b6020852080865282840193608082901c0660051b850184613b8b5750506104b6565b600585811b8701805183519091529091528385019482841606901b850184613bb45750506104b6565b600585901b860180518251909152905250613b69565b6000806005613bd98686612b12565b613be391906152da565b613bee906001614cf7565b9050828111613bfe576000611e36565b613c088382615305565b611e369060026153fc565b600080670de0b6b3a7640000613c2985876152ee565b613c3391906152da565b613c3d9086614cf7565b9050821561035157613c4f83826152da565b611e36565b805160609081906000613c688260086152ee565b90506000816001600160401b03811115613c8457613c84614472565b604051908082528060200260200182016040528015613cad578160200160208202803683370190505b5090506000826001600160401b03811115613cca57613cca614472565b604051908082528060200260200182016040528015613cf3578160200160208202803683370190505b5090506000805b85811015613e205760005b6008811015613e1757600081613d1c8460086152ee565b613d269190614cf7565b9050613d338260206152ee565b8b8481518110613d4557613d45614df5565b602002602001015160001c901c60020b868281518110613d6757613d67614df5565b60039290920b602092830291909101820152613d849083906152ee565b613d8f906018614cf7565b8b8481518110613da157613da1614df5565b602002602001015160001c901c858281518110613dc057613dc0614df5565b602002602001019060ff16908160ff1681525050858181518110613de657613de6614df5565b602002602001015160030b600003613dfe5750613e17565b83613e0881615670565b94505050806001019050613d05565b50600101613cfa565b50806001600160401b03811115613e3957613e39614472565b604051908082528060200260200182016040528015613e62578160200160208202803683370190505b509650806001600160401b03811115613e7d57613e7d614472565b604051908082528060200260200182016040528015613ea6578160200160208202803683370190505b50955060005b81811015613f3a57838181518110613ec657613ec6614df5565b6020026020010151888281518110613ee057613ee0614df5565b602002602001019060030b908160030b81525050828181518110613f0657613f06614df5565b6020026020010151878281518110613f2057613f20614df5565b60ff90921660209283029190910190910152600101613eac565b505050505050915091565b60008360030b600003613f5a5750600061017e565b633b9aca00613f70600384810b9087900b6156e6565b613f7a9190615716565b633b9aca00613f9363ffffffff8616600388900b6156e6565b613f9d9190615716565b613fa79190615744565b6103519085614d75565b6000670de0b6b3a7640000821015613fdf57604051637046c4a960e01b8152600481018390526024016106ce565b6000613ffb613ff6670de0b6b3a7640000856152da565b614092565b9050600061401182670de0b6b3a76400006152ee565b905083821c670de0b6b3a764000081900361402e57509392505050565b6706f05b59d3b200005b801561408857670de0b6b3a764000061405183806152ee565b61405b91906152da565b9150671bc16d674ec800008210614080576140768184614cf7565b9250600182901c91505b60011c614038565b5090949350505050565b6000600160801b82106140b257608091821c916140af9082614cf7565b90505b600160401b82106140d057604091821c916140cd9082614cf7565b90505b64010000000082106140ef57602091821c916140ec9082614cf7565b90505b62010000821061410c57601091821c916141099082614cf7565b90505b610100821061412857600891821c916141259082614cf7565b90505b6010821061414357600491821c916141409082614cf7565b90505b6004821061415e57600291821c9161415b9082614cf7565b90505b60028210610f2d576100a1600182614cf7565b604080516101c08101825260008082526020820181905291810182905260608082018190526080820183905260a0820183905260c0820183905260e0820183905261010082018390526101208201839052610140820183905261016082018390526101808201929092526101a081019190915290565b60405180604001604052806141fa6143a7565b81526020016142076143a7565b905290565b6040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a081019190915260c0810161424b6142ca565b81526020016142076142ca565b604080516101c081018252600080825260208201819052909182019081526060602082018190526040820181905260008183018190526080830181905260a0830181905260c0830181905260e08301819052610100830181905261012083015261014082018190526101609091015290565b6040805160c0810182526060808252825160a081018452600080825260208281018290529482018190529181018290526080810191909152909182019081526020016000815260200160006001600160a01b0316815260200160008152602001600081525090565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c081019190915290565b6040805160a08101909152806000815260200160006001600160a01b031681526020016000815260200160608152602001606081525090565b6040518061010001604052806143bb6142ca565b81526040805160808082018352600080835260208381018290528385018290528451928301855281835282810182905293820181905260608083019190915282015291019081526000602080830182905260408084018390526060808501849052608080860185905260a08087018690528351610120810185528681529485018690529284018590529083018490528201839052810182905260c081810183905260e0820183905261010082019290925291015290565b634e487b7160e01b600052604160045260246000fd5b60405161018081016001600160401b03811182821017156144ab576144ab614472565b60405290565b604051608081016001600160401b03811182821017156144ab576144ab614472565b60405160a081016001600160401b03811182821017156144ab576144ab614472565b60405161012081016001600160401b03811182821017156144ab576144ab614472565b604051601f8201601f191681016001600160401b038111828210171561454057614540614472565b604052919050565b6001600160a01b038116811461455d57600080fd5b50565b8035610f2d81614548565b60ff8116811461455d57600080fd5b8035610f2d8161456b565b63ffffffff8116811461455d57600080fd5b8035610f2d81614585565b80356001600160401b0381168114610f2d57600080fd5b600082601f8301126145ca57600080fd5b81356001600160401b038111156145e3576145e3614472565b6145f6601f8201601f1916602001614518565b81815284602083860101111561460b57600080fd5b816020850160208301376000918101602001919091529392505050565b6000806040838503121561463b57600080fd5b82356001600160401b038082111561465257600080fd5b90840190610180828703121561466757600080fd5b61466f614488565b61467883614560565b815261468660208401614560565b602082015261469760408401614560565b60408201526146a86060840161457a565b60608201526146b96080840161457a565b60808201526146ca60a0840161457a565b60a08201526146db60c08401614597565b60c08201526146ec60e084016145a2565b60e0820152610100838101359082015261012080840135908201526101408084013590820152610160808401358381111561472657600080fd5b614732898287016145b9565b91830191909152509660209590950135955050505050565b6001600160a01b03169052565b60008151808452602080850194506020840160005b838110156147915781516001600160a01b03168752958201959082019060010161476c565b509495945050505050565b60008151808452602080850194506020840160005b8381101561479157815163ffffffff16875295820195908201906001016147b1565b604081526147e660408201845115159052565b600060208401516147fb606084018215159052565b50604084015161480e608084018261474a565b5060608401516101c08060a085015261482b610200850183614757565b9150608086015161484160c086018260030b9052565b5060a086015161485660e086018260030b9052565b5060c086015161010061486d8187018360030b9052565b60e088015191506101206148858188018460030b9052565b9088015191506101409061489d8783018460030b9052565b88015191506101606148b68782018463ffffffff169052565b908801519150610180906148d18783018463ffffffff169052565b8801516101a087810191909152908801519286019290925250850151838203603f19016101e0850152614904828261479c565b9250505061017e602083018460ff169052565b634e487b7160e01b600052602160045260246000fd5b600b811061493d5761493d614917565b9052565b80516101408084528151908401819052600091610160850191602091820190845b8181101561498157825160030b85529383019391830191600101614962565b5050505060208301516149d2602086018263ffffffff808251168352806020830151166020840152806040830151166040840152806060830151166060840152806080830151166080840152505050565b5060408301516149e560c086018261492d565b5060608301516149f860e086018261474a565b50608083015161010085015260a08301516101208501528091505092915050565b805160068110614a2b57614a2b614917565b8252602081810151600390810b82850152604080840151820b818601526060938401518051830b8587015292830151820b6080860152820151810b60a0850152910151900b60c090910152565b8051151582526020810151151560208301526040810151614a9d604084018215159052565b506060810151614ab1606084018215159052565b506080810151614ac5608084018215159052565b5060a0810151614ad960a084018215159052565b5060c0810151614aed60c084018215159052565b5060e0810151614b0160e084018215159052565b50610100908101511515910152565b60006102c08251818552614b2682860182614941565b9150506020830151614b3b6020860182614a19565b506040830151614b5161010086018260030b9052565b506060830151614b6761012086018260030b9052565b506080830151614b7d61014086018260030b9052565b5060a0830151614b9361016086018260030b9052565b5060c0830151614ba961018086018260030b9052565b5060e0830151614bbd6101a0860182614a78565b509392505050565b60018060a01b0385168152608060208201526000845160406080840152614bef60c0840182614b10565b90506020860151607f198483030160a0850152614c0c8282614b10565b91505082810360408401526101208551818352614c2b82840182614941565b91505060208601518282036020840152614c458282614941565b9150506040860151614c6260408401826001600160401b03169052565b506060860151614c7a606084018263ffffffff169052565b506080860151614c8d608084018261474a565b5060a086015160a083015260c0860151614cac60c084018260ff169052565b5060e086015160e083015261010080870151614ccc8285018260ff169052565b50506060939093019390935250949350505050565b634e487b7160e01b600052601160045260246000fd5b808201808211156100a1576100a1614ce1565b634e487b7160e01b600052601260045260246000fd5b600082614d2f57614d2f614d0a565b500690565b8051610f2d81614548565b600060208284031215614d5157600080fd5b815161017e81614548565b600060208284031215614d6e57600080fd5b5051919050565b600381810b9083900b01637fffffff8113637fffffff19821217156100a1576100a1614ce1565b600382810b9082900b03637fffffff198112637fffffff821317156100a1576100a1614ce1565b6001600160a01b03929092168252602082015260400190565b60ff81811683821601908111156100a1576100a1614ce1565b634e487b7160e01b600052603260045260246000fd5b8051600381900b8114610f2d57600080fd5b600060808284031215614e2f57600080fd5b614e376144b1565b9050614e4282614e0b565b8152614e5060208301614e0b565b6020820152614e6160408301614e0b565b6040820152614e7260608301614e0b565b606082015292915050565b600060e08284031215614e8f57600080fd5b614e976144b1565b825160068110614ea657600080fd5b8152614eb460208401614e0b565b6020820152614ec560408401614e0b565b6040820152614ed78460608501614e1d565b60608201529392505050565b60008160030b8360030b80614efa57614efa614d0a565b637fffffff19821460001982141615614f1557614f15614ce1565b90059392505050565b60006001600160401b03821115614f3757614f37614472565b5060051b60200190565b600082601f830112614f5257600080fd5b81516020614f67614f6283614f1e565b614518565b8083825260208201915060208460051b870101935086841115614f8957600080fd5b602086015b84811015614fae578051614fa181614548565b8352918301918301614f8e565b509695505050505050565b600082601f830112614fca57600080fd5b81516020614fda614f6283614f1e565b8083825260208201915060208460051b870101935086841115614ffc57600080fd5b602086015b84811015614fae5780518352918301918301615001565b60006020828403121561502a57600080fd5b81516001600160401b038082111561504157600080fd5b9083019060a0828603121561505557600080fd5b61505d6144d3565b8251600b811061506c57600080fd5b815261507a60208401614d34565b60208201526040830151604082015260608301518281111561509b57600080fd5b6150a787828601614f41565b6060830152506080830151828111156150bf57600080fd5b6150cb87828601614fb9565b60808301525095945050505050565b600080604083850312156150ed57600080fd5b82516150f881614548565b6020939093015192949293505050565b8051610f2d81614585565b600060a0828403121561512557600080fd5b61512d6144d3565b825161513881614585565b8152602083015161514881614585565b6020820152604083015161515b81614585565b6040820152606083015161516e81614585565b6060820152608083015161518181614585565b60808201529392505050565b8051610f2d8161456b565b8051600d8110610f2d57600080fd5b805161ffff81168114610f2d57600080fd5b600061018082840312156151cc57600080fd5b6151d46144f5565b6151dd8361518d565b81526151eb6020840161518d565b60208201526151fc60408401615198565b604082015261520d606084016151a7565b606082015261521e6080840161518d565b608082015261522f60a08401615108565b60a082015261524060c0840161518d565b60c082015261525160e0840161518d565b60e082015261010061526585828601614e1d565b908201529392505050565b674d4f4e535445525f60c01b81526000825160005b818110156152a25760208186018101516008868401015201615285565b506000920160080191825250919050565b805160208083015191908110156152d4576000198160200360031b1b821691505b50919050565b6000826152e9576152e9614d0a565b500490565b80820281158282048414176100a1576100a1614ce1565b818103818111156100a1576100a1614ce1565b600181815b8085111561535357816000190482111561533957615339614ce1565b8085161561534657918102915b93841c939080029061531d565b509250929050565b60008261536a575060016100a1565b81615377575060006100a1565b816001811461538d5760028114615397576153b3565b60019150506100a1565b60ff8411156153a8576153a8614ce1565b50506001821b6100a1565b5060208310610133831016604e8410600b84101617156153d6575081810a6100a1565b6153e08383615318565b80600019048211156153f4576153f4614ce1565b029392505050565b600061017e838361535b565b60008260030b8260030b028060030b9150808214613a5357613a53614ce1565b60008151808452602080850194506020840160005b838110156147915781518752958201959082019060010161543d565b6000602080835260c0830160018060a01b03808651168386015282860151604086015263ffffffff6040870151166060860152606086015160a0608087015282815180855260e0880191508583019450600092505b808310156154d0578451841682529385019360019290920191908501906154ae565b506080880151878203601f190160a089015294506154ee8186615428565b98975050505050505050565b600082601f83011261550b57600080fd5b8151602061551b614f6283614f1e565b8083825260208201915060208460051b87010193508684111561553d57600080fd5b602086015b84811015614fae5761555381614e0b565b8352918301918301615542565b6000806040838503121561557357600080fd5b82516001600160401b0381111561558957600080fd5b615595858286016154fa565b9250506155a460208401614e0b565b90509250929050565b600080604083850312156155c057600080fd5b82516001600160401b03808211156155d757600080fd5b6155e3868387016154fa565b93506020915081850151818111156155fa57600080fd5b85019050601f8101861361560d57600080fd5b805161561b614f6282614f1e565b81815260059190911b8201830190838101908883111561563a57600080fd5b928401925b828410156156615783516156528161456b565b8252928401929084019061563f565b80955050505050509250929050565b60006001820161568257615682614ce1565b5060010190565b600063ffffffff808416806156a0576156a0614d0a565b92169190910492915050565b63ffffffff828116828216039080821115613a5357613a53614ce1565b63ffffffff818116838216019080821115613a5357613a53614ce1565b80820260008212600160ff1b8414161561570257615702614ce1565b81810583148215176100a1576100a1614ce1565b60008261572557615725614d0a565b600160ff1b82146000198414161561573f5761573f614ce1565b500590565b808201828112600083128015821682158216171561576457615764614ce1565b50509291505056fea264697066735822122086b603e4d818bdb49c0bd5676bc9abbc395525ee319c2b07b795aa434978097d64736f6c63430008170033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c8063307800a21461003a575b600080fd5b81801561004657600080fd5b5061005a610055366004614628565b610071565b6040516100689291906147d3565b60405180910390f35b610079614171565b600061008b84846100966100a7610185565b915091509250929050565b60006100a18261028d565b92915050565b60408051608081018252600080825260208201819052918101829052606081019190915260006100e08585600001518660200151610323565b90506100ec8184610359565b7f726ea5eedb687a29deab0c52f0dfd5ffc55b2eb8fd292b6fb398a17f895d2b5e3382868760e001516040516101259493929190614bc5565b60405180910390a1604051806080016040528082600001516040015160030b815260200182602001516040015160030b815260200182600001516060015160030b815260200182602001516060015160030b8152509150505b9392505050565b61018d614171565b600080610199876104bd565b905060006102528760040160006101cb8b61010001518c602001516001600160a01b03166106a590919063ffffffff16565b8152602080820192909252604090810160009081206101408d015182528352818120548251608080820185528382528186018490528185018490526060918201939093528351928301845260ff8083166001148452604883901c1694830194909452602881901c60030b9282019290925260089190911c63ffffffff169181019190915290565b90508060200151925060008061026c8a8a85878c8c6106fa565b9150915061027e898b868585886109cc565b95505050505094509492505050565b60008160000361029f57506000919050565b6102aa826001614cf7565b4340414443423a5a604051602001610300979695949392919096875260609590951b6001600160601b0319166020870152603486019390935260548501919091526074840152609483015260b482015260d40190565b6040516020818303038152906040528051906020012060001c6100a19190614d20565b61032b6141e7565b6103336141e7565b61034285858360000151610db4565b61035185848360200151610db4565b949350505050565b600061036483610e92565b9050610371838284610f32565b61037d83821584610f32565b825180515160e0909101516020850151515161039a92919061107c565b602083015180515160e090910151845151516103b792919061107c565b60006103c5846001856113cc565b905060006103d5856000866113cc565b608080840151875160e09081015160ff928316151560c09182015260a0808801518b51840151908516151590840152818801518b518401519085161515610100918201529486015160208c0180518501519186161515918401919091529086015181518401519085161515908401529085015190519091015191161515910152905061049c836104655781610467565b825b846104725783610474565b825b85610483578760200151610486565b87515b86610492578851611522565b8860200151611522565b84516104a89083611635565b6104b6856020015182611635565b5050505050565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c08101919091526040518060e0016040528083600001516001600160a01b0316815260200183602001516001600160a01b0316815260200183604001516001600160a01b0316815260200183604001516001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa15801561057c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105a09190614d3f565b6001600160a01b0316815260200183604001516001600160a01b0316628e96916040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105ef573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106139190614d3f565b6001600160a01b0316815260200183604001516001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa158015610663573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106879190614d3f565b6001600160a01b031681526020018361010001518152509050919050565b60006001600160401b038211156106d757604051633995b34160e01b8152600481018390526024015b60405180910390fd5b5067ffffffffffffffff60a01b60a09190911b166001600160a01b039091161790565b61070261420c565b61070a614258565b6107126142ca565b61071a6142ca565b60006107398860a001518c61016001518a602001518b60c00151611696565b905061074581896118e4565b866000018160030b60030b815250819450505061085660405180604001604052808d6060015160ff1681526020018d604001516001600160a01b031663c3dfdae66040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d99190614d3f565b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610816573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061083a9190614d5c565b8152508b8b8487602001516000015163ffffffff168d8d611a8b565b8760a0018197508263ffffffff1663ffffffff168152508294505050505060006109038860a001516040518061012001604052808681526020018581526020018e60e001516001600160401b031681526020018e60c0015163ffffffff1681526020018b602001516001600160a01b031681526020018b60c0015181526020018e60a0015160ff1681526020018e610140015181526020018c6020015160ff16815250898963ffffffff16565b9050604051806101000160405280826040015187600001516109259190614d75565b60030b81526020016109438560200151604001518460000151611c0c565b60030b815260200184602001516040015160030b836000015160030b1361096b576000610980565b60208501516040015183516109809190614d9c565b60030b8152602001826000015160030b8152602001826020015160030b81526020018660a0015163ffffffff168152602001848152602001838152509450505050965096945050505050565b6109d4614171565b60006109fb87610100015188602001516001600160a01b03166106a590919063ffffffff16565b90506064836020015160ff161115610a1557600060608601525b60808501516060860151600391820b15910b158115610a3857610a38888a611c39565b8180610a415750805b15610ae157845115610a6f57600083815260048b01602090815260408083206101408d015184529091528120555b87608001516001600160a01b0316637ac46f978a602001518b61010001516040518363ffffffff1660e01b8152600401610aaa929190614dc3565b600060405180830381600087803b158015610ac457600080fd5b505af1158015610ad8573d6000803e3d6000fd5b50505050610b72565b845115610b1257608087015160030b60408601526020850151610b05906001614ddc565b60ff166020860152610b47565b60408051608080820183526001808352602083015289015160030b9181019190915260a088015163ffffffff16606082015294505b610b5085611d44565b600084815260048c01602090815260408083206101408e015184529091529020555b8115610cb2576000610b878a60c00151611d62565b60808a015160208c01516101008d0151604051631c2aafe760e01b81526001600160a01b039283166004820152602481019190915260448101849052929350600092911690631c2aafe790606401602060405180830381865afa158015610bf2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c169190614d5c565b905089608001516001600160a01b031663184f61438c602001518d610100015185856001610c449190614cf7565b6040516001600160e01b031960e087901b1681526001600160a01b039094166004850152602484019290925260448301526064820152608401600060405180830381600087803b158015610c9757600080fd5b505af1158015610cab573d6000803e3d6000fd5b5050505050505b801515845281610cc3576000610d05565b610d058760e0015160200151602001518860a0015163ffffffff168960c0015160200151602001518a60c0015160200151600001518d6060015160ff16611d9b565b63ffffffff16610140850152604087015160030b608085015281610d2a576000610d4b565b60c087015151602081518110610d4257610d42614df5565b60200260200101515b600390810b60a08601526020880151810b60e08601528751900b61010085015281610d8457604080516000815260208101909152610d92565b610d92878a88611e3f611e54565b60608501528180610da05750805b151560208501525050509695505050505050565b818152602082015160409081015160030b9082015260608201516001600160a01b031615610e8d5760028260400151600a811115610df457610df4614917565b14610e1257604051635e7b518b60e11b815260040160405180910390fd5b6060820151608083015160405163ce11a20960e01b81526001600160a01b0386169263ce11a20992610e4692600401614dc3565b60e060405180830381865afa158015610e63573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e879190614e7d565b60208201525b505050565b6000600282515160400151600a811115610eae57610eae614917565b03610ef057600260208301515160400151600a811115610ed057610ed0614917565b03610ee8578151516020830151516100a19190611fb9565b506001919050565b600260208301515160400151600a811115610f0d57610f0d614917565b03610f1a57506000919050565b8151516020830151516100a19190611fb9565b919050565b610f3c8383612018565b610e8d57600082610f5257602084015151610f56565b8351515b9050600083610f6757845151610f6e565b6020850151515b9050600084610f8557856020015160200151610f8c565b8551602001515b9050600085610fa057865160e00151610faa565b866020015160e001515b8351909150600090602a81518110610fc457610fc4614df5565b60200260200101519050610fdc85846022848a612039565b15158252835161100e9086908590602390600b5b8151811061100057611000614df5565b60200260200101518a612039565b1515602083015283516110299086908590602490600c610ff0565b1515604083015261103e85846025848a612039565b1515606083015261105385846026848a612039565b1515608083015261106885846029848a612039565b151560a09092019190915250505050505050565b8160200151156111685760038360078151811061109b5761109b614df5565b60200260200101516110ad9190614ee3565b836007815181106110c0576110c0614df5565b602002602001018181516110d49190614d9c565b60030b905250603283600c815181106110ef576110ef614df5565b602002602001018181516111039190614d75565b60030b905250600a8160198151811061111e5761111e614df5565b602002602001018181516111329190614d75565b60030b90525060148160188151811061114d5761114d614df5565b602002602001018181516111619190614d75565b60030b9052505b8160400151156112855760028360048151811061118757611187614df5565b6020026020010181815161119b9190614ee3565b60030b9052506002836005815181106111b6576111b6614df5565b602002602001018181516111ca9190614ee3565b600390810b9091529050836006815181106111e7576111e7614df5565b60200260200101516111f99190614ee3565b8360068151811061120c5761120c614df5565b602002602001018181516112209190614d9c565b60030b90525060028360088151811061123b5761123b614df5565b6020026020010181815161124f9190614ee3565b60030b905250603283600b8151811061126a5761126a614df5565b6020026020010181815161127e9190614d75565b60030b9052505b8160600151156112bf576002836006815181106112a4576112a4614df5565b602002602001018181516112b89190614ee3565b60030b9052505b81608001511561135757600283600b815181106112de576112de614df5565b602002602001018181516112f29190614ee3565b60030b905250600283600c8151811061130d5761130d614df5565b602002602001018181516113219190614ee3565b60030b905250600283600d8151811061133c5761133c614df5565b602002602001018181516113509190614ee3565b60030b9052505b81511561138e57600a8160198151811061137357611373614df5565b602002602001018181516113879190614d75565b60030b9052505b8160a0015115610e8d576002836006815181106113ad576113ad614df5565b602002602001018181516113c19190614ee3565b60030b905250505050565b6113d4614332565b6000836113e6578451604001516113f0565b8460200151604001515b90506113fc8585612018565b15611443576040805160e08101825260039290920b8252600060208301819052908201819052606082018190526080820181905260a0820181905260c0820152905061017e565b60008461145557602086015151611459565b8551515b905060008561146a57865151611471565b6020870151515b905060018260400151600a81111561148b5761148b614917565b036114a35761149c828285886120a7565b9350611518565b60028260400151600a8111156114bb576114bb614917565b036114e65761149c8282886114d8578960200151602001516114df565b8951602001515b86896122ed565b8160400151600a8111156114fc576114fc614917565b604051630d2a62bd60e41b81526004016106ce91815260200190565b5050509392505050565b8351600390810b604083019081526020860151820b608085015251900b156115c7578251600390810b60408401908152602085015190910b60808301526060850151905161157091906124fa565b60030b60c0820181905260408301805161158b908390614d9c565b60030b905250606083015160408201516115a591906124fa565b60030b60c083018190526040820180516115c0908390614d9c565b60030b9052505b6115d981604001518260e0015161250f565b60030b60a083018190526040820180516115f4908390614d9c565b60030b905250604082015160e083015161160e919061250f565b60030b60a08201819052604083018051611629908390614d9c565b60030b90525050505050565b604082015160030b15611692576000816040015183604001516116589190614d75565b83515190915060009060098151811061167357611673614df5565b6020026020010151905061168782826124fa565b60030b604085015250505b5050565b61169e61436e565b6000848060200190518101906116b49190615018565b8051909150600a8111156116ca576116ca614917565b600003611700578051600a8111156116e4576116e4614917565b60405163f089562b60e01b81526004016106ce91815260200190565b60208101516001600160a01b0316156117d257600080876001600160a01b031663aef874fa846020015185604001516040518363ffffffff1660e01b815260040161174c929190614dc3565b6040805180830381865afa158015611768573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061178c91906150da565b91509150816001600160a01b0316866001600160a01b03161415806117b15750848114155b156117cf576040516376adf5c560e11b815260040160405180910390fd5b50505b60005b8160600151518110156118da57600080886001600160a01b031663aef874fa8560600151858151811061180a5761180a614df5565b60200260200101518660800151868151811061182857611828614df5565b60200260200101516040518363ffffffff1660e01b815260040161184d929190614dc3565b6040805180830381865afa158015611869573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061188d91906150da565b91509150816001600160a01b0316876001600160a01b03161415806118b25750858114155b156118d057604051631c927f9f60e31b815260040160405180910390fd5b50506001016117d5565b5095945050505050565b6118ec6142ca565b60008083608001516001600160a01b031663d4ac484885602001518660c001516040518363ffffffff1660e01b8152600401611929929190614dc3565b60a060405180830381865afa158015611946573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061196a9190615113565b9050600080611984836000015163ffffffff168888612564565b9450915083905060028751600a8111156119a0576119a0614917565b03611a2b5760a0860151602088015160405163415a9c6f60e11b81526001600160a01b0391821660048201529116906382b538de9060240161018060405180830381865afa1580156119f6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a1a91906151b9565b60a00151611a289085614d75565b93505b6040518060c001604052808381526020018481526020018860000151600a811115611a5857611a58614917565b81526020898101516001600160a01b0316908201526040808a015190820152606001600181525094505050509250929050565b611a936142ca565b6000611a9d614258565b611aa561436e565b8851611ac157611abc633b9aca0063ffffffff8716565b611ac7565b88606001515b9250611ae88a84611adb8e6020015161262e565b8e518b9060ff168a612679565b6020808a015163ffffffff948516918101919091529390921690925282875293509150611b169089886127f0565b8851611b5d578351611b4390600981518110611b3457611b34614df5565b602002602001015160016129a8565b602085015163ffffffff9091166040909101819052611b63565b88604001515b602085015163ffffffff9091166040909101528351600a81518110611b8a57611b8a614df5565b6020908102919091018101519085015163ffffffff90911660609091015280516040850190600a811115611bc057611bc0614917565b9081600a811115611bd357611bd3614917565b90525060208101516001600160a01b0316606085015260400151608084015260c081015160ff1660a08401529750975097945050505050565b60008160030b600014611c3257611c2382846124fa565b611c2d9084614d9c565b61017e565b5090919050565b600360ff16816080015160ff16036116925781604001516001600160a01b031663683fedf76040518163ffffffff1660e01b8152600401602060405180830381865afa158015611c8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cb19190614d3f565b60c08201516020830151610100840151606085015160405163057bd05b60e41b815263ffffffff90941660048501526001600160a01b039283166024850152604484019190915260ff16606483015291909116906357bd05b090608401600060405180830381600087803b158015611d2857600080fd5b505af1158015611d3c573d6000803e3d6000fd5b505050505050565b60006100a182600001518360600151846040015185602001516129be565b6000611d738263ffffffff16612a12565b604051602001611d839190615270565b6040516020818303038152906040526100a1906152b3565b600080611db48563ffffffff168563ffffffff16612b12565b90506000611dc36005836152da565b611dce906001614cf7565b90506000670de0b6b3a7640000611deb8963ffffffff8c166152ee565b611df591906152da565b611e059063ffffffff8b16614cf7565b905084821115611e3157611e198583615305565b611e249060026153fc565b611e2e90826152da565b90505b925050505b95945050505050565b6020822080835260009061017e908390614d20565b6060611e36604051806101600160405280866060015160ff1681526020018760c00151602001516000015160ff16815260200185610100015160ff16815260200186604001516001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa158015611ed7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611efb9190614d3f565b6001600160a01b03168152610180860151602082015260c088015151604090910190601781518110611f2f57611f2f614df5565b602002602001015160030b81526020018760c00151600001516018602b811115611f5b57611f5b614917565b81518110611f6b57611f6b614df5565b602002602001015160030b8152602001856101a0015181526020018760c00151602001516020015163ffffffff1681526020018760a0015163ffffffff168152602001600081525083612b3b565b8051600090600681518110611fd057611fd0614df5565b602002602001015160030b83600001516006602b811115611ff357611ff3614917565b8151811061200357612003614df5565b602002602001015160030b1215905092915050565b60008161202e57602083015160e001515161017e565b50505160e001515190565b60008061204c8787600001518787612fb9565b90508060030b600003612063576000915050611e36565b6064600382900b12612079576001915050611e36565b6120858160030b613112565b61209b6120926064613112565b8563ffffffff16565b10979650505050505050565b6120af614332565b60408051600180825281830190925290816020015b6120cc614332565b8152602001906001900390816120c4579050506000815181106120f1576120f1614df5565b60200260200101519050600061210b866000015184613141565b90506121178187613162565b905061212881878760a001516131a4565b90506121498661214461213b6064613112565b8663ffffffff16565b61323e565b612154576000612157565b60015b60ff16608083018190521561217657612171816002615408565b612178565b805b905061218981868860a00151613257565b905061219581866132b3565b86519091506121fd906121c59060065b815181106121b5576121b5614df5565b602002602001015160030b613112565b86516121d29060076121a5565b6020898101515190890151518a5163ffffffff92831692909116906121f890601e6121a5565b6132cb565b612212670de0b6b3a76400008563ffffffff16565b1161221e576000612221565b60015b60ff1660a083015284516122369060086121a5565b61224460648563ffffffff16565b10612250576000612253565b60015b60ff90811660c084015260a083015116151580612276575060c082015160ff1615155b1561227f575060005b60008160030b8560030b131561229e576122998286614d9c565b6122a1565b60005b90506122ad8186614d9c565b600382810b855281900b602085015291506122c882886133cb565b60030b60408401526122da8287613403565b60030b6060840152509095945050505050565b6122f5614332565b600061232a878661232561230f896020015160030b613112565b61231f8a6040015160030b613112565b88613412565b613449565b905061233b8188876000015161356d565b905061234c81888860a001516131a4565b9050600061236a886121446123616064613112565b8763ffffffff16565b9050806123775781612382565b612382826002615408565b915061239382888a60a00151613257565b915061239f82886132b3565b91506001865160058111156123b6576123b6614917565b036123d8576123c78288600b6135fd565b6123d19083614d9c565b9150612431565b6002865160058111156123ed576123ed614917565b036123fe576123c78288600c6135fd565b60038651600581111561241357612413614917565b03612431576124248288600d6135fd565b61242e9083614d9c565b91505b60008260030b8660030b1261244f5761244a8387614d9c565b612452565b60005b905061245e8187614d9c565b92506040518060e001604052808260030b81526020018460030b8152602001612487858c6133cb565b60030b81526020016124ae898c6124a9670de0b6b3a76400008b63ffffffff16565b61364e565b6124b8868c613699565b6124c29190614d75565b60030b8152602001836124d65760006124d9565b60015b60ff1681526000602082018190526040909101529998505050505050505050565b60008160030b8360030b12611c32578161017e565b60008160a00151801561252d5750600161252b8460030b613112565b115b1561255b57612554600a6125438560030b613112565b61254d91906152da565b60016136a8565b90506100a1565b50600092915050565b6060600082608001516001600160a01b03166357e9ee7b6040518060a0016040528086602001516001600160a01b031681526020018660c0015181526020018863ffffffff1681526020018760600151815260200187608001518152506040518263ffffffff1660e01b81526004016125dd9190615459565b600060405180830381865afa1580156125fa573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526126229190810190615560565b91509150935093915050565b6000612646600a6a084595161401484a0000006152da565b82101561265557506000919050565b6a084595161401484a00000061266f83633b9aca006152ee565b6100a191906152da565b606060008061268661436e565b61268e614258565b6126978b6136b7565b60a081015160ff16945090506126ae886001614cf7565b8463ffffffff16101561270857612705600f6126d063ffffffff87168b615305565b6126db90600a6152ee565b6126e591906152da565b6126f59063ffffffff8716614cf7565b6127008960056152ee565b6138d8565b93505b600260ff1681610160015160ff1603612780576000612732670de0b6b3a76400008863ffffffff16565b9050670a688906bd8b000081111561274d576001835261277a565b600283526101208201516001600160a01b031660208401526101408201516001600160401b031660408401525b506127c4565b80610160015160ff16600a81111561279a5761279a614917565b8290600a8111156127ad576127ad614917565b9081600a8111156127c0576127c0614917565b9052505b6127dd816060015182608001518c8c8560e001516138e7565b9095509250965096509650965096915050565b60608201515160005b818110156104b65760008460600151828151811061281957612819614df5565b6020026020010151905060008560800151838151811061283b5761283b614df5565b602002602001015190506000808660a001516001600160a01b031663aef874fa85856040518363ffffffff1660e01b815260040161287a929190614dc3565b6040805180830381865afa158015612896573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128ba91906150da565b91509150816001600160a01b031687602001516001600160a01b03161415806128e75750808760c0015114155b156129055760405163325e7bd360e01b815260040160405180910390fd5b6000808860a001516001600160a01b03166324e44dfc87876040518363ffffffff1660e01b815260040161293a929190614dc3565b600060405180830381865afa158015612957573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261297f91908101906155ad565b915091506129968b61299184846139ac565b613a5a565b505050505050508060010190506127f9565b60008160030b8360030b1215611c32578161017e565b6000846129cc5760006129cf565b60015b60ff1660001b905060088463ffffffff1660001b901b8117905060288363ffffffff1660001b901b8117905060488260ff1660001b901b81179050949350505050565b606081600003612a395750506040805180820190915260018152600360fc1b602082015290565b8160005b8115612a635780612a4d81615670565b9150612a5c9050600a836152da565b9150612a3d565b6000816001600160401b03811115612a7d57612a7d614472565b6040519080825280601f01601f191660200182016040528015612aa7576020820181803683370190505b5090505b841561035157612abc600183615305565b9150612ac9600a86614d20565b612ad4906030614cf7565b60f81b818381518110612ae957612ae9614df5565b60200101906001600160f81b031916908160001a905350612b0b600a866152da565b9450612aab565b805b60638110156100a15782612b2782613ab8565b63ffffffff1610156100a157600101612b14565b6080820151516040805160208101918290526060858101516101408701516337347e0560e11b909452633b9aca006024840152604483019390935292916000919081906001600160a01b0316636e68fc0a606483016020604051808303816000875af1158015612baf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612bd39190614d5c565b905290506000826001600160401b03811115612bf157612bf1614472565b604051908082528060200260200182016040528015612c1a578160200160208202803683370190505b50905060015b83811015612c4e5780828281518110612c3b57612c3b614df5565b6020908102919091010152600101612c20565b50612c598282613b4f565b6000836001600160401b03811115612c7357612c73614472565b604051908082528060200260200182016040528015612c9c578160200160208202803683370190505b509050600080612cc689610100015163ffffffff168a6020015160ff168b6000015160ff16613bca565b90506000612cdc8a60c0015160030b60646138d8565b905060005b87811015612ec757633b9aca0063ffffffff168b60e00151878381518110612d0b57612d0b614df5565b602002602001015181518110612d2357612d23614df5565b602002602001015163ffffffff161115612d94578a60e00151868281518110612d4e57612d4e614df5565b602002602001015181518110612d6657612d66614df5565b60200260200101516040516304470bfd60e21b81526004016106ce919063ffffffff91909116815260200190565b6000612de28c60e00151888481518110612db057612db0614df5565b602002602001015181518110612dc857612dc8614df5565b602002602001015163ffffffff168d610120015186613c13565b905060648c60a0015160030b820281612dfd57612dfd614d0a565b040160648382020490036000612e1b89633b9aca0063ffffffff8f16565b90508115801590612e395750633b9aca0082101580612e3957508181105b15612ebd578c6040015160ff16861015612ebd578c60800151888481518110612e6457612e64614df5565b602002602001015181518110612e7c57612e7c614df5565b6020026020010151878481518110612e9657612e96614df5565b60200260200101906001600160a01b031690816001600160a01b0316815250508560010195505b5050600101612ce1565b506000836001600160401b03811115612ee257612ee2614472565b604051908082528060200260200182016040528015612f0b578160200160208202803683370190505b5090506000805b89811015612fa85760006001600160a01b0316878281518110612f3757612f37614df5565b60200260200101516001600160a01b031614612fa057868181518110612f5f57612f5f614df5565b6020026020010151838381518110612f7957612f79614df5565b60200260200101906001600160a01b031690816001600160a01b0316815250508160010191505b600101612f12565b50909b9a5050505050505050505050565b835160009083602b811115612fd057612fd0614917565b81518110612fe057612fe0614df5565b602002602001015190506002600a811115612ffd57612ffd614917565b8560400151600a81111561301357613013614917565b036130e757602383602b81111561302c5761302c614917565b14801561304a5750600184600581111561304857613048614917565b145b1561305d5761305a601482614d75565b90505b602483602b81111561307157613071614917565b14801561308f5750600284600581111561308d5761308d614917565b145b156130a25761309f601482614d75565b90505b602583602b8111156130b6576130b6614917565b1480156130d4575060038460058111156130d2576130d2614917565b145b156130e7576130e4601482614d75565b90505b60646130f483605a6124fa565b6130fe9083615408565b6131089190614ee3565b611e369082614d9c565b6000808260030b121561312757506000919050565b60008260030b1361313a57506000919050565b5060030b90565b600061017e6131518460046121a5565b61315c8560056121a5565b84613412565b80516000906064908490601a8151811061317e5761317e614df5565b60200260200101516131909190615408565b61319a9190614ee3565b61017e9084614d75565b6000600182036131f55782516064908590600e5b815181106131c8576131c8614df5565b60200260200101516131da9190615408565b6131e49190614ee3565b6131ee9085614d75565b905061017e565b6002820361320b5782516064908590600f6131b8565b60038203613221578251606490859060106131b8565b60048203613237578251606490859060116131b8565b508261017e565b815160009061324e9060196121a5565b90911092915050565b6000600182036132775761326d848460126135fd565b6131ee9085614d9c565b6002820361328b5761326d848460136135fd565b6003820361329f5761326d848460146135fd565b600482036132375761326d848460156135fd565b60006132c1838360216135fd565b61017e9084614d9c565b600060646132d983886152ee565b6132e391906152da565b6132ed9087614cf7565b955060006132fc8760016136a8565b9050600061330d61254d888a614cf7565b905085600061331d6002886152da565b905060008361333486670de0b6b3a76400006152ee565b61333e91906152da565b9050600061334c838b614cf7565b61335e85670de0b6b3a76400006152ee565b61336891906152da565b90506000670de0b6b3a7640000826133818560026152ee565b61338b91906152ee565b61339591906152da565b90506133ba6133ac82670d2f13f7789f00006138d8565b6702c68af0bb1400006136a8565b9d9c50505050505050505050505050565b8051600090606490601f5b815181106133e6576133e6614df5565b6020026020010151846133f99190615408565b61017e9190614ee3565b805160009060649060276133d6565b600082841015613441576134326134298585615305565b8363ffffffff16565b61343c9085614cf7565b610351565b509092915050565b6060820151518351600091829160649190838151811061346b5761346b614df5565b602002602001015161347d9190615408565b6134879190614ee3565b60608501516020015186519192506064916001815181106134aa576134aa614df5565b60200260200101516134bc9190615408565b6134c69190614ee3565b6134d09082614d75565b60608501516040015186519192506064916002815181106134f3576134f3614df5565b60200260200101516135059190615408565b61350f9190614ee3565b6135199082614d75565b6060808601510151865191925060649160038151811061353b5761353b614df5565b602002602001015161354d9190615408565b6135579190614ee3565b6135619082614d75565b9050611e368184614d75565b6000600182600581111561358357613583614917565b036135b3578251606490601b5b815181106135a0576135a0614df5565b6020026020010151856131da9190615408565b60028260058111156135c7576135c7614917565b036135d8578251606490601c613590565b60038260058111156135ec576135ec614917565b03613237578251606490601d613590565b6000606461363a846000015184602b81111561361b5761361b614917565b8151811061362b5761362b614df5565b6020026020010151605a6124fa565b6136449086615408565b6103519190614ee3565b600060048451600581111561366557613665614917565b14801561367957506706f05b59d3b2000082115b613684576000610351565b60028360200151604001516103519190614ee3565b805160009060649060286133d6565b6000818311611c32578161017e565b6136bf614258565b6136c7614258565b6137228360000180548060200260200160405190810160405280929190818152602001828054801561371857602002820191906000526020600020905b815481526020019060010190808311613704575b5050505050613c54565b606083015260808201526001830154600881901c601082901c603083901c60ff90811661010086015263ffffffff90911660e085015290811660c08401521660a0820152600283015461377c60a082901c9060e083901c90565b60ff166101608401526001600160401b039081166101408401526001600160a01b0390911661012083015260038401549081908111156137be576137be614472565b6040519080825280602002602001820160405280156137e7578160200160208202803683370190505b50610180830152806001600160401b0381111561380657613806614472565b60405190808252806020026020018201604052801561382f578160200160208202803683370190505b506101a083015260005b818110156138cf5761386d85600301828154811061385957613859614df5565b90600052602060002001549060a082901c90565b846101800151838151811061388457613884614df5565b60200260200101856101a0015184815181106138a2576138a2614df5565b63ffffffff909316602093840291909101909201919091526001600160a01b039091169052600101613839565b50909392505050565b6000818310611c32578161017e565b606060006138f6600486615689565b60408051602b8082526105808201909252919650602082016105608036833701905050915060005b87518110156139945761394b87828151811061393c5761393c614df5565b60200260200101518787613f45565b8389838151811061395e5761395e614df5565b602002602001015160ff168151811061397957613979614df5565b60039290920b6020928302919091019091015260010161391e565b506139a0838686613f45565b90509550959350505050565b60408051602b8082526105808201909252606091602082016105608036833701905050905060005b8351811015613a535760008482815181106139f1576139f1614df5565b602002602001015190508060030b600014613a4a578083858481518110613a1a57613a1a614df5565b602002602001015160ff1681518110613a3557613a35614df5565b602002602001019060030b908160030b815250505b506001016139d4565b5092915050565b606060005b8351811015613ab057828181518110613a7a57613a7a614df5565b6020026020010151848281518110613a9457613a94614df5565b60209081029190910101805190910160030b9052600101613a5f565b509192915050565b600063ffffffff82161580613ad45750606363ffffffff831610155b15613ae157506000919050565b670de0b6b3a7640000613b20613af88460636156ac565b613b039060026156c9565b613b1b9063ffffffff16670de0b6b3a76400006152ee565b613fb1565b613b3290675cfb2e807b1e0000615305565b613b45620186a063ffffffff86166152ee565b61266f91906152ee565b80516000196001600160801b0382156104b6576020840193505b6020852080865282840193608082901c0660051b850184613b8b5750506104b6565b600585811b8701805183519091529091528385019482841606901b850184613bb45750506104b6565b600585901b860180518251909152905250613b69565b6000806005613bd98686612b12565b613be391906152da565b613bee906001614cf7565b9050828111613bfe576000611e36565b613c088382615305565b611e369060026153fc565b600080670de0b6b3a7640000613c2985876152ee565b613c3391906152da565b613c3d9086614cf7565b9050821561035157613c4f83826152da565b611e36565b805160609081906000613c688260086152ee565b90506000816001600160401b03811115613c8457613c84614472565b604051908082528060200260200182016040528015613cad578160200160208202803683370190505b5090506000826001600160401b03811115613cca57613cca614472565b604051908082528060200260200182016040528015613cf3578160200160208202803683370190505b5090506000805b85811015613e205760005b6008811015613e1757600081613d1c8460086152ee565b613d269190614cf7565b9050613d338260206152ee565b8b8481518110613d4557613d45614df5565b602002602001015160001c901c60020b868281518110613d6757613d67614df5565b60039290920b602092830291909101820152613d849083906152ee565b613d8f906018614cf7565b8b8481518110613da157613da1614df5565b602002602001015160001c901c858281518110613dc057613dc0614df5565b602002602001019060ff16908160ff1681525050858181518110613de657613de6614df5565b602002602001015160030b600003613dfe5750613e17565b83613e0881615670565b94505050806001019050613d05565b50600101613cfa565b50806001600160401b03811115613e3957613e39614472565b604051908082528060200260200182016040528015613e62578160200160208202803683370190505b509650806001600160401b03811115613e7d57613e7d614472565b604051908082528060200260200182016040528015613ea6578160200160208202803683370190505b50955060005b81811015613f3a57838181518110613ec657613ec6614df5565b6020026020010151888281518110613ee057613ee0614df5565b602002602001019060030b908160030b81525050828181518110613f0657613f06614df5565b6020026020010151878281518110613f2057613f20614df5565b60ff90921660209283029190910190910152600101613eac565b505050505050915091565b60008360030b600003613f5a5750600061017e565b633b9aca00613f70600384810b9087900b6156e6565b613f7a9190615716565b633b9aca00613f9363ffffffff8616600388900b6156e6565b613f9d9190615716565b613fa79190615744565b6103519085614d75565b6000670de0b6b3a7640000821015613fdf57604051637046c4a960e01b8152600481018390526024016106ce565b6000613ffb613ff6670de0b6b3a7640000856152da565b614092565b9050600061401182670de0b6b3a76400006152ee565b905083821c670de0b6b3a764000081900361402e57509392505050565b6706f05b59d3b200005b801561408857670de0b6b3a764000061405183806152ee565b61405b91906152da565b9150671bc16d674ec800008210614080576140768184614cf7565b9250600182901c91505b60011c614038565b5090949350505050565b6000600160801b82106140b257608091821c916140af9082614cf7565b90505b600160401b82106140d057604091821c916140cd9082614cf7565b90505b64010000000082106140ef57602091821c916140ec9082614cf7565b90505b62010000821061410c57601091821c916141099082614cf7565b90505b610100821061412857600891821c916141259082614cf7565b90505b6010821061414357600491821c916141409082614cf7565b90505b6004821061415e57600291821c9161415b9082614cf7565b90505b60028210610f2d576100a1600182614cf7565b604080516101c08101825260008082526020820181905291810182905260608082018190526080820183905260a0820183905260c0820183905260e0820183905261010082018390526101208201839052610140820183905261016082018390526101808201929092526101a081019190915290565b60405180604001604052806141fa6143a7565b81526020016142076143a7565b905290565b6040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a081019190915260c0810161424b6142ca565b81526020016142076142ca565b604080516101c081018252600080825260208201819052909182019081526060602082018190526040820181905260008183018190526080830181905260a0830181905260c0830181905260e08301819052610100830181905261012083015261014082018190526101609091015290565b6040805160c0810182526060808252825160a081018452600080825260208281018290529482018190529181018290526080810191909152909182019081526020016000815260200160006001600160a01b0316815260200160008152602001600081525090565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c081019190915290565b6040805160a08101909152806000815260200160006001600160a01b031681526020016000815260200160608152602001606081525090565b6040518061010001604052806143bb6142ca565b81526040805160808082018352600080835260208381018290528385018290528451928301855281835282810182905293820181905260608083019190915282015291019081526000602080830182905260408084018390526060808501849052608080860185905260a08087018690528351610120810185528681529485018690529284018590529083018490528201839052810182905260c081810183905260e0820183905261010082019290925291015290565b634e487b7160e01b600052604160045260246000fd5b60405161018081016001600160401b03811182821017156144ab576144ab614472565b60405290565b604051608081016001600160401b03811182821017156144ab576144ab614472565b60405160a081016001600160401b03811182821017156144ab576144ab614472565b60405161012081016001600160401b03811182821017156144ab576144ab614472565b604051601f8201601f191681016001600160401b038111828210171561454057614540614472565b604052919050565b6001600160a01b038116811461455d57600080fd5b50565b8035610f2d81614548565b60ff8116811461455d57600080fd5b8035610f2d8161456b565b63ffffffff8116811461455d57600080fd5b8035610f2d81614585565b80356001600160401b0381168114610f2d57600080fd5b600082601f8301126145ca57600080fd5b81356001600160401b038111156145e3576145e3614472565b6145f6601f8201601f1916602001614518565b81815284602083860101111561460b57600080fd5b816020850160208301376000918101602001919091529392505050565b6000806040838503121561463b57600080fd5b82356001600160401b038082111561465257600080fd5b90840190610180828703121561466757600080fd5b61466f614488565b61467883614560565b815261468660208401614560565b602082015261469760408401614560565b60408201526146a86060840161457a565b60608201526146b96080840161457a565b60808201526146ca60a0840161457a565b60a08201526146db60c08401614597565b60c08201526146ec60e084016145a2565b60e0820152610100838101359082015261012080840135908201526101408084013590820152610160808401358381111561472657600080fd5b614732898287016145b9565b91830191909152509660209590950135955050505050565b6001600160a01b03169052565b60008151808452602080850194506020840160005b838110156147915781516001600160a01b03168752958201959082019060010161476c565b509495945050505050565b60008151808452602080850194506020840160005b8381101561479157815163ffffffff16875295820195908201906001016147b1565b604081526147e660408201845115159052565b600060208401516147fb606084018215159052565b50604084015161480e608084018261474a565b5060608401516101c08060a085015261482b610200850183614757565b9150608086015161484160c086018260030b9052565b5060a086015161485660e086018260030b9052565b5060c086015161010061486d8187018360030b9052565b60e088015191506101206148858188018460030b9052565b9088015191506101409061489d8783018460030b9052565b88015191506101606148b68782018463ffffffff169052565b908801519150610180906148d18783018463ffffffff169052565b8801516101a087810191909152908801519286019290925250850151838203603f19016101e0850152614904828261479c565b9250505061017e602083018460ff169052565b634e487b7160e01b600052602160045260246000fd5b600b811061493d5761493d614917565b9052565b80516101408084528151908401819052600091610160850191602091820190845b8181101561498157825160030b85529383019391830191600101614962565b5050505060208301516149d2602086018263ffffffff808251168352806020830151166020840152806040830151166040840152806060830151166060840152806080830151166080840152505050565b5060408301516149e560c086018261492d565b5060608301516149f860e086018261474a565b50608083015161010085015260a08301516101208501528091505092915050565b805160068110614a2b57614a2b614917565b8252602081810151600390810b82850152604080840151820b818601526060938401518051830b8587015292830151820b6080860152820151810b60a0850152910151900b60c090910152565b8051151582526020810151151560208301526040810151614a9d604084018215159052565b506060810151614ab1606084018215159052565b506080810151614ac5608084018215159052565b5060a0810151614ad960a084018215159052565b5060c0810151614aed60c084018215159052565b5060e0810151614b0160e084018215159052565b50610100908101511515910152565b60006102c08251818552614b2682860182614941565b9150506020830151614b3b6020860182614a19565b506040830151614b5161010086018260030b9052565b506060830151614b6761012086018260030b9052565b506080830151614b7d61014086018260030b9052565b5060a0830151614b9361016086018260030b9052565b5060c0830151614ba961018086018260030b9052565b5060e0830151614bbd6101a0860182614a78565b509392505050565b60018060a01b0385168152608060208201526000845160406080840152614bef60c0840182614b10565b90506020860151607f198483030160a0850152614c0c8282614b10565b91505082810360408401526101208551818352614c2b82840182614941565b91505060208601518282036020840152614c458282614941565b9150506040860151614c6260408401826001600160401b03169052565b506060860151614c7a606084018263ffffffff169052565b506080860151614c8d608084018261474a565b5060a086015160a083015260c0860151614cac60c084018260ff169052565b5060e086015160e083015261010080870151614ccc8285018260ff169052565b50506060939093019390935250949350505050565b634e487b7160e01b600052601160045260246000fd5b808201808211156100a1576100a1614ce1565b634e487b7160e01b600052601260045260246000fd5b600082614d2f57614d2f614d0a565b500690565b8051610f2d81614548565b600060208284031215614d5157600080fd5b815161017e81614548565b600060208284031215614d6e57600080fd5b5051919050565b600381810b9083900b01637fffffff8113637fffffff19821217156100a1576100a1614ce1565b600382810b9082900b03637fffffff198112637fffffff821317156100a1576100a1614ce1565b6001600160a01b03929092168252602082015260400190565b60ff81811683821601908111156100a1576100a1614ce1565b634e487b7160e01b600052603260045260246000fd5b8051600381900b8114610f2d57600080fd5b600060808284031215614e2f57600080fd5b614e376144b1565b9050614e4282614e0b565b8152614e5060208301614e0b565b6020820152614e6160408301614e0b565b6040820152614e7260608301614e0b565b606082015292915050565b600060e08284031215614e8f57600080fd5b614e976144b1565b825160068110614ea657600080fd5b8152614eb460208401614e0b565b6020820152614ec560408401614e0b565b6040820152614ed78460608501614e1d565b60608201529392505050565b60008160030b8360030b80614efa57614efa614d0a565b637fffffff19821460001982141615614f1557614f15614ce1565b90059392505050565b60006001600160401b03821115614f3757614f37614472565b5060051b60200190565b600082601f830112614f5257600080fd5b81516020614f67614f6283614f1e565b614518565b8083825260208201915060208460051b870101935086841115614f8957600080fd5b602086015b84811015614fae578051614fa181614548565b8352918301918301614f8e565b509695505050505050565b600082601f830112614fca57600080fd5b81516020614fda614f6283614f1e565b8083825260208201915060208460051b870101935086841115614ffc57600080fd5b602086015b84811015614fae5780518352918301918301615001565b60006020828403121561502a57600080fd5b81516001600160401b038082111561504157600080fd5b9083019060a0828603121561505557600080fd5b61505d6144d3565b8251600b811061506c57600080fd5b815261507a60208401614d34565b60208201526040830151604082015260608301518281111561509b57600080fd5b6150a787828601614f41565b6060830152506080830151828111156150bf57600080fd5b6150cb87828601614fb9565b60808301525095945050505050565b600080604083850312156150ed57600080fd5b82516150f881614548565b6020939093015192949293505050565b8051610f2d81614585565b600060a0828403121561512557600080fd5b61512d6144d3565b825161513881614585565b8152602083015161514881614585565b6020820152604083015161515b81614585565b6040820152606083015161516e81614585565b6060820152608083015161518181614585565b60808201529392505050565b8051610f2d8161456b565b8051600d8110610f2d57600080fd5b805161ffff81168114610f2d57600080fd5b600061018082840312156151cc57600080fd5b6151d46144f5565b6151dd8361518d565b81526151eb6020840161518d565b60208201526151fc60408401615198565b604082015261520d606084016151a7565b606082015261521e6080840161518d565b608082015261522f60a08401615108565b60a082015261524060c0840161518d565b60c082015261525160e0840161518d565b60e082015261010061526585828601614e1d565b908201529392505050565b674d4f4e535445525f60c01b81526000825160005b818110156152a25760208186018101516008868401015201615285565b506000920160080191825250919050565b805160208083015191908110156152d4576000198160200360031b1b821691505b50919050565b6000826152e9576152e9614d0a565b500490565b80820281158282048414176100a1576100a1614ce1565b818103818111156100a1576100a1614ce1565b600181815b8085111561535357816000190482111561533957615339614ce1565b8085161561534657918102915b93841c939080029061531d565b509250929050565b60008261536a575060016100a1565b81615377575060006100a1565b816001811461538d5760028114615397576153b3565b60019150506100a1565b60ff8411156153a8576153a8614ce1565b50506001821b6100a1565b5060208310610133831016604e8410600b84101617156153d6575081810a6100a1565b6153e08383615318565b80600019048211156153f4576153f4614ce1565b029392505050565b600061017e838361535b565b60008260030b8260030b028060030b9150808214613a5357613a53614ce1565b60008151808452602080850194506020840160005b838110156147915781518752958201959082019060010161543d565b6000602080835260c0830160018060a01b03808651168386015282860151604086015263ffffffff6040870151166060860152606086015160a0608087015282815180855260e0880191508583019450600092505b808310156154d0578451841682529385019360019290920191908501906154ae565b506080880151878203601f190160a089015294506154ee8186615428565b98975050505050505050565b600082601f83011261550b57600080fd5b8151602061551b614f6283614f1e565b8083825260208201915060208460051b87010193508684111561553d57600080fd5b602086015b84811015614fae5761555381614e0b565b8352918301918301615542565b6000806040838503121561557357600080fd5b82516001600160401b0381111561558957600080fd5b615595858286016154fa565b9250506155a460208401614e0b565b90509250929050565b600080604083850312156155c057600080fd5b82516001600160401b03808211156155d757600080fd5b6155e3868387016154fa565b93506020915081850151818111156155fa57600080fd5b85019050601f8101861361560d57600080fd5b805161561b614f6282614f1e565b81815260059190911b8201830190838101908883111561563a57600080fd5b928401925b828410156156615783516156528161456b565b8252928401929084019061563f565b80955050505050509250929050565b60006001820161568257615682614ce1565b5060010190565b600063ffffffff808416806156a0576156a0614d0a565b92169190910492915050565b63ffffffff828116828216039080821115613a5357613a53614ce1565b63ffffffff818116838216019080821115613a5357613a53614ce1565b80820260008212600160ff1b8414161561570257615702614ce1565b81810583148215176100a1576100a1614ce1565b60008261572557615725614d0a565b600160ff1b82146000198414161561573f5761573f614ce1565b500590565b808201828112600083128015821682158216171561576457615764614ce1565b50509291505056fea264697066735822122086b603e4d818bdb49c0bd5676bc9abbc395525ee319c2b07b795aa434978097d64736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "action(IGOC.ActionContext,IGOC.MonsterInfo storage)": {
        "details": "weird, but memory ctx is more efficient here than calldata ctx",
        "returns": {
          "result": "Fields objectId, heroToken, heroTokenId, iteration remain uninitialized here. Caller is responsible to set that values."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "action(IGOC.ActionContext,IGOC.MonsterInfo storage)": {
        "notice": "Fight, post fight, generate fight results"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}