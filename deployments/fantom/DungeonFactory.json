{
  "address": "0xA7af921BDC98205DE59f3Fa2da560eE7707Fb179",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "dungNum",
          "type": "uint16"
        }
      ],
      "name": "DungeonAlreadySpecific",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "dungNum",
          "type": "uint16"
        }
      ],
      "name": "DungeonAlreadySpecific2",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorDungeonCompleted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorDungeonIsFreeAlready",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "ErrorHeroIsDead",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        }
      ],
      "name": "ErrorHeroIsNotRegistered",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorHeroLevelStartFrom1",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorHeroNotInDungeon",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "biome",
          "type": "uint256"
        }
      ],
      "name": "ErrorIncorrectBiome",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "heroLevel",
          "type": "uint256"
        }
      ],
      "name": "ErrorLevelTooLow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "heroBiome",
          "type": "uint8"
        }
      ],
      "name": "ErrorNoDungeonsForBiome",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorNoEligibleDungeons",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorNotChances",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ErrorNotDeployer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorNotObject1",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ErrorNotOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorNotReady",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorNotStages",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorOnlyEoa",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorPaused",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "heroLevel",
          "type": "uint256"
        }
      ],
      "name": "ErrorWrongLevel",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "multiplier",
          "type": "uint256"
        }
      ],
      "name": "ErrorWrongMultiplier",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "stage",
          "type": "uint256"
        }
      ],
      "name": "ErrorWrongStage",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidInitialization",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotInitializing",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "OutOfBounds",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "TooHighValue",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        }
      ],
      "name": "TooLowX",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "WrongSpecificDungeon",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "dungId",
          "type": "uint64"
        }
      ],
      "name": "Clear",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ts",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "block",
          "type": "uint256"
        }
      ],
      "name": "ContractInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "dungLogicId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint8[][]",
              "name": "objTypesByStages",
              "type": "uint8[][]"
            },
            {
              "internalType": "uint32[][]",
              "name": "objChancesByStages",
              "type": "uint32[][]"
            },
            {
              "internalType": "uint32[]",
              "name": "uniqObjects",
              "type": "uint32[]"
            },
            {
              "internalType": "uint8",
              "name": "minLevel",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "maxLevel",
              "type": "uint8"
            },
            {
              "internalType": "bytes32[]",
              "name": "requiredCustomDataIndex",
              "type": "bytes32[]"
            },
            {
              "internalType": "uint64[]",
              "name": "requiredCustomDataMinValue",
              "type": "uint64[]"
            },
            {
              "internalType": "uint64[]",
              "name": "requiredCustomDataMaxValue",
              "type": "uint64[]"
            },
            {
              "internalType": "bool[]",
              "name": "requiredCustomDataIsHero",
              "type": "bool[]"
            }
          ],
          "indexed": false,
          "internalType": "struct IDungeonFactory.DungeonGenerateInfo",
          "name": "info",
          "type": "tuple"
        }
      ],
      "name": "DungeonLogicRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "dungLogicId",
          "type": "uint16"
        }
      ],
      "name": "DungeonLogicRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "dungLogicId",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "biome",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroCls",
          "type": "uint256"
        }
      ],
      "name": "DungeonSpecificLogicRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "dungLogicId",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroLvl",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroCls",
          "type": "uint256"
        }
      ],
      "name": "DungeonSpecificLogicRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "dungeonId",
          "type": "uint64"
        }
      ],
      "name": "FreeDungeonAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "version",
          "type": "uint64"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "level",
          "type": "uint256"
        }
      ],
      "name": "MinLevelForTreasuryChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "dungId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "objId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "iteration",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "currentStage",
          "type": "uint256"
        }
      ],
      "name": "ObjectOpened",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "RevisionIncreased",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CONTROLLABLE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "created",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "createdBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "currentDungeon",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "dungLogicNum",
          "type": "uint16"
        }
      ],
      "name": "dungeonAttributes",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "stages",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "biome",
              "type": "uint8"
            },
            {
              "internalType": "uint32[]",
              "name": "uniqObjects",
              "type": "uint32[]"
            },
            {
              "internalType": "bytes32",
              "name": "minMaxLevel",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32[]",
              "name": "requiredCustomDataIndex",
              "type": "bytes32[]"
            },
            {
              "internalType": "bytes32[]",
              "name": "requiredCustomDataValue",
              "type": "bytes32[]"
            },
            {
              "components": [
                {
                  "internalType": "bytes32[]",
                  "name": "objTypesByStages",
                  "type": "bytes32[]"
                },
                {
                  "internalType": "uint32[][]",
                  "name": "objChancesByStages",
                  "type": "uint32[][]"
                }
              ],
              "internalType": "struct IDungeonFactory.ObjectGenerateInfo",
              "name": "info",
              "type": "tuple"
            }
          ],
          "internalType": "struct IDungeonFactory.DungeonAttributes",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "dungeonCounter",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "dungeonId",
          "type": "uint64"
        }
      ],
      "name": "dungeonNgLevel",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "dungeonId",
          "type": "uint64"
        }
      ],
      "name": "dungeonStatus",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "dungNum",
          "type": "uint16"
        },
        {
          "internalType": "bool",
          "name": "isCompleted",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "currentObject",
          "type": "uint32"
        },
        {
          "internalType": "uint8",
          "name": "currentObjIndex",
          "type": "uint8"
        },
        {
          "internalType": "address[]",
          "name": "treasuryTokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "treasuryTokensAmounts",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes32[]",
          "name": "treasuryItems",
          "type": "bytes32[]"
        },
        {
          "internalType": "uint8",
          "name": "stages",
          "type": "uint8"
        },
        {
          "internalType": "uint32[]",
          "name": "uniqObjects",
          "type": "uint32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "maxAvailableBiome_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "treasuryBalance",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "heroLevel",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "dungeonBiome",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "maxOpenedNgLevel",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "heroNgLevel",
          "type": "uint8"
        }
      ],
      "name": "dungeonTreasuryReward",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "dungId",
          "type": "uint64"
        }
      ],
      "name": "emergencyExit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "dungId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "heroToken_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId_",
          "type": "uint256"
        }
      ],
      "name": "enter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "dungId",
          "type": "uint64"
        },
        {
          "internalType": "bool",
          "name": "claim",
          "type": "bool"
        }
      ],
      "name": "exit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "msgSender",
          "type": "address"
        }
      ],
      "name": "exitForcibly",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "biome",
          "type": "uint256"
        }
      ],
      "name": "freeDungeonsByLevel",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "biome",
          "type": "uint256"
        }
      ],
      "name": "freeDungeonsByLevelLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IController",
          "name": "controller_",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "heroLevel",
          "type": "uint8"
        },
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "random",
          "type": "uint256"
        }
      ],
      "name": "getDungeonLogic",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroLevel",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "biome",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "heroNgLevel",
          "type": "uint256"
        }
      ],
      "name": "getDungeonTreasuryAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountForDungeon",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "mintAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "increaseRevision",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "controller_",
          "type": "address"
        }
      ],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "isBiomeBoss",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isController",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "dungeonLogic",
          "type": "uint16"
        },
        {
          "internalType": "uint8",
          "name": "heroLevel",
          "type": "uint8"
        },
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "isDungeonEligibleForHero",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isGovernance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "forwarder",
          "type": "address"
        }
      ],
      "name": "isTrustedForwarder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "treasuryToken",
          "type": "address"
        }
      ],
      "name": "launch",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "dungeonId",
          "type": "uint64"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "launchForNewHero",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "dungeonId",
          "type": "uint64"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxAvailableBiome",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "maxBiomeCompleted",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "minLevelForTreasury",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "dungId",
          "type": "uint64"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "objectAction",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC721Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "dungId",
          "type": "uint64"
        }
      ],
      "name": "openObject",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "previousImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "reborn",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "dungLogicId",
          "type": "uint16"
        },
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "components": [
            {
              "internalType": "uint8[][]",
              "name": "objTypesByStages",
              "type": "uint8[][]"
            },
            {
              "internalType": "uint32[][]",
              "name": "objChancesByStages",
              "type": "uint32[][]"
            },
            {
              "internalType": "uint32[]",
              "name": "uniqObjects",
              "type": "uint32[]"
            },
            {
              "internalType": "uint8",
              "name": "minLevel",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "maxLevel",
              "type": "uint8"
            },
            {
              "internalType": "bytes32[]",
              "name": "requiredCustomDataIndex",
              "type": "bytes32[]"
            },
            {
              "internalType": "uint64[]",
              "name": "requiredCustomDataMinValue",
              "type": "uint64[]"
            },
            {
              "internalType": "uint64[]",
              "name": "requiredCustomDataMaxValue",
              "type": "uint64[]"
            },
            {
              "internalType": "bool[]",
              "name": "requiredCustomDataIsHero",
              "type": "bool[]"
            }
          ],
          "internalType": "struct IDungeonFactory.DungeonGenerateInfo",
          "name": "genInfo",
          "type": "tuple"
        },
        {
          "internalType": "uint8",
          "name": "specReqBiome",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "specReqHeroClass",
          "type": "uint8"
        },
        {
          "internalType": "bool",
          "name": "isSpecific",
          "type": "bool"
        }
      ],
      "name": "registerDungeonLogic",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "dungLogicId",
          "type": "uint16"
        },
        {
          "internalType": "uint8",
          "name": "specReqBiome",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "specReqHeroClass",
          "type": "uint8"
        }
      ],
      "name": "removeDungeonLogic",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "revision",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "heroBiome",
          "type": "uint8"
        }
      ],
      "name": "setBossCompleted",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroLevel",
          "type": "uint256"
        }
      ],
      "name": "setMinLevelForTreasury",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "skillSlotsForDurabilityReduction",
      "outputs": [
        {
          "internalType": "uint8[]",
          "name": "result",
          "type": "uint8[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x36f30da8b13c5ea1573c8316394752a6e2be0126a01e7c9cd2efc4890dc22d16",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0xA7af921BDC98205DE59f3Fa2da560eE7707Fb179",
    "transactionIndex": 0,
    "gasUsed": "4909745",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000020080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000400000000000000000000000000000000000000",
    "blockHash": "0x0005173100000bfa8ca20cf1d17ef072cd4830f97357c92ad5e3cf1c2dd84f8d",
    "transactionHash": "0x36f30da8b13c5ea1573c8316394752a6e2be0126a01e7c9cd2efc4890dc22d16",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 105001637,
        "transactionHash": "0x36f30da8b13c5ea1573c8316394752a6e2be0126a01e7c9cd2efc4890dc22d16",
        "address": "0xA7af921BDC98205DE59f3Fa2da560eE7707Fb179",
        "topics": [
          "0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 0,
        "blockHash": "0x0005173100000bfa8ca20cf1d17ef072cd4830f97357c92ad5e3cf1c2dd84f8d"
      }
    ],
    "blockNumber": 105001637,
    "cumulativeGasUsed": "4909745",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 58,
  "solcInputHash": "1a4342b5d9fe8c3b83a893539aac6eae",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"dungNum\",\"type\":\"uint16\"}],\"name\":\"DungeonAlreadySpecific\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"dungNum\",\"type\":\"uint16\"}],\"name\":\"DungeonAlreadySpecific2\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorDungeonCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorDungeonIsFreeAlready\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"ErrorHeroIsDead\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"}],\"name\":\"ErrorHeroIsNotRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorHeroLevelStartFrom1\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorHeroNotInDungeon\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"biome\",\"type\":\"uint256\"}],\"name\":\"ErrorIncorrectBiome\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroLevel\",\"type\":\"uint256\"}],\"name\":\"ErrorLevelTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"heroBiome\",\"type\":\"uint8\"}],\"name\":\"ErrorNoDungeonsForBiome\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorNoEligibleDungeons\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorNotChances\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ErrorNotDeployer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorNotObject1\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ErrorNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorNotReady\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorNotStages\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorOnlyEoa\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroLevel\",\"type\":\"uint256\"}],\"name\":\"ErrorWrongLevel\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"ErrorWrongMultiplier\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stage\",\"type\":\"uint256\"}],\"name\":\"ErrorWrongStage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"OutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TooHighValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"TooLowX\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongSpecificDungeon\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dungId\",\"type\":\"uint64\"}],\"name\":\"Clear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"ContractInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"dungLogicId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint8[][]\",\"name\":\"objTypesByStages\",\"type\":\"uint8[][]\"},{\"internalType\":\"uint32[][]\",\"name\":\"objChancesByStages\",\"type\":\"uint32[][]\"},{\"internalType\":\"uint32[]\",\"name\":\"uniqObjects\",\"type\":\"uint32[]\"},{\"internalType\":\"uint8\",\"name\":\"minLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxLevel\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"requiredCustomDataIndex\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"requiredCustomDataMinValue\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64[]\",\"name\":\"requiredCustomDataMaxValue\",\"type\":\"uint64[]\"},{\"internalType\":\"bool[]\",\"name\":\"requiredCustomDataIsHero\",\"type\":\"bool[]\"}],\"indexed\":false,\"internalType\":\"struct IDungeonFactory.DungeonGenerateInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"name\":\"DungeonLogicRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"dungLogicId\",\"type\":\"uint16\"}],\"name\":\"DungeonLogicRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"dungLogicId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"biome\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroCls\",\"type\":\"uint256\"}],\"name\":\"DungeonSpecificLogicRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"dungLogicId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroLvl\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroCls\",\"type\":\"uint256\"}],\"name\":\"DungeonSpecificLogicRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dungeonId\",\"type\":\"uint64\"}],\"name\":\"FreeDungeonAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"MinLevelForTreasuryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dungId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"objId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentStage\",\"type\":\"uint256\"}],\"name\":\"ObjectOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"RevisionIncreased\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTROLLABLE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"currentDungeon\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"dungLogicNum\",\"type\":\"uint16\"}],\"name\":\"dungeonAttributes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"stages\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint32[]\",\"name\":\"uniqObjects\",\"type\":\"uint32[]\"},{\"internalType\":\"bytes32\",\"name\":\"minMaxLevel\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"requiredCustomDataIndex\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"requiredCustomDataValue\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"objTypesByStages\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint32[][]\",\"name\":\"objChancesByStages\",\"type\":\"uint32[][]\"}],\"internalType\":\"struct IDungeonFactory.ObjectGenerateInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"internalType\":\"struct IDungeonFactory.DungeonAttributes\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dungeonCounter\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dungeonId\",\"type\":\"uint64\"}],\"name\":\"dungeonNgLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dungeonId\",\"type\":\"uint64\"}],\"name\":\"dungeonStatus\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"dungNum\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isCompleted\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"currentObject\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"currentObjIndex\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"treasuryTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"treasuryTokensAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"treasuryItems\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"stages\",\"type\":\"uint8\"},{\"internalType\":\"uint32[]\",\"name\":\"uniqObjects\",\"type\":\"uint32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAvailableBiome_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"treasuryBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"heroLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"dungeonBiome\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxOpenedNgLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"heroNgLevel\",\"type\":\"uint8\"}],\"name\":\"dungeonTreasuryReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dungId\",\"type\":\"uint64\"}],\"name\":\"emergencyExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dungId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"heroToken_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId_\",\"type\":\"uint256\"}],\"name\":\"enter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dungId\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"claim\",\"type\":\"bool\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"}],\"name\":\"exitForcibly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"biome\",\"type\":\"uint256\"}],\"name\":\"freeDungeonsByLevel\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"biome\",\"type\":\"uint256\"}],\"name\":\"freeDungeonsByLevelLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IController\",\"name\":\"controller_\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"heroLevel\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"random\",\"type\":\"uint256\"}],\"name\":\"getDungeonLogic\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"biome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"heroNgLevel\",\"type\":\"uint256\"}],\"name\":\"getDungeonTreasuryAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountForDungeon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"increaseRevision\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"isBiomeBoss\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"dungeonLogic\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"heroLevel\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"isDungeonEligibleForHero\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"treasuryToken\",\"type\":\"address\"}],\"name\":\"launch\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dungeonId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"launchForNewHero\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dungeonId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAvailableBiome\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"maxBiomeCompleted\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"minLevelForTreasury\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dungId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"objectAction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dungId\",\"type\":\"uint64\"}],\"name\":\"openObject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"reborn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"dungLogicId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint8[][]\",\"name\":\"objTypesByStages\",\"type\":\"uint8[][]\"},{\"internalType\":\"uint32[][]\",\"name\":\"objChancesByStages\",\"type\":\"uint32[][]\"},{\"internalType\":\"uint32[]\",\"name\":\"uniqObjects\",\"type\":\"uint32[]\"},{\"internalType\":\"uint8\",\"name\":\"minLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxLevel\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"requiredCustomDataIndex\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"requiredCustomDataMinValue\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64[]\",\"name\":\"requiredCustomDataMaxValue\",\"type\":\"uint64[]\"},{\"internalType\":\"bool[]\",\"name\":\"requiredCustomDataIsHero\",\"type\":\"bool[]\"}],\"internalType\":\"struct IDungeonFactory.DungeonGenerateInfo\",\"name\":\"genInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"specReqBiome\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"specReqHeroClass\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSpecific\",\"type\":\"bool\"}],\"name\":\"registerDungeonLogic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"dungLogicId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"specReqBiome\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"specReqHeroClass\",\"type\":\"uint8\"}],\"name\":\"removeDungeonLogic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"heroBiome\",\"type\":\"uint8\"}],\"name\":\"setBossCompleted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroLevel\",\"type\":\"uint256\"}],\"name\":\"setMinLevelForTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"skillSlotsForDurabilityReduction\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"result\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidInitialization()\":[{\"details\":\"The contract is already initialized.\"}],\"NotInitializing()\":[{\"details\":\"The contract is not initializing.\"}]},\"events\":{\"Initialized(uint64)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"}},\"kind\":\"dev\",\"methods\":{\"created()\":{\"returns\":{\"_0\":\"Creation timestamp\"}},\"createdBlock()\":{\"returns\":{\"_0\":\"Creation block number\"}},\"emergencyExit(uint64)\":{\"details\":\"Governance can drop hero from dungeon in emergency case\"},\"exitForcibly(address,uint256,address)\":{\"details\":\"Implement logic of special consumable that allows a hero to exit current dungeon using the shelter\"},\"increaseRevision(address)\":{\"details\":\"Revision should be increased on each contract upgrade\"},\"isBiomeBoss(address,uint256)\":{\"details\":\"Easily get info should given hero fight with boss in the current biome or not.\"},\"isController(address)\":{\"details\":\"Return true if given address is controller\"},\"onERC721Received(address,address,uint256,bytes)\":{\"details\":\"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`.\"},\"previousImplementation()\":{\"details\":\"Previous logic implementation\"},\"registerDungeonLogic(uint16,uint8,(uint8[][],uint32[][],uint32[],uint8,uint8,bytes32[],uint64[],uint64[],bool[]),uint8,uint8,bool)\":{\"params\":{\"biome\":\"Assume biome > 0\",\"isSpecific\":\"The dungeon is specific, so it shouldn't be registered in dungeonsLogicByBiome\",\"specReqBiome\":\"required biome\",\"specReqHeroClass\":\"required hero class\"}},\"revision()\":{\"details\":\"Contract upgrade counter\"},\"setMinLevelForTreasury(address,uint256)\":{\"details\":\"Set eligible hero level for treasury tokens\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"CONTROLLABLE_VERSION()\":{\"notice\":\"Version of the contract\"},\"VERSION()\":{\"notice\":\"Version of the contract\"},\"controller()\":{\"notice\":\"Return controller address saved in the contract slot\"},\"created()\":{\"notice\":\"Return creation timestamp\"},\"createdBlock()\":{\"notice\":\"Return creation block number\"},\"exitForcibly(address,uint256,address)\":{\"notice\":\"Hero exists current dungeon forcibly same as when dying but without loosing life chance\"},\"isGovernance(address)\":{\"notice\":\"Return true if given address is setup as governance in Controller\"},\"registerDungeonLogic(uint16,uint8,(uint8[][],uint32[][],uint32[],uint8,uint8,bytes32[],uint64[],uint64[],bool[]),uint8,uint8,bool)\":{\"notice\":\"Register ordinal or specific dungeon\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/DungeonFactory.sol\":\"DungeonFactory\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":50},\"remappings\":[]},\"sources\":{\"contracts/core/DungeonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n/**\\n            \\u2592\\u2593\\u2592  \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2593\\n             \\u2592\\u2588\\u2588\\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593  \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n              \\u2592\\u2588\\u2588\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592 \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n               \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592                   \\u2592\\u2588\\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                     \\u2592\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592     \\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                   \\u2592\\u2592\\u2592\\u2592\\u2592   \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                         \\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                       \\u2592\\u2588\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\n                        \\u2592\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592       \\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\n                          \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593   \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                           \\u2592\\u2592\\u2593\\u2593\\u2592   \\u2592\\u2588\\u2588\\u2593\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                  \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                                 \\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                                \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n      \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593                  \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                      \\u2592\\u2593\\u2593\\n    \\u2592\\u2593\\u2588\\u2592   \\u2592\\u2592\\u2588\\u2592\\u2592                   \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2592\\u2593\\u2593\\u2592\\n   \\u2592\\u2592\\u2588\\u2592       \\u2593\\u2592                    \\u2592\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2588\\u2593\\u2592\\n   \\u2593\\u2592\\u2588\\u2588\\u2593\\u2592                             \\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2592\\n    \\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2593\\u2592        \\u2592\\u2592\\u2592         \\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592\\u2592\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2592 \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n     \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2592\\u2592\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2593\\u2593     \\u2593\\u2593  \\u2593\\u2593\\u2588\\u2593   \\u2592\\u2592\\u2593\\u2593   \\u2592\\u2592\\u2588\\u2592   \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n            \\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592  \\u2592\\u2593\\u2593\\u2593\\u2592\\u2588\\u2592   \\u2592\\u2592\\u2592\\u2588\\u2592          \\u2592\\u2592\\u2588\\u2593\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592   \\u2593\\u2588\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\n \\u2592            \\u2592\\u2593\\u2593\\u2588\\u2593  \\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2593  \\u2592\\u2588\\u2593\\u2593\\u2592          \\u2593\\u2593\\u2588\\u2593\\u2592\\u2593\\u2588\\u2593\\u2592\\u2592   \\u2593\\u2588\\u2593        \\u2593\\u2588\\u2588\\u2588\\u2593\\n\\u2593\\u2593\\u2592         \\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592\\u2592\\u2593\\u2588\\u2592   \\u2592\\u2593\\u2588\\u2588\\u2593  \\u2593\\u2588\\u2588\\u2593\\u2592     \\u2592\\u2588\\u2593 \\u2593\\u2593\\u2588\\u2588   \\u2592\\u2593\\u2593\\u2593\\u2592\\u2592\\u2593\\u2588\\u2593        \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2592\\n \\u2588\\u2588\\u2593\\u2593\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592\\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592     \\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592\\n*/\\npragma solidity 0.8.23;\\n\\nimport \\\"../proxy/Controllable.sol\\\";\\nimport \\\"../lib/DungeonFactoryLib.sol\\\";\\nimport \\\"../relay/ERC2771Context.sol\\\";\\nimport \\\"../openzeppelin/ERC721Holder.sol\\\";\\n\\ncontract DungeonFactory is Controllable, IDungeonFactory, ERC2771Context, ERC721Holder {\\n  //region ------------------------ CONSTANTS\\n\\n  /// @notice Version of the contract\\n  string public constant override VERSION = \\\"2.1.1\\\";\\n  //endregion ------------------------ CONSTANTS\\n\\n  //region ------------------------ INITIALIZER\\n  function init(address controller_) external initializer {\\n    __Controllable_init(controller_);\\n  }\\n  //endregion ------------------------ INITIALIZER\\n\\n  //region ------------------------ VIEWS\\n  function dungeonAttributes(uint16 dungLogicNum) external view returns (DungeonAttributes memory) {\\n    return DungeonFactoryLib.dungeonAttributes(dungLogicNum);\\n  }\\n\\n  function dungeonStatus(uint64 dungeonId) external view returns (\\n    uint16 dungNum,\\n    bool isCompleted,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint32 currentObject,\\n    uint8 currentObjIndex,\\n    address[] memory treasuryTokens,\\n    uint[] memory treasuryTokensAmounts,\\n    bytes32[] memory treasuryItems,\\n    uint8 stages,\\n    uint32[] memory uniqObjects\\n  ) {\\n    return DungeonFactoryLib.dungeonStatus(dungeonId);\\n  }\\n\\n  function dungeonCounter() external view returns (uint64) {\\n    return DungeonFactoryLib.dungeonCounter();\\n  }\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view override returns (uint8) {\\n    return DungeonFactoryLib.maxBiomeCompleted(heroToken, heroTokenId);\\n  }\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) external view override returns (uint64) {\\n    return DungeonFactoryLib.currentDungeon(heroToken, heroTokenId);\\n  }\\n\\n  function minLevelForTreasury(address token) external view returns (uint) {\\n    return DungeonFactoryLib.minLevelForTreasury(token);\\n  }\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external override view returns (uint8[] memory result) {\\n    return DungeonFactoryLib.skillSlotsForDurabilityReduction(heroToken, heroTokenId);\\n  }\\n\\n  function freeDungeonsByLevelLength(uint biome) external view returns (uint) {\\n    return DungeonFactoryLib.freeDungeonsByLevelLength(biome);\\n  }\\n\\n  function freeDungeonsByLevel(uint id, uint biome) external view returns (uint64) {\\n    return DungeonFactoryLib.freeDungeonsByLevel(id, biome);\\n  }\\n\\n  function dungeonTreasuryReward(\\n    address token,\\n    uint maxAvailableBiome_,\\n    uint treasuryBalance,\\n    uint8 heroLevel,\\n    uint8 dungeonBiome,\\n    uint8 maxOpenedNgLevel,\\n    uint8 heroNgLevel\\n  ) external view returns (uint) {\\n    return DungeonLib.dungeonTreasuryReward(token, maxAvailableBiome_, treasuryBalance, heroLevel, dungeonBiome, maxOpenedNgLevel, heroNgLevel);\\n  }\\n\\n  function getDungeonTreasuryAmount(address token, uint heroLevel, uint biome, uint heroNgLevel) external view returns (\\n    uint totalAmount,\\n    uint amountForDungeon,\\n    uint mintAmount\\n  ) {\\n    return DungeonFactoryLib.getDungeonTreasuryAmount(IController(controller()), token, heroLevel, biome, heroNgLevel);\\n  }\\n\\n  function getDungeonLogic(IController controller_, uint8 heroLevel, address heroToken, uint heroTokenId, uint random)\\n  external view returns (uint16) {\\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller_);\\n    return DungeonLib.getDungeonLogic(DungeonLib._S(), cc, heroLevel, heroToken, heroTokenId, random);\\n  }\\n\\n  function isDungeonEligibleForHero(uint16 dungeonLogic, uint8 heroLevel, address heroToken, uint heroTokenId)\\n  external view returns (bool) {\\n    return DungeonLib.isDungeonEligibleForHero(\\n      DungeonLib._S(),\\n      IStatController(IController(controller()).statController()),\\n      dungeonLogic,\\n      heroLevel,\\n      heroToken,\\n      heroTokenId\\n    );\\n  }\\n\\n  /// @dev Easily get info should given hero fight with boss in the current biome or not.\\n  function isBiomeBoss(address heroToken, uint heroTokenId) external view returns (bool) {\\n    return DungeonFactoryLib.isBiomeBoss(IController(controller()), heroToken, heroTokenId);\\n  }\\n\\n  function maxAvailableBiome() external view returns (uint8) {\\n    return DungeonFactoryLib.maxAvailableBiome();\\n  }\\n\\n  function dungeonNgLevel(uint64 dungeonId) external view returns (uint) {\\n    return DungeonFactoryLib.dungeonNgLevel(dungeonId);\\n  }\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ ACTIONS\\n\\n  function launch(address heroToken, uint heroTokenId, address treasuryToken) external returns (uint64 dungeonId) {\\n    return DungeonFactoryLib.launch(_isNotSmartContract(), IController(controller()), _msgSender(), heroToken, heroTokenId, treasuryToken);\\n  }\\n\\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external override returns (uint64 dungeonId) {\\n    return DungeonFactoryLib.launchForNewHero(IController(controller()), owner, heroToken, heroTokenId);\\n  }\\n\\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external override {\\n    DungeonFactoryLib.setBossCompleted(IController(controller()), objectId, heroToken, heroTokenId, heroBiome);\\n  }\\n  //endregion ------------------------ ACTIONS\\n\\n  //////////////////////////////////////////////////////////////////////////////////////\\n  //           DUNGEON LOGIC\\n  //////////////////////////////////////////////////////////////////////////////////////\\n\\n  //region ------------------------ GOV ACTIONS\\n\\n  /// @notice Register ordinal or specific dungeon\\n  /// @param biome Assume biome > 0\\n  /// @param isSpecific The dungeon is specific, so it shouldn't be registered in dungeonsLogicByBiome\\n  /// @param specReqBiome required biome\\n  /// @param specReqHeroClass required hero class\\n  function registerDungeonLogic(\\n    uint16 dungLogicId,\\n    uint8 biome,\\n    DungeonGenerateInfo memory genInfo,\\n    uint8 specReqBiome,\\n    uint8 specReqHeroClass,\\n    bool isSpecific\\n  ) external {\\n    DungeonFactoryLib.registerDungeonLogic(\\n      IController(controller()),\\n      dungLogicId,\\n      biome,\\n      genInfo,\\n      specReqBiome,\\n      specReqHeroClass,\\n      isSpecific\\n    );\\n  }\\n\\n  function removeDungeonLogic(uint16 dungLogicId, uint8 specReqBiome, uint8 specReqHeroClass) external {\\n    DungeonFactoryLib.removeDungeonLogic(IController(controller()), dungLogicId, specReqBiome, specReqHeroClass);\\n  }\\n\\n  /// @dev Set eligible hero level for treasury tokens\\n  function setMinLevelForTreasury(address token, uint heroLevel) external {\\n    DungeonFactoryLib.setMinLevelForTreasury(IController(controller()), token, heroLevel);\\n  }\\n\\n  /// @dev Governance can drop hero from dungeon in emergency case\\n  function emergencyExit(uint64 dungId) external {\\n    DungeonFactoryLib.emergencyExit(IController(controller()), dungId);\\n  }\\n  //endregion ------------------------ GOV ACTIONS\\n\\n  //region ------------------------ USER ACTIONS\\n  function enter(uint64 dungId, address heroToken_, uint heroTokenId_) external {\\n    DungeonFactoryLib.enter(_isNotSmartContract(), IController(controller()), _msgSender(), dungId, heroToken_, heroTokenId_);\\n  }\\n\\n  function openObject(uint64 dungId) external {\\n    DungeonFactoryLib.openObject(_isNotSmartContract(), IController(controller()), _msgSender(), dungId);\\n  }\\n\\n  function objectAction(uint64 dungId, bytes memory data) external {\\n    DungeonFactoryLib.objectAction(_isNotSmartContract(), IController(controller()), _msgSender(), dungId, data);\\n  }\\n\\n  function exit(uint64 dungId, bool claim) external {\\n    DungeonFactoryLib.exit(_isNotSmartContract(), IController(controller()), _msgSender(), dungId, claim);\\n  }\\n  //endregion ------------------------ USER ACTIONS\\n\\n  //region ------------------------ Contracts actions\\n\\n  /// @notice Hero exists current dungeon forcibly same as when dying but without loosing life chance\\n  /// @dev Implement logic of special consumable that allows a hero to exit current dungeon using the shelter\\n  function exitForcibly(address heroToken, uint heroTokenId, address msgSender) override external {\\n    DungeonFactoryLib.exitForcibly(IController(controller()), heroToken, heroTokenId, msgSender);\\n  }\\n\\n  function reborn(address heroToken, uint heroTokenId) external override {\\n    DungeonFactoryLib.reborn(IController(controller()), heroToken, heroTokenId);\\n  }\\n  //endregion ------------------------ Contracts actions\\n}\\n\",\"keccak256\":\"0x058e382973b3cb0737c6024f6c374a970bd45fff2edcfc2b28309d77dc251dbd\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IAppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @notice All errors of the app\\ninterface IAppErrors {\\n\\n  //region ERC20Errors\\n  /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n  error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n  /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n  error ERC20InvalidSender(address sender);\\n\\n  /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n  error ERC20InvalidReceiver(address receiver);\\n\\n  /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n  error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n  /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n  error ERC20InvalidApprover(address approver);\\n\\n  /**\\n   * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n  error ERC20InvalidSpender(address spender);\\n\\n  //endregion ERC20Errors\\n\\n  //region ERC721Errors\\n\\n  /**\\n  * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n  error ERC721InvalidOwner(address owner);\\n\\n  /**\\n   * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n  error ERC721NonexistentToken(uint256 tokenId);\\n\\n  /**\\n   * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n  error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n  /**\\n   * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n  error ERC721InvalidSender(address sender);\\n\\n  /**\\n   * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n  error ERC721InvalidReceiver(address receiver);\\n\\n  /**\\n   * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n  error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n  /**\\n   * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n  error ERC721InvalidApprover(address approver);\\n\\n  /**\\n   * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n  error ERC721InvalidOperator(address operator);\\n\\n  //endregion ERC721Errors\\n\\n  error ZeroAddress();\\n  error ZeroValueNotAllowed();\\n  error ZeroToken();\\n  error LengthsMismatch();\\n  error NotEnoughBalance();\\n  error NotEnoughAllowance();\\n  error EmptyNameNotAllowed();\\n  error NotInitialized();\\n  error AlreadyInitialized();\\n  error ReentrancyGuardReentrantCall();\\n  error TooLongString();\\n  error AlreadyDeployed(address deployed);\\n  error AlreadyClaimed();\\n\\n  //region Restrictions\\n  error ErrorNotDeployer(address sender);\\n  error ErrorNotGoc();\\n  error NotGovernance(address sender);\\n  error ErrorOnlyEoa();\\n  error NotEOA(address sender);\\n  error ErrorForbidden(address sender);\\n  error AdminOnly();\\n  error ErrorNotItemController(address sender);\\n  error ErrorNotHeroController(address sender);\\n  error ErrorNotDungeonFactory(address sender);\\n  error ErrorNotObjectController(address sender);\\n  error ErrorNotStoryController();\\n  error ErrorNotAllowedSender();\\n  error MintNotAllowed();\\n  error NotPvpController();\\n  //endregion Restrictions\\n\\n  //region PackingLib\\n  error TooHighValue(uint value);\\n  error IntValueOutOfRange(int value);\\n  error OutOfBounds(uint index, uint length);\\n  error UnexpectedValue(uint expected, uint actual);\\n  error WrongValue(uint newValue, uint actual);\\n  error IntOutOfRange(int value);\\n  error ZeroValue();\\n  /// @notice packCustomDataChange requires an input string with two zero bytes at the beginning\\n  ///         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// This error happens if these bytes are not zero\\n  error IncompatibleInputString();\\n  error IncorrectOtherItemTypeKind(uint8 kind);\\n  //endregion PackingLib\\n\\n  //region Hero\\n  error ErrorHeroIsNotRegistered(address heroToken);\\n  error ErrorHeroIsDead(address heroToken, uint heroTokenId);\\n  error ErrorHeroNotInDungeon();\\n  error HeroInDungeon();\\n  error ErrorNotOwner(address token, uint tokenId);\\n  error Staked(address heroToken, uint heroId);\\n  error NameTaken();\\n  error TooBigName();\\n  error WrongSymbolsInTheName();\\n  error NoPayToken(address token, uint payTokenAmount);\\n  error AlreadyHaveReinforcement();\\n  /// @notice SIP-001 - Reinforcement requires 3 skills\\n  error ErrorReinforcementRequiresThreeSkills();\\n  error WrongTier(uint tier);\\n  error NotEnoughNgLevel(uint8 ngLevel);\\n  error NgpNotActive(address hero);\\n  error RebornNotAllowed();\\n  error AlreadyPrePaidHero();\\n\\n  error SandboxTierForbidden();\\n  error SandboxPrepaidOnly();\\n  error SandboxNgZeroOnly();\\n  error SandboxModeNotAllowed();\\n  error SandboxUpgradeModeRequired();\\n  error SandboxModeRequired();\\n  error SandboxItemOutside();\\n  error SandboxItemNotActive();\\n  error SandboxItemNotRegistered();\\n  error SandboxItemAlreadyEquipped();\\n  error SandboxDifferentHeroesNotAllowed();\\n  error HeroWasTransferredBetweenAccounts();\\n  //endregion Hero\\n\\n  //region Dungeon\\n  error ErrorDungeonIsFreeAlready();\\n  error ErrorNoEligibleDungeons();\\n  error ErrorDungeonBusy();\\n  error ErrorNoDungeonsForBiome(uint8 heroBiome);\\n  error ErrorDungeonCompleted();\\n  error ErrorAlreadyInDungeon();\\n  error NotEnoughTokens(uint balance, uint expectedBalance);\\n  error DungeonAlreadySpecific(uint16 dungNum);\\n  error DungeonAlreadySpecific2(uint16 dungNum);\\n  error WrongSpecificDungeon();\\n  //endregion Dungeon\\n\\n  //region Items\\n  error ErrorItemNotEligibleForTheSlot(uint itemType, uint8 itemSlot);\\n  error ErrorItemSlotBusyHand(uint8 slot);\\n  error ErrorItemSlotBusy();\\n  error ErrorItemNotInSlot();\\n  error ErrorConsumableItemIsUsed(address item);\\n  error ErrorCannotRemoveItemFromMap();\\n  error ErrorCannotRemoveDataFromMap();\\n  error EquippedItemsExist();\\n  error ItemEquipped(address item, uint itemId);\\n  error ZeroItemMetaType();\\n  error NotZeroOtherItemMetaType();\\n  error ZeroLevel();\\n  error ItemTypeChanged();\\n  error ItemMetaTypeChanged();\\n  error UnknownItem(address item);\\n  error ErrorEquipForbidden();\\n  error EquipForbiddenInDungeon();\\n  error TakeOffForbiddenInDungeon();\\n  error Consumable(address item);\\n  error NotConsumable(address item);\\n  error Broken(address item);\\n  error ZeroLife();\\n  error RequirementsToItemAttributes();\\n  error NotEquipped(address item);\\n  error ZeroDurability();\\n  error ZeroAugmentation();\\n  error TooHighAgLevel(uint8 augmentationLevel);\\n  error UseForbiddenZeroPayToken();\\n  error IncorrectMinMaxAttributeRange(int32 min, int32 max);\\n  error SameIdsNotAllowed();\\n  error ZeroFragility();\\n  error OtherTypeItemNotRepairable();\\n  error NotOther();\\n  error DoubleItemUsageForbidden(uint itemIndex, address[] items);\\n  error ItemAlreadyUsedInSlot(address item, uint8 equippedSlot);\\n  error WrongWayToRegisterItem();\\n  error UnionItemNotFound(address item);\\n  error WrongListUnionItemTokens(address item, uint countTokens, uint requiredCountTokens);\\n  error UnknownUnionConfig(uint unionConfigId);\\n  error UserHasNoKeyPass(address user, address keyPassItem);\\n  error MaxValue(uint value);\\n  error UnexpectedOtherItem(address item);\\n  error NotExist();\\n  error ItemNotFound(address item, uint itemId);\\n  error NoFirstAugmentationInfo();\\n  error NotAugmentationProtectiveItem(address item);\\n  //endregion Items\\n\\n  //region Stages\\n  error ErrorWrongStage(uint stage);\\n  error ErrorNotStages();\\n  //endregion Stages\\n\\n  //region Level\\n  error ErrorWrongLevel(uint heroLevel);\\n  error ErrorLevelTooLow(uint heroLevel);\\n  error ErrorHeroLevelStartFrom1();\\n  error ErrorWrongLevelUpSum();\\n  error ErrorMaxLevel();\\n  //endregion Level\\n\\n  //region Treasure\\n  error ErrorNotValidTreasureToken(address treasureToken);\\n  //endregion Treasure\\n\\n  //region State\\n  error ErrorPaused();\\n  error ErrorNotReady();\\n  error ErrorNotObject1();\\n  error ErrorNotObject2();\\n  error ErrorNotCompleted();\\n  //endregion State\\n\\n  //region Biome\\n  error ErrorNotBiome();\\n  error ErrorIncorrectBiome(uint biome);\\n  error TooHighBiome(uint biome);\\n  //endregion Biome\\n\\n  //region Misc\\n  error ErrorWrongMultiplier(uint multiplier);\\n  error ErrorNotEnoughMana(uint32 mana, uint requiredMana);\\n  error ErrorExperienceMustNotDecrease();\\n  error ErrorNotEnoughExperience();\\n  error ErrorNotChances();\\n  error ErrorNotEligible(address heroToken, uint16 dungNum);\\n  error ErrorZeroKarmaNotAllowed();\\n  //endregion Misc\\n\\n  //region GOC\\n  error GenObjectIdBiomeOverflow(uint8 biome);\\n  error GenObjectIdSubTypeOverflow(uint subType);\\n  error GenObjectIdIdOverflow(uint id);\\n  error UnknownObjectTypeGoc1(uint8 objectType);\\n  error UnknownObjectTypeGoc2(uint8 objectType);\\n  error UnknownObjectTypeGocLib1(uint8 objectType);\\n  error UnknownObjectTypeGocLib2(uint8 objectType);\\n  error UnknownObjectTypeForSubtype(uint8 objectSubType);\\n  error FightDelay();\\n  error ZeroChance();\\n  error TooHighChance(uint32 chance);\\n  error TooHighRandom(uint random);\\n  error EmptyObjects();\\n  error ObjectNotFound();\\n  error WrongGetObjectTypeInput();\\n  error WrongChances(uint32 chances, uint32 maxChances);\\n  //endregion GOC\\n\\n  //region Story\\n  error PageNotRemovedError(uint pageId);\\n  error NotItem1();\\n  error NotItem2();\\n  error NotRandom(uint32 random);\\n  error NotHeroData();\\n  error NotGlobalData();\\n  error ZeroStoryIdRemoveStory();\\n  error ZeroStoryIdStoryAction();\\n  error ZeroStoryIdAction();\\n  error NotEnoughAmount(uint balance, uint requiredAmount);\\n  error NotAnswer();\\n  error AnswerStoryIdMismatch(uint16 storyId, uint16 storyIdFromAnswerHash);\\n  error AnswerPageIdMismatch(uint16 pageId, uint16 pageIdFromAnswerHash);\\n  error NotSkippableStory();\\n  error StoryNotPassed();\\n  error SkippingNotAllowed();\\n  //endregion Story\\n\\n  //region FightLib\\n  error NotMagic();\\n  error NotAType(uint atype);\\n  //endregion FightLib\\n\\n  //region MonsterLib\\n  error NotYourDebuffItem();\\n  error UnknownAttackType(uint attackType);\\n  error NotYourAttackItem();\\n  /// @notice The skill item cannot be used because it doesn't belong either to the hero or to the hero's helper\\n  error NotYourBuffItem();\\n  //endregion MonsterLib\\n\\n  //region GameToken\\n  error ApproveToZeroAddress();\\n  error MintToZeroAddress();\\n  error TransferToZeroAddress();\\n  error TransferAmountExceedsBalance(uint balance, uint value);\\n  error InsufficientAllowance();\\n  error BurnAmountExceedsBalance();\\n  error NotMinter(address sender);\\n  //endregion GameToken\\n\\n  //region NFT\\n  error TokenTransferNotAllowed();\\n  error IdOverflow(uint id);\\n  error NotExistToken(uint tokenId);\\n  error EquippedItemIsNotAllowedToTransfer(uint tokenId);\\n  //endregion NFT\\n\\n  //region CalcLib\\n  error TooLowX(uint x);\\n  //endregion CalcLib\\n\\n  //region Controller\\n  error NotFutureGovernance(address sender);\\n  //endregion Controller\\n\\n  //region Oracle\\n  error OracleWrongInput();\\n  //endregion Oracle\\n\\n  //region ReinforcementController\\n  error AlreadyStaked();\\n  error MaxFee(uint8 fee);\\n  error MinFee(uint8 fee);\\n  error StakeHeroNotStats();\\n  error NotStaked();\\n  error NoStakedHeroes();\\n  error GuildHelperNotAvailable(uint guildId, address helper, uint helperId);\\n  error PvpStaked();\\n  error HelperNotAvailableInGivenBiome();\\n  //endregion ReinforcementController\\n\\n  //region SponsoredHero\\n  error InvalidHeroClass();\\n  error ZeroAmount();\\n  error InvalidProof();\\n  error NoHeroesAvailable();\\n  error AlreadyRegistered();\\n  //endregion SponsoredHero\\n\\n  //region SacraRelay\\n  error SacraRelayNotOwner();\\n  error SacraRelayNotDelegator();\\n  error SacraRelayNotOperator();\\n  error SacraRelayInvalidChainId(uint callChainId, uint blockChainId);\\n  error SacraRelayInvalidNonce(uint callNonce, uint txNonce);\\n  error SacraRelayDeadline();\\n  error SacraRelayDelegationExpired();\\n  error SacraRelayNotAllowed();\\n  error SacraRelayInvalidSignature();\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error by selector, see tests\\n  error SacraRelayNoErrorSelector(bytes4 selector, string tracingInfo);\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error manually from {errorBytes} as following:\\n  /// if (keccak256(abi.encodeWithSignature(\\\"MyError()\\\")) == keccak256(errorBytes)) { ... }\\n  error SacraRelayUnexpectedReturnData(bytes errorBytes, string tracingInfo);\\n  error SacraRelayCallToNotContract(address notContract, string tracingInfo);\\n  //endregion SacraRelay\\n\\n  //region Misc\\n  error UnknownHeroClass(uint heroClass);\\n  error AbsDiff(int32 a, int32 b);\\n  //region Misc\\n\\n  //region ------------------------ UserController\\n  error NoAvailableLootBox(address msgSender, uint lootBoxKind);\\n  error FameHallHeroAlreadyRegistered(uint8 openedNgLevel);\\n\\n  //endregion ------------------------ UserController\\n\\n  //region ------------------------ Guilds\\n  error AlreadyGuildMember();\\n  error NotGuildMember();\\n  error WrongGuild();\\n  error GuildActionForbidden(uint right);\\n  error GuildHasMaxSize(uint guildSize);\\n  error GuildHasMaxLevel(uint level);\\n  error TooLongUrl();\\n  error TooLongDescription();\\n  error CannotRemoveGuildOwnerFromNotEmptyGuild();\\n  error GuildControllerOnly();\\n  error GuildAlreadyHasShelter();\\n  error ShelterIsBusy();\\n  error ShelterIsNotRegistered();\\n  error ShelterIsNotOwnedByTheGuild();\\n  error ShelterIsInUse();\\n  error GuildHasNoShelter();\\n  error ShelterBidIsNotAllowedToBeUsed();\\n  error ShelterHasHeroesInside();\\n  error SecondGuildAdminIsNotAllowed();\\n  error NotEnoughGuildBankBalance(uint guildId);\\n\\n  error GuildReinforcementCooldownPeriod();\\n  error NoStakedGuildHeroes();\\n  error NotStakedInGuild();\\n  error ShelterHasNotEnoughLevelForReinforcement();\\n  error NotBusyGuildHelper();\\n  error TooLowGuildLevel();\\n\\n  /// @notice Target biome can be selected only once per epoch\\n  error BiomeAlreadySelected();\\n  error NoDominationRequest();\\n  error PvpFightIsNotPrepared(uint8 biome, uint32 week, address user);\\n  error PvpFightIsCompleted(uint8 biome, uint32 week, address user);\\n  error TooLowMaxCountTurns();\\n  error UserTokensVaultAlreadySet();\\n\\n  error DifferentBiomeInPvpFight();\\n  error PvpFightOpponentNotFound();\\n  error PvpHeroHasInitializedFight();\\n  error PvpHeroNotRegistered();\\n\\n  /// @notice User should unregister pvp-hero from prev biome and only then register it in the new biome\\n  error UserHasRegisteredPvpHeroInBiome(uint8 biome);\\n  error UserHasRegisteredPvpHero();\\n  error UserNotAllowedForPvpInCurrentEpoch(uint week);\\n\\n  error UnknownPvpStrategy();\\n\\n  error GuildRequestNotActive();\\n  error GuildRequestNotAvailable();\\n  error NotAdminCannotAddMemberWithNotZeroRights();\\n  //endregion ------------------------ Guilds\\n\\n  //region ------------------------ Shelters\\n  error ErrorNotShelterController();\\n  error ErrorNotGuildController();\\n  error ShelterHasNotItem(uint shelterId, address item);\\n  error MaxNumberItemsSoldToday(uint numSoldItems, uint limit);\\n  error GuildHasNotEnoughPvpPoints(uint64 pointsAvailable, uint pointRequired);\\n  error FreeShelterItemsAreNotAllowed(uint shelterId, address item);\\n  error TooLowShelterLevel(uint8 shelterLevel, uint8 allowedShelterLevel);\\n  error NotEnoughPvpPointsCapacity(address user, uint usedPoints, uint pricePvpPoints, uint64 capactiy);\\n  error IncorrectShelterLevel(uint8 shelterLevel);\\n  //endregion ------------------------ Shelters\\n\\n  //region ------------------------ Auction\\n  error WrongAuctionPosition();\\n  error AuctionPositionClosed();\\n  error AuctionBidOpened(uint positionId);\\n  error TooLowAmountToBid();\\n  error AuctionEnded();\\n  error TooLowAmountForNewBid();\\n  error AuctionSellerOnly();\\n  error AuctionBuyerOnly();\\n  error AuctionBidNotFound();\\n  error AuctionBidClosed();\\n  error OnlyShelterAuction();\\n  error CannotCloseLastBid();\\n  error AuctionNotEnded();\\n  error NotShelterAuction();\\n  error AuctionPositionOpened(uint positionId);\\n  error AuctionSellerCannotBid();\\n  error AuctionGuildWithShelterCannotBid();\\n  error AuctionBidExists();\\n  //endregion ------------------------ Auction\\n\\n  //region ------------------------ Pawnshop\\n  error AuctionPositionNotSupported(uint positionId);\\n  error PositionNotSupported(uint positionId);\\n  error NotNftPositionNotSupported(uint positionId);\\n  error CallFailed(bytes callResultData);\\n\\n  error PawnShopZeroOwner();\\n  error PawnShopZeroFeeRecipient();\\n  error PawnShopNotOwner();\\n  error PawnShopAlreadyAnnounced();\\n  error PawnShopTimeLock();\\n  error PawnShopWrongAddressValue();\\n  error PawnShopWrongUintValue();\\n  error PawnShopZeroAddress();\\n  error PawnShopTooHighValue();\\n  error PawnShopZeroAToken();\\n  error PawnShopZeroCToken();\\n  error PawnShopWrongAmounts();\\n  error PawnShopPosFeeForInstantDealForbidden();\\n  error PawnShopPosFeeAbsurdlyHigh();\\n  error PawnShopIncorrect();\\n  error PawnShopWrongId();\\n  error PawnShopNotBorrower();\\n  error PawnShopPositionClosed();\\n  error PawnShopPositionExecuted();\\n  error PawnShopWrongBidAmount();\\n  error PawnShopTooLowBid();\\n  error PawnShopNewBidTooLow();\\n  error PawnShopBidAlreadyExists();\\n  error PawnShopAuctionEnded();\\n  error PawnShopNotLender();\\n  error PawnShopTooEarlyToClaim();\\n  error PawnShopPositionNotExecuted();\\n  error PawnShopAlreadyClaimed();\\n  error PawnShopAuctionNotEnded();\\n  error PawnShopBidClosed();\\n  error PawnShopNoBids();\\n  error PawnShopAuctionBidNotFound();\\n  error PawnShopWrongBid();\\n  error PawnShopBidNotFound();\\n\\n  //endregion ------------------------ Pawnshop\\n}\\n\\n\",\"keccak256\":\"0xffad2dad8ff8fe73014cba8a82fa888a9499e5cde9fde050e1fb34dd2c5979fc\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IApplicationEvents.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IDungeonFactory.sol\\\";\\nimport \\\"./IStoryController.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\nimport \\\"./IPvpController.sol\\\";\\n\\n/// @notice All events of the app\\ninterface IApplicationEvents {\\n\\n  //region ------------------------ Common\\n  event SetOperator(address operator, bool remove);\\n  event Salvage(address receiver, address token, uint amount);\\n  //endregion ------------------------ Common\\n\\n\\n  //region ------------------ StatController\\n  event HeroItemSlotChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint itemType,\\n    uint itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip,\\n    address caller\\n  );\\n  event CurrentStatsChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats change,\\n    bool increase,\\n    address caller\\n  );\\n  event BonusAttributesChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    bool add,\\n    bool temporally,\\n    address caller\\n  );\\n  event TemporallyAttributesCleared(address heroToken, uint heroTokenId, address caller);\\n  event NewHeroInited(address heroToken, uint heroTokenId, IStatController.ChangeableStats stats);\\n  event LevelUp(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes change\\n  );\\n  event ConsumableUsed(address heroToken, uint heroTokenId, address item);\\n  event RemoveConsumableUsage(address heroToken, uint heroTokenId, address item);\\n  event HeroCustomDataChanged(address token, uint tokenId, bytes32 index, uint value);\\n  event HeroCustomDataChangedNg(address token, uint tokenId, bytes32 index, uint value, uint8 ngLevel);\\n  event HeroCustomDataCleared(address token, uint tokenId);\\n  event GlobalCustomDataChanged(bytes32 index, uint value);\\n  //endregion ------------------ StatController\\n\\n  //region ------------------ DungeonFactoryController\\n  event DungeonLaunched(\\n    uint16 dungeonLogicNum,\\n    uint64 dungeonId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken,\\n    uint treasuryAmount\\n  );\\n\\n  event BossCompleted(uint32 objectId, uint biome, address hero, uint heroId);\\n  event FreeDungeonAdded(uint8 biome, uint64 dungeonId);\\n\\n  event ObjectOpened(uint64 dungId, address hero, uint id, uint32 objId, uint iteration, uint currentStage);\\n  event Clear(uint64 dungId);\\n\\n  event DungeonLogicRegistered(uint16 dungLogicId, IDungeonFactory.DungeonGenerateInfo info);\\n  event DungeonLogicRemoved(uint16 dungLogicId);\\n  event DungeonSpecificLogicRegistered(uint16 dungLogicId, uint biome, uint heroCls);\\n  event DungeonSpecificLogicRemoved(uint16 dungLogicId, uint heroLvl, uint heroCls);\\n  event DungeonRegistered(uint16 dungLogicId, uint64 dungeonId);\\n  event DungeonRemoved(uint16 dungLogicId, uint64 dungeonId);\\n  event MinLevelForTreasuryChanged(address token, uint level);\\n\\n  event ObjectAction(\\n    uint64 dungId,\\n    IGOC.ActionResult result,\\n    uint currentStage,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint newStage\\n  );\\n  /// @notice On add the item to the dungeon\\n  event AddTreasuryItem(uint64 dungId, address itemAdr, uint itemId);\\n  event AddTreasuryToken(uint64 dungId, address token, uint amount);\\n  event ClaimToken(uint64 dungId, address token, uint amount);\\n  event ClaimItem(uint64 dungId, address token, uint id);\\n\\n  event Entered(uint64 dungId, address hero, uint id);\\n  event DungeonCompleted(uint16 dungLogicNum, uint64 dungId, address hero, uint heroId);\\n  event Exit(uint64 dungId, bool claim);\\n  event ExitForcibly(uint64 dungId, address hero, uint heroId);\\n  event FreeDungeonRemoved(uint8 biome, uint64 dungeonId);\\n  event HeroCurrentDungeonChanged(address hero, uint heroId, uint64 dungeonId);\\n  //endregion ------------------ DungeonFactoryController\\n\\n  //region ------------------ GameObjectController\\n  event EventRegistered(uint32 objectId, IGOC.EventRegInfo eventRegInfo);\\n  event StoryRegistered(uint32 objectId, uint16 storyId);\\n  event MonsterRegistered(uint32 objectId, IGOC.MonsterGenInfo monsterGenInfo);\\n  event ObjectRemoved(uint32 objectId);\\n  event ObjectResultEvent(\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    IGOC.ObjectType objectType,\\n    address hero,\\n    uint heroId,\\n    uint8 stageId,\\n    uint iteration,\\n    bytes data,\\n    IGOC.ActionResult result,\\n    uint salt\\n  );\\n  //endregion ------------------ GameObjectController\\n\\n  //region ------------------ StoryController\\n  event SetBurnItemsMeta(uint storyId, IStoryController.AnswerBurnRandomItemMeta meta);\\n  event SetNextObjRewriteMeta(uint storyId, IStoryController.NextObjRewriteMeta meta);\\n  event SetAnswersMeta(uint storyId, uint16[] answerPageIds, uint8[] answerHeroClasses, uint16[] answerIds);\\n  event SetAnswerNextPageMeta(uint storyId, IStoryController.AnswerNextPageMeta meta);\\n  event SetAnswerAttributeRequirements(uint storyId, IStoryController.AnswerAttributeRequirementsMeta meta);\\n  event SetAnswerItemRequirements(uint storyId, IStoryController.AnswerItemRequirementsMeta meta);\\n  event SetAnswerTokenRequirementsMeta(uint storyId, IStoryController.AnswerTokenRequirementsMeta meta);\\n  event SetAnswerAttributes(uint storyId, IStoryController.AnswerAttributesMeta meta);\\n  event SetAnswerHeroCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetAnswerGlobalCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetSuccessInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetFailInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetCustomDataResult(uint storyId, IStoryController.AnswerCustomDataResultMeta meta, IStoryController.CustomDataResult _type);\\n  event StoryCustomDataRequirements(uint storyId, bytes32 requiredCustomDataIndex, uint requiredCustomDataMinValue, uint requiredCustomDataMaxValue, bool requiredCustomDataIsHero);\\n  event StoryRequiredLevel(uint storyId, uint requiredLevel);\\n  event StoryFinalized(uint32 objectId, uint storyId);\\n  event StoryRemoved(uint32 objectId, uint storyId);\\n\\n  event ItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  /// @notice Durability of the item was reduced to 0\\n  event ItemBroken(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n\\n  event NotEquippedItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event StoryChangeAttributes(\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    uint stageId,\\n    uint iteration,\\n    int32[] attributes\\n  );\\n  //endregion ------------------ StoryController\\n\\n  //region ------------------------ HeroController\\n  event HeroRegistered(address hero, uint8 heroClass, address payToken, uint payAmount);\\n  /// @notice Deprecated, replaced by {HeroCreatedNgpSandbox}. Don't remove - it's required by subgraph\\n  event HeroCreatedNgp(address hero, uint heroId, string name, address owner, string refCode, uint8 tier, uint8 ngLevel);\\n  event HeroCreatedNgpSandbox(address hero, uint heroId, string name, address owner, string refCode, uint8 tier, uint8 ngLevel, bool sandbox);\\n  event BiomeChanged(address hero, uint heroId, uint8 biome);\\n  event LevelUp(address hero, uint heroId, address owner, IStatController.CoreAttributes change);\\n  event ReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event GuildReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event OtherItemGuildReinforcement(address item, uint itemId, address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event ReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event GuildReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event Killed(address hero, uint heroId, address killer, bytes32[] dropItems, uint dropTokenAmount);\\n  event Reborn(address hero, uint heroId, uint8 newNgLevel);\\n  event BossKilled(address account, address hero, uint heroId, uint8 biome, uint8 newNgLevel, bool reborn, uint rewardAmount);\\n  event TierSetup(uint8 tier, address hero, uint72 payAmount, uint8[] slots, address[][] items);\\n  event SandboxUpgraded(address hero, uint heroId);\\n  event SandboxReturnAmountToTreasury(uint64 dungId, address token, uint amount);\\n  //endregion ------------------------ HeroController\\n\\n  //region ------------------------ FightLib\\n  event FightResultProcessed(\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    IFightCalculator.FightCall callData,\\n    uint iteration\\n  );\\n  /// @param heroA Address of the fighter A.  Address of the fighter B can be detected by fightId\\n  /// @param heroIdA ID of the figher A. ID of the fighter B can be detected by fightId\\n  event PvpFightResultProcessed(\\n    uint48 fightId,\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    uint turn,\\n    address heroA,\\n    uint heroIdA\\n  );\\n  //endregion ------------------------ FightLib\\n\\n  //region ------------------------ Oracle\\n  event Random(uint number, uint max);\\n  //endregion ------------------------ Oracle\\n\\n  //region ------------------------ Controller\\n  event OfferGovernance(address newGov);\\n  event GovernanceAccepted(address gov);\\n  event StatControllerChanged(address value);\\n  event StoryControllerChanged(address value);\\n  event GameObjectControllerChanged(address value);\\n  event ReinforcementControllerChanged(address value);\\n  event OracleChanged(address value);\\n  event TreasuryChanged(address value);\\n  event ItemControllerChanged(address value);\\n  event HeroControllerChanged(address value);\\n  event GameTokenChanged(address value);\\n  event DungeonFactoryChanged(address value);\\n  event ProxyUpdated(address proxy, address logic);\\n  event Claimed(address token, uint amount);\\n  event TokenStatusChanged(address token, bool status);\\n  event UserControllerChanged(address value);\\n  event GuildControllerChanged(address value);\\n\\n  event PvpControllerChanged(address value);\\n\\n  event GameTokenPriceChanged(uint value);\\n  event RewardsPoolChanged(address value);\\n  event ItemBoxControllerChanged(address value);\\n  event Process(address token, uint amount, address from, uint toBurn, uint toTreasury, uint toGov);\\n  //endregion ------------------------ Controller\\n\\n\\n  //region ------------------------ ReinforcementController\\n  event HeroStaked(address heroToken, uint heroId, uint biome, uint score);\\n  event HeroStakedV2(address heroToken, uint heroId, uint biome, uint rewardAmount);\\n  event HeroWithdraw(address heroToken, uint heroId);\\n  event HeroAsk(address heroToken, uint heroId);\\n  event HeroAskV2(address heroToken, uint heroId, uint hitsLast24h, uint fixedFee, uint helperRewardAmount);\\n  event TokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint totalAmount);\\n  event GuildTokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint guildId);\\n  event NftRewardRegistered(address heroToken, uint heroId, address token, uint id);\\n  event GuildNftRewardRegistered(address heroToken, uint heroId, address token, uint id, uint guildId);\\n  event ToHelperRatioChanged(uint value);\\n  event ClaimedToken(address heroToken, uint heroId, address token, uint amount, address recipient);\\n  event ClaimedItem(address heroToken, uint heroId, address item, uint itemId, address recipient);\\n  event MinLevelChanged(uint8 value);\\n  event MinLifeChancesChanged(uint value);\\n  //endregion ------------------------ ReinforcementController\\n\\n  //region ------------------------ Treasury, reward pool\\n  event AssetsSentToDungeon(address dungeon, address token, uint amount);\\n  event RewardSentToUser(address receiver, address token, uint rewardAmount);\\n  event NotEnoughReward(address receiver, address token, uint rewardAmountToPay);\\n  event BaseAmountChanged(uint oldValue, uint newValue);\\n  //endregion ------------------------ Treasury, reward pool\\n\\n  //region ------------------------ EventLib\\n  event EventResult(uint64 dungeonId, address heroToken, uint heroTokenId, uint8 stageId, IStatController.ActionInternalInfo gen, uint iteration);\\n  //endregion ------------------------ EventLib\\n\\n  //region ------------------------ Item controller and helper contracts\\n  event ItemRegistered(address item, IItemController.RegisterItemParams info);\\n  event OtherItemRegistered(address item, IItemController.ItemMeta meta, bytes packedItemMetaData);\\n  event ItemRemoved(address item);\\n  event OtherItemRemoved(address item);\\n  event NewItemMinted(address item, uint itemId, IItemController.MintInfo info);\\n  event Equipped(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot);\\n  event TakenOff(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot, address destination);\\n  event ItemRepaired(address item, uint itemId, uint consumedItemId, uint16 baseDurability);\\n  event FailedToRepairItem(address item, uint itemId, uint consumedItemId, uint16 itemDurability);\\n  event Augmented(address item, uint itemId, uint consumedItemId, uint8 augLevel, IItemController.AugmentInfo info);\\n  event ResetAugmentation(address item, uint itemId, uint consumedItemId, IItemController.AugmentInfo info);\\n  event NotAugmented(address item, uint itemId, uint consumedItemId, uint8 augLevel);\\n  event ReduceDurability(address item, uint itemId, uint newDurability);\\n  event Used(address item, uint tokenId, address heroToken, uint heroTokenId);\\n  event Destroyed(address item, uint itemId);\\n  event FragilityReduced(address item, uint itemId, address consumedItem, uint consumedItemId, uint fragility);\\n  event ItemControllerHelper(address helper);\\n  event SetUnionConfig(uint configId, address[] items, uint[] count, address itemToMint);\\n  event RemoveUnionConfig(uint configId);\\n  event SetUnionKeyPass(address keyPassItem);\\n  event SetAugmentationProtectiveItem(address keyPassItem);\\n  event CombineItems(address msgSender, uint configId, address[] items, uint[][] itemIds, address mintedItem, uint mintedItemId);\\n  event RegisterSandboxItem(address hero, uint heroId, address item, uint itemId, uint tsMinting);\\n  event WithdrawItemsFromSandbox(address hero, uint heroId, address[] items, uint[] itemIds);\\n  event ItemReturnedToSandbox(address hero, uint heroId, address item, uint itemId);\\n  event RegisterSandboxUpgrade(address hero, uint heroId, uint tsUpgradng);\\n  event TransferItemToHeroFromSandbox(address hero, uint heroId, address item, uint itemId);\\n  event DestroyItemInSandbox(address item, uint itemId);\\n  event NewItemSentToSandbox(address item, uint itemId);\\n  event ExitFromDungeon(address hero, uint heroId);\\n  //endregion ------------------------ Item controller and helper contracts\\n\\n  //region ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n  event ChangePauseStatus(bool value);\\n  event MinterChanged(address value);\\n\\n  event UniqueUriChanged(uint id, string uri);\\n  event BaseUriChanged(string uri);\\n\\n  event HeroMinted(uint heroId);\\n  event HeroBurned(uint heroId);\\n  event HeroUriByStatusChanged(string uri, uint statusLvl);\\n\\n  event ItemMinted(uint tokenId);\\n  event ItemBurned(uint tokenId);\\n  event UriByRarityChanged(string uri, uint rarity);\\n  event SponsoredHeroCreated(address msgSender, address heroAddress, uint heroId, string heroName);\\n  //endregion ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n\\n  //region ------------------------ User controller\\n  event SetUserName(address user, string name);\\n  event SetUserAvatar(address user, string avatar);\\n  event LootBoxOpened(address user, uint lootBoxKind, address[] itemTokens, uint[] itemTokenIds);\\n  event LootBoxConfigChanged(uint lootBoxKind, address[] mintItems, uint32[] mintItemsChances, uint maxDropItems);\\n  event SetFeeRenaming(uint feeRenaming);\\n\\n  event ActivityCompleted(address user, bool daily, bool weekly);\\n  event RegisterPassedDungeon(address user, uint32 epochWeek, uint counterPassedDungeons);\\n  event RegisterPvp(address user, uint32 epochWeek, uint counterPvp);\\n  event FameHallHeroRegistered(address hero, uint heroId, address heroOwner, uint8 openedNgLevel);\\n  event SetMinHeroLevel(uint level);\\n  event SetGuildStakingAdapter(address adapter);\\n\\n  event AddGamePoints(address user, uint finalBalanceGamePoints);\\n  /// @param paramId See IUserController.UserControllerParam\\n  event SetUserControllerParam(uint8 paramId, uint paramValue);\\n  event UseGamePointsToSkipStory(address user, uint16 storyId, uint priceInGamePoints, uint finalBalanceGamePoints);\\n  event SetStoryPassed(address user, uint16 storyId);\\n  //endregion ------------------------ User controller\\n\\n  //region ------------------------ Guild\\n\\n  event GuildCreated(address owner, uint guildId, string name, string urlLogo);\\n  event AddToGuild(uint guildId, address newUser);\\n  event ChangeGuildRights(uint guildId, address user, uint rights);\\n  event RemoveFromGuild(uint guildId, address user);\\n  event GuildDeleted(uint guildId);\\n  event GuildLevelUp(uint guildId, uint8 newLevel);\\n  event GuildRename(uint guildId, string newName);\\n  event GuildLogoChanged(uint guildId, string newLogoUrl);\\n  event GuildDescriptionChanged(uint guildId, string newDescription);\\n  event SetGuildRelation(uint guildId1, uint guildId2, bool peace);\\n  event TransferFromGuildBank(address user, address token, uint amount, address recipient);\\n  event TransferNftFromGuildBank(address user, address[] nfts, uint[] tokenIds, address recipient);\\n  event GuildBankDeployed(uint guildId, address guildBank);\\n  event TransferOwnership(address prevOwner, address newOwner);\\n\\n  event SetToHelperRatio(uint guildId, uint8 value, address user);\\n  event TopUpGuildBank(address msgSender, uint guildId, address guildBank, uint amount);\\n\\n  event GuildRequestRegistered(address msgSender, uint guildId, string userMessage, uint depositAmount);\\n  event GuildRequestStatusChanged(address msgSender, uint guildRequestId, uint8 newStatus, address user);\\n  event SetToHelperRatio(uint guildId, address msgSender, uint8 toHelperRatio);\\n  event SetGuildRequestDepositAmount(uint guildId, address msgSender, uint amount);\\n  event SetGuildBaseFee(uint fee);\\n  event SetPvpPointsCapacity(address msgSender, uint64 capacityPvpPoints, address[] users);\\n  event SetShelterController(address shelterController);\\n  event SetShelterAuction(address shelterAuction);\\n  event PayForBidFromGuildBank(uint guildId, uint amount, uint bid);\\n  //endregion ------------------------ Guild\\n\\n  //region ------------------------ Guild shelter\\n  event RegisterShelter(uint sheleterId, uint price);\\n  event SetShelterItems(\\n    uint shelterId,\\n    address[] items,\\n    uint64[] pricesInPvpPoints,\\n    uint128[] pricesInGameTokens,\\n    uint16[] maxItemsPerDayThresholds\\n  );\\n  event RemoveShelterItems(uint shelterId, address[] items);\\n  event BuyShelter(uint guidlId, uint shelterId);\\n  event LeaveShelter(uint guildId, uint shelterId);\\n  event NewShelterBid(uint shelterId, uint buyerGuildId, uint amount);\\n  event RevokeShelterBid(uint shelterId);\\n  event UseShelterBid(uint shelterId, uint sellerGuildId, uint buyerGuidId, uint amount);\\n  event PurchaseShelterItem(address msgSender, address item, uint numSoldItems, uint priceInPvpPoints, uint priceInGameToken);\\n  event ChangeShelterOwner(uint shelterId, uint fromGuildId, uint toGuildId);\\n  event RestInShelter(address msgSender, address heroToken, uint heroTokenId);\\n  //endregion ------------------------ Guild shelter\\n\\n  //region ------------------------ Guild reinforcement\\n  event GuildHeroStaked(address heroToken, uint heroId, uint guildId);\\n  event GuildHeroWithdrawn(address heroToken, uint heroId, uint guildId);\\n  event GuildHeroAsked(address heroToken, uint heroId, uint guildId, address user);\\n\\n  /// @param user Address can be 0 if heroId was already burnt at the moment of reinforcement releasing\\n  event GuildHeroReleased(address heroToken, uint heroId, uint guildId, address user);\\n  //endregion ------------------------ Guild reinforcement\\n\\n  //region ------------------------ Pvp\\n  event AddBiomeRequest(address user, uint8 biome, uint guildId, uint32 week);\\n  event PvpHeroAdded(address user, uint guildId, address hero, uint heroId, uint week, uint8 biome);\\n  /// @param manuallyRemoved True - removed manually by the user, false - removed automatically after the fight\\n  event PvpHeroRemoved(address user, uint guildId, uint week, uint8 biome, address hero, uint heroId, bool manuallyRemoved);\\n  event PreparePvpFight(uint48 fightId, uint32 week, address hero, uint heroId, uint heroGuildId, address opponentHero, uint opponentHeroId, uint opponentGuildId);\\n\\n  /// @notice heroId can be detected by {fightId} and {heroes}\\n  event PvpFightCompleted(\\n    IPvpController.PvpFightResults fightResult,\\n    uint48 fightId,\\n    address[2] heroes,\\n    uint64[2] guilds,\\n    bool[2] winners,\\n    uint[2] prizes,\\n    bool technicalDefeat\\n  );\\n  event UpdatePvpEpoch(uint8 biome, uint32 week, uint guildBiomeOwnerId);\\n  event FirstPvpEpoch(uint8 biome, uint32 week);\\n  event BiomeTaxPaid(address msgSender, uint8 biome, uint guildId, uint amount, uint taxPercent, uint taxAmount);\\n  event BiomeTaxPaidNft(address msgSender, uint8 biome, uint guildId, address item, uint itemId, uint taxPercent);\\n  event AddPvpFightItems(uint48 fightId, address[] items, uint[] itemIds);\\n\\n  //endregion ------------------------ Pvp\\n\\n  //region ------------------------ Guild auction\\n  event AuctionPositionOpened(uint positionId, uint shelterId, uint sellerGuildId, address msgSender, uint minAuctionPrice);\\n  event AuctionPositionClosed(uint positionId, address msgSender);\\n  event AuctionBidOpened(uint bidId, uint positionId, uint amount, address msgSender);\\n  event ApplyAuctionBid(uint bidId, address msgSender);\\n  event AuctionSetFee(uint fee);\\n  //endregion ------------------------ Guild auction\\n\\n  //region ------------------------ Guild bank\\n  event GuildBankTransfer(address token, address recipient, uint amount);\\n  event GuildBankTransferNft(address to, address nft, uint tokenId);\\n  event GuildBankTransferNftMulti(address to, address[] nfts, uint[] tokenIds);\\n  //endregion ------------------------ Guild bank\\n\\n  //region ------------------------ Pawnshop\\n  event PawnShopRouterDeployed(address pawnShop, address gameToken, address routerOwner, address deployed);\\n  event PawnShopRouterTransfer(address token, uint amount, address receiver);\\n  event PawnShopRouterBulkSell(address[] nfts, uint[] nftIds, uint[] prices, address nftOwner, uint[] positionIds);\\n  event PawnShopRouterClosePositions(uint[] positionIds, address receiver);\\n  event PawnShopRouterBulkBuy(uint[] positionIds, address receiver);\\n\\n  //endregion ------------------------ Pawnshop\\n\\n  //region ------------------------ Airdrop Distributor\\n  event AirdropDistributorSetToken(address token);\\n  event AirdropDistributorAddTree(uint week, bytes32 merkleRoot_);\\n  event AirdropDistributorRemoveTree(uint week);\\n  event AirdropDistributorClaim(uint[] _weeks, uint[] amounts, address receiver);\\n\\n  //endregion ------------------------ Airdrop Distributor\\n\\n  //region ------------------------ GuildStakingManager\\n  event SetStakingToken(address token);\\n  event StakeTokens(address token, uint amount, uint guildId, uint total);\\n  //endregion ------------------------ GuildStakingManager\\n\\n}\\n\",\"keccak256\":\"0x92745e450978c77b380a0625458dda3edd8aa29d2efbadd8327e93707ff0f08b\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IControllable {\\n\\n  function VERSION() external pure returns (string memory);\\n\\n  function revision() external view returns (uint);\\n\\n  function previousImplementation() external view returns (address);\\n\\n  function isController(address contract_) external view returns (bool);\\n\\n  function isGovernance(address contract_) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0x296b634c46b5d178b2408523fcf569ed370e20a719b7b3f2183b278631b94f65\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IController {\\n\\n  function governance() external view returns (address);\\n\\n  function statController() external view returns (address);\\n\\n  function storyController() external view returns (address);\\n\\n  function gameObjectController() external view returns (address);\\n\\n  function reinforcementController() external view returns (address);\\n\\n  function oracle() external view returns (address);\\n\\n  function treasury() external view returns (address);\\n\\n  function itemController() external view returns (address);\\n\\n  function heroController() external view returns (address);\\n\\n  function dungeonFactory() external view returns (address);\\n\\n  function gameToken() external view returns (address);\\n\\n  function validTreasuryTokens(address token) external view returns (bool);\\n\\n  function isDeployer(address adr) external view returns (bool);\\n\\n  function onPause() external view returns (bool);\\n\\n  function userController() external view returns (address);\\n\\n  function guildController() external view returns (address);\\n\\n  function pvpController() external view returns (address);\\n\\n  function rewardsPool() external view returns (address);\\n\\n  function itemBoxController() external view returns (address);\\n\\n  function gameTokenPrice() external view returns (uint);\\n\\n  function process(address token, uint amount, address from) external;\\n}\\n\",\"keccak256\":\"0x47f787dc04215fffcfce23bc8ed7e777decd7eb29d60f42ffe72fd09a928c4e3\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDungeonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IDungeonFactory {\\n\\n  /// @custom:storage-location erc7201:dungeon.factory.main\\n  struct MainState {\\n    /// @dev biome => dungeonLaunchedId\\n    mapping(uint => EnumerableSet.UintSet) freeDungeons;\\n    /// @dev hero + heroId + biome (packMapObject) -> completed\\n    mapping(bytes32 => bool) bossCompleted;\\n    /// @dev hero + heroId + dungNum (packDungeonKey) -> completed\\n    mapping(bytes32 => bool) specificDungeonCompleted;\\n    /// @notice Max biome completed by the hero\\n    /// @dev hero + heroId (nftPacked) -> max biome completed\\n    mapping(bytes32 => uint8) maxBiomeCompleted;\\n    /// @notice which dungeon the hero is currently in\\n    /// @dev hero+id => current DungeonId\\n    mapping(bytes32 => uint64) heroCurrentDungeon;\\n\\n    // ---\\n\\n    /// @notice Specific dungeon for the given pair of hero level + hero class\\n    ///         ALl specific dungeons are listed also in allSpecificDungeons\\n    /// @dev packUint8Array(specReqBiome, specReqHeroClass) => dungNum\\n    mapping(bytes32 => uint16) dungeonSpecific;\\n    /// @dev contains all specific dungNum for easy management\\n    EnumerableSet.UintSet allSpecificDungeons;\\n    /// @dev biome => dungNum\\n    mapping(uint8 => EnumerableSet.UintSet) dungeonsLogicByBiome;\\n\\n    // ---\\n\\n    /// @dev max available biome. auto-increment with new dung deploy\\n    uint8 maxBiome;\\n\\n    /// @notice Address of treasure token => min hero level required\\n    /// @dev manual threshold for treasury\\n    mapping(address => uint) minLevelForTreasury;\\n\\n    /// @notice Contains arrays for SKILL_1, SKILL_2, SKILL_3 with 0 or 1\\n    /// i.e. [0, 1, 0] means that durability of SKILL_2 should be reduced\\n    /// @dev hero + heroId => uint8[] array where idx = slotNum\\n    mapping(bytes32 => bytes32) skillSlotsForDurabilityReduction;\\n\\n    /// @notice Counter of dungeons, it's incremented on launch of a new dungeon\\n    uint64 dungeonCounter;\\n\\n    /// @dev dungNum = init attributes\\n    mapping(uint16 => DungeonAttributes) dungeonAttributes;\\n    /// @dev dungeonId => status\\n    mapping(uint64 => DungeonStatus) dungeonStatuses;\\n\\n    /// @notice NG_LEVEL of the hero that has created the given dungeon\\n    mapping(uint64 dungeonId => uint ngLevel) dungeonNgLevel;\\n  }\\n\\n  struct ObjectGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    /// @dev uint8 types, packed using PackingLib.packUint8Array\\n    bytes32[] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    /// @dev uint64 chances\\n    uint32[][] objChancesByStages;\\n  }\\n\\n  struct DungeonGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    uint8[][] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    uint32[][] objChancesByStages;\\n\\n    uint32[] uniqObjects;\\n\\n    uint8 minLevel;\\n    uint8 maxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n  }\\n\\n  /// @notice Attributes of the given dungeon logic\\n  struct DungeonAttributes {\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    uint8 stages;\\n    uint8 biome;\\n\\n    /// @notice Default list of objects that should be passed in the dungeon\\n    uint32[] uniqObjects;\\n\\n    /// @dev min+max (packUint8Array)\\n    bytes32 minMaxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    /// @notice Packed DungeonGenerateInfo.requiredCustomData: MinValue, MaxValue, IsHero\\n    /// @dev min+max+isHero(packStoryCustomDataRequirements)\\n    bytes32[] requiredCustomDataValue;\\n\\n    ObjectGenerateInfo info;\\n  }\\n\\n  /// @notice Current status of the given dungeon\\n  struct DungeonStatus {\\n    uint64 dungeonId;\\n    /// @notice Dungeon logic id\\n    uint16 dungNum;\\n\\n    /// @notice True if the dungeon is completed by the hero\\n    bool isCompleted;\\n\\n    /// @notice Hero in the dungeon or 0\\n    address heroToken;\\n    uint heroTokenId;\\n    /// @notice Current object that should be passed by the hero. 0 - new object is not opened\\n    uint32 currentObject;\\n    /// @notice Current stage in the dungeon that should be passed by the hero.\\n    uint8 currentStage;\\n\\n    EnumerableMap.AddressToUintMap treasuryTokens;\\n    /// @notice All items that were minted on result of made actions\\n    bytes32[] treasuryItems;\\n\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    /// This value can be bigger than length of uniqObjects\\n    uint8 stages;\\n    /// @notice List of objects to be passed in the stage. The list can be dynamically changed during passing the stages\\n    uint32[] uniqObjects;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n\\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external returns (uint64 dungeonId);\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8);\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64);\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result);\\n\\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external;\\n\\n  /// @notice Hero exists current dungeon forcibly same as when dying but without loosing life chance\\n  function exitForcibly(address heroToken, uint heroTokenId, address msgSender) external;\\n\\n  function maxAvailableBiome() external view returns (uint8);\\n\\n  function reborn(address hero, uint heroId) external;\\n}\\n\",\"keccak256\":\"0x4e3a2e8f2fc6a0a59c3639e1548919e3a4f5b06295fcb8b4556df4f033e8ae87\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbca9de297214bb9c30daefda5ecaedd0af2c3e8e0440403ad543fb33528c5ef8\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xa365c0e17de806f6262765ef6236512674ac8563a6ee3436e81cec7b1d87468e\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  /**\\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n   */\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n   */\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of tokens in ``owner``'s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\n   *\\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n   * The approval is cleared when the token is transferred.\\n   *\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n   *\\n   * Requirements:\\n   *\\n   * - The caller must own the token or be an approved operator.\\n   * - `tokenId` must exist.\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address to, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Returns the account approved for `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  /**\\n   * @dev Approve or remove `operator` as an operator for the caller.\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n   *\\n   * Requirements:\\n   *\\n   * - The `operator` cannot be the caller.\\n   *\\n   * Emits an {ApprovalForAll} event.\\n   */\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  /**\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n   *\\n   * See {setApprovalForAll}\\n   */\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0xe7d89e4cdfc41317d90bf469428b6ef17cec6eb6fccab0080bdf0378129d2708\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n  /**\\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n   * by `operator` from `from`, this function is called.\\n   *\\n   * It must return its Solidity selector to confirm the token transfer.\\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n   *\\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n   */\\n  function onERC721Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xe5e9287463463820051374de194e01b41e1b77c1df73fab6ea0409b485edf33d\",\"license\":\"MIT\"},\"contracts/interfaces/IFightCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface IFightCalculator {\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    MELEE, // 1\\n    MAGIC, // 2\\n    SLOT_3,\\n    SLOT_4,\\n    SLOT_5,\\n    SLOT_6,\\n    SLOT_7,\\n    SLOT_8,\\n    SLOT_9,\\n    SLOT_10\\n  }\\n\\n  /// @notice Attacker info: suitable both for hero and monsters\\n  struct AttackInfo {\\n    /// @notice Type of the attack\\n    /// by default, if attack token presents, it's magic attack and not-magic otherwise\\n    /// but this logic can become more complicated after introducing new attack types\\n    AttackType attackType;\\n    /// @notice NFT selected by hero for attack, it should be equip on.\\n    /// If attacker is a monster, this is a special case (stub NFT with zero ID is used)\\n    address attackToken;\\n    uint attackTokenId;\\n    address[] skillTokens;\\n    uint[] skillTokenIds;\\n  }\\n\\n  struct FighterInfo {\\n    int32[] fighterAttributes;\\n    IStatController.ChangeableStats fighterStats;\\n    AttackType attackType;\\n    address attackToken;\\n    uint attackTokenId;\\n    uint race;\\n  }\\n\\n  struct Statuses {\\n    bool stun;\\n    bool burn;\\n    bool freeze;\\n    bool confuse;\\n    bool curse;\\n    bool poison;\\n    bool gotCriticalHit;\\n    bool missed;\\n    bool hitBlocked;\\n  }\\n\\n  struct FightResult {\\n    int32 healthA;\\n    int32 healthB;\\n    int32 manaConsumedA;\\n    int32 manaConsumedB;\\n  }\\n\\n  struct FightCall {\\n    FighterInfo fighterA;\\n    FighterInfo fighterB;\\n    uint64 dungeonId;\\n    uint32 objectId;\\n    address heroAdr;\\n    uint heroId;\\n    uint8 stageId;\\n    uint iteration;\\n    uint8 turn;\\n  }\\n\\n  /// @notice Additional info passed to fight\\n  struct FightCallAdd {\\n    address msgSender;\\n\\n    /// @notice Unique ID of the pvp-fight, 0 for not pvp fights\\n    uint48 fightId;\\n  }\\n\\n  struct SkillSlots {\\n    bool slot1;\\n    bool slot2;\\n    bool slot3;\\n  }\\n\\n  //region ------------------------ FightLib-internal (FightInfoInternal is required by IApplicationEvents..)\\n  struct FightInfoInternal {\\n    Fighter fighterA;\\n    Fighter fighterB;\\n  }\\n\\n  struct Fighter {\\n    IFightCalculator.FighterInfo info;\\n    IItemController.AttackInfo magicAttack;\\n    int32 health;\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 damagePoison;\\n    int32 damageReflect;\\n    IFightCalculator.Statuses statuses;\\n  }\\n  //endregion ------------------------ FightLib-internal\\n\\n  function fight(FightCall memory callData) external returns (FightResult memory);\\n}\\n\",\"keccak256\":\"0xc985eb5db749909d4a80ba77a85e105245d8edee11f1c9532b69dc38dcc53c38\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGOC.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\n\\ninterface IGOC {\\n\\n  enum ObjectType {\\n    UNKNOWN, // 0\\n    EVENT, // 1\\n    MONSTER, // 2\\n    STORY, // 3\\n    END_SLOT\\n  }\\n\\n  enum ObjectSubType {\\n    UNKNOWN_0, // 0\\n    ENEMY_NPC_1, // 1\\n    ENEMY_NPC_SUPER_RARE_2, // 2\\n    BOSS_3, // 3\\n    SHRINE_4, // 4\\n    CHEST_5, // 5\\n    STORY_6, // 6\\n    STORY_UNIQUE_7, // 7\\n    SHRINE_UNIQUE_8, // 8\\n    CHEST_UNIQUE_9, // 9\\n    ENEMY_NPC_UNIQUE_10, // 10\\n    STORY_ON_ROAD_11, // 11\\n    STORY_UNDERGROUND_12, // 12\\n    STORY_NIGHT_CAMP_13, // 13\\n    STORY_MOUNTAIN_14, // 14\\n    STORY_WATER_15, // 15\\n    STORY_CASTLE_16, // 16\\n    STORY_HELL_17, // 17\\n    STORY_SPACE_18, // 18\\n    STORY_WOOD_19, // 19\\n    STORY_CATACOMBS_20, // 20\\n    STORY_BAD_HOUSE_21, // 21\\n    STORY_GOOD_TOWN_22, // 22\\n    STORY_BAD_TOWN_23, // 23\\n    STORY_BANDIT_CAMP_24, // 24\\n    STORY_BEAST_LAIR_25, // 25\\n    STORY_PRISON_26, // 26\\n    STORY_SWAMP_27, // 27\\n    STORY_INSIDE_28, // 28\\n    STORY_OUTSIDE_29, // 29\\n    STORY_INSIDE_RARE_30,\\n    STORY_OUTSIDE_RARE_31,\\n    ENEMY_NPC_INSIDE_32,\\n    ENEMY_NPC_INSIDE_RARE_33,\\n    ENEMY_NPC_OUTSIDE_34,\\n    ENEMY_NPC_OUTSIDE_RARE_35,\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:game.object.controller.main\\n  struct MainState {\\n\\n    /// @dev objId = biome(00) type(00) id(0000) => biome(uint8) + objType(uint8)\\n    /// Id is id of the event, story or monster.\\n    mapping(uint32 => bytes32) objectMeta;\\n\\n    /// @dev biome(uint8) + objType(uint8) => set of object id\\n    mapping(bytes32 => EnumerableSet.UintSet) objectIds;\\n\\n    /// @dev heroAdr180 + heroId64 + cType8 + biome8 => set of already played objects. Should be cleared periodically\\n    mapping(bytes32 => EnumerableSet.UintSet) playedObjects;\\n\\n    /// @dev HeroAdr(160) + heroId(uint64) + objId(uint32) => iteration count. It needs for properly emit events for every new entrance.\\n    mapping(bytes32 => uint) iterations;\\n\\n    /// @dev objId(uint32) => EventInfo\\n    mapping(uint32 => EventInfo) eventInfos;\\n\\n    /// @dev objId(uint32) => storyId\\n    mapping(uint32 => uint16) storyIds;\\n\\n    /// @dev objId(uint32) => MonsterInfo\\n    mapping(uint32 => MonsterInfo) monsterInfos;\\n\\n    /// @dev hero+id => last fight action timestamp\\n    mapping(bytes32 => uint) lastHeroFightTs;\\n\\n    /// @dev delay for user actions in fight (suppose to prevent bot actions)\\n    uint fightDelay;\\n  }\\n\\n  struct ActionResult {\\n    bool kill;\\n    bool completed;\\n    address heroToken;\\n    address[] mintItems;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n    uint32 objectId;\\n    uint32 experience;\\n    uint heroTokenId;\\n    uint iteration;\\n    uint32[] rewriteNextObject;\\n  }\\n\\n  struct EventInfo {\\n    /// @dev chance to use good or bad attributes/stats\\n    uint32 goodChance;\\n\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] goodAttributes;\\n    bytes32[] badAttributes;\\n\\n    /// @dev experience(uint32) + heal(int32) + manaRegen(int32) + lifeChancesRecovered(int32) + damage(int32) + manaConsume(int32) packStatsChange\\n    bytes32 statsChange;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n  }\\n\\n  struct MonsterInfo {\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] attributes;\\n    /// @dev level(uint8) + race(uint8) + experience(uint32) + maxDropItems(uint8) packMonsterStats\\n    bytes32 stats;\\n    /// @dev attackToken(160) + attackTokenId(uint64) + attackType(uint8) packAttackInfo\\n    bytes32 attackInfo;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n\\n    /// @dev heroAdr(160) + heroId(uint64) => iteration => GeneratedMonster packed\\n    mapping(bytes32 => mapping(uint => bytes32)) _generatedMonsters;\\n  }\\n\\n  struct MultiplierInfo {\\n    uint8 biome;\\n    /// @notice NG_LEVEL of the hero who is going to fight with the given monster\\n    /// Use type(uint8).max for !NG+\\n    uint8 heroNgLevel;\\n  }\\n\\n  struct GeneratedMonster {\\n    bool generated;\\n    uint8 turnCounter;\\n    int32 hp;\\n    uint32 amplifier;\\n  }\\n\\n  struct MonsterGenInfo {\\n    uint16 monsterId;\\n    uint8 biome;\\n    ObjectSubType subType;\\n\\n    uint8[] attributeIds;\\n    int32[] attributeValues;\\n\\n    uint8 level;\\n    uint8 race;\\n    uint32 experience;\\n    uint8 maxDropItems;\\n\\n    address attackToken;\\n    uint64 attackTokenId;\\n    uint8 attackType;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct ActionContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    uint8 biome;\\n    uint8 objectSubType;\\n    uint8 stageId;\\n    uint8 heroNgLevel;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint heroTokenId;\\n    uint salt;\\n    uint iteration;\\n    bytes data;\\n  }\\n\\n  struct EventRegInfo {\\n    uint8 biome;\\n    uint16 eventId;\\n    ObjectSubType subType;\\n\\n    uint32 goodChance;\\n\\n    AttributeGenerateInfo goodAttributes;\\n    AttributeGenerateInfo badAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct AttributeGenerateInfo {\\n    uint8[] ids;\\n    int32[] values;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev represent object registration if non zero values\\n  function getObjectMeta(uint32 objectId) external view returns (uint8 biome, uint8 objectSubType);\\n\\n  function isBattleObject(uint32 objectId) external view returns (bool);\\n\\n  function getRandomObject(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biomeLevel,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external returns (uint32 objectId);\\n\\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint iteration);\\n\\n  function action(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) external returns (ActionResult memory);\\n\\n}\\n\",\"keccak256\":\"0x9f12869021850ca2a16a083d0f1808f112061ca2d0278e82fe77f2839330b0d3\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGameToken.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IGameToken is IERC20 {\\n\\n  function minter() external view returns (address);\\n\\n  function mint(address account, uint amount) external returns (bool);\\n\\n  function burn(uint amount) external returns (bool);\\n\\n  function setMinter(address minter_) external;\\n\\n  function pause(bool value) external;\\n\\n}\\n\",\"keccak256\":\"0x55fbc7d57c7c72905132decd85a2008a901e550d0b71cf7ac5db6b36a1c598d6\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGuildController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IGuildController {\\n  enum GuildRightBits {\\n    ADMIN_0,\\n    RENAME_1,\\n    CHANGE_LOGO_2,\\n    CHANGE_SHELTER_3,\\n    ADD_MEMBER_4,\\n    REMOVE_MEMBER_5,\\n    BANK_TOKENS_OPERATION_6,\\n    CHANGE_ROLES_7,\\n    LEVEL_UP_8,\\n    SET_RELATION_KIND_9,\\n    BANK_ITEMS_OPERATION_10,\\n    SET_GUILD_PARAMS_11,\\n    CHANGE_PURCHASING_SHELTER_ITEMS_CAPACITY_12,\\n    DOMINATION_REQUEST_13\\n  }\\n\\n  enum GuildsParams {\\n    NONE_0,\\n    COUNTER_GUILD_IDS_1,\\n    BASE_FEE_2,\\n    COUNTER_GUILD_REQUESTS_3,\\n    REENTRANT_STATUS_4,\\n    SHELTER_CONTROLLER_5,\\n    SHELTER_AUCTION_6\\n\\n    // max 255 params because enum is uint8 by default\\n  }\\n\\n  enum GuildRequestStatus {\\n    NONE_0,\\n    ACCEPTED_1,\\n    REJECTED_2,\\n    CANCELED_3\\n  }\\n\\n  /// @custom:storage-location erc7201:guild.controller.main\\n  struct MainState {\\n    /// @notice Mapping to store various guilds params (with global values for all guilds)\\n    mapping(GuildsParams param => uint value) guildsParam;\\n\\n    /// @notice guildId => address of instance of GuildBank contract\\n    mapping(uint guildId => address) guildBanks;\\n\\n    /// @notice guild id => guild data (owner, name, logo, etc)\\n    mapping(uint guildId => GuildData) guildData;\\n\\n    /// @notice name => guild id\\n    mapping(string guildName => uint guildId) nameToGuild;\\n\\n    /// @notice EOA => guild id, EOA can be a member of a single guild only\\n    mapping(address member => uint guildId) memberToGuild;\\n\\n    /// @notice List of participants of guilds\\n    /// @dev Allowed number of members is 20 + 5 * guildLevel\\n    mapping(uint guildId => EnumerableSet.AddressSet listEoa) members;\\n\\n    /// @notice Rights of the member in the guild, mask of GuildRightBits\\n    mapping(address member => uint maskRights) rights;\\n\\n    /// @notice _getGuildsPairKey(guild1, guild2) => status (false - war, true - peace)\\n    mapping(bytes32 guildsPairKey => bool) relationsPeaceful;\\n\\n    // ---------------------------- Request to join to the guild\\n    /// @notice Full list of requests registered for the guild\\n    mapping(uint guildId => mapping(GuildRequestStatus status => EnumerableSet.UintSet guildRequestIds)) guildRequests;\\n\\n    /// @notice List of active requests created by the given user.\\n    /// \\\"Active\\\" => deposit should be returned to the user.\\n    /// All not-active requests are removed from here automatically.\\n    mapping(address user => EnumerableSet.UintSet guildRequestIds) userActiveGuildRequests;\\n\\n    /// @notice Data of all guild requests ever created\\n    mapping(uint guildRequestId => GuildRequestData) guildRequestData;\\n\\n    /// @notice Deposit amount required to create a guild request\\n    mapping(uint guildId => GuildRequestDeposit) guildRequestDepositAmounts;\\n\\n    /// @notice Counter of spent pvp points + number of guild pvp-points allowed to be used by the guild member\\n    mapping(uint guildId => mapping(address member => UserPvpPoints)) userPvpPoints;\\n\\n    /// @notice guild id => guildDescription\\n    mapping(uint guildId => string) guildDescription;\\n  }\\n\\n  struct GuildData {\\n    /// @notice Not empty unique guild name\\n    string guildName;\\n\\n    /// @notice URL of guild logo (empty is allowed)\\n    string urlLogo;\\n\\n    /// @notice Creator (owner) of the guild\\n    address owner;\\n\\n    /// @notice Guild level [1...10]\\n    uint8 guildLevel;\\n\\n    /// @notice Percent of guild reinforcement fee Value in range [_FEE_MIN ... _TO_HELPER_RATIO_MAX], i.e. [10..50]\\n    uint8 toHelperRatio;\\n\\n    /// @notice Global guild points counter, it's incremented on each victory in php-fight.\\n    /// @dev Assume here, that uint64 is enough to store any sums of scores\\n    uint64 pvpCounter;\\n  }\\n\\n  struct GuildRequestData {\\n    GuildRequestStatus status;\\n    /// @notice Creator of the guild request that asks to include him to the guild\\n    address user;\\n    /// @notice Message to the guild owner from the user\\n    string userMessage;\\n    uint guildId;\\n  }\\n\\n  struct GuildRequestDeposit {\\n    bool initialized;\\n    uint192 amount;\\n  }\\n\\n  struct UserPvpPoints {\\n    /// @notice How many guild pvp-points the user is allowed to use\\n    uint64 capacityPvpPoints;\\n\\n    /// @notice How many guild pvp-points the user has used\\n    uint64 spentPvpPoints;\\n  }\\n\\n  /// ----------------------------------------------------------------------------------------------\\n\\n  function memberOf(address user) external view returns (uint guildId);\\n  function guildToShelter(uint guildId) external view returns (uint shelterId);\\n\\n  function getGuildData(uint guildId) external view returns (\\n    string memory guildName,\\n    string memory urlLogo,\\n    address owner,\\n    uint8 guildLevel,\\n    uint64 pvpCounter,\\n    uint toHelperRatio\\n  );\\n\\n  function getRights(address user) external view returns (uint);\\n  function getGuildBank(uint guildId) external view returns (address);\\n  function shelterController() external view returns (address);\\n\\n  function isPeacefulRelation(uint guildId, uint guildId2) external view returns (bool);\\n  function incPvpCounter(uint guildId, uint64 value) external;\\n\\n  function usePvpPoints(uint guildId, address user, uint64 priceInPvpPoints) external;\\n  function payFromGuildBank(uint guildId, uint shelterPrice) external;\\n  function payFromBalance(uint amount, address user) external;\\n\\n  /// @notice Ensure that the {user} has given {right}, revert otherwise\\n  function checkPermissions(address user, uint right) external view returns (uint guildId, uint rights);\\n  function shelterAuctionController() external view returns (address);\\n  function payForAuctionBid(uint guildId, uint amount, uint bid) external;\\n\\n}\\n\",\"keccak256\":\"0x9dea406907a40f6080c76838ea7967aeee64d05837da64a866d25e0e2ef59833\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IHeroController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IHeroController {\\n\\n  /// @custom:storage-location erc7201:hero.controller.main\\n  struct MainState {\\n\\n    /// @dev A central place for all hero tokens\\n    /// @dev Deprecated. Controller is used instead.\\n    address heroTokensVault;\\n\\n    /// @dev heroAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) payToken;\\n\\n    /// @dev heroAdr => heroCls8\\n    mapping(address => uint8) heroClass;\\n\\n    // ---\\n\\n    /// @dev hero+id => individual hero name\\n    mapping(bytes32 => string) heroName;\\n\\n    /// @dev name => hero+id, needs for checking uniq names\\n    mapping(string => bytes32) nameToHero;\\n\\n    // ---\\n\\n    /// @dev hero+id => biome\\n    mapping(bytes32 => uint8) heroBiome;\\n\\n    /// @notice Exist reinforcement of any kind for the given hero\\n    /// @dev hero+id => packed reinforcement helper+id\\n    mapping(bytes32 => bytes32) reinforcementHero;\\n\\n    /// @dev hero+id => reinforcement packed attributes\\n    mapping(bytes32 => bytes32[]) reinforcementHeroAttributes;\\n\\n    /// @notice packedHero (hero + id) => count of calls of beforeTokenTransfer\\n    mapping(bytes32 => uint) countHeroTransfers;\\n\\n\\n    // ------------------------------------ NG plus\\n\\n    /// @notice (tier, hero address) => TierInfo, where tier = [2, 3]\\n    /// @dev For tier=1 no data is required. Amount for tier 1 is stored in {payToken}, no items are minted\\n    /// Token from {payToken} is equal for all tiers\\n    mapping(bytes32 packedTierHero => TierInfo) tiers;\\n\\n    mapping(bytes32 packedHero => HeroInfo) heroInfo;\\n\\n    /// @notice Max NG_LVL reached by the heroes of a given account\\n    mapping(address user => uint8 maxNgLevel) maxUserNgLevel;\\n\\n    /// @notice When the hero has killed boss on the given biome first time\\n    /// packedBiomeNgLevel = packed (biome, NG_LEVEL)\\n    mapping(bytes32 packedHero => mapping (bytes32 packedBiomeNgLevel => uint timestamp)) killedBosses;\\n\\n    /// @notice Max NG_LEVEL reached by any user\\n    uint maxOpenedNgLevel;\\n\\n    /// @notice Sandbox mode for heroes, see SCR-1153\\n    mapping(bytes32 packedHero => SandboxMode sandboxMode) sandbox;\\n  }\\n\\n  /// @notice Tier = hero creation cost option\\n  /// There are 3 tiers:\\n  /// 1: most chip option, just pay fixed amount {payTokens} - new hero is created\\n  /// 2: pay bigger amount - random skill is equipped on the newly created hero\\n  /// 3: pay even more amount - random sill + some random items are equipped on the newly created hero\\n  struct TierInfo {\\n    /// @notice Cost of the hero creation using the given tier in terms of the token stored in {payToken}\\n    /// This amount is used for tiers 2, 3. For tier 1 the amount is taken from {payToken}\\n    uint amount;\\n\\n    /// @notice All slots for which items-to-mint are registered in {itemsToMint}\\n    EnumerableSet.UintSet slots;\\n\\n    /// @notice slot => items that can be minted and equipped on the hero to the given {slot} after hero creation\\n    mapping(uint8 slot => address[] items) itemsToMint;\\n  }\\n\\n  /// @notice Current NG+-related values\\n  struct HeroInfo {\\n    /// @notice Hero tier = [0..3]. 0 - the hero is post-paid, it can be changed by upgrading the hero to pre-paid\\n    uint8 tier;\\n\\n    /// @notice NG_LVL of the hero\\n    uint8 ngLevel;\\n\\n    /// @notice True if hero has passed last biome on current NG+ and so NG_LEVEL can be incremented (reborn is allowed)\\n    bool rebornAllowed;\\n\\n    /// @notice Amount paid for the hero on creation OR on upgrade to NG+\\n    /// Amount paid for creation of the hero in terms of game token (!NG+) is NOT stored here.\\n    /// @dev uint72 is used here to pack the whole struct to single slot\\n    /// Zero for sandbox-heroes\\n    uint72 paidAmount;\\n\\n    /// @notice Pay token used to pay {paidAmount}\\n    /// Zero for sandbox-heroes\\n    address paidToken;\\n  }\\n\\n  /// @notice Input data to create new hero\\n  struct HeroCreationData {\\n    /// @notice Desired NG_LVL of the hero\\n    uint8 ngLevel;\\n\\n    /// @notice Desired tire of the newly created hero. Allowed values: [1..3]\\n    uint8 tier;\\n\\n    /// @notice Enter to the dungeon after creation\\n    bool enter;\\n\\n    /// @notice Desired hero name\\n    string heroName;\\n\\n    /// @notice Optional: user account for which the hero is created\\n    address targetUserAccount;\\n\\n    /// @notice Optional: ref-code to be passed to the hero-creation-related event\\n    string refCode;\\n\\n    /// @notice SCR-1153: create not-paid hero with limited rights\\n    bool sandboxMode;\\n  }\\n\\n  enum SandboxMode {\\n    /// @notice The hero is created in normal (not sandbox) mode\\n    NORMAL_MODE_0,\\n\\n    /// @notice The hero was created in sandbox mode and wasn't upgraded.\\n    SANDBOX_MODE_1,\\n\\n    /// @notice The hero was created in sandbox mode and was upgraded to the normal mode\\n    UPGRADED_TO_NORMAL_2\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function heroClass(address hero) external view returns (uint8);\\n\\n  function heroBiome(address hero, uint heroId) external view returns (uint8);\\n\\n  function payTokenInfo(address hero) external view returns (address token, uint amount);\\n\\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (address helperHeroToken, uint helperHeroId);\\n\\n  function score(address hero, uint heroId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool);\\n\\n  function beforeTokenTransfer(address hero, uint heroId) external returns (bool);\\n\\n  // ---\\n\\n  function create(address hero, string memory heroName_, bool enter) external returns (uint);\\n\\n  function kill(address hero, uint heroId) external returns (bytes32[] memory dropItems);\\n\\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId);\\n\\n  function resetLifeAndMana(address hero, uint heroId) external;\\n\\n  function countHeroTransfers(address hero, uint heroId) external view returns (uint);\\n\\n  function askGuildReinforcement(address hero, uint heroId, address helper, uint helperId) external;\\n\\n  function getHeroInfo(address hero, uint heroId) external view returns (IHeroController.HeroInfo memory data);\\n\\n  function registerKilledBoss(address hero, uint heroId, uint32 objectId) external;\\n\\n  function maxOpenedNgLevel() external view returns (uint);\\n\\n  function sandboxMode(address hero, uint heroId) external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xd5ab48c90da3f207bade75ccf72d31c2b70b32037604608878b48ad3f7b46cb9\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemBoxController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IItemBoxController {\\n  /// @custom:storage-location erc7201:ItemBox.controller.main\\n  struct MainState {\\n    mapping(bytes32 packedHero => HeroData) heroData;\\n\\n    /// @notice Owners of all items minted in sandbox mode\\n    mapping(bytes32 packedItem => bytes32 packedHero) heroes;\\n  }\\n\\n  struct HeroData {\\n    /// @notice Moment of upgrading sandbox-hero to normal-hero\\n    uint tsUpgraded;\\n\\n    /// @notice List of all items registered for the hero\\n    EnumerableSet.AddressSet items;\\n\\n    /// @notice item => (itemId => packedItemBoxItemInfo)\\n    /// @dev Ids are never deleted from the map, so the order of ids is never changed\\n    mapping(address item => EnumerableMap.UintToUintMap) states;\\n  }\\n\\n  struct ItemBoxItemInfo {\\n    /// @notice True if the item was withdrawn from balance\\n    /// It can happens in follow cases:\\n    /// 1) the hero was upgraded and the item was withdrawn on hero owner balance\\n    /// 2) the item is used by ItemController:\\n    /// 2.1) the item is equipped on the hero and so it's transferred to the hero balance\\n    /// 2.2) the consumable item is used\\n    /// 3) the item is burnt\\n    /// @dev Status is required to avoid deletion (and so changing order) of the {items}\\n    bool withdrawn;\\n\\n    /// @notice The moment of the initial item minting\\n    uint64 timestamp;\\n  }\\n\\n  enum ItemState {\\n    /// @notice The item was never registered in the sandbox\\n    NOT_REGISTERED_0,\\n    /// @notice The item is not active (outdated) and cannot be used anymore\\n    NOT_AVAILABLE_1,\\n    /// @notice The item is active and located inside the sandbox\\n    INSIDE_2,\\n    /// @notice The item is either withdrawn or equipped\\n    OUTSIDE_3\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function firstActiveItemOfHeroByIndex(address hero, uint heroId, address item) external view returns (uint itemId);\\n  function registerItems(address hero, uint heroId, address[] memory items, uint[] memory itemIds, uint countValidItems) external;\\n  function itemState(address hero, uint heroId, address item, uint itemId) external view returns (IItemBoxController.ItemState);\\n  function itemHero(address item, uint itemId) external view returns (address hero, uint heroId);\\n  function registerSandboxUpgrade(bytes32 packedHero) external;\\n  function transferToHero(address hero, uint heroId, address item, uint itemId) external;\\n  function destroyItem(address item, uint itemId) external;\\n}\\n\",\"keccak256\":\"0xdb480923e0879904a4a5fda24ebf7caf027238c1cec2a0eb58885655e7b624e0\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IItemController {\\n\\n  enum GlobalParam {\\n    UNKNOWN_0,\\n\\n    /// @notice Address of ItemControllerHelper\\n    ITEM_CONTROLLER_HELPER_ADDRESS_1\\n  }\\n\\n  /// @custom:storage-location erc7201:item.controller.main\\n  struct MainState {\\n\\n    ////////////////// GENERATE //////////////////\\n\\n    EnumerableSet.AddressSet items;\\n\\n    /// @dev itemAdr => itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n    mapping(address => bytes32) itemMeta;\\n\\n    /// @dev itemAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) augmentInfo;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoAttributes;\\n\\n    // --- consumable ---\\n\\n    /// @dev itemAdr => ids+values (toBytes32ArrayWithIds)\\n    mapping(address => bytes32[]) _itemConsumableAttributes;\\n\\n    /// @dev itemAdr => IStatController.ChangeableStats packed int32[]\\n    mapping(address => bytes32) itemConsumableStats;\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoCasterAttributes;\\n\\n    /// @dev itemAdr => id8 + minDmg(int32) + maxDmg(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(address => bytes32) generateInfoAttack;\\n\\n    ////////////////// ITEMS INFO //////////////////\\n\\n    /// @dev itemAdr+id => itemRarity8 + augmentationLevel8 + itemDurability16\\n    mapping(bytes32 => bytes32) itemInfo;\\n\\n    /// @dev itemAdr+id => heroAdr+id\\n    mapping(bytes32 => bytes32) equippedOn;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemAttributes;\\n\\n    // --- consumable ---\\n\\n    // consumable stats unchangeable, get them by address\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemCasterAttributes;\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr+Id => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(bytes32 => bytes32) _itemAttackInfo;\\n\\n    ////////////////// Additional generate info //////////////////\\n\\n    /// @notice (itemAdr) => Bitmask of ConsumableActionBits\\n    mapping(address => uint) _consumableActionMask;\\n\\n\\n    /// --------------------------------- SIP-003: Item fragility\\n    /// @notice itemAdr + id => item fragility counter that displays the chance of an unsuccessful repair\\n    /// @dev [0...100_000], decimals 3\\n    mapping(bytes32 packedItem => uint fragility) itemFragility;\\n\\n    /// @notice Universal mapping to store various addresses and numbers (params of the contract)\\n    mapping (GlobalParam param => uint value) globalParam;\\n\\n    /// @notice Item address => packedMetadata\\n    /// {packedMetaData} is encoded using abi.encode/abi.decode\\n    /// Read first byte, detect meta data type by the byte value, apply proper decoder from PackingLib\\n    mapping(address item => bytes packedMetaData) packedItemMetaData;\\n\\n    /// --------------------------------- SCR-1263: Reverse-augmentation\\n    /// @notice Item attributes values before first augmentation.\\n    /// @dev SCR-1263: The values are required in augmentation if protective item is used and the augmentation is failed.\\n    mapping(bytes32 packedItem => ResetAugmentationData) _resetAugmentation;\\n  }\\n\\n  struct RegisterItemParams {\\n    ItemMeta itemMeta;\\n    address augmentToken;\\n    uint augmentAmount;\\n    ItemGenerateInfo commonAttributes;\\n\\n    IGOC.AttributeGenerateInfo consumableAttributes;\\n    IStatController.ChangeableStats consumableStats;\\n\\n    ItemGenerateInfo casterAttributes;\\n    ItemGenerateInfo targetAttributes;\\n\\n    AttackInfo genAttackInfo;\\n    /// @notice Bit mask of ConsumableActionBits\\n    uint consumableActionMask;\\n  }\\n\\n  /// @notice Possible actions that can be triggered by using the consumable item\\n  enum ConsumableActionBits {\\n    CLEAR_TEMPORARY_ATTRIBUTES_0\\n    // other items are used instead this mask\\n  }\\n\\n  struct ItemGenerateInfo {\\n    /// @notice Attribute ids\\n    uint8[] ids;\\n    /// @notice Min value of the attribute, != 0\\n    int32[] mins;\\n    /// @notice Max value of the attribute, != 0\\n    int32[] maxs;\\n    /// @notice Chance of the selection [0..MAX_CHANCES]\\n    uint32[] chances;\\n  }\\n\\n  struct ItemMeta {\\n    uint8 itemMetaType;\\n    // Level in range 1-99. Reducing durability in low level dungeons. lvl/5+1 = biome\\n    uint8 itemLevel;\\n    IItemController.ItemType itemType;\\n    uint16 baseDurability;\\n    uint8 defaultRarity;\\n    uint32 manaCost;\\n\\n    // it doesn't include positions with 100% chance\\n    uint8 minRandomAttributes;\\n    uint8 maxRandomAttributes;\\n\\n    IStatController.CoreAttributes requirements;\\n  }\\n\\n  // Deprecated. Todo - remove\\n  enum FeeType {\\n    UNKNOWN,\\n    REPAIR,\\n    AUGMENT,\\n    STORY,\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemRarity {\\n    UNKNOWN, // 0\\n    NORMAL, // 1\\n    MAGIC, // 2\\n    RARE, // 3\\n    SET, // 4\\n    UNIQUE, // 5\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemType {\\n    NO_SLOT, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    RING, // 6\\n    OFF_HAND, // 7\\n    BOOTS, // 8\\n    ONE_HAND, // 9\\n    TWO_HAND, // 10\\n    SKILL, // 11\\n    OTHER, // 12\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemMetaType {\\n    UNKNOWN, // 0\\n    COMMON, // 1\\n    ATTACK, // 2\\n    BUFF, // 3\\n    CONSUMABLE, // 4\\n\\n    END_SLOT\\n  }\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    FIRE, // 1\\n    COLD, // 2\\n    LIGHTNING, // 3\\n    CHAOS, // 4\\n\\n    END_SLOT\\n  }\\n\\n  struct AttackInfo {\\n    AttackType aType;\\n    int32 min;\\n    int32 max;\\n    // if not zero - activate attribute factor for the attribute\\n    IStatController.CoreAttributes attributeFactors;\\n  }\\n\\n  struct ItemInfo {\\n    ItemRarity rarity;\\n    uint8 augmentationLevel;\\n    uint16 durability;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct MintInfo {\\n    IItemController.ItemMeta meta;\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.ItemRarity itemRarity;\\n\\n    IItemController.AttackInfo attackInfo;\\n\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct AugmentInfo {\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.AttackInfo attackInfo;\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  ///region ------------------------ Item type \\\"Other\\\"\\n  /// @notice Possible kinds of \\\"Other\\\" items\\n  /// Each \\\"Other\\\" item has each own structure for metadata, see OtherItemXXX\\n  enum OtherSubtypeKind {\\n    UNKNOWN_0,\\n    /// @notice Item to reduce fragility, see SCB-1014. Metadata is {OtherItemReduceFragility}\\n    REDUCE_FRAGILITY_1,\\n\\n    /// @notice This item allows asking guild reinforcement to the guild member\\n    USE_GUILD_REINFORCEMENT_2,\\n\\n    /// @notice Exit from dungeon (shelter of level 3 is required)\\n    EXIT_FROM_DUNGEON_3,\\n\\n    /// @notice OTHER_5 Rest in the shelter: restore of hp & mp, clear temporally attributes, clear used consumables (shelter of level 3 is required)\\n    /// @dev It's OTHER_5 in deploy script, but internally it has subtype 4, see gen_others.ts\\n    REST_IN_SHELTER_4,\\n\\n    /// @notice OTHER_4 Stub item that has no logic in contracts, but it has correct (not empty) packedMetaData\\n    /// @dev It's OTHER_4 in deploy script, but internally it has subtype 5, see gen_others.ts\\n    EMPTY_NO_LOGIC_5,\\n\\n    END_SLOT\\n  }\\n  struct OtherItemReduceFragility {\\n    /// @notice \\\"Other\\\" item kind. It MUST BE first field in the struct.\\n    uint8 kind;\\n\\n    /// @notice Value on which the fragility will be reduced.\\n    /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n    uint248 value;\\n  }\\n  ///endregion ------------------------ Item type \\\"Other\\\"\\n\\n  struct AugmentOptParams {\\n    /// @notice Optional protective item\\n    /// @dev SCR-1263: If the protective item specified\\n    /// than failed augmentation doesn't destroy main item but reduces its augmentation level to the zero instead.\\n    /// Protective item is configured in ItemControllerHelper.\\n    address protectiveItem;\\n    uint protectiveItemId;\\n  }\\n\\n  struct ResetAugmentationData {\\n    /// @notice Moment of the first augmentation if any\\n    uint tsFirstAugmentation;\\n\\n    /// @notice Values of the item attributes before the first augmentation\\n    /// @dev Use PackingLib.toInt32ArrayWithIds to decode attribute ids and values\\n    bytes32[] itemAttributes;\\n\\n    /// @notice Values of the caster attributes before the first augmentation\\n    /// @dev Use PackingLib.toInt32ArrayWithIds to decode attribute ids and values\\n    bytes32[] itemCasterAttributes;\\n\\n    /// @notice Values of the target attributes before the first augmentation\\n    /// @dev Use PackingLib.toInt32ArrayWithIds to decode attribute ids and values\\n    bytes32[] itemTargetAttributes;\\n\\n    /// @notice packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    bytes32 itemAttackInfo;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function itemMeta(address item) external view returns (ItemMeta memory meta);\\n\\n  function augmentInfo(address item) external view returns (address token, uint amount);\\n\\n  function genAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genCasterAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genTargetAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genAttackInfo(address item) external view returns (AttackInfo memory info);\\n\\n  function itemInfo(address item, uint itemId) external view returns (ItemInfo memory info);\\n\\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId);\\n\\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats);\\n\\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function itemAttackInfo(address item, uint itemId) external view returns (AttackInfo memory info);\\n\\n  function score(address item, uint tokenId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address item, uint tokenId) external view returns (bool);\\n\\n  // ---\\n\\n  function mint(address item, address recipient) external returns (uint itemId);\\n\\n  function reduceDurability(address hero, uint heroId, uint8 biome, bool reduceDurabilityAllSkills) external;\\n\\n  function destroy(address item, uint tokenId) external;\\n\\n  function takeOffDirectly(\\n    address item,\\n    uint itemId,\\n    address hero,\\n    uint heroId,\\n    uint8 itemSlot,\\n    address destination,\\n    bool broken\\n  ) external;\\n\\n  /// @notice SIP-003: item fragility counter that displays the chance of an unsuccessful repair.\\n  /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n  function itemFragility(address item, uint itemId) external view returns (uint);\\n\\n  /// @notice SIP-003: The quest mechanic that previously burned the item will increase its fragility by 1%\\n  function incBrokenItemFragility(address item, uint itemId) external;\\n\\n  function equip(\\n    address hero,\\n    uint heroId,\\n    address[] calldata items,\\n    uint[] calldata itemIds,\\n    uint8[] calldata itemSlots\\n  ) external;\\n}\\n\",\"keccak256\":\"0x1f2001fd779237da65009e09352df63d1408c04cc9f86099bb7efb6eae1ebf88\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IMinter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\n\\ninterface IMinter {\\n\\n  function amountForDungeon(uint dungeonBiomeLevel, uint heroLevel) external view returns (uint);\\n\\n  function mintDungeonReward(uint64 dungeonId, uint dungeonBiomeLevel, uint heroLevel) external returns (uint amount);\\n\\n}\\n\",\"keccak256\":\"0x3b8a36fc894e406919648722291fe3b2b196791734eb9b11d4d60c37c6d92ae7\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IOracle {\\n\\n  function getRandomNumber(uint max, uint seed) external returns (uint);\\n\\n  function getRandomNumberInRange(uint min, uint max, uint seed) external returns (uint);\\n\\n}\\n\",\"keccak256\":\"0x75a2bed27cbd9be6c76b6f3e941ee5f6f55380f61cd867254a0c766fc3b71976\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IPvpController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\n\\ninterface IPvpController {\\n  enum PvpParams {\\n    NONE_0,\\n    /// @notice Hero can be pvp-staked if his level is greater of equal to the given min level\\n    MIN_HERO_LEVEL_1,\\n\\n    /// @notice Address of IGuildStakingAdapter, can be not initialized\\n    GUILD_STAKING_ADAPTER_2,\\n\\n    /// @notice Unique ID of the pvp-fight (each pvp-fight consists from multiple turns)\\n    FIGHT_COUNTER_3\\n\\n    // max 255 params because enum is uint8 by default\\n  }\\n\\n  /// @custom:storage-location erc7201:pvp.controller.main\\n  struct MainState {\\n    /// @notice Mapping to store various params of PvpController\\n    mapping(PvpParams param => uint value) pvpParam;\\n\\n    /// @notice Current states of biomes\\n    mapping(uint8 biome => BiomeData) biomeState;\\n\\n    /// @notice Biomes owned by the guilds\\n    mapping(uint guildId => uint8 biome) ownedBiome;\\n\\n    mapping(uint epochWeek => EpochData) epochData;\\n  }\\n\\n  struct EpochData {\\n    /// @notice Current state of the user in the current epoch\\n    mapping (address user => PvpUserState) pvpUserState;\\n\\n    /// @notice biome data for the given epoch\\n    mapping(uint8 biome => EpochBiomeData) epochBiomeData;\\n\\n    /// @notice All prepared pvp-fights for the given user\\n    /// Index of currently active fight is stored in {pvpUserState.activeFightIndex1}\\n    mapping (address user => PvpFightData[]) fightData;\\n\\n    /// @notice All currently registered packed-heroes\\n    EnumerableSet.UintSet stakedHeroes;\\n\\n    /// @notice Weekly request of the guild to dominate at the given biome starting from the next week\\n    mapping(uint guildId => uint8 biome) targetBiome;\\n\\n    /// @notice All guilds pretend for the given biome\\n    mapping(uint8 biome => EnumerableSet.UintSet guildIds) biomeGuilds;\\n  }\\n\\n  /// @notice Current state of the user. Possible states: user has or hasn't staked a hero in pvp.\\n  /// Each user is able to stake pvp-heroes multiple times per epoch\\n  /// but the user is able to stake only 1 pvp-hero at any moment.\\n  /// @dev Implementation assumes that the struct occupies single slot, the struct is read as a whole\\n  struct PvpUserState {\\n    /// @notice Domination biome at the moment of staking\\n    /// @dev not 0 if the user has pvp-staked hero\\n    uint8 biome;\\n\\n    /// @notice 1-based index of currently active fight in {fightData} (the fight is either prepared or in-progress).\\n    /// 0 - there is no active fight\\n    uint32 activeFightIndex1;\\n\\n    /// @notice How many times the user has staked heroes for PVP\\n    /// @dev Max possible value is limited by MAX_NUMBER_STAKES_FOR_USER_PER_EPOCH\\n    uint32 numHeroesStaked;\\n\\n    /// @notice User's guild at the moment of staking\\n    /// 0 if user has no hero staked in pvp currently\\n    uint64 guildId;\\n\\n    /// @notice Total number of pvp-fights performed since the last call of addPvpHero.\\n    /// @dev All pvp-fights are won here because looser is auto removed.\\n    uint8 countFights;\\n\\n    /// @notice Max number of pvp-fights allowed by the user per single call of addPvpHero, 0 - no limits\\n    uint8 maxFights;\\n\\n    /// @notice Unique id of the current pvp-fight (the fight with activeFightIndex1)\\n    uint48 fightId;\\n  }\\n\\n  struct BiomeData {\\n    /// @notice Biome owner - the guild that dominates in the biome at the given epoch. He has a right to get a tax\\n    /// @dev Assume here that uint64 is enough to store any guildId. It allows us to store whole struct in a single slot\\n    uint64 guildBiomeOwnerId;\\n\\n    /// @notice Current epoch (last epoch for which pvp-battle was made)\\n    /// 0 if epoch was never started\\n    uint32 startedEpochWeek;\\n\\n    /// @notice Number of consecutive epochs during which {guildBiomeOwnerId} wasn't changed\\n    uint16 dominationCounter;\\n  }\\n\\n  struct EpochBiomeData {\\n    /// @notice List of guilds asked for domination in the biome => total points scored by the guilds in the given epoch\\n    /// @dev guildId => count points\\n    EnumerableMap.UintToUintMap guildPoints;\\n\\n    /// @notice All users free for pvp-fight\\n    /// User is added here on registration and removed as soon as the fight for the user is initialized.\\n    mapping(uint guildId => EnumerableSet.AddressSet) freeUsers;\\n\\n    /// @notice All users (from the {guilds}) provided heroes for pvp\\n    /// @dev guildId => (user address => packedHero (hero + heroId))\\n    mapping(uint guildId => EnumerableMap.AddressToUintMap) registeredHeroes;\\n\\n    /// @notice The skills and attack type selected in advance\\n    mapping(bytes32 packedHero => bytes) pvpStrategy;\\n  }\\n\\n  enum PvpFightStatus {\\n    /// @notice No fight, the hero doesn't have selected opponent\\n    NOT_INITIALIZED_0,\\n\\n    /// @notice The hero has opponent, the fight is not started\\n    PREPARED_1,\\n\\n    /// @notice The fight is started but not completed\\n    FIGHTING_2,\\n\\n    /// @notice The fight is completed, the hero is the winner\\n    WINNER_3,\\n\\n    /// @notice The fight is completed, the hero is the looser\\n    LOSER_4\\n  }\\n\\n  /// @notice Current state of the fight\\n  /// @dev Implementation assumes that the struct occupies single slot, the struct is read as a whole\\n  /// @dev We don't store biome and guildId here. This info is stored in user state and can be lost after fight ending.\\n  struct PvpFightData {\\n    /// @notice address of user whose hero is the fight opponent\\n    address fightOpponent;\\n\\n    /// @notice Current status of PVP-fight\\n    PvpFightStatus fightStatus;\\n\\n    /// @notice Current value of the health (only when fightStatus is FIGHTING_2)\\n    uint32 health;\\n\\n    /// @notice Current value of the mana (only when fightStatus is FIGHTING_2)\\n    uint32 mana;\\n\\n    /// @notice Number of moves made (only when fightStatus is FIGHTING_2)\\n    uint8 countTurns;\\n  }\\n\\n  /// @dev Implementation assumes that the struct occupies single slot, the struct is read as a whole\\n  struct PvpFightResults {\\n    bool completed;\\n    uint8 totalCountFights;\\n    uint32 healthHero;\\n    uint32 healthOpponent;\\n    uint32 manaConsumedHero;\\n    uint32 manaConsumedOpponent;\\n  }\\n\\n  /// @notice Strategy how to use attack info\\n  enum PvpBehaviourStrategyKinds {\\n    /// @notice Use all skills, use magic attack if it's available\\n    /// @dev {PvpStrategyDefault} is used as data in {addPvpHero}\\n    DEFAULT_STRATEGY_0\\n\\n    // new strategies are able to use different structures to store data passed to {addPvpHero}\\n  }\\n\\n  /// @notice The data provided by user at the staking with {DEFAULT_STRATEGY_0}\\n  struct PvpStrategyDefault {\\n    /// @notice Should be equal to DEFAULT_STRATEGY_0\\n    uint behaviourStrategyKind;\\n    IFightCalculator.AttackInfo attackInfo;\\n  }\\n\\n  struct HeroData {\\n    address hero;\\n    uint heroId;\\n    bytes pvpStrategy;\\n  }\\n\\n  /// ------------------------------------------------------------------------------------------------------------------\\n  /// ------------------------------------------------------------------------------------------------------------------\\n  /// ------------------------------------------------------------------------------------------------------------------\\n\\n  /// @notice Update epoch if necessary and return actual biome owner and tax\\n  /// @return guildId Owner of the biome\\n  /// @return taxPercent Tax percent , [0...100_000], decimals 3\\n  function refreshBiomeTax(uint8 biome) external returns (uint guildId, uint taxPercent);\\n\\n  function isHeroStakedCurrently(address hero, uint heroId) external view returns (bool staked);\\n  function onGuildDeletion(uint guildId) external;\\n}\",\"keccak256\":\"0x9af8cb3a40e61bb50dbb672847272498d5e87f4eca22ff7598dbb48970321ad1\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IReinforcementController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\n/// @notice Terms\\n/// Reinforcement v1: helper is selected randomly in askHero, fixed part of rewards (tokens and NFT) is sent to the helper.\\n/// Guild reinforcement: helper is selected from guild heroes. Rewards are sent to guild bank.\\n/// Reinforcement v2: helper is selected manually in askHeroV2, helper receives fixed amount.\\ninterface IReinforcementController {\\n\\n  enum ConfigParams {\\n    /// @notice Packed MinMaxBoardV2\\n    V2_MIN_MAX_BOARD_0\\n  }\\n\\n  /// @custom:storage-location erc7201:reinforcement.controller.main\\n  struct MainState {\\n\\n    // ------------------------ Reinforcement v1\\n\\n    /// @dev minLvl8 + minLifeChances8\\n    bytes32 config;\\n    /// @dev hero token + hero id => heroInfo(biome8 + score128 + fee8 + stakeTs64)\\n    mapping(bytes32 => bytes32) _stakedHeroes;\\n    /// @dev biome => helperAdr+id\\n    mapping(uint => EnumerableSet.Bytes32Set) _internalIdsByBiomes;\\n    /// @dev biome => score  // The field is deprecated and not updated any more\\n    mapping(uint => uint) maxScore;\\n    /// @dev heroAdr+id => itemAdr+id\\n    mapping(bytes32 => bytes32[]) _heroNftRewards;\\n    /// @dev heroAdr+id => tokenAdr and amount map\\n    mapping(bytes32 => EnumerableMap.AddressToUintMap) _heroTokenRewards;\\n\\n\\n    // ------------------------ Guild reinforcement\\n\\n    /// @notice All staked guild heroes for the given guild\\n    /// @dev helper (hero token + hero id) => guild\\n    mapping(bytes32 packedHero => uint guildId) stakedGuildHeroes;\\n\\n    /// @notice All guild heroes that are currently in use by guild reinforcement\\n    /// It's allowed to withdraw a hero before reinforcement releasing,\\n    /// so it's possible to have !0 in {guildBusyHelpers} and 0 in {stakedGuildHeroes} simultaneously.\\n    /// @dev helper (hero token + hero id) => guildId (guild at the moment of askGuildReinforcement)\\n    mapping(bytes32 packedHero => uint guildId) busyGuildHelpers;\\n\\n    /// @notice All (free and busy) staked guild heroes per guild.\\n    /// guild => (packed helper => guild where the helper is busy currently)\\n    /// @dev There is a chance that guilds are different here\\n    /// i.e. hero can be:\\n    /// 1) added to G1 2) staked in G1 3) asked for help 4) withdrawn 5) G1=>G2 6) staked in G2\\n    /// In such case guildHelpers[G2][hero] = G1, guildHelpers[G1][hero] = 0\\n    /// After releasing guildHelpers[G2][hero] = 0\\n    mapping(uint guildId => EnumerableMap.Bytes32ToUintMap) guildHelpers;\\n\\n    /// @notice Moment of withdrawing the hero from staking. Next staking is possible in 1 day since withdrawing\\n    mapping(bytes32 packedHero => uint lastWithdrawTimestamp) lastGuildHeroWithdrawTs;\\n\\n\\n    // ------------------------ Reinforcement v2\\n    /// @notice Map to store various config params\\n    mapping(ConfigParams paramId => uint) configParams;\\n\\n    mapping(bytes32 packedHero => HeroInfoV2) stakedHeroesV2;\\n\\n    /// @notice biome => set of packedHero. All staked heroes (they can be busy of free currently)\\n    mapping(uint biome => EnumerableSet.Bytes32Set) heroesByBiomeV2;\\n\\n    mapping(uint biome => LastWindowsV2) stat24hV2;\\n  }\\n\\n\\n  /// @notice Deprecated. Reinforcement v1\\n  struct HeroInfo {\\n    uint8 biome;\\n    uint score; // stored in 128 but easy to use 256\\n    /// @notice To helper ratio\\n    uint8 fee;\\n    uint64 stakeTs;\\n  }\\n\\n  struct HeroInfoV2 {\\n    uint8 biome;\\n    uint64 stakeTs;\\n    /// @notice Amount of game token that is paid to the helper at the moment of the call {askHeroV2}\\n    uint128 rewardAmount;\\n  }\\n\\n  /// @notice Statistic of askHeroV2 calls per last 24 hours at the moment of the last call\\n  struct LastWindowsV2 {\\n    /// @notice 24 hours are divided on 8 intervals, each interval is 3 hour\\n    /// Current basket has index {basketIndex}\\n    /// {baskets[current basket]} contains \\\"old\\\" value.\\n    /// New value for the current basket is collected in {basketValue}.\\n    /// The value for the current basket is calculated as weighted average of old and new values.\\n    /// New value replaces the old value at the moment of changing current basket index.\\n    uint24[8] baskets;\\n    /// @notice New value (hits counter) for current basket\\n    uint24 basketValue;\\n    /// @notice Abs. index of the current basket (abs. hour / 3)\\n    uint48 basketIndex;\\n  }\\n\\n  /// @dev 1 slot\\n  struct ConfigReinforcementV2 {\\n    /// @notice if Number-of-askHeroV2-calls is below given value then burn fee has min value\\n    uint32 minNumberHits;\\n    /// @notice if Number-of-askHeroV2-calls is above given value then burn fee has max value\\n    uint32 maxNumberHits;\\n    /// @notice Lowest fee = amountForDungeon / given value, i.e. 100 => amountForDungeon/100 as lower fee\\n    uint32 lowDivider;\\n    /// @notice Highest fee = amountForDungeon / given value, i.e. 2 => amountForDungeon/2 as highest fee\\n    uint32 highDivider;\\n    /// @notice Limit for min level of the staked hero\\n    /// In practice we need following limitation: (stats.level < 5 || (stats.level - 5) / 5 < biome)\\n    /// so, levelLimit should be equal 5\\n    /// In tests we need to be able to disable such limitation, so levelLimit = 0 allow to disable that constraint\\n    uint8 levelLimit;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function toHelperRatio(address heroToken, uint heroId) external view returns (uint);\\n\\n  function isStaked(address heroToken, uint heroId) external view returns (bool);\\n\\n  function registerTokenReward(address heroToken, uint heroId, address token, uint amount) external;\\n\\n  function registerNftReward(address heroToken, uint heroId, address token, uint tokenId) external;\\n\\n  function askHeroV2(address hero, uint heroId, address helper, uint helperId) external returns (int32[] memory attributes);\\n\\n  function askGuildHero(address hero, uint heroId, address helper, uint helperId) external returns (int32[] memory attributes);\\n\\n  /// @notice Return the guild in which the hero is currently asked for guild reinforcement\\n  function busyGuildHelperOf(address heroToken, uint heroId) external view returns (uint guildId);\\n\\n  function releaseGuildHero(address helperHeroToken, uint helperHeroTokenId) external;\\n}\",\"keccak256\":\"0x9db4175e2a6415c55ef773a1abd960feba58b2973afce83691762fb679d7fd13\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IRewardsPool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IRewardsPool {\\n\\n  /// @custom:storage-location erc7201:rewards.pool.main\\n  struct MainState {\\n    mapping(address token => uint baseAmountValue) baseAmounts;\\n  }\\n\\n  function balanceOfToken(address token) external view returns (uint);\\n\\n  function rewardAmount(address token, uint maxBiome, uint maxNgLevel, uint biome, uint heroNgLevel) external view returns (uint);\\n\\n  function sendReward(address token, uint rewardAmount_, address receiver) external;\\n\\n  function lostProfitPercent(uint maxBiome, uint maxNgLevel, uint heroNgLevel) external view returns (uint percent);\\n}\\n\",\"keccak256\":\"0x1059791209fc6106767c7c2d894b38a08ef2d806eff084b07f663d25fdf18609\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStatController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IStatController {\\n\\n  /// @custom:storage-location erc7201:stat.controller.main\\n  struct MainState {\\n    mapping(bytes32 => bytes32[]) heroTotalAttributes;\\n    /// @dev heroAdr+heroId => int32 packed strength, dexterity, vitality, energy\\n    mapping(bytes32 => bytes32) _heroCore;\\n    mapping(bytes32 => bytes32[]) heroBonusAttributes;\\n    mapping(bytes32 => bytes32[]) heroTemporallyAttributes;\\n    /// @dev heroAdr+heroId => uint32 packed level, experience, life, mana, lifeChances\\n    mapping(bytes32 => bytes32) heroStats;\\n    /// @dev heroAdr+heroId+itemSlot => itemAdr + itemId\\n    mapping(bytes32 => bytes32) heroSlots;\\n    /// @dev heroAdr+heroId => busy slots uint8[] packed\\n    mapping(bytes32 => bytes32) heroBusySlots;\\n    mapping(bytes32 => EnumerableSet.AddressSet) usedConsumables;\\n    /// @dev heroCustomDataV2 is used instead\\n    mapping(bytes32 => mapping(bytes32 => uint)) _deprecated_heroCustomData;\\n    mapping(bytes32 => uint) globalCustomData;\\n\\n    /// @notice packNftIdWithValue(hero, heroId, ngLevel) => hero custom data map\\n    /// @dev initially it was packedHero => hero custom data map\\n    mapping(bytes32 => EnumerableMap.Bytes32ToUintMap) heroCustomDataV2;\\n  }\\n\\n\\n  enum ATTRIBUTES {\\n    // core\\n    STRENGTH, // 0\\n    DEXTERITY, // 1\\n    VITALITY, // 2\\n    ENERGY, // 3\\n    // attributes\\n    DAMAGE_MIN, // 4\\n    DAMAGE_MAX, // 5\\n    ATTACK_RATING, // 6\\n    DEFENSE, // 7\\n    BLOCK_RATING, // 8\\n    LIFE, // 9\\n    MANA, // 10\\n    // resistance\\n    FIRE_RESISTANCE, // 11\\n    COLD_RESISTANCE, // 12\\n    LIGHTNING_RESISTANCE, // 13\\n    // dmg against\\n    DMG_AGAINST_HUMAN, // 14\\n    DMG_AGAINST_UNDEAD, // 15\\n    DMG_AGAINST_DAEMON, // 16\\n    DMG_AGAINST_BEAST, // 17\\n\\n    // defence against\\n    DEF_AGAINST_HUMAN, // 18\\n    DEF_AGAINST_UNDEAD, // 19\\n    DEF_AGAINST_DAEMON, // 20\\n    DEF_AGAINST_BEAST, // 21\\n\\n    // --- unique, not augmentable\\n    // hero will not die until have positive chances\\n    LIFE_CHANCES, // 22\\n    // increase chance to get an item\\n    MAGIC_FIND, // 23\\n    // decrease chance to get an item\\n    DESTROY_ITEMS, // 24\\n    // percent of chance x2 dmg\\n    CRITICAL_HIT, // 25\\n    // dmg factors\\n    MELEE_DMG_FACTOR, // 26\\n    FIRE_DMG_FACTOR, // 27\\n    COLD_DMG_FACTOR, // 28\\n    LIGHTNING_DMG_FACTOR, // 29\\n    // increase attack rating on given percent\\n    AR_FACTOR, // 30\\n    // percent of damage will be converted to HP\\n    LIFE_STOLEN_PER_HIT, // 31\\n    // amount of mana restored after each battle\\n    MANA_AFTER_KILL, // 32\\n    // reduce all damage on percent after all other reductions\\n    DAMAGE_REDUCTION, // 33\\n\\n    // -- statuses\\n    // chance to stun an enemy, stunned enemy skip next hit\\n    STUN, // 34\\n    // chance burn an enemy, burned enemy will loss 50% of defence\\n    BURN, // 35\\n    // chance freeze an enemy, frozen enemy will loss 50% of MELEE damage\\n    FREEZE, // 36\\n    // chance to reduce enemy's attack rating on 50%\\n    CONFUSE, // 37\\n    // chance curse an enemy, cursed enemy will loss 50% of resistance\\n    CURSE, // 38\\n    // percent of dmg return to attacker\\n    REFLECT_DAMAGE_MELEE, // 39\\n    REFLECT_DAMAGE_MAGIC, // 40\\n    // chance to poison enemy, poisoned enemy will loss 10% of the current health\\n    POISON, // 41\\n    // reduce chance get any of uniq statuses\\n    RESIST_TO_STATUSES, // 42\\n\\n    END_SLOT // 43\\n  }\\n\\n  // possible\\n  // HEAL_FACTOR\\n\\n  struct CoreAttributes {\\n    int32 strength;\\n    int32 dexterity;\\n    int32 vitality;\\n    int32 energy;\\n  }\\n\\n  struct ChangeableStats {\\n    uint32 level;\\n    uint32 experience;\\n    uint32 life;\\n    uint32 mana;\\n    uint32 lifeChances;\\n  }\\n\\n  enum ItemSlots {\\n    UNKNOWN, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    BOOTS, // 6\\n    RIGHT_RING, // 7\\n    LEFT_RING, // 8\\n    RIGHT_HAND, // 9\\n    LEFT_HAND, // 10\\n    TWO_HAND, // 11\\n    SKILL_1, // 12\\n    SKILL_2, // 13\\n    SKILL_3, // 14\\n    END_SLOT // 15\\n  }\\n\\n  struct NftItem {\\n    address token;\\n    uint tokenId;\\n  }\\n\\n  enum Race {\\n    UNKNOWN, // 0\\n    HUMAN, // 1\\n    UNDEAD, // 2\\n    DAEMON, // 3\\n    BEAST, // 4\\n    END_SLOT // 5\\n  }\\n\\n  struct ChangeAttributesInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    int32[] changeAttributes;\\n    bool add;\\n    bool temporally;\\n  }\\n\\n  struct BuffInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    uint32 heroLevel;\\n    address[] buffTokens;\\n    uint[] buffTokenIds;\\n  }\\n\\n  /// @dev This struct is used inside event, so it's moved here from lib\\n  struct ActionInternalInfo {\\n    int32[] posAttributes;\\n    int32[] negAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintedItems;\\n  }\\n\\n  function initNewHero(address token, uint tokenId, uint heroClass) external;\\n\\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory);\\n\\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32);\\n\\n  function heroAttributesLength(address token, uint tokenId) external view returns (uint);\\n\\n  function heroBaseAttributes(address token, uint tokenId) external view returns (CoreAttributes memory);\\n\\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint);\\n\\n  function globalCustomData(bytes32 index) external view returns (uint);\\n\\n  function heroStats(address token, uint tokenId) external view returns (ChangeableStats memory);\\n\\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked);\\n\\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory);\\n\\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function levelUp(address token, uint tokenId, uint heroClass, CoreAttributes memory change) external returns (uint newLvl);\\n\\n  function changeHeroItemSlot(\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) external;\\n\\n  function changeCurrentStats(\\n    address token,\\n    uint tokenId,\\n    ChangeableStats memory change,\\n    bool increase\\n  ) external;\\n\\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external;\\n\\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external;\\n\\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external;\\n\\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external;\\n\\n  function buffHero(BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed);\\n\\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external;\\n\\n  function setGlobalCustomData(bytes32 index, uint value) external;\\n\\n  /// @notice Restore life and mana during reinforcement\\n  /// @dev Life and mana will be increased on ((current life/mana attr value) - (prev life/mana attr value))\\n  /// @param prevAttributes Hero attributes before reinforcement\\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external;\\n\\n  function reborn(address heroToken, uint heroTokenId, uint heroClass) external;\\n}\\n\",\"keccak256\":\"0x76f41b42703aa0c36784f125a2d66ca2f1f642ab23f34da31e3982a48259f802\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStoryController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../lib/ControllerContextLib.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\nimport \\\"./IHeroController.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n\\ninterface IStoryController {\\n\\n  enum AnswerResultId {\\n    UNKNOWN, // 0\\n    SUCCESS, // 1\\n    ATTRIBUTE_FAIL, // 2\\n    RANDOM_FAIL, // 3\\n    DELAY_FAIL, // 4\\n    HERO_CUSTOM_DATA_FAIL, // 5\\n    GLOBAL_CUSTOM_DATA_FAIL, // 6\\n\\n    END_SLOT\\n  }\\n\\n  enum CustomDataResult {\\n    UNKNOWN, // 0\\n    HERO_SUCCESS, // 1\\n    HERO_FAIL, // 2\\n    GLOBAL_SUCCESS, // 3\\n    GLOBAL_FAIL, // 4\\n\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:story.controller.main\\n  struct MainState {\\n\\n    // --- STORY REG INFO ---\\n\\n    /// @dev Uniq story identification.\\n    mapping(uint32 => uint16) storyIds;\\n    /// @dev Revers mapping for stories for using in the next object rewrite logic.\\n    mapping(uint16 => uint32) idToStory;\\n    /// @dev Store used ids for stories.\\n    mapping(uint16 => bool) _usedStoryIds;\\n    /// @dev Prevent register the story twice\\n    mapping(uint32 => bool) registeredStories;\\n\\n    // --- ANSWER MAPPING ---\\n\\n    /// @dev storyId => all story pages. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.UintSet) allStoryPages;\\n\\n    /// @dev storyId => all possible answers. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.Bytes32Set) allStoryAnswers;\\n\\n    /// @dev storyId + pageId + heroClass (zero is default answers) => storyId + pageId + heroClass (zero is default answers) + answerId\\n    mapping(bytes32 => bytes32[]) answers;\\n    /// @dev answerUnPackedId + answerResultId => nextPageIds (will be chosen randomly from this array)\\n    ///      where answerResultId is:\\n    ///      0 - unknown,\\n    ///      1 - success,\\n    ///      2 - attr fail\\n    ///      3 - random fail\\n    ///      4 - delay fail\\n    ///      5 - hero custom data fail\\n    ///      6 - global custom data fail\\n    ///      see COUNT_ANSWER_RESULT_IDS\\n    mapping(bytes32 => uint16[]) nextPageIds;\\n    /// @dev story + pageId + heroClass (zero is default answers) => random nextObjs (adr + id, like packed nft id)\\n    mapping(bytes32 => uint32[]) nextObjectsRewrite;\\n\\n    /// @dev answerPackedId => packed array of uint32[]\\n    ///      0 - random requirement(uint32, 1 - 99% success of this action, zero means no check)\\n    ///      1 - delay requirement(uint32, if time since the last call more than this value the check is fail, zero means no check)\\n    ///      2 - isFinalAnswer(uint8)\\n    mapping(bytes32 => bytes32) answerAttributes;\\n\\n    // --- ANSWER REQUIREMENTS ---\\n\\n    /// @dev answerPackedId => array of AttributeRequirementsPacked\\n    mapping(bytes32 => bytes32[]) attributeRequirements;\\n    /// @dev answerPackedId=> array of ItemRequirementsPacked\\n    mapping(bytes32 => bytes32[]) itemRequirements;\\n    /// @dev answerPackedId => array of TokenRequirementsPacked\\n    mapping(bytes32 => bytes32[]) tokenRequirements;\\n    /// @dev answerPackedId => custom data for hero\\n    mapping(bytes32 => CustomDataRequirementPacked[]) heroCustomDataRequirement;\\n    /// @dev answerPackedId => global custom data\\n    mapping(bytes32 => CustomDataRequirementPacked[]) globalCustomDataRequirement;\\n\\n    // --- ANSWER RESULTS ---\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) successInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) successInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) successInfoMintItems;\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) failInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) failInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) failInfoMintItems;\\n\\n    /// @dev answerUnPackedId + CustomDataResult => custom data array change\\n    ///      where CustomDataResult is\\n    ///      1 - hero success\\n    ///      2 - hero fail\\n    ///      3 - global success\\n    ///      4 - global fail\\n    ///      see COUNT_CUSTOM_DATA_RESULT_IDS\\n    mapping(bytes32 => bytes32[]) customDataResult;\\n\\n    /// @notice answerPackedId => slot+chance+stopIfBurnt\\n    /// @dev Since SIP-003 the items are not burn but broke\\n    mapping(bytes32 => bytes32[]) burnItem;\\n\\n    // --- GENERAL STORY REQUIREMENTS ---\\n\\n    /// @dev story => Custom hero data requirements for a story. If exist and hero is not eligible should be not chose in a dungeon.\\n    mapping(uint => CustomDataRequirementRangePacked[]) storyRequiredHeroData;\\n    /// @dev story => Minimal level for the history. 0 means no requirements.\\n    mapping(uint => uint) storyRequiredLevel;\\n\\n    // --- HERO STATES ---\\n\\n    /// @dev hero + heroId + storyId => pageId + heroLastActionTS\\n    mapping(bytes32 => bytes32) heroState;\\n\\n    // --- OTHER ---\\n\\n    /// @dev storyId => build hash for the last update\\n    mapping(uint16 => uint) storyBuildHash;\\n\\n    /// @notice Number of already minted items by the user within the given iteration of the story.\\n    /// Only minting of the given number of items is allowed per iteration (see MAX_MINTED_ITEMS_PER_ITERATION).\\n    /// @dev hero, heroId, story => mintedInIteration\\n    /// This map is not cleared: storyId:objectId is 1:1, each object has own sequence of iterations without duplicates\\n    mapping(bytes32 => mapping(uint iteration => uint countMintedItems)) mintedInIteration;\\n\\n    /// @notice True if the story is allowed to be skipped, see SCR-1248\\n    EnumerableSet.UintSet skippableStory;\\n  }\\n\\n  /// @dev We need to have flat structure coz Solidity can not handle arrays of structs properly\\n  struct StoryMetaInfo {\\n    uint16 storyId;\\n\\n    // --- story reqs\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n    uint minLevel;\\n\\n    // --- answer reqs\\n\\n    AnswersMeta answersMeta;\\n    AnswerNextPageMeta answerNextPage;\\n    AnswerAttributeRequirementsMeta answerAttributeRequirements;\\n    AnswerItemRequirementsMeta answerItemRequirements;\\n    AnswerTokenRequirementsMeta answerTokenRequirements;\\n    AnswerAttributesMeta answerAttributes;\\n    AnswerCustomDataMeta answerHeroCustomDataRequirement;\\n    AnswerCustomDataMeta answerGlobalCustomDataRequirement;\\n\\n    // --- answer results\\n\\n    AnswerBurnRandomItemMeta answerBurnRandomItemMeta;\\n    NextObjRewriteMeta nextObjRewriteMeta;\\n\\n    // --- story results\\n\\n    AnswerResultMeta successInfo;\\n    AnswerResultMeta failInfo;\\n\\n    AnswerCustomDataResultMeta successHeroCustomData;\\n    AnswerCustomDataResultMeta failHeroCustomData;\\n    AnswerCustomDataResultMeta successGlobalCustomData;\\n    AnswerCustomDataResultMeta failGlobalCustomData;\\n  }\\n\\n  struct NextObjRewriteMeta {\\n    uint16[] nextObjPageIds;\\n    uint8[] nextObjHeroClasses;\\n    uint32[][] nextObjIds;\\n  }\\n\\n  struct AnswersMeta {\\n    uint16[] answerPageIds;\\n    uint8[] answerHeroClasses;\\n    uint16[] answerIds;\\n  }\\n\\n  struct AnswerNextPageMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint8[] answerResultIds;\\n    uint16[][] answerNextPageIds;\\n  }\\n\\n  struct AnswerAttributeRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    bool[][] cores;\\n    uint8[][] ids;\\n    int32[][] values;\\n  }\\n\\n  struct AnswerItemRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireItems;\\n    bool[][] requireItemBurn;\\n    bool[][] requireItemEquipped;\\n  }\\n\\n  struct AnswerTokenRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireToken;\\n    uint88[][] requireAmount;\\n    bool[][] requireTransfer;\\n  }\\n\\n  struct AnswerAttributesMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint32[] randomRequirements;\\n    uint32[] delayRequirements;\\n    bool[] isFinalAnswer;\\n  }\\n\\n  struct AnswerCustomDataMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    bool[][] mandatory;\\n    uint64[][] dataValuesMin;\\n    uint64[][] dataValuesMax;\\n  }\\n\\n  struct AnswerResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    uint8[][] attributeIds;\\n    /// @dev Max value is limitied by int24, see toBytes32ArrayWithIds impl\\n    int32[][] attributeValues;\\n\\n    uint32[] experience;\\n    int32[] heal;\\n    int32[] manaRegen;\\n    int32[] lifeChancesRecovered;\\n    int32[] damage;\\n    int32[] manaConsumed;\\n\\n    address[][] mintItems;\\n    uint32[][] mintItemsChances;\\n  }\\n\\n  struct AnswerCustomDataResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    int16[][] dataValues;\\n  }\\n\\n  struct AnswerBurnRandomItemMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    /// @notice 0 - random slot\\n    uint8[][] slots;\\n    /// @notice typical chances are [0..100] (no decimals here)\\n    uint64[][] chances;\\n    /// @notice Since SIP-003 the burning is replaced by breaking bu the name is kept as is\\n    bool[][] isStopIfBurnt;\\n  }\\n\\n  struct CustomDataRequirementPacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + mandatory(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct CustomDataRequirementRangePacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + isHeroData(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct StatsChange {\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n  }\\n\\n  struct StoryActionContext {\\n    uint stageId;\\n    uint iteration;\\n    bytes32 answerIdHash;\\n    bytes32 answerAttributes;\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IOracle oracle;\\n    uint8 heroClassFromAnswerHash;\\n    uint8 biome;\\n    uint16 storyId;\\n    uint16 storyIdFromAnswerHash;\\n    uint16 pageIdFromAnswerHash;\\n    uint16 answerNumber;\\n    uint16 pageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint40 heroLastActionTS;\\n    uint80 heroTokenId;\\n    IStatController.ChangeableStats heroStats;\\n  }\\n\\n  // --- WRITE ---\\n\\n  function storyAction(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) external returns (IGOC.ActionResult memory);\\n\\n  // --- READ ---\\n\\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function idToStory(uint16 id) external view returns (uint32 objectId);\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId);\\n\\n  function storyIds(uint32 objectId) external view returns (uint16);\\n\\n  function registeredStories(uint32 objectId) external view returns (bool);\\n\\n  function skippableStory(uint16 storyId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xeac9e7fe282320b84466c974533f30b7e4c96b8ce94d40a63ef394928059bc4a\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/ITreasury.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface ITreasury {\\n\\n  function balanceOfToken(address token) external view returns (uint);\\n\\n  function sendToDungeon(address dungeon, address token, uint amount) external;\\n}\\n\",\"keccak256\":\"0x0977372e2310cd09e7b99c5f2b1af75949bf18ebcabfd0fc114e4f8714760414\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IUserController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IUserController {\\n\\n  //region ------------------------ Data types\\n\\n  enum LootBoxKind {\\n    /// @notice small loot box - reward for the daily activity\\n    DAILY_0,\\n    /// @notice large loot box - reward for the weekly activity (daily activity is passed each ot of the 7 days)\\n    WEEKLY_1,\\n\\n    END_SLOT\\n  }\\n\\n  /// @dev registerPassedDungeon assumes that the whole struct takes single slot only, not more\\n  struct UserActivity {\\n    /// @notice A day for which the daily activity is calculated (see counterXXX below)\\n    /// The number of days since 1970-01-01\\n    uint32 epochDay;\\n\\n    /// @notice A week for which total count of daily activities were calculated\\n    /// The number of weeks since (1970-01-01 Thursday) - 3 days = (1969-12-29 Monday)\\n    uint32 epochWeek;\\n\\n    /// @notice Count of dungeons passed during the day\\n    uint32 counterPassedDungeons;\\n    /// @notice Count of PvP during the day\\n    uint32 counterPvp;\\n\\n    /// @notice Count of daily activities completed per the week\\n    uint16 dailyActivities;\\n\\n    /// @notice Daily activity is completed and small loot box is added to the earned loot boxes\\n    bool dailyLootBoxReceived;\\n    /// @notice Weekly activity is completed and large loot box is added to the earned loot boxes\\n    bool weeklyLootBoxReceived;\\n  }\\n\\n  struct EarnedLootBoxes {\\n    /// @notice Count of loot boxes earned by daily activity\\n    uint32 dailyCounter;\\n    /// @notice Count of loot boxes earned by weekly activity\\n    uint32 weeklyCounter;\\n  }\\n\\n  struct LootBoxConfig {\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n    uint maxDropItems;\\n  }\\n\\n  enum UserControllerParam {\\n    /// @notice Price of story skipping in game points\\n    PRICE_STORY_SKIPPING_1\\n  }\\n\\n  /// @custom:storage-location erc7201:user.controller.main\\n  struct MainState {\\n    /// @notice Amount of sacra required to rename user account\\n    uint feeRenaming;\\n\\n    /// @dev user EOA => account name\\n    mapping(address => string) userAccountName;\\n\\n    /// @dev name => user EOA, needs for checking uniq names\\n    mapping(string => address) nameToUserAccount;\\n\\n    /// @notice user => daily activity info\\n    mapping(address => UserActivity) userActivity;\\n\\n    /// @notice user => earned loot boxes\\n    mapping(address => EarnedLootBoxes) counterLootBoxes;\\n\\n    /// @notice Configs of loot boxes of various kinds\\n    mapping(LootBoxKind => LootBoxConfig) lootBoxConfig;\\n\\n    /// @dev Deprecated, controller is used instead.\\n    address userTokensVault;\\n\\n    /// @dev user EOA => account avatar\\n    mapping(address => string) userAvatar;\\n\\n    // @notice Hall of Fame: ngLevel [1...99] => who opened the NG_LEVEL first\\n    mapping(uint8 ngLevel => FameHallData) fameHall;\\n\\n    /// @notice Points earned for passing dungeons\\n    mapping(address user => uint gamePoints) gamePoints;\\n\\n    /// @notice List of objects (currently only stories) passed by the given account\\n    /// @dev hashes of the stories are as encodePacked(\\\"STORY_{ID}\\\")\\n    mapping(address user => EnumerableSet.Bytes32Set hashes) passedObjects;\\n\\n    /// @notice Values of various params, see {UserControllerParam}\\n    mapping(UserControllerParam paramId => uint value) userControllerParams;\\n  }\\n\\n  struct FameHallData {\\n    // ------------ slot 1\\n    /// @notice The hero who opened given the NG_LEVEL first\\n    address hero;\\n    uint64 heroId;\\n    // ------------ slot 2\\n    /// @notice The owner of the hero\\n    address heroOwner;\\n    /// @notice Timestamp of the moment of the opening given NG_LEVEL\\n    uint64 tsOpen;\\n  }\\n\\n  //endregion ------------------------ Data types\\n\\n  /// @notice Register daily activity - a dungeon was passed\\n  /// @param user Owner of the hero who has passed the dungeon\\n  function registerPassedDungeon(address user) external;\\n\\n  /// @notice Register daily activity - PvP was made\\n  /// @param user Owner of the hero who has taken participation in the PvP\\n  function registerPvP(address user, bool isWinner) external;\\n\\n  function registerFameHallHero(address hero, uint heroId, uint8 openedNgLevel) external;\\n\\n  function useGamePointsToSkipStore(address user, uint16 storyId) external;\\n\\n  function setStoryPassed(address user, uint16 storyId) external;\\n\\n  function isStoryPassed(address user, uint16 storyId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa6cb408a8c73afc71c4ebee178257123ee65ed09fb96c2a806b5a83e0dac2140\",\"license\":\"BUSL-1.1\"},\"contracts/lib/AppLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @notice Common internal utils, shared constants\\nlibrary AppLib {\\n\\n  /// @notice Biome owner has the right to receive 1% tax on any income in the biome. Decimals 3.\\n  /// The final value of tax is in the range [1..10]%, it depends on total liquidity staked by the guild\\n  uint internal constant BIOME_TAX_PERCENT_MIN = 1_000; // 1%\\n\\n  /// @notice Max possible value of biome owner tax percent, decimals 3.\\n  uint internal constant BIOME_TAX_PERCENT_MAX = 10_000; // 10%\\n\\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\\n  /// @dev Should NOT be used for third-party pools\\n  function approveIfNeeded(address token, uint amount, address spender) internal {\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\n      IERC20(token).approve(spender, type(uint).max);\\n    }\\n  }\\n\\n  /// @dev Remove from array the item with given id and move the last item on it place\\n  ///      Use with mapping for keeping indexes in correct ordering\\n  function removeIndexed(\\n    uint256[] storage array,\\n    mapping(uint256 => uint256) storage indexes,\\n    uint256 id\\n  ) internal {\\n    uint256 lastId = array[array.length - 1];\\n    uint256 index = indexes[id];\\n    indexes[lastId] = index;\\n    indexes[id] = type(uint256).max;\\n    array[index] = lastId;\\n    array.pop();\\n  }\\n\\n  /// @notice Return a-b OR zero if a < b\\n  function sub0(uint32 a, uint32 b) internal pure returns (uint32) {\\n    return a > b ? a - b : 0;\\n  }\\n}\\n\",\"keccak256\":\"0x0f7680143b82bce36ebc739a16cf8f2ede8a231a9448f3e56816c0710c66cc04\",\"license\":\"BUSL-1.1\"},\"contracts/lib/CalcLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\n\\nlibrary CalcLib {\\n\\n  uint32 public constant MAX_CHANCE = 1e9;\\n\\n  function minI32(int32 a, int32 b) internal pure returns (int32) {\\n    return a < b ? a : b;\\n  }\\n\\n  function max32(int32 a, int32 b) internal pure returns (int32) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function absDiff(int32 a, int32 b) internal pure returns (uint32) {\\n    if (!((a >= 0 && b >= 0) || (a <= 0 && b <= 0))) revert IAppErrors.AbsDiff(a, b);\\n    if (a < 0) {\\n      a = - a;\\n    }\\n    if (b < 0) {\\n      b = - b;\\n    }\\n    return uint32(uint(int(a >= b ? a - b : b - a)));\\n  }\\n\\n  function toUint(int32 n) internal pure returns (uint) {\\n    if (n <= 0) {\\n      return 0;\\n    }\\n    return uint(int(n));\\n  }\\n\\n  function toInt32(uint a) internal pure returns (int32){\\n    if (a >= uint(int(type(int32).max))) {\\n      return type(int32).max;\\n    }\\n    return int32(int(a));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandom(uint maxValue) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n\\n    uint salt = genSalt();\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), salt))) % (maxValue + 1));\\n  }\\n\\n  function genSalt() internal view returns (uint salt) {\\n    // skale has a RNG Endpoint\\n    if (\\n      block.chainid == uint(1351057110)\\n      || block.chainid == uint(37084624)\\n    ) {\\n      assembly {\\n        let freemem := mload(0x40)\\n        let start_addr := add(freemem, 0)\\n        if iszero(staticcall(gas(), 0x18, 0, 0, start_addr, 32)) {\\n          invalid()\\n        }\\n        salt := mload(freemem)\\n      }\\n    }\\n  }\\n\\n  function pseudoRandomUint32(uint32 maxValue) internal view returns (uint32) {\\n    return uint32(pseudoRandom(uint(maxValue)));\\n  }\\n\\n  /// @notice Generate pseudo-random uint in the range [0..maxValue) using Solady pseudo-random function\\n  function nextPrng(LibPRNG.PRNG memory prng, uint maxValue) internal pure returns (uint) {\\n    return LibPRNG.next(prng) % maxValue;\\n  }\\n\\n  /// @notice pseudoRandomUint32 with customizable pseudoRandom()\\n  function pseudoRandomUint32Flex(\\n    uint32 maxValue,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint32) {\\n    return uint32(random_(uint(maxValue)));\\n  }\\n\\n  function pseudoRandomInt32(int32 maxValue) internal view returns (int32) {\\n    bool neg;\\n    if (maxValue < 0) {\\n      neg = true;\\n      maxValue = - maxValue;\\n    }\\n    uint32 v = uint32(pseudoRandom(uint(int(maxValue))));\\n    return neg\\n      ? - int32(int(uint(v)))\\n      : int32(int(uint(v)));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandomWithSeed(uint maxValue, uint seed) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    uint salt = genSalt();\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), seed, salt))) % (maxValue + 1));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  function pseudoRandomInRange(uint min, uint max) internal view returns (uint) {\\n    if (min >= max) {\\n      return max;\\n    }\\n    uint r = pseudoRandom(max - min);\\n    return min + r;\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  ///      Equal to pseudoRandomInRange(min, max, pseudoRandom)\\n  function pseudoRandomInRangeFlex(\\n    uint min,\\n    uint max,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint) {\\n    return min >= max ? max : min + random_(max - min);\\n  }\\n\\n  function minusWithZeroFloor(uint a, uint b) internal pure returns (uint){\\n    if (a <= b) {\\n      return 0;\\n    }\\n    return a - b;\\n  }\\n\\n  function minusWithMinFloorI32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) - int(b) < type(int32).min) {\\n      return type(int32).min;\\n    }\\n    return a - b;\\n  }\\n\\n  function plusWithMaxFloor32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) + int(b) >= type(int32).max) {\\n      return type(int32).max;\\n    }\\n    return a + b;\\n  }\\n\\n  function sqrt(uint x) internal pure returns (uint z) {\\n    assembly {\\n    // Start off with z at 1.\\n      z := 1\\n\\n    // Used below to help find a nearby power of 2.\\n      let y := x\\n\\n    // Find the lowest power of 2 that is at least sqrt(x).\\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n        y := shr(128, y) // Like dividing by 2 ** 128.\\n        z := shl(64, z) // Like multiplying by 2 ** 64.\\n      }\\n      if iszero(lt(y, 0x10000000000000000)) {\\n        y := shr(64, y) // Like dividing by 2 ** 64.\\n        z := shl(32, z) // Like multiplying by 2 ** 32.\\n      }\\n      if iszero(lt(y, 0x100000000)) {\\n        y := shr(32, y) // Like dividing by 2 ** 32.\\n        z := shl(16, z) // Like multiplying by 2 ** 16.\\n      }\\n      if iszero(lt(y, 0x10000)) {\\n        y := shr(16, y) // Like dividing by 2 ** 16.\\n        z := shl(8, z) // Like multiplying by 2 ** 8.\\n      }\\n      if iszero(lt(y, 0x100)) {\\n        y := shr(8, y) // Like dividing by 2 ** 8.\\n        z := shl(4, z) // Like multiplying by 2 ** 4.\\n      }\\n      if iszero(lt(y, 0x10)) {\\n        y := shr(4, y) // Like dividing by 2 ** 4.\\n        z := shl(2, z) // Like multiplying by 2 ** 2.\\n      }\\n      if iszero(lt(y, 0x8)) {\\n      // Equivalent to 2 ** z.\\n        z := shl(1, z)\\n      }\\n\\n    // Shifting right by 1 is like dividing by 2.\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n\\n    // Compute a rounded down version of z.\\n      let zRoundDown := div(x, z)\\n\\n    // If zRoundDown is smaller, use it.\\n      if lt(zRoundDown, z) {\\n        z := zRoundDown\\n      }\\n    }\\n  }\\n\\n  /*********************************************\\n *              PRB-MATH                      *\\n *   https://github.com/hifi-finance/prb-math *\\n **********************************************/\\n  /// @notice Calculates the binary logarithm of x.\\n  ///\\n  /// @dev Based on the iterative approximation algorithm.\\n  /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n  ///\\n  /// Requirements:\\n  /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n  ///\\n  /// Caveats:\\n  /// - The results are nor perfectly accurate to the last decimal,\\n  ///   due to the lossy precision of the iterative approximation.\\n  ///\\n  /// @param x The unsigned 60.18-decimal fixed-point number for which\\n  ///           to calculate the binary logarithm.\\n  /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n  function log2(uint256 x) internal pure returns (uint256 result) {\\n    if (x < 1e18) revert IAppErrors.TooLowX(x);\\n\\n    // Calculate the integer part of the logarithm\\n    // and add it to the result and finally calculate y = x * 2^(-n).\\n    uint256 n = mostSignificantBit(x / 1e18);\\n\\n    // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number.\\n    // The operation can't overflow because n is maximum 255 and SCALE is 1e18.\\n    uint256 rValue = n * 1e18;\\n\\n    // This is y = x * 2^(-n).\\n    uint256 y = x >> n;\\n\\n    // If y = 1, the fractional part is zero.\\n    if (y == 1e18) {\\n      return rValue;\\n    }\\n\\n    // Calculate the fractional part via the iterative approximation.\\n    // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n    for (uint256 delta = 5e17; delta > 0; delta >>= 1) {\\n      y = (y * y) / 1e18;\\n\\n      // Is y^2 > 2 and so in the range [2,4)?\\n      if (y >= 2 * 1e18) {\\n        // Add the 2^(-m) factor to the logarithm.\\n        rValue += delta;\\n\\n        // Corresponds to z/2 on Wikipedia.\\n        y >>= 1;\\n      }\\n    }\\n    return rValue;\\n  }\\n\\n  /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n  /// @dev See the note on msb in the \\\"Find First Set\\\"\\n  ///      Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n  /// @param x The uint256 number for which to find the index of the most significant bit.\\n  /// @return msb The index of the most significant bit as an uint256.\\n  //noinspection NoReturn\\n  function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n    if (x >= 2 ** 128) {\\n      x >>= 128;\\n      msb += 128;\\n    }\\n    if (x >= 2 ** 64) {\\n      x >>= 64;\\n      msb += 64;\\n    }\\n    if (x >= 2 ** 32) {\\n      x >>= 32;\\n      msb += 32;\\n    }\\n    if (x >= 2 ** 16) {\\n      x >>= 16;\\n      msb += 16;\\n    }\\n    if (x >= 2 ** 8) {\\n      x >>= 8;\\n      msb += 8;\\n    }\\n    if (x >= 2 ** 4) {\\n      x >>= 4;\\n      msb += 4;\\n    }\\n    if (x >= 2 ** 2) {\\n      x >>= 2;\\n      msb += 2;\\n    }\\n    if (x >= 2 ** 1) {\\n      // No need to shift x any more.\\n      msb += 1;\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x7df92aac39866072cfba309c8e1928ab48c64c01fec09659a783f9708bd70750\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ControllerContextLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\nimport \\\"../interfaces/IDungeonFactory.sol\\\";\\nimport \\\"../interfaces/IReinforcementController.sol\\\";\\nimport \\\"../interfaces/IGameToken.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IUserController.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IRewardsPool.sol\\\";\\nimport \\\"../interfaces/IPvpController.sol\\\";\\nimport \\\"../interfaces/IItemBoxController.sol\\\";\\n\\n/// @notice Provide context-struct with all controller addresses and routines for lazy init\\n/// Usage:\\n///       Create an instance of the structure\\n///               cc = ControllerContextLib.init(controller);\\n///       access controller directly\\n///               cc.controller.xxx();\\n///       access other contracts indirectly\\n///               sc = ControllerContextLib.statController(cc);\\nlibrary ControllerContextLib {\\n  //region ----------------- Data types\\n  enum CacheIndex {\\n    STAT_CONTROLLER_0,\\n    STORY_CONTROLLER_1,\\n    ORACLE_2,\\n    TREASURY_3,\\n    DUNGEON_FACTORY_4,\\n    GOC_5,\\n    REINFORCEMENT_CONTROLLER_6,\\n    ITEM_CONTROLLER_7,\\n    HERO_CONTROLLER_8,\\n    GAME_TOKEN_9,\\n    USER_CONTROLLER_10,\\n    GUILD_CONTROLLER_11,\\n    PVP_CONTROLLER_12,\\n    REWARDS_POOL_13,\\n    ITEM_BOX_CONTROLLER_14\\n  }\\n\\n  uint constant private CACHE_SIZE = 15;\\n\\n  struct ControllerContext {\\n    /// @notice Direct access to the controller\\n    IController controller;\\n\\n    /// @notice All lazy-initialized addresses in order of {CacheIndex}\\n    address[CACHE_SIZE] cache;\\n  }\\n  //endregion ----------------- Data types\\n\\n  //region ----------------- Initialization and _lazyInit\\n  function init(IController controller) internal pure returns (ControllerContext memory cc) {\\n    cc.controller = controller;\\n    return cc;\\n  }\\n\\n  function _lazyInit(\\n    ControllerContext memory cc,\\n    CacheIndex index,\\n    function () external view returns(address) getter\\n  ) internal view returns (address) {\\n    address a = cc.cache[uint(index)];\\n    if (a != address(0)) return a;\\n\\n    cc.cache[uint(index)] = getter();\\n    return cc.cache[uint(index)];\\n  }\\n  //endregion ----------------- Initialization and _lazyInit\\n\\n  //region ----------------- Access with lazy initialization\\n  function statController(ControllerContext memory cc) internal view returns (IStatController) {\\n    return IStatController(_lazyInit(cc, CacheIndex.STAT_CONTROLLER_0, cc.controller.statController));\\n  }\\n\\n  function storyController(ControllerContext memory cc) internal view returns (IStoryController) {\\n    return IStoryController(_lazyInit(cc, CacheIndex.STORY_CONTROLLER_1, cc.controller.storyController));\\n  }\\n\\n  function oracle(ControllerContext memory cc) internal view returns (IOracle) {\\n    return IOracle(_lazyInit(cc, CacheIndex.ORACLE_2, cc.controller.oracle));\\n  }\\n\\n  function treasury(ControllerContext memory cc) internal view returns (ITreasury) {\\n    return ITreasury(_lazyInit(cc, CacheIndex.TREASURY_3, cc.controller.treasury));\\n  }\\n\\n  function dungeonFactory(ControllerContext memory cc) internal view returns (IDungeonFactory) {\\n    return IDungeonFactory(_lazyInit(cc, CacheIndex.DUNGEON_FACTORY_4, cc.controller.dungeonFactory));\\n  }\\n\\n  function gameObjectController(ControllerContext memory cc) internal view returns (IGOC) {\\n    return IGOC(_lazyInit(cc, CacheIndex.GOC_5, cc.controller.gameObjectController));\\n  }\\n\\n  function reinforcementController(ControllerContext memory cc) internal view returns (IReinforcementController) {\\n    return IReinforcementController(_lazyInit(cc, CacheIndex.REINFORCEMENT_CONTROLLER_6, cc.controller.reinforcementController));\\n  }\\n\\n  function itemController(ControllerContext memory cc) internal view returns (IItemController) {\\n    return IItemController(_lazyInit(cc, CacheIndex.ITEM_CONTROLLER_7, cc.controller.itemController));\\n  }\\n\\n  function heroController(ControllerContext memory cc) internal view returns (IHeroController) {\\n    return IHeroController(_lazyInit(cc, CacheIndex.HERO_CONTROLLER_8, cc.controller.heroController));\\n  }\\n\\n  function gameToken(ControllerContext memory cc) internal view returns (IGameToken) {\\n    return IGameToken(_lazyInit(cc, CacheIndex.GAME_TOKEN_9, cc.controller.gameToken));\\n  }\\n\\n  function userController(ControllerContext memory cc) internal view returns (IUserController) {\\n    return IUserController(_lazyInit(cc, CacheIndex.USER_CONTROLLER_10, cc.controller.userController));\\n  }\\n\\n  function guildController(ControllerContext memory cc) internal view returns (IGuildController) {\\n    return IGuildController(_lazyInit(cc, CacheIndex.GUILD_CONTROLLER_11, cc.controller.guildController));\\n  }\\n\\n  function pvpController(ControllerContext memory cc) internal view returns (IPvpController) {\\n    return IPvpController(_lazyInit(cc, CacheIndex.PVP_CONTROLLER_12, cc.controller.pvpController));\\n  }\\n\\n  function rewardsPool(ControllerContext memory cc) internal view returns (IRewardsPool) {\\n    return IRewardsPool(_lazyInit(cc, CacheIndex.REWARDS_POOL_13, cc.controller.rewardsPool));\\n  }\\n\\n  function itemBoxController(ControllerContext memory cc) internal view returns (IItemBoxController) {\\n    return IItemBoxController(_lazyInit(cc, CacheIndex.ITEM_BOX_CONTROLLER_14, cc.controller.itemBoxController));\\n  }\\n  //endregion ----------------- Access with lazy initialization\\n}\",\"keccak256\":\"0x8fa8be52cfba698f7e5a39c5043f05bddd9629868982402238b4294a9bbadb68\",\"license\":\"BUSL-1.1\"},\"contracts/lib/DungeonFactoryLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IDungeonFactory.sol\\\";\\nimport \\\"../interfaces/IGameToken.sol\\\";\\nimport \\\"../interfaces/IMinter.sol\\\";\\nimport \\\"../interfaces/IReinforcementController.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../proxy/Controllable.sol\\\";\\nimport \\\"../lib/StringLib.sol\\\";\\nimport \\\"../lib/DungeonLib.sol\\\";\\nimport \\\"../relay/ERC2771Context.sol\\\";\\nimport \\\"../lib/ControllerContextLib.sol\\\";\\n\\nlibrary DungeonFactoryLib {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\\n  using PackingLib for bytes32;\\n  using PackingLib for uint16;\\n  using PackingLib for uint8;\\n  using PackingLib for address;\\n  using PackingLib for uint32[];\\n  using PackingLib for uint32;\\n  using PackingLib for uint64;\\n  using PackingLib for int32[];\\n  using PackingLib for int32;\\n\\n  //region ------------------------ Data types\\n  struct ObjectActionLocal {\\n    bool isCompleted;\\n    bool needClear;\\n    uint32 currentObjectId;\\n    uint32 newCurrentObjectId;\\n    uint newCurrentStage;\\n  }\\n\\n  struct LaunchContext {\\n    IStatController.ChangeableStats stats;\\n    uint16 dungNum;\\n    uint treasuryAmount;\\n    IHeroController heroController;\\n    uint maxOpenedNgLevel;\\n    uint heroNgLevel;\\n  }\\n\\n  struct OpenObjectContext {\\n    address dungHero;\\n    uint dungHeroId;\\n    IGOC goc;\\n    uint currentStage;\\n    uint32 objectId;\\n  }\\n\\n  //endregion ------------------------ Data types\\n\\n  uint private constant BOSS_1_EVENT = 1280132;\\n  uint private constant BOSS_2_EVENT = 2290232;\\n  uint private constant BOSS_3_EVENT = 3290332;\\n  uint private constant BOSS_4_EVENT = 4290432;\\n\\n  //region ------------------------ RESTRICTIONS\\n\\n  function onlyDeployer(IController controller) internal view {\\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n\\n  function _onlyEoa(bool isEoa) internal pure {\\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\\n  }\\n\\n  function onlyHeroController(IController controller) internal view {\\n    if (controller.heroController() != msg.sender) revert IAppErrors.ErrorNotHeroController(msg.sender);\\n  }\\n\\n  function onlyItemController(ControllerContextLib.ControllerContext memory cc) internal view {\\n    IItemController itemController = ControllerContextLib.itemController(cc);\\n    if (address(itemController) != msg.sender) revert IAppErrors.ErrorNotItemController(msg.sender);\\n  }\\n\\n  function _checkOwnerRegisteredNotPaused(\\n    address heroToken,\\n    uint heroTokenId,\\n    address msgSender,\\n    ControllerContextLib.ControllerContext memory cc\\n  ) internal view {\\n    if (IERC721(heroToken).ownerOf(heroTokenId) != msgSender) revert IAppErrors.ErrorNotOwner(heroToken, heroTokenId);\\n    if (ControllerContextLib.heroController(cc).heroClass(heroToken) == 0) revert IAppErrors.ErrorHeroIsNotRegistered(heroToken);\\n    if (cc.controller.onPause()) revert IAppErrors.ErrorPaused();\\n  }\\n\\n  function _onlySameLevels(uint dungeonNgLevel_, uint8 heroNgLevel_) internal pure {\\n    if (dungeonNgLevel_ != heroNgLevel_) revert IAppErrors.ErrorWrongLevel(heroNgLevel_);\\n  }\\n\\n  //endregion ------------------------ RESTRICTIONS\\n\\n  //region ------------------------ VIEWS\\n  function _S() internal pure returns (IDungeonFactory.MainState storage s) {\\n    return DungeonLib._S();\\n  }\\n\\n  function dungeonAttributes(uint16 dungNum) internal view returns (IDungeonFactory.DungeonAttributes memory) {\\n    return _S().dungeonAttributes[dungNum];\\n  }\\n\\n  function dungeonStatus(uint64 dungeonId) internal view returns (\\n    uint16 dungNum,\\n    bool isCompleted,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint32 currentObject,\\n    uint8 currentStage,\\n    address[] memory treasuryTokens_,\\n    uint[] memory treasuryTokensAmounts_,\\n    bytes32[] memory treasuryItems,\\n    uint8 stages,\\n    uint32[] memory uniqObjects\\n  ) {\\n    IDungeonFactory.DungeonStatus storage dungStatus = _S().dungeonStatuses[dungeonId];\\n\\n    dungNum = dungStatus.dungNum;\\n    isCompleted = dungStatus.isCompleted;\\n    heroToken = dungStatus.heroToken;\\n    heroTokenId = dungStatus.heroTokenId;\\n    currentObject = dungStatus.currentObject;\\n    currentStage = dungStatus.currentStage;\\n    treasuryItems = dungStatus.treasuryItems;\\n    stages = dungStatus.stages;\\n    uniqObjects = dungStatus.uniqObjects;\\n\\n    uint tokensLength = dungStatus.treasuryTokens.length();\\n\\n    treasuryTokens_ = new address[](tokensLength);\\n    treasuryTokensAmounts_ = new uint[](tokensLength);\\n\\n    for (uint i; i < tokensLength; ++i) {\\n      (treasuryTokens_[i], treasuryTokensAmounts_[i]) = dungStatus.treasuryTokens.at(i);\\n    }\\n  }\\n\\n  function dungeonCounter() internal view returns (uint64) {\\n    return _S().dungeonCounter;\\n  }\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) internal view returns (uint8) {\\n    return _S().maxBiomeCompleted[heroToken.packNftId(heroTokenId)];\\n  }\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) internal view returns (uint64) {\\n    return _S().heroCurrentDungeon[heroToken.packNftId(heroTokenId)];\\n  }\\n\\n  function minLevelForTreasury(address token) internal view returns (uint) {\\n    return _S().minLevelForTreasury[token];\\n  }\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) internal view returns (\\n    uint8[] memory result\\n  ) {\\n    return _S().skillSlotsForDurabilityReduction[heroToken.packNftId(heroTokenId)].unpackUint8Array();\\n  }\\n\\n  /// @return Length of the items in freeDungeons map for the given {biome}\\n  function freeDungeonsByLevelLength(uint biome) internal view returns (uint) {\\n    return _S().freeDungeons[biome].length();\\n  }\\n\\n  /// @param index Index of the free dungeon inside freeDungeons map\\n  /// @return dungeonId\\n  function freeDungeonsByLevel(uint index, uint biome) internal view returns (uint64) {\\n    return uint64(_S().freeDungeons[biome].at(index));\\n  }\\n\\n  function getDungeonTreasuryAmount(IController controller, address token, uint heroVirtualLevel, uint biome, uint heroNgLevel)\\n  external view returns (\\n    uint totalAmount,\\n    uint amountForDungeon,\\n    uint mintAmount\\n  ) {\\n    totalAmount = ITreasury(controller.treasury()).balanceOfToken(token);\\n    mintAmount = IMinter(IGameToken(controller.gameToken()).minter()).amountForDungeon(biome, heroVirtualLevel);\\n    IHeroController heroController = IHeroController(controller.heroController());\\n    amountForDungeon = DungeonLib.dungeonTreasuryReward(\\n      token,\\n      uint(_S().maxBiome),\\n      totalAmount,\\n      uint8(heroVirtualLevel),\\n      uint8(biome),\\n      heroController.maxOpenedNgLevel(),\\n      heroNgLevel\\n    );\\n  }\\n\\n  /// @notice Check if biome boss completed by the hero.\\n  /// @dev isBiomeBossCompleted would be more correct title, but isBiomeBoss is already used\\n  function isBiomeBoss(IController controller, address heroToken, uint heroTokenId)\\n  internal view returns (bool) {\\n    uint8 heroBiome = IHeroController(controller.heroController()).heroBiome(heroToken, heroTokenId);\\n    return _S().bossCompleted[heroToken.packMapObject(uint64(heroTokenId), heroBiome)];\\n  }\\n\\n  function maxAvailableBiome() internal view returns (uint8) {\\n    return _S().maxBiome;\\n  }\\n\\n  function dungeonNgLevel(uint64 dungeonId) internal view returns (uint) {\\n    return _S().dungeonNgLevel[dungeonId];\\n  }\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ ACTIONS\\n  function launch(\\n    bool isEoa,\\n    IController controller,\\n    address msgSender,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken\\n  ) external returns (uint64 dungeonId) {\\n    _onlyEoa(isEoa);\\n    return _launch(controller, msgSender, heroToken, heroTokenId, treasuryToken);\\n  }\\n\\n  function launchForNewHero(\\n    IController controller,\\n    address msgSender,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external returns (uint64 dungeonId) {\\n    onlyHeroController(controller);\\n    return _launch(controller, msgSender, heroToken, heroTokenId, controller.gameToken());\\n  }\\n\\n  /// @notice Create new dungeon and enter to it. Treasury reward is sent by treasury to the dungeon.\\n  function _launch(\\n    IController controller,\\n    address msgSender,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken\\n  ) internal returns (uint64 dungeonId) {\\n    IDungeonFactory.MainState storage s = _S();\\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\\n    LaunchContext memory ctx;\\n\\n    ctx.heroController = ControllerContextLib.heroController(cc);\\n    ctx.maxOpenedNgLevel = ctx.heroController.maxOpenedNgLevel();\\n    ctx.heroNgLevel = ctx.heroController.getHeroInfo(heroToken, heroTokenId).ngLevel;\\n\\n    // check part of restrictions; other part is checked inside DungeonLib._enter\\n    _checkOwnerRegisteredNotPaused(heroToken, heroTokenId, msgSender, cc);\\n    if (!controller.validTreasuryTokens(treasuryToken)) revert IAppErrors.ErrorNotValidTreasureToken(treasuryToken);\\n\\n    // select a logic for new dungeon\\n    ctx.stats = ControllerContextLib.statController(cc).heroStats(heroToken, heroTokenId);\\n    ctx.dungNum = DungeonLib.getDungeonLogic(\\n      s,\\n      cc,\\n      uint8(ctx.stats.level),\\n      heroToken,\\n      heroTokenId,\\n      ControllerContextLib.oracle(cc).getRandomNumber(1e18, 0)\\n    );\\n\\n    // register new dungeon\\n    dungeonId = s.dungeonCounter + 1;\\n    s.dungeonCounter = dungeonId;\\n\\n    IDungeonFactory.DungeonAttributes storage dungAttr = s.dungeonAttributes[ctx.dungNum];\\n    IDungeonFactory.DungeonStatus storage dungStatus = s.dungeonStatuses[dungeonId];\\n\\n    if (dungStatus.isCompleted) revert IAppErrors.ErrorDungeonCompleted();\\n\\n    dungStatus.dungeonId = dungeonId;\\n    dungStatus.dungNum = ctx.dungNum;\\n    dungStatus.stages = dungAttr.stages;\\n    dungStatus.uniqObjects = dungAttr.uniqObjects;\\n\\n    s.dungeonNgLevel[dungeonId] = ctx.heroNgLevel;\\n\\n    emit IApplicationEvents.DungeonRegistered(ctx.dungNum, dungeonId);\\n\\n    // enter to the dungeon\\n    DungeonLib._enter(cc, dungStatus, dungAttr, ctx.dungNum, dungeonId, heroToken, heroTokenId);\\n\\n    // when entered, open the first object for reduce txs\\n    _openObject(cc, msgSender, dungeonId);\\n\\n    // send treasury to the dungeon\\n    // if we have reduced drop then do not mint token at all\\n    if (StatLib.mintDropChanceDelta(ctx.stats.experience, uint(ctx.stats.level), dungAttr.biome) == 0) {\\n      ctx.treasuryAmount = DungeonLib.dungeonTreasuryReward(\\n        treasuryToken,\\n        uint(_S().maxBiome),\\n        ControllerContextLib.treasury(cc).balanceOfToken(treasuryToken),\\n        StatLib.getVirtualLevel(\\n          ctx.stats.experience,\\n          StatLib.getVirtualLevel(ctx.stats.experience, uint(ctx.stats.level), true),\\n          true\\n        ),\\n        dungAttr.biome,\\n        ctx.maxOpenedNgLevel,\\n        ctx.heroNgLevel\\n      );\\n    }\\n\\n    if (ctx.treasuryAmount != 0) {\\n      ControllerContextLib.treasury(cc).sendToDungeon(address(this), treasuryToken, ctx.treasuryAmount);\\n      DungeonLib._registerTreasuryToken(treasuryToken, s.dungeonStatuses[dungeonId].treasuryTokens, ctx.treasuryAmount);\\n    }\\n\\n    emit IApplicationEvents.DungeonLaunched(ctx.dungNum, dungeonId, heroToken, heroTokenId, treasuryToken, ctx.treasuryAmount);\\n  }\\n\\n  /// @notice Set boss completed for the given hero and given biome.\\n  /// @dev Set custom data for the hero: BOSS_COMPLETED_ = 1\\n  function setBossCompleted(IController controller, uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external {\\n    if (controller.gameObjectController() != msg.sender) revert IAppErrors.ErrorNotGoc();\\n\\n    IDungeonFactory.MainState storage s = _S();\\n\\n    bytes32 packMapObject = heroToken.packMapObject(uint64(heroTokenId), heroBiome);\\n    if (!s.bossCompleted[packMapObject]) {\\n      s.bossCompleted[packMapObject] = true;\\n    }\\n\\n    bytes32 packedHero = heroToken.packNftId(heroTokenId);\\n    if (s.maxBiomeCompleted[packedHero] < heroBiome) {\\n      s.maxBiomeCompleted[packedHero] = heroBiome;\\n    }\\n\\n    bytes32 index = _getBossCompletedIndex(heroBiome);\\n    IStatController(controller.statController()).setHeroCustomData(heroToken, heroTokenId, index, 1);\\n\\n    IHeroController(controller.heroController()).registerKilledBoss(heroToken, heroTokenId, objectId);\\n\\n    emit IApplicationEvents.BossCompleted(objectId, heroBiome, heroToken, heroTokenId);\\n  }\\n  //endregion ------------------------ ACTIONS\\n\\n  //region ------------------------ DUNGEON LOGIC - GOV ACTIONS\\n\\n  /// @notice Register ordinal or specific dungeon\\n  /// @dev can be called for exist dungeon - will rewrite dungeon data\\n  /// @param dungNum Dungeon logic id\\n  /// @param biome Assume biome > 0\\n  /// @param isSpecific The dungeon is specific, so it shouldn't be registered in dungeonsLogicByBiome\\n  function registerDungeonLogic(\\n    IController controller,\\n    uint16 dungNum,\\n    uint8 biome,\\n    IDungeonFactory.DungeonGenerateInfo memory genInfo,\\n    uint8 specReqBiome,\\n    uint8 specReqHeroClass,\\n    bool isSpecific\\n  ) internal {\\n    onlyDeployer(controller);\\n    IDungeonFactory.MainState storage s = _S();\\n\\n    uint len = genInfo.objChancesByStages.length;\\n    if (len != genInfo.objTypesByStages.length || len != genInfo.uniqObjects.length) revert IAppErrors.ErrorNotStages();\\n\\n    for (uint i; i < len; ++i) {\\n      if (genInfo.objChancesByStages[i].length != genInfo.objTypesByStages[i].length) revert IAppErrors.ErrorNotChances();\\n    }\\n\\n    IDungeonFactory.DungeonAttributes storage info = s.dungeonAttributes[dungNum];\\n\\n    if (biome > s.maxBiome) {\\n      s.maxBiome = biome;\\n    }\\n\\n    info.stages = uint8(len); // info.stages can be increased later by chamber story\\n    info.biome = biome;\\n\\n    info.uniqObjects = genInfo.uniqObjects;\\n    info.minMaxLevel = DungeonLib._toUint8PackedArray(genInfo.minLevel, genInfo.maxLevel);\\n\\n    info.requiredCustomDataIndex = genInfo.requiredCustomDataIndex;\\n    bytes32[] storage requiredCustomDataValue = info.requiredCustomDataValue;\\n\\n    for (uint i; i < genInfo.requiredCustomDataMinValue.length; ++i) {\\n      requiredCustomDataValue.push(\\n        PackingLib.packCustomDataRequirements(\\n          genInfo.requiredCustomDataMinValue[i],\\n          genInfo.requiredCustomDataMaxValue[i],\\n          genInfo.requiredCustomDataIsHero[i]\\n        )\\n      );\\n    }\\n\\n    for (uint i; i < len; ++i) {\\n      info.info.objTypesByStages.push(PackingLib.packUint8Array(genInfo.objTypesByStages[i]));\\n      info.info.objChancesByStages.push(genInfo.objChancesByStages[i]);\\n    }\\n\\n    if (isSpecific) {\\n      bytes32 packedId = DungeonLib._toUint8PackedArray(specReqBiome, specReqHeroClass);\\n      if (s.dungeonSpecific[packedId] != 0) revert IAppErrors.DungeonAlreadySpecific(dungNum);\\n      s.dungeonSpecific[packedId] = dungNum;\\n\\n      if (s.allSpecificDungeons.contains(dungNum)) revert IAppErrors.DungeonAlreadySpecific2(dungNum);\\n\\n      s.allSpecificDungeons.add(dungNum);\\n\\n      emit IApplicationEvents.DungeonSpecificLogicRegistered(dungNum, specReqBiome, specReqHeroClass);\\n    } else {\\n      s.dungeonsLogicByBiome[info.biome].add(dungNum);\\n    }\\n\\n    emit IApplicationEvents.DungeonLogicRegistered(dungNum, genInfo);\\n  }\\n\\n  /// @dev Remove the dungeon logic (both ordinal and specific logics are supported)\\n  /// @param dungNum Dungeon logic id\\n  function removeDungeonLogic(IController controller, uint16 dungNum, uint8 specReqBiome, uint8 specReqHeroClass) internal {\\n    onlyDeployer(controller);\\n    IDungeonFactory.MainState storage s = _S();\\n\\n    uint8 biome = s.dungeonAttributes[dungNum].biome;\\n    delete s.dungeonAttributes[dungNum];\\n\\n    if (s.dungeonsLogicByBiome[biome].contains(dungNum)) {\\n      s.dungeonsLogicByBiome[biome].remove(dungNum);\\n      emit IApplicationEvents.DungeonLogicRemoved(dungNum);\\n    }\\n\\n    if (s.allSpecificDungeons.contains(dungNum)) {\\n      bytes32 packedId = DungeonLib._toUint8PackedArray(specReqBiome, specReqHeroClass);\\n      if (s.dungeonSpecific[packedId] != dungNum) revert IAppErrors.WrongSpecificDungeon();\\n\\n      delete s.dungeonSpecific[packedId];\\n      s.allSpecificDungeons.remove(dungNum);\\n      emit IApplicationEvents.DungeonSpecificLogicRemoved(dungNum, specReqBiome, specReqHeroClass);\\n    }\\n  }\\n\\n  /// @dev Set eligible hero level for treasury tokens\\n  function setMinLevelForTreasury(IController controller, address token, uint heroLevel) internal {\\n    onlyDeployer(controller);\\n\\n    if (heroLevel < DungeonLib.MIN_LEVEL_FOR_TREASURY_DEFAULT) {\\n      revert IAppErrors.ErrorLevelTooLow(heroLevel);\\n    }\\n\\n    _S().minLevelForTreasury[token] = heroLevel;\\n    emit IApplicationEvents.MinLevelForTreasuryChanged(token, heroLevel);\\n  }\\n\\n  /// @dev Governance can drop hero from dungeon in emergency case\\n  function emergencyExit(IController controller, uint64 dungId) internal {\\n    onlyDeployer(controller);\\n    DungeonLib.emergencyExit(controller, dungId);\\n  }\\n  //endregion ------------------------ DUNGEON LOGIC - GOV ACTIONS\\n\\n  //region ------------------------ DUNGEON LOGIC - USER ACTIONS\\n\\n  /// @notice Enter to the exist dungeon\\n  function enter(bool isEoa, IController controller, address msgSender, uint64 dungId, address heroToken, uint heroTokenId) external {\\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\\n    IDungeonFactory.DungeonStatus storage dungStatus = _S().dungeonStatuses[dungId];\\n\\n    // check part of restrictions; other part is checked inside DungeonLib._enter\\n    _onlyEoa(isEoa);\\n    _checkOwnerRegisteredNotPaused(heroToken, heroTokenId, msgSender, cc);\\n    if (dungStatus.isCompleted) revert IAppErrors.ErrorDungeonCompleted();\\n    _onlySameLevels(_S().dungeonNgLevel[dungId], ControllerContextLib.heroController(cc).getHeroInfo(heroToken, heroTokenId).ngLevel);\\n\\n    // enter to the dungeon\\n    uint16 dungNum = dungStatus.dungNum;\\n    DungeonLib._enter(cc, dungStatus, _S().dungeonAttributes[dungNum], dungNum, dungId, heroToken, heroTokenId);\\n\\n    // when entered, open the first object for reduce txs\\n    _openObject(cc, msgSender, dungId);\\n  }\\n\\n  function openObject(bool isEoa, IController controller, address msgSender, uint64 dungId) internal {\\n    _onlyEoa(isEoa);\\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\\n    _openObject(cc, msgSender, dungId);\\n  }\\n\\n  /// @notice Set new current object for the dungeon\\n  function _openObject(ControllerContextLib.ControllerContext memory cc, address msgSender, uint64 dungId) internal {\\n    IDungeonFactory.MainState storage s = _S();\\n    IDungeonFactory.DungeonStatus storage dungStatus = s.dungeonStatuses[dungId];\\n    IDungeonFactory.DungeonAttributes storage dungAttributes = s.dungeonAttributes[dungStatus.dungNum];\\n\\n    OpenObjectContext memory ctx;\\n\\n    ctx.goc = ControllerContextLib.gameObjectController(cc);\\n\\n    // check restrictions\\n    if (dungStatus.currentObject != 0) revert IAppErrors.ErrorNotReady();\\n    (ctx.dungHero, ctx.dungHeroId) = _checkCurrentHero(dungStatus, msgSender, cc);\\n\\n    // select new object and set it as current object in the dungeon\\n    ctx.currentStage = dungStatus.currentStage;\\n    ctx.objectId = _generateObject(dungAttributes, dungStatus, ctx.currentStage, ctx.goc, ctx.dungHero, ctx.dungHeroId, ControllerContextLib.statController(cc));\\n    if (ctx.objectId == 0) revert IAppErrors.ErrorNotObject1();\\n    dungStatus.currentObject = ctx.objectId;\\n\\n    // generate some info for UI\\n    uint iteration = ctx.goc.open(ctx.dungHero, ctx.dungHeroId, ctx.objectId);\\n    emit IApplicationEvents.ObjectOpened(dungId, ctx.dungHero, ctx.dungHeroId, ctx.objectId, iteration, ctx.currentStage);\\n  }\\n\\n  /// @notice Do action and handle results\\n  /// @param data AttackInfo struct encoded using abi.encode\\n  function objectAction(bool isEoa, IController controller, address msgSender, uint64 dungId, bytes memory data) internal {\\n    IDungeonFactory.MainState storage s = _S();\\n\\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\\n    ObjectActionLocal memory v;\\n\\n    IDungeonFactory.DungeonStatus storage dungStatus = s.dungeonStatuses[dungId];\\n    IDungeonFactory.DungeonAttributes storage dungAttributes = s.dungeonAttributes[dungStatus.dungNum];\\n\\n    // check restrictions, some restrictions are checked inside objectAction\\n    _onlyEoa(isEoa);\\n    _checkCurrentHero(dungStatus, msgSender, cc);\\n\\n    v.currentObjectId = dungStatus.currentObject;\\n\\n    (v.isCompleted, v.newCurrentStage, v.newCurrentObjectId, v.needClear) = DungeonLib.objectAction(\\n      dungStatus,\\n      dungAttributes,\\n      dungId,\\n      msgSender,\\n      data,\\n      controller, // we pass controller, not cc, because objectAction is external\\n      v.currentObjectId\\n    );\\n\\n    if (v.isCompleted) {\\n      dungStatus.isCompleted = true;\\n    }\\n\\n    if (v.newCurrentStage != 0) {\\n      dungStatus.currentStage = uint8(v.newCurrentStage);\\n    }\\n\\n    if (v.newCurrentObjectId != v.currentObjectId) {\\n      dungStatus.currentObject = v.newCurrentObjectId;\\n    }\\n\\n    if (v.needClear) {\\n      _clear(dungStatus, dungAttributes.biome, dungId);\\n    }\\n\\n    // if dungeon is not ended and current object is empty we can open next object for reduce users transactions\\n    if (!v.isCompleted && dungStatus.currentObject == 0 && !v.needClear) {\\n      _openObject(cc, msgSender, dungId);\\n    }\\n  }\\n\\n  /// @notice Exit from completed dungeon\\n  function exit(bool isEoa, IController controller, address msgSender, uint64 dungId, bool claim) internal {\\n    _onlyEoa(isEoa);\\n    DungeonLib.exitDungeon(controller, dungId, claim, msgSender);\\n  }\\n\\n  /// @notice Hero exists current dungeon forcibly same as when dying but without loosing life chance\\n  function exitForcibly(\\n    IController controller,\\n    address heroToken,\\n    uint heroTokenId,\\n    address msgSender\\n  ) external {\\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\\n\\n    onlyItemController(cc);\\n\\n    IDungeonFactory.MainState storage s = _S();\\n    uint64 dungId = currentDungeon(heroToken, heroTokenId);\\n\\n    IDungeonFactory.DungeonStatus storage dungStatus = s.dungeonStatuses[dungId];\\n    _checkCurrentHero(dungStatus, msgSender, cc);\\n\\n    IDungeonFactory.DungeonAttributes storage dungAttributes = s.dungeonAttributes[dungStatus.dungNum];\\n\\n    // Extract hero from the current dungeon, clear hero state.\\n    // life => 1, mana => 0, lifeChance is NOT changed, hero is NOT burnt, items are kept equipped.\\n    DungeonLib.exitForcibly(heroToken, heroTokenId, dungStatus, dungAttributes, cc);\\n\\n    // clear dungeon state\\n    _clear(dungStatus, dungAttributes.biome, dungId);\\n  }\\n\\n  function reborn(IController controller, address hero, uint heroId) external {\\n    onlyHeroController(controller);\\n\\n    uint8 maxBiome = _S().maxBiome;\\n    for (uint8 biome; biome <= maxBiome; ++biome) {\\n      delete _S().bossCompleted[PackingLib.packMapObject(hero, uint64(heroId), biome)];\\n    }\\n    delete _S().maxBiomeCompleted[PackingLib.packNftId(hero, heroId)];\\n  }\\n  //endregion ------------------------ DUNGEON LOGIC - USER ACTIONS\\n\\n  //region ------------------------ DUNGEON LOGIC - INTERNAL LOGIC\\n\\n  /// @notice Generate object for the current stage\\n  /// @return objectId Either uniqObj or randomly generated object if uniqObj is not specified for the stage\\n  function _generateObject(\\n    IDungeonFactory.DungeonAttributes storage dungAttributes,\\n    IDungeonFactory.DungeonStatus storage dungStatus,\\n    uint currentStage,\\n    IGOC goc,\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController sc\\n  ) internal returns (uint32 objectId) {\\n    if (currentStage >= dungStatus.stages) revert IAppErrors.ErrorWrongStage(currentStage);\\n\\n    //////////// if we have specific dungeon (rewrite from stories for ex., it has highest priority\\n    objectId = dungStatus.uniqObjects[currentStage];\\n    if (objectId != 0) {\\n      return objectId;\\n    }\\n\\n    /////////// if a hero play long enough on this biome he should meet a boss\\n\\n    IStatController.ChangeableStats memory stats = sc.heroStats(heroToken, heroTokenId);\\n    if (\\n      StatLib.mintDropChanceDelta(stats.experience, stats.level, dungAttributes.biome) != 0\\n      && !_S().bossCompleted[heroToken.packMapObject(uint64(heroTokenId), dungAttributes.biome)]\\n      && stats.level >= dungAttributes.biome * 5\\n    ) {\\n      if (dungAttributes.biome == 1) {\\n        return uint32(BOSS_1_EVENT);\\n      }\\n      if (dungAttributes.biome == 2) {\\n        return uint32(BOSS_2_EVENT);\\n      }\\n      if (dungAttributes.biome == 3) {\\n        return uint32(BOSS_3_EVENT);\\n      }\\n      if (dungAttributes.biome == 4) {\\n        return uint32(BOSS_4_EVENT);\\n      }\\n    }\\n\\n    ////////// normal search an object\\n\\n    IDungeonFactory.ObjectGenerateInfo memory info = dungAttributes.info;\\n    return goc.getRandomObject(\\n      DungeonLib._toUint8ArrayWithoutZeroes(info.objTypesByStages[currentStage]),\\n      info.objChancesByStages[currentStage],\\n      dungAttributes.biome,\\n      heroToken,\\n      heroTokenId\\n    );\\n\\n  }\\n\\n  /// @notice Clear hero info in dungeon status, add dungeon to the list of free dungeons\\n  function _clear(IDungeonFactory.DungeonStatus storage dungStatus, uint8 biome, uint64 dungId) internal {\\n    delete dungStatus.heroToken;\\n    delete dungStatus.heroTokenId;\\n    delete dungStatus.currentObject;\\n    delete dungStatus.currentStage;\\n    _addFreeDungeon(biome, dungId);\\n    emit IApplicationEvents.Clear(dungId);\\n  }\\n\\n  /// @notice Check: hero is registered, not dead, in the dungeon, sender is the owner, the dungeon is not completed,\\n  /// controller is not paused\\n  /// @return heroToken Token of the hero who is in the dungeon\\n  /// @return heroTokenId Token ID of the hero who is in the dungeon\\n  function _checkCurrentHero(\\n    IDungeonFactory.DungeonStatus storage dungStatus,\\n    address msgSender,\\n    ControllerContextLib.ControllerContext memory cc\\n  ) internal view returns (address heroToken, uint heroTokenId) {\\n\\n    heroToken = dungStatus.heroToken;\\n    heroTokenId = dungStatus.heroTokenId;\\n\\n    if (dungStatus.isCompleted) revert IAppErrors.ErrorDungeonCompleted();\\n    _checkOwnerRegisteredNotPaused(heroToken, heroTokenId, msgSender, cc);\\n\\n    if (!ControllerContextLib.statController(cc).isHeroAlive(heroToken, heroTokenId)) revert IAppErrors.ErrorHeroIsDead(heroToken, heroTokenId);\\n    if (currentDungeon(heroToken, heroTokenId) != dungStatus.dungeonId) revert IAppErrors.ErrorHeroNotInDungeon();\\n  }\\n\\n  /// @notice Add the {dungeonId} to the list of free dungeons (available to pass) of the given {biome}\\n  function _addFreeDungeon(uint8 biome, uint64 dungeonId) internal {\\n    if (!_S().freeDungeons[biome].add(dungeonId)) revert IAppErrors.ErrorDungeonIsFreeAlready();\\n    emit IApplicationEvents.FreeDungeonAdded(biome, dungeonId);\\n  }\\n  //endregion ------------------------ DUNGEON LOGIC - INTERNAL LOGIC\\n\\n  //region ------------------------ Utils\\n  /// @dev We need separate utility function for tests\\n  function _getBossCompletedIndex(uint8 heroBiome) internal pure returns (bytes32) {\\n    return bytes32(abi.encodePacked(\\\"BOSS_COMPLETED_\\\", StringLib._toString(heroBiome)));\\n  }\\n\\n  //endregion ------------------------ Utils\\n\\n}\\n\",\"keccak256\":\"0x66e564e973ab494e09fa4cd0807c6a37a48c28ad5788dc1f822a2616881e5fac\",\"license\":\"BUSL-1.1\"},\"contracts/lib/DungeonLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IDungeonFactory.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IFightCalculator.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IGameToken.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IMinter.sol\\\";\\nimport \\\"../interfaces/IReinforcementController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"../interfaces/IUserController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\nimport \\\"./AppLib.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./ControllerContextLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\nimport \\\"./RewardsPoolLib.sol\\\";\\nimport \\\"./StatControllerLib.sol\\\";\\nimport \\\"./StatLib.sol\\\";\\nimport \\\"./AppLib.sol\\\";\\n\\nlibrary DungeonLib {\\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using CalcLib for int32;\\n  using PackingLib for bytes32;\\n  using PackingLib for uint16;\\n  using PackingLib for uint8;\\n  using PackingLib for address;\\n  using PackingLib for uint8[];\\n  using PackingLib for uint32[];\\n  using PackingLib for uint32;\\n  using PackingLib for uint64;\\n  using PackingLib for int32[];\\n  using PackingLib for int32;\\n\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"dungeon.factory.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 private constant DUNGEON_FACTORY_STORAGE_LOCATION = 0xae5971282b317bbed599861775fe0712755bb3b2f655bfe8fb14280d8429f600;\\n\\n  /// @notice Treasure reward is available starting from level 5. We need some initial gap as protection against bots\\n  uint public constant MIN_LEVEL_FOR_TREASURY_DEFAULT = 5;\\n\\n  /// @notice Max possible default minLevelForTreasury (= 95)\\n  uint internal constant MAX_NIM_LEVEL_FOR_TREASURE = StatLib.MAX_LEVEL - StatLib.BIOME_LEVEL_STEP + 1;\\n\\n  //region ------------------------ Data types\\n\\n  struct ObjectActionInternalData {\\n    address msgSender;\\n    address heroToken;\\n    IStatController statController;\\n    bytes data;\\n    uint stages;\\n    uint biome;\\n    uint heroTokenId;\\n    uint64 dungId;\\n    uint32 objectId;\\n    uint8 currentStage;\\n    bool isBattleObj;\\n    IGOC.ActionResult result;\\n    IStatController.ChangeableStats stats;\\n  }\\n\\n  /// @notice Lazy initialization data for _claimAll\\n  struct ClaimContext {\\n    address helpHeroToken;\\n    address heroPayToken;\\n    address msgSender;\\n    address guildBank;\\n    address[] tokens;\\n    /// @notice list of items sent to ItemBox\\n    address[] items;\\n\\n    uint8 biome;\\n    uint8 sandboxMode;\\n    uint64 dungId;\\n\\n    /// @dev Limited by ReinforcementController._TO_HELPER_RATIO_MAX\\n    uint toHelperRatio;\\n    uint itemLength;\\n    uint tokenLength;\\n    uint helpHeroId;\\n\\n    /// @notice Percent of tax that is taken if favor of biome owner, decimals 3\\n    uint taxPercent;\\n    uint guildId;\\n\\n    uint[] amounts;\\n\\n    /// @notice list of items sent to ItemBox\\n    uint[] itemIds;\\n    /// @notice Actual count of items sent to the ItemBox\\n    uint countItems;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Common\\n\\n  function _S() internal pure returns (IDungeonFactory.MainState storage s) {\\n    assembly {\\n      s.slot := DUNGEON_FACTORY_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n\\n  /// @notice Calculate amount of treasure reward that a hero can count on\\n  /// @param token Treasury token\\n  /// @param maxAvailableBiome Max deployed biome\\n  /// @param treasuryBalance Total treasury of the dungeon\\n  /// @param lvlForMint Current level of the hero\\n  /// @param dungeonBiome Biome to which the dungeon belongs\\n  /// @param maxOpenedNgLevel Max NG_LEVEL reached by any user\\n  /// @param heroNgLevel Current NG_LEVEL of the user\\n  function dungeonTreasuryReward(\\n    address token,\\n    uint maxAvailableBiome,\\n    uint treasuryBalance,\\n    uint lvlForMint,\\n    uint dungeonBiome,\\n    uint maxOpenedNgLevel,\\n    uint heroNgLevel\\n  ) internal view returns (uint) {\\n    if (dungeonBiome < maxAvailableBiome || heroNgLevel < maxOpenedNgLevel) {\\n      return 0;\\n    }\\n\\n    uint customMinLevel = _S().minLevelForTreasury[token];\\n    if (customMinLevel != 0 && lvlForMint < customMinLevel) {\\n      return 0;\\n    }\\n\\n    if (lvlForMint > StatLib.MAX_LEVEL) revert IAppErrors.ErrorWrongLevel(lvlForMint);\\n    if (dungeonBiome > StatLib.MAX_POSSIBLE_BIOME) revert IAppErrors.ErrorIncorrectBiome(dungeonBiome);\\n\\n    uint biomeLevel = dungeonBiome * StatLib.BIOME_LEVEL_STEP;\\n\\n    // CalcLib.log2((StatLib.MAX_LEVEL + 1) * 1e18);\\n    uint maxMultiplier = 6643856189774724682;\\n    uint multiplier = (maxMultiplier - CalcLib.log2((StatLib.MAX_LEVEL - biomeLevel + 1) * 1e18)) / 100;\\n    if (multiplier >= 1e18) revert IAppErrors.ErrorWrongMultiplier(multiplier);\\n    uint base = treasuryBalance * multiplier / 1e18;\\n\\n    if (biomeLevel < lvlForMint) {\\n      // reduce base on biome difference\\n      base = base / 2 ** (lvlForMint - biomeLevel + 10);\\n    }\\n    return base;\\n  }\\n  //endregion ------------------------ Common\\n\\n  //region ------------------------ Main logic\\n\\n  /// @notice Make an action with object, update hero params according results\\n  function objectAction(\\n    IDungeonFactory.DungeonStatus storage dungStatus,\\n    IDungeonFactory.DungeonAttributes storage dungAttributes,\\n    uint64 dungId,\\n    address msgSender,\\n    bytes memory data,\\n    IController controller,\\n    uint32 currentObject_\\n  ) external returns (\\n    bool isCompleted,\\n    uint currentStage,\\n    uint32 currentObject,\\n    bool clear\\n  ) {\\n    IGOC.ActionResult memory a;\\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\\n    return _objectAction(\\n      ObjectActionInternalData({\\n        dungId: dungId,\\n        msgSender: msgSender,\\n        data: data,\\n        heroToken: dungStatus.heroToken,\\n        heroTokenId: dungStatus.heroTokenId,\\n        objectId: currentObject_,\\n        currentStage: dungStatus.currentStage,\\n        biome: uint(dungAttributes.biome),\\n        statController: ControllerContextLib.statController(cc),\\n        result: a,\\n        stats: IStatController.ChangeableStats(0, 0, 0, 0, 0),\\n        stages: uint(dungStatus.stages),\\n        isBattleObj: false\\n      }),\\n      dungStatus,\\n      dungAttributes,\\n      cc\\n    );\\n  }\\n\\n  /// @notice Make an action with object, update hero params according results\\n  /// @param c Context\\n  /// @return isCompleted The dungeon is completed (there is no new stage to pass)\\n  /// @return newStage Next stage (0 if the dungeon is completed)\\n  /// @return currentObject Id of the current object. It's always 0 if new stage is selected (new object is not opened)\\n  /// @return clear True if dungStatus of the hero should be cleared and the dungeon should be added to free dungeon list\\n  function _objectAction(\\n    ObjectActionInternalData memory c,\\n    IDungeonFactory.DungeonStatus storage dungStatus,\\n    IDungeonFactory.DungeonAttributes storage dungAttributes,\\n    ControllerContextLib.ControllerContext memory cc\\n  ) internal returns (\\n    bool isCompleted,\\n    uint newStage,\\n    uint32 currentObject,\\n    bool clear\\n  ) {\\n    // isCompleted = false;\\n    currentObject = c.objectId;\\n    // newStage = 0;\\n\\n    // check restrictions, most of them are checked by the caller\\n    if (c.objectId == 0) revert IAppErrors.ErrorNotObject2();\\n\\n    c.isBattleObj = ControllerContextLib.gameObjectController(cc).isBattleObject(c.objectId);\\n    c.result = ControllerContextLib.gameObjectController(cc).action(\\n      c.msgSender, c.dungId, c.objectId, c.heroToken, c.heroTokenId, c.currentStage, c.data\\n    );\\n\\n    if (c.isBattleObj) {\\n      _markSkillSlotsForDurabilityReduction(\\n        _S(),\\n        c.statController,\\n        ControllerContextLib.itemController(cc),\\n        c.data,\\n        c.heroToken,\\n        c.heroTokenId\\n      );\\n    }\\n\\n    c.stats = c.statController.heroStats(c.heroToken, c.heroTokenId);\\n    if (c.stats.mana < c.result.manaConsumed.toUint()) {\\n      revert IAppErrors.ErrorNotEnoughMana(c.stats.mana, c.result.manaConsumed.toUint());\\n    }\\n\\n    if (c.result.kill || c.stats.life <= c.result.damage.toUint()) {\\n      c.result.kill = true;\\n      _changeCurrentDungeon(_S(), c.heroToken, c.heroTokenId, 0);\\n      IHeroController hc = ControllerContextLib.heroController(cc);\\n      hc.releaseReinforcement(c.heroToken, c.heroTokenId);\\n\\n      // in case of death we need to remove rewrote objects and reset initial stages\\n      _resetUniqueObjects(dungStatus, dungAttributes);\\n\\n      // no need to release if we completed the dungeon - we will never back on the same\\n      _releaseSkillSlotsForDurabilityReduction(_S(), c.heroToken, c.heroTokenId);\\n\\n      // if it was the last life chance - kill the hero\\n      if (c.stats.lifeChances <= 1) {\\n        _killHero(hc, c.dungId, c.heroToken, c.heroTokenId, dungStatus.treasuryItems);\\n      } else {\\n        _afterObjCompleteForSurvivedHero(c, cc);\\n        _reduceLifeChances(c.statController, c.heroToken, c.heroTokenId, c.stats.life, c.stats.mana);\\n\\n        // scb-1000: soft death resets used consumables\\n        c.statController.clearUsedConsumables(c.heroToken, c.heroTokenId);\\n        // also soft death reset all buffs\\n        c.statController.clearTemporallyAttributes(c.heroToken, c.heroTokenId);\\n      }\\n\\n      // scb-994: increment death count counter\\n      uint deathCounter = c.statController.heroCustomData(c.heroToken, c.heroTokenId, StatControllerLib.DEATH_COUNT_HASH);\\n      c.statController.setHeroCustomData(c.heroToken, c.heroTokenId, StatControllerLib.DEATH_COUNT_HASH, deathCounter + 1);\\n\\n      clear = true;\\n    } else {\\n      _increaseChangeableStats(c.statController, c.heroToken, c.heroTokenId, c.result);\\n      _decreaseChangeableStats(c.statController, c.heroToken, c.heroTokenId, c.result);\\n      _mintItems(c, cc, dungStatus.treasuryItems);\\n      if (c.result.completed) {\\n        _afterObjCompleteForSurvivedHero(c, cc);\\n        (isCompleted, newStage, currentObject) = _nextRoomOrComplete(c, cc, dungStatus, c.stages, dungStatus.treasuryTokens);\\n      }\\n      // clear = false;\\n    }\\n\\n    emit IApplicationEvents.ObjectAction(c.dungId, c.result, c.currentStage, c.heroToken, c.heroTokenId, newStage);\\n    return (isCompleted, newStage, currentObject, clear);\\n  }\\n\\n  /// @notice Hero exists current dungeon forcibly same as when dying but without loosing life chance and keeping all items equipped\\n  /// @dev Dungeon state is cleared outside\\n  function exitForcibly(\\n    address heroToken,\\n    uint heroTokenId,\\n    IDungeonFactory.DungeonStatus storage dungStatus,\\n    IDungeonFactory.DungeonAttributes storage dungAttributes,\\n    ControllerContextLib.ControllerContext memory cc\\n  ) internal {\\n    _changeCurrentDungeon(_S(), heroToken, heroTokenId, 0);\\n    IHeroController hc = ControllerContextLib.heroController(cc);\\n    IStatController sc = ControllerContextLib.statController(cc);\\n\\n    hc.releaseReinforcement(heroToken, heroTokenId);\\n    _resetUniqueObjects(dungStatus, dungAttributes);\\n\\n    // equipped items are NOT taken off\\n    // life => 1, mana => 0\\n    hc.resetLifeAndMana(heroToken, heroTokenId);\\n\\n    sc.clearUsedConsumables(heroToken, heroTokenId);\\n    sc.clearTemporallyAttributes(heroToken, heroTokenId);\\n  }\\n\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ Main logic - auxiliary functions\\n\\n  /// @notice If hero has dead in the dungeon, it's necessary to restore initial set of unique objects,\\n  ///         in other words, all changes introduces by {_nextRoomOrComplete} should be thrown away.\\n  function _resetUniqueObjects(\\n    IDungeonFactory.DungeonStatus storage dungStatus,\\n    IDungeonFactory.DungeonAttributes storage dungAttributes\\n  ) internal {\\n    dungStatus.stages = dungAttributes.stages;\\n    delete dungStatus.uniqObjects;\\n\\n    uint32[] memory uniqObjects = dungAttributes.uniqObjects;\\n    for (uint i; i < uniqObjects.length; ++i) {\\n      dungStatus.uniqObjects.push(uniqObjects[i]);\\n    }\\n  }\\n\\n  /// @notice Kill the hero, take hero's tokens and items\\n  function _killHero(\\n    IHeroController heroController,\\n    uint64 dungId,\\n    address heroToken,\\n    uint heroTokenId,\\n    bytes32[] storage treasuryItems\\n  ) internal {\\n    (bytes32[] memory drop) = heroController.kill(heroToken, heroTokenId);\\n    _putHeroItemToDungeon(dungId, drop, treasuryItems);\\n  }\\n\\n  /// @notice All hero's items are taken by the dungeon\\n  function _putHeroItemToDungeon(uint64 dungId, bytes32[] memory drop, bytes32[] storage treasuryItems) internal {\\n    uint dropLength = drop.length;\\n    for (uint i; i < dropLength; ++i) {\\n      treasuryItems.push(drop[i]);\\n      (address itemAdr, uint itemId) = drop[i].unpackNftId();\\n      emit IApplicationEvents.AddTreasuryItem(dungId, itemAdr, itemId);\\n    }\\n  }\\n\\n  /// @notice If battle object: reduce equipped items durability and clear temporally attributes\\n  /// @dev Not necessary to call if a hero is dead\\n  function _afterObjCompleteForSurvivedHero(\\n    ObjectActionInternalData memory context,\\n    ControllerContextLib.ControllerContext memory cc\\n  ) internal {\\n    if (context.isBattleObj) {\\n      // reduce equipped items durability\\n      ControllerContextLib.itemController(cc).reduceDurability(context.heroToken, context.heroTokenId, uint8(context.biome), false);\\n      // clear temporally attributes\\n      context.statController.clearTemporallyAttributes(context.heroToken, context.heroTokenId);\\n    }\\n  }\\n\\n  /// @notice Check if the dungeon is completed, calculate index of the next stage.\\n  /// @dev Take {rewriteNextObject} from the results of the previous action and set next objects for the dungeon\\n  /// @param curStages Current value of dungStatus.stages\\n  /// @return isCompleted The dungeon is completed\\n  /// @return currentStage Next stage (0 if the dungeon is completed)\\n  /// @return currentObj Always 0. It means, that new current object should be opened.\\n  function _nextRoomOrComplete(\\n    ObjectActionInternalData memory context,\\n    ControllerContextLib.ControllerContext memory cc,\\n    IDungeonFactory.DungeonStatus storage dungStatus,\\n    uint curStages,\\n    EnumerableMap.AddressToUintMap storage treasuryTokens\\n  ) internal returns (\\n    bool isCompleted,\\n    uint currentStage,\\n    uint32 currentObj\\n  ) {\\n    uint len = context.result.rewriteNextObject.length;\\n\\n    if (context.currentStage + 1 >= curStages && len == 0) {\\n      // if we have reduced drop then do not mint token at all\\n      if (StatLib.mintDropChanceDelta(context.stats.experience, context.stats.level, context.biome) == 0) {\\n        _mintGameTokens(\\n          context.dungId,\\n          cc,\\n          StatLib.getVirtualLevel(context.stats.experience, context.stats.level, true),\\n          context.biome,\\n          treasuryTokens,\\n          context.heroToken,\\n          context.heroTokenId\\n        );\\n      }\\n      isCompleted = true;\\n    } else {\\n      // need to extend stages for new rewrite objects size\\n      uint newStages = context.currentStage + 1 + len;\\n      if (curStages < newStages) {\\n        dungStatus.stages = uint8(newStages);\\n\\n        // need to extend exist array\\n        dungStatus.uniqObjects = new uint32[](newStages);\\n        // no need to write again old uniq objects, they will be updated in case of hero death\\n      }\\n\\n      for (uint i; i < len; ++i) {\\n        uint32 nextObjId = context.result.rewriteNextObject[i];\\n        dungStatus.uniqObjects[context.currentStage + 1 + i] = nextObjId;\\n      }\\n\\n      currentStage = context.currentStage + 1;\\n    }\\n\\n    // currentObj is 0 by default\\n    return (isCompleted, currentStage, currentObj);\\n  }\\n\\n  /// @notice Increase life, mana and lifeChances according to the action {result}\\n  function _increaseChangeableStats(\\n    IStatController statController,\\n    address heroToken,\\n    uint heroTokenId,\\n    IGOC.ActionResult memory result\\n  ) internal {\\n    if (result.heal != 0 || result.manaRegen != 0 || result.experience != 0 || result.lifeChancesRecovered != 0) {\\n      statController.changeCurrentStats(\\n        heroToken,\\n        heroTokenId,\\n        IStatController.ChangeableStats({\\n          level: 0,\\n          experience: result.experience,\\n          life: uint32(result.heal.toUint()),\\n          mana: uint32(result.manaRegen.toUint()),\\n          lifeChances: uint32(result.lifeChancesRecovered.toUint())\\n        }),\\n        true\\n      );\\n    }\\n  }\\n\\n  /// @notice Decrease life and mana according to the action {result}\\n  function _decreaseChangeableStats(\\n    IStatController statController,\\n    address heroToken,\\n    uint heroTokenId,\\n    IGOC.ActionResult memory result\\n  ) internal {\\n    // decrease changeable stats\\n    if (result.damage != 0 || result.manaConsumed != 0) {\\n      statController.changeCurrentStats(\\n        heroToken,\\n        heroTokenId,\\n        IStatController.ChangeableStats({\\n          level: 0,\\n          experience: 0,\\n          life: uint32(result.damage.toUint()),\\n          mana: uint32(result.manaConsumed.toUint()),\\n          lifeChances: 0\\n        }),\\n        false\\n      );\\n    }\\n  }\\n\\n  /// @notice Decrease lifeChances on 1, restore life and mana to full\\n  function _reduceLifeChances(IStatController statController, address hero, uint heroId, uint32 curLife, uint32 curMana) internal {\\n    uint32 lifeFull = uint32(CalcLib.toUint(statController.heroAttribute(hero, heroId, uint(IStatController.ATTRIBUTES.LIFE))));\\n    uint32 manaFull = uint32(CalcLib.toUint(statController.heroAttribute(hero, heroId, uint(IStatController.ATTRIBUTES.MANA))));\\n\\n    // --------- reduce life chance\\n    statController.changeCurrentStats(\\n      hero,\\n      heroId,\\n      IStatController.ChangeableStats({level: 0, experience: 0, life: 0, mana: 0, lifeChances: 1}),\\n      false\\n    );\\n\\n    // --------- restore life and mana to full\\n    statController.changeCurrentStats(\\n      hero,\\n      heroId,\\n      IStatController.ChangeableStats({\\n        level: 0,\\n        experience: 0,\\n        life: AppLib.sub0(lifeFull, curLife),\\n        mana: AppLib.sub0(manaFull, curMana),\\n        lifeChances: 0\\n      }),\\n      true\\n    );\\n  }\\n\\n  /// @notice Mint mint-items from {result}, add them to {treasuryItems}\\n  function _mintItems(\\n    ObjectActionInternalData memory context,\\n    ControllerContextLib.ControllerContext memory cc,\\n    bytes32[] storage treasuryItems\\n  ) internal {\\n    uint64 dungId = context.dungId;\\n    IGOC.ActionResult memory result = context.result;\\n\\n    IItemController ic = ControllerContextLib.itemController(cc);\\n\\n    for (uint i; i < result.mintItems.length; i++) {\\n      if (result.mintItems[i] == address(0)) {\\n        continue;\\n      }\\n      uint itemId = ic.mint(result.mintItems[i], address(this));\\n      treasuryItems.push(result.mintItems[i].packNftId(itemId));\\n      emit IApplicationEvents.AddTreasuryItem(dungId, result.mintItems[i], itemId);\\n    }\\n  }\\n\\n  /// @notice Register game-token in {treasuryTokens}, mint dungeon reward\\n  function _mintGameTokens(\\n    uint64 dungId,\\n    ControllerContextLib.ControllerContext memory cc,\\n    uint lvlForMint,\\n    uint biome,\\n    EnumerableMap.AddressToUintMap storage treasuryTokens,\\n    address hero,\\n    uint heroId\\n  ) private {\\n    IHeroController heroController = ControllerContextLib.heroController(cc);\\n    uint maxOpenedNgLevel = heroController.maxOpenedNgLevel();\\n    uint heroNgLevel = heroController.getHeroInfo(hero, heroId).ngLevel;\\n\\n    IGameToken gameToken = ControllerContextLib.gameToken(cc);\\n    uint amount = IMinter(gameToken.minter()).mintDungeonReward(dungId, biome, lvlForMint);\\n    // Total amount of rewards should be equal to: reward = normal_reward * (1 + NG_LVL) / ng_sum\\n    // We have minted {amount}, so we should burn off {amount - reward}.\\n    // {amount} is exactly equal to {reward} only if NG_LVL is 0\\n    uint reward = amount * (1 + heroNgLevel) / RewardsPoolLib.getNgSum(maxOpenedNgLevel);\\n    if (amount > reward) {\\n      gameToken.burn(amount - reward);\\n      amount = reward;\\n    }\\n    \\n    _registerTreasuryToken(address(gameToken), treasuryTokens, amount);\\n    emit IApplicationEvents.AddTreasuryToken(dungId, address(gameToken), amount);\\n  }\\n\\n  /// @notice Add {rewardToken} to {treasuryTokens} if it's not add there already\\n  function _registerTreasuryToken(address rewardToken, EnumerableMap.AddressToUintMap storage treasuryTokens, uint amount) internal {\\n    (bool exist, uint existAmount) = treasuryTokens.tryGet(rewardToken);\\n\\n    if (!exist || existAmount + amount > 0) {\\n      uint balance = IERC20(rewardToken).balanceOf(address(this));\\n      if (balance < existAmount + amount) {\\n        revert IAppErrors.NotEnoughTokens(balance, existAmount + amount);\\n      }\\n\\n      treasuryTokens.set(rewardToken, existAmount + amount);\\n    }\\n  }\\n  //endregion ------------------------ Main logic - auxiliary functions\\n\\n  //region ------------------------ ENTER/EXIT\\n\\n  /// @notice Hero enters to the dungeon. Check requirements before entering, update status of the hero and the dungeon.\\n  function _enter(\\n    ControllerContextLib.ControllerContext memory cc,\\n    IDungeonFactory.DungeonStatus storage dungStatus,\\n    IDungeonFactory.DungeonAttributes storage dungAttrs,\\n    uint16 dungNum,\\n    uint64 dungId,\\n    address heroToken,\\n    uint heroTokenId\\n  ) internal {\\n    IDungeonFactory.MainState storage s = _S();\\n\\n    IStatController.ChangeableStats memory stats = ControllerContextLib.statController(cc).heroStats(heroToken, heroTokenId);\\n    uint8 dungBiome = dungAttrs.biome;\\n\\n    if (ControllerContextLib.reinforcementController(cc).isStaked(heroToken, heroTokenId)) revert IAppErrors.Staked(heroToken, heroTokenId);\\n    {\\n      IPvpController pc = ControllerContextLib.pvpController(cc);\\n      if (address(pc) != address(0) && pc.isHeroStakedCurrently(heroToken, heroTokenId)) revert IAppErrors.PvpStaked();\\n    }\\n\\n    if (stats.lifeChances == 0) revert IAppErrors.ErrorHeroIsDead(heroToken, heroTokenId);\\n    if (s.heroCurrentDungeon[heroToken.packNftId(heroTokenId)] != 0) revert IAppErrors.ErrorAlreadyInDungeon();\\n    // assume here that onlyEnteredHeroOwner is already checked by the caller\\n\\n    if (ControllerContextLib.heroController(cc).heroBiome(heroToken, heroTokenId) != dungBiome) revert IAppErrors.ErrorNotBiome();\\n    if (dungStatus.heroToken != address(0)) revert IAppErrors.ErrorDungeonBusy();\\n    if (!isDungeonEligibleForHero(s, ControllerContextLib.statController(cc), dungNum, uint8(stats.level), heroToken, heroTokenId)) {\\n      revert IAppErrors.ErrorNotEligible(heroToken, dungNum);\\n    }\\n\\n    // remove free dungeon\\n    if (s.freeDungeons[dungBiome].remove(uint(dungId))) {\\n      emit IApplicationEvents.FreeDungeonRemoved(dungBiome, dungId);\\n    }\\n\\n    _changeCurrentDungeon(s, heroToken, heroTokenId, dungId);\\n    if (dungStatus.currentStage != 0) {\\n      dungStatus.currentStage = uint8(0);\\n    }\\n    dungStatus.heroToken = heroToken;\\n    dungStatus.heroTokenId = heroTokenId;\\n\\n    emit IApplicationEvents.Entered(dungId, heroToken, heroTokenId);\\n  }\\n\\n  /// @notice Check if dungeon is eligible for the hero\\n  /// @param dungNum Dungeon logic id\\n  function isDungeonEligibleForHero(\\n    IDungeonFactory.MainState storage s,\\n    IStatController statController,\\n    uint16 dungNum,\\n    uint8 heroLevel,\\n    address heroToken,\\n    uint heroTokenId\\n  ) internal view returns (bool) {\\n    IDungeonFactory.DungeonAttributes storage dungAttr = s.dungeonAttributes[dungNum];\\n\\n    // check if the hero level is in the range required by the dungeon\\n    {\\n      (uint minLevel, uint maxLevel,) = dungAttr.minMaxLevel.unpackUint8Array3();\\n      if (heroLevel < minLevel || heroLevel > maxLevel) {\\n        return false;\\n      }\\n    }\\n\\n    // check if hero/global custom values are in the ranges required by the dungeon\\n    bytes32[] memory requiredCustomDataIndex = dungAttr.requiredCustomDataIndex;\\n    bytes32[] memory requiredCustomDataValue = dungAttr.requiredCustomDataValue;\\n\\n    uint len = requiredCustomDataIndex.length;\\n    for (uint i; i < len; ++i) {\\n      bytes32 index = requiredCustomDataIndex[i];\\n      if (index == bytes32(0)) continue;\\n\\n      (uint64 min, uint64 max, bool isHeroValue) = requiredCustomDataValue[i].unpackCustomDataRequirements();\\n\\n      uint value = isHeroValue\\n        ? statController.heroCustomData(heroToken, heroTokenId, index)\\n        : statController.globalCustomData(index);\\n\\n      if (value < uint(min) || value > uint(max)) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Select logic for the new dungeon\\n  function getDungeonLogic(\\n    IDungeonFactory.MainState storage s_,\\n    ControllerContextLib.ControllerContext memory cc,\\n    uint8 heroLevel,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint random\\n  ) internal view returns (uint16) {\\n    if (heroLevel == 0) revert IAppErrors.ErrorHeroLevelStartFrom1();\\n\\n    uint8 heroBiome;\\n    {\\n      IHeroController hc = ControllerContextLib.heroController(cc);\\n      heroBiome = hc.heroBiome(heroToken, heroTokenId);\\n\\n      // try to get specific dungeon\\n      // specific dungeon for concrete level and class\\n      uint16 specificDungeon = s_.dungeonSpecific[_toUint8PackedArray(heroLevel / uint8(StatLib.BIOME_LEVEL_STEP) + 1, hc.heroClass(heroToken))];\\n      // if no specific dungeon for concrete class try to find for all classes\\n      if (specificDungeon == 0) {\\n        specificDungeon = s_.dungeonSpecific[_toUint8PackedArray(heroLevel / uint8(StatLib.BIOME_LEVEL_STEP) + 1, 0)];\\n      }\\n      // if no specific dungeon for concrete class and level try to find for all classes and all levels\\n      if (specificDungeon == 0) {\\n        // in this case we have 1 specific dungeon for all classes and levels, and only 1, suppose to be initial territory\\n        specificDungeon = s_.dungeonSpecific[_toUint8PackedArray(0, 0)];\\n      }\\n\\n      if (specificDungeon != 0) {\\n        if (!s_.specificDungeonCompleted[heroToken.packDungeonKey(uint64(heroTokenId), specificDungeon)]\\n        && s_.dungeonAttributes[specificDungeon].biome == heroBiome) {\\n          return specificDungeon;\\n        }\\n      }\\n    }\\n\\n    EnumerableSet.UintSet storage dungs = s_.dungeonsLogicByBiome[heroBiome];\\n    uint size = dungs.length();\\n    if (size == 0) revert IAppErrors.ErrorNoDungeonsForBiome(heroBiome);\\n\\n    IStatController statController = ControllerContextLib.statController(cc);\\n    uint16 dungeonLogic;\\n    uint dungeonIndex = random % size;\\n    for (uint i; i < size; ++i) {\\n      dungeonLogic = uint16(dungs.at(dungeonIndex));\\n\\n      if (isDungeonEligibleForHero(s_, statController, dungeonLogic, heroLevel, heroToken, heroTokenId)) {\\n        return dungeonLogic;\\n      }\\n      dungeonIndex++;\\n      if (dungeonIndex >= size) {\\n        dungeonIndex = 0;\\n      }\\n    }\\n\\n    revert IAppErrors.ErrorNoEligibleDungeons();\\n  }\\n\\n  /// @notice Exit the dungeon\\n  /// @param claim Claim treasure items and tokens\\n  function exitDungeon(IController controller, uint64 dungId, bool claim, address msgSender) external {\\n    IDungeonFactory.DungeonStatus storage dungStatus = _S().dungeonStatuses[dungId];\\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(controller);\\n    address heroToken = dungStatus.heroToken;\\n    uint heroTokenId = dungStatus.heroTokenId;\\n\\n    if (!dungStatus.isCompleted) revert IAppErrors.ErrorNotCompleted();\\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\\n    if (IERC721(heroToken).ownerOf(heroTokenId) != msgSender) revert IAppErrors.ErrorNotOwner(heroToken, heroTokenId);\\n    if (_S().heroCurrentDungeon[heroToken.packNftId(heroTokenId)] != dungId) revert IAppErrors.ErrorHeroNotInDungeon();\\n\\n    IHeroController heroController = ControllerContextLib.heroController(cc);\\n    (address payToken,) = heroController.payTokenInfo(heroToken);\\n\\n    uint16 dungNum = dungStatus.dungNum;\\n    _setDungeonCompleted(_S(), dungNum, dungId, heroToken, heroTokenId);\\n\\n    if (claim) {\\n      _claimAll(cc, msgSender, dungId, dungNum, dungStatus, heroToken, heroTokenId, payToken);\\n    }\\n    _heroExit(_S(), heroController, heroToken, heroTokenId);\\n\\n    if (payToken == address(0)) {\\n      // F2P hero doesn't have pay token, he is destroyed after exit of the dungeon\\n      _killHero(heroController, dungId, heroToken, heroTokenId, dungStatus.treasuryItems);\\n    }\\n\\n    // register daily activity\\n    address userController = controller.userController();\\n    if (userController != address(0)) {\\n      if (heroController.sandboxMode(heroToken, heroTokenId) != uint8(IHeroController.SandboxMode.SANDBOX_MODE_1)) {\\n        IUserController(userController).registerPassedDungeon(msgSender);\\n      }\\n    }\\n\\n    emit IApplicationEvents.Exit(dungId, claim);\\n  }\\n\\n  /// @notice Emergency exit: the governance can drop the hero from dungeon in emergency\\n  function emergencyExit(IController controller, uint64 dungId) external {\\n    IDungeonFactory.MainState storage s = _S();\\n    // assume that governance-restriction is checked on caller side\\n    IDungeonFactory.DungeonStatus storage dungStatus = s.dungeonStatuses[dungId];\\n\\n    _heroExit(s, IHeroController(controller.heroController()), dungStatus.heroToken, dungStatus.heroTokenId);\\n\\n    dungStatus.isCompleted = true;\\n    dungStatus.heroToken = address(0);\\n    dungStatus.heroTokenId = 0;\\n\\n    emit IApplicationEvents.Exit(dungId, false);\\n  }\\n\\n  //endregion ------------------------ ENTER/EXIT\\n\\n  //region ------------------------ ENTER/EXIT auxiliary functions\\n  /// @dev this function should emit event to indicate dungeon remove\\n  function _setDungeonCompleted(IDungeonFactory.MainState storage s, uint16 dungNum, uint64 dungeonId, address heroToken, uint heroTokenId) internal {\\n    if (s.allSpecificDungeons.contains(dungNum)) {\\n      s.specificDungeonCompleted[heroToken.packDungeonKey(uint64(heroTokenId), dungNum)] = true;\\n    }\\n    emit IApplicationEvents.DungeonCompleted(dungNum, dungeonId, heroToken, heroTokenId);\\n  }\\n\\n  /// @notice Change current dungeon of the hero to 0 and release his reinforcement\\n  function _heroExit(IDungeonFactory.MainState storage s, IHeroController heroController, address heroToken, uint heroTokenId) internal {\\n    _changeCurrentDungeon(s, heroToken, heroTokenId, 0);\\n    heroController.releaseReinforcement(heroToken, heroTokenId);\\n  }\\n\\n  /// @notice Change current dungeon of the hero to the {dungeonId}\\n  function _changeCurrentDungeon(IDungeonFactory.MainState storage s, address hero, uint heroId, uint64 dungeonId) internal {\\n    s.heroCurrentDungeon[hero.packNftId(heroId)] = dungeonId;\\n    emit IApplicationEvents.HeroCurrentDungeonChanged(hero, heroId, dungeonId);\\n  }\\n\\n  /// @notice Enumerate busy slots of the hero, find all SKILL_XXX and return their addresses and ids\\n  /// @return skillSlotAdr Addresses of available skills. 0 - SKILL_1, 1 - SKILL_2, 2 - SKILL_3.\\n  ///                      Address is zero if the hero doesn't have the corresponded skill.\\n  /// @return skillSlotIds Ids of available skills. 0 - SKILL_1, 1 - SKILL_2, 2 - SKILL_3\\n  ///                      ID is zero if the hero doesn't have the corresponded skill.\\n  function _getSkillSlotsForHero(IStatController statCtr, address heroToken, uint heroTokenId) internal view returns (\\n    address[3] memory skillSlotAdr,\\n    uint[3] memory skillSlotIds\\n  ) {\\n    uint8[] memory busySlots = statCtr.heroItemSlots(heroToken, uint64(heroTokenId));\\n\\n    for (uint i; i < busySlots.length; ++i) {\\n      if (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_1)) {\\n        (skillSlotAdr[0], skillSlotIds[0]) = statCtr.heroItemSlot(heroToken, uint64(heroTokenId), busySlots[i]).unpackNftId();\\n      }\\n      if (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_2)) {\\n        (skillSlotAdr[1], skillSlotIds[1]) = statCtr.heroItemSlot(heroToken, uint64(heroTokenId), busySlots[i]).unpackNftId();\\n      }\\n      if (busySlots[i] == uint8(IStatController.ItemSlots.SKILL_3)) {\\n        (skillSlotAdr[2], skillSlotIds[2]) = statCtr.heroItemSlot(heroToken, uint64(heroTokenId), busySlots[i]).unpackNftId();\\n      }\\n    }\\n\\n    return (skillSlotAdr, skillSlotIds);\\n  }\\n\\n  /// @notice Generate map[3] for SKILL_1, SKILL_2, SKILL_3 (0 - not marked, 1 - marked)\\n  ///         and save the map to {s_}._skillSlotsForDurabilityReduction as packed uint8[]\\n  /// @dev mark skill slots for durability reduction\\n  /// SIP-001: take into account hero's skills only and ignore skills of the helper\\n  /// @param data abi.encoded IFightCalculator.AttackInfo\\n  function _markSkillSlotsForDurabilityReduction(\\n    IDungeonFactory.MainState storage s_,\\n    IStatController sc,\\n    IItemController itemController,\\n    bytes memory data,\\n    address heroToken,\\n    uint heroTokenId\\n  ) internal {\\n    uint8[] memory map = new uint8[](3);\\n    (IFightCalculator.AttackInfo memory attackInfo) = abi.decode(data, (IFightCalculator.AttackInfo));\\n\\n    uint length = attackInfo.skillTokens.length;\\n\\n    if (length != 0 || attackInfo.attackToken != address(0)) {\\n\\n      (address[3] memory skillSlotAdr, uint[3] memory skillSlotIds) = _getSkillSlotsForHero(sc, heroToken, heroTokenId);\\n\\n      for (uint i; i < length; ++i) {\\n        address token = attackInfo.skillTokens[i];\\n        uint tokenId = attackInfo.skillTokenIds[i];\\n\\n        // The hero is able to use own skills OR the skills of the helper. Take into account only own hero's skills here\\n        (address h,) = itemController.equippedOn(token, tokenId);\\n        if (h == heroToken) {\\n          if (token == skillSlotAdr[0] && tokenId == skillSlotIds[0]) {\\n            map[0] = 1;\\n          } else if (token == skillSlotAdr[1] && tokenId == skillSlotIds[1]) {\\n            map[1] = 1;\\n          } else if (token == skillSlotAdr[2] && tokenId == skillSlotIds[2]) {\\n            map[2] = 1;\\n          }\\n        }\\n      }\\n\\n      if (attackInfo.attackToken == skillSlotAdr[0] && attackInfo.attackTokenId == skillSlotIds[0]) {\\n        map[0] = 1;\\n      } else if (attackInfo.attackToken == skillSlotAdr[1] && attackInfo.attackTokenId == skillSlotIds[1]) {\\n        map[1] = 1;\\n      } else if (attackInfo.attackToken == skillSlotAdr[2] && attackInfo.attackTokenId == skillSlotIds[2]) {\\n        map[2] = 1;\\n      }\\n    }\\n\\n    // write even empty map for clear prev values\\n    s_.skillSlotsForDurabilityReduction[heroToken.packNftId(heroTokenId)] = map.packUint8Array();\\n  }\\n\\n  /// @dev clear all skill slots marks\\n  function _releaseSkillSlotsForDurabilityReduction(IDungeonFactory.MainState storage s_, address heroToken, uint heroTokenId) internal {\\n    delete s_.skillSlotsForDurabilityReduction[heroToken.packNftId(heroTokenId)];\\n  }\\n\\n  //endregion ------------------------ ENTER/EXIT auxiliary functions\\n\\n  //region ------------------------ CLAIM\\n\\n  /// @notice Calculate amount of biome owner tax\\n  /// @return taxPercent Percent of tax that is taken if favor of biome owner, decimals 3\\n  /// @return guildBank Address of guild bank of the biome owner\\n  /// @return guildId The owner of the biome\\n  function _getBiomeTax(\\n    uint8 biome,\\n    ControllerContextLib.ControllerContext memory cc\\n  ) internal returns (\\n    uint taxPercent,\\n    address guildBank,\\n    uint guildId\\n  ) {\\n    IPvpController pvpController = ControllerContextLib.pvpController(cc);\\n    if (address(pvpController) != address(0)) {\\n      (uint _guildId, uint _taxPercent) = pvpController.refreshBiomeTax(biome);\\n      if (_guildId != 0) {\\n        // assume that guildController cannot be 0 if pvp controller is set\\n        guildBank = ControllerContextLib.guildController(cc).getGuildBank(_guildId);\\n        if (guildBank != address(0)) {\\n          guildId = _guildId;\\n          taxPercent = _taxPercent;\\n        }\\n      }\\n    }\\n\\n    return (taxPercent, guildBank, guildId);\\n  }\\n\\n  /// @notice Claim all treasure tokens and items registered for the given hero.\\n  ///         At first the tax is taken in favor of biome owner if any.\\n  ///         Remain tokens are send to msgSender and/or helper, or they can be send to controller or burned.\\n  ///         The items are transferred to msgSender or helper (random choice) or destroyed (F2P hero).\\n  /// @dev ClaimContext is used both for lazy initialization and to extend limits of allowed local vars.\\n  /// @param heroPayToken Hero pay token. It's zero for hero 5.\\n  function _claimAll(\\n    ControllerContextLib.ControllerContext memory cc,\\n    address msgSender,\\n    uint64 dungId,\\n    uint16 dungNum,\\n    IDungeonFactory.DungeonStatus storage dungStatus,\\n    address hero,\\n    uint heroId,\\n    address heroPayToken\\n  ) internal {\\n    ClaimContext memory context;\\n\\n    context.msgSender = msgSender;\\n    context.dungId = dungId;\\n\\n    (context.helpHeroToken, context.helpHeroId) = ControllerContextLib.heroController(cc).heroReinforcementHelp(hero, heroId);\\n    context.toHelperRatio = ControllerContextLib.reinforcementController(cc).toHelperRatio(context.helpHeroToken, context.helpHeroId);\\n\\n    context.itemLength = dungStatus.treasuryItems.length;\\n    context.tokenLength = dungStatus.treasuryTokens.length();\\n    context.tokens = new address[](context.tokenLength);\\n    context.amounts = new uint[](context.tokenLength);\\n\\n    IDungeonFactory.DungeonAttributes storage dungAttrs = _S().dungeonAttributes[dungNum];\\n    context.biome = dungAttrs.biome;\\n    (context.taxPercent, context.guildBank, context.guildId) = _getBiomeTax(context.biome, cc);\\n\\n    context.heroPayToken = heroPayToken;\\n    context.sandboxMode = ControllerContextLib.heroController(cc).sandboxMode(hero, heroId);\\n\\n    // need to write tokens separately coz we need to delete them from map\\n    for (uint i; i < context.tokenLength; i++) {\\n      (context.tokens[i], context.amounts[i]) = dungStatus.treasuryTokens.at(i);\\n    }\\n\\n    for (uint i; i < context.tokenLength; i++) {\\n      _claimToken(dungStatus.treasuryTokens, context, cc, context.tokens[i], context.amounts[i]);\\n    }\\n\\n    if (context.sandboxMode == uint8(IHeroController.SandboxMode.SANDBOX_MODE_1) && context.itemLength != 0) {\\n      context.items = new address[](context.itemLength);\\n      context.itemIds = new uint[](context.itemLength);\\n      context.countItems = 0;\\n    }\\n\\n    for (uint i; i < context.itemLength; i++) {\\n      (address itemAdr, uint itemId) = dungStatus.treasuryItems[i].unpackNftId();\\n      if (_claimItem(context, cc, itemAdr, itemId)) {\\n        // the item was already sent to itemBoxController, we need to call registerItems() for it below\\n        context.items[context.countItems] = itemAdr;\\n        context.itemIds[context.countItems] = itemId;\\n        context.countItems += 1;\\n      }\\n    }\\n\\n    if (context.sandboxMode == uint8(IHeroController.SandboxMode.SANDBOX_MODE_1) && context.countItems != 0) {\\n      // Too much code is required to cut two arrays to required length here.\\n      // It's easier to ignore unnecessary items on ItemBox side.\\n      ControllerContextLib.itemBoxController(cc).registerItems(hero, heroId, context.items, context.itemIds, context.countItems);\\n    }\\n\\n    delete dungStatus.treasuryItems;\\n  }\\n\\n  /// @notice Remove {token} from treasuryTokens, transfer/burn token {amount}\\n  function _claimToken(\\n    EnumerableMap.AddressToUintMap storage treasuryTokens,\\n    ClaimContext memory context,\\n    ControllerContextLib.ControllerContext memory cc,\\n    address token,\\n    uint amount\\n  ) internal {\\n\\n    treasuryTokens.remove(token);\\n    if (amount != 0) {\\n      if (context.heroPayToken == address(0)) {\\n        if (token == address(ControllerContextLib.gameToken(cc))) {\\n          IGameToken(token).burn(amount);\\n        } else {\\n          IERC20(token).transfer(address(cc.controller), amount);\\n        }\\n\\n      } else {\\n        if (context.sandboxMode == uint8(IHeroController.SandboxMode.SANDBOX_MODE_1)) {\\n          // send treasury back to the Treasury in sandbox mode, assume that amount != 0 here\\n          IERC20(token).transfer(address(ControllerContextLib.treasury(cc)), amount);\\n          emit IApplicationEvents.SandboxReturnAmountToTreasury(context.dungId, token, amount);\\n        } else {\\n          // get tax in favor of biome owner if any\\n          uint amountMinusTax = amount;\\n          if (context.taxPercent != 0 && context.guildBank != address(0)) {\\n            uint taxAmount = amount * context.taxPercent / 100_000;\\n            IERC20(token).transfer(context.guildBank, taxAmount); // assume that taxAmount is not 0 here\\n            amountMinusTax -= taxAmount;\\n            emit IApplicationEvents.BiomeTaxPaid(context.msgSender, context.biome, context.guildId, amount, context.taxPercent, taxAmount);\\n          }\\n\\n          uint toHelper = context.helpHeroToken == address(0)\\n            ? 0\\n            : amountMinusTax * context.toHelperRatio / 100;\\n\\n          uint toHeroOwner = amountMinusTax - toHelper;\\n          if (toHeroOwner != 0) {\\n            IERC20(token).transfer(context.msgSender, toHeroOwner);\\n          }\\n\\n          if (toHelper != 0) {\\n            IReinforcementController reinforcementController = ControllerContextLib.reinforcementController(cc);\\n            IERC20(token).transfer(address(reinforcementController), toHelper);\\n            reinforcementController.registerTokenReward(context.helpHeroToken, context.helpHeroId, token, toHelper);\\n          }\\n\\n          emit IApplicationEvents.ClaimToken(context.dungId, token, amount);\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Destroy item (for F2P) or transfer the item to helper/sender (random choice)\\n  /// @return itemWasSentToItemBoxController True if ItemBoxController.registerItems() must be called after the call\\n  function _claimItem(\\n    ClaimContext memory context,\\n    ControllerContextLib.ControllerContext memory cc,\\n    address token,\\n    uint tokenId\\n  ) internal returns (bool itemWasSentToItemBoxController) {\\n    if (IERC721(token).ownerOf(tokenId) == address(this)) {\\n\\n      if (context.heroPayToken == address(0)) {\\n        // if it is F2P hero destroy all drop (not applicable for sandbox)\\n        ControllerContextLib.itemController(cc).destroy(token, tokenId);\\n      } else {\\n        // get tax in favor of biome owner if any\\n        bool toBiomeOwner = false;\\n        if (context.taxPercent != 0 && context.guildBank != address(0)) {\\n          toBiomeOwner = ControllerContextLib.oracle(cc).getRandomNumber(100_000, 0) < context.taxPercent;\\n        }\\n\\n        bool toHelper = false;\\n        if (!toBiomeOwner && context.helpHeroToken != address(0)) {\\n          toHelper = ControllerContextLib.oracle(cc).getRandomNumber(100, 0) < context.toHelperRatio;\\n        }\\n\\n        if (toBiomeOwner) {\\n          // SCR-1253: Attention: GuildBank with version below 1.0.2 was not inherited from ERC721Holder (mistake).\\n          // As result, safeTransferFrom doesn't work with such banks, they must be updated. So, use transferFrom here.\\n          IERC721(token).transferFrom(address(this), context.guildBank, tokenId);\\n          emit IApplicationEvents.BiomeTaxPaidNft(context.msgSender, context.biome, context.guildId, token, tokenId, context.taxPercent);\\n        } else if (toHelper) {\\n          IReinforcementController reinforcementController = ControllerContextLib.reinforcementController(cc);\\n          IERC721(token).safeTransferFrom(address(this), address(reinforcementController), tokenId);\\n          reinforcementController.registerNftReward(context.helpHeroToken, context.helpHeroId, token, tokenId);\\n        } else {\\n          if (context.sandboxMode == uint8(IHeroController.SandboxMode.SANDBOX_MODE_1)) {\\n            IItemBoxController itemBoxController = ControllerContextLib.itemBoxController(cc);\\n            IERC721(token).safeTransferFrom(address(this), address(itemBoxController), tokenId);\\n            itemWasSentToItemBoxController = true; // notify caller that registerItems() should be called\\n          } else {\\n            IERC721(token).safeTransferFrom(address(this), context.msgSender, tokenId);\\n          }\\n        }\\n\\n        emit IApplicationEvents.ClaimItem(context.dungId, token, tokenId);\\n      }\\n    }\\n\\n    return itemWasSentToItemBoxController;\\n  }\\n  //endregion ------------------------ CLAIM\\n\\n  //region ------------------------ Utils\\n  function _toUint8PackedArray(uint8 val0, uint8 val1) internal pure returns (bytes32 key) {\\n    return PackingLib.packUint8Array3(val0, val1, 0);\\n  }\\n\\n  function _toUint8ArrayWithoutZeroes(bytes32 data) internal pure returns (uint8[] memory result) {\\n    uint8[] memory arr = data.unpackUint8Array();\\n\\n    uint newSize;\\n    for (uint i; i < arr.length; ++i) {\\n      if (arr[i] == 0) {\\n        break;\\n      }\\n      newSize++;\\n    }\\n\\n    result = new uint8[](newSize);\\n    for (uint i; i < newSize; ++i) {\\n      result[i] = arr[i];\\n    }\\n  }\\n  //endregion ------------------------ Utils\\n}\\n\",\"keccak256\":\"0x402548ae0aa8098e6e8dcaf73a9562f51ea0154887eb76630b7f0b9d5b23c9a2\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PackingLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\n\\nlibrary PackingLib {\\n\\n  //////////////////////////\\n  // ---- PACKING LOGIC ----\\n  //////////////////////////\\n\\n  //region ------------------------------------ COMMON\\n\\n  function packNftId(address token, uint id) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert IAppErrors.TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n  }\\n\\n  function unpackNftId(bytes32 data) internal pure returns (address token, uint id) {\\n    token = address(uint160(uint(data)));\\n    id = uint(data) >> 160;\\n  }\\n\\n  function packAddressWithAmount(address token, uint amount) internal pure returns (bytes32 data) {\\n    if (amount > uint(type(uint96).max)) revert IAppErrors.TooHighValue(amount);\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(uint96(amount))) << 160;\\n  }\\n\\n  function unpackAddressWithAmount(bytes32 data) internal pure returns (address token, uint amount) {\\n    token = address(uint160(uint(data)));\\n    amount = uint(data) >> 160;\\n  }\\n\\n  function packItemMintInfo(address item, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(chance)) << 160;\\n  }\\n\\n  function unpackItemMintInfo(bytes32 data) internal pure returns (address item, uint32 chance) {\\n    item = address(uint160(uint(data)));\\n    chance = uint32(uint(data) >> 160);\\n  }\\n\\n  /// @param customDataIndex We assume, that two lowest bytes of this string are always zero\\n  /// So, the string looks like following: 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// Last 2 bytes will be used to encode {value}\\n  function packCustomDataChange(bytes32 customDataIndex, int16 value) internal pure returns (bytes32 data) {\\n    if (uint(customDataIndex) != (uint(customDataIndex) >> 16) << 16) revert IAppErrors.IncompatibleInputString();\\n    data = bytes32(uint(customDataIndex));\\n    data |= bytes32(uint(uint16(value)));\\n  }\\n\\n  function unpackCustomDataChange(bytes32 data) internal pure returns (bytes32 customDataIndex, int16 value) {\\n    customDataIndex = bytes32((uint(data) >> 16) << 16);\\n    value = int16(int(uint(uint16(uint(data)))));\\n  }\\n\\n  /// @dev min(uint64) + max(uint64) + isHeroData/isMandatory(uint8)\\n  function packCustomDataRequirements(uint64 min, uint64 max, bool key) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(min));\\n    data |= bytes32(uint(max)) << 64;\\n    data |= bytes32(uint(key ? uint8(1) : uint8(0))) << (64 + 64);\\n  }\\n\\n  function unpackCustomDataRequirements(bytes32 data) internal pure returns (uint64 min, uint64 max, bool key) {\\n    min = uint64(uint(data));\\n    max = uint64(uint(data) >> 64);\\n    key = uint8(uint(data) >> (64 + 64)) == uint8(1);\\n  }\\n\\n  function packStatsChange(\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(experience));\\n    data |= bytes32(uint(uint32(heal))) << 32;\\n    data |= bytes32(uint(uint32(manaRegen))) << (32 + 32);\\n    data |= bytes32(uint(uint32(lifeChancesRecovered))) << (32 + 32 + 32);\\n    data |= bytes32(uint(uint32(damage))) << (32 + 32 + 32 + 32);\\n    data |= bytes32(uint(uint32(manaConsumed))) << (32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackStatsChange(bytes32 data) internal pure returns (\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) {\\n    experience = uint32(uint(data));\\n    heal = int32(int(uint(data) >> 32));\\n    manaRegen = int32(int(uint(data) >> (32 + 32)));\\n    lifeChancesRecovered = int32(int(uint(data) >> (32 + 32 + 32)));\\n    damage = int32(int(uint(data) >> (32 + 32 + 32 + 32)));\\n    manaConsumed = int32(int(uint(data) >> (32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packNftIdWithValue(address token, uint id, uint32 value) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert IAppErrors.TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n    serialized |= bytes32(uint(value)) << 160 + 64;\\n  }\\n\\n  function unpackNftIdWithValue(bytes32 data) internal pure returns (address token, uint id, uint32 value) {\\n    token = address(uint160(uint(data)));\\n    id = uint64(uint(data) >> 160);\\n    value = uint32(uint(data) >> 160 + 64);\\n  }\\n  //endregion ------------------------------------ COMMON\\n\\n  //region ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(bytes20(objectAddress));\\n    packedData |= bytes32(uint(objectId) << 32);\\n    packedData |= bytes32(uint(objectType) << 24);\\n  }\\n\\n  function unpackMapObject(bytes32 packedData) internal pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\\n    objectAddress = address(bytes20(packedData));\\n    objectId = uint64(uint(packedData) >> 32);\\n    objectType = uint8(uint(packedData) >> 24);\\n  }\\n\\n  function packCoordinate(uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(x));\\n    packedData |= bytes32(uint(y) << 128);\\n  }\\n\\n  function unpackCoordinate(bytes32 packedData) internal pure returns (uint128 x, uint128 y) {\\n    x = uint128(uint(packedData));\\n    y = uint128(uint(packedData) >> 128);\\n  }\\n\\n  /// @param x Assume x <= max uint64\\n  /// @param y Assume y <= max uint64\\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    // 256 => 128 + 128;\\n    // 1) 128 is used for biomeMapFieldId, territoryNumber and probably other fields in the future\\n    // 2) 128 is used to store x, y as uint64, uint64\\n\\n    // we will use uint64 for coordinates assuming it is more than enough for biome map\\n    packedData = bytes32(uint(biomeMapFieldId));\\n    packedData |= bytes32(uint(territoryNumber) << (8));\\n    packedData |= bytes32(uint(uint64(x)) << 128);\\n    packedData |= bytes32(uint(uint64(y)) << (64 + 128));\\n  }\\n\\n  function unpackBattlefieldId(bytes32 packedData) internal pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\\n    biomeMapFieldId = uint8(uint(packedData));\\n    territoryNumber = uint8(uint(packedData) >> (8));\\n    x = uint128(uint64(uint(packedData) >> (128)));\\n    y = uint128(uint64(uint(packedData) >> (64 + 128)));\\n  }\\n  //endregion ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  //region ------------------------------------ REINFORCEMENT\\n\\n  function packReinforcementHeroInfo(uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(biome));\\n    packedData |= bytes32(uint(score) << 8);\\n    packedData |= bytes32(uint(fee) << (8 + 128));\\n    packedData |= bytes32(uint(stakeTs) << (8 + 128 + 8));\\n  }\\n\\n  function unpackReinforcementHeroInfo(bytes32 packedData) internal pure returns (uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) {\\n    biome = uint8(uint(packedData));\\n    score = uint128(uint(packedData) >> 8);\\n    fee = uint8(uint(packedData) >> (8 + 128));\\n    stakeTs = uint64(uint(packedData) >> (8 + 128 + 8));\\n  }\\n\\n  function packConfigReinforcementV2(uint32 min, uint32 max, uint32 lowDivider, uint32 highDivider, uint8 levelLimit) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(min));\\n    packedData |= bytes32(uint(max) << 32);\\n    packedData |= bytes32(uint(lowDivider) << 64);\\n    packedData |= bytes32(uint(highDivider) << 96);\\n    packedData |= bytes32(uint(levelLimit) << 128);\\n  }\\n\\n  function unpackConfigReinforcementV2(bytes32 packedData) internal pure returns (uint32 min, uint32 max, uint32 lowDivider, uint32 highDivider, uint8 levelLimit) {\\n    min = uint32(uint(packedData));\\n    max = uint32(uint(packedData) >> 32);\\n    lowDivider = uint32(uint(packedData) >> 64);\\n    highDivider = uint32(uint(packedData) >> 96);\\n    levelLimit = uint8(uint(packedData) >> 128);\\n  }\\n  //endregion ------------------------------------ REINFORCEMENT\\n\\n  //region ------------------------------------ DUNGEON\\n\\n  function packDungeonKey(address heroAdr, uint80 heroId, uint16 dungLogicNum) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(dungLogicNum)) << (160 + 80);\\n  }\\n\\n  function unpackDungeonKey(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 dungLogicNum) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    dungLogicNum = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  // --- GAME OBJECTS ---\\n\\n  function packIterationKey(address heroAdr, uint64 heroId, uint32 objId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(objId)) << (160 + 64);\\n  }\\n\\n  function unpackIterationKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint32 objId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    objId = uint32(uint(data) >> (160 + 64));\\n  }\\n\\n  function packMonsterStats(\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(level));\\n    data |= bytes32(uint(race)) << 8;\\n    data |= bytes32(uint(experience)) << (8 + 8);\\n    data |= bytes32(uint(maxDropItems)) << (8 + 8 + 32);\\n  }\\n\\n  function unpackMonsterStats(bytes32 data) internal pure returns (\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) {\\n    level = uint8(uint(data));\\n    race = uint8(uint(data) >> 8);\\n    experience = uint32(uint(data) >> (8 + 8));\\n    maxDropItems = uint8(uint(data) >> (8 + 8 + 32));\\n  }\\n\\n  function packAttackInfo(\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(attackToken)));\\n    data |= bytes32(uint(attackTokenId)) << 160;\\n    data |= bytes32(uint(attackType)) << (160 + 64);\\n  }\\n\\n  function unpackAttackInfo(bytes32 data) internal pure returns (\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) {\\n    attackToken = address(uint160(uint(data)));\\n    attackTokenId = uint64(uint(data) >> 160);\\n    attackType = uint8(uint(data) >> (160 + 64));\\n  }\\n\\n  function packPlayedObjKey(address heroAdr, uint64 heroId, uint8 oType, uint8 biome) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(oType)) << (160 + 64);\\n    data |= bytes32(uint(biome)) << (160 + 64 + 8);\\n  }\\n\\n  function unpackPlayedObjKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint8 oType, uint8 biome) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    oType = uint8(uint(data) >> (160 + 64));\\n    biome = uint8(uint(data) >> (160 + 64 + 8));\\n  }\\n\\n  function packGeneratedMonster(bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint8(generated ? 1 : 0)));\\n    data |= bytes32(uint(amplifier)) << 8;\\n    data |= bytes32(uint(uint32(hp))) << (8 + 32);\\n    data |= bytes32(uint(turnCounter)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 data) internal pure returns (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) {\\n    generated = uint8(uint(data)) == uint8(1);\\n    amplifier = uint32(uint(data) >> 8);\\n    hp = int32(int(uint(data) >> (8 + 32)));\\n    turnCounter = uint8(uint(data) >> (8 + 32 + 32));\\n  }\\n  //endregion ------------------------------------ DUNGEON\\n\\n  //region ------------------------------------ ITEMS\\n\\n  /// @notice itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n  /// @param itemType This is ItemType enum\\n  function packItemMeta(\\n    uint8 itemMetaType,\\n    uint8 itemLvl,\\n    uint8 itemType,\\n    uint16 baseDurability,\\n    uint8 defaultRarity,\\n    uint8 minAttr,\\n    uint8 maxAttr,\\n    uint32 manaCost,\\n    IStatController.CoreAttributes memory req\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(itemMetaType));\\n    data |= bytes32(uint(itemLvl)) << 8;\\n    data |= bytes32(uint(itemType)) << (8 + 8);\\n    data |= bytes32(uint(baseDurability)) << (8 + 8 + 8);\\n    data |= bytes32(uint(defaultRarity)) << (8 + 8 + 8 + 16);\\n    data |= bytes32(uint(minAttr)) << (8 + 8 + 8 + 16 + 8);\\n    data |= bytes32(uint(maxAttr)) << (8 + 8 + 8 + 16 + 8 + 8);\\n    data |= bytes32(uint(manaCost)) << (8 + 8 + 8 + 16 + 8 + 8 + 8);\\n    data |= bytes32(uint(int(req.strength))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32);\\n    data |= bytes32(uint(int(req.dexterity))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32);\\n    data |= bytes32(uint(int(req.vitality))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(req.energy))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemMeta(bytes32 data) internal pure returns (IItemController.ItemMeta memory) {\\n    IItemController.ItemMeta memory result;\\n\\n    result.itemMetaType = uint8(uint(data));\\n    result.itemLevel = uint8(uint(data) >> 8);\\n    result.itemType = IItemController.ItemType(uint8(uint(data) >> (8 + 8)));\\n    result.baseDurability = uint16(uint(data) >> (8 + 8 + 8));\\n    result.defaultRarity = uint8(uint(data) >> (8 + 8 + 8 + 16));\\n    result.minRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8));\\n    result.maxRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8));\\n    result.manaCost = uint32(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8));\\n    result.requirements.strength = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32)));\\n    result.requirements.dexterity = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32)));\\n    result.requirements.vitality = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32)));\\n    result.requirements.energy = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32)));\\n\\n    return result;\\n  }\\n\\n  function packItemGenerateInfo(uint8 id, int32 min, int32 max, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(id));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(chance)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32 data) internal pure returns (uint8 id, int32 min, int32 max, uint32 chance) {\\n    id = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    chance = uint32(uint(data) >> (8 + 32 + 32));\\n  }\\n\\n  function packItemAttackInfo(\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attackType));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(int(factorStr))) << (8 + 32 + 32);\\n    data |= bytes32(uint(int(factorDex))) << (8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorVit))) << (8 + 32 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorEng))) << (8 + 32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 data) internal pure returns (\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) {\\n    attackType = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    factorStr = int32(int(uint(data) >> (8 + 32 + 32)));\\n    factorDex = int32(int(uint(data) >> (8 + 32 + 32 + 32)));\\n    factorVit = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32)));\\n    factorEng = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packItemInfo(uint8 rarity, uint8 augmentationLevel, uint16 durability) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(rarity));\\n    data |= bytes32(uint(augmentationLevel)) << 8;\\n    data |= bytes32(uint(durability)) << (8 + 8);\\n  }\\n\\n  function unpackItemInfo(bytes32 data) internal pure returns (uint8 rarity, uint8 augmentationLevel, uint16 durability) {\\n    rarity = uint8(uint(data));\\n    augmentationLevel = uint8(uint(data) >> 8);\\n    durability = uint16(uint(data) >> (8 + 8));\\n  }\\n\\n  function packItemBoxItemInfo(bool withdrawn, uint64 timestamp) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint8(withdrawn ? 1 : 0)));\\n    data |= bytes32(uint(timestamp)) << 8;\\n  }\\n\\n  function unpackItemBoxItemInfo(bytes32 data) internal pure returns (bool withdrawn, uint64 timestamp) {\\n    withdrawn = uint8(uint(data)) != 0;\\n    timestamp = uint64(uint(data) >> 8);\\n  }\\n  //endregion ------------------------------------ ITEMS\\n\\n  //region ------------------------------------ STORIES\\n\\n  function packStoryPageId(uint16 storyId, uint16 pageId, uint8 heroClass) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n  }\\n\\n  function unpackStoryPageId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n  }\\n\\n  function packStoryAnswerId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n  }\\n\\n  function unpackStoryAnswerId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n  }\\n\\n  function packStoryNextPagesId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(resultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryNextPagesId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    resultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryAttributeRequirement(uint8 attributeIndex, int32 value, bool isCore) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attributeIndex));\\n    data |= bytes32(uint(uint32(value))) << 8;\\n    data |= bytes32(uint(isCore ? uint8(1) : uint8(0))) << (8 + 32);\\n  }\\n\\n  function unpackStoryAttributeRequirement(bytes32 data) internal pure returns (uint8 attributeIndex, int32 value, bool isCore) {\\n    attributeIndex = uint8(uint(data));\\n    value = int32(int(uint(data) >> 8));\\n    isCore = uint8(uint(data) >> (8 + 32)) == uint8(1);\\n  }\\n\\n  function packStoryItemRequirement(address item, bool requireItemBurn, bool requireItemEquipped) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(requireItemBurn ? uint8(1) : uint8(0))) << 160;\\n    data |= bytes32(uint(requireItemEquipped ? uint8(1) : uint8(0))) << (160 + 8);\\n  }\\n\\n  function unpackStoryItemRequirement(bytes32 data) internal pure returns (address item, bool requireItemBurn, bool requireItemEquipped) {\\n    item = address(uint160(uint(data)));\\n    requireItemBurn = uint8(uint(data) >> 160) == uint8(1);\\n    requireItemEquipped = uint8(uint(data) >> (160 + 8)) == uint8(1);\\n  }\\n\\n  /// @dev max amount is 309,485,009 for token with 18 decimals\\n  function packStoryTokenRequirement(address token, uint88 amount, bool requireTransfer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(amount)) << 160;\\n    data |= bytes32(uint(requireTransfer ? uint8(1) : uint8(0))) << (160 + 88);\\n  }\\n\\n  function unpackStoryTokenRequirement(bytes32 data) internal pure returns (address token, uint88 amount, bool requireTransfer) {\\n    token = address(uint160(uint(data)));\\n    amount = uint88(uint(data) >> 160);\\n    requireTransfer = uint8(uint(data) >> (160 + 88)) == uint8(1);\\n  }\\n\\n  function packStoryCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(customDataResultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryCustomDataResult(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    customDataResultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryHeroState(uint16 pageId, uint40 heroLastActionTS) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(pageId));\\n    data |= bytes32(uint(heroLastActionTS)) << 16;\\n  }\\n\\n  function unpackStoryHeroState(bytes32 data) internal pure returns (uint16 pageId, uint40 heroLastActionTS) {\\n    pageId = uint16(uint(data));\\n    heroLastActionTS = uint40(uint(data) >> 16);\\n  }\\n\\n  function packStoryHeroStateId(address heroAdr, uint80 heroId, uint16 storyId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(storyId)) << (160 + 80);\\n  }\\n\\n  function unpackStoryHeroStateId(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 storyId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    storyId = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  function packStorySimpleRequirement(uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(randomRequirement));\\n    data |= bytes32(uint(delayRequirement)) << 32;\\n    data |= bytes32(uint(isFinalAnswer ? uint8(1) : uint8(0))) << (32 + 32);\\n  }\\n\\n  function unpackStorySimpleRequirement(bytes32 data) internal pure returns (uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) {\\n    randomRequirement = uint32(uint(data));\\n    delayRequirement = uint32(uint(data) >> 32);\\n    isFinalAnswer = uint8(uint(data) >> (32 + 32)) == uint8(1);\\n  }\\n\\n  function packBreakInfo(uint8 slot, uint64 chance, bool stopIfBroken) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(slot));\\n    data |= bytes32(uint(chance)) << 8;\\n    data |= bytes32(uint(stopIfBroken ? uint8(1) : uint8(0))) << (8 + 64);\\n  }\\n\\n  function unpackBreakInfo(bytes32 data) internal pure returns (uint8 slot, uint64 chance, bool stopIfBurned) {\\n    slot = uint8(uint(data));\\n    chance = uint64(uint(data) >> 8);\\n    stopIfBurned = uint8(uint(data) >> (8 + 64)) == uint8(1);\\n  }\\n  //endregion ------------------------------------ STORIES\\n\\n  //region ------------------------------------ Hero controller\\n  function packTierHero(uint8 tier, address hero) internal pure returns (bytes32 packedTierHero) {\\n    packedTierHero = bytes32(uint(tier));\\n    packedTierHero |= bytes32(uint(uint160(hero)) << 8);\\n  }\\n\\n  function unpackTierHero(bytes32 packedTierHero) internal pure returns (uint8 tier, address hero) {\\n    tier = uint8(uint(packedTierHero));\\n    hero = address(uint160(uint(packedTierHero) >> 8));\\n  }\\n\\n  //endregion ------------------------------------ Hero controller\\n\\n  ////////////////////////////////////////////////////////////////////////////////////\\n  // ---- ARRAYS LOGIC ----\\n  ////////////////////////////////////////////////////////////////////////////////////\\n\\n  //region ------------------------------------ SIMPLE ARRAYS\\n\\n\\n  function packUint8Array(uint8[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 32) revert IAppErrors.OutOfBounds(len, 32);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 8);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {packUint8Array} for small number of items\\n  ///         It allows to exclude dynamic array creation.\\n  function packUint8Array3(uint8 a, uint8 b, uint8 c) internal pure returns (bytes32) {\\n    bytes32 result = bytes32(uint(a));\\n    result |= bytes32(uint(b)) << (1 * 8);\\n    result |= bytes32(uint(c)) << (2 * 8);\\n    return result;\\n  }\\n\\n\\n  function unpackUint8Array(bytes32 data) internal pure returns (uint8[] memory) {\\n    uint8[] memory result = new uint8[](32);\\n    for (uint i = 0; i < 32; i++) {\\n      result[i] = uint8(uint(data) >> (i * 8));\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {unpackUint8Array} for small number of items\\n  ///         It allows to exclude only first 3 values\\n  function unpackUint8Array3(bytes32 data) internal pure returns (uint8 a, uint8 b, uint8 c) {\\n    a = uint8(uint(data));\\n    b = uint8(uint(data) >> (1 * 8));\\n    c = uint8(uint(data) >> (2 * 8));\\n  }\\n\\n  function changeUnit8ArrayWithCheck(bytes32 data, uint index, uint8 value, uint8 expectedPrevValue) internal pure returns (bytes32 newData) {\\n    uint8[] memory arr = unpackUint8Array(data);\\n    if (arr[index] != expectedPrevValue) revert IAppErrors.UnexpectedValue(uint(expectedPrevValue), uint(arr[index]));\\n    arr[index] = value;\\n    return packUint8Array(arr);\\n  }\\n\\n  function packInt32Array(int32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert IAppErrors.OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i; i < len; i++) {\\n      result |= bytes32(uint(uint32(data[i]))) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackInt32Array(bytes32 data) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = int32(int(uint(data) >> (i * 32)));\\n    }\\n    return result;\\n  }\\n\\n  function packUint32Array(uint32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert IAppErrors.OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackUint32Array(bytes32 data) internal pure returns (uint32[] memory) {\\n    uint32[] memory result = new uint32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = uint32(uint(data) >> (i * 32));\\n    }\\n    return result;\\n  }\\n  //endregion ------------------------------------ SIMPLE ARRAYS\\n\\n  //region ------------------------------------ COMPLEX ARRAYS\\n\\n  // We should represent arrays without concrete size.\\n  // For this reason we must not revert IAppErrors.on out of bounds but return zero value instead.\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getInt32AsInt24(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n//    if (idx / 8 >= arr.length) {\\n//      return int32(0);\\n//    }\\n//    return int32(int24(int(uint(arr[idx / 8]) >> ((idx % 8) * 32))));\\n//  }\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getUnit8From32Step(bytes32[] memory arr, uint idx) internal pure returns (uint8) {\\n//    if (idx / 8 >= arr.length) {\\n//      return uint8(0);\\n//    }\\n//    return uint8(uint(arr[idx / 8]) >> ((idx % 8) * 32 + 24));\\n//  }\\n\\n  function getInt32Memory(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function getInt32(bytes32[] storage arr, uint idx) internal view returns (int32) {\\n    // additional gas usage, but we should not revert IAppErrors.on out of bounds\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function setInt32(bytes32[] storage arr, uint idx, int32 value) internal {\\n    uint pos = idx / 8;\\n    uint shift = (idx % 8) * 32;\\n\\n    uint curLength = arr.length;\\n    if (pos >= curLength) {\\n      arr.push(0);\\n      for (uint i = curLength; i < pos; ++i) {\\n        arr.push(0);\\n      }\\n    }\\n\\n    arr[pos] = bytes32(uint(arr[pos]) & ~(uint(0xffffffff) << shift) | (uint(uint32(value)) & 0xffffffff) << shift);\\n  }\\n\\n  /// @notice Increment {idx}-th item on {value}\\n  function changeInt32(bytes32[] storage arr, uint idx, int32 value) internal returns (int32 newValue, int32 change) {\\n    int32 cur = int32(int(getInt32(arr, idx)));\\n    int newValueI = int(cur) + int(value);\\n    newValue = int32(newValueI);\\n    change = int32(newValueI - int(cur));\\n\\n    setInt32(arr, idx, newValue);\\n  }\\n\\n  function toInt32Array(bytes32[] memory arr, uint size) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](size);\\n    for (uint i = 0; i < arr.length; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= size) break;\\n        result[idx] = getInt32Memory(arr, idx);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array\\n  function toBytes32Array(int32[] memory arr) internal pure returns (bytes32[] memory) {\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n        result[i] |= bytes32(uint(uint32(arr[idx]))) << (j * 32);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array using last 8bytes for ids\\n  ///      we can not use zero values coz will not able to properly unpack it later\\n  function toBytes32ArrayWithIds(int32[] memory arr, uint8[] memory ids) internal pure returns (bytes32[] memory) {\\n    if (arr.length != ids.length) revert IAppErrors.LengthsMismatch();\\n\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n\\n        if (arr[idx] > type(int24).max || arr[idx] < type(int24).min) revert IAppErrors.IntOutOfRange(int(arr[idx]));\\n        if (arr[idx] == 0) revert IAppErrors.ZeroValue();\\n        result[i] |= bytes32(uint(uint24(int24(arr[idx])))) << (j * 32);\\n        result[i] |= bytes32(uint(ids[idx])) << (j * 32 + 24);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev we do not know exact size of array, assume zero values is not acceptable for this array\\n  function toInt32ArrayWithIds(bytes32[] memory arr) internal pure returns (int32[] memory values, uint8[] memory ids) {\\n    uint len = arr.length;\\n    uint size = len * 8;\\n    int32[] memory valuesTmp = new int32[](size);\\n    uint8[] memory idsTmp = new uint8[](size);\\n    uint counter;\\n    for (uint i = 0; i < len; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        // if (idx >= size) break;  // it looks like a useless check\\n        valuesTmp[idx] = int32(int24(int(uint(arr[i]) >> (j * 32)))); // getInt32AsInt24(arr, idx);\\n        idsTmp[idx] = uint8(uint(arr[i]) >> (j * 32 + 24)); // getUnit8From32Step(arr, idx);\\n        if (valuesTmp[idx] == 0) {\\n          break;\\n        }\\n        counter++;\\n      }\\n    }\\n\\n    values = new int32[](counter);\\n    ids = new uint8[](counter);\\n    for (uint i; i < counter; ++i) {\\n      values[i] = valuesTmp[i];\\n      ids[i] = idsTmp[i];\\n    }\\n  }\\n  //endregion ------------------------------------ COMPLEX ARRAYS\\n\\n  //region ------------------------------------ Guilds\\n  /// @dev ShelterID is uint. But in the code we assume that this ID can be stored as uint64 (see auctions)\\n  /// @param biome 1, 2, 3...\\n  /// @param shelterLevel 1, 2 or 3.\\n  /// @param shelterIndex 0, 1, 2 ...\\n  function packShelterId(uint8 biome, uint8 shelterLevel, uint8 shelterIndex) internal pure returns (uint) {\\n    return uint(biome) | (uint(shelterLevel) << 8) | (uint(shelterIndex) << 16);\\n  }\\n\\n  function unpackShelterId(uint shelterId) internal pure returns (uint8 biome, uint8 shelterLevel, uint8 shelterIndex) {\\n    return (uint8(shelterId), uint8(shelterId >> 8), uint8(shelterId >> 16));\\n  }\\n  //endregion ------------------------------------ Guilds\\n\\n  //region ------------------------------------ Metadata of IItemController.OtherSubtypeKind\\n\\n  function getOtherItemTypeKind(bytes memory packedData) internal pure returns (IItemController.OtherSubtypeKind) {\\n    bytes32 serialized;\\n    assembly {\\n      serialized := mload(add(packedData, 32))\\n    }\\n    uint8 kind = uint8(uint(serialized));\\n    if (kind == 0 || kind >= uint8(IItemController.OtherSubtypeKind.END_SLOT)) revert IAppErrors.IncorrectOtherItemTypeKind(kind);\\n    return IItemController.OtherSubtypeKind(kind);\\n  }\\n\\n  function packOtherItemReduceFragility(uint value) internal pure returns (bytes memory packedData) {\\n    bytes32 serialized = bytes32(uint(uint8(IItemController.OtherSubtypeKind.REDUCE_FRAGILITY_1)));\\n    serialized |= bytes32(uint(uint248(value))) << 8;\\n    return bytes.concat(serialized);\\n  }\\n\\n  function unpackOtherItemReduceFragility(bytes memory packedData) internal pure returns (uint) {\\n    bytes32 serialized;\\n    assembly {\\n      serialized := mload(add(packedData, 32))\\n    }\\n    uint8 kind = uint8(uint(serialized));\\n    if (kind != uint8(IItemController.OtherSubtypeKind.REDUCE_FRAGILITY_1)) revert IAppErrors.IncorrectOtherItemTypeKind(kind);\\n    uint value = uint248(uint(serialized) >> 8);\\n    return value;\\n  }\\n  //endregion ------------------------------------ Metadata of IItemController.OtherSubtypeKind\\n\\n  //region ------------------------------------ Metadata of IPvpController.PvpAttackInfoDefaultStrategy\\n  function getPvpBehaviourStrategyKind(bytes memory encodedData) internal pure returns (uint) {\\n    bytes32 serialized;\\n    assembly {\\n      serialized := mload(add(encodedData, 64)) // first 32 bytes contain 0x20 and indicate array, we need to read second 32 bytes to get first uint in the struct\\n    }\\n\\n    return uint(serialized);\\n  }\\n  //endregion ------------------------------------ Metadata of IPvpController.PvpAttackInfoDefaultStrategy\\n\\n}\\n\",\"keccak256\":\"0x2c8652b2e7d685dc36cefd6c6bb81f116b72909e103879c1afb2e2e92821f83e\",\"license\":\"BUSL-1.1\"},\"contracts/lib/RewardsPoolLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IGameToken.sol\\\";\\nimport \\\"../interfaces/IRewardsPool.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../proxy/Controllable.sol\\\";\\n\\nlibrary RewardsPoolLib {\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"rewards.pool.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant REWARDS_POOL_STORAGE_LOCATION = 0x6ad655e44097c54b487e7c9215cc0bbf37bbe7fc2f8034e2ddf6749036fda500; // rewards.pool.main\\n\\n  //region ------------------------ Storage\\n\\n  function _S() internal pure returns (IRewardsPool.MainState storage s) {\\n    assembly {\\n      s.slot := REWARDS_POOL_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n  //endregion ------------------------ Storage\\n\\n  //region ------------------------ Restrictions\\n  function onlyHeroController(IController controller) internal view {\\n    if (controller.heroController() != msg.sender) revert IAppErrors.ErrorNotHeroController(msg.sender);\\n  }\\n\\n  function _onlyDeployer(IController controller) internal view {\\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n\\n  function _onlyGovernance(IController controller) internal view {\\n    if (controller.governance() != msg.sender) revert IAppErrors.NotGovernance(msg.sender);\\n  }\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ View\\n  function balanceOfToken(address token) internal view returns (uint) {\\n    return IERC20(token).balanceOf(address(this));\\n  }\\n\\n  function baseAmount(address token) internal view returns (uint) {\\n    return _S().baseAmounts[token];\\n  }\\n\\n  /// @param maxBiome Max available biome, see {IDungeonFactory.state.maxBiome}\\n  /// @param maxNgLevel Max opened NG_LEVEL, see {IHeroController.state.maxOpenedNgLevel}\\n  /// @param biome Current hero biome [0..19\\n  /// @param heroNgLevel Current hero NG_LVL [0..99]\\n  /// @return Reward percent, decimals 18\\n  function rewardPercent(uint maxBiome, uint maxNgLevel, uint biome, uint heroNgLevel) internal pure returns (uint) {\\n    // biome_sum = max biome*(max biome+1)/2\\n    // biome_weight = biome / biome_sum\\n    // reward_percent = biome_weight * (1 + NG_LVL) / ng_sum\\n    return  1e18 * biome * (1 + heroNgLevel)\\n      / (maxBiome * (maxBiome + 1) / 2) // biome_sum\\n      / getNgSum(maxNgLevel);\\n  }\\n\\n  /// @notice be definition  ng_sum  = (max_ng + 1) * (max_ng+2) / 2\\n  function getNgSum(uint maxNgLevel) internal pure returns (uint) {\\n    return ((maxNgLevel + 1) * (maxNgLevel + 2) / 2);\\n  }\\n\\n  function rewardAmount(address token, uint maxBiome, uint maxNgLevel, uint biome, uint heroNgLevel) internal view returns (uint) {\\n    return baseAmount(token) * rewardPercent(maxBiome, maxNgLevel, biome, heroNgLevel) / 1e18;\\n  }\\n\\n  /// @notice Calculate lost profit amount in percents in the case when hero is created on {heroNgLevel} > 0\\n  /// @param maxBiome Max available biome, see {IDungeonFactory.state.maxBiome}\\n  /// @param maxNgLevel Max opened NG_LEVEL, see {IHeroController.state.maxOpenedNgLevel}\\n  /// @param heroNgLevel NG_LVL [1..99] where the hero is created, assume heroNgLevel > 0\\n  /// @return Lost reward percent, decimals 18\\n  function lostProfitPercent(uint maxBiome, uint maxNgLevel, uint heroNgLevel) internal pure returns (uint) {\\n    uint percent;\\n    for (uint8 ngLevel = 0; ngLevel < heroNgLevel; ++ngLevel) {\\n      percent += totalProfitOnLevel(maxBiome, maxNgLevel, ngLevel);\\n    }\\n    return percent;\\n  }\\n\\n  /// @notice SCR-1064: Calculate a percent to reduce drop chance of the monsters on various NG-levels.\\n  /// The percent is reverse to the percent of the rewards.\\n  /// @param maxBiome Max available biome, see {IDungeonFactory.state.maxBiome}\\n  /// @param maxNgLevel Max opened NG_LEVEL, see {IHeroController.state.maxOpenedNgLevel}\\n  /// @param heroNgLevel NG_LVL [1..99] where the hero is created, assume heroNgLevel > 0\\n  /// @return Drop chance percent, decimals 18\\n  function dropChancePercent(uint maxBiome, uint maxNgLevel, uint heroNgLevel) internal pure returns (uint) {\\n    if (heroNgLevel == 0) return 1e18; // NG0 is special case - drop is NOT reduced\\n\\n    return heroNgLevel > maxNgLevel\\n      ? 0\\n      : totalProfitOnLevel(maxBiome, maxNgLevel, maxNgLevel - heroNgLevel + 1);\\n  }\\n\\n  /// @notice Calculate total percent of rewards in all biomes on the given {ngLevel}\\n  function totalProfitOnLevel(uint maxBiome, uint maxNgLevel, uint ngLevel) internal pure returns (uint percent) {\\n    for (uint8 biome = 1; biome <= maxBiome; ++biome) {\\n      percent += rewardPercent(maxBiome, maxNgLevel, biome, ngLevel);\\n    }\\n    return percent;\\n  }\\n  //endregion ------------------------ View\\n\\n  //region ------------------------ Gov actions\\n  function setBaseAmount(IController controller, address token, uint baseAmount_) internal {\\n    _onlyDeployer(controller);\\n\\n    emit IApplicationEvents.BaseAmountChanged(_S().baseAmounts[token], baseAmount_);\\n    _S().baseAmounts[token] = baseAmount_;\\n  }\\n\\n  function withdraw(IController controller, address token, uint amount, address receiver) internal {\\n    _onlyGovernance(controller);\\n\\n    IERC20(token).transfer(receiver, amount);\\n  }\\n  //endregion ------------------------ Gov actions\\n\\n  //region ------------------------ Logic\\n  /// @notice Send {amount} of the {token} to the {dungeon}\\n  /// @dev Assume here that all calculations and checks are made on dungeonFactory-side\\n  function sendReward(IController controller, address token, uint rewardAmount_, address receiver) internal {\\n    onlyHeroController(controller);\\n\\n    uint balance = IERC20(token).balanceOf(address(this));\\n    if (balance >= rewardAmount_) {\\n      IERC20(token).transfer(receiver, rewardAmount_);\\n      emit IApplicationEvents.RewardSentToUser(receiver, token, rewardAmount_);\\n    } else {\\n      // there is not enough amount on reward pool balance\\n      // just register reward in events\\n      // assume that the reward should be paid to the receiver later manually\\n      emit IApplicationEvents.NotEnoughReward(receiver, token, rewardAmount_);\\n    }\\n  }\\n\\n  //endregion ------------------------ Logic\\n\\n}\\n\",\"keccak256\":\"0x7247419aeb0a36bc2bd0b51ccdadff8ba5eb3b78aa5e3260f8b5815cd602aa33\",\"license\":\"BUSL-1.1\"},\"contracts/lib/SlotsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\\n/// @author bogdoslav\\nlibrary SlotsLib {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant SLOT_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  // ************* GETTERS *******************\\n\\n  /// @dev Gets a slot as bytes32\\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as an address\\n  function getAddress(bytes32 slot) internal view returns (address result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as uint256\\n  function getUint(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  // ************* ARRAY GETTERS *******************\\n\\n  /// @dev Gets an array length\\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  // ************* SETTERS *******************\\n\\n  /// @dev Sets a slot with bytes32\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, bytes32 value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with address\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, address value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with uint\\n  function set(bytes32 slot, uint value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x52ede981a6bb509c0dce07a0373e3c073c24fd16ca4ca7fbaa24f6c8b747b45b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StatControllerLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../lib/StatLib.sol\\\";\\n\\n/// @notice Implementation of StatController\\nlibrary StatControllerLib {\\n  using StatLib for uint;\\n  using StatLib for uint[];\\n  using StatLib for uint32;\\n  using StatLib for int32;\\n  using StatLib for int32;\\n  using CalcLib for uint;\\n  using CalcLib for int;\\n  using CalcLib for int32;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using EnumerableMap for EnumerableMap.Bytes32ToUintMap;\\n  using PackingLib for bytes32[];\\n  using PackingLib for bytes32;\\n  using PackingLib for int32;\\n  using PackingLib for uint32;\\n\\n  //region ------------------------ Constants\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"stat.controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0xca9e8235a410bd2656fc43f888ab589425034944963c2881072ee821e700e600;\\n\\n  int32 public constant LEVEL_UP_SUM = 5;\\n  bytes32 public constant KARMA_HASH = bytes32(\\\"KARMA\\\");\\n  uint internal constant DEFAULT_KARMA_VALUE = 1000;\\n\\n  /// @notice Virtual data, value is not stored to hero custom data, heroClass is taken from heroController by the index\\n  bytes32 public constant HERO_CLASS_HASH = bytes32(\\\"HERO_CLASS\\\");\\n\\n  /// @notice Custom data of the hero. Value is incremented on every life-chance lost\\n  bytes32 public constant DEATH_COUNT_HASH = bytes32(\\\"DEATH_COUNT\\\");\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ RESTRICTIONS\\n\\n  function onlyRegisteredContract(IController controller_) internal view returns (IHeroController) {\\n    // using of ControllerContextLib.ControllerContext increases size of the contract on 0.5 kb\\n    address sender = msg.sender;\\n    address heroController = controller_.heroController();\\n    if (\\n      heroController != sender\\n      && controller_.itemController() != sender\\n      && controller_.dungeonFactory() != sender\\n      && controller_.storyController() != sender\\n      && controller_.gameObjectController() != sender\\n      && controller_.pvpController() != sender\\n    ) revert IAppErrors.ErrorForbidden(sender);\\n\\n    return IHeroController(heroController);\\n  }\\n\\n  function onlyItemController(IController controller_) internal view {\\n    if (controller_.itemController() != msg.sender) revert IAppErrors.ErrorNotItemController(msg.sender);\\n  }\\n\\n  function onlyHeroController(IController controller_) internal view returns (IHeroController) {\\n    address heroController = controller_.heroController();\\n    if (heroController != msg.sender) revert IAppErrors.ErrorNotHeroController(msg.sender);\\n    return IHeroController(heroController);\\n  }\\n\\n  function onlyDeployer(IController controller) internal view {\\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n  //endregion ------------------------ RESTRICTIONS\\n\\n  //region ------------------------ VIEWS\\n  function _S() internal pure returns (IStatController.MainState storage s) {\\n    assembly {\\n      s.slot := MAIN_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n\\n  function heroAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (int32[] memory) {\\n    return PackingLib.toInt32Array(s.heroTotalAttributes[PackingLib.packNftId(token, tokenId)], uint(IStatController.ATTRIBUTES.END_SLOT));\\n  }\\n\\n  function heroBonusAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (int32[] memory) {\\n    return PackingLib.toInt32Array(s.heroBonusAttributes[PackingLib.packNftId(token, tokenId)], uint(IStatController.ATTRIBUTES.END_SLOT));\\n  }\\n\\n  function heroTemporallyAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (int32[] memory) {\\n    return PackingLib.toInt32Array(s.heroTemporallyAttributes[PackingLib.packNftId(token, tokenId)], uint(IStatController.ATTRIBUTES.END_SLOT));\\n  }\\n\\n\\n  function heroAttributesLength(address /*token*/, uint /*tokenId*/) internal pure returns (uint) {\\n    return uint(IStatController.ATTRIBUTES.END_SLOT);\\n  }\\n\\n  function heroAttribute(IStatController.MainState storage s, address token, uint tokenId, uint index) internal view returns (int32) {\\n    return PackingLib.getInt32(s.heroTotalAttributes[PackingLib.packNftId(token, tokenId)], index);\\n  }\\n\\n  function heroBaseAttributes(IStatController.MainState storage s, address token, uint tokenId) internal view returns (\\n    IStatController.CoreAttributes memory core\\n  ) {\\n    int32[] memory data = PackingLib.unpackInt32Array(s._heroCore[PackingLib.packNftId(token, tokenId)]);\\n    core = IStatController.CoreAttributes({\\n      strength: int32(data[0]),\\n      dexterity: int32(data[1]),\\n      vitality: int32(data[2]),\\n      energy: int32(data[3])\\n    });\\n  }\\n\\n  function heroCustomData(IHeroController hc, address hero, uint heroId, bytes32 index) internal view returns (uint) {\\n    return heroCustomDataOnNgLevel(hc, hero, heroId, index, hc.getHeroInfo(hero, heroId).ngLevel);\\n  }\\n\\n  function heroCustomDataOnNgLevel(IHeroController hc, address hero, uint heroId, bytes32 index, uint8 ngLevel) internal view returns (uint) {\\n    if (index == HERO_CLASS_HASH) {\\n      return hc.heroClass(hero);\\n    } else {\\n      (, uint value) = _S().heroCustomDataV2[PackingLib.packNftIdWithValue(hero, heroId, ngLevel)].tryGet(index);\\n\\n      if (index == KARMA_HASH && value == 0) {\\n        return DEFAULT_KARMA_VALUE;\\n      }\\n\\n      return value;\\n    }\\n  }\\n\\n\\n  function getAllHeroCustomData(IHeroController hc, address hero, uint heroId) internal view returns (bytes32[] memory keys, uint[] memory values) {\\n    // Result doesn't include HERO_CLASS_HASH\\n    EnumerableMap.Bytes32ToUintMap storage map = _S().heroCustomDataV2[PackingLib.packNftIdWithValue(hero, heroId, hc.getHeroInfo(hero, heroId).ngLevel)];\\n    uint length = map.length();\\n    keys = new bytes32[](length);\\n    values = new uint[](length);\\n    for (uint i; i < length; ++i) {\\n      (keys[i], values[i]) = map.at(i);\\n    }\\n  }\\n\\n  function globalCustomData(IStatController.MainState storage s, bytes32 index) internal view returns (uint) {\\n    return s.globalCustomData[index];\\n  }\\n\\n  function heroStats(IStatController.MainState storage s, address token, uint tokenId) internal view returns (\\n    IStatController.ChangeableStats memory result\\n  ) {\\n    uint32[] memory data = PackingLib.unpackUint32Array(s.heroStats[PackingLib.packNftId(token, tokenId)]);\\n    result = IStatController.ChangeableStats({\\n      level: uint32(data[0]),\\n      experience: uint32(data[1]),\\n      life: uint32(data[2]),\\n      mana: uint32(data[3]),\\n      lifeChances: uint32(data[4])\\n    });\\n  }\\n\\n  function heroItemSlot(IStatController.MainState storage s, address heroToken, uint64 heroTokenId, uint8 itemSlot) internal view returns (\\n    bytes32 nftPacked\\n  ) {\\n    return s.heroSlots[PackingLib.packMapObject(heroToken, heroTokenId, itemSlot)];\\n  }\\n\\n  /// @return Return list of indices of the busy item slots for the given hero\\n  function heroItemSlots(IStatController.MainState storage s, address heroToken, uint heroTokenId) internal view returns (\\n    uint8[] memory\\n  ) {\\n    uint8[] memory slots = PackingLib.unpackUint8Array(s.heroBusySlots[PackingLib.packNftId(heroToken, heroTokenId)]);\\n\\n    uint8[] memory busySlotsNumbers = new uint8[](slots.length);\\n    uint counter;\\n\\n    for (uint8 i; i < uint8(slots.length); ++i) {\\n      if (slots[i] != 0) {\\n        busySlotsNumbers[counter] = i;\\n        counter++;\\n      }\\n    }\\n\\n    uint8[] memory result = new uint8[](counter);\\n\\n    for (uint i; i < counter; ++i) {\\n      result[i] = busySlotsNumbers[i];\\n    }\\n\\n    return result;\\n  }\\n\\n  function isHeroAlive(IStatController.MainState storage s, address heroToken, uint heroTokenId) internal view returns (bool) {\\n    return heroStats(s, heroToken, heroTokenId).lifeChances != 0;\\n  }\\n\\n  function isConsumableUsed(IStatController.MainState storage s, address heroToken, uint heroTokenId, address item) internal view returns (bool) {\\n    return s.usedConsumables[PackingLib.packNftId(heroToken, heroTokenId)].contains(item);\\n  }\\n\\n  /// @notice Calculate totalAttributes + all attributes of the items specified in {info}\\n  function buffHero(\\n    IStatController.MainState storage s,\\n    IController controller,\\n    IStatController.BuffInfo calldata info\\n  ) external view returns (\\n    int32[] memory dest,\\n    int32 manaSum\\n  ) {\\n    uint length = info.buffTokens.length;\\n    if (length == 0) {\\n      return (heroAttributes(s, info.heroToken, info.heroTokenId), 0);\\n    }\\n\\n    IItemController ic = IItemController(controller.itemController());\\n\\n    int32[] memory buffAttributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    address[] memory usedTokens = new address[](length);\\n\\n    for (uint i; i < length; ++i) {\\n\\n      // we should ignore the same skills\\n      bool used;\\n      for (uint j; j < i; ++j) {\\n        if (usedTokens[j] == info.buffTokens[i]) {\\n          used = true;\\n          break;\\n        }\\n      }\\n      if (used) {\\n        continue;\\n      }\\n\\n\\n      manaSum += int32(ic.itemMeta(info.buffTokens[i]).manaCost);\\n      (int32[] memory values, uint8[] memory ids) = ic.casterAttributes(info.buffTokens[i], info.buffTokenIds[i]);\\n      StatLib.attributesAdd(buffAttributes, StatLib.valuesToFullAttributesArray(values, ids));\\n      usedTokens[i] = info.buffTokens[i];\\n    }\\n\\n    int32[] memory totalAttributes = StatLib.attributesAdd(heroAttributes(s, info.heroToken, info.heroTokenId), buffAttributes);\\n\\n    StatLib.attributesAdd(buffAttributes, heroBonusAttributes(s, info.heroToken, info.heroTokenId));\\n    StatLib.attributesAdd(buffAttributes, heroTemporallyAttributes(s, info.heroToken, info.heroTokenId));\\n\\n    return (\\n      StatLib.updateCoreDependAttributesInMemory(\\n        totalAttributes,\\n        buffAttributes,\\n        IHeroController(controller.heroController()).heroClass(info.heroToken),\\n        info.heroLevel\\n      ),\\n      manaSum\\n    );\\n  }\\n\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ PURE\\n\\n  function isItemTypeEligibleToItemSlot(uint itemType, uint itemSlot) internal pure returns (bool) {\\n    // Consumable items not eligible\\n    if (itemType == 0 || itemSlot == 0) {\\n      return false;\\n    }\\n    // items with type before 5 mapped 1 to 1\\n    if (itemType <= uint(IItemController.ItemType.AMULET)) {\\n      return itemSlot == itemType;\\n    }\\n    if (itemType == uint(IItemController.ItemType.RING)) {\\n      return itemSlot == uint(IStatController.ItemSlots.RIGHT_RING)\\n        || itemSlot == uint(IStatController.ItemSlots.LEFT_RING);\\n    }\\n    if (itemType == uint(IItemController.ItemType.BOOTS)) {\\n      return itemSlot == uint(IStatController.ItemSlots.BOOTS);\\n    }\\n    if (itemType == uint(IItemController.ItemType.ONE_HAND)) {\\n      return itemSlot == uint(IStatController.ItemSlots.RIGHT_HAND);\\n    }\\n    if (itemType == uint(IItemController.ItemType.OFF_HAND)) {\\n      return itemSlot == uint(IStatController.ItemSlots.LEFT_HAND);\\n    }\\n    if (itemType == uint(IItemController.ItemType.TWO_HAND)) {\\n      return itemSlot == uint(IStatController.ItemSlots.TWO_HAND);\\n    }\\n    if (itemType == uint(IItemController.ItemType.SKILL)) {\\n      return itemSlot == uint(IStatController.ItemSlots.SKILL_1)\\n      || itemSlot == uint(IStatController.ItemSlots.SKILL_2)\\n        || itemSlot == uint(IStatController.ItemSlots.SKILL_3);\\n    }\\n    // unknown types\\n    return false;\\n  }\\n\\n  /// @notice How much experience is required to go from the {level} to the next level\\n  function levelUpExperienceRequired(uint32 level) internal pure returns (uint) {\\n    if (level == 0 || level >= StatLib.MAX_LEVEL) return 0;\\n    return level == uint32(1)\\n      ? StatLib.levelExperience(level)\\n      : StatLib.levelExperience(level) - StatLib.levelExperience(level - uint32(1));\\n  }\\n\\n  //endregion ------------------------ PURE\\n\\n  //region ------------------------ ACTIONS\\n\\n  /// @param heroClass Assume that heroController passes correct value of the heroClass for the given hero\\n  /// Also assume that the hero exists and alive\\n  function reborn(IController controller, address hero, uint heroId, uint heroClass) external {\\n    IStatController.MainState storage s = _S();\\n    bytes32 heroPackedId = PackingLib.packNftId(hero, heroId);\\n\\n    IHeroController heroController = onlyHeroController(controller);\\n    if (_S().heroBusySlots[heroPackedId] != 0) revert IAppErrors.EquippedItemsExist();\\n\\n    uint32 lifeChances = heroStats(s, hero, heroId).lifeChances;\\n\\n    // -------------------------- clear\\n    delete s.heroTotalAttributes[heroPackedId];\\n    delete s.heroTemporallyAttributes[heroPackedId];\\n    delete s.heroBonusAttributes[heroPackedId];\\n\\n    // -------------------------- init from zero\\n    uint32[] memory baseStats = _initCoreAndAttributes(s, heroPackedId, heroClass);\\n    _changeChangeableStats(\\n      s,\\n      heroPackedId,\\n      1, // level is set to 1\\n      0, // experience is set to 0\\n      baseStats[0], // life is restored\\n      baseStats[1], // mana is restored\\n      lifeChances// life chances are not changed\\n    );\\n\\n    // custom data is NOT cleared on reborn, new custom data map is used on each new NG_LVL\\n    _prepareHeroCustomDataForNextNgLevel(heroController, hero, heroId);\\n  }\\n\\n  function _prepareHeroCustomDataForNextNgLevel(IHeroController heroController, address hero, uint heroId) internal {\\n    // assume here, that statController.reborn is called AFTER incrementing of NG_LVL, current NG_LVL has \\\"new\\\" value\\n    uint8 newNgLevel = heroController.getHeroInfo(hero, heroId).ngLevel;\\n    if (newNgLevel == 0) revert IAppErrors.ZeroValueNotAllowed(); // edge case\\n    uint8 prevNgLevel = newNgLevel - 1;\\n\\n    // copy value of DEATH_COUNT from current ng-level to next ng-level\\n    (bool exist, uint value) = _S().heroCustomDataV2[PackingLib.packNftIdWithValue(hero, heroId, prevNgLevel)].tryGet(DEATH_COUNT_HASH);\\n    if (exist && value != 0) {\\n      _S().heroCustomDataV2[PackingLib.packNftIdWithValue(hero, heroId, newNgLevel)].set(DEATH_COUNT_HASH, value);\\n      emit IApplicationEvents.HeroCustomDataChangedNg(hero, heroId, DEATH_COUNT_HASH, value, newNgLevel);\\n    }\\n\\n    // leave KARMA equal to 0 on next ng-level, getter returns default karma in this case\\n    emit IApplicationEvents.HeroCustomDataChangedNg(hero, heroId, KARMA_HASH, DEFAULT_KARMA_VALUE, newNgLevel);\\n  }\\n\\n  /// @notice Keep stories, monsters, DEATH_COUNT_HASH and HERO_CLASS_HASH; remove all other custom data\\n  function _removeAllHeroCustomData(IHeroController hc, address hero, uint heroId) internal {\\n    EnumerableMap.Bytes32ToUintMap storage data = _S().heroCustomDataV2[PackingLib.packNftIdWithValue(hero, heroId, hc.getHeroInfo(hero, heroId).ngLevel)];\\n    uint length = data.length();\\n    bytes32[] memory keysToRemove = new bytes32[](length);\\n    bytes32 monsterPrefix = bytes32(abi.encodePacked(\\\"MONSTER_\\\")); // 8 bytes\\n    bytes32 storyPrefix = bytes32(abi.encodePacked(\\\"STORY_\\\")); // 6 bytes\\n\\n    for (uint i; i < length; ++i) {\\n      (bytes32 key,) = data.at(i);\\n      if (key == DEATH_COUNT_HASH || key == HERO_CLASS_HASH) continue;\\n\\n      bool isNotMonster;\\n      bool isNotStory;\\n      for (uint j; j < 8; j++) {\\n        if (!isNotMonster && key[j] != monsterPrefix[j]) {\\n          isNotMonster = true;\\n        }\\n        if (!isNotStory && j < 6 && key[j] != storyPrefix[j]) {\\n          isNotStory = true;\\n        }\\n        if (isNotMonster && isNotStory) break;\\n      }\\n\\n      if (isNotMonster && isNotStory) {\\n        keysToRemove[i] = key;\\n      }\\n    }\\n\\n    for (uint i; i < length; ++i) {\\n      if (keysToRemove[i] != bytes32(0)) {\\n        data.remove(keysToRemove[i]);\\n      }\\n    }\\n\\n    emit IApplicationEvents.HeroCustomDataCleared(hero, heroId);\\n  }\\n\\n  /// @notice Initialize new hero, set up custom data, core data, changeable stats by default value\\n  /// @param heroClass [1..6], see StatLib.initHeroXXX\\n  function initNewHero(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass\\n  ) external {\\n    IHeroController heroController = onlyHeroController(c);\\n\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n    uint32[] memory baseStats = _initCoreAndAttributes(s, heroPackedId, heroClass);\\n\\n    _changeChangeableStats(s, heroPackedId, 1, 0, baseStats[0], baseStats[1], baseStats[2]);\\n\\n    emit IApplicationEvents.NewHeroInited(heroToken, heroTokenId, IStatController.ChangeableStats({\\n      level: 1,\\n      experience: 0,\\n      life: baseStats[0],\\n      mana: baseStats[1],\\n      lifeChances: baseStats[2]\\n    }));\\n\\n    // --- init predefined custom hero data\\n    _initNewHeroCustomData(s, heroController, heroToken, heroTokenId);\\n  }\\n\\n  /// @dev Reset custom hero data if something went wrong\\n  function resetHeroCustomData(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external {\\n    onlyDeployer(c);\\n    _removeAllHeroCustomData(IHeroController(c.heroController()), heroToken, heroTokenId);\\n    _initNewHeroCustomData(s, IHeroController(c.heroController()), heroToken, heroTokenId);\\n  }\\n\\n  function _initNewHeroCustomData(IStatController.MainState storage s, IHeroController heroController, address hero, uint heroId) internal {\\n    uint8 ngLevel = heroController.getHeroInfo(hero, heroId).ngLevel;\\n    bytes32 heroPackedIdValue = PackingLib.packNftIdWithValue(hero, heroId, ngLevel);\\n\\n    EnumerableMap.Bytes32ToUintMap storage customData = s.heroCustomDataV2[heroPackedIdValue];\\n\\n    // set initial karma\\n    customData.set(KARMA_HASH, DEFAULT_KARMA_VALUE);\\n    emit IApplicationEvents.HeroCustomDataChangedNg(hero, heroId, KARMA_HASH, DEFAULT_KARMA_VALUE, ngLevel);\\n\\n    // HERO_CLASS_HASH is not used as custom data anymore, getter takes value directly from heroController\\n\\n    // set death count value\\n    // customData[DEATH_COUNT_HASH] is initialized by 0 by default\\n    emit IApplicationEvents.HeroCustomDataChangedNg(hero, heroId, DEATH_COUNT_HASH, 0, ngLevel);\\n  }\\n\\n  function _initCoreAndAttributes(IStatController.MainState storage s, bytes32 heroPackedId, uint heroClass) internal returns (\\n    uint32[] memory baseStats\\n  ){\\n    _initNewHeroCore(s, heroPackedId, heroClass);\\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\\n    return StatLib.initAttributes(totalAttributes, heroClass, 1, heroClass.initialHero().core);\\n  }\\n\\n  function _initNewHeroCore(IStatController.MainState storage s, bytes32 heroPackedId, uint heroClass) internal {\\n    IStatController.CoreAttributes memory initialCore = heroClass.initialHero().core;\\n    int32[] memory arr = new int32[](4);\\n\\n    arr[0] = int32(initialCore.strength);\\n    arr[1] = int32(initialCore.dexterity);\\n    arr[2] = int32(initialCore.vitality);\\n    arr[3] = int32(initialCore.energy);\\n\\n    s._heroCore[heroPackedId] = PackingLib.packInt32Array(arr);\\n  }\\n\\n  function _changeChangeableStats(\\n    IStatController.MainState storage s,\\n    bytes32 heroPackedId,\\n    uint32 level,\\n    uint32 experience,\\n    uint32 life,\\n    uint32 mana,\\n    uint32 lifeChances\\n  ) internal {\\n    if (lifeChances != 0 && life == 0) {\\n      life = 1;\\n    }\\n    uint32[] memory data = new uint32[](5);\\n    data[0] = level;\\n    data[1] = experience;\\n    data[2] = life;\\n    data[3] = mana;\\n    data[4] = lifeChances;\\n\\n    s.heroStats[heroPackedId] = PackingLib.packUint32Array(data);\\n  }\\n\\n  /// @notice Add/remove the item to/from the hero\\n  function changeHeroItemSlot(\\n    IStatController.MainState storage s,\\n    IController controller,\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) internal {\\n    onlyItemController(controller);\\n    if (!isItemTypeEligibleToItemSlot(itemType, itemSlot)) revert IAppErrors.ErrorItemNotEligibleForTheSlot(itemType, itemSlot);\\n\\n    // if we are going to take an item by two hands, we need both hands free.\\n    // if we are going to use only one hand, we shouldn't keep anything by two hands\\n    if (itemSlot == uint(IStatController.ItemSlots.TWO_HAND)) {\\n      if (heroItemSlot(s, heroToken, heroTokenId, uint8(IStatController.ItemSlots.RIGHT_HAND)) != bytes32(0)\\n        || heroItemSlot(s, heroToken, heroTokenId, uint8(IStatController.ItemSlots.LEFT_HAND)) != bytes32(0)) {\\n        revert IAppErrors.ErrorItemSlotBusyHand(itemSlot);\\n      }\\n    }\\n    if (itemSlot == uint(IStatController.ItemSlots.RIGHT_HAND) || itemSlot == uint(IStatController.ItemSlots.LEFT_HAND)) {\\n      if (heroItemSlot(s, heroToken, heroTokenId, uint8(IStatController.ItemSlots.TWO_HAND)) != bytes32(0)) {\\n        revert IAppErrors.ErrorItemSlotBusyHand(itemSlot);\\n      }\\n    }\\n\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n    (address equippedItem, uint equippedItemId) = PackingLib.unpackNftId(heroItemSlot(s, heroToken, heroTokenId, itemSlot));\\n    if (equip) {\\n      if (equippedItem != address(0)) revert IAppErrors.ErrorItemSlotBusy();\\n\\n      s.heroSlots[PackingLib.packMapObject(heroToken, uint64(heroTokenId), itemSlot)] = PackingLib.packNftId(itemToken, itemTokenId);\\n      s.heroBusySlots[heroPackedId] = PackingLib.changeUnit8ArrayWithCheck(s.heroBusySlots[heroPackedId], itemSlot, 1, 0);\\n    } else {\\n      if (equippedItem != itemToken || equippedItemId != itemTokenId) revert IAppErrors.ErrorItemNotInSlot();\\n\\n      delete s.heroSlots[PackingLib.packMapObject(heroToken, uint64(heroTokenId), itemSlot)];\\n      s.heroBusySlots[heroPackedId] = PackingLib.changeUnit8ArrayWithCheck(s.heroBusySlots[heroPackedId], itemSlot, 0, 1);\\n    }\\n\\n    emit IApplicationEvents.HeroItemSlotChanged(heroToken, heroTokenId, itemType, itemSlot, itemToken, itemTokenId, equip, msg.sender);\\n  }\\n\\n  /// @notice Increase or decrease stats (life, mana, lifeChances). Experience can be increased only.\\n  function changeCurrentStats(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats memory change,\\n    bool increase\\n  ) internal {\\n    onlyRegisteredContract(c);\\n\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n    IStatController.ChangeableStats memory currentStats = heroStats(s, heroToken, heroTokenId);\\n\\n    uint32 life = currentStats.life;\\n    uint32 mana = currentStats.mana;\\n    uint32 lifeChances = currentStats.lifeChances;\\n\\n    if (increase) {\\n      bytes32[] storage attrs = s.heroTotalAttributes[heroPackedId];\\n      int32 maxLife = attrs.getInt32(uint(IStatController.ATTRIBUTES.LIFE));\\n      int32 maxMana = attrs.getInt32(uint(IStatController.ATTRIBUTES.MANA));\\n      int32 maxLC = attrs.getInt32(uint(IStatController.ATTRIBUTES.LIFE_CHANCES));\\n\\n      currentStats.experience += change.experience;\\n      life = uint32(Math.min(maxLife.toUint(), uint(life + change.life)));\\n      mana = uint32(Math.min(maxMana.toUint(), uint(mana + change.mana)));\\n\\n      // Assume that Life Chances can be increased only by 1 per use.\\n      // Some stories and events can allow users to increase life chance above max...\\n      // Such attempts should be forbidden on UI side, we just silently ignore them here, no revert\\n      lifeChances = uint32(Math.min(maxLC.toUint(), uint(lifeChances + change.lifeChances)));\\n    } else {\\n      if (change.experience != 0) revert IAppErrors.ErrorExperienceMustNotDecrease();\\n      life = life > change.life ? life - change.life : 0;\\n      lifeChances = lifeChances > change.lifeChances ? lifeChances - change.lifeChances : 0;\\n      mana = mana > change.mana ? mana - change.mana : 0;\\n    }\\n\\n    _changeChangeableStats(s, heroPackedId, currentStats.level, currentStats.experience, life, mana, lifeChances);\\n    emit IApplicationEvents.CurrentStatsChanged(heroToken, heroTokenId, change, increase, msg.sender);\\n  }\\n\\n  /// @notice Mark consumable {item} as used\\n  function registerConsumableUsage(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId,\\n    address item\\n  ) internal {\\n    onlyRegisteredContract(c);\\n\\n    if (!s.usedConsumables[PackingLib.packNftId(heroToken, heroTokenId)].add(item)) revert IAppErrors.ErrorConsumableItemIsUsed(item);\\n    emit IApplicationEvents.ConsumableUsed(heroToken, heroTokenId, item);\\n  }\\n\\n  /// @notice Clear all consumable items of the given hero\\n  function clearUsedConsumables(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId\\n  ) internal {\\n    onlyRegisteredContract(c);\\n\\n    EnumerableSet.AddressSet storage items = s.usedConsumables[PackingLib.packNftId(heroToken, heroTokenId)];\\n\\n    uint length = items.length();\\n\\n    for (uint i; i < length; ++i) {\\n      // we are removing the first element, so it's safe to use in cycle\\n      address item = items.at(0);\\n      if (!items.remove(item)) revert IAppErrors.ErrorCannotRemoveItemFromMap();\\n      emit IApplicationEvents.RemoveConsumableUsage(heroToken, heroTokenId, item);\\n    }\\n  }\\n\\n  /// @notice Increase or decrease values of the given attributes, any attributes are allowed.\\n  /// @dev If a core attribute is changed than depended attributes are recalculated\\n  function changeBonusAttributes(\\n    IStatController.MainState storage s,\\n    IController c,\\n    IStatController.ChangeAttributesInfo memory info\\n  ) internal {\\n    IHeroController heroController = onlyRegisteredContract(c);\\n    bytes32 heroPackedId = PackingLib.packNftId(info.heroToken, info.heroTokenId);\\n\\n    IStatController.ChangeableStats memory stats = heroStats(s, info.heroToken, info.heroTokenId);\\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\\n    (bytes32[] storage bonusMain, bytes32[] storage bonusExtra) = info.temporally\\n      ? (s.heroTemporallyAttributes[heroPackedId], s.heroBonusAttributes[heroPackedId])\\n      : (s.heroBonusAttributes[heroPackedId], s.heroTemporallyAttributes[heroPackedId]);\\n\\n    int32[] memory cachedTotalAttrChanged = new int32[](info.changeAttributes.length);\\n    for (uint i; i < info.changeAttributes.length; ++i) {\\n      int32 change = info.changeAttributes[i];\\n      if (change != 0) {\\n        int32 newTotalValue;\\n\\n        if (info.add) {\\n          bonusMain.changeInt32(i, change);\\n          newTotalValue = totalAttributes.getInt32(i) + change;\\n        } else {\\n          bonusMain.changeInt32(i, - change);\\n          newTotalValue = totalAttributes.getInt32(i) - change;\\n        }\\n\\n        // todo in some cases value stored here to totalAttributes will be overwritten below by updateCoreDependAttributes\\n        // it happens if core attribute is changed AND it's depend attribute is change too\\n        // values of the depend attribute will be overwritten by updateCoreDependAttributes\\n        // fix it together with PACKED WRITING\\n        totalAttributes.setInt32(i, newTotalValue);\\n        cachedTotalAttrChanged[i] = newTotalValue;\\n      }\\n    }\\n\\n    _updateCoreDependAttributes(heroController.heroClass(info.heroToken), totalAttributes, bonusMain, bonusExtra, stats, cachedTotalAttrChanged, info.changeAttributes);\\n    _compareStatsWithAttributes(s, heroPackedId, totalAttributes, stats);\\n\\n    emit IApplicationEvents.BonusAttributesChanged(info.heroToken, info.heroTokenId, info.add, info.temporally, msg.sender);\\n  }\\n\\n  /// @dev Make sure we don't have life/mana more than total attributes after decreasing\\n  function _compareStatsWithAttributes(\\n    IStatController.MainState storage s,\\n    bytes32 heroPackedId,\\n    bytes32[] storage totalAttributes,\\n    IStatController.ChangeableStats memory curStats\\n  ) internal {\\n    uint life = totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.LIFE)).toUint();\\n    uint mana = totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.MANA)).toUint();\\n    bool changed;\\n    if (life < curStats.life) {\\n      curStats.life = uint32(Math.min(life, curStats.life));\\n      changed = true;\\n    }\\n    if (mana < curStats.mana) {\\n      curStats.mana = uint32(Math.min(mana, curStats.mana));\\n      changed = true;\\n    }\\n    if (changed) {\\n      _changeChangeableStats(s,\\n        heroPackedId,\\n        curStats.level,\\n        curStats.experience,\\n        curStats.life,\\n        curStats.mana,\\n        curStats.lifeChances\\n      );\\n    }\\n  }\\n\\n  function clearTemporallyAttributes(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId\\n  ) internal {\\n    IHeroController heroController = onlyRegisteredContract(c);\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n\\n    bytes32[] memory tmpBonuses = s.heroTemporallyAttributes[heroPackedId];\\n\\n    IStatController.ChangeableStats memory stats = heroStats(s, heroToken, heroTokenId);\\n    bytes32[] storage bonus = s.heroBonusAttributes[heroPackedId];\\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\\n\\n    int32[] memory baseValues = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    int32[] memory tmpBonusesUnpacked = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < uint(IStatController.ATTRIBUTES.END_SLOT); ++i) {\\n      int32 value = tmpBonuses.getInt32Memory(i);\\n      if (value != int32(0)) {\\n        (baseValues[i],) = totalAttributes.changeInt32(i, - int32(uint32(value)));\\n        tmpBonusesUnpacked[i] = value;\\n      }\\n    }\\n\\n    delete s.heroTemporallyAttributes[heroPackedId];\\n\\n    bytes32[] storage tmpBonusesStorage = s.heroTemporallyAttributes[heroPackedId];\\n\\n    _updateCoreDependAttributes(heroController.heroClass(heroToken), totalAttributes, bonus, tmpBonusesStorage, stats, baseValues, tmpBonusesUnpacked);\\n    _compareStatsWithAttributes(s, heroPackedId, totalAttributes, stats);\\n\\n    emit IApplicationEvents.TemporallyAttributesCleared(heroToken, heroTokenId, msg.sender);\\n  }\\n\\n  /// @dev Update depend-values for all changed attributes\\n  function _updateCoreDependAttributes(\\n    uint heroClass,\\n    bytes32[] storage totalAttributes,\\n    bytes32[] storage bonusMain,\\n    bytes32[] storage bonusExtra,\\n    IStatController.ChangeableStats memory stats,\\n    int32[] memory baseValues,\\n    int32[] memory changed\\n  ) internal {\\n    // handle core depend attributes in the second loop, totalAttributes should be updated together\\n    uint len = changed.length;\\n    for (uint i; i < len; ++i) {\\n      // depend-values should be recalculated if corresponded core value is changed (even if it's equal to 0 now)\\n      if (changed[i] != 0) {\\n        StatLib.updateCoreDependAttributes(totalAttributes, bonusMain, bonusExtra, stats, i, heroClass, baseValues[i]);\\n      }\\n    }\\n  }\\n\\n  function levelUp(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes memory change\\n  ) internal returns (uint newLvl) {\\n    onlyHeroController(c);\\n\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n    if (change.strength + change.dexterity + change.vitality + change.energy != LEVEL_UP_SUM) revert IAppErrors.ErrorWrongLevelUpSum();\\n\\n    IStatController.ChangeableStats memory currentStats = heroStats(s, heroToken, heroTokenId);\\n\\n    if (currentStats.level >= StatLib.MAX_LEVEL) revert IAppErrors.ErrorMaxLevel();\\n    if (currentStats.level.levelExperience() > currentStats.experience) revert IAppErrors.ErrorNotEnoughExperience();\\n    currentStats.level++;\\n\\n    {\\n      int32[] memory data = PackingLib.unpackInt32Array(s._heroCore[heroPackedId]);\\n\\n      data[0] += change.strength;\\n      data[1] += change.dexterity;\\n      data[2] += change.vitality;\\n      data[3] += change.energy;\\n\\n      s._heroCore[heroPackedId] = PackingLib.packInt32Array(data);\\n    }\\n\\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\\n    {\\n      bytes32[] storage bonus = s.heroBonusAttributes[heroPackedId];\\n      bytes32[] storage bonusTmp = s.heroTemporallyAttributes[heroPackedId];\\n\\n      // update\\n      _addCoreToTotal(\\n        heroClass,\\n        totalAttributes,\\n        bonus,\\n        bonusTmp,\\n        currentStats,\\n        change.strength,\\n        uint(IStatController.ATTRIBUTES.STRENGTH)\\n      );\\n      _addCoreToTotal(\\n        heroClass,\\n        totalAttributes,\\n        bonus,\\n        bonusTmp,\\n        currentStats,\\n        change.dexterity,\\n        uint(IStatController.ATTRIBUTES.DEXTERITY)\\n      );\\n      _addCoreToTotal(\\n        heroClass,\\n        totalAttributes,\\n        bonus,\\n        bonusTmp,\\n        currentStats,\\n        change.vitality,\\n        uint(IStatController.ATTRIBUTES.VITALITY)\\n      );\\n      _addCoreToTotal(\\n        heroClass,\\n        totalAttributes,\\n        bonus,\\n        bonusTmp,\\n        currentStats,\\n        change.energy,\\n        uint(IStatController.ATTRIBUTES.ENERGY)\\n      );\\n    }\\n\\n    // setup new level and restore life/mana\\n    currentStats.life = uint32(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.LIFE)).toUint());\\n    currentStats.mana = uint32(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.MANA)).toUint());\\n\\n    _changeChangeableStats(\\n      s,\\n      heroPackedId,\\n      currentStats.level,\\n      currentStats.experience,\\n      currentStats.life,\\n      currentStats.mana,\\n      currentStats.lifeChances\\n    );\\n\\n    emit IApplicationEvents.LevelUp(heroToken, heroTokenId, heroClass, change);\\n\\n    return currentStats.level;\\n  }\\n\\n  /// @notice scb-1009: Update current values of Life and mana during reinforcement as following:\\n  /// Reinforcement increases max value of life/mana on DELTA, current value of life/mana is increased on DELTA too\\n  /// @param prevAttributes Hero attributes before reinforcement\\n  function restoreLifeAndMana(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address heroToken,\\n    uint heroTokenId,\\n    int32[] memory prevAttributes\\n  ) external {\\n    onlyRegisteredContract(c);\\n\\n    IStatController.ChangeableStats memory currentStats = heroStats(s, heroToken, heroTokenId);\\n    bytes32 heroPackedId = PackingLib.packNftId(heroToken, heroTokenId);\\n\\n    // assume here that totalAttributes were already updated during reinforcement\\n    // and so max values of life and mana were increased on delta1 and delta2\\n    bytes32[] storage totalAttributes = s.heroTotalAttributes[heroPackedId];\\n\\n    // now increase current values of life and mana on delta1 and delta2 too\\n    currentStats.life += _getPositiveDelta(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.LIFE)), prevAttributes[uint(IStatController.ATTRIBUTES.LIFE)]);\\n    currentStats.mana += _getPositiveDelta(totalAttributes.getInt32(uint(IStatController.ATTRIBUTES.MANA)), prevAttributes[uint(IStatController.ATTRIBUTES.MANA)]);\\n\\n    _changeChangeableStats(\\n      s,\\n      heroPackedId,\\n      currentStats.level,\\n      currentStats.experience,\\n      currentStats.life,\\n      currentStats.mana,\\n      currentStats.lifeChances\\n    );\\n  }\\n\\n  function _getPositiveDelta(int32 a, int32 b) internal pure returns (uint32) {\\n    return a < b\\n      ? 0\\n      : uint32(uint(int(a - b)));\\n  }\\n\\n  function _addCoreToTotal(\\n    uint heroClass,\\n    bytes32[] storage totalAttributes,\\n    bytes32[] storage bonus,\\n    bytes32[] storage bonusTmp,\\n    IStatController.ChangeableStats memory stats,\\n    int32 changeValue,\\n    uint attrIndex\\n  ) internal {\\n    if (changeValue != 0) {\\n      (int32 newValue,) = totalAttributes.changeInt32(attrIndex, int32(uint32(changeValue)));\\n      StatLib.updateCoreDependAttributes(totalAttributes, bonus, bonusTmp, stats, attrIndex, heroClass, newValue);\\n    }\\n  }\\n\\n  function setHeroCustomData(\\n    IStatController.MainState storage s,\\n    IController c,\\n    address token,\\n    uint tokenId,\\n    bytes32 index,\\n    uint value\\n  ) internal {\\n    IHeroController heroController = onlyRegisteredContract(c);\\n    uint8 ngLevel = heroController.getHeroInfo(token, tokenId).ngLevel;\\n\\n    if (index == KARMA_HASH && value == 0) {\\n      revert IAppErrors.ErrorZeroKarmaNotAllowed();\\n    }\\n\\n    s.heroCustomDataV2[PackingLib.packNftIdWithValue(token, tokenId, ngLevel)].set(index, value);\\n    emit IApplicationEvents.HeroCustomDataChangedNg(token, tokenId, index, value, ngLevel);\\n  }\\n\\n  function setGlobalCustomData(\\n    IStatController.MainState storage s,\\n    IController c,\\n    bytes32 index,\\n    uint value\\n  ) internal {\\n    onlyRegisteredContract(c);\\n\\n    s.globalCustomData[index] = value;\\n\\n    emit IApplicationEvents.GlobalCustomDataChanged(index, value);\\n  }\\n  //endregion ------------------------ ACTIONS\\n}\\n\",\"keccak256\":\"0x159ac338ef6b47b2d18c995c1faa8a5a0d95ca66efe29817e497f82f5a8518f6\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StatLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\n\\nlibrary StatLib {\\n  using PackingLib for bytes32[];\\n  using PackingLib for bytes32;\\n  using PackingLib for uint32[];\\n  using PackingLib for int32[];\\n  using CalcLib for int32;\\n\\n  //region --------------------------- Constants\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant STAT_LIB_VERSION = \\\"1.0.0\\\";\\n  uint32 public constant MAX_LEVEL = 99;\\n\\n  uint public constant BASE_EXPERIENCE = 100_000;\\n  uint public constant BIOME_LEVEL_STEP = 5;\\n  uint internal constant _MAX_AMPLIFIER = 1e18;\\n  uint private constant _PRECISION = 1e18;\\n  uint private constant VIRTUAL_LEVEL_GAP = 2;\\n\\n  /// @dev Assume MAX_BIOME * BIOME_LEVEL_STEP < MAX_LEVEL + 1, see dungeonTreasuryReward\\n  uint public constant MAX_POSSIBLE_BIOME = 19;\\n  //endregion --------------------------- Constants\\n\\n  //region --------------------------- Data types\\n\\n  struct BaseMultiplier {\\n    uint minDamage;\\n    uint maxDamage;\\n    uint attackRating;\\n    uint defense;\\n    uint blockRating;\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct LevelUp {\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct InitialHero {\\n    IStatController.CoreAttributes core;\\n    BaseMultiplier multiplier;\\n    LevelUp levelUp;\\n    int32 baseLifeChances;\\n  }\\n\\n  enum HeroClasses {\\n    UNKNOWN,\\n    THRALL,\\n    SAVAGE,\\n    MAGE,\\n    ASSASSIN,\\n    GHOST,\\n    HAMMERGINA,\\n    END_SLOT\\n  }\\n  //endregion --------------------------- Data types\\n\\n  //region --------------------------- BASE\\n\\n  function isNetworkWithOldSavage() public view returns (bool) {\\n    return block.chainid == uint(111188) || block.chainid == uint(250);\\n  }\\n\\n  // --- HERO 1 (Slave) ---\\n\\n  function initialHero1() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 15,\\n      vitality: 30,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 2e18,\\n      blockRating: 0.1e18,\\n      life: 1.5e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 2e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 2 (Spata) ---\\n\\n  function initialHero2() internal view returns (InitialHero memory) {\\n\\n    bool old = isNetworkWithOldSavage();\\n\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 30,\\n      dexterity: 5,\\n      vitality: 25,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: old ? 0.25e18 : 0.5e18,\\n      attackRating: old ? 2e18 : 3e18,\\n      defense: 1e18,\\n      blockRating: 0.08e18,\\n      life: 1.3e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.8e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 3 (Decidia) ---\\n\\n  function initialHero3() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 10,\\n      dexterity: 15,\\n      vitality: 20,\\n      energy: 25\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 1e18,\\n      blockRating: 0.1e18,\\n      life: 1e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.3e18,\\n      mana: 2e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 4 (Innatus) ---\\n\\n  function initialHero4() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 25,\\n      vitality: 15,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 4e18,\\n      defense: 3e18,\\n      blockRating: 0.2e18,\\n      life: 1.2e18,\\n      mana: 1e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 5 (F2P) ---\\n\\n  function initialHero5() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 20,\\n      dexterity: 20,\\n      vitality: 20,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: 0.25e18,\\n      attackRating: 3e18,\\n      defense: 2.5e18,\\n      blockRating: 0.15e18,\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // --- HERO 6 (F2P) HAMMERGINA ---\\n\\n  function initialHero6() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 50,\\n      dexterity: 30,\\n      vitality: 50,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.2e18,\\n      maxDamage: 0.3e18,\\n      attackRating: 5e18,\\n      defense: 3e18,\\n      blockRating: 0.15e18,\\n      life: 2e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // ------\\n\\n  function initialHero(uint heroClass) internal view returns (InitialHero memory) {\\n    if (heroClass == 1) {\\n      return initialHero1();\\n    } else if (heroClass == 2) {\\n      return initialHero2();\\n    } else if (heroClass == 3) {\\n      return initialHero3();\\n    } else if (heroClass == 4) {\\n      return initialHero4();\\n    } else if (heroClass == 5) {\\n      return initialHero5();\\n    } else if (heroClass == 6) {\\n      return initialHero6();\\n    } else {\\n      revert IAppErrors.UnknownHeroClass(heroClass);\\n    }\\n  }\\n  //endregion --------------------------- BASE\\n\\n  //region --------------------------- CALCULATIONS\\n\\n  function minDamage(int32 strength, uint heroClass) internal view returns (int32) {\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.minDamage / _PRECISION));\\n  }\\n\\n  function maxDamage(int32 strength, uint heroClass) internal view returns (int32){\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.maxDamage / _PRECISION));\\n  }\\n\\n  function attackRating(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.attackRating / _PRECISION));\\n  }\\n\\n  function defense(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.defense / _PRECISION));\\n  }\\n\\n  function blockRating(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(Math.min((dexterity.toUint() * initialHero(heroClass).multiplier.blockRating / _PRECISION), 75)));\\n  }\\n\\n  function life(int32 vitality, uint heroClass, uint32 level) internal view returns (int32){\\n    return int32(int(\\n      (vitality.toUint() * initialHero(heroClass).multiplier.life / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.life / _PRECISION)\\n    ));\\n  }\\n\\n  function mana(int32 energy, uint heroClass, uint32 level) internal view returns (int32){\\n    return int32(int(\\n      (energy.toUint() * initialHero(heroClass).multiplier.mana / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.mana / _PRECISION)\\n    ));\\n  }\\n\\n  function lifeChances(uint heroClass, uint32 /*level*/) internal view returns (int32){\\n    return initialHero(heroClass).baseLifeChances;\\n  }\\n\\n  function levelExperience(uint32 level) internal pure returns (uint32) {\\n    if (level == 0 || level >= MAX_LEVEL) {\\n      return 0;\\n    }\\n    return uint32(uint(level) * BASE_EXPERIENCE * (67e17 - CalcLib.log2((uint(MAX_LEVEL - level + 2)) * 1e18)) / 1e18);\\n  }\\n\\n  function chanceToHit(\\n    uint attackersAttackRating,\\n    uint defendersDefenceRating,\\n    uint attackersLevel,\\n    uint defendersLevel,\\n    uint arFactor\\n  ) internal pure returns (uint) {\\n    attackersAttackRating += attackersAttackRating * arFactor / 100;\\n    uint x = Math.max(attackersAttackRating, 1);\\n    uint y = Math.max(attackersAttackRating + defendersDefenceRating, 1);\\n    uint z = attackersLevel;\\n    uint k = defendersLevel / 2;\\n    uint xy = x * 1e18 / y;\\n    uint zk = z * 1e18 / (attackersLevel + k);\\n    uint base = 2 * xy * zk / 1e18;\\n    return Math.max(Math.min(base, 0.95e18), 0.2e18);\\n  }\\n\\n  function experienceToVirtualLevel(uint experience, uint startFromLevel) internal pure returns (uint level) {\\n    level = startFromLevel;\\n    for (; level < MAX_LEVEL;) {\\n      if (levelExperience(uint32(level)) >= (experience + 1)) {\\n        break;\\n      }\\n      unchecked{++level;}\\n    }\\n  }\\n\\n  function expPerMonster(uint32 monsterExp, uint monsterRarity, uint32 /*heroExp*/, uint32 /*heroCurrentLvl*/, uint /*monsterBiome*/) internal pure returns (uint32) {\\n    // do not reduce exp per level, it is no economical sense\\n    return uint32(uint(monsterExp) + uint(monsterExp) * monsterRarity / _MAX_AMPLIFIER);\\n  }\\n\\n  /// @notice Allow to calculate delta param for {mintDropChance}\\n  function mintDropChanceDelta(uint heroCurrentExp, uint heroCurrentLevel, uint monsterBiome) internal pure returns (uint) {\\n    uint heroBiome = getVirtualLevel(heroCurrentExp, heroCurrentLevel, true) / StatLib.BIOME_LEVEL_STEP + 1;\\n    return heroBiome > monsterBiome ? 2 ** (heroBiome - monsterBiome + 10) : 0;\\n  }\\n\\n  function getVirtualLevel(uint heroCurrentExp, uint heroCurrentLevel, bool withGap) internal pure returns (uint) {\\n    uint virtualLevel = StatLib.experienceToVirtualLevel(heroCurrentExp, heroCurrentLevel);\\n    if (withGap && (virtualLevel + 1) > VIRTUAL_LEVEL_GAP) {\\n      virtualLevel -= VIRTUAL_LEVEL_GAP;\\n    }\\n    return virtualLevel;\\n  }\\n\\n  function initAttributes(\\n    bytes32[] storage attributes,\\n    uint heroClass,\\n    uint32 level,\\n    IStatController.CoreAttributes memory base\\n  ) internal returns (uint32[] memory result) {\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.STRENGTH), base.strength);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEXTERITY), base.dexterity);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.VITALITY), base.vitality);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ENERGY), base.energy);\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN), minDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX), maxDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING), attackRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE), defense(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING), blockRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE), life(base.vitality, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA), mana(base.energy, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE_CHANCES), lifeChances(heroClass, level));\\n\\n    result = new uint32[](3);\\n    result[0] = uint32(life(base.vitality, heroClass, level).toUint());\\n    result[1] = uint32(mana(base.energy, heroClass, level).toUint());\\n    result[2] = uint32(lifeChances(heroClass, uint32(level)).toUint());\\n  }\\n\\n  function updateCoreDependAttributesInMemory(\\n    int32[] memory attributes,\\n    int32[] memory bonus,\\n    uint heroClass,\\n    uint32 level\\n  ) internal view returns (int32[] memory) {\\n    int32 strength = attributes[uint(IStatController.ATTRIBUTES.STRENGTH)];\\n    int32 dexterity = attributes[uint(IStatController.ATTRIBUTES.DEXTERITY)];\\n    int32 vitality = attributes[uint(IStatController.ATTRIBUTES.VITALITY)];\\n    int32 energy = attributes[uint(IStatController.ATTRIBUTES.ENERGY)];\\n\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] = minDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)];\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] = maxDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)];\\n    attributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] = attackRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.ATTACK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.DEFENSE)] = defense(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DEFENSE)];\\n    attributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] = blockRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.BLOCK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.LIFE)] = life(vitality, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.LIFE)];\\n    attributes[uint(IStatController.ATTRIBUTES.MANA)] = mana(energy, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.MANA)];\\n    return attributes;\\n  }\\n\\n  function updateCoreDependAttributes(\\n    bytes32[] storage attributes,\\n    bytes32[] storage bonusMain,\\n    bytes32[] storage bonusExtra,\\n    IStatController.ChangeableStats memory _heroStats,\\n    uint index,\\n    uint heroClass,\\n    int32 base\\n  ) internal {\\n    if (index == uint(IStatController.ATTRIBUTES.STRENGTH)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN),\\n        StatLib.minDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n      );\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX),\\n        StatLib.maxDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.DEXTERITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING),\\n        StatLib.attackRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE),\\n        StatLib.defense(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING),\\n        StatLib.blockRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.VITALITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE),\\n        StatLib.life(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.ENERGY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA),\\n        StatLib.mana(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n      );\\n    }\\n  }\\n\\n  function attributesAdd(int32[] memory base, int32[] memory add) internal pure returns (int32[] memory) {\\n    unchecked{\\n      for (uint i; i < base.length; ++i) {\\n        base[i] += add[i];\\n      }\\n    }\\n    return base;\\n  }\\n\\n// Currently this function is not used\\n//  function attributesRemove(int32[] memory base, int32[] memory remove) internal pure returns (int32[] memory) {\\n//    unchecked{\\n//      for (uint i; i < base.length; ++i) {\\n//        base[i] = CalcLib.minusWithMinFloorI32(base[i], remove[i]);\\n//      }\\n//    }\\n//    return base;\\n//  }\\n\\n  function packChangeableStats(IStatController.ChangeableStats memory stats) internal pure returns (bytes32) {\\n    uint32[] memory cData = new uint32[](5);\\n    cData[0] = stats.level;\\n    cData[1] = stats.experience;\\n    cData[2] = stats.life;\\n    cData[3] = stats.mana;\\n    cData[4] = stats.lifeChances;\\n\\n    return cData.packUint32Array();\\n  }\\n\\n  function unpackChangeableStats(bytes32 data) internal pure returns (IStatController.ChangeableStats memory result) {\\n    uint32[] memory cData = data.unpackUint32Array();\\n    return IStatController.ChangeableStats({\\n      level: cData[0],\\n      experience: cData[1],\\n      life: cData[2],\\n      mana: cData[3],\\n      lifeChances: cData[4]\\n    });\\n  }\\n\\n  function bytesToFullAttributesArray(bytes32[] memory attributes) internal pure returns (int32[] memory result) {\\n    (int32[] memory values, uint8[] memory ids) = attributes.toInt32ArrayWithIds();\\n    return valuesToFullAttributesArray(values, ids);\\n  }\\n\\n  function valuesToFullAttributesArray(int32[] memory values, uint8[] memory ids) internal pure returns (int32[] memory result) {\\n    result = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < values.length; ++i) {\\n      int32 value = values[i];\\n      if (value != 0) {\\n        result[ids[i]] = value;\\n      }\\n    }\\n  }\\n  //endregion --------------------------- CALCULATIONS\\n\\n}\\n\",\"keccak256\":\"0x582a05f0eab2a0d8b7d95e13626e959df6260d56f61735f995e420af7e9841bc\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StringLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n\\nlibrary StringLib {\\n\\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n  function toString(uint value) external pure returns (string memory) {\\n    return _toString(value);\\n  }\\n\\n  function _toString(uint value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint temp = value;\\n    uint digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  function toAsciiString(address x) external pure returns (string memory) {\\n    return _toAsciiString(x);\\n  }\\n\\n  function _toAsciiString(address x) internal pure returns (string memory) {\\n    bytes memory s = new bytes(40);\\n    for (uint i = 0; i < 20; i++) {\\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n      bytes1 hi = bytes1(uint8(b) / 16);\\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n      s[2 * i] = _char(hi);\\n      s[2 * i + 1] = _char(lo);\\n    }\\n    return string(s);\\n  }\\n\\n  function char(bytes1 b) external pure returns (bytes1 c) {\\n    return _char(b);\\n  }\\n\\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n    else return bytes1(uint8(b) + 0x57);\\n  }\\n\\n  function concat(string memory a, string memory b) internal pure returns (string memory) {\\n    return string(abi.encodePacked(a, b));\\n  }\\n\\n  function isASCIILettersOnly(string memory str) internal pure returns (bool) {\\n    bytes memory b = bytes(str);\\n    for (uint i = 0; i < b.length; i++) {\\n      if (uint8(b[i]) < 32 || uint8(b[i]) > 127) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\",\"keccak256\":\"0xcf94b1e6e63466d0100f5181a080968017995f5019a2cfdb35f1ae4a3b7dab3b\",\"license\":\"BUSL-1.1\"},\"contracts/openzeppelin/ERC721Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n  /**\\n   * @dev See {IERC721Receiver-onERC721Received}.\\n   *\\n   * Always returns `IERC721Receiver.onERC721Received.selector`.\\n   */\\n  function onERC721Received(\\n    address,\\n    address,\\n    uint256,\\n    bytes memory\\n  ) public virtual override returns (bytes4) {\\n    return this.onERC721Received.selector;\\n  }\\n}\\n\",\"keccak256\":\"0xaf4708e1efc6a96ca12406877a82d66ea4bc82b71b26e982a70b0ce8755d8eed\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  // To implement this library for multiple types with as little code repetition as possible, we write it in\\n  // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\\n  // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\\n  // This means that we can only create new EnumerableMaps for types that fit in bytes32.\\n\\n  /**\\n   * @dev Query for a nonexistent map key.\\n     */\\n  error EnumerableMapNonexistentKey(bytes32 key);\\n\\n  struct Bytes32ToBytes32Map {\\n    // Storage of keys\\n    EnumerableSet.Bytes32Set _keys;\\n    mapping(bytes32 key => bytes32) _values;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n    map._values[key] = value;\\n    return map._keys.add(key);\\n  }\\n\\n  /**\\n   * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n    delete map._values[key];\\n    return map._keys.remove(key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n    return map._keys.contains(key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n    return map._keys.length();\\n  }\\n\\n  /**\\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n    bytes32 key = map._keys.at(index);\\n    return (key, map._values[key]);\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == bytes32(0)) {\\n      return (contains(map, key), bytes32(0));\\n    } else {\\n      return (true, value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == 0 && !contains(map, key)) {\\n      revert EnumerableMapNonexistentKey(key);\\n    }\\n    return value;\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n    return map._keys.values();\\n  }\\n\\n  // UintToUintMap\\n\\n  struct UintToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key)));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintToAddressMap\\n\\n  struct UintToAddressMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressToUintMap\\n\\n  struct AddressToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n    return remove(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (address(uint160(uint256(key))), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // Bytes32ToUintMap\\n\\n  struct Bytes32ToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, key, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n    return remove(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n    return contains(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (key, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, key);\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, key));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x5052395b3d57e4347a977f96eba69188b4a952594afae411910995ecab5c1d05\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position is the index of the value in the `values` array plus 1.\\n    // Position 0 is used to mean a value is not in the set.\\n    mapping(bytes32 value => uint256) _positions;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._positions[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We cache the value's position to prevent multiple reads from the same storage slot\\n    uint256 position = set._positions[value];\\n\\n    if (position != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 valueIndex = position - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (valueIndex != lastIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the lastValue to the index where the value to delete is\\n        set._values[valueIndex] = lastValue;\\n        // Update the tracked position of the lastValue (that was just moved)\\n        set._positions[lastValue] = position;\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the tracked position for the deleted slot\\n      delete set._positions[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._positions[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n     */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xd5483249a7bac53a40791ade8d640831cdec526eea6b42a4db68f2ce13c008fa\",\"license\":\"MIT\"},\"contracts/openzeppelin/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n  struct InitializableStorage {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n         */\\n    uint64 _initialized;\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n    bool _initializing;\\n  }\\n\\n  // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n  /**\\n   * @dev The contract is already initialized.\\n     */\\n  error InvalidInitialization();\\n\\n  /**\\n   * @dev The contract is not initializing.\\n     */\\n  error NotInitializing();\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n  event Initialized(uint64 version);\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier initializer() {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    // Cache values to avoid duplicated sloads\\n    bool isTopLevelCall = !$._initializing;\\n    uint64 initialized = $._initialized;\\n\\n    // Allowed calls:\\n    // - initialSetup: the contract is not in the initializing state and no previous version was\\n    //                 initialized\\n    // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n    //                 current contract is just being deployed\\n    bool initialSetup = initialized == 0 && isTopLevelCall;\\n    bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n    if (!initialSetup && !construction) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = 1;\\n    if (isTopLevelCall) {\\n      $._initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      $._initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier reinitializer(uint64 version) {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing || $._initialized >= version) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = version;\\n    $._initializing = true;\\n    _;\\n    $._initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n  modifier onlyInitializing() {\\n    _checkInitializing();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n  function _checkInitializing() internal view virtual {\\n    if (!_isInitializing()) {\\n      revert NotInitializing();\\n    }\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n  function _disableInitializers() internal virtual {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing) {\\n      revert InvalidInitialization();\\n    }\\n    if ($._initialized != type(uint64).max) {\\n      $._initialized = type(uint64).max;\\n      emit Initialized(type(uint64).max);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n  function _getInitializedVersion() internal view returns (uint64) {\\n    return _getInitializableStorage()._initialized;\\n  }\\n\\n  /**\\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n  function _isInitializing() internal view returns (bool) {\\n    return _getInitializableStorage()._initializing;\\n  }\\n\\n  /**\\n   * @dev Returns a pointer to the storage namespace.\\n     */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n    assembly {\\n      $.slot := INITIALIZABLE_STORAGE\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x80aa3fc0fc9afdf84bd1a51716150cd13041f42d920a9afa8020ea41cf673809\",\"license\":\"MIT\"},\"contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n\\n  /**\\n    * @dev Muldiv operation overflow.\\n   */\\n  error MathOverflowedMulDiv();\\n\\n  enum Rounding {\\n    Floor, // Toward negative infinity\\n    Ceil, // Toward positive infinity\\n    Trunc, // Toward zero\\n    Expand // Away from zero\\n  }\\n\\n  /**\\n   * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      uint256 c = a + b;\\n      if (c < a) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b > a) return (false, 0);\\n      return (true, a - b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n      if (a == 0) return (true, 0);\\n      uint256 c = a * b;\\n      if (c / a != b) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a / b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a % b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (b == 0) {\\n      // Guarantee the same behavior as in a regular Solidity division.\\n      return a / b;\\n    }\\n\\n    // The following calculation ensures accurate ceiling division without overflow.\\n    // Since a is non-zero, (a - 1) / b will not overflow.\\n    // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n    // but the largest value we can obtain is type(uint256).max - 1, which happens\\n    // when a = type(uint256).max and b = 1.\\n    unchecked {\\n      return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n    unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n      uint256 prod0 = x * y; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n      if (prod1 == 0) {\\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n        // The surrounding unchecked block does not change this fact.\\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n        return prod0 / denominator;\\n      }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n      if (denominator <= prod1) {\\n        revert MathOverflowedMulDiv();\\n      }\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n      uint256 remainder;\\n      assembly {\\n      // Compute remainder using mulmod.\\n        remainder := mulmod(x, y, denominator)\\n\\n      // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n    // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n      uint256 twos = denominator & (0 - denominator);\\n      assembly {\\n      // Divide denominator by twos.\\n        denominator := div(denominator, twos)\\n\\n      // Divide [prod1 prod0] by twos.\\n        prod0 := div(prod0, twos)\\n\\n      // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n\\n    // Shift in bits from prod1 into prod0.\\n      prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n      uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n    // works in modular arithmetic, doubling the correct bits in each step.\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n      result = prod0 * inverse;\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n    unchecked {\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      return min(result, a / result);\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = sqrt(a);\\n      return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 128;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 64;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 32;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 16;\\n      }\\n      if (value >> 8 > 0) {\\n        value >>= 8;\\n        result += 8;\\n      }\\n      if (value >> 4 > 0) {\\n        value >>= 4;\\n        result += 4;\\n      }\\n      if (value >> 2 > 0) {\\n        value >>= 2;\\n        result += 2;\\n      }\\n      if (value >> 1 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log2(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >= 10 ** 64) {\\n        value /= 10 ** 64;\\n        result += 64;\\n      }\\n      if (value >= 10 ** 32) {\\n        value /= 10 ** 32;\\n        result += 32;\\n      }\\n      if (value >= 10 ** 16) {\\n        value /= 10 ** 16;\\n        result += 16;\\n      }\\n      if (value >= 10 ** 8) {\\n        value /= 10 ** 8;\\n        result += 8;\\n      }\\n      if (value >= 10 ** 4) {\\n        value /= 10 ** 4;\\n        result += 4;\\n      }\\n      if (value >= 10 ** 2) {\\n        value /= 10 ** 2;\\n        result += 2;\\n      }\\n      if (value >= 10 ** 1) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log10(value);\\n      return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 16;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 8;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 4;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 2;\\n      }\\n      if (value >> 8 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log256(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n  function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n    return uint8(rounding) % 2 == 1;\\n  }\\n\\n}\\n\",\"keccak256\":\"0x4d972e3e1d79f693b6cb42007d23c27256cb6f087392edea24b93585a822572c\",\"license\":\"MIT\"},\"contracts/proxy/Controllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Initializable.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../lib/SlotsLib.sol\\\";\\n\\n/// @title Implement basic functionality for any contract that require strict control\\n/// @dev Can be used with upgradeable pattern.\\n///      Require call __Controllable_init() in any case.\\n/// @author belbix\\nabstract contract Controllable is Initializable, IControllable {\\n  using SlotsLib for bytes32;\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant CONTROLLABLE_VERSION = \\\"1.0.0\\\";\\n\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.revision\\\")) - 1);\\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.prev_logic\\\")) - 1);\\n\\n  event ContractInitialized(address controller, uint ts, uint block);\\n  event RevisionIncreased(uint value, address oldLogic);\\n\\n  // init implementation contract\\n  constructor() initializer {}\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\n  /// @dev Use it only once after first logic setup\\n  /// @param controller_ Controller address\\n  function __Controllable_init(address controller_) internal onlyInitializing {\\n    _init(controller_);\\n  }\\n\\n  function _init(address controller_) private {\\n    require(controller_ != address(0), \\\"Zero controller\\\");\\n    _CONTROLLER_SLOT.set(controller_);\\n    _CREATED_SLOT.set(block.timestamp);\\n    _CREATED_BLOCK_SLOT.set(block.number);\\n    emit ContractInitialized(controller_, block.timestamp, block.number);\\n  }\\n\\n  /// @dev Return true if given address is controller\\n  function isController(address value_) public override view returns (bool) {\\n    return value_ == controller();\\n  }\\n\\n  /// @notice Return true if given address is setup as governance in Controller\\n  function isGovernance(address value_) public override view returns (bool) {\\n    return IController(controller()).governance() == value_;\\n  }\\n\\n  /// @dev Contract upgrade counter\\n  function revision() external view override returns (uint) {\\n    return _REVISION_SLOT.getUint();\\n  }\\n\\n  /// @dev Previous logic implementation\\n  function previousImplementation() external view override returns (address) {\\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\\n  }\\n\\n  // ************* SETTERS/GETTERS *******************\\n\\n  /// @notice Return controller address saved in the contract slot\\n  function controller() public view override returns (address) {\\n    return _CONTROLLER_SLOT.getAddress();\\n  }\\n\\n  /// @notice Return creation timestamp\\n  /// @return Creation timestamp\\n  function created() external view override returns (uint256) {\\n    return _CREATED_SLOT.getUint();\\n  }\\n\\n  /// @notice Return creation block number\\n  /// @return Creation block number\\n  function createdBlock() external override view returns (uint256) {\\n    return _CREATED_BLOCK_SLOT.getUint();\\n  }\\n\\n  /// @dev Revision should be increased on each contract upgrade\\n  function increaseRevision(address oldLogic) external override {\\n    require(msg.sender == address(this), \\\"Increase revision forbidden\\\");\\n    uint r = _REVISION_SLOT.getUint() + 1;\\n    _REVISION_SLOT.set(r);\\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\\n    emit RevisionIncreased(r, oldLogic);\\n  }\\n\\n}\\n\",\"keccak256\":\"0x1edc53f0d11834bebf4485746d04112ed10db9d4cb19b4945362c593ebf97daf\",\"license\":\"BUSL-1.1\"},\"contracts/relay/ERC2771Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.1;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\n// based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol\\nabstract contract ERC2771Context {\\n  // for whitelist new relayers need to add new constants and update proxies\\n  address private constant GELATO_RELAY_1_BALANCE_ERC_2771 = 0xd8253782c45a12053594b9deB72d8e8aB2Fca54c;\\n  address private constant SACRA_RELAY = 0x52CEba41Da235Af367bFC0b0cCd3314cb901bB5F;\\n  address private constant SACRA_RELAY_2 = 0x102f1f556cD9C3D5f820E6920A8931657c5Da21B;\\n\\n  function isTrustedForwarder(address forwarder) public view virtual returns (bool){\\n    return forwarder == GELATO_RELAY_1_BALANCE_ERC_2771 || forwarder == SACRA_RELAY || forwarder == SACRA_RELAY_2;\\n  }\\n\\n  function _msgSender() internal view virtual returns (address sender) {\\n    if (isTrustedForwarder(msg.sender)) {\\n      // The assembly code is more direct than the Solidity version using `abi.decode`.\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n      }\\n      return sender;\\n    } else {\\n      return msg.sender;\\n    }\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    if (isTrustedForwarder(msg.sender)) {\\n      return msg.data[: msg.data.length - 20];\\n    } else {\\n      return msg.data;\\n    }\\n  }\\n\\n  /// @notice Return true if given address is not a smart contract but a wallet address.\\n  /// @dev It is not 100% guarantee after EIP-3074 implementation, use it as an additional check.\\n  /// @return true if the address is a wallet.\\n  function _isNotSmartContract() internal view returns (bool) {\\n    return isTrustedForwarder(msg.sender) || msg.sender == tx.origin;\\n  }\\n\\n  function onlyEOA() internal view {\\n    if (!_isNotSmartContract()) {\\n      revert IAppErrors.NotEOA(msg.sender);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x7af64d60f6e51e2595b6412b2c4e4ed51a9895851eba74ad2444124d26163180\",\"license\":\"MIT\"},\"contracts/solady/LibPRNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for generating pseudorandom numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\\n/// @author LazyShuffler based on NextShuffler by aschlosberg (divergencearran)\\n/// (https://github.com/divergencetech/ethier/blob/main/contracts/random/NextShuffler.sol)\\nlibrary LibPRNG {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The initial length must be greater than zero and less than `2**32 - 1`.\\n    error InvalidInitialLazyShufflerLength();\\n\\n    /// @dev The new length must not be less than the current length.\\n    error InvalidNewLazyShufflerLength();\\n\\n    /// @dev The lazy shuffler has not been initialized.\\n    error LazyShufflerNotInitialized();\\n\\n    /// @dev Cannot double initialize the lazy shuffler.\\n    error LazyShufflerAlreadyInitialized();\\n\\n    /// @dev The lazy shuffle has finished.\\n    error LazyShuffleFinished();\\n\\n    /// @dev The queried index is out of bounds.\\n    error LazyShufflerGetOutOfBounds();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pseudorandom number state in memory.\\n    struct PRNG {\\n        uint256 state;\\n    }\\n\\n    /// @dev A lazy Fisher-Yates shuffler for a range `[0..n)` in storage.\\n    struct LazyShuffler {\\n        // Bits Layout:\\n        // - [0..31]    `numShuffled`\\n        // - [32..223]  `permutationSlot`\\n        // - [224..255] `length`\\n        uint256 _state;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Seeds the `prng` with `state`.\\n    function seed(PRNG memory prng, uint256 state) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(prng, state)\\n        }\\n    }\\n\\n    /// @dev Returns the next pseudorandom uint256.\\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\\n        // We simply use `keccak256` for a great balance between\\n        // runtime gas costs, bytecode size, and statistical properties.\\n        //\\n        // A high-quality LCG with a 32-byte state\\n        // is only about 30% more gas efficient during runtime,\\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\\n        // when this function is inlined.\\n        //\\n        // Using this method is about 2x more efficient than\\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n        }\\n    }\\n\\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\\n    /// between 0 (inclusive) and `upper` (exclusive).\\n    /// If your modulus is big, this method is recommended\\n    /// for uniform sampling to avoid modulo bias.\\n    /// For uniform sampling across all uint256 values,\\n    /// or for small enough moduli such that the bias is neligible,\\n    /// use {next} instead.\\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := keccak256(prng, 0x20)\\n                mstore(prng, result)\\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\\n            }\\n            result := mod(result, upper)\\n        }\\n    }\\n\\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n\\n                    {\\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                let b := add(a, 0x01)\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let o := mod(shr(128, r), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n\\n                    {\\n                        let o := mod(and(r, mask), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the standard normal distribution denominated in `WAD`.\\n    function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\\n            // The chance of drawing a sample outside 10 \\u03c3 from the standard normal distribution\\n            // is \\u2248 0.000000000000000000000015, which is insignificant for most practical purposes.\\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\\n            let s := 0x1000000000000000100000000000000010000000000000001\\n            let r1 := mulmod(result, a, n)\\n            let r2 := mulmod(r1, a, n)\\n            let r3 := mulmod(r2, a, n)\\n            // forgefmt: disable-next-item\\n            result := sub(sar(96, mul(26614938895861601847173011183,\\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the unit exponential distribution denominated in `WAD`.\\n    function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\\n            // Gas usage varies, starting from about 172+ gas.\\n            let r := keccak256(prng, 0x20)\\n            mstore(prng, r)\\n            let p := shl(129, r)\\n            let w := shl(1, r)\\n            if iszero(gt(w, p)) {\\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n                for {} 1 {} {\\n                    r := mulmod(r, a, n)\\n                    if iszero(lt(shl(129, r), w)) {\\n                        r := mulmod(r, a, n)\\n                        result := add(1000000000000000000, result)\\n                        w := shl(1, r)\\n                        p := shl(129, r)\\n                        if iszero(lt(w, p)) { break }\\n                        continue\\n                    }\\n                    w := shl(1, r)\\n                    if iszero(lt(w, shl(129, r))) { break }\\n                }\\n            }\\n            result := add(div(p, shl(129, 170141183460469231732)), result)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*       STORAGE-BASED RANGE LAZY SHUFFLING OPERATIONS        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Initializes the state for lazy-shuffling the range `[0..n)`.\\n    /// Reverts if `n == 0 || n >= 2**32 - 1`.\\n    /// Reverts if `$` has already been initialized.\\n    /// If you need to reduce the length after initialization, just use a fresh new `$`.\\n    function initialize(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sload($.slot) {\\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, $.slot)\\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Increases the length of `$`.\\n    /// Reverts if `$` has not been initialized.\\n    function grow(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            // If the new length is smaller than the old length, revert.\\n            if lt(n, shr(224, state)) {\\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\\n        }\\n    }\\n\\n    /// @dev Restarts the shuffler by setting `numShuffled` to zero,\\n    /// such that all elements can be drawn again.\\n    /// Restarting does NOT clear the internal permutation, nor changes the length.\\n    /// Even with the same sequence of randomness, reshuffling can yield different results.\\n    function restart(LazyShuffler storage $) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot)\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, shl(32, shr(32, state)))\\n        }\\n    }\\n\\n    /// @dev Returns the number of elements that have been shuffled.\\n    function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := and(0xffffffff, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns the length of `$`.\\n    /// Returns zero if `$` is not initialized, else a non-zero value less than `2**32 - 1`.\\n    function length(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := shr(224, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns if `$` has been initialized.\\n    function initialized(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(iszero(sload($.slot)))\\n        }\\n    }\\n\\n    /// @dev Returns if there are any more elements left to shuffle.\\n    /// Reverts if `$` is not initialized.\\n    function finished(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := eq(shr(224, state), and(0xffffffff, state))\\n        }\\n    }\\n\\n    /// @dev Returns the current value stored at `index`, accounting for all historical shuffling.\\n    /// Reverts if `index` is greater than or equal to the `length` of `$`.\\n    function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            let n := shr(224, state) // Length of `$`.\\n            if iszero(lt(index, n)) {\\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let u32 := gt(n, 0xfffe)\\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\\n            result := and(m, shr(o, sload(s)))\\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\\n        }\\n    }\\n\\n    /// @dev Does a single Fisher-Yates shuffle step, increments the `numShuffled` in `$`,\\n    /// and returns the next value in the shuffled range.\\n    /// `randomness` can be taken from a good-enough source, or a higher quality source like VRF.\\n    /// Reverts if there are no more values to shuffle, which includes the case if `$` is not initialized.\\n    function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function _get(u32_, state_, i_) -> _value {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                _value := and(m_, shr(o_, sload(s_)))\\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\\n            }\\n            function _set(u32_, state_, i_, value_) {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                let v_ := sload(s_) // Bucket slot value.\\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\\n            }\\n            let state := sload($.slot) // The packed value at `$`.\\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\\n            let n := shr(224, state) // Length of `$`.\\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\\n            if iszero(remainder) {\\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\\n            chosen := _get(gt(n, 0xfffe), state, index)\\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdcb71f8dc72bb7384776154ca24d34c23e3c9bcf124bc75f0d2e379f9ebd021d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b507ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00805468010000000000000000810460ff1615906001600160401b03166000811580156200005d5750825b90506000826001600160401b031660011480156200007a5750303b155b90508115801562000089575080155b15620000a85760405163f92ee8a960e01b815260040160405180910390fd5b84546001600160401b03191660011785558315620000d757845460ff60401b1916680100000000000000001785555b83156200011e57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505061575a80620001336000396000f3fe608060405234801561001057600080fd5b506004361061021e5760003560e01c80639a641e0211610126578063b429afeb116100b3578063b429afeb146104eb578063b5a44d04146104fe578063b6d2fe6c14610511578063b701c1aa1461053f578063be2e0ad81461055f578063d06969c71461057f578063dee1f0e414610592578063e76bd825146105a5578063f77c4791146105b8578063fee27cbe146105c0578063ffa1ad74146105d357600080fd5b80639a641e021461042a5780639d0bcca01461043d5780639f3cfa7a14610452578063a433af6f1461045a578063a46374b31461046d578063a4efd30914610497578063a7540ee5146104aa578063ac257b3a146104bd578063ad8c5755146104d0578063b2192fdd146104e357600080fd5b80634fac6ccd116101af5780634fac6ccd1461031b578063572b6c051461032e57806357bd05b0146103415780635a67eb48146103545780636a8a5e8c146103675780636bb4b4591461037a5780637442adbc146103a55780637be89369146103b85780637c00116c146103de5780637cc96380146103f1578063936725ec146103f957600080fd5b80630e30c13e14610223578063150b7a021461024d57806319ab453c1461027957806327dd892f1461028e5780632fcd5deb146102a1578063325a19f1146102c457806338430cce146102da5780634593144c146102ed57806348b371bf146102f55780634d52532c14610308575b600080fd5b6102366102313660046142a5565b6105f7565b60405160ff90911681526020015b60405180910390f35b61026061025b3660046143af565b61060c565b6040516001600160e01b03199091168152602001610244565b61028c61028736600461441a565b61061d565b005b61028c61029c36600461446c565b610717565b6102b46102af3660046144d1565b61073d565b6040519015158152602001610244565b6102cc6107c4565b604051908152602001610244565b61028c6102e8366004614520565b6107fd565b6102cc61081f565b61028c61030336600461456f565b61084f565b6102cc61031636600461456f565b610863565b61028c61032936600461441a565b61086e565b6102b461033c36600461441a565b610980565b61028c61034f36600461459e565b6109f5565b61028c6103623660046142a5565b610a98565b61028c6103753660046145f1565b610aaa565b61038d6103883660046145f1565b610b40565b6040516001600160401b039091168152602001610244565b6102cc6103b3366004614633565b610c02565b6103cb6103c636600461464c565b610c0d565b60405161ffff9091168152602001610244565b61038d6103ec3660046146a7565b610c3b565b6102cc610c47565b61041d604051806040016040528060058152602001640312e302e360dc1b81525081565b604051610244919061470f565b61038d6104383660046142a5565b610c65565b610445610c71565b6040516102449190614722565b61038d610ca1565b61028c6104683660046142a5565b610cab565b61048061047b36600461456f565b610d30565b6040516102449b9a999897969594939291906147e3565b61028c6104a536600461488e565b610d70565b6102cc6104b836600461441a565b610d88565b6102cc6104cb3660046148cc565b610d93565b6102b46104de3660046142a5565b610dbc565b610236610dd0565b6102b46104f936600461441a565b610dda565b61028c61050c366004614950565b610dff565b61052461051f366004614991565b610e89565b60408051938452602084019290925290820152606001610244565b61055261054d3660046149cc565b610f45565b6040516102449190614a6f565b61057261056d3660046142a5565b610f56565b6040516102449190614b45565b61038d61058d3660046145f1565b610f62565b6102b46105a036600461441a565b610fc9565b61028c6105b3366004614e80565b61104e565b610445611064565b61028c6105ce36600461456f565b611094565b61041d60405180604001604052806005815260200164322e312e3160d81b81525081565b600061060383836110b5565b90505b92915050565b630a85bd0160e11b5b949350505050565b60006106276110f2565b805490915060ff600160401b82041615906001600160401b031660008115801561064e5750825b90506000826001600160401b0316600114801561066a5750303b155b905081158015610678575080155b156106965760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff1916600117855583156106c057845460ff60401b1916600160401b1785555b6106c986611116565b831561070f57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b610739610722611127565b61072a611064565b61073261113f565b8585611161565b5050565b60006107bb61074a6111fb565b610752611064565b6001600160a01b0316628e96916040518163ffffffff1660e01b8152600401602060405180830381865afa15801561078e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107b2919061503f565b8787878761121f565b95945050505050565b60006107f86107f460017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b615072565b5490565b905090565b610739610808611127565b610810611064565b61081861113f565b85856114d8565b60006107f86107f460017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1615072565b61086061085a611064565b82611716565b50565b60006106068261176e565b3330146108c05760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b60006108de6107f46001600080516020615705833981519152615072565b6108e9906001615085565b905061090b816109086001600080516020615705833981519152615072565b55565b61093a8261090860017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4615072565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c891015b60405180910390a15050565b60006001600160a01b03821673d8253782c45a12053594b9deb72d8e8ab2fca54c14806109c957506001600160a01b0382167352ceba41da235af367bfc0b0ccd3314cb901bb5f145b8061060657506001600160a01b03821673102f1f556cd9c3d5f820e6920a8931657c5da21b1492915050565b73Efa058adaC8A0D21724D73f9466e3AF0D1B9A358637c1ecb8e610a17611064565b6040516001600160e01b031960e084901b1681526001600160a01b03918216600482015263ffffffff8816602482015290861660448201526064810185905260ff8416608482015260a40160006040518083038186803b158015610a7a57600080fd5b505af4158015610a8e573d6000803e3d6000fd5b5050505050505050565b610739610aa3611064565b838361179a565b73Efa058adaC8A0D21724D73f9466e3AF0D1B9A3586303395eef610acc611064565b6040516001600160e01b031960e084901b1681526001600160a01b03918216600482015281871660248201526044810186905290841660648201526084015b60006040518083038186803b158015610b2357600080fd5b505af4158015610b37573d6000803e3d6000fd5b50505050505050565b600073Efa058adaC8A0D21724D73f9466e3AF0D1B9A35863987707f9610b64611127565b610b6c611064565b610b7461113f565b6040516001600160e01b031960e086901b16815292151560048401526001600160a01b03918216602484015281166044830152808816606483015260848201879052851660a482015260c4015b602060405180830381865af4158015610bde573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106159190615098565b600061060682611839565b600080610c198761185a565b9050610c30610c266111fb565b8288888888611872565b979650505050505050565b60006106038383611b9f565b60006107f86107f46001600080516020615705833981519152615072565b60006106038383611bc2565b60006107f86107f460017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4615072565b60006107f8611c05565b73Efa058adaC8A0D21724D73f9466e3AF0D1B9A35863dc01b901610ccd611064565b6040516001600160e01b031960e084901b1681526001600160a01b0391821660048201529085166024820152604481018490526064015b60006040518083038186803b158015610d1c57600080fd5b505af415801561070f573d6000803e3d6000fd5b600080600080600080606080606060006060610d4b8c611c21565b9a509a509a509a509a509a509a509a509a509a509a5091939597999b90929496989a50565b610d83610d7b611064565b848484611eca565b505050565b6000610606826120b8565b6000610db08888888860ff168860ff168860ff168860ff166120e4565b98975050505050505050565b6000610603610dc9611064565b8484612283565b60006107f8612396565b6000610de4611064565b6001600160a01b0316826001600160a01b0316149050919050565b73Efa058adaC8A0D21724D73f9466e3AF0D1B9A35863efa20d9b610e21611127565b610e29611064565b610e3161113f565b6040516001600160e01b031960e086901b16815292151560048401526001600160a01b039182166024840152811660448301526001600160401b03871660648301528516608482015260a4810184905260c401610b0b565b600080600073Efa058adaC8A0D21724D73f9466e3AF0D1B9A358633e457e4f610eb0611064565b6040516001600160e01b031960e084901b1681526001600160a01b039182166004820152908a16602482015260448101899052606481018890526084810187905260a401606060405180830381865af4158015610f11573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f3591906150b5565b9250925092509450945094915050565b610f4d614071565b610606826123ac565b60606106038383612662565b600073Efa058adaC8A0D21724D73f9466e3AF0D1B9A35863c77d56a2610f86611064565b6040516001600160e01b031960e084901b1681526001600160a01b0391821660048201528186166024820152908716604482015260648101869052608401610bc1565b6000816001600160a01b0316610fdd611064565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa15801561101a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061103e919061503f565b6001600160a01b03161492915050565b61070f611059611064565b87878787878761269b565b60006107f86107f460017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618615072565b61086061109f611127565b6110a7611064565b6110af61113f565b84612aa2565b60006110bf612aca565b60030160006110d76001600160a01b03861685612ad4565b815260208101919091526040016000205460ff169392505050565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b61111e612b24565b61086081612b4b565b600061113233610980565b806107f857505032331490565b600061114a33610980565b1561115c575060131936013560601c90565b503390565b61116a85612c5e565b60405163139ed9b560e21b81526001600160a01b0380861660048301526001600160401b0384166024830152821515604483015284166064820152739ceDa5bC06a5b3a2416FAca9D37dcbe7410260cf90634e7b66d49060840160006040518083038186803b1580156111dc57600080fd5b505af41580156111f0573d6000803e3d6000fd5b505050505050505050565b7fae5971282b317bbed599861775fe0712755bb3b2f655bfe8fb14280d8429f60090565b61ffff84166000908152600d870160205260408120600281015460ff8082169160081c81169087168211806112565750808760ff16115b1561126757600093505050506114ce565b50506000816003018054806020026020016040519081016040528092919081815260200182805480156112b957602002820191906000526020600020905b8154815260200190600101908083116112a5575b5050505050905060008260040180548060200260200160405190810160405280929190818152602001828054801561131057602002820191906000526020600020905b8154815260200190600101908083116112fc575b505085519394506000925050505b818110156114c457600084828151811061133a5761133a6150e3565b602002602001015190506000801b810361135457506114bc565b600080600061138b87868151811061136e5761136e6150e3565b602002602001015190604082901c90608083901c60ff1660011490565b92509250925060008161140c578f6001600160a01b0316630a82c861866040518263ffffffff1660e01b81526004016113c691815260200190565b602060405180830381865afa1580156113e3573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061140791906150f9565b61147d565b8f6001600160a01b0316631c2aafe78e8e886040518463ffffffff1660e01b815260040161143c93929190615112565b602060405180830381865afa158015611459573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061147d91906150f9565b9050836001600160401b031681108061149e5750826001600160401b031681115b156114b65760009a50505050505050505050506114ce565b50505050505b60010161131e565b5060019450505050505b9695505050505050565b60006114e2612aca565b905060006114ef8661185a565b6040805160a0810182526000808252602080830182905282840182905260608301829052608083018290526001600160401b0389168252600e870181528382208054600160401b900461ffff168352600d8801909152929020929350916115558a612c5e565b611560828986612c7c565b50508160020160009054906101000a900463ffffffff16836040019063ffffffff16908163ffffffff1681525050739ceDa5bC06a5b3a2416FAca9D37dcbe7410260cf6311942d1783838a8c8b8f8a604001516040518863ffffffff1660e01b81526004016115d59796959493929190615133565b608060405180830381865af41580156115f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116169190615190565b1515602087015263ffffffff1660608601526080850152158015845261164857815460ff60501b1916600160501b1782555b60808301511561167957608083015160028301805460ff909216600160201b0264ff00000000199092169190911790555b826040015163ffffffff16836060015163ffffffff16146116b557606083015160028301805463ffffffff191663ffffffff9092169190911790555b8260200151156116d55780546116d5908390610100900460ff1689612da4565b82511580156116ec5750600282015463ffffffff16155b80156116fa57508260200151155b1561170a5761170a848989612e0f565b50505050505050505050565b61171f8261307e565b604051632586866b60e11b81526001600160a01b03831660048201526001600160401b0382166024820152739ceDa5bC06a5b3a2416FAca9D37dcbe7410260cf90634b0d0cd690604401610d04565b6000611778612aca565b6001600160401b039092166000908152600f9290920160205250604090205490565b6117a38361307e565b60058110156117c857604051634bebee7f60e01b8152600481018290526024016108b7565b806117d1612aca565b600a016000846001600160a01b03166001600160a01b03168152602001908152602001600020819055507f996f9d801b1a05cd3c7b555e5b6f61db994ea8ef57125b5b5d3b07b9dad4e2cf828260405161182c9291906151da565b60405180910390a1505050565b6000610606611846612aca565b60008481526020919091526040902061310a565b6118626140d1565b6001600160a01b03909116815290565b60008460ff166000036118985760405163a8473eab60e01b815260040160405180910390fd5b6000806118a488613114565b604051631ebd249360e01b81529091506001600160a01b03821690631ebd2493906118d590899089906004016151da565b602060405180830381865afa1580156118f2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061191691906151f3565b915060008960050160006119ad60058b6119309190615226565b61193b906001615248565b604051631789b7b160e01b81526001600160a01b03871690631789b7b190611967908e90600401614722565b602060405180830381865afa158015611984573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119a891906151f3565b613134565b8152602081019190915260400160009081205461ffff169150819003611a0d578960050160006119f560058b6119e39190615226565b6119ee906001615248565b6000613134565b815260208101919091526040016000205461ffff1690505b8061ffff16600003611a4257896005016000611a2a600080613134565b815260208101919091526040016000205461ffff1690505b61ffff811615611ac8576001600160a01b03871660a087901b67ffffffffffffffff60a01b161760f082901b6001600160f01b03191617600090815260028b01602052604090205460ff16158015611ab9575061ffff81166000908152600d8b01602052604090205460ff84811661010090920416145b15611ac85792506114ce915050565b505060ff81166000908152600889016020526040812090611ae88261310a565b905080600003611b0f576040516283533360e01b815260ff841660048201526024016108b7565b6000611b1a8a613149565b9050600080611b298489615261565b905060005b84811015611b8557611b408683613168565b9250611b508e85858f8f8f61121f565b15611b6457829750505050505050506114ce565b81611b6e81615275565b925050848210611b7d57600091505b600101611b2e565b5060405163b940612960e01b815260040160405180910390fd5b600061060383611bad612aca565b60008581526020919091526040902090613168565b6000611bcc612aca565b6004016000611be46001600160a01b03861685612ad4565b81526020810191909152604001600020546001600160401b03169392505050565b6000611c0f612aca565b600c01546001600160401b0316919050565b6000806000806000806060806060600060606000611c3d612aca565b600e0160008e6001600160401b03166001600160401b0316815260200190815260200160002090508060000160089054906101000a900461ffff169b5080600001600a9054906101000a900460ff169a5080600001600b9054906101000a90046001600160a01b03169950806001015498508060020160009054906101000a900463ffffffff1697508060020160049054906101000a900460ff16965080600601805480602002602001604051908101604052809291908181526020018280548015611d2857602002820191906000526020600020905b815481526020019060010190808311611d14575b505050600784015460088501805460408051602080840282018101909252828152969a5060ff90931698509093509150830182828015611db357602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff1681526020019060040190602082600301049283019260010382029150808411611d765790505b505050505091506000611dc882600301613174565b9050806001600160401b03811115611de257611de26142d1565b604051908082528060200260200182016040528015611e0b578160200160208202803683370190505b509650806001600160401b03811115611e2657611e266142d1565b604051908082528060200260200182016040528015611e4f578160200160208202803683370190505b50955060005b81811015611eb857611e6a600384018261317f565b898381518110611e7c57611e7c6150e3565b60200260200101898481518110611e9557611e956150e3565b60209081029190910101919091526001600160a01b039091169052600101611e55565b50505091939597999b90929496989a50565b611ed38461307e565b6000611edd612aca565b61ffff85166000908152600d820160205260408120805461ffff198116825592935061010090920460ff169190611f1760018301826140f4565b6002820160009055600382016000611f2f9190614119565b611f3d600483016000614119565b600582016000611f4d8282614119565b611f5b600183016000614137565b50505060ff821660009081526008840160205260409020611f81915061ffff871661319b565b15611fe15760ff811660009081526008830160205260409020611fa89061ffff87166131b3565b5060405161ffff861681527f6ee9dd6501e6ec9a0a3e60e773ac5fd9d48414213bc6a16588c88bda44f492899060200160405180910390a15b611ff26006830161ffff871661319b565b1561070f5760006120038585613134565b600081815260058501602052604090205490915061ffff87811691161461203d5760405163066a129160e31b815260040160405180910390fd5b60008181526005840160205260409020805461ffff191690556120676006840161ffff88166131b3565b506040805161ffff8816815260ff878116602083015286168183015290517f9c5c01904f703f1392e848da84f3f506975241d8d8d0f67550729c5f5080c94e9181900360600190a150505050505050565b60006120c2612aca565b6001600160a01b039092166000908152600a9290920160205250604090205490565b6000868410806120f357508282105b1561210057506000610c30565b600061210a6111fb565b6001600160a01b038a166000908152600a9190910160205260409020549050801580159061213757508086105b15612146576000915050610c30565b606386111561216b57604051633505ce1b60e11b8152600481018790526024016108b7565b601385111561219057604051637d34ca9360e01b8152600481018690526024016108b7565b600061219d60058761528e565b9050675c33b801024d7e4a600060646121dc6121ba856063615072565b6121c5906001615085565b6121d790670de0b6b3a764000061528e565b6131bf565b6121e69084615072565b6121f091906152a5565b9050670de0b6b3a7640000811061221d57604051630dd7f01960e01b8152600481018290526024016108b7565b6000670de0b6b3a7640000612232838d61528e565b61223c91906152a5565b90508984101561227357612250848b615072565b61225b90600a615085565b61226690600261539d565b61227090826152a5565b90505b9c9b505050505050505050505050565b600080846001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156122c4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122e8919061503f565b6001600160a01b0316631ebd249385856040518363ffffffff1660e01b81526004016123159291906151da565b602060405180830381865afa158015612332573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061235691906151f3565b9050612360612aca565b60010160006123796001600160a01b03871686856132a0565b815260208101919091526040016000205460ff1695945050505050565b60006123a0612aca565b6009015460ff16919050565b6123b4614071565b6123bc612aca565b61ffff83166000908152600d919091016020908152604091829020825160e081018452815460ff808216835261010090910416818401526001820180548551818602810186018752818152929593949386019383018282801561246a57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff168152602001906004019060208260030104928301926001038202915080841161242d5790505b5050505050815260200160028201548152602001600382018054806020026020016040519081016040528092919081815260200182805480156124cc57602002820191906000526020600020905b8154815260200190600101908083116124b8575b505050505081526020016004820180548060200260200160405190810160405280929190818152602001828054801561252457602002820191906000526020600020905b815481526020019060010190808311612510575b50505050508152602001600582016040518060400160405290816000820180548060200260200160405190810160405280929190818152602001828054801561258c57602002820191906000526020600020905b815481526020019060010190808311612578575b5050505050815260200160018201805480602002602001604051908101604052809291908181526020016000905b828210156126525760008481526020908190208301805460408051828502810185019091528181529283018282801561263e57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff16815260200190600401906020826003010492830192600103820291508084116126015790505b5050505050815260200190600101906125ba565b5050509152505090525092915050565b606061060361266f612aca565b600b0160006126876001600160a01b03871686612ad4565b8152602001908152602001600020546132d5565b6126a48761307e565b60006126ae612aca565b60208601515186515191925090811415806126ce57508560400151518114155b156126ec5760405163c81acf3360e01b815260040160405180910390fd5b60005b8181101561275957865180518290811061270b5761270b6150e3565b6020026020010151518760200151828151811061272a5761272a6150e3565b602002602001015151146127515760405163f001029b60e01b815260040160405180910390fd5b6001016126ef565b5061ffff88166000908152600d830160205260409020600983015460ff90811690891611156127945760098301805460ff191660ff8a161790555b805460ff8981166101000261ffff1990921690841617178155604087015180516127c8916001840191602090910190614155565b506127db87606001518860800151613134565b600282015560a087015180516127fb916003840191602090910190614204565b506004810160005b8860c001515181101561288f57816128748a60c00151838151811061282a5761282a6150e3565b60200260200101518b60e001518481518110612848576128486150e3565b60200260200101518c61010001518581518110612867576128676150e3565b602002602001015161334d565b81546001818101845560009384526020909320015501612803565b5060005b83811015612930578851805160058501916128c591849081106128b8576128b86150e3565b6020026020010151613388565b8154600181018355600092835260209283902001558901518051600685019190839081106128f5576128f56150e3565b602090810291909101810151825460018101845560009384529282902081516129279491909101929190910190614155565b50600101612893565b508415612a325760006129438888613134565b600081815260058701602052604090205490915061ffff161561297f576040516366e6550f60e01b815261ffff8c1660048201526024016108b7565b60008181526005860160205260409020805461ffff191661ffff8d169081179091556129af90600687019061319b565b156129d35760405163ce9c78df60e01b815261ffff8c1660048201526024016108b7565b6129e46006860161ffff8d16613407565b506040805161ffff8d16815260ff8a8116602083015289168183015290517fc27376e37bec2cd9acd6957a46ca5cba20a88a21fd0eff1b02cf8536462304769181900360600190a150612a5c565b8154610100900460ff1660009081526008850160205260409020612a5a9061ffff8c16613407565b505b7fa8932b9bd78638467b3e5c0f0ffa9c72761db9f7f605b8df2f7a899770d064ae8a89604051612a8d929190615463565b60405180910390a15050505050505050505050565b612aab84612c5e565b6000612ab68461185a565b9050612ac3818484612e0f565b5050505050565b60006107f86111fb565b60006001600160401b03821115612b0157604051633995b34160e01b8152600481018390526024016108b7565b5067ffffffffffffffff60a01b60a09190911b166001600160a01b039091161790565b612b2c613413565b612b4957604051631afcd79f60e31b815260040160405180910390fd5b565b6001600160a01b038116612b935760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b60448201526064016108b7565b612bc28161090860017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618615072565b612bf14261090860017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b615072565b612c204361090860017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1615072565b7f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe236713426814243604051612c5393929190615112565b60405180910390a150565b8061086057604051636221cab960e01b815260040160405180910390fd5b82546001840154600160581b82046001600160a01b031691600160501b900460ff1615612cbc57604051636927c40b60e11b815260040160405180910390fd5b612cc88282868661342d565b612cd183613149565b6001600160a01b031663f16a306683836040518363ffffffff1660e01b8152600401612cfe9291906151da565b602060405180830381865afa158015612d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d3f9190615562565b612d6057818160405163033aace360e41b81526004016108b79291906151da565b84546001600160401b0316612d758383611bc2565b6001600160401b031614612d9c576040516337bcc65160e01b815260040160405180910390fd5b935093915050565b8254600160581b600160f81b03191683556000600184015560028301805464ffffffffff19169055612dd682826135ea565b6040516001600160401b03821681527f883aa0807cbcd64d238a9795b0433f37884de37e569aff04d512cb1df62c6e019060200161182c565b6000612e19612aca565b6001600160401b0383166000908152600e8201602090815260408083208054600160401b900461ffff168452600d85018352818420825160a081018452858152938401859052918301849052606083018490526080830193909352929350909190612e8387613676565b6001600160a01b03166040820152600283015463ffffffff1615612eba5760405163282404cd60e01b815260040160405180910390fd5b612ec5838789612c7c565b602083018190526001600160a01b03909116808352600285015460ff600160201b90910416606084018190526040840151612f0e93869388939291612f098e613149565b613696565b63ffffffff1660808201819052600003612f3b57604051638a874ec160e01b815260040160405180910390fd5b608081015160028401805463ffffffff191663ffffffff909216918217905560408083015183516020850151925163f2c6c6fb60e01b81526001600160a01b03918216600482015260248101939093526044830193909352600092169063f2c6c6fb906064016020604051808303816000875af1158015612fc0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612fe491906150f9565b90507f7a40f4421a71ae931ce048b2171197c34a78510813f1d3f4202935dd9f105b1a8683600001518460200151856080015185876060015160405161306c969594939291906001600160401b039690961686526001600160a01b03949094166020860152604085019290925263ffffffff166060840152608083015260a082015260c00190565b60405180910390a15050505050505050565b604051631430d62960e21b81526001600160a01b038216906350c358a4906130aa903390600401614722565b602060405180830381865afa1580156130c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130eb9190615562565b610860573360405163451cea1760e11b81526004016108b79190614722565b6000610606825490565b600061060682600884600001516001600160a01b031663016dff5d613a91565b600060ff8316600883901b61ff001617610603565b600061060682600084600001516001600160a01b0316628e9691613a91565b60006106038383613b9d565b600061060682613bc7565b600080808061318e8686613bd2565b9097909650945050505050565b60008181526001830160205260408120541515610603565b60006106038383613bfd565b6000670de0b6b3a76400008210156131ed57604051637046c4a960e01b8152600481018390526024016108b7565b6000613209613204670de0b6b3a7640000856152a5565b613cf0565b9050600061321f82670de0b6b3a764000061528e565b905083821c670de0b6b3a764000081900361323c57509392505050565b6706f05b59d3b200005b801561329657670de0b6b3a764000061325f838061528e565b61326991906152a5565b9150671bc16d674ec80000821061328e576132848184615085565b9250600182901c91505b60011c613246565b5090949350505050565b60609290921b6001600160601b03191660209190911b6bffffffffffffffff00000000161760189190911b63ff000000161790565b6040805160208082526104208201909252606091600091908082016104008036833701905050905060005b60208110156133465761331481600861528e565b8460001c901c82828151811061332c5761332c6150e3565b60ff90921660209283029190910190910152600101613300565b5092915050565b67ffffffffffffffff60401b604083901b166001600160401b0384161760808261337857600061337b565b60015b60ff16901b179392505050565b805160009060208111156133b957604051633d71388b60e21b815260048101829052602060248201526044016108b7565b6000805b828110156133ff576133d081600861528e565b8582815181106133e2576133e26150e3565b602090810291909101015160ff16901b91909117906001016133bd565b509392505050565b60006106038383613dd3565b600061341d6110f2565b54600160401b900460ff16919050565b6040516331a9108f60e11b8152600481018490526001600160a01b038084169190861690636352211e90602401602060405180830381865afa158015613477573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061349b919061503f565b6001600160a01b0316146134c657838360405163547208b960e11b81526004016108b79291906151da565b6134cf81613114565b6001600160a01b0316631789b7b1856040518263ffffffff1660e01b81526004016134fa9190614722565b602060405180830381865afa158015613517573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061353b91906151f3565b60ff16600003613560578360405163adc7fced60e01b81526004016108b79190614722565b80600001516001600160a01b03166318d928316040518163ffffffff1660e01b8152600401602060405180830381865afa1580156135a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135c69190615562565b156135e457604051635e1633d360e11b815260040160405180910390fd5b50505050565b613618816001600160401b03166135ff612aca565b60ff851660009081526020919091526040902090613407565b613635576040516313e5d5f160e11b815260040160405180910390fd5b6040805160ff841681526001600160401b03831660208201527f3e9a7af2aeebce9d24ef707bdb61adf2708293e374a19f8e9c31f905c68b43c19101610974565b600061060682600584600001516001600160a01b03166389dd9f13613a91565b600786015460009060ff1686106136c3576040516315f7ec4560e21b8152600481018790526024016108b7565b8660080186815481106136d8576136d86150e3565b60009182526020822060088204015460079091166004026101000a900463ffffffff169150819003610c3057604051631a95890960e31b81526000906001600160a01b0384169063d4ac48489061373590889088906004016151da565b60a060405180830381865afa158015613752573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613776919061557f565b602081015181518b549293506137a09263ffffffff9283169290911690610100900460ff16613e22565b158015906137f157506137b1612aca565b8954600191909101906000906137db906001600160a01b038916908890610100900460ff166132a0565b815260208101919091526040016000205460ff16155b801561381e5750885461380d90610100900460ff166005615616565b60ff16816000015163ffffffff1610155b15613897578854610100900460ff166001036138405762138884915050610c30565b8854610100900460ff1660020361385d576222f238915050610c30565b8854610100900460ff1660030361387a57623234dc915050610c30565b8854610100900460ff166004036138975762417780915050610c30565b6040805160058b018054606060208202840181018552938301818152600094849284918401828280156138e957602002820191906000526020600020905b8154815260200190600101908083116138d5575b5050505050815260200160018201805480602002602001604051908101604052809291908181526020016000905b828210156139af5760008481526020908190208301805460408051828502810185019091528181529283018282801561399b57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff168152602001906004019060208260030104928301926001038202915080841161395e5790505b505050505081526020019060010190613917565b50505050815250509050866001600160a01b0316636f383c0f6139ee83600001518b815181106139e1576139e16150e3565b6020026020010151613e78565b83602001518b81518110613a0457613a046150e3565b60200260200101518d60000160019054906101000a900460ff168a8a6040518663ffffffff1660e01b8152600401613a40959493929190615632565b6020604051808303816000875af1158015613a5f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a839190615681565b9a9950505050505050505050565b600080856020015185600e811115613aab57613aab61569e565b600f8110613abb57613abb6150e3565b602002015190506001600160a01b03811615613ad8579050610615565b83836040518163ffffffff1660e01b8152600401602060405180830381865afa158015613b09573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b2d919061503f565b866020015186600e811115613b4457613b4461569e565b600f8110613b5457613b546150e3565b6001600160a01b039092166020928302919091015286015185600e811115613b7e57613b7e61569e565b600f8110613b8e57613b8e6150e3565b60200201519695505050505050565b6000826000018281548110613bb457613bb46150e3565b9060005260206000200154905092915050565b60006106068261310a565b60008080613be08585613168565b600081815260029690960160205260409095205494959350505050565b60008181526001830160205260408120548015613ce6576000613c21600183615072565b8554909150600090613c3590600190615072565b9050808214613c9a576000866000018281548110613c5557613c556150e3565b9060005260206000200154905080876000018481548110613c7857613c786150e3565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080613cab57613cab6156b4565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610606565b6000915050610606565b6000600160801b8210613d1057608091821c91613d0d9082615085565b90505b600160401b8210613d2e57604091821c91613d2b9082615085565b90505b600160201b8210613d4c57602091821c91613d499082615085565b90505b620100008210613d6957601091821c91613d669082615085565b90505b6101008210613d8557600891821c91613d829082615085565b90505b60108210613da057600491821c91613d9d9082615085565b90505b60048210613dbb57600291821c91613db89082615085565b90505b60028210613dce57610606600182615085565b919050565b6000818152600183016020526040812054613e1a57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610606565b506000610606565b6000806005613e3386866001613f6c565b613e3d91906152a5565b613e48906001615085565b9050828111613e585760006107bb565b613e628382615072565b613e6d90600a615085565b6107bb90600261539d565b60606000613e85836132d5565b90506000805b8251811015613ece57828181518110613ea657613ea66150e3565b602002602001015160ff1660000315613ece5781613ec381615275565b925050600101613e8b565b50806001600160401b03811115613ee757613ee76142d1565b604051908082528060200260200182016040528015613f10578160200160208202803683370190505b50925060005b81811015613f6457828181518110613f3057613f306150e3565b6020026020010151848281518110613f4a57613f4a6150e3565b60ff90921660209283029190910190910152600101613f16565b505050919050565b600080613f798585613fa2565b9050828015613f9257506002613f90826001615085565b115b15610615576107bb600282615072565b805b606381101561060657613fb8836001615085565b613fc182613fd5565b63ffffffff16101561060657600101613fa4565b600063ffffffff82161580613ff15750606363ffffffff831610155b15613ffe57506000919050565b670de0b6b3a76400006140386140158460636156ca565b6140209060026156e7565b6121d79063ffffffff16670de0b6b3a764000061528e565b61404a90675cfb2e807b1e0000615072565b61405d620186a063ffffffff861661528e565b614067919061528e565b61060691906152a5565b6040518060e00160405280600060ff168152602001600060ff168152602001606081526020016000801916815260200160608152602001606081526020016140cc604051806040016040528060608152602001606081525090565b905290565b604051806040016040528060006001600160a01b031681526020016140cc61423f565b508054600082556007016008900490600052602060002090810190610860919061425e565b5080546000825590600052602060002090810190610860919061425e565b50805460008255906000526020600020908101906108609190614273565b828054828255906000526020600020906007016008900481019282156141f45791602002820160005b838211156141c257835183826101000a81548163ffffffff021916908363ffffffff160217905550926020019260040160208160030104928301926001030261417e565b80156141f25782816101000a81549063ffffffff02191690556004016020816003010492830192600103026141c2565b505b5061420092915061425e565b5090565b8280548282559060005260206000209081019282156141f4579160200282015b828111156141f4578251825591602001919060010190614224565b604051806101e00160405280600f906020820280368337509192915050565b5b80821115614200576000815560010161425f565b8082111561420057600061428782826140f4565b50600101614273565b6001600160a01b038116811461086057600080fd5b600080604083850312156142b857600080fd5b82356142c381614290565b946020939093013593505050565b634e487b7160e01b600052604160045260246000fd5b60405161012081016001600160401b038111828210171561430a5761430a6142d1565b60405290565b604051601f8201601f191681016001600160401b0381118282101715614338576143386142d1565b604052919050565b600082601f83011261435157600080fd5b81356001600160401b0381111561436a5761436a6142d1565b61437d601f8201601f1916602001614310565b81815284602083860101111561439257600080fd5b816020850160208301376000918101602001919091529392505050565b600080600080608085870312156143c557600080fd5b84356143d081614290565b935060208501356143e081614290565b92506040850135915060608501356001600160401b0381111561440257600080fd5b61440e87828801614340565b91505092959194509250565b60006020828403121561442c57600080fd5b813561443781614290565b9392505050565b6001600160401b038116811461086057600080fd5b801515811461086057600080fd5b8035613dce81614453565b6000806040838503121561447f57600080fd5b823561448a8161443e565b9150602083013561449a81614453565b809150509250929050565b803561ffff81168114613dce57600080fd5b60ff8116811461086057600080fd5b8035613dce816144b7565b600080600080608085870312156144e757600080fd5b6144f0856144a5565b93506020850135614500816144b7565b9250604085013561451081614290565b9396929550929360600135925050565b6000806040838503121561453357600080fd5b823561453e8161443e565b915060208301356001600160401b0381111561455957600080fd5b61456585828601614340565b9150509250929050565b60006020828403121561458157600080fd5b81356144378161443e565b63ffffffff8116811461086057600080fd5b600080600080608085870312156145b457600080fd5b84356145bf8161458c565b935060208501356145cf81614290565b92506040850135915060608501356145e6816144b7565b939692955090935050565b60008060006060848603121561460657600080fd5b833561461181614290565b925060208401359150604084013561462881614290565b809150509250925092565b60006020828403121561464557600080fd5b5035919050565b600080600080600060a0868803121561466457600080fd5b853561466f81614290565b9450602086013561467f816144b7565b9350604086013561468f81614290565b94979396509394606081013594506080013592915050565b600080604083850312156146ba57600080fd5b50508035926020909101359150565b6000815180845260005b818110156146ef576020818501810151868301820152016146d3565b506000602082860101526020601f19601f83011685010191505092915050565b60208152600061060360208301846146c9565b6001600160a01b0391909116815260200190565b60008151808452602080850194506020840160005b838110156147705781516001600160a01b03168752958201959082019060010161474b565b509495945050505050565b60008151808452602080850194506020840160005b8381101561477057815187529582019590820190600101614790565b60008151808452602080850194506020840160005b8381101561477057815163ffffffff16875295820195908201906001016147c1565b61ffff8c1681528a151560208201526001600160a01b038a1660408201526060810189905263ffffffff88166080820152600061016060ff891660a08401528060c084015261483481840189614736565b905082810360e0840152614848818861477b565b905082810361010084015261485d818761477b565b60ff8616610120850152905082810361014084015261487c81856147ac565b9e9d5050505050505050505050505050565b6000806000606084860312156148a357600080fd5b6148ac846144a5565b925060208401356148bc816144b7565b91506040840135614628816144b7565b600080600080600080600060e0888a0312156148e757600080fd5b87356148f281614290565b965060208801359550604088013594506060880135614910816144b7565b93506080880135614920816144b7565b925060a0880135614930816144b7565b915060c0880135614940816144b7565b8091505092959891949750929550565b60008060006060848603121561496557600080fd5b83356149708161443e565b9250602084013561498081614290565b929592945050506040919091013590565b600080600080608085870312156149a757600080fd5b84356149b281614290565b966020860135965060408601359560600135945092505050565b6000602082840312156149de57600080fd5b610603826144a5565b60008282518085526020808601955060208260051b8401016020860160005b84811015614a3457601f19868403018952614a228383516147ac565b98840198925090830190600101614a06565b5090979650505050505050565b6000815160408452614a56604085018261477b565b9050602083015184820360208601526107bb82826149e7565b6020815260ff825116602082015260006020830151614a93604084018260ff169052565b50604083015160e06060840152614aae6101008401826147ac565b9050606084015160808401526080840151601f19808584030160a0860152614ad6838361477b565b925060a08601519150808584030160c0860152614af3838361477b565b925060c08601519150808584030160e0860152506107bb8282614a41565b60008151808452602080850194506020840160005b8381101561477057815160ff1687529582019590820190600101614b26565b6020815260006106036020830184614b11565b60006001600160401b03821115614b7157614b716142d1565b5060051b60200190565b600082601f830112614b8c57600080fd5b81356020614ba1614b9c83614b58565b614310565b828152600592831b8501820192828201919087851115614bc057600080fd5b8387015b85811015614a345780356001600160401b03811115614be35760008081fd5b8801603f81018a13614bf55760008081fd5b858101356040614c07614b9c83614b58565b82815291851b8301810191888101908d841115614c245760008081fd5b938201935b83851015614c4e5784359250614c3e836144b7565b8282529389019390890190614c29565b885250505093850193508401614bc4565b600082601f830112614c7057600080fd5b81356020614c80614b9c83614b58565b8083825260208201915060208460051b870101935086841115614ca257600080fd5b602086015b84811015614cc7578035614cba8161458c565b8352918301918301614ca7565b509695505050505050565b600082601f830112614ce357600080fd5b81356020614cf3614b9c83614b58565b82815260059290921b84018101918181019086841115614d1257600080fd5b8286015b84811015614cc75780356001600160401b03811115614d355760008081fd5b614d438986838b0101614c5f565b845250918301918301614d16565b600082601f830112614d6257600080fd5b81356020614d72614b9c83614b58565b8083825260208201915060208460051b870101935086841115614d9457600080fd5b602086015b84811015614cc75780358352918301918301614d99565b600082601f830112614dc157600080fd5b81356020614dd1614b9c83614b58565b8083825260208201915060208460051b870101935086841115614df357600080fd5b602086015b84811015614cc7578035614e0b8161443e565b8352918301918301614df8565b600082601f830112614e2957600080fd5b81356020614e39614b9c83614b58565b8083825260208201915060208460051b870101935086841115614e5b57600080fd5b602086015b84811015614cc7578035614e7381614453565b8352918301918301614e60565b60008060008060008060c08789031215614e9957600080fd5b614ea2876144a5565b95506020870135614eb2816144b7565b945060408701356001600160401b0380821115614ece57600080fd5b90880190610120828b031215614ee357600080fd5b614eeb6142e7565b823582811115614efa57600080fd5b614f068c828601614b7b565b825250602083013582811115614f1b57600080fd5b614f278c828601614cd2565b602083015250604083013582811115614f3f57600080fd5b614f4b8c828601614c5f565b604083015250614f5d606084016144c6565b6060820152614f6e608084016144c6565b608082015260a083013582811115614f8557600080fd5b614f918c828601614d51565b60a08301525060c083013582811115614fa957600080fd5b614fb58c828601614db0565b60c08301525060e083013582811115614fcd57600080fd5b614fd98c828601614db0565b60e0830152506101008084013583811115614ff357600080fd5b614fff8d828701614e18565b828401525050809650505050615017606088016144c6565b9250615025608088016144c6565b915061503360a08801614461565b90509295509295509295565b60006020828403121561505157600080fd5b815161443781614290565b634e487b7160e01b600052601160045260246000fd5b818103818111156106065761060661505c565b808201808211156106065761060661505c565b6000602082840312156150aa57600080fd5b81516144378161443e565b6000806000606084860312156150ca57600080fd5b8351925060208401519150604084015190509250925092565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561510b57600080fd5b5051919050565b6001600160a01b039390931683526020830191909152604082015260600190565b8781528660208201526001600160401b0386166040820152600060018060a01b03808716606084015260e0608084015261517060e08401876146c9565b941660a08301525063ffffffff9190911660c09091015295945050505050565b600080600080608085870312156151a657600080fd5b84516151b181614453565b6020860151604087015191955093506151c98161458c565b60608601519092506145e681614453565b6001600160a01b03929092168252602082015260400190565b60006020828403121561520557600080fd5b8151614437816144b7565b634e487b7160e01b600052601260045260246000fd5b600060ff83168061523957615239615210565b8060ff84160491505092915050565b60ff81811683821601908111156106065761060661505c565b60008261527057615270615210565b500690565b6000600182016152875761528761505c565b5060010190565b80820281158282048414176106065761060661505c565b6000826152b4576152b4615210565b500490565b600181815b808511156152f45781600019048211156152da576152da61505c565b808516156152e757918102915b93841c93908002906152be565b509250929050565b60008261530b57506001610606565b8161531857506000610606565b816001811461532e576002811461533857615354565b6001915050610606565b60ff8411156153495761534961505c565b50506001821b610606565b5060208310610133831016604e8410600b8410161715615377575081810a610606565b61538183836152b9565b80600019048211156153955761539561505c565b029392505050565b600061060383836152fc565b60008282518085526020808601955060208260051b8401016020860160005b84811015614a3457601f198684030189526153e4838351614b11565b988401989250908301906001016153c8565b60008151808452602080850194506020840160005b838110156147705781516001600160401b03168752958201959082019060010161540b565b60008151808452602080850194506020840160005b83811015614770578151151587529582019590820190600101615445565b61ffff83168152604060208201526000825161012080604085015261548c6101608501836153a9565b91506020850151603f19808685030160608701526154aa84836149e7565b935060408701519150808685030160808701526154c784836147ac565b9350606087015191506154df60a087018360ff169052565b608087015160ff1660c087015260a0870151868503820160e08801529150615507848361477b565b935060c0870151915061010081878603018188015261552685846153f6565b945060e0880151925081878603018488015261554285846153f6565b945080880151935050808685030161014087015250506114ce8282615430565b60006020828403121561557457600080fd5b815161443781614453565b600060a0828403121561559157600080fd5b60405160a081018181106001600160401b03821117156155b3576155b36142d1565b60405282516155c18161458c565b815260208301516155d18161458c565b602082015260408301516155e48161458c565b604082015260608301516155f78161458c565b6060820152608083015161560a8161458c565b60808201529392505050565b60ff81811683821602908116908181146133465761334661505c565b60a08152600061564560a0830188614b11565b828103602084015261565781886147ac565b60ff96909616604084015250506001600160a01b0392909216606083015260809091015292915050565b60006020828403121561569357600080fd5b81516144378161458c565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052603160045260246000fd5b63ffffffff8281168282160390808211156133465761334661505c565b63ffffffff8181168382160190808211156133465761334661505c56fe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda26469706673582212206add5e1b9122d0164ff9d547463cf353763f3997eab433f184e9ec09d61cf30164736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061021e5760003560e01c80639a641e0211610126578063b429afeb116100b3578063b429afeb146104eb578063b5a44d04146104fe578063b6d2fe6c14610511578063b701c1aa1461053f578063be2e0ad81461055f578063d06969c71461057f578063dee1f0e414610592578063e76bd825146105a5578063f77c4791146105b8578063fee27cbe146105c0578063ffa1ad74146105d357600080fd5b80639a641e021461042a5780639d0bcca01461043d5780639f3cfa7a14610452578063a433af6f1461045a578063a46374b31461046d578063a4efd30914610497578063a7540ee5146104aa578063ac257b3a146104bd578063ad8c5755146104d0578063b2192fdd146104e357600080fd5b80634fac6ccd116101af5780634fac6ccd1461031b578063572b6c051461032e57806357bd05b0146103415780635a67eb48146103545780636a8a5e8c146103675780636bb4b4591461037a5780637442adbc146103a55780637be89369146103b85780637c00116c146103de5780637cc96380146103f1578063936725ec146103f957600080fd5b80630e30c13e14610223578063150b7a021461024d57806319ab453c1461027957806327dd892f1461028e5780632fcd5deb146102a1578063325a19f1146102c457806338430cce146102da5780634593144c146102ed57806348b371bf146102f55780634d52532c14610308575b600080fd5b6102366102313660046142a5565b6105f7565b60405160ff90911681526020015b60405180910390f35b61026061025b3660046143af565b61060c565b6040516001600160e01b03199091168152602001610244565b61028c61028736600461441a565b61061d565b005b61028c61029c36600461446c565b610717565b6102b46102af3660046144d1565b61073d565b6040519015158152602001610244565b6102cc6107c4565b604051908152602001610244565b61028c6102e8366004614520565b6107fd565b6102cc61081f565b61028c61030336600461456f565b61084f565b6102cc61031636600461456f565b610863565b61028c61032936600461441a565b61086e565b6102b461033c36600461441a565b610980565b61028c61034f36600461459e565b6109f5565b61028c6103623660046142a5565b610a98565b61028c6103753660046145f1565b610aaa565b61038d6103883660046145f1565b610b40565b6040516001600160401b039091168152602001610244565b6102cc6103b3366004614633565b610c02565b6103cb6103c636600461464c565b610c0d565b60405161ffff9091168152602001610244565b61038d6103ec3660046146a7565b610c3b565b6102cc610c47565b61041d604051806040016040528060058152602001640312e302e360dc1b81525081565b604051610244919061470f565b61038d6104383660046142a5565b610c65565b610445610c71565b6040516102449190614722565b61038d610ca1565b61028c6104683660046142a5565b610cab565b61048061047b36600461456f565b610d30565b6040516102449b9a999897969594939291906147e3565b61028c6104a536600461488e565b610d70565b6102cc6104b836600461441a565b610d88565b6102cc6104cb3660046148cc565b610d93565b6102b46104de3660046142a5565b610dbc565b610236610dd0565b6102b46104f936600461441a565b610dda565b61028c61050c366004614950565b610dff565b61052461051f366004614991565b610e89565b60408051938452602084019290925290820152606001610244565b61055261054d3660046149cc565b610f45565b6040516102449190614a6f565b61057261056d3660046142a5565b610f56565b6040516102449190614b45565b61038d61058d3660046145f1565b610f62565b6102b46105a036600461441a565b610fc9565b61028c6105b3366004614e80565b61104e565b610445611064565b61028c6105ce36600461456f565b611094565b61041d60405180604001604052806005815260200164322e312e3160d81b81525081565b600061060383836110b5565b90505b92915050565b630a85bd0160e11b5b949350505050565b60006106276110f2565b805490915060ff600160401b82041615906001600160401b031660008115801561064e5750825b90506000826001600160401b0316600114801561066a5750303b155b905081158015610678575080155b156106965760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff1916600117855583156106c057845460ff60401b1916600160401b1785555b6106c986611116565b831561070f57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b610739610722611127565b61072a611064565b61073261113f565b8585611161565b5050565b60006107bb61074a6111fb565b610752611064565b6001600160a01b0316628e96916040518163ffffffff1660e01b8152600401602060405180830381865afa15801561078e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107b2919061503f565b8787878761121f565b95945050505050565b60006107f86107f460017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b615072565b5490565b905090565b610739610808611127565b610810611064565b61081861113f565b85856114d8565b60006107f86107f460017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1615072565b61086061085a611064565b82611716565b50565b60006106068261176e565b3330146108c05760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b60006108de6107f46001600080516020615705833981519152615072565b6108e9906001615085565b905061090b816109086001600080516020615705833981519152615072565b55565b61093a8261090860017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4615072565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c891015b60405180910390a15050565b60006001600160a01b03821673d8253782c45a12053594b9deb72d8e8ab2fca54c14806109c957506001600160a01b0382167352ceba41da235af367bfc0b0ccd3314cb901bb5f145b8061060657506001600160a01b03821673102f1f556cd9c3d5f820e6920a8931657c5da21b1492915050565b73__$ab645b4c934bd909f08d0d9ba5d19f570d$__637c1ecb8e610a17611064565b6040516001600160e01b031960e084901b1681526001600160a01b03918216600482015263ffffffff8816602482015290861660448201526064810185905260ff8416608482015260a40160006040518083038186803b158015610a7a57600080fd5b505af4158015610a8e573d6000803e3d6000fd5b5050505050505050565b610739610aa3611064565b838361179a565b73__$ab645b4c934bd909f08d0d9ba5d19f570d$__6303395eef610acc611064565b6040516001600160e01b031960e084901b1681526001600160a01b03918216600482015281871660248201526044810186905290841660648201526084015b60006040518083038186803b158015610b2357600080fd5b505af4158015610b37573d6000803e3d6000fd5b50505050505050565b600073__$ab645b4c934bd909f08d0d9ba5d19f570d$__63987707f9610b64611127565b610b6c611064565b610b7461113f565b6040516001600160e01b031960e086901b16815292151560048401526001600160a01b03918216602484015281166044830152808816606483015260848201879052851660a482015260c4015b602060405180830381865af4158015610bde573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106159190615098565b600061060682611839565b600080610c198761185a565b9050610c30610c266111fb565b8288888888611872565b979650505050505050565b60006106038383611b9f565b60006107f86107f46001600080516020615705833981519152615072565b60006106038383611bc2565b60006107f86107f460017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4615072565b60006107f8611c05565b73__$ab645b4c934bd909f08d0d9ba5d19f570d$__63dc01b901610ccd611064565b6040516001600160e01b031960e084901b1681526001600160a01b0391821660048201529085166024820152604481018490526064015b60006040518083038186803b158015610d1c57600080fd5b505af415801561070f573d6000803e3d6000fd5b600080600080600080606080606060006060610d4b8c611c21565b9a509a509a509a509a509a509a509a509a509a509a5091939597999b90929496989a50565b610d83610d7b611064565b848484611eca565b505050565b6000610606826120b8565b6000610db08888888860ff168860ff168860ff168860ff166120e4565b98975050505050505050565b6000610603610dc9611064565b8484612283565b60006107f8612396565b6000610de4611064565b6001600160a01b0316826001600160a01b0316149050919050565b73__$ab645b4c934bd909f08d0d9ba5d19f570d$__63efa20d9b610e21611127565b610e29611064565b610e3161113f565b6040516001600160e01b031960e086901b16815292151560048401526001600160a01b039182166024840152811660448301526001600160401b03871660648301528516608482015260a4810184905260c401610b0b565b600080600073__$ab645b4c934bd909f08d0d9ba5d19f570d$__633e457e4f610eb0611064565b6040516001600160e01b031960e084901b1681526001600160a01b039182166004820152908a16602482015260448101899052606481018890526084810187905260a401606060405180830381865af4158015610f11573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f3591906150b5565b9250925092509450945094915050565b610f4d614071565b610606826123ac565b60606106038383612662565b600073__$ab645b4c934bd909f08d0d9ba5d19f570d$__63c77d56a2610f86611064565b6040516001600160e01b031960e084901b1681526001600160a01b0391821660048201528186166024820152908716604482015260648101869052608401610bc1565b6000816001600160a01b0316610fdd611064565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa15801561101a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061103e919061503f565b6001600160a01b03161492915050565b61070f611059611064565b87878787878761269b565b60006107f86107f460017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618615072565b61086061109f611127565b6110a7611064565b6110af61113f565b84612aa2565b60006110bf612aca565b60030160006110d76001600160a01b03861685612ad4565b815260208101919091526040016000205460ff169392505050565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b61111e612b24565b61086081612b4b565b600061113233610980565b806107f857505032331490565b600061114a33610980565b1561115c575060131936013560601c90565b503390565b61116a85612c5e565b60405163139ed9b560e21b81526001600160a01b0380861660048301526001600160401b038416602483015282151560448301528416606482015273__$1523437c96ee4244b41dcb81ce9bb69efd$__90634e7b66d49060840160006040518083038186803b1580156111dc57600080fd5b505af41580156111f0573d6000803e3d6000fd5b505050505050505050565b7fae5971282b317bbed599861775fe0712755bb3b2f655bfe8fb14280d8429f60090565b61ffff84166000908152600d870160205260408120600281015460ff8082169160081c81169087168211806112565750808760ff16115b1561126757600093505050506114ce565b50506000816003018054806020026020016040519081016040528092919081815260200182805480156112b957602002820191906000526020600020905b8154815260200190600101908083116112a5575b5050505050905060008260040180548060200260200160405190810160405280929190818152602001828054801561131057602002820191906000526020600020905b8154815260200190600101908083116112fc575b505085519394506000925050505b818110156114c457600084828151811061133a5761133a6150e3565b602002602001015190506000801b810361135457506114bc565b600080600061138b87868151811061136e5761136e6150e3565b602002602001015190604082901c90608083901c60ff1660011490565b92509250925060008161140c578f6001600160a01b0316630a82c861866040518263ffffffff1660e01b81526004016113c691815260200190565b602060405180830381865afa1580156113e3573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061140791906150f9565b61147d565b8f6001600160a01b0316631c2aafe78e8e886040518463ffffffff1660e01b815260040161143c93929190615112565b602060405180830381865afa158015611459573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061147d91906150f9565b9050836001600160401b031681108061149e5750826001600160401b031681115b156114b65760009a50505050505050505050506114ce565b50505050505b60010161131e565b5060019450505050505b9695505050505050565b60006114e2612aca565b905060006114ef8661185a565b6040805160a0810182526000808252602080830182905282840182905260608301829052608083018290526001600160401b0389168252600e870181528382208054600160401b900461ffff168352600d8801909152929020929350916115558a612c5e565b611560828986612c7c565b50508160020160009054906101000a900463ffffffff16836040019063ffffffff16908163ffffffff168152505073__$1523437c96ee4244b41dcb81ce9bb69efd$__6311942d1783838a8c8b8f8a604001516040518863ffffffff1660e01b81526004016115d59796959493929190615133565b608060405180830381865af41580156115f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116169190615190565b1515602087015263ffffffff1660608601526080850152158015845261164857815460ff60501b1916600160501b1782555b60808301511561167957608083015160028301805460ff909216600160201b0264ff00000000199092169190911790555b826040015163ffffffff16836060015163ffffffff16146116b557606083015160028301805463ffffffff191663ffffffff9092169190911790555b8260200151156116d55780546116d5908390610100900460ff1689612da4565b82511580156116ec5750600282015463ffffffff16155b80156116fa57508260200151155b1561170a5761170a848989612e0f565b50505050505050505050565b61171f8261307e565b604051632586866b60e11b81526001600160a01b03831660048201526001600160401b038216602482015273__$1523437c96ee4244b41dcb81ce9bb69efd$__90634b0d0cd690604401610d04565b6000611778612aca565b6001600160401b039092166000908152600f9290920160205250604090205490565b6117a38361307e565b60058110156117c857604051634bebee7f60e01b8152600481018290526024016108b7565b806117d1612aca565b600a016000846001600160a01b03166001600160a01b03168152602001908152602001600020819055507f996f9d801b1a05cd3c7b555e5b6f61db994ea8ef57125b5b5d3b07b9dad4e2cf828260405161182c9291906151da565b60405180910390a1505050565b6000610606611846612aca565b60008481526020919091526040902061310a565b6118626140d1565b6001600160a01b03909116815290565b60008460ff166000036118985760405163a8473eab60e01b815260040160405180910390fd5b6000806118a488613114565b604051631ebd249360e01b81529091506001600160a01b03821690631ebd2493906118d590899089906004016151da565b602060405180830381865afa1580156118f2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061191691906151f3565b915060008960050160006119ad60058b6119309190615226565b61193b906001615248565b604051631789b7b160e01b81526001600160a01b03871690631789b7b190611967908e90600401614722565b602060405180830381865afa158015611984573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119a891906151f3565b613134565b8152602081019190915260400160009081205461ffff169150819003611a0d578960050160006119f560058b6119e39190615226565b6119ee906001615248565b6000613134565b815260208101919091526040016000205461ffff1690505b8061ffff16600003611a4257896005016000611a2a600080613134565b815260208101919091526040016000205461ffff1690505b61ffff811615611ac8576001600160a01b03871660a087901b67ffffffffffffffff60a01b161760f082901b6001600160f01b03191617600090815260028b01602052604090205460ff16158015611ab9575061ffff81166000908152600d8b01602052604090205460ff84811661010090920416145b15611ac85792506114ce915050565b505060ff81166000908152600889016020526040812090611ae88261310a565b905080600003611b0f576040516283533360e01b815260ff841660048201526024016108b7565b6000611b1a8a613149565b9050600080611b298489615261565b905060005b84811015611b8557611b408683613168565b9250611b508e85858f8f8f61121f565b15611b6457829750505050505050506114ce565b81611b6e81615275565b925050848210611b7d57600091505b600101611b2e565b5060405163b940612960e01b815260040160405180910390fd5b600061060383611bad612aca565b60008581526020919091526040902090613168565b6000611bcc612aca565b6004016000611be46001600160a01b03861685612ad4565b81526020810191909152604001600020546001600160401b03169392505050565b6000611c0f612aca565b600c01546001600160401b0316919050565b6000806000806000806060806060600060606000611c3d612aca565b600e0160008e6001600160401b03166001600160401b0316815260200190815260200160002090508060000160089054906101000a900461ffff169b5080600001600a9054906101000a900460ff169a5080600001600b9054906101000a90046001600160a01b03169950806001015498508060020160009054906101000a900463ffffffff1697508060020160049054906101000a900460ff16965080600601805480602002602001604051908101604052809291908181526020018280548015611d2857602002820191906000526020600020905b815481526020019060010190808311611d14575b505050600784015460088501805460408051602080840282018101909252828152969a5060ff90931698509093509150830182828015611db357602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff1681526020019060040190602082600301049283019260010382029150808411611d765790505b505050505091506000611dc882600301613174565b9050806001600160401b03811115611de257611de26142d1565b604051908082528060200260200182016040528015611e0b578160200160208202803683370190505b509650806001600160401b03811115611e2657611e266142d1565b604051908082528060200260200182016040528015611e4f578160200160208202803683370190505b50955060005b81811015611eb857611e6a600384018261317f565b898381518110611e7c57611e7c6150e3565b60200260200101898481518110611e9557611e956150e3565b60209081029190910101919091526001600160a01b039091169052600101611e55565b50505091939597999b90929496989a50565b611ed38461307e565b6000611edd612aca565b61ffff85166000908152600d820160205260408120805461ffff198116825592935061010090920460ff169190611f1760018301826140f4565b6002820160009055600382016000611f2f9190614119565b611f3d600483016000614119565b600582016000611f4d8282614119565b611f5b600183016000614137565b50505060ff821660009081526008840160205260409020611f81915061ffff871661319b565b15611fe15760ff811660009081526008830160205260409020611fa89061ffff87166131b3565b5060405161ffff861681527f6ee9dd6501e6ec9a0a3e60e773ac5fd9d48414213bc6a16588c88bda44f492899060200160405180910390a15b611ff26006830161ffff871661319b565b1561070f5760006120038585613134565b600081815260058501602052604090205490915061ffff87811691161461203d5760405163066a129160e31b815260040160405180910390fd5b60008181526005840160205260409020805461ffff191690556120676006840161ffff88166131b3565b506040805161ffff8816815260ff878116602083015286168183015290517f9c5c01904f703f1392e848da84f3f506975241d8d8d0f67550729c5f5080c94e9181900360600190a150505050505050565b60006120c2612aca565b6001600160a01b039092166000908152600a9290920160205250604090205490565b6000868410806120f357508282105b1561210057506000610c30565b600061210a6111fb565b6001600160a01b038a166000908152600a9190910160205260409020549050801580159061213757508086105b15612146576000915050610c30565b606386111561216b57604051633505ce1b60e11b8152600481018790526024016108b7565b601385111561219057604051637d34ca9360e01b8152600481018690526024016108b7565b600061219d60058761528e565b9050675c33b801024d7e4a600060646121dc6121ba856063615072565b6121c5906001615085565b6121d790670de0b6b3a764000061528e565b6131bf565b6121e69084615072565b6121f091906152a5565b9050670de0b6b3a7640000811061221d57604051630dd7f01960e01b8152600481018290526024016108b7565b6000670de0b6b3a7640000612232838d61528e565b61223c91906152a5565b90508984101561227357612250848b615072565b61225b90600a615085565b61226690600261539d565b61227090826152a5565b90505b9c9b505050505050505050505050565b600080846001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156122c4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122e8919061503f565b6001600160a01b0316631ebd249385856040518363ffffffff1660e01b81526004016123159291906151da565b602060405180830381865afa158015612332573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061235691906151f3565b9050612360612aca565b60010160006123796001600160a01b03871686856132a0565b815260208101919091526040016000205460ff1695945050505050565b60006123a0612aca565b6009015460ff16919050565b6123b4614071565b6123bc612aca565b61ffff83166000908152600d919091016020908152604091829020825160e081018452815460ff808216835261010090910416818401526001820180548551818602810186018752818152929593949386019383018282801561246a57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff168152602001906004019060208260030104928301926001038202915080841161242d5790505b5050505050815260200160028201548152602001600382018054806020026020016040519081016040528092919081815260200182805480156124cc57602002820191906000526020600020905b8154815260200190600101908083116124b8575b505050505081526020016004820180548060200260200160405190810160405280929190818152602001828054801561252457602002820191906000526020600020905b815481526020019060010190808311612510575b50505050508152602001600582016040518060400160405290816000820180548060200260200160405190810160405280929190818152602001828054801561258c57602002820191906000526020600020905b815481526020019060010190808311612578575b5050505050815260200160018201805480602002602001604051908101604052809291908181526020016000905b828210156126525760008481526020908190208301805460408051828502810185019091528181529283018282801561263e57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff16815260200190600401906020826003010492830192600103820291508084116126015790505b5050505050815260200190600101906125ba565b5050509152505090525092915050565b606061060361266f612aca565b600b0160006126876001600160a01b03871686612ad4565b8152602001908152602001600020546132d5565b6126a48761307e565b60006126ae612aca565b60208601515186515191925090811415806126ce57508560400151518114155b156126ec5760405163c81acf3360e01b815260040160405180910390fd5b60005b8181101561275957865180518290811061270b5761270b6150e3565b6020026020010151518760200151828151811061272a5761272a6150e3565b602002602001015151146127515760405163f001029b60e01b815260040160405180910390fd5b6001016126ef565b5061ffff88166000908152600d830160205260409020600983015460ff90811690891611156127945760098301805460ff191660ff8a161790555b805460ff8981166101000261ffff1990921690841617178155604087015180516127c8916001840191602090910190614155565b506127db87606001518860800151613134565b600282015560a087015180516127fb916003840191602090910190614204565b506004810160005b8860c001515181101561288f57816128748a60c00151838151811061282a5761282a6150e3565b60200260200101518b60e001518481518110612848576128486150e3565b60200260200101518c61010001518581518110612867576128676150e3565b602002602001015161334d565b81546001818101845560009384526020909320015501612803565b5060005b83811015612930578851805160058501916128c591849081106128b8576128b86150e3565b6020026020010151613388565b8154600181018355600092835260209283902001558901518051600685019190839081106128f5576128f56150e3565b602090810291909101810151825460018101845560009384529282902081516129279491909101929190910190614155565b50600101612893565b508415612a325760006129438888613134565b600081815260058701602052604090205490915061ffff161561297f576040516366e6550f60e01b815261ffff8c1660048201526024016108b7565b60008181526005860160205260409020805461ffff191661ffff8d169081179091556129af90600687019061319b565b156129d35760405163ce9c78df60e01b815261ffff8c1660048201526024016108b7565b6129e46006860161ffff8d16613407565b506040805161ffff8d16815260ff8a8116602083015289168183015290517fc27376e37bec2cd9acd6957a46ca5cba20a88a21fd0eff1b02cf8536462304769181900360600190a150612a5c565b8154610100900460ff1660009081526008850160205260409020612a5a9061ffff8c16613407565b505b7fa8932b9bd78638467b3e5c0f0ffa9c72761db9f7f605b8df2f7a899770d064ae8a89604051612a8d929190615463565b60405180910390a15050505050505050505050565b612aab84612c5e565b6000612ab68461185a565b9050612ac3818484612e0f565b5050505050565b60006107f86111fb565b60006001600160401b03821115612b0157604051633995b34160e01b8152600481018390526024016108b7565b5067ffffffffffffffff60a01b60a09190911b166001600160a01b039091161790565b612b2c613413565b612b4957604051631afcd79f60e31b815260040160405180910390fd5b565b6001600160a01b038116612b935760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b60448201526064016108b7565b612bc28161090860017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618615072565b612bf14261090860017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b615072565b612c204361090860017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1615072565b7f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe236713426814243604051612c5393929190615112565b60405180910390a150565b8061086057604051636221cab960e01b815260040160405180910390fd5b82546001840154600160581b82046001600160a01b031691600160501b900460ff1615612cbc57604051636927c40b60e11b815260040160405180910390fd5b612cc88282868661342d565b612cd183613149565b6001600160a01b031663f16a306683836040518363ffffffff1660e01b8152600401612cfe9291906151da565b602060405180830381865afa158015612d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d3f9190615562565b612d6057818160405163033aace360e41b81526004016108b79291906151da565b84546001600160401b0316612d758383611bc2565b6001600160401b031614612d9c576040516337bcc65160e01b815260040160405180910390fd5b935093915050565b8254600160581b600160f81b03191683556000600184015560028301805464ffffffffff19169055612dd682826135ea565b6040516001600160401b03821681527f883aa0807cbcd64d238a9795b0433f37884de37e569aff04d512cb1df62c6e019060200161182c565b6000612e19612aca565b6001600160401b0383166000908152600e8201602090815260408083208054600160401b900461ffff168452600d85018352818420825160a081018452858152938401859052918301849052606083018490526080830193909352929350909190612e8387613676565b6001600160a01b03166040820152600283015463ffffffff1615612eba5760405163282404cd60e01b815260040160405180910390fd5b612ec5838789612c7c565b602083018190526001600160a01b03909116808352600285015460ff600160201b90910416606084018190526040840151612f0e93869388939291612f098e613149565b613696565b63ffffffff1660808201819052600003612f3b57604051638a874ec160e01b815260040160405180910390fd5b608081015160028401805463ffffffff191663ffffffff909216918217905560408083015183516020850151925163f2c6c6fb60e01b81526001600160a01b03918216600482015260248101939093526044830193909352600092169063f2c6c6fb906064016020604051808303816000875af1158015612fc0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612fe491906150f9565b90507f7a40f4421a71ae931ce048b2171197c34a78510813f1d3f4202935dd9f105b1a8683600001518460200151856080015185876060015160405161306c969594939291906001600160401b039690961686526001600160a01b03949094166020860152604085019290925263ffffffff166060840152608083015260a082015260c00190565b60405180910390a15050505050505050565b604051631430d62960e21b81526001600160a01b038216906350c358a4906130aa903390600401614722565b602060405180830381865afa1580156130c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130eb9190615562565b610860573360405163451cea1760e11b81526004016108b79190614722565b6000610606825490565b600061060682600884600001516001600160a01b031663016dff5d613a91565b600060ff8316600883901b61ff001617610603565b600061060682600084600001516001600160a01b0316628e9691613a91565b60006106038383613b9d565b600061060682613bc7565b600080808061318e8686613bd2565b9097909650945050505050565b60008181526001830160205260408120541515610603565b60006106038383613bfd565b6000670de0b6b3a76400008210156131ed57604051637046c4a960e01b8152600481018390526024016108b7565b6000613209613204670de0b6b3a7640000856152a5565b613cf0565b9050600061321f82670de0b6b3a764000061528e565b905083821c670de0b6b3a764000081900361323c57509392505050565b6706f05b59d3b200005b801561329657670de0b6b3a764000061325f838061528e565b61326991906152a5565b9150671bc16d674ec80000821061328e576132848184615085565b9250600182901c91505b60011c613246565b5090949350505050565b60609290921b6001600160601b03191660209190911b6bffffffffffffffff00000000161760189190911b63ff000000161790565b6040805160208082526104208201909252606091600091908082016104008036833701905050905060005b60208110156133465761331481600861528e565b8460001c901c82828151811061332c5761332c6150e3565b60ff90921660209283029190910190910152600101613300565b5092915050565b67ffffffffffffffff60401b604083901b166001600160401b0384161760808261337857600061337b565b60015b60ff16901b179392505050565b805160009060208111156133b957604051633d71388b60e21b815260048101829052602060248201526044016108b7565b6000805b828110156133ff576133d081600861528e565b8582815181106133e2576133e26150e3565b602090810291909101015160ff16901b91909117906001016133bd565b509392505050565b60006106038383613dd3565b600061341d6110f2565b54600160401b900460ff16919050565b6040516331a9108f60e11b8152600481018490526001600160a01b038084169190861690636352211e90602401602060405180830381865afa158015613477573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061349b919061503f565b6001600160a01b0316146134c657838360405163547208b960e11b81526004016108b79291906151da565b6134cf81613114565b6001600160a01b0316631789b7b1856040518263ffffffff1660e01b81526004016134fa9190614722565b602060405180830381865afa158015613517573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061353b91906151f3565b60ff16600003613560578360405163adc7fced60e01b81526004016108b79190614722565b80600001516001600160a01b03166318d928316040518163ffffffff1660e01b8152600401602060405180830381865afa1580156135a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135c69190615562565b156135e457604051635e1633d360e11b815260040160405180910390fd5b50505050565b613618816001600160401b03166135ff612aca565b60ff851660009081526020919091526040902090613407565b613635576040516313e5d5f160e11b815260040160405180910390fd5b6040805160ff841681526001600160401b03831660208201527f3e9a7af2aeebce9d24ef707bdb61adf2708293e374a19f8e9c31f905c68b43c19101610974565b600061060682600584600001516001600160a01b03166389dd9f13613a91565b600786015460009060ff1686106136c3576040516315f7ec4560e21b8152600481018790526024016108b7565b8660080186815481106136d8576136d86150e3565b60009182526020822060088204015460079091166004026101000a900463ffffffff169150819003610c3057604051631a95890960e31b81526000906001600160a01b0384169063d4ac48489061373590889088906004016151da565b60a060405180830381865afa158015613752573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613776919061557f565b602081015181518b549293506137a09263ffffffff9283169290911690610100900460ff16613e22565b158015906137f157506137b1612aca565b8954600191909101906000906137db906001600160a01b038916908890610100900460ff166132a0565b815260208101919091526040016000205460ff16155b801561381e5750885461380d90610100900460ff166005615616565b60ff16816000015163ffffffff1610155b15613897578854610100900460ff166001036138405762138884915050610c30565b8854610100900460ff1660020361385d576222f238915050610c30565b8854610100900460ff1660030361387a57623234dc915050610c30565b8854610100900460ff166004036138975762417780915050610c30565b6040805160058b018054606060208202840181018552938301818152600094849284918401828280156138e957602002820191906000526020600020905b8154815260200190600101908083116138d5575b5050505050815260200160018201805480602002602001604051908101604052809291908181526020016000905b828210156139af5760008481526020908190208301805460408051828502810185019091528181529283018282801561399b57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff168152602001906004019060208260030104928301926001038202915080841161395e5790505b505050505081526020019060010190613917565b50505050815250509050866001600160a01b0316636f383c0f6139ee83600001518b815181106139e1576139e16150e3565b6020026020010151613e78565b83602001518b81518110613a0457613a046150e3565b60200260200101518d60000160019054906101000a900460ff168a8a6040518663ffffffff1660e01b8152600401613a40959493929190615632565b6020604051808303816000875af1158015613a5f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a839190615681565b9a9950505050505050505050565b600080856020015185600e811115613aab57613aab61569e565b600f8110613abb57613abb6150e3565b602002015190506001600160a01b03811615613ad8579050610615565b83836040518163ffffffff1660e01b8152600401602060405180830381865afa158015613b09573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b2d919061503f565b866020015186600e811115613b4457613b4461569e565b600f8110613b5457613b546150e3565b6001600160a01b039092166020928302919091015286015185600e811115613b7e57613b7e61569e565b600f8110613b8e57613b8e6150e3565b60200201519695505050505050565b6000826000018281548110613bb457613bb46150e3565b9060005260206000200154905092915050565b60006106068261310a565b60008080613be08585613168565b600081815260029690960160205260409095205494959350505050565b60008181526001830160205260408120548015613ce6576000613c21600183615072565b8554909150600090613c3590600190615072565b9050808214613c9a576000866000018281548110613c5557613c556150e3565b9060005260206000200154905080876000018481548110613c7857613c786150e3565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080613cab57613cab6156b4565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610606565b6000915050610606565b6000600160801b8210613d1057608091821c91613d0d9082615085565b90505b600160401b8210613d2e57604091821c91613d2b9082615085565b90505b600160201b8210613d4c57602091821c91613d499082615085565b90505b620100008210613d6957601091821c91613d669082615085565b90505b6101008210613d8557600891821c91613d829082615085565b90505b60108210613da057600491821c91613d9d9082615085565b90505b60048210613dbb57600291821c91613db89082615085565b90505b60028210613dce57610606600182615085565b919050565b6000818152600183016020526040812054613e1a57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610606565b506000610606565b6000806005613e3386866001613f6c565b613e3d91906152a5565b613e48906001615085565b9050828111613e585760006107bb565b613e628382615072565b613e6d90600a615085565b6107bb90600261539d565b60606000613e85836132d5565b90506000805b8251811015613ece57828181518110613ea657613ea66150e3565b602002602001015160ff1660000315613ece5781613ec381615275565b925050600101613e8b565b50806001600160401b03811115613ee757613ee76142d1565b604051908082528060200260200182016040528015613f10578160200160208202803683370190505b50925060005b81811015613f6457828181518110613f3057613f306150e3565b6020026020010151848281518110613f4a57613f4a6150e3565b60ff90921660209283029190910190910152600101613f16565b505050919050565b600080613f798585613fa2565b9050828015613f9257506002613f90826001615085565b115b15610615576107bb600282615072565b805b606381101561060657613fb8836001615085565b613fc182613fd5565b63ffffffff16101561060657600101613fa4565b600063ffffffff82161580613ff15750606363ffffffff831610155b15613ffe57506000919050565b670de0b6b3a76400006140386140158460636156ca565b6140209060026156e7565b6121d79063ffffffff16670de0b6b3a764000061528e565b61404a90675cfb2e807b1e0000615072565b61405d620186a063ffffffff861661528e565b614067919061528e565b61060691906152a5565b6040518060e00160405280600060ff168152602001600060ff168152602001606081526020016000801916815260200160608152602001606081526020016140cc604051806040016040528060608152602001606081525090565b905290565b604051806040016040528060006001600160a01b031681526020016140cc61423f565b508054600082556007016008900490600052602060002090810190610860919061425e565b5080546000825590600052602060002090810190610860919061425e565b50805460008255906000526020600020908101906108609190614273565b828054828255906000526020600020906007016008900481019282156141f45791602002820160005b838211156141c257835183826101000a81548163ffffffff021916908363ffffffff160217905550926020019260040160208160030104928301926001030261417e565b80156141f25782816101000a81549063ffffffff02191690556004016020816003010492830192600103026141c2565b505b5061420092915061425e565b5090565b8280548282559060005260206000209081019282156141f4579160200282015b828111156141f4578251825591602001919060010190614224565b604051806101e00160405280600f906020820280368337509192915050565b5b80821115614200576000815560010161425f565b8082111561420057600061428782826140f4565b50600101614273565b6001600160a01b038116811461086057600080fd5b600080604083850312156142b857600080fd5b82356142c381614290565b946020939093013593505050565b634e487b7160e01b600052604160045260246000fd5b60405161012081016001600160401b038111828210171561430a5761430a6142d1565b60405290565b604051601f8201601f191681016001600160401b0381118282101715614338576143386142d1565b604052919050565b600082601f83011261435157600080fd5b81356001600160401b0381111561436a5761436a6142d1565b61437d601f8201601f1916602001614310565b81815284602083860101111561439257600080fd5b816020850160208301376000918101602001919091529392505050565b600080600080608085870312156143c557600080fd5b84356143d081614290565b935060208501356143e081614290565b92506040850135915060608501356001600160401b0381111561440257600080fd5b61440e87828801614340565b91505092959194509250565b60006020828403121561442c57600080fd5b813561443781614290565b9392505050565b6001600160401b038116811461086057600080fd5b801515811461086057600080fd5b8035613dce81614453565b6000806040838503121561447f57600080fd5b823561448a8161443e565b9150602083013561449a81614453565b809150509250929050565b803561ffff81168114613dce57600080fd5b60ff8116811461086057600080fd5b8035613dce816144b7565b600080600080608085870312156144e757600080fd5b6144f0856144a5565b93506020850135614500816144b7565b9250604085013561451081614290565b9396929550929360600135925050565b6000806040838503121561453357600080fd5b823561453e8161443e565b915060208301356001600160401b0381111561455957600080fd5b61456585828601614340565b9150509250929050565b60006020828403121561458157600080fd5b81356144378161443e565b63ffffffff8116811461086057600080fd5b600080600080608085870312156145b457600080fd5b84356145bf8161458c565b935060208501356145cf81614290565b92506040850135915060608501356145e6816144b7565b939692955090935050565b60008060006060848603121561460657600080fd5b833561461181614290565b925060208401359150604084013561462881614290565b809150509250925092565b60006020828403121561464557600080fd5b5035919050565b600080600080600060a0868803121561466457600080fd5b853561466f81614290565b9450602086013561467f816144b7565b9350604086013561468f81614290565b94979396509394606081013594506080013592915050565b600080604083850312156146ba57600080fd5b50508035926020909101359150565b6000815180845260005b818110156146ef576020818501810151868301820152016146d3565b506000602082860101526020601f19601f83011685010191505092915050565b60208152600061060360208301846146c9565b6001600160a01b0391909116815260200190565b60008151808452602080850194506020840160005b838110156147705781516001600160a01b03168752958201959082019060010161474b565b509495945050505050565b60008151808452602080850194506020840160005b8381101561477057815187529582019590820190600101614790565b60008151808452602080850194506020840160005b8381101561477057815163ffffffff16875295820195908201906001016147c1565b61ffff8c1681528a151560208201526001600160a01b038a1660408201526060810189905263ffffffff88166080820152600061016060ff891660a08401528060c084015261483481840189614736565b905082810360e0840152614848818861477b565b905082810361010084015261485d818761477b565b60ff8616610120850152905082810361014084015261487c81856147ac565b9e9d5050505050505050505050505050565b6000806000606084860312156148a357600080fd5b6148ac846144a5565b925060208401356148bc816144b7565b91506040840135614628816144b7565b600080600080600080600060e0888a0312156148e757600080fd5b87356148f281614290565b965060208801359550604088013594506060880135614910816144b7565b93506080880135614920816144b7565b925060a0880135614930816144b7565b915060c0880135614940816144b7565b8091505092959891949750929550565b60008060006060848603121561496557600080fd5b83356149708161443e565b9250602084013561498081614290565b929592945050506040919091013590565b600080600080608085870312156149a757600080fd5b84356149b281614290565b966020860135965060408601359560600135945092505050565b6000602082840312156149de57600080fd5b610603826144a5565b60008282518085526020808601955060208260051b8401016020860160005b84811015614a3457601f19868403018952614a228383516147ac565b98840198925090830190600101614a06565b5090979650505050505050565b6000815160408452614a56604085018261477b565b9050602083015184820360208601526107bb82826149e7565b6020815260ff825116602082015260006020830151614a93604084018260ff169052565b50604083015160e06060840152614aae6101008401826147ac565b9050606084015160808401526080840151601f19808584030160a0860152614ad6838361477b565b925060a08601519150808584030160c0860152614af3838361477b565b925060c08601519150808584030160e0860152506107bb8282614a41565b60008151808452602080850194506020840160005b8381101561477057815160ff1687529582019590820190600101614b26565b6020815260006106036020830184614b11565b60006001600160401b03821115614b7157614b716142d1565b5060051b60200190565b600082601f830112614b8c57600080fd5b81356020614ba1614b9c83614b58565b614310565b828152600592831b8501820192828201919087851115614bc057600080fd5b8387015b85811015614a345780356001600160401b03811115614be35760008081fd5b8801603f81018a13614bf55760008081fd5b858101356040614c07614b9c83614b58565b82815291851b8301810191888101908d841115614c245760008081fd5b938201935b83851015614c4e5784359250614c3e836144b7565b8282529389019390890190614c29565b885250505093850193508401614bc4565b600082601f830112614c7057600080fd5b81356020614c80614b9c83614b58565b8083825260208201915060208460051b870101935086841115614ca257600080fd5b602086015b84811015614cc7578035614cba8161458c565b8352918301918301614ca7565b509695505050505050565b600082601f830112614ce357600080fd5b81356020614cf3614b9c83614b58565b82815260059290921b84018101918181019086841115614d1257600080fd5b8286015b84811015614cc75780356001600160401b03811115614d355760008081fd5b614d438986838b0101614c5f565b845250918301918301614d16565b600082601f830112614d6257600080fd5b81356020614d72614b9c83614b58565b8083825260208201915060208460051b870101935086841115614d9457600080fd5b602086015b84811015614cc75780358352918301918301614d99565b600082601f830112614dc157600080fd5b81356020614dd1614b9c83614b58565b8083825260208201915060208460051b870101935086841115614df357600080fd5b602086015b84811015614cc7578035614e0b8161443e565b8352918301918301614df8565b600082601f830112614e2957600080fd5b81356020614e39614b9c83614b58565b8083825260208201915060208460051b870101935086841115614e5b57600080fd5b602086015b84811015614cc7578035614e7381614453565b8352918301918301614e60565b60008060008060008060c08789031215614e9957600080fd5b614ea2876144a5565b95506020870135614eb2816144b7565b945060408701356001600160401b0380821115614ece57600080fd5b90880190610120828b031215614ee357600080fd5b614eeb6142e7565b823582811115614efa57600080fd5b614f068c828601614b7b565b825250602083013582811115614f1b57600080fd5b614f278c828601614cd2565b602083015250604083013582811115614f3f57600080fd5b614f4b8c828601614c5f565b604083015250614f5d606084016144c6565b6060820152614f6e608084016144c6565b608082015260a083013582811115614f8557600080fd5b614f918c828601614d51565b60a08301525060c083013582811115614fa957600080fd5b614fb58c828601614db0565b60c08301525060e083013582811115614fcd57600080fd5b614fd98c828601614db0565b60e0830152506101008084013583811115614ff357600080fd5b614fff8d828701614e18565b828401525050809650505050615017606088016144c6565b9250615025608088016144c6565b915061503360a08801614461565b90509295509295509295565b60006020828403121561505157600080fd5b815161443781614290565b634e487b7160e01b600052601160045260246000fd5b818103818111156106065761060661505c565b808201808211156106065761060661505c565b6000602082840312156150aa57600080fd5b81516144378161443e565b6000806000606084860312156150ca57600080fd5b8351925060208401519150604084015190509250925092565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561510b57600080fd5b5051919050565b6001600160a01b039390931683526020830191909152604082015260600190565b8781528660208201526001600160401b0386166040820152600060018060a01b03808716606084015260e0608084015261517060e08401876146c9565b941660a08301525063ffffffff9190911660c09091015295945050505050565b600080600080608085870312156151a657600080fd5b84516151b181614453565b6020860151604087015191955093506151c98161458c565b60608601519092506145e681614453565b6001600160a01b03929092168252602082015260400190565b60006020828403121561520557600080fd5b8151614437816144b7565b634e487b7160e01b600052601260045260246000fd5b600060ff83168061523957615239615210565b8060ff84160491505092915050565b60ff81811683821601908111156106065761060661505c565b60008261527057615270615210565b500690565b6000600182016152875761528761505c565b5060010190565b80820281158282048414176106065761060661505c565b6000826152b4576152b4615210565b500490565b600181815b808511156152f45781600019048211156152da576152da61505c565b808516156152e757918102915b93841c93908002906152be565b509250929050565b60008261530b57506001610606565b8161531857506000610606565b816001811461532e576002811461533857615354565b6001915050610606565b60ff8411156153495761534961505c565b50506001821b610606565b5060208310610133831016604e8410600b8410161715615377575081810a610606565b61538183836152b9565b80600019048211156153955761539561505c565b029392505050565b600061060383836152fc565b60008282518085526020808601955060208260051b8401016020860160005b84811015614a3457601f198684030189526153e4838351614b11565b988401989250908301906001016153c8565b60008151808452602080850194506020840160005b838110156147705781516001600160401b03168752958201959082019060010161540b565b60008151808452602080850194506020840160005b83811015614770578151151587529582019590820190600101615445565b61ffff83168152604060208201526000825161012080604085015261548c6101608501836153a9565b91506020850151603f19808685030160608701526154aa84836149e7565b935060408701519150808685030160808701526154c784836147ac565b9350606087015191506154df60a087018360ff169052565b608087015160ff1660c087015260a0870151868503820160e08801529150615507848361477b565b935060c0870151915061010081878603018188015261552685846153f6565b945060e0880151925081878603018488015261554285846153f6565b945080880151935050808685030161014087015250506114ce8282615430565b60006020828403121561557457600080fd5b815161443781614453565b600060a0828403121561559157600080fd5b60405160a081018181106001600160401b03821117156155b3576155b36142d1565b60405282516155c18161458c565b815260208301516155d18161458c565b602082015260408301516155e48161458c565b604082015260608301516155f78161458c565b6060820152608083015161560a8161458c565b60808201529392505050565b60ff81811683821602908116908181146133465761334661505c565b60a08152600061564560a0830188614b11565b828103602084015261565781886147ac565b60ff96909616604084015250506001600160a01b0392909216606083015260809091015292915050565b60006020828403121561569357600080fd5b81516144378161458c565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052603160045260246000fd5b63ffffffff8281168282160390808211156133465761334661505c565b63ffffffff8181168382160190808211156133465761334661505c56fe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda26469706673582212206add5e1b9122d0164ff9d547463cf353763f3997eab433f184e9ec09d61cf30164736f6c63430008170033",
  "libraries": {
    "DungeonLib": "0x9ceDa5bC06a5b3a2416FAca9D37dcbe7410260cf",
    "DungeonFactoryLib": "0xEfa058adaC8A0D21724D73f9466e3AF0D1B9A358"
  },
  "devdoc": {
    "errors": {
      "InvalidInitialization()": [
        {
          "details": "The contract is already initialized."
        }
      ],
      "NotInitializing()": [
        {
          "details": "The contract is not initializing."
        }
      ]
    },
    "events": {
      "Initialized(uint64)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      }
    },
    "kind": "dev",
    "methods": {
      "created()": {
        "returns": {
          "_0": "Creation timestamp"
        }
      },
      "createdBlock()": {
        "returns": {
          "_0": "Creation block number"
        }
      },
      "emergencyExit(uint64)": {
        "details": "Governance can drop hero from dungeon in emergency case"
      },
      "exitForcibly(address,uint256,address)": {
        "details": "Implement logic of special consumable that allows a hero to exit current dungeon using the shelter"
      },
      "increaseRevision(address)": {
        "details": "Revision should be increased on each contract upgrade"
      },
      "isBiomeBoss(address,uint256)": {
        "details": "Easily get info should given hero fight with boss in the current biome or not."
      },
      "isController(address)": {
        "details": "Return true if given address is controller"
      },
      "onERC721Received(address,address,uint256,bytes)": {
        "details": "See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."
      },
      "previousImplementation()": {
        "details": "Previous logic implementation"
      },
      "registerDungeonLogic(uint16,uint8,(uint8[][],uint32[][],uint32[],uint8,uint8,bytes32[],uint64[],uint64[],bool[]),uint8,uint8,bool)": {
        "params": {
          "biome": "Assume biome > 0",
          "isSpecific": "The dungeon is specific, so it shouldn't be registered in dungeonsLogicByBiome",
          "specReqBiome": "required biome",
          "specReqHeroClass": "required hero class"
        }
      },
      "revision()": {
        "details": "Contract upgrade counter"
      },
      "setMinLevelForTreasury(address,uint256)": {
        "details": "Set eligible hero level for treasury tokens"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "CONTROLLABLE_VERSION()": {
        "notice": "Version of the contract"
      },
      "VERSION()": {
        "notice": "Version of the contract"
      },
      "controller()": {
        "notice": "Return controller address saved in the contract slot"
      },
      "created()": {
        "notice": "Return creation timestamp"
      },
      "createdBlock()": {
        "notice": "Return creation block number"
      },
      "exitForcibly(address,uint256,address)": {
        "notice": "Hero exists current dungeon forcibly same as when dying but without loosing life chance"
      },
      "isGovernance(address)": {
        "notice": "Return true if given address is setup as governance in Controller"
      },
      "registerDungeonLogic(uint16,uint8,(uint8[][],uint32[][],uint32[],uint8,uint8,bytes32[],uint64[],uint64[],bool[]),uint8,uint8,bool)": {
        "notice": "Register ordinal or specific dungeon"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}