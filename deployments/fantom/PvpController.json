{
  "address": "0xf452568Efaf85f8070EE4ac011cF83d45a09e63E",
  "abi": [
    {
      "inputs": [],
      "name": "BiomeAlreadySelected",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "name": "EnumerableMapNonexistentKey",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "ErrorHeroIsDead",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        }
      ],
      "name": "ErrorHeroIsNotRegistered",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "biome",
          "type": "uint256"
        }
      ],
      "name": "ErrorIncorrectBiome",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "heroLevel",
          "type": "uint256"
        }
      ],
      "name": "ErrorLevelTooLow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ErrorNotDeployer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorNotGuildController",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ErrorNotOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ErrorPaused",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "right",
          "type": "uint256"
        }
      ],
      "name": "GuildActionForbidden",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "HeroInDungeon",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "HeroWasTransferredBetweenAccounts",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidInitialization",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoDominationRequest",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotGuildMember",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotInitializing",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PvpFightOpponentNotFound",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PvpHeroHasInitializedFight",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PvpHeroNotRegistered",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SandboxModeNotAllowed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        }
      ],
      "name": "Staked",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "TooHighValue",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TooLowGuildLevel",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnknownPvpStrategy",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "name": "UserHasRegisteredPvpHeroInBiome",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "week",
          "type": "uint256"
        }
      ],
      "name": "UserNotAllowedForPvpInCurrentEpoch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "week",
          "type": "uint32"
        }
      ],
      "name": "AddBiomeRequest",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ts",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "block",
          "type": "uint256"
        }
      ],
      "name": "ContractInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "week",
          "type": "uint32"
        }
      ],
      "name": "FirstPvpEpoch",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "version",
          "type": "uint64"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint48",
          "name": "fightId",
          "type": "uint48"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "week",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroGuildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "opponentHero",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "opponentHeroId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "opponentGuildId",
          "type": "uint256"
        }
      ],
      "name": "PreparePvpFight",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "week",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "name": "PvpHeroAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "week",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "manuallyRemoved",
          "type": "bool"
        }
      ],
      "name": "PvpHeroRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "RevisionIncreased",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "adapter",
          "type": "address"
        }
      ],
      "name": "SetGuildStakingAdapter",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "level",
          "type": "uint256"
        }
      ],
      "name": "SetMinHeroLevel",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "week",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "guildBiomeOwnerId",
          "type": "uint256"
        }
      ],
      "name": "UpdatePvpEpoch",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CONTROLLABLE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "pvpStrategy",
          "type": "bytes"
        },
        {
          "internalType": "uint8",
          "name": "maxFights",
          "type": "uint8"
        }
      ],
      "name": "addPvpHero",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "created",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "createdBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentWeek",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "uint32",
          "name": "week",
          "type": "uint32"
        }
      ],
      "name": "getBiomeGuilds",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "guildIds",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "name": "getBiomeOwner",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "name": "getBiomeTax",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "taxPercent",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCounterFightId",
      "outputs": [
        {
          "internalType": "uint48",
          "name": "",
          "type": "uint48"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "blockTimestamp",
          "type": "uint256"
        }
      ],
      "name": "getCurrentEpochWeek",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "name": "getDominationCounter",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "dominationCounter",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "week",
          "type": "uint32"
        }
      ],
      "name": "getDominationRequest",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "epochWeek",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index0",
          "type": "uint256"
        }
      ],
      "name": "getFightDataByIndex",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "fightOpponent",
              "type": "address"
            },
            {
              "internalType": "enum IPvpController.PvpFightStatus",
              "name": "fightStatus",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "health",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "mana",
              "type": "uint32"
            },
            {
              "internalType": "uint8",
              "name": "countTurns",
              "type": "uint8"
            }
          ],
          "internalType": "struct IPvpController.PvpFightData",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "epochWeek",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "getFightDataLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "uint32",
          "name": "epochWeek",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "name": "getFreeUsers",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "uint32",
          "name": "epochWeek",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "name": "getGuildPoints",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getGuildStakingAdapter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getMinHeroLevel",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "uint32",
          "name": "epochWeek",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        }
      ],
      "name": "getPvpStrategy",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "uint32",
          "name": "epochWeek",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        }
      ],
      "name": "getPvpStrategyKind",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "name": "getStartedEpoch",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "epochWeek",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "week",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "getUserState",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "biome",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "activeFightIndex1",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "numHeroesStaked",
              "type": "uint32"
            },
            {
              "internalType": "uint64",
              "name": "guildId",
              "type": "uint64"
            },
            {
              "internalType": "uint8",
              "name": "countFights",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "maxFights",
              "type": "uint8"
            },
            {
              "internalType": "uint48",
              "name": "fightId",
              "type": "uint48"
            }
          ],
          "internalType": "struct IPvpController.PvpUserState",
          "name": "userState",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "week",
          "type": "uint32"
        }
      ],
      "name": "hasPvpHero",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "increaseRevision",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "controller_",
          "type": "address"
        }
      ],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isController",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isGovernance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "epoch",
          "type": "uint32"
        }
      ],
      "name": "isHeroStaked",
      "outputs": [
        {
          "internalType": "bool",
          "name": "staked",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        }
      ],
      "name": "isHeroStakedCurrently",
      "outputs": [
        {
          "internalType": "bool",
          "name": "staked",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "forwarder",
          "type": "address"
        }
      ],
      "name": "isTrustedForwarder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC721Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "name": "onGuildDeletion",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "name": "ownedBiome",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "prepareFight",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "previousImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "name": "refreshBiomeTax",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "taxPercent",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "uint32",
          "name": "epochWeek",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "registeredHero",
      "outputs": [
        {
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroId",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "uint32",
          "name": "epochWeek",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "guildId",
          "type": "uint256"
        }
      ],
      "name": "registeredUsers",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "removePvpHero",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "revision",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "name": "selectBiomeForDomination",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "adapter_",
          "type": "address"
        }
      ],
      "name": "setGuildStakingAdapter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "level",
          "type": "uint256"
        }
      ],
      "name": "setMinHeroLevel",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "maxCountTurns",
          "type": "uint8"
        }
      ],
      "name": "startFight",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        }
      ],
      "name": "updateEpoch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x4add4c8299141876a97a34c0fa29b6cc04132321423c00384ceaa01ac16df037",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0xf452568Efaf85f8070EE4ac011cF83d45a09e63E",
    "transactionIndex": 0,
    "gasUsed": "4818168",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000080000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0005173200000489235d022a738d9c8a97545e3032ed4bb195e36d484726d632",
    "transactionHash": "0x4add4c8299141876a97a34c0fa29b6cc04132321423c00384ceaa01ac16df037",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 105001780,
        "transactionHash": "0x4add4c8299141876a97a34c0fa29b6cc04132321423c00384ceaa01ac16df037",
        "address": "0xf452568Efaf85f8070EE4ac011cF83d45a09e63E",
        "topics": [
          "0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 0,
        "blockHash": "0x0005173200000489235d022a738d9c8a97545e3032ed4bb195e36d484726d632"
      }
    ],
    "blockNumber": 105001780,
    "cumulativeGasUsed": "4818168",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "1a4342b5d9fe8c3b83a893539aac6eae",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BiomeAlreadySelected\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"EnumerableMapNonexistentKey\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"ErrorHeroIsDead\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"}],\"name\":\"ErrorHeroIsNotRegistered\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"biome\",\"type\":\"uint256\"}],\"name\":\"ErrorIncorrectBiome\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroLevel\",\"type\":\"uint256\"}],\"name\":\"ErrorLevelTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ErrorNotDeployer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorNotGuildController\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ErrorNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"right\",\"type\":\"uint256\"}],\"name\":\"GuildActionForbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HeroInDungeon\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HeroWasTransferredBetweenAccounts\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoDominationRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotGuildMember\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PvpFightOpponentNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PvpHeroHasInitializedFight\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PvpHeroNotRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SandboxModeNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TooHighValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooLowGuildLevel\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnknownPvpStrategy\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"name\":\"UserHasRegisteredPvpHeroInBiome\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"week\",\"type\":\"uint256\"}],\"name\":\"UserNotAllowedForPvpInCurrentEpoch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"week\",\"type\":\"uint32\"}],\"name\":\"AddBiomeRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"ContractInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"week\",\"type\":\"uint32\"}],\"name\":\"FirstPvpEpoch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"fightId\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"week\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroGuildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"opponentHero\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"opponentHeroId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"opponentGuildId\",\"type\":\"uint256\"}],\"name\":\"PreparePvpFight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"week\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"name\":\"PvpHeroAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"week\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"manuallyRemoved\",\"type\":\"bool\"}],\"name\":\"PvpHeroRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"RevisionIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"SetGuildStakingAdapter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"SetMinHeroLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"week\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildBiomeOwnerId\",\"type\":\"uint256\"}],\"name\":\"UpdatePvpEpoch\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTROLLABLE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"pvpStrategy\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"maxFights\",\"type\":\"uint8\"}],\"name\":\"addPvpHero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentWeek\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"week\",\"type\":\"uint32\"}],\"name\":\"getBiomeGuilds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"guildIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"name\":\"getBiomeOwner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"name\":\"getBiomeTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCounterFightId\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"getCurrentEpochWeek\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"name\":\"getDominationCounter\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"dominationCounter\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"week\",\"type\":\"uint32\"}],\"name\":\"getDominationRequest\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"epochWeek\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index0\",\"type\":\"uint256\"}],\"name\":\"getFightDataByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fightOpponent\",\"type\":\"address\"},{\"internalType\":\"enum IPvpController.PvpFightStatus\",\"name\":\"fightStatus\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"health\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"mana\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"countTurns\",\"type\":\"uint8\"}],\"internalType\":\"struct IPvpController.PvpFightData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"epochWeek\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getFightDataLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"epochWeek\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"name\":\"getFreeUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"epochWeek\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"name\":\"getGuildPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGuildStakingAdapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinHeroLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"epochWeek\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"getPvpStrategy\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"epochWeek\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"getPvpStrategyKind\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"name\":\"getStartedEpoch\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"epochWeek\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"week\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"activeFightIndex1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numHeroesStaked\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"guildId\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"countFights\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxFights\",\"type\":\"uint8\"},{\"internalType\":\"uint48\",\"name\":\"fightId\",\"type\":\"uint48\"}],\"internalType\":\"struct IPvpController.PvpUserState\",\"name\":\"userState\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"week\",\"type\":\"uint32\"}],\"name\":\"hasPvpHero\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"increaseRevision\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"}],\"name\":\"isHeroStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"staked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"isHeroStakedCurrently\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"staked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"name\":\"onGuildDeletion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"name\":\"ownedBiome\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prepareFight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"name\":\"refreshBiomeTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"epochWeek\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"registeredHero\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"epochWeek\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"name\":\"registeredUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removePvpHero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"name\":\"selectBiomeForDomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adapter_\",\"type\":\"address\"}],\"name\":\"setGuildStakingAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"setMinHeroLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"maxCountTurns\",\"type\":\"uint8\"}],\"name\":\"startFight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"}],\"name\":\"updateEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"EnumerableMapNonexistentKey(bytes32)\":[{\"details\":\"Query for a nonexistent map key.\"}],\"InvalidInitialization()\":[{\"details\":\"The contract is already initialized.\"}],\"NotInitializing()\":[{\"details\":\"The contract is not initializing.\"}]},\"events\":{\"Initialized(uint64)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"},\"PvpHeroRemoved(address,uint256,uint256,uint8,address,uint256,bool)\":{\"params\":{\"manuallyRemoved\":\"True - removed manually by the user, false - removed automatically after the fight\"}}},\"kind\":\"dev\",\"methods\":{\"addPvpHero(address,uint256,bytes,uint8)\":{\"params\":{\"pvpStrategy\":\"abi.encode(PvpAttackInfoDefaultStrategy)\"}},\"created()\":{\"returns\":{\"_0\":\"Creation timestamp\"}},\"createdBlock()\":{\"returns\":{\"_0\":\"Creation block number\"}},\"getBiomeTax(uint8)\":{\"returns\":{\"guildId\":\"Owner of the biome\",\"taxPercent\":\"Final tax percent, [0...100_000], decimals 3\"}},\"getDominationRequest(uint256,uint32)\":{\"returns\":{\"biome\":\"Biome where the guild is going to dominate in the given epoch\"}},\"increaseRevision(address)\":{\"details\":\"Revision should be increased on each contract upgrade\"},\"isController(address)\":{\"details\":\"Return true if given address is controller\"},\"onERC721Received(address,address,uint256,bytes)\":{\"details\":\"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`.\"},\"previousImplementation()\":{\"details\":\"Previous logic implementation\"},\"refreshBiomeTax(uint8)\":{\"returns\":{\"guildId\":\"Owner of the biome\",\"taxPercent\":\"Tax percent [0...100_000], decimals 3\"}},\"revision()\":{\"details\":\"Contract upgrade counter\"}},\"stateVariables\":{\"VERSION\":{\"details\":\"Should be incremented when contract changed\"}},\"version\":1},\"userdoc\":{\"errors\":{\"BiomeAlreadySelected()\":[{\"notice\":\"Target biome can be selected only once per epoch\"}],\"UserHasRegisteredPvpHeroInBiome(uint8)\":[{\"notice\":\"User should unregister pvp-hero from prev biome and only then register it in the new biome\"}]},\"kind\":\"user\",\"methods\":{\"CONTROLLABLE_VERSION()\":{\"notice\":\"Version of the contract\"},\"VERSION()\":{\"notice\":\"Version of the contract\"},\"addPvpHero(address,uint256,bytes,uint8)\":{\"notice\":\"Stake hero for pvp for the current epoch. User is able to register a hero only once per epoch, the hero cannot be replaced, only removed.\"},\"controller()\":{\"notice\":\"Return controller address saved in the contract slot\"},\"created()\":{\"notice\":\"Return creation timestamp\"},\"createdBlock()\":{\"notice\":\"Return creation block number\"},\"getBiomeGuilds(uint8,uint32)\":{\"notice\":\"List of guilds that send domination request for the biome\"},\"getBiomeTax(uint8)\":{\"notice\":\"Get biome tax\"},\"getCurrentEpochWeek(uint256)\":{\"notice\":\"Get week for the given timestamp. Assume that first day of the week is Monday\"},\"getFightDataLength(uint32,address)\":{\"notice\":\"Number of pvp-fights registered for the user in the given epoch\"},\"getMinHeroLevel()\":{\"notice\":\"Get min hero level allowed for pvp-fight\"},\"hasPvpHero(address,uint256,uint32)\":{\"notice\":\"Check if the user has a pvp-hero registered for pvp-fight in the given epoch\"},\"isGovernance(address)\":{\"notice\":\"Return true if given address is setup as governance in Controller\"},\"isHeroStaked(address,uint256,uint32)\":{\"notice\":\"Check if the given hero is staked in pvp controller in the given epoch\"},\"isHeroStakedCurrently(address,uint256)\":{\"notice\":\"Check if the given hero is staked in pvp controller in the current epoch\"},\"ownedBiome(uint256)\":{\"notice\":\"Biome owned currently by the given guild\"},\"refreshBiomeTax(uint8)\":{\"notice\":\"Update epoch if necessary and return biome owner and biome tax\"},\"registeredHero(uint8,uint32,uint256,address)\":{\"notice\":\"Hero registered by the user for pvp-fight in the given week and biome\"},\"registeredUsers(uint8,uint32,uint256)\":{\"notice\":\"List of the users registered for pvp-fight in the given week and biome\"},\"removePvpHero()\":{\"notice\":\"Withdraw hero from pvp for the current epoch\"},\"selectBiomeForDomination(uint8)\":{\"notice\":\"Select new domination target once per epoch\"},\"updateEpoch(uint8)\":{\"notice\":\"Change epoch if the current epoch is completed, update biome owner\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/PvpController.sol\":\"PvpController\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":50},\"remappings\":[]},\"sources\":{\"contracts/core/PvpController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n/**\\n            \\u2592\\u2593\\u2592  \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2593\\n             \\u2592\\u2588\\u2588\\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593  \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n              \\u2592\\u2588\\u2588\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592 \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n               \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592                   \\u2592\\u2588\\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                     \\u2592\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592     \\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                   \\u2592\\u2592\\u2592\\u2592\\u2592   \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                         \\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                       \\u2592\\u2588\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\n                        \\u2592\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592       \\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\n                          \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593   \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                           \\u2592\\u2592\\u2593\\u2593\\u2592   \\u2592\\u2588\\u2588\\u2593\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                  \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                                 \\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                                \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n      \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593                  \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                      \\u2592\\u2593\\u2593\\n    \\u2592\\u2593\\u2588\\u2592   \\u2592\\u2592\\u2588\\u2592\\u2592                   \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2592\\u2593\\u2593\\u2592\\n   \\u2592\\u2592\\u2588\\u2592       \\u2593\\u2592                    \\u2592\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2588\\u2593\\u2592\\n   \\u2593\\u2592\\u2588\\u2588\\u2593\\u2592                             \\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2592\\n    \\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2593\\u2592        \\u2592\\u2592\\u2592         \\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592\\u2592\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2592 \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n     \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2592\\u2592\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2593\\u2593     \\u2593\\u2593  \\u2593\\u2593\\u2588\\u2593   \\u2592\\u2592\\u2593\\u2593   \\u2592\\u2592\\u2588\\u2592   \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n            \\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592  \\u2592\\u2593\\u2593\\u2593\\u2592\\u2588\\u2592   \\u2592\\u2592\\u2592\\u2588\\u2592          \\u2592\\u2592\\u2588\\u2593\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592   \\u2593\\u2588\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\n \\u2592            \\u2592\\u2593\\u2593\\u2588\\u2593  \\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2593  \\u2592\\u2588\\u2593\\u2593\\u2592          \\u2593\\u2593\\u2588\\u2593\\u2592\\u2593\\u2588\\u2593\\u2592\\u2592   \\u2593\\u2588\\u2593        \\u2593\\u2588\\u2588\\u2588\\u2593\\n\\u2593\\u2593\\u2592         \\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592\\u2592\\u2593\\u2588\\u2592   \\u2592\\u2593\\u2588\\u2588\\u2593  \\u2593\\u2588\\u2588\\u2593\\u2592     \\u2592\\u2588\\u2593 \\u2593\\u2593\\u2588\\u2588   \\u2592\\u2593\\u2593\\u2593\\u2592\\u2592\\u2593\\u2588\\u2593        \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2592\\n \\u2588\\u2588\\u2593\\u2593\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592\\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592     \\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592\\n*/\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IPvpController.sol\\\";\\nimport \\\"../lib/PvpControllerLib.sol\\\";\\nimport \\\"../lib/PvpFightLib.sol\\\";\\nimport \\\"../proxy/Controllable.sol\\\";\\nimport \\\"../relay/ERC2771Context.sol\\\";\\nimport \\\"../openzeppelin/ERC721Holder.sol\\\";\\n\\ncontract PvpController is Initializable, Controllable, ERC2771Context, IPvpController, ERC721Holder {\\n  //region ------------------------ Constants\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant override VERSION = \\\"1.0.0\\\";\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Initializer\\n\\n  function init(address controller_) external initializer {\\n    __Controllable_init(controller_);\\n\\n    PvpControllerLib._S().pvpParam[IPvpController.PvpParams.MIN_HERO_LEVEL_1] = PvpControllerLib.DEFAULT_MIN_HERO_LEVEL;\\n  }\\n  //endregion ------------------------ Initializer\\n\\n  //region ------------------------ View\\n  function getBiomeOwner(uint8 biome) external view returns (uint guildId) {\\n    return PvpControllerLib.getBiomeOwner(biome);\\n  }\\n\\n  function getStartedEpoch(uint8 biome) external view returns (uint32 epochWeek) {\\n    return PvpControllerLib.getStartedEpoch(biome);\\n  }\\n\\n  function getDominationCounter(uint8 biome) external view returns (uint16 dominationCounter) {\\n    return PvpControllerLib.getDominationCounter(biome);\\n  }\\n\\n  /// @notice List of guilds that send domination request for the biome\\n  function getBiomeGuilds(uint8 biome, uint32 week) external view returns (uint[] memory guildIds) {\\n    return PvpControllerLib.getBiomeGuilds(biome, week);\\n  }\\n\\n  /// @return biome Biome where the guild is going to dominate in the given epoch\\n  function getDominationRequest(uint guildId, uint32 week) external view returns (uint8 biome) {\\n    return PvpControllerLib.getDominationRequest(guildId, week);\\n  }\\n\\n  function getGuildPoints(uint8 biome, uint32 epochWeek, uint guildId) external view returns (uint) {\\n    return PvpControllerLib.getGuildPoints(biome, epochWeek, guildId);\\n  }\\n\\n  function getFreeUsers(uint8 biome, uint32 epochWeek, uint guildId) external view returns (address[] memory) {\\n    return PvpControllerLib.getFreeUsers(biome, epochWeek, guildId);\\n  }\\n\\n  function getPvpStrategy(uint8 biome, uint32 epochWeek, address hero, uint heroId) external view returns (bytes memory) {\\n    return PvpControllerLib.getPvpStrategy(biome, epochWeek, hero, heroId);\\n  }\\n\\n  function getPvpStrategyKind(uint8 biome, uint32 epochWeek, address hero, uint heroId) external view returns (uint) {\\n    return PvpControllerLib.getPvpStrategyKind(biome, epochWeek, hero, heroId);\\n  }\\n\\n  /// @notice Number of pvp-fights registered for the user in the given epoch\\n  function getFightDataLength(uint32 epochWeek, address user) external view returns (uint) {\\n    return PvpControllerLib.getFightDataLength(epochWeek, user);\\n  }\\n\\n  function getFightDataByIndex(uint32 epochWeek, address user, uint index0) external view returns (IPvpController.PvpFightData memory) {\\n    return PvpControllerLib.getFightDataByIndex(epochWeek, user, index0);\\n  }\\n\\n  /// @notice List of the users registered for pvp-fight in the given week and biome\\n  function registeredUsers(uint8 biome, uint32 epochWeek, uint guildId) external view returns (address[] memory) {\\n    return PvpControllerLib.registeredUsers(biome, epochWeek, guildId);\\n  }\\n\\n  /// @notice Hero registered by the user for pvp-fight in the given week and biome\\n  function registeredHero(uint8 biome, uint32 epochWeek, uint guildId, address user) external view returns (address hero, uint heroId) {\\n    return PvpControllerLib.registeredHero(biome, epochWeek, guildId, user);\\n  }\\n\\n  /// @notice Biome owned currently by the given guild\\n  function ownedBiome(uint guildId) external view returns (uint8 biome) {\\n    return PvpControllerLib.ownedBiome(guildId);\\n  }\\n\\n  /// @notice Get week for the given timestamp. Assume that first day of the week is Monday\\n  function getCurrentEpochWeek(uint blockTimestamp) external pure returns (uint32) {\\n    return PvpControllerLib.getCurrentEpochWeek(blockTimestamp);\\n  }\\n\\n  function currentWeek() external view returns (uint32) {\\n    return PvpControllerLib.getCurrentEpochWeek(block.timestamp);\\n  }\\n\\n  /// @notice Get biome tax\\n  /// @return guildId Owner of the biome\\n  /// @return taxPercent Final tax percent, [0...100_000], decimals 3\\n  function getBiomeTax(uint8 biome) external view returns (uint guildId, uint taxPercent) {\\n    return PvpControllerLib.getBiomeTax(biome);\\n  }\\n\\n  /// @notice Check if the user has a pvp-hero registered for pvp-fight in the given epoch\\n  function hasPvpHero(address user, uint guildId, uint32 week) external view returns (bool) {\\n    return PvpControllerLib.hasPvpHero(user, guildId, week);\\n  }\\n\\n  /// @notice Check if the given hero is staked in pvp controller in the given epoch\\n  function isHeroStaked(address hero, uint heroId, uint32 epoch) external view returns (bool staked) {\\n    return PvpControllerLib.isHeroStaked(hero, heroId, epoch);\\n  }\\n\\n  /// @notice Check if the given hero is staked in pvp controller in the current epoch\\n  function isHeroStakedCurrently(address hero, uint heroId) external view returns (bool staked) {\\n    return PvpControllerLib.isHeroStaked(hero, heroId, PvpControllerLib.getCurrentEpochWeek(block.timestamp));\\n  }\\n\\n  function getUserState(uint32 week, address user) external view returns (IPvpController.PvpUserState memory userState) {\\n    return PvpControllerLib.getUserState(week, user);\\n  }\\n\\n  /// @notice Get min hero level allowed for pvp-fight\\n  function getMinHeroLevel() external view returns (uint) {\\n    return PvpControllerLib.getMinHeroLevel();\\n  }\\n\\n  function getCounterFightId() external view returns (uint48) {\\n    return PvpControllerLib.getCounterFightId();\\n  }\\n\\n  function getGuildStakingAdapter() external view returns (address) {\\n    return PvpControllerLib.getGuildStakingAdapter();\\n  }\\n\\n  //endregion ------------------------ View\\n\\n  //region ------------------------ Deployer actions\\n  function setMinHeroLevel(uint level) external {\\n    PvpControllerLib.setMinHeroLevel(IController(controller()), level);\\n  }\\n\\n  function setGuildStakingAdapter(address adapter_) external {\\n    PvpControllerLib.setGuildStakingAdapter(IController(controller()), adapter_);\\n  }\\n  //endregion ------------------------ Deployer actions\\n\\n  //region ------------------------ Domination actions\\n\\n  /// @notice Select new domination target once per epoch\\n  function selectBiomeForDomination(uint8 biome) external {\\n    return PvpControllerLib.selectBiomeForDomination(\\n      _msgSender(),\\n      IController(controller()),\\n      biome,\\n      block.timestamp,\\n      CalcLib.pseudoRandom\\n    );\\n  }\\n\\n  /// @notice Withdraw hero from pvp for the current epoch\\n  function removePvpHero() external {\\n    PvpControllerLib.removePvpHero(_msgSender(), IController(controller()), block.timestamp);\\n  }\\n\\n  /// @notice Stake hero for pvp for the current epoch.\\n  /// User is able to register a hero only once per epoch, the hero cannot be replaced, only removed.\\n  /// @param pvpStrategy abi.encode(PvpAttackInfoDefaultStrategy)\\n  function addPvpHero(address hero, uint heroId, bytes memory pvpStrategy, uint8 maxFights) external {\\n    PvpControllerLib.addPvpHero(\\n      _msgSender(),\\n      IController(controller()),\\n      hero,\\n      heroId,\\n      pvpStrategy,\\n      maxFights,\\n      block.timestamp,\\n      CalcLib.pseudoRandom\\n    );\\n  }\\n\\n  /// @notice Change epoch if the current epoch is completed, update biome owner\\n  function updateEpoch(uint8 biome) external {\\n    PvpControllerLib.updateEpoch(biome, block.timestamp, CalcLib.pseudoRandom);\\n  }\\n\\n  /// @notice Update epoch if necessary and return biome owner and biome tax\\n  /// @return guildId Owner of the biome\\n  /// @return taxPercent Tax percent [0...100_000], decimals 3\\n  function refreshBiomeTax(uint8 biome) external returns (uint guildId, uint taxPercent) {\\n    return PvpControllerLib.refreshBiomeTax(biome, block.timestamp, CalcLib.pseudoRandom);\\n  }\\n\\n  function onGuildDeletion(uint guildId) external {\\n    PvpControllerLib.onGuildDeletion(IController(controller()), guildId);\\n  }\\n  //endregion ------------------------ Domination actions\\n\\n  //region ------------------------ PvP actions\\n  function prepareFight() external {\\n    PvpFightLib.prepareFight(_msgSender(), IController(controller()), block.timestamp, CalcLib.pseudoRandom);\\n  }\\n\\n  function startFight(uint8 maxCountTurns) external {\\n    PvpFightLib.startFight(_msgSender(), IController(controller()), block.timestamp, maxCountTurns);\\n  }\\n  //endregion ------------------------ PvP actions\\n}\",\"keccak256\":\"0x96fa54c9fd5b38479560b49e7a9b055738bea353a6c9cc085967890c23a19cea\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IAppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @notice All errors of the app\\ninterface IAppErrors {\\n\\n  //region ERC20Errors\\n  /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n  error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n  /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n  error ERC20InvalidSender(address sender);\\n\\n  /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n  error ERC20InvalidReceiver(address receiver);\\n\\n  /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n  error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n  /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n  error ERC20InvalidApprover(address approver);\\n\\n  /**\\n   * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n  error ERC20InvalidSpender(address spender);\\n\\n  //endregion ERC20Errors\\n\\n  //region ERC721Errors\\n\\n  /**\\n  * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n  error ERC721InvalidOwner(address owner);\\n\\n  /**\\n   * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n  error ERC721NonexistentToken(uint256 tokenId);\\n\\n  /**\\n   * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n  error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n  /**\\n   * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n  error ERC721InvalidSender(address sender);\\n\\n  /**\\n   * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n  error ERC721InvalidReceiver(address receiver);\\n\\n  /**\\n   * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n  error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n  /**\\n   * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n  error ERC721InvalidApprover(address approver);\\n\\n  /**\\n   * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n  error ERC721InvalidOperator(address operator);\\n\\n  //endregion ERC721Errors\\n\\n  error ZeroAddress();\\n  error ZeroValueNotAllowed();\\n  error ZeroToken();\\n  error LengthsMismatch();\\n  error NotEnoughBalance();\\n  error NotEnoughAllowance();\\n  error EmptyNameNotAllowed();\\n  error NotInitialized();\\n  error AlreadyInitialized();\\n  error ReentrancyGuardReentrantCall();\\n  error TooLongString();\\n  error AlreadyDeployed(address deployed);\\n  error AlreadyClaimed();\\n\\n  //region Restrictions\\n  error ErrorNotDeployer(address sender);\\n  error ErrorNotGoc();\\n  error NotGovernance(address sender);\\n  error ErrorOnlyEoa();\\n  error NotEOA(address sender);\\n  error ErrorForbidden(address sender);\\n  error AdminOnly();\\n  error ErrorNotItemController(address sender);\\n  error ErrorNotHeroController(address sender);\\n  error ErrorNotDungeonFactory(address sender);\\n  error ErrorNotObjectController(address sender);\\n  error ErrorNotStoryController();\\n  error ErrorNotAllowedSender();\\n  error MintNotAllowed();\\n  error NotPvpController();\\n  //endregion Restrictions\\n\\n  //region PackingLib\\n  error TooHighValue(uint value);\\n  error IntValueOutOfRange(int value);\\n  error OutOfBounds(uint index, uint length);\\n  error UnexpectedValue(uint expected, uint actual);\\n  error WrongValue(uint newValue, uint actual);\\n  error IntOutOfRange(int value);\\n  error ZeroValue();\\n  /// @notice packCustomDataChange requires an input string with two zero bytes at the beginning\\n  ///         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// This error happens if these bytes are not zero\\n  error IncompatibleInputString();\\n  error IncorrectOtherItemTypeKind(uint8 kind);\\n  //endregion PackingLib\\n\\n  //region Hero\\n  error ErrorHeroIsNotRegistered(address heroToken);\\n  error ErrorHeroIsDead(address heroToken, uint heroTokenId);\\n  error ErrorHeroNotInDungeon();\\n  error HeroInDungeon();\\n  error ErrorNotOwner(address token, uint tokenId);\\n  error Staked(address heroToken, uint heroId);\\n  error NameTaken();\\n  error TooBigName();\\n  error WrongSymbolsInTheName();\\n  error NoPayToken(address token, uint payTokenAmount);\\n  error AlreadyHaveReinforcement();\\n  /// @notice SIP-001 - Reinforcement requires 3 skills\\n  error ErrorReinforcementRequiresThreeSkills();\\n  error WrongTier(uint tier);\\n  error NotEnoughNgLevel(uint8 ngLevel);\\n  error NgpNotActive(address hero);\\n  error RebornNotAllowed();\\n  error AlreadyPrePaidHero();\\n\\n  error SandboxTierForbidden();\\n  error SandboxPrepaidOnly();\\n  error SandboxNgZeroOnly();\\n  error SandboxModeNotAllowed();\\n  error SandboxUpgradeModeRequired();\\n  error SandboxModeRequired();\\n  error SandboxItemOutside();\\n  error SandboxItemNotActive();\\n  error SandboxItemNotRegistered();\\n  error SandboxItemAlreadyEquipped();\\n  error SandboxDifferentHeroesNotAllowed();\\n  error HeroWasTransferredBetweenAccounts();\\n  //endregion Hero\\n\\n  //region Dungeon\\n  error ErrorDungeonIsFreeAlready();\\n  error ErrorNoEligibleDungeons();\\n  error ErrorDungeonBusy();\\n  error ErrorNoDungeonsForBiome(uint8 heroBiome);\\n  error ErrorDungeonCompleted();\\n  error ErrorAlreadyInDungeon();\\n  error NotEnoughTokens(uint balance, uint expectedBalance);\\n  error DungeonAlreadySpecific(uint16 dungNum);\\n  error DungeonAlreadySpecific2(uint16 dungNum);\\n  error WrongSpecificDungeon();\\n  //endregion Dungeon\\n\\n  //region Items\\n  error ErrorItemNotEligibleForTheSlot(uint itemType, uint8 itemSlot);\\n  error ErrorItemSlotBusyHand(uint8 slot);\\n  error ErrorItemSlotBusy();\\n  error ErrorItemNotInSlot();\\n  error ErrorConsumableItemIsUsed(address item);\\n  error ErrorCannotRemoveItemFromMap();\\n  error ErrorCannotRemoveDataFromMap();\\n  error EquippedItemsExist();\\n  error ItemEquipped(address item, uint itemId);\\n  error ZeroItemMetaType();\\n  error NotZeroOtherItemMetaType();\\n  error ZeroLevel();\\n  error ItemTypeChanged();\\n  error ItemMetaTypeChanged();\\n  error UnknownItem(address item);\\n  error ErrorEquipForbidden();\\n  error EquipForbiddenInDungeon();\\n  error TakeOffForbiddenInDungeon();\\n  error Consumable(address item);\\n  error NotConsumable(address item);\\n  error Broken(address item);\\n  error ZeroLife();\\n  error RequirementsToItemAttributes();\\n  error NotEquipped(address item);\\n  error ZeroDurability();\\n  error ZeroAugmentation();\\n  error TooHighAgLevel(uint8 augmentationLevel);\\n  error UseForbiddenZeroPayToken();\\n  error IncorrectMinMaxAttributeRange(int32 min, int32 max);\\n  error SameIdsNotAllowed();\\n  error ZeroFragility();\\n  error OtherTypeItemNotRepairable();\\n  error NotOther();\\n  error DoubleItemUsageForbidden(uint itemIndex, address[] items);\\n  error ItemAlreadyUsedInSlot(address item, uint8 equippedSlot);\\n  error WrongWayToRegisterItem();\\n  error UnionItemNotFound(address item);\\n  error WrongListUnionItemTokens(address item, uint countTokens, uint requiredCountTokens);\\n  error UnknownUnionConfig(uint unionConfigId);\\n  error UserHasNoKeyPass(address user, address keyPassItem);\\n  error MaxValue(uint value);\\n  error UnexpectedOtherItem(address item);\\n  error NotExist();\\n  error ItemNotFound(address item, uint itemId);\\n  error NoFirstAugmentationInfo();\\n  error NotAugmentationProtectiveItem(address item);\\n  //endregion Items\\n\\n  //region Stages\\n  error ErrorWrongStage(uint stage);\\n  error ErrorNotStages();\\n  //endregion Stages\\n\\n  //region Level\\n  error ErrorWrongLevel(uint heroLevel);\\n  error ErrorLevelTooLow(uint heroLevel);\\n  error ErrorHeroLevelStartFrom1();\\n  error ErrorWrongLevelUpSum();\\n  error ErrorMaxLevel();\\n  //endregion Level\\n\\n  //region Treasure\\n  error ErrorNotValidTreasureToken(address treasureToken);\\n  //endregion Treasure\\n\\n  //region State\\n  error ErrorPaused();\\n  error ErrorNotReady();\\n  error ErrorNotObject1();\\n  error ErrorNotObject2();\\n  error ErrorNotCompleted();\\n  //endregion State\\n\\n  //region Biome\\n  error ErrorNotBiome();\\n  error ErrorIncorrectBiome(uint biome);\\n  error TooHighBiome(uint biome);\\n  //endregion Biome\\n\\n  //region Misc\\n  error ErrorWrongMultiplier(uint multiplier);\\n  error ErrorNotEnoughMana(uint32 mana, uint requiredMana);\\n  error ErrorExperienceMustNotDecrease();\\n  error ErrorNotEnoughExperience();\\n  error ErrorNotChances();\\n  error ErrorNotEligible(address heroToken, uint16 dungNum);\\n  error ErrorZeroKarmaNotAllowed();\\n  //endregion Misc\\n\\n  //region GOC\\n  error GenObjectIdBiomeOverflow(uint8 biome);\\n  error GenObjectIdSubTypeOverflow(uint subType);\\n  error GenObjectIdIdOverflow(uint id);\\n  error UnknownObjectTypeGoc1(uint8 objectType);\\n  error UnknownObjectTypeGoc2(uint8 objectType);\\n  error UnknownObjectTypeGocLib1(uint8 objectType);\\n  error UnknownObjectTypeGocLib2(uint8 objectType);\\n  error UnknownObjectTypeForSubtype(uint8 objectSubType);\\n  error FightDelay();\\n  error ZeroChance();\\n  error TooHighChance(uint32 chance);\\n  error TooHighRandom(uint random);\\n  error EmptyObjects();\\n  error ObjectNotFound();\\n  error WrongGetObjectTypeInput();\\n  error WrongChances(uint32 chances, uint32 maxChances);\\n  //endregion GOC\\n\\n  //region Story\\n  error PageNotRemovedError(uint pageId);\\n  error NotItem1();\\n  error NotItem2();\\n  error NotRandom(uint32 random);\\n  error NotHeroData();\\n  error NotGlobalData();\\n  error ZeroStoryIdRemoveStory();\\n  error ZeroStoryIdStoryAction();\\n  error ZeroStoryIdAction();\\n  error NotEnoughAmount(uint balance, uint requiredAmount);\\n  error NotAnswer();\\n  error AnswerStoryIdMismatch(uint16 storyId, uint16 storyIdFromAnswerHash);\\n  error AnswerPageIdMismatch(uint16 pageId, uint16 pageIdFromAnswerHash);\\n  error NotSkippableStory();\\n  error StoryNotPassed();\\n  error SkippingNotAllowed();\\n  //endregion Story\\n\\n  //region FightLib\\n  error NotMagic();\\n  error NotAType(uint atype);\\n  //endregion FightLib\\n\\n  //region MonsterLib\\n  error NotYourDebuffItem();\\n  error UnknownAttackType(uint attackType);\\n  error NotYourAttackItem();\\n  /// @notice The skill item cannot be used because it doesn't belong either to the hero or to the hero's helper\\n  error NotYourBuffItem();\\n  //endregion MonsterLib\\n\\n  //region GameToken\\n  error ApproveToZeroAddress();\\n  error MintToZeroAddress();\\n  error TransferToZeroAddress();\\n  error TransferAmountExceedsBalance(uint balance, uint value);\\n  error InsufficientAllowance();\\n  error BurnAmountExceedsBalance();\\n  error NotMinter(address sender);\\n  //endregion GameToken\\n\\n  //region NFT\\n  error TokenTransferNotAllowed();\\n  error IdOverflow(uint id);\\n  error NotExistToken(uint tokenId);\\n  error EquippedItemIsNotAllowedToTransfer(uint tokenId);\\n  //endregion NFT\\n\\n  //region CalcLib\\n  error TooLowX(uint x);\\n  //endregion CalcLib\\n\\n  //region Controller\\n  error NotFutureGovernance(address sender);\\n  //endregion Controller\\n\\n  //region Oracle\\n  error OracleWrongInput();\\n  //endregion Oracle\\n\\n  //region ReinforcementController\\n  error AlreadyStaked();\\n  error MaxFee(uint8 fee);\\n  error MinFee(uint8 fee);\\n  error StakeHeroNotStats();\\n  error NotStaked();\\n  error NoStakedHeroes();\\n  error GuildHelperNotAvailable(uint guildId, address helper, uint helperId);\\n  error PvpStaked();\\n  error HelperNotAvailableInGivenBiome();\\n  //endregion ReinforcementController\\n\\n  //region SponsoredHero\\n  error InvalidHeroClass();\\n  error ZeroAmount();\\n  error InvalidProof();\\n  error NoHeroesAvailable();\\n  error AlreadyRegistered();\\n  //endregion SponsoredHero\\n\\n  //region SacraRelay\\n  error SacraRelayNotOwner();\\n  error SacraRelayNotDelegator();\\n  error SacraRelayNotOperator();\\n  error SacraRelayInvalidChainId(uint callChainId, uint blockChainId);\\n  error SacraRelayInvalidNonce(uint callNonce, uint txNonce);\\n  error SacraRelayDeadline();\\n  error SacraRelayDelegationExpired();\\n  error SacraRelayNotAllowed();\\n  error SacraRelayInvalidSignature();\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error by selector, see tests\\n  error SacraRelayNoErrorSelector(bytes4 selector, string tracingInfo);\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error manually from {errorBytes} as following:\\n  /// if (keccak256(abi.encodeWithSignature(\\\"MyError()\\\")) == keccak256(errorBytes)) { ... }\\n  error SacraRelayUnexpectedReturnData(bytes errorBytes, string tracingInfo);\\n  error SacraRelayCallToNotContract(address notContract, string tracingInfo);\\n  //endregion SacraRelay\\n\\n  //region Misc\\n  error UnknownHeroClass(uint heroClass);\\n  error AbsDiff(int32 a, int32 b);\\n  //region Misc\\n\\n  //region ------------------------ UserController\\n  error NoAvailableLootBox(address msgSender, uint lootBoxKind);\\n  error FameHallHeroAlreadyRegistered(uint8 openedNgLevel);\\n\\n  //endregion ------------------------ UserController\\n\\n  //region ------------------------ Guilds\\n  error AlreadyGuildMember();\\n  error NotGuildMember();\\n  error WrongGuild();\\n  error GuildActionForbidden(uint right);\\n  error GuildHasMaxSize(uint guildSize);\\n  error GuildHasMaxLevel(uint level);\\n  error TooLongUrl();\\n  error TooLongDescription();\\n  error CannotRemoveGuildOwnerFromNotEmptyGuild();\\n  error GuildControllerOnly();\\n  error GuildAlreadyHasShelter();\\n  error ShelterIsBusy();\\n  error ShelterIsNotRegistered();\\n  error ShelterIsNotOwnedByTheGuild();\\n  error ShelterIsInUse();\\n  error GuildHasNoShelter();\\n  error ShelterBidIsNotAllowedToBeUsed();\\n  error ShelterHasHeroesInside();\\n  error SecondGuildAdminIsNotAllowed();\\n  error NotEnoughGuildBankBalance(uint guildId);\\n\\n  error GuildReinforcementCooldownPeriod();\\n  error NoStakedGuildHeroes();\\n  error NotStakedInGuild();\\n  error ShelterHasNotEnoughLevelForReinforcement();\\n  error NotBusyGuildHelper();\\n  error TooLowGuildLevel();\\n\\n  /// @notice Target biome can be selected only once per epoch\\n  error BiomeAlreadySelected();\\n  error NoDominationRequest();\\n  error PvpFightIsNotPrepared(uint8 biome, uint32 week, address user);\\n  error PvpFightIsCompleted(uint8 biome, uint32 week, address user);\\n  error TooLowMaxCountTurns();\\n  error UserTokensVaultAlreadySet();\\n\\n  error DifferentBiomeInPvpFight();\\n  error PvpFightOpponentNotFound();\\n  error PvpHeroHasInitializedFight();\\n  error PvpHeroNotRegistered();\\n\\n  /// @notice User should unregister pvp-hero from prev biome and only then register it in the new biome\\n  error UserHasRegisteredPvpHeroInBiome(uint8 biome);\\n  error UserHasRegisteredPvpHero();\\n  error UserNotAllowedForPvpInCurrentEpoch(uint week);\\n\\n  error UnknownPvpStrategy();\\n\\n  error GuildRequestNotActive();\\n  error GuildRequestNotAvailable();\\n  error NotAdminCannotAddMemberWithNotZeroRights();\\n  //endregion ------------------------ Guilds\\n\\n  //region ------------------------ Shelters\\n  error ErrorNotShelterController();\\n  error ErrorNotGuildController();\\n  error ShelterHasNotItem(uint shelterId, address item);\\n  error MaxNumberItemsSoldToday(uint numSoldItems, uint limit);\\n  error GuildHasNotEnoughPvpPoints(uint64 pointsAvailable, uint pointRequired);\\n  error FreeShelterItemsAreNotAllowed(uint shelterId, address item);\\n  error TooLowShelterLevel(uint8 shelterLevel, uint8 allowedShelterLevel);\\n  error NotEnoughPvpPointsCapacity(address user, uint usedPoints, uint pricePvpPoints, uint64 capactiy);\\n  error IncorrectShelterLevel(uint8 shelterLevel);\\n  //endregion ------------------------ Shelters\\n\\n  //region ------------------------ Auction\\n  error WrongAuctionPosition();\\n  error AuctionPositionClosed();\\n  error AuctionBidOpened(uint positionId);\\n  error TooLowAmountToBid();\\n  error AuctionEnded();\\n  error TooLowAmountForNewBid();\\n  error AuctionSellerOnly();\\n  error AuctionBuyerOnly();\\n  error AuctionBidNotFound();\\n  error AuctionBidClosed();\\n  error OnlyShelterAuction();\\n  error CannotCloseLastBid();\\n  error AuctionNotEnded();\\n  error NotShelterAuction();\\n  error AuctionPositionOpened(uint positionId);\\n  error AuctionSellerCannotBid();\\n  error AuctionGuildWithShelterCannotBid();\\n  error AuctionBidExists();\\n  //endregion ------------------------ Auction\\n\\n  //region ------------------------ Pawnshop\\n  error AuctionPositionNotSupported(uint positionId);\\n  error PositionNotSupported(uint positionId);\\n  error NotNftPositionNotSupported(uint positionId);\\n  error CallFailed(bytes callResultData);\\n\\n  error PawnShopZeroOwner();\\n  error PawnShopZeroFeeRecipient();\\n  error PawnShopNotOwner();\\n  error PawnShopAlreadyAnnounced();\\n  error PawnShopTimeLock();\\n  error PawnShopWrongAddressValue();\\n  error PawnShopWrongUintValue();\\n  error PawnShopZeroAddress();\\n  error PawnShopTooHighValue();\\n  error PawnShopZeroAToken();\\n  error PawnShopZeroCToken();\\n  error PawnShopWrongAmounts();\\n  error PawnShopPosFeeForInstantDealForbidden();\\n  error PawnShopPosFeeAbsurdlyHigh();\\n  error PawnShopIncorrect();\\n  error PawnShopWrongId();\\n  error PawnShopNotBorrower();\\n  error PawnShopPositionClosed();\\n  error PawnShopPositionExecuted();\\n  error PawnShopWrongBidAmount();\\n  error PawnShopTooLowBid();\\n  error PawnShopNewBidTooLow();\\n  error PawnShopBidAlreadyExists();\\n  error PawnShopAuctionEnded();\\n  error PawnShopNotLender();\\n  error PawnShopTooEarlyToClaim();\\n  error PawnShopPositionNotExecuted();\\n  error PawnShopAlreadyClaimed();\\n  error PawnShopAuctionNotEnded();\\n  error PawnShopBidClosed();\\n  error PawnShopNoBids();\\n  error PawnShopAuctionBidNotFound();\\n  error PawnShopWrongBid();\\n  error PawnShopBidNotFound();\\n\\n  //endregion ------------------------ Pawnshop\\n}\\n\\n\",\"keccak256\":\"0xffad2dad8ff8fe73014cba8a82fa888a9499e5cde9fde050e1fb34dd2c5979fc\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IApplicationEvents.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IDungeonFactory.sol\\\";\\nimport \\\"./IStoryController.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\nimport \\\"./IPvpController.sol\\\";\\n\\n/// @notice All events of the app\\ninterface IApplicationEvents {\\n\\n  //region ------------------------ Common\\n  event SetOperator(address operator, bool remove);\\n  event Salvage(address receiver, address token, uint amount);\\n  //endregion ------------------------ Common\\n\\n\\n  //region ------------------ StatController\\n  event HeroItemSlotChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint itemType,\\n    uint itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip,\\n    address caller\\n  );\\n  event CurrentStatsChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats change,\\n    bool increase,\\n    address caller\\n  );\\n  event BonusAttributesChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    bool add,\\n    bool temporally,\\n    address caller\\n  );\\n  event TemporallyAttributesCleared(address heroToken, uint heroTokenId, address caller);\\n  event NewHeroInited(address heroToken, uint heroTokenId, IStatController.ChangeableStats stats);\\n  event LevelUp(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes change\\n  );\\n  event ConsumableUsed(address heroToken, uint heroTokenId, address item);\\n  event RemoveConsumableUsage(address heroToken, uint heroTokenId, address item);\\n  event HeroCustomDataChanged(address token, uint tokenId, bytes32 index, uint value);\\n  event HeroCustomDataChangedNg(address token, uint tokenId, bytes32 index, uint value, uint8 ngLevel);\\n  event HeroCustomDataCleared(address token, uint tokenId);\\n  event GlobalCustomDataChanged(bytes32 index, uint value);\\n  //endregion ------------------ StatController\\n\\n  //region ------------------ DungeonFactoryController\\n  event DungeonLaunched(\\n    uint16 dungeonLogicNum,\\n    uint64 dungeonId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken,\\n    uint treasuryAmount\\n  );\\n\\n  event BossCompleted(uint32 objectId, uint biome, address hero, uint heroId);\\n  event FreeDungeonAdded(uint8 biome, uint64 dungeonId);\\n\\n  event ObjectOpened(uint64 dungId, address hero, uint id, uint32 objId, uint iteration, uint currentStage);\\n  event Clear(uint64 dungId);\\n\\n  event DungeonLogicRegistered(uint16 dungLogicId, IDungeonFactory.DungeonGenerateInfo info);\\n  event DungeonLogicRemoved(uint16 dungLogicId);\\n  event DungeonSpecificLogicRegistered(uint16 dungLogicId, uint biome, uint heroCls);\\n  event DungeonSpecificLogicRemoved(uint16 dungLogicId, uint heroLvl, uint heroCls);\\n  event DungeonRegistered(uint16 dungLogicId, uint64 dungeonId);\\n  event DungeonRemoved(uint16 dungLogicId, uint64 dungeonId);\\n  event MinLevelForTreasuryChanged(address token, uint level);\\n\\n  event ObjectAction(\\n    uint64 dungId,\\n    IGOC.ActionResult result,\\n    uint currentStage,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint newStage\\n  );\\n  /// @notice On add the item to the dungeon\\n  event AddTreasuryItem(uint64 dungId, address itemAdr, uint itemId);\\n  event AddTreasuryToken(uint64 dungId, address token, uint amount);\\n  event ClaimToken(uint64 dungId, address token, uint amount);\\n  event ClaimItem(uint64 dungId, address token, uint id);\\n\\n  event Entered(uint64 dungId, address hero, uint id);\\n  event DungeonCompleted(uint16 dungLogicNum, uint64 dungId, address hero, uint heroId);\\n  event Exit(uint64 dungId, bool claim);\\n  event ExitForcibly(uint64 dungId, address hero, uint heroId);\\n  event FreeDungeonRemoved(uint8 biome, uint64 dungeonId);\\n  event HeroCurrentDungeonChanged(address hero, uint heroId, uint64 dungeonId);\\n  //endregion ------------------ DungeonFactoryController\\n\\n  //region ------------------ GameObjectController\\n  event EventRegistered(uint32 objectId, IGOC.EventRegInfo eventRegInfo);\\n  event StoryRegistered(uint32 objectId, uint16 storyId);\\n  event MonsterRegistered(uint32 objectId, IGOC.MonsterGenInfo monsterGenInfo);\\n  event ObjectRemoved(uint32 objectId);\\n  event ObjectResultEvent(\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    IGOC.ObjectType objectType,\\n    address hero,\\n    uint heroId,\\n    uint8 stageId,\\n    uint iteration,\\n    bytes data,\\n    IGOC.ActionResult result,\\n    uint salt\\n  );\\n  //endregion ------------------ GameObjectController\\n\\n  //region ------------------ StoryController\\n  event SetBurnItemsMeta(uint storyId, IStoryController.AnswerBurnRandomItemMeta meta);\\n  event SetNextObjRewriteMeta(uint storyId, IStoryController.NextObjRewriteMeta meta);\\n  event SetAnswersMeta(uint storyId, uint16[] answerPageIds, uint8[] answerHeroClasses, uint16[] answerIds);\\n  event SetAnswerNextPageMeta(uint storyId, IStoryController.AnswerNextPageMeta meta);\\n  event SetAnswerAttributeRequirements(uint storyId, IStoryController.AnswerAttributeRequirementsMeta meta);\\n  event SetAnswerItemRequirements(uint storyId, IStoryController.AnswerItemRequirementsMeta meta);\\n  event SetAnswerTokenRequirementsMeta(uint storyId, IStoryController.AnswerTokenRequirementsMeta meta);\\n  event SetAnswerAttributes(uint storyId, IStoryController.AnswerAttributesMeta meta);\\n  event SetAnswerHeroCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetAnswerGlobalCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetSuccessInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetFailInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetCustomDataResult(uint storyId, IStoryController.AnswerCustomDataResultMeta meta, IStoryController.CustomDataResult _type);\\n  event StoryCustomDataRequirements(uint storyId, bytes32 requiredCustomDataIndex, uint requiredCustomDataMinValue, uint requiredCustomDataMaxValue, bool requiredCustomDataIsHero);\\n  event StoryRequiredLevel(uint storyId, uint requiredLevel);\\n  event StoryFinalized(uint32 objectId, uint storyId);\\n  event StoryRemoved(uint32 objectId, uint storyId);\\n\\n  event ItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  /// @notice Durability of the item was reduced to 0\\n  event ItemBroken(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n\\n  event NotEquippedItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event StoryChangeAttributes(\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    uint stageId,\\n    uint iteration,\\n    int32[] attributes\\n  );\\n  //endregion ------------------ StoryController\\n\\n  //region ------------------------ HeroController\\n  event HeroRegistered(address hero, uint8 heroClass, address payToken, uint payAmount);\\n  /// @notice Deprecated, replaced by {HeroCreatedNgpSandbox}. Don't remove - it's required by subgraph\\n  event HeroCreatedNgp(address hero, uint heroId, string name, address owner, string refCode, uint8 tier, uint8 ngLevel);\\n  event HeroCreatedNgpSandbox(address hero, uint heroId, string name, address owner, string refCode, uint8 tier, uint8 ngLevel, bool sandbox);\\n  event BiomeChanged(address hero, uint heroId, uint8 biome);\\n  event LevelUp(address hero, uint heroId, address owner, IStatController.CoreAttributes change);\\n  event ReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event GuildReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event OtherItemGuildReinforcement(address item, uint itemId, address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event ReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event GuildReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event Killed(address hero, uint heroId, address killer, bytes32[] dropItems, uint dropTokenAmount);\\n  event Reborn(address hero, uint heroId, uint8 newNgLevel);\\n  event BossKilled(address account, address hero, uint heroId, uint8 biome, uint8 newNgLevel, bool reborn, uint rewardAmount);\\n  event TierSetup(uint8 tier, address hero, uint72 payAmount, uint8[] slots, address[][] items);\\n  event SandboxUpgraded(address hero, uint heroId);\\n  event SandboxReturnAmountToTreasury(uint64 dungId, address token, uint amount);\\n  //endregion ------------------------ HeroController\\n\\n  //region ------------------------ FightLib\\n  event FightResultProcessed(\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    IFightCalculator.FightCall callData,\\n    uint iteration\\n  );\\n  /// @param heroA Address of the fighter A.  Address of the fighter B can be detected by fightId\\n  /// @param heroIdA ID of the figher A. ID of the fighter B can be detected by fightId\\n  event PvpFightResultProcessed(\\n    uint48 fightId,\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    uint turn,\\n    address heroA,\\n    uint heroIdA\\n  );\\n  //endregion ------------------------ FightLib\\n\\n  //region ------------------------ Oracle\\n  event Random(uint number, uint max);\\n  //endregion ------------------------ Oracle\\n\\n  //region ------------------------ Controller\\n  event OfferGovernance(address newGov);\\n  event GovernanceAccepted(address gov);\\n  event StatControllerChanged(address value);\\n  event StoryControllerChanged(address value);\\n  event GameObjectControllerChanged(address value);\\n  event ReinforcementControllerChanged(address value);\\n  event OracleChanged(address value);\\n  event TreasuryChanged(address value);\\n  event ItemControllerChanged(address value);\\n  event HeroControllerChanged(address value);\\n  event GameTokenChanged(address value);\\n  event DungeonFactoryChanged(address value);\\n  event ProxyUpdated(address proxy, address logic);\\n  event Claimed(address token, uint amount);\\n  event TokenStatusChanged(address token, bool status);\\n  event UserControllerChanged(address value);\\n  event GuildControllerChanged(address value);\\n\\n  event PvpControllerChanged(address value);\\n\\n  event GameTokenPriceChanged(uint value);\\n  event RewardsPoolChanged(address value);\\n  event ItemBoxControllerChanged(address value);\\n  event Process(address token, uint amount, address from, uint toBurn, uint toTreasury, uint toGov);\\n  //endregion ------------------------ Controller\\n\\n\\n  //region ------------------------ ReinforcementController\\n  event HeroStaked(address heroToken, uint heroId, uint biome, uint score);\\n  event HeroStakedV2(address heroToken, uint heroId, uint biome, uint rewardAmount);\\n  event HeroWithdraw(address heroToken, uint heroId);\\n  event HeroAsk(address heroToken, uint heroId);\\n  event HeroAskV2(address heroToken, uint heroId, uint hitsLast24h, uint fixedFee, uint helperRewardAmount);\\n  event TokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint totalAmount);\\n  event GuildTokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint guildId);\\n  event NftRewardRegistered(address heroToken, uint heroId, address token, uint id);\\n  event GuildNftRewardRegistered(address heroToken, uint heroId, address token, uint id, uint guildId);\\n  event ToHelperRatioChanged(uint value);\\n  event ClaimedToken(address heroToken, uint heroId, address token, uint amount, address recipient);\\n  event ClaimedItem(address heroToken, uint heroId, address item, uint itemId, address recipient);\\n  event MinLevelChanged(uint8 value);\\n  event MinLifeChancesChanged(uint value);\\n  //endregion ------------------------ ReinforcementController\\n\\n  //region ------------------------ Treasury, reward pool\\n  event AssetsSentToDungeon(address dungeon, address token, uint amount);\\n  event RewardSentToUser(address receiver, address token, uint rewardAmount);\\n  event NotEnoughReward(address receiver, address token, uint rewardAmountToPay);\\n  event BaseAmountChanged(uint oldValue, uint newValue);\\n  //endregion ------------------------ Treasury, reward pool\\n\\n  //region ------------------------ EventLib\\n  event EventResult(uint64 dungeonId, address heroToken, uint heroTokenId, uint8 stageId, IStatController.ActionInternalInfo gen, uint iteration);\\n  //endregion ------------------------ EventLib\\n\\n  //region ------------------------ Item controller and helper contracts\\n  event ItemRegistered(address item, IItemController.RegisterItemParams info);\\n  event OtherItemRegistered(address item, IItemController.ItemMeta meta, bytes packedItemMetaData);\\n  event ItemRemoved(address item);\\n  event OtherItemRemoved(address item);\\n  event NewItemMinted(address item, uint itemId, IItemController.MintInfo info);\\n  event Equipped(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot);\\n  event TakenOff(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot, address destination);\\n  event ItemRepaired(address item, uint itemId, uint consumedItemId, uint16 baseDurability);\\n  event FailedToRepairItem(address item, uint itemId, uint consumedItemId, uint16 itemDurability);\\n  event Augmented(address item, uint itemId, uint consumedItemId, uint8 augLevel, IItemController.AugmentInfo info);\\n  event ResetAugmentation(address item, uint itemId, uint consumedItemId, IItemController.AugmentInfo info);\\n  event NotAugmented(address item, uint itemId, uint consumedItemId, uint8 augLevel);\\n  event ReduceDurability(address item, uint itemId, uint newDurability);\\n  event Used(address item, uint tokenId, address heroToken, uint heroTokenId);\\n  event Destroyed(address item, uint itemId);\\n  event FragilityReduced(address item, uint itemId, address consumedItem, uint consumedItemId, uint fragility);\\n  event ItemControllerHelper(address helper);\\n  event SetUnionConfig(uint configId, address[] items, uint[] count, address itemToMint);\\n  event RemoveUnionConfig(uint configId);\\n  event SetUnionKeyPass(address keyPassItem);\\n  event SetAugmentationProtectiveItem(address keyPassItem);\\n  event CombineItems(address msgSender, uint configId, address[] items, uint[][] itemIds, address mintedItem, uint mintedItemId);\\n  event RegisterSandboxItem(address hero, uint heroId, address item, uint itemId, uint tsMinting);\\n  event WithdrawItemsFromSandbox(address hero, uint heroId, address[] items, uint[] itemIds);\\n  event ItemReturnedToSandbox(address hero, uint heroId, address item, uint itemId);\\n  event RegisterSandboxUpgrade(address hero, uint heroId, uint tsUpgradng);\\n  event TransferItemToHeroFromSandbox(address hero, uint heroId, address item, uint itemId);\\n  event DestroyItemInSandbox(address item, uint itemId);\\n  event NewItemSentToSandbox(address item, uint itemId);\\n  event ExitFromDungeon(address hero, uint heroId);\\n  //endregion ------------------------ Item controller and helper contracts\\n\\n  //region ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n  event ChangePauseStatus(bool value);\\n  event MinterChanged(address value);\\n\\n  event UniqueUriChanged(uint id, string uri);\\n  event BaseUriChanged(string uri);\\n\\n  event HeroMinted(uint heroId);\\n  event HeroBurned(uint heroId);\\n  event HeroUriByStatusChanged(string uri, uint statusLvl);\\n\\n  event ItemMinted(uint tokenId);\\n  event ItemBurned(uint tokenId);\\n  event UriByRarityChanged(string uri, uint rarity);\\n  event SponsoredHeroCreated(address msgSender, address heroAddress, uint heroId, string heroName);\\n  //endregion ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n\\n  //region ------------------------ User controller\\n  event SetUserName(address user, string name);\\n  event SetUserAvatar(address user, string avatar);\\n  event LootBoxOpened(address user, uint lootBoxKind, address[] itemTokens, uint[] itemTokenIds);\\n  event LootBoxConfigChanged(uint lootBoxKind, address[] mintItems, uint32[] mintItemsChances, uint maxDropItems);\\n  event SetFeeRenaming(uint feeRenaming);\\n\\n  event ActivityCompleted(address user, bool daily, bool weekly);\\n  event RegisterPassedDungeon(address user, uint32 epochWeek, uint counterPassedDungeons);\\n  event RegisterPvp(address user, uint32 epochWeek, uint counterPvp);\\n  event FameHallHeroRegistered(address hero, uint heroId, address heroOwner, uint8 openedNgLevel);\\n  event SetMinHeroLevel(uint level);\\n  event SetGuildStakingAdapter(address adapter);\\n\\n  event AddGamePoints(address user, uint finalBalanceGamePoints);\\n  /// @param paramId See IUserController.UserControllerParam\\n  event SetUserControllerParam(uint8 paramId, uint paramValue);\\n  event UseGamePointsToSkipStory(address user, uint16 storyId, uint priceInGamePoints, uint finalBalanceGamePoints);\\n  event SetStoryPassed(address user, uint16 storyId);\\n  //endregion ------------------------ User controller\\n\\n  //region ------------------------ Guild\\n\\n  event GuildCreated(address owner, uint guildId, string name, string urlLogo);\\n  event AddToGuild(uint guildId, address newUser);\\n  event ChangeGuildRights(uint guildId, address user, uint rights);\\n  event RemoveFromGuild(uint guildId, address user);\\n  event GuildDeleted(uint guildId);\\n  event GuildLevelUp(uint guildId, uint8 newLevel);\\n  event GuildRename(uint guildId, string newName);\\n  event GuildLogoChanged(uint guildId, string newLogoUrl);\\n  event GuildDescriptionChanged(uint guildId, string newDescription);\\n  event SetGuildRelation(uint guildId1, uint guildId2, bool peace);\\n  event TransferFromGuildBank(address user, address token, uint amount, address recipient);\\n  event TransferNftFromGuildBank(address user, address[] nfts, uint[] tokenIds, address recipient);\\n  event GuildBankDeployed(uint guildId, address guildBank);\\n  event TransferOwnership(address prevOwner, address newOwner);\\n\\n  event SetToHelperRatio(uint guildId, uint8 value, address user);\\n  event TopUpGuildBank(address msgSender, uint guildId, address guildBank, uint amount);\\n\\n  event GuildRequestRegistered(address msgSender, uint guildId, string userMessage, uint depositAmount);\\n  event GuildRequestStatusChanged(address msgSender, uint guildRequestId, uint8 newStatus, address user);\\n  event SetToHelperRatio(uint guildId, address msgSender, uint8 toHelperRatio);\\n  event SetGuildRequestDepositAmount(uint guildId, address msgSender, uint amount);\\n  event SetGuildBaseFee(uint fee);\\n  event SetPvpPointsCapacity(address msgSender, uint64 capacityPvpPoints, address[] users);\\n  event SetShelterController(address shelterController);\\n  event SetShelterAuction(address shelterAuction);\\n  event PayForBidFromGuildBank(uint guildId, uint amount, uint bid);\\n  //endregion ------------------------ Guild\\n\\n  //region ------------------------ Guild shelter\\n  event RegisterShelter(uint sheleterId, uint price);\\n  event SetShelterItems(\\n    uint shelterId,\\n    address[] items,\\n    uint64[] pricesInPvpPoints,\\n    uint128[] pricesInGameTokens,\\n    uint16[] maxItemsPerDayThresholds\\n  );\\n  event RemoveShelterItems(uint shelterId, address[] items);\\n  event BuyShelter(uint guidlId, uint shelterId);\\n  event LeaveShelter(uint guildId, uint shelterId);\\n  event NewShelterBid(uint shelterId, uint buyerGuildId, uint amount);\\n  event RevokeShelterBid(uint shelterId);\\n  event UseShelterBid(uint shelterId, uint sellerGuildId, uint buyerGuidId, uint amount);\\n  event PurchaseShelterItem(address msgSender, address item, uint numSoldItems, uint priceInPvpPoints, uint priceInGameToken);\\n  event ChangeShelterOwner(uint shelterId, uint fromGuildId, uint toGuildId);\\n  event RestInShelter(address msgSender, address heroToken, uint heroTokenId);\\n  //endregion ------------------------ Guild shelter\\n\\n  //region ------------------------ Guild reinforcement\\n  event GuildHeroStaked(address heroToken, uint heroId, uint guildId);\\n  event GuildHeroWithdrawn(address heroToken, uint heroId, uint guildId);\\n  event GuildHeroAsked(address heroToken, uint heroId, uint guildId, address user);\\n\\n  /// @param user Address can be 0 if heroId was already burnt at the moment of reinforcement releasing\\n  event GuildHeroReleased(address heroToken, uint heroId, uint guildId, address user);\\n  //endregion ------------------------ Guild reinforcement\\n\\n  //region ------------------------ Pvp\\n  event AddBiomeRequest(address user, uint8 biome, uint guildId, uint32 week);\\n  event PvpHeroAdded(address user, uint guildId, address hero, uint heroId, uint week, uint8 biome);\\n  /// @param manuallyRemoved True - removed manually by the user, false - removed automatically after the fight\\n  event PvpHeroRemoved(address user, uint guildId, uint week, uint8 biome, address hero, uint heroId, bool manuallyRemoved);\\n  event PreparePvpFight(uint48 fightId, uint32 week, address hero, uint heroId, uint heroGuildId, address opponentHero, uint opponentHeroId, uint opponentGuildId);\\n\\n  /// @notice heroId can be detected by {fightId} and {heroes}\\n  event PvpFightCompleted(\\n    IPvpController.PvpFightResults fightResult,\\n    uint48 fightId,\\n    address[2] heroes,\\n    uint64[2] guilds,\\n    bool[2] winners,\\n    uint[2] prizes,\\n    bool technicalDefeat\\n  );\\n  event UpdatePvpEpoch(uint8 biome, uint32 week, uint guildBiomeOwnerId);\\n  event FirstPvpEpoch(uint8 biome, uint32 week);\\n  event BiomeTaxPaid(address msgSender, uint8 biome, uint guildId, uint amount, uint taxPercent, uint taxAmount);\\n  event BiomeTaxPaidNft(address msgSender, uint8 biome, uint guildId, address item, uint itemId, uint taxPercent);\\n  event AddPvpFightItems(uint48 fightId, address[] items, uint[] itemIds);\\n\\n  //endregion ------------------------ Pvp\\n\\n  //region ------------------------ Guild auction\\n  event AuctionPositionOpened(uint positionId, uint shelterId, uint sellerGuildId, address msgSender, uint minAuctionPrice);\\n  event AuctionPositionClosed(uint positionId, address msgSender);\\n  event AuctionBidOpened(uint bidId, uint positionId, uint amount, address msgSender);\\n  event ApplyAuctionBid(uint bidId, address msgSender);\\n  event AuctionSetFee(uint fee);\\n  //endregion ------------------------ Guild auction\\n\\n  //region ------------------------ Guild bank\\n  event GuildBankTransfer(address token, address recipient, uint amount);\\n  event GuildBankTransferNft(address to, address nft, uint tokenId);\\n  event GuildBankTransferNftMulti(address to, address[] nfts, uint[] tokenIds);\\n  //endregion ------------------------ Guild bank\\n\\n  //region ------------------------ Pawnshop\\n  event PawnShopRouterDeployed(address pawnShop, address gameToken, address routerOwner, address deployed);\\n  event PawnShopRouterTransfer(address token, uint amount, address receiver);\\n  event PawnShopRouterBulkSell(address[] nfts, uint[] nftIds, uint[] prices, address nftOwner, uint[] positionIds);\\n  event PawnShopRouterClosePositions(uint[] positionIds, address receiver);\\n  event PawnShopRouterBulkBuy(uint[] positionIds, address receiver);\\n\\n  //endregion ------------------------ Pawnshop\\n\\n  //region ------------------------ Airdrop Distributor\\n  event AirdropDistributorSetToken(address token);\\n  event AirdropDistributorAddTree(uint week, bytes32 merkleRoot_);\\n  event AirdropDistributorRemoveTree(uint week);\\n  event AirdropDistributorClaim(uint[] _weeks, uint[] amounts, address receiver);\\n\\n  //endregion ------------------------ Airdrop Distributor\\n\\n  //region ------------------------ GuildStakingManager\\n  event SetStakingToken(address token);\\n  event StakeTokens(address token, uint amount, uint guildId, uint total);\\n  //endregion ------------------------ GuildStakingManager\\n\\n}\\n\",\"keccak256\":\"0x92745e450978c77b380a0625458dda3edd8aa29d2efbadd8327e93707ff0f08b\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IControllable {\\n\\n  function VERSION() external pure returns (string memory);\\n\\n  function revision() external view returns (uint);\\n\\n  function previousImplementation() external view returns (address);\\n\\n  function isController(address contract_) external view returns (bool);\\n\\n  function isGovernance(address contract_) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0x296b634c46b5d178b2408523fcf569ed370e20a719b7b3f2183b278631b94f65\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IController {\\n\\n  function governance() external view returns (address);\\n\\n  function statController() external view returns (address);\\n\\n  function storyController() external view returns (address);\\n\\n  function gameObjectController() external view returns (address);\\n\\n  function reinforcementController() external view returns (address);\\n\\n  function oracle() external view returns (address);\\n\\n  function treasury() external view returns (address);\\n\\n  function itemController() external view returns (address);\\n\\n  function heroController() external view returns (address);\\n\\n  function dungeonFactory() external view returns (address);\\n\\n  function gameToken() external view returns (address);\\n\\n  function validTreasuryTokens(address token) external view returns (bool);\\n\\n  function isDeployer(address adr) external view returns (bool);\\n\\n  function onPause() external view returns (bool);\\n\\n  function userController() external view returns (address);\\n\\n  function guildController() external view returns (address);\\n\\n  function pvpController() external view returns (address);\\n\\n  function rewardsPool() external view returns (address);\\n\\n  function itemBoxController() external view returns (address);\\n\\n  function gameTokenPrice() external view returns (uint);\\n\\n  function process(address token, uint amount, address from) external;\\n}\\n\",\"keccak256\":\"0x47f787dc04215fffcfce23bc8ed7e777decd7eb29d60f42ffe72fd09a928c4e3\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDungeonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IDungeonFactory {\\n\\n  /// @custom:storage-location erc7201:dungeon.factory.main\\n  struct MainState {\\n    /// @dev biome => dungeonLaunchedId\\n    mapping(uint => EnumerableSet.UintSet) freeDungeons;\\n    /// @dev hero + heroId + biome (packMapObject) -> completed\\n    mapping(bytes32 => bool) bossCompleted;\\n    /// @dev hero + heroId + dungNum (packDungeonKey) -> completed\\n    mapping(bytes32 => bool) specificDungeonCompleted;\\n    /// @notice Max biome completed by the hero\\n    /// @dev hero + heroId (nftPacked) -> max biome completed\\n    mapping(bytes32 => uint8) maxBiomeCompleted;\\n    /// @notice which dungeon the hero is currently in\\n    /// @dev hero+id => current DungeonId\\n    mapping(bytes32 => uint64) heroCurrentDungeon;\\n\\n    // ---\\n\\n    /// @notice Specific dungeon for the given pair of hero level + hero class\\n    ///         ALl specific dungeons are listed also in allSpecificDungeons\\n    /// @dev packUint8Array(specReqBiome, specReqHeroClass) => dungNum\\n    mapping(bytes32 => uint16) dungeonSpecific;\\n    /// @dev contains all specific dungNum for easy management\\n    EnumerableSet.UintSet allSpecificDungeons;\\n    /// @dev biome => dungNum\\n    mapping(uint8 => EnumerableSet.UintSet) dungeonsLogicByBiome;\\n\\n    // ---\\n\\n    /// @dev max available biome. auto-increment with new dung deploy\\n    uint8 maxBiome;\\n\\n    /// @notice Address of treasure token => min hero level required\\n    /// @dev manual threshold for treasury\\n    mapping(address => uint) minLevelForTreasury;\\n\\n    /// @notice Contains arrays for SKILL_1, SKILL_2, SKILL_3 with 0 or 1\\n    /// i.e. [0, 1, 0] means that durability of SKILL_2 should be reduced\\n    /// @dev hero + heroId => uint8[] array where idx = slotNum\\n    mapping(bytes32 => bytes32) skillSlotsForDurabilityReduction;\\n\\n    /// @notice Counter of dungeons, it's incremented on launch of a new dungeon\\n    uint64 dungeonCounter;\\n\\n    /// @dev dungNum = init attributes\\n    mapping(uint16 => DungeonAttributes) dungeonAttributes;\\n    /// @dev dungeonId => status\\n    mapping(uint64 => DungeonStatus) dungeonStatuses;\\n\\n    /// @notice NG_LEVEL of the hero that has created the given dungeon\\n    mapping(uint64 dungeonId => uint ngLevel) dungeonNgLevel;\\n  }\\n\\n  struct ObjectGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    /// @dev uint8 types, packed using PackingLib.packUint8Array\\n    bytes32[] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    /// @dev uint64 chances\\n    uint32[][] objChancesByStages;\\n  }\\n\\n  struct DungeonGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    uint8[][] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    uint32[][] objChancesByStages;\\n\\n    uint32[] uniqObjects;\\n\\n    uint8 minLevel;\\n    uint8 maxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n  }\\n\\n  /// @notice Attributes of the given dungeon logic\\n  struct DungeonAttributes {\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    uint8 stages;\\n    uint8 biome;\\n\\n    /// @notice Default list of objects that should be passed in the dungeon\\n    uint32[] uniqObjects;\\n\\n    /// @dev min+max (packUint8Array)\\n    bytes32 minMaxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    /// @notice Packed DungeonGenerateInfo.requiredCustomData: MinValue, MaxValue, IsHero\\n    /// @dev min+max+isHero(packStoryCustomDataRequirements)\\n    bytes32[] requiredCustomDataValue;\\n\\n    ObjectGenerateInfo info;\\n  }\\n\\n  /// @notice Current status of the given dungeon\\n  struct DungeonStatus {\\n    uint64 dungeonId;\\n    /// @notice Dungeon logic id\\n    uint16 dungNum;\\n\\n    /// @notice True if the dungeon is completed by the hero\\n    bool isCompleted;\\n\\n    /// @notice Hero in the dungeon or 0\\n    address heroToken;\\n    uint heroTokenId;\\n    /// @notice Current object that should be passed by the hero. 0 - new object is not opened\\n    uint32 currentObject;\\n    /// @notice Current stage in the dungeon that should be passed by the hero.\\n    uint8 currentStage;\\n\\n    EnumerableMap.AddressToUintMap treasuryTokens;\\n    /// @notice All items that were minted on result of made actions\\n    bytes32[] treasuryItems;\\n\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    /// This value can be bigger than length of uniqObjects\\n    uint8 stages;\\n    /// @notice List of objects to be passed in the stage. The list can be dynamically changed during passing the stages\\n    uint32[] uniqObjects;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n\\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external returns (uint64 dungeonId);\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8);\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64);\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result);\\n\\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external;\\n\\n  /// @notice Hero exists current dungeon forcibly same as when dying but without loosing life chance\\n  function exitForcibly(address heroToken, uint heroTokenId, address msgSender) external;\\n\\n  function maxAvailableBiome() external view returns (uint8);\\n\\n  function reborn(address hero, uint heroId) external;\\n}\\n\",\"keccak256\":\"0x4e3a2e8f2fc6a0a59c3639e1548919e3a4f5b06295fcb8b4556df4f033e8ae87\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbca9de297214bb9c30daefda5ecaedd0af2c3e8e0440403ad543fb33528c5ef8\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xa365c0e17de806f6262765ef6236512674ac8563a6ee3436e81cec7b1d87468e\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  /**\\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n   */\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n   */\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of tokens in ``owner``'s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\n   *\\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n   * The approval is cleared when the token is transferred.\\n   *\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n   *\\n   * Requirements:\\n   *\\n   * - The caller must own the token or be an approved operator.\\n   * - `tokenId` must exist.\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address to, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Returns the account approved for `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  /**\\n   * @dev Approve or remove `operator` as an operator for the caller.\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n   *\\n   * Requirements:\\n   *\\n   * - The `operator` cannot be the caller.\\n   *\\n   * Emits an {ApprovalForAll} event.\\n   */\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  /**\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n   *\\n   * See {setApprovalForAll}\\n   */\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0xe7d89e4cdfc41317d90bf469428b6ef17cec6eb6fccab0080bdf0378129d2708\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n  /**\\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n   * by `operator` from `from`, this function is called.\\n   *\\n   * It must return its Solidity selector to confirm the token transfer.\\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n   *\\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n   */\\n  function onERC721Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xe5e9287463463820051374de194e01b41e1b77c1df73fab6ea0409b485edf33d\",\"license\":\"MIT\"},\"contracts/interfaces/IFightCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface IFightCalculator {\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    MELEE, // 1\\n    MAGIC, // 2\\n    SLOT_3,\\n    SLOT_4,\\n    SLOT_5,\\n    SLOT_6,\\n    SLOT_7,\\n    SLOT_8,\\n    SLOT_9,\\n    SLOT_10\\n  }\\n\\n  /// @notice Attacker info: suitable both for hero and monsters\\n  struct AttackInfo {\\n    /// @notice Type of the attack\\n    /// by default, if attack token presents, it's magic attack and not-magic otherwise\\n    /// but this logic can become more complicated after introducing new attack types\\n    AttackType attackType;\\n    /// @notice NFT selected by hero for attack, it should be equip on.\\n    /// If attacker is a monster, this is a special case (stub NFT with zero ID is used)\\n    address attackToken;\\n    uint attackTokenId;\\n    address[] skillTokens;\\n    uint[] skillTokenIds;\\n  }\\n\\n  struct FighterInfo {\\n    int32[] fighterAttributes;\\n    IStatController.ChangeableStats fighterStats;\\n    AttackType attackType;\\n    address attackToken;\\n    uint attackTokenId;\\n    uint race;\\n  }\\n\\n  struct Statuses {\\n    bool stun;\\n    bool burn;\\n    bool freeze;\\n    bool confuse;\\n    bool curse;\\n    bool poison;\\n    bool gotCriticalHit;\\n    bool missed;\\n    bool hitBlocked;\\n  }\\n\\n  struct FightResult {\\n    int32 healthA;\\n    int32 healthB;\\n    int32 manaConsumedA;\\n    int32 manaConsumedB;\\n  }\\n\\n  struct FightCall {\\n    FighterInfo fighterA;\\n    FighterInfo fighterB;\\n    uint64 dungeonId;\\n    uint32 objectId;\\n    address heroAdr;\\n    uint heroId;\\n    uint8 stageId;\\n    uint iteration;\\n    uint8 turn;\\n  }\\n\\n  /// @notice Additional info passed to fight\\n  struct FightCallAdd {\\n    address msgSender;\\n\\n    /// @notice Unique ID of the pvp-fight, 0 for not pvp fights\\n    uint48 fightId;\\n  }\\n\\n  struct SkillSlots {\\n    bool slot1;\\n    bool slot2;\\n    bool slot3;\\n  }\\n\\n  //region ------------------------ FightLib-internal (FightInfoInternal is required by IApplicationEvents..)\\n  struct FightInfoInternal {\\n    Fighter fighterA;\\n    Fighter fighterB;\\n  }\\n\\n  struct Fighter {\\n    IFightCalculator.FighterInfo info;\\n    IItemController.AttackInfo magicAttack;\\n    int32 health;\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 damagePoison;\\n    int32 damageReflect;\\n    IFightCalculator.Statuses statuses;\\n  }\\n  //endregion ------------------------ FightLib-internal\\n\\n  function fight(FightCall memory callData) external returns (FightResult memory);\\n}\\n\",\"keccak256\":\"0xc985eb5db749909d4a80ba77a85e105245d8edee11f1c9532b69dc38dcc53c38\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGOC.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\n\\ninterface IGOC {\\n\\n  enum ObjectType {\\n    UNKNOWN, // 0\\n    EVENT, // 1\\n    MONSTER, // 2\\n    STORY, // 3\\n    END_SLOT\\n  }\\n\\n  enum ObjectSubType {\\n    UNKNOWN_0, // 0\\n    ENEMY_NPC_1, // 1\\n    ENEMY_NPC_SUPER_RARE_2, // 2\\n    BOSS_3, // 3\\n    SHRINE_4, // 4\\n    CHEST_5, // 5\\n    STORY_6, // 6\\n    STORY_UNIQUE_7, // 7\\n    SHRINE_UNIQUE_8, // 8\\n    CHEST_UNIQUE_9, // 9\\n    ENEMY_NPC_UNIQUE_10, // 10\\n    STORY_ON_ROAD_11, // 11\\n    STORY_UNDERGROUND_12, // 12\\n    STORY_NIGHT_CAMP_13, // 13\\n    STORY_MOUNTAIN_14, // 14\\n    STORY_WATER_15, // 15\\n    STORY_CASTLE_16, // 16\\n    STORY_HELL_17, // 17\\n    STORY_SPACE_18, // 18\\n    STORY_WOOD_19, // 19\\n    STORY_CATACOMBS_20, // 20\\n    STORY_BAD_HOUSE_21, // 21\\n    STORY_GOOD_TOWN_22, // 22\\n    STORY_BAD_TOWN_23, // 23\\n    STORY_BANDIT_CAMP_24, // 24\\n    STORY_BEAST_LAIR_25, // 25\\n    STORY_PRISON_26, // 26\\n    STORY_SWAMP_27, // 27\\n    STORY_INSIDE_28, // 28\\n    STORY_OUTSIDE_29, // 29\\n    STORY_INSIDE_RARE_30,\\n    STORY_OUTSIDE_RARE_31,\\n    ENEMY_NPC_INSIDE_32,\\n    ENEMY_NPC_INSIDE_RARE_33,\\n    ENEMY_NPC_OUTSIDE_34,\\n    ENEMY_NPC_OUTSIDE_RARE_35,\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:game.object.controller.main\\n  struct MainState {\\n\\n    /// @dev objId = biome(00) type(00) id(0000) => biome(uint8) + objType(uint8)\\n    /// Id is id of the event, story or monster.\\n    mapping(uint32 => bytes32) objectMeta;\\n\\n    /// @dev biome(uint8) + objType(uint8) => set of object id\\n    mapping(bytes32 => EnumerableSet.UintSet) objectIds;\\n\\n    /// @dev heroAdr180 + heroId64 + cType8 + biome8 => set of already played objects. Should be cleared periodically\\n    mapping(bytes32 => EnumerableSet.UintSet) playedObjects;\\n\\n    /// @dev HeroAdr(160) + heroId(uint64) + objId(uint32) => iteration count. It needs for properly emit events for every new entrance.\\n    mapping(bytes32 => uint) iterations;\\n\\n    /// @dev objId(uint32) => EventInfo\\n    mapping(uint32 => EventInfo) eventInfos;\\n\\n    /// @dev objId(uint32) => storyId\\n    mapping(uint32 => uint16) storyIds;\\n\\n    /// @dev objId(uint32) => MonsterInfo\\n    mapping(uint32 => MonsterInfo) monsterInfos;\\n\\n    /// @dev hero+id => last fight action timestamp\\n    mapping(bytes32 => uint) lastHeroFightTs;\\n\\n    /// @dev delay for user actions in fight (suppose to prevent bot actions)\\n    uint fightDelay;\\n  }\\n\\n  struct ActionResult {\\n    bool kill;\\n    bool completed;\\n    address heroToken;\\n    address[] mintItems;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n    uint32 objectId;\\n    uint32 experience;\\n    uint heroTokenId;\\n    uint iteration;\\n    uint32[] rewriteNextObject;\\n  }\\n\\n  struct EventInfo {\\n    /// @dev chance to use good or bad attributes/stats\\n    uint32 goodChance;\\n\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] goodAttributes;\\n    bytes32[] badAttributes;\\n\\n    /// @dev experience(uint32) + heal(int32) + manaRegen(int32) + lifeChancesRecovered(int32) + damage(int32) + manaConsume(int32) packStatsChange\\n    bytes32 statsChange;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n  }\\n\\n  struct MonsterInfo {\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] attributes;\\n    /// @dev level(uint8) + race(uint8) + experience(uint32) + maxDropItems(uint8) packMonsterStats\\n    bytes32 stats;\\n    /// @dev attackToken(160) + attackTokenId(uint64) + attackType(uint8) packAttackInfo\\n    bytes32 attackInfo;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n\\n    /// @dev heroAdr(160) + heroId(uint64) => iteration => GeneratedMonster packed\\n    mapping(bytes32 => mapping(uint => bytes32)) _generatedMonsters;\\n  }\\n\\n  struct MultiplierInfo {\\n    uint8 biome;\\n    /// @notice NG_LEVEL of the hero who is going to fight with the given monster\\n    /// Use type(uint8).max for !NG+\\n    uint8 heroNgLevel;\\n  }\\n\\n  struct GeneratedMonster {\\n    bool generated;\\n    uint8 turnCounter;\\n    int32 hp;\\n    uint32 amplifier;\\n  }\\n\\n  struct MonsterGenInfo {\\n    uint16 monsterId;\\n    uint8 biome;\\n    ObjectSubType subType;\\n\\n    uint8[] attributeIds;\\n    int32[] attributeValues;\\n\\n    uint8 level;\\n    uint8 race;\\n    uint32 experience;\\n    uint8 maxDropItems;\\n\\n    address attackToken;\\n    uint64 attackTokenId;\\n    uint8 attackType;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct ActionContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    uint8 biome;\\n    uint8 objectSubType;\\n    uint8 stageId;\\n    uint8 heroNgLevel;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint heroTokenId;\\n    uint salt;\\n    uint iteration;\\n    bytes data;\\n  }\\n\\n  struct EventRegInfo {\\n    uint8 biome;\\n    uint16 eventId;\\n    ObjectSubType subType;\\n\\n    uint32 goodChance;\\n\\n    AttributeGenerateInfo goodAttributes;\\n    AttributeGenerateInfo badAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct AttributeGenerateInfo {\\n    uint8[] ids;\\n    int32[] values;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev represent object registration if non zero values\\n  function getObjectMeta(uint32 objectId) external view returns (uint8 biome, uint8 objectSubType);\\n\\n  function isBattleObject(uint32 objectId) external view returns (bool);\\n\\n  function getRandomObject(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biomeLevel,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external returns (uint32 objectId);\\n\\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint iteration);\\n\\n  function action(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) external returns (ActionResult memory);\\n\\n}\\n\",\"keccak256\":\"0x9f12869021850ca2a16a083d0f1808f112061ca2d0278e82fe77f2839330b0d3\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGameToken.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IGameToken is IERC20 {\\n\\n  function minter() external view returns (address);\\n\\n  function mint(address account, uint amount) external returns (bool);\\n\\n  function burn(uint amount) external returns (bool);\\n\\n  function setMinter(address minter_) external;\\n\\n  function pause(bool value) external;\\n\\n}\\n\",\"keccak256\":\"0x55fbc7d57c7c72905132decd85a2008a901e550d0b71cf7ac5db6b36a1c598d6\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGuildBank.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\n\\ninterface IGuildBank {\\n  function transfer(address token, address recipient, uint amount) external;\\n\\n  function approve(address token, address spender, uint256 amount) external returns (bool);\\n\\n  function transferNft(address to, address nft, uint256 tokenId) external;\\n\\n  function transferNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external;\\n\\n  function approveNft(address to, address nft, uint256 tokenId) external;\\n\\n  function approveNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external;\\n}\",\"keccak256\":\"0x89143aa04e65d7668b2668a36825c7b1d5203a34dbe6a6ececaa71b5d67a2895\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGuildController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IGuildController {\\n  enum GuildRightBits {\\n    ADMIN_0,\\n    RENAME_1,\\n    CHANGE_LOGO_2,\\n    CHANGE_SHELTER_3,\\n    ADD_MEMBER_4,\\n    REMOVE_MEMBER_5,\\n    BANK_TOKENS_OPERATION_6,\\n    CHANGE_ROLES_7,\\n    LEVEL_UP_8,\\n    SET_RELATION_KIND_9,\\n    BANK_ITEMS_OPERATION_10,\\n    SET_GUILD_PARAMS_11,\\n    CHANGE_PURCHASING_SHELTER_ITEMS_CAPACITY_12,\\n    DOMINATION_REQUEST_13\\n  }\\n\\n  enum GuildsParams {\\n    NONE_0,\\n    COUNTER_GUILD_IDS_1,\\n    BASE_FEE_2,\\n    COUNTER_GUILD_REQUESTS_3,\\n    REENTRANT_STATUS_4,\\n    SHELTER_CONTROLLER_5,\\n    SHELTER_AUCTION_6\\n\\n    // max 255 params because enum is uint8 by default\\n  }\\n\\n  enum GuildRequestStatus {\\n    NONE_0,\\n    ACCEPTED_1,\\n    REJECTED_2,\\n    CANCELED_3\\n  }\\n\\n  /// @custom:storage-location erc7201:guild.controller.main\\n  struct MainState {\\n    /// @notice Mapping to store various guilds params (with global values for all guilds)\\n    mapping(GuildsParams param => uint value) guildsParam;\\n\\n    /// @notice guildId => address of instance of GuildBank contract\\n    mapping(uint guildId => address) guildBanks;\\n\\n    /// @notice guild id => guild data (owner, name, logo, etc)\\n    mapping(uint guildId => GuildData) guildData;\\n\\n    /// @notice name => guild id\\n    mapping(string guildName => uint guildId) nameToGuild;\\n\\n    /// @notice EOA => guild id, EOA can be a member of a single guild only\\n    mapping(address member => uint guildId) memberToGuild;\\n\\n    /// @notice List of participants of guilds\\n    /// @dev Allowed number of members is 20 + 5 * guildLevel\\n    mapping(uint guildId => EnumerableSet.AddressSet listEoa) members;\\n\\n    /// @notice Rights of the member in the guild, mask of GuildRightBits\\n    mapping(address member => uint maskRights) rights;\\n\\n    /// @notice _getGuildsPairKey(guild1, guild2) => status (false - war, true - peace)\\n    mapping(bytes32 guildsPairKey => bool) relationsPeaceful;\\n\\n    // ---------------------------- Request to join to the guild\\n    /// @notice Full list of requests registered for the guild\\n    mapping(uint guildId => mapping(GuildRequestStatus status => EnumerableSet.UintSet guildRequestIds)) guildRequests;\\n\\n    /// @notice List of active requests created by the given user.\\n    /// \\\"Active\\\" => deposit should be returned to the user.\\n    /// All not-active requests are removed from here automatically.\\n    mapping(address user => EnumerableSet.UintSet guildRequestIds) userActiveGuildRequests;\\n\\n    /// @notice Data of all guild requests ever created\\n    mapping(uint guildRequestId => GuildRequestData) guildRequestData;\\n\\n    /// @notice Deposit amount required to create a guild request\\n    mapping(uint guildId => GuildRequestDeposit) guildRequestDepositAmounts;\\n\\n    /// @notice Counter of spent pvp points + number of guild pvp-points allowed to be used by the guild member\\n    mapping(uint guildId => mapping(address member => UserPvpPoints)) userPvpPoints;\\n\\n    /// @notice guild id => guildDescription\\n    mapping(uint guildId => string) guildDescription;\\n  }\\n\\n  struct GuildData {\\n    /// @notice Not empty unique guild name\\n    string guildName;\\n\\n    /// @notice URL of guild logo (empty is allowed)\\n    string urlLogo;\\n\\n    /// @notice Creator (owner) of the guild\\n    address owner;\\n\\n    /// @notice Guild level [1...10]\\n    uint8 guildLevel;\\n\\n    /// @notice Percent of guild reinforcement fee Value in range [_FEE_MIN ... _TO_HELPER_RATIO_MAX], i.e. [10..50]\\n    uint8 toHelperRatio;\\n\\n    /// @notice Global guild points counter, it's incremented on each victory in php-fight.\\n    /// @dev Assume here, that uint64 is enough to store any sums of scores\\n    uint64 pvpCounter;\\n  }\\n\\n  struct GuildRequestData {\\n    GuildRequestStatus status;\\n    /// @notice Creator of the guild request that asks to include him to the guild\\n    address user;\\n    /// @notice Message to the guild owner from the user\\n    string userMessage;\\n    uint guildId;\\n  }\\n\\n  struct GuildRequestDeposit {\\n    bool initialized;\\n    uint192 amount;\\n  }\\n\\n  struct UserPvpPoints {\\n    /// @notice How many guild pvp-points the user is allowed to use\\n    uint64 capacityPvpPoints;\\n\\n    /// @notice How many guild pvp-points the user has used\\n    uint64 spentPvpPoints;\\n  }\\n\\n  /// ----------------------------------------------------------------------------------------------\\n\\n  function memberOf(address user) external view returns (uint guildId);\\n  function guildToShelter(uint guildId) external view returns (uint shelterId);\\n\\n  function getGuildData(uint guildId) external view returns (\\n    string memory guildName,\\n    string memory urlLogo,\\n    address owner,\\n    uint8 guildLevel,\\n    uint64 pvpCounter,\\n    uint toHelperRatio\\n  );\\n\\n  function getRights(address user) external view returns (uint);\\n  function getGuildBank(uint guildId) external view returns (address);\\n  function shelterController() external view returns (address);\\n\\n  function isPeacefulRelation(uint guildId, uint guildId2) external view returns (bool);\\n  function incPvpCounter(uint guildId, uint64 value) external;\\n\\n  function usePvpPoints(uint guildId, address user, uint64 priceInPvpPoints) external;\\n  function payFromGuildBank(uint guildId, uint shelterPrice) external;\\n  function payFromBalance(uint amount, address user) external;\\n\\n  /// @notice Ensure that the {user} has given {right}, revert otherwise\\n  function checkPermissions(address user, uint right) external view returns (uint guildId, uint rights);\\n  function shelterAuctionController() external view returns (address);\\n  function payForAuctionBid(uint guildId, uint amount, uint bid) external;\\n\\n}\\n\",\"keccak256\":\"0x9dea406907a40f6080c76838ea7967aeee64d05837da64a866d25e0e2ef59833\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGuildStakingAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\ninterface IGuildStakingAdapter {\\n\\n  /// @notice Calculate relative increment of the biome tax for the given guild owner, [0..1e18]\\n  /// 0 - no increment (default 1% is used), 1 - max possible increment (i.e. 5%)\\n  function getExtraFeeRatio(uint guildId) external view returns (uint);\\n\\n}\\n\",\"keccak256\":\"0xc1cfe82d9256ab38c775b247adc7b2fc8a5200eee346bd1157fa9bda29784cee\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IHeroController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IHeroController {\\n\\n  /// @custom:storage-location erc7201:hero.controller.main\\n  struct MainState {\\n\\n    /// @dev A central place for all hero tokens\\n    /// @dev Deprecated. Controller is used instead.\\n    address heroTokensVault;\\n\\n    /// @dev heroAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) payToken;\\n\\n    /// @dev heroAdr => heroCls8\\n    mapping(address => uint8) heroClass;\\n\\n    // ---\\n\\n    /// @dev hero+id => individual hero name\\n    mapping(bytes32 => string) heroName;\\n\\n    /// @dev name => hero+id, needs for checking uniq names\\n    mapping(string => bytes32) nameToHero;\\n\\n    // ---\\n\\n    /// @dev hero+id => biome\\n    mapping(bytes32 => uint8) heroBiome;\\n\\n    /// @notice Exist reinforcement of any kind for the given hero\\n    /// @dev hero+id => packed reinforcement helper+id\\n    mapping(bytes32 => bytes32) reinforcementHero;\\n\\n    /// @dev hero+id => reinforcement packed attributes\\n    mapping(bytes32 => bytes32[]) reinforcementHeroAttributes;\\n\\n    /// @notice packedHero (hero + id) => count of calls of beforeTokenTransfer\\n    mapping(bytes32 => uint) countHeroTransfers;\\n\\n\\n    // ------------------------------------ NG plus\\n\\n    /// @notice (tier, hero address) => TierInfo, where tier = [2, 3]\\n    /// @dev For tier=1 no data is required. Amount for tier 1 is stored in {payToken}, no items are minted\\n    /// Token from {payToken} is equal for all tiers\\n    mapping(bytes32 packedTierHero => TierInfo) tiers;\\n\\n    mapping(bytes32 packedHero => HeroInfo) heroInfo;\\n\\n    /// @notice Max NG_LVL reached by the heroes of a given account\\n    mapping(address user => uint8 maxNgLevel) maxUserNgLevel;\\n\\n    /// @notice When the hero has killed boss on the given biome first time\\n    /// packedBiomeNgLevel = packed (biome, NG_LEVEL)\\n    mapping(bytes32 packedHero => mapping (bytes32 packedBiomeNgLevel => uint timestamp)) killedBosses;\\n\\n    /// @notice Max NG_LEVEL reached by any user\\n    uint maxOpenedNgLevel;\\n\\n    /// @notice Sandbox mode for heroes, see SCR-1153\\n    mapping(bytes32 packedHero => SandboxMode sandboxMode) sandbox;\\n  }\\n\\n  /// @notice Tier = hero creation cost option\\n  /// There are 3 tiers:\\n  /// 1: most chip option, just pay fixed amount {payTokens} - new hero is created\\n  /// 2: pay bigger amount - random skill is equipped on the newly created hero\\n  /// 3: pay even more amount - random sill + some random items are equipped on the newly created hero\\n  struct TierInfo {\\n    /// @notice Cost of the hero creation using the given tier in terms of the token stored in {payToken}\\n    /// This amount is used for tiers 2, 3. For tier 1 the amount is taken from {payToken}\\n    uint amount;\\n\\n    /// @notice All slots for which items-to-mint are registered in {itemsToMint}\\n    EnumerableSet.UintSet slots;\\n\\n    /// @notice slot => items that can be minted and equipped on the hero to the given {slot} after hero creation\\n    mapping(uint8 slot => address[] items) itemsToMint;\\n  }\\n\\n  /// @notice Current NG+-related values\\n  struct HeroInfo {\\n    /// @notice Hero tier = [0..3]. 0 - the hero is post-paid, it can be changed by upgrading the hero to pre-paid\\n    uint8 tier;\\n\\n    /// @notice NG_LVL of the hero\\n    uint8 ngLevel;\\n\\n    /// @notice True if hero has passed last biome on current NG+ and so NG_LEVEL can be incremented (reborn is allowed)\\n    bool rebornAllowed;\\n\\n    /// @notice Amount paid for the hero on creation OR on upgrade to NG+\\n    /// Amount paid for creation of the hero in terms of game token (!NG+) is NOT stored here.\\n    /// @dev uint72 is used here to pack the whole struct to single slot\\n    /// Zero for sandbox-heroes\\n    uint72 paidAmount;\\n\\n    /// @notice Pay token used to pay {paidAmount}\\n    /// Zero for sandbox-heroes\\n    address paidToken;\\n  }\\n\\n  /// @notice Input data to create new hero\\n  struct HeroCreationData {\\n    /// @notice Desired NG_LVL of the hero\\n    uint8 ngLevel;\\n\\n    /// @notice Desired tire of the newly created hero. Allowed values: [1..3]\\n    uint8 tier;\\n\\n    /// @notice Enter to the dungeon after creation\\n    bool enter;\\n\\n    /// @notice Desired hero name\\n    string heroName;\\n\\n    /// @notice Optional: user account for which the hero is created\\n    address targetUserAccount;\\n\\n    /// @notice Optional: ref-code to be passed to the hero-creation-related event\\n    string refCode;\\n\\n    /// @notice SCR-1153: create not-paid hero with limited rights\\n    bool sandboxMode;\\n  }\\n\\n  enum SandboxMode {\\n    /// @notice The hero is created in normal (not sandbox) mode\\n    NORMAL_MODE_0,\\n\\n    /// @notice The hero was created in sandbox mode and wasn't upgraded.\\n    SANDBOX_MODE_1,\\n\\n    /// @notice The hero was created in sandbox mode and was upgraded to the normal mode\\n    UPGRADED_TO_NORMAL_2\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function heroClass(address hero) external view returns (uint8);\\n\\n  function heroBiome(address hero, uint heroId) external view returns (uint8);\\n\\n  function payTokenInfo(address hero) external view returns (address token, uint amount);\\n\\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (address helperHeroToken, uint helperHeroId);\\n\\n  function score(address hero, uint heroId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool);\\n\\n  function beforeTokenTransfer(address hero, uint heroId) external returns (bool);\\n\\n  // ---\\n\\n  function create(address hero, string memory heroName_, bool enter) external returns (uint);\\n\\n  function kill(address hero, uint heroId) external returns (bytes32[] memory dropItems);\\n\\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId);\\n\\n  function resetLifeAndMana(address hero, uint heroId) external;\\n\\n  function countHeroTransfers(address hero, uint heroId) external view returns (uint);\\n\\n  function askGuildReinforcement(address hero, uint heroId, address helper, uint helperId) external;\\n\\n  function getHeroInfo(address hero, uint heroId) external view returns (IHeroController.HeroInfo memory data);\\n\\n  function registerKilledBoss(address hero, uint heroId, uint32 objectId) external;\\n\\n  function maxOpenedNgLevel() external view returns (uint);\\n\\n  function sandboxMode(address hero, uint heroId) external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xd5ab48c90da3f207bade75ccf72d31c2b70b32037604608878b48ad3f7b46cb9\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItem.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IItem {\\n\\n  function isItem() external pure returns (bool);\\n\\n  function mintFor(address recipient) external returns (uint tokenId);\\n\\n  function burn(uint tokenId) external;\\n\\n  function controlledTransfer(address from, address to, uint tokenId) external;\\n}\\n\",\"keccak256\":\"0x766165af1a0ef65f8969414e165fdbc38294b5f249d280a3be272cbaa90721a7\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemBoxController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IItemBoxController {\\n  /// @custom:storage-location erc7201:ItemBox.controller.main\\n  struct MainState {\\n    mapping(bytes32 packedHero => HeroData) heroData;\\n\\n    /// @notice Owners of all items minted in sandbox mode\\n    mapping(bytes32 packedItem => bytes32 packedHero) heroes;\\n  }\\n\\n  struct HeroData {\\n    /// @notice Moment of upgrading sandbox-hero to normal-hero\\n    uint tsUpgraded;\\n\\n    /// @notice List of all items registered for the hero\\n    EnumerableSet.AddressSet items;\\n\\n    /// @notice item => (itemId => packedItemBoxItemInfo)\\n    /// @dev Ids are never deleted from the map, so the order of ids is never changed\\n    mapping(address item => EnumerableMap.UintToUintMap) states;\\n  }\\n\\n  struct ItemBoxItemInfo {\\n    /// @notice True if the item was withdrawn from balance\\n    /// It can happens in follow cases:\\n    /// 1) the hero was upgraded and the item was withdrawn on hero owner balance\\n    /// 2) the item is used by ItemController:\\n    /// 2.1) the item is equipped on the hero and so it's transferred to the hero balance\\n    /// 2.2) the consumable item is used\\n    /// 3) the item is burnt\\n    /// @dev Status is required to avoid deletion (and so changing order) of the {items}\\n    bool withdrawn;\\n\\n    /// @notice The moment of the initial item minting\\n    uint64 timestamp;\\n  }\\n\\n  enum ItemState {\\n    /// @notice The item was never registered in the sandbox\\n    NOT_REGISTERED_0,\\n    /// @notice The item is not active (outdated) and cannot be used anymore\\n    NOT_AVAILABLE_1,\\n    /// @notice The item is active and located inside the sandbox\\n    INSIDE_2,\\n    /// @notice The item is either withdrawn or equipped\\n    OUTSIDE_3\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function firstActiveItemOfHeroByIndex(address hero, uint heroId, address item) external view returns (uint itemId);\\n  function registerItems(address hero, uint heroId, address[] memory items, uint[] memory itemIds, uint countValidItems) external;\\n  function itemState(address hero, uint heroId, address item, uint itemId) external view returns (IItemBoxController.ItemState);\\n  function itemHero(address item, uint itemId) external view returns (address hero, uint heroId);\\n  function registerSandboxUpgrade(bytes32 packedHero) external;\\n  function transferToHero(address hero, uint heroId, address item, uint itemId) external;\\n  function destroyItem(address item, uint itemId) external;\\n}\\n\",\"keccak256\":\"0xdb480923e0879904a4a5fda24ebf7caf027238c1cec2a0eb58885655e7b624e0\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IItemController {\\n\\n  enum GlobalParam {\\n    UNKNOWN_0,\\n\\n    /// @notice Address of ItemControllerHelper\\n    ITEM_CONTROLLER_HELPER_ADDRESS_1\\n  }\\n\\n  /// @custom:storage-location erc7201:item.controller.main\\n  struct MainState {\\n\\n    ////////////////// GENERATE //////////////////\\n\\n    EnumerableSet.AddressSet items;\\n\\n    /// @dev itemAdr => itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n    mapping(address => bytes32) itemMeta;\\n\\n    /// @dev itemAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) augmentInfo;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoAttributes;\\n\\n    // --- consumable ---\\n\\n    /// @dev itemAdr => ids+values (toBytes32ArrayWithIds)\\n    mapping(address => bytes32[]) _itemConsumableAttributes;\\n\\n    /// @dev itemAdr => IStatController.ChangeableStats packed int32[]\\n    mapping(address => bytes32) itemConsumableStats;\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoCasterAttributes;\\n\\n    /// @dev itemAdr => id8 + minDmg(int32) + maxDmg(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(address => bytes32) generateInfoAttack;\\n\\n    ////////////////// ITEMS INFO //////////////////\\n\\n    /// @dev itemAdr+id => itemRarity8 + augmentationLevel8 + itemDurability16\\n    mapping(bytes32 => bytes32) itemInfo;\\n\\n    /// @dev itemAdr+id => heroAdr+id\\n    mapping(bytes32 => bytes32) equippedOn;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemAttributes;\\n\\n    // --- consumable ---\\n\\n    // consumable stats unchangeable, get them by address\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemCasterAttributes;\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr+Id => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(bytes32 => bytes32) _itemAttackInfo;\\n\\n    ////////////////// Additional generate info //////////////////\\n\\n    /// @notice (itemAdr) => Bitmask of ConsumableActionBits\\n    mapping(address => uint) _consumableActionMask;\\n\\n\\n    /// --------------------------------- SIP-003: Item fragility\\n    /// @notice itemAdr + id => item fragility counter that displays the chance of an unsuccessful repair\\n    /// @dev [0...100_000], decimals 3\\n    mapping(bytes32 packedItem => uint fragility) itemFragility;\\n\\n    /// @notice Universal mapping to store various addresses and numbers (params of the contract)\\n    mapping (GlobalParam param => uint value) globalParam;\\n\\n    /// @notice Item address => packedMetadata\\n    /// {packedMetaData} is encoded using abi.encode/abi.decode\\n    /// Read first byte, detect meta data type by the byte value, apply proper decoder from PackingLib\\n    mapping(address item => bytes packedMetaData) packedItemMetaData;\\n\\n    /// --------------------------------- SCR-1263: Reverse-augmentation\\n    /// @notice Item attributes values before first augmentation.\\n    /// @dev SCR-1263: The values are required in augmentation if protective item is used and the augmentation is failed.\\n    mapping(bytes32 packedItem => ResetAugmentationData) _resetAugmentation;\\n  }\\n\\n  struct RegisterItemParams {\\n    ItemMeta itemMeta;\\n    address augmentToken;\\n    uint augmentAmount;\\n    ItemGenerateInfo commonAttributes;\\n\\n    IGOC.AttributeGenerateInfo consumableAttributes;\\n    IStatController.ChangeableStats consumableStats;\\n\\n    ItemGenerateInfo casterAttributes;\\n    ItemGenerateInfo targetAttributes;\\n\\n    AttackInfo genAttackInfo;\\n    /// @notice Bit mask of ConsumableActionBits\\n    uint consumableActionMask;\\n  }\\n\\n  /// @notice Possible actions that can be triggered by using the consumable item\\n  enum ConsumableActionBits {\\n    CLEAR_TEMPORARY_ATTRIBUTES_0\\n    // other items are used instead this mask\\n  }\\n\\n  struct ItemGenerateInfo {\\n    /// @notice Attribute ids\\n    uint8[] ids;\\n    /// @notice Min value of the attribute, != 0\\n    int32[] mins;\\n    /// @notice Max value of the attribute, != 0\\n    int32[] maxs;\\n    /// @notice Chance of the selection [0..MAX_CHANCES]\\n    uint32[] chances;\\n  }\\n\\n  struct ItemMeta {\\n    uint8 itemMetaType;\\n    // Level in range 1-99. Reducing durability in low level dungeons. lvl/5+1 = biome\\n    uint8 itemLevel;\\n    IItemController.ItemType itemType;\\n    uint16 baseDurability;\\n    uint8 defaultRarity;\\n    uint32 manaCost;\\n\\n    // it doesn't include positions with 100% chance\\n    uint8 minRandomAttributes;\\n    uint8 maxRandomAttributes;\\n\\n    IStatController.CoreAttributes requirements;\\n  }\\n\\n  // Deprecated. Todo - remove\\n  enum FeeType {\\n    UNKNOWN,\\n    REPAIR,\\n    AUGMENT,\\n    STORY,\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemRarity {\\n    UNKNOWN, // 0\\n    NORMAL, // 1\\n    MAGIC, // 2\\n    RARE, // 3\\n    SET, // 4\\n    UNIQUE, // 5\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemType {\\n    NO_SLOT, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    RING, // 6\\n    OFF_HAND, // 7\\n    BOOTS, // 8\\n    ONE_HAND, // 9\\n    TWO_HAND, // 10\\n    SKILL, // 11\\n    OTHER, // 12\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemMetaType {\\n    UNKNOWN, // 0\\n    COMMON, // 1\\n    ATTACK, // 2\\n    BUFF, // 3\\n    CONSUMABLE, // 4\\n\\n    END_SLOT\\n  }\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    FIRE, // 1\\n    COLD, // 2\\n    LIGHTNING, // 3\\n    CHAOS, // 4\\n\\n    END_SLOT\\n  }\\n\\n  struct AttackInfo {\\n    AttackType aType;\\n    int32 min;\\n    int32 max;\\n    // if not zero - activate attribute factor for the attribute\\n    IStatController.CoreAttributes attributeFactors;\\n  }\\n\\n  struct ItemInfo {\\n    ItemRarity rarity;\\n    uint8 augmentationLevel;\\n    uint16 durability;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct MintInfo {\\n    IItemController.ItemMeta meta;\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.ItemRarity itemRarity;\\n\\n    IItemController.AttackInfo attackInfo;\\n\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct AugmentInfo {\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.AttackInfo attackInfo;\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  ///region ------------------------ Item type \\\"Other\\\"\\n  /// @notice Possible kinds of \\\"Other\\\" items\\n  /// Each \\\"Other\\\" item has each own structure for metadata, see OtherItemXXX\\n  enum OtherSubtypeKind {\\n    UNKNOWN_0,\\n    /// @notice Item to reduce fragility, see SCB-1014. Metadata is {OtherItemReduceFragility}\\n    REDUCE_FRAGILITY_1,\\n\\n    /// @notice This item allows asking guild reinforcement to the guild member\\n    USE_GUILD_REINFORCEMENT_2,\\n\\n    /// @notice Exit from dungeon (shelter of level 3 is required)\\n    EXIT_FROM_DUNGEON_3,\\n\\n    /// @notice OTHER_5 Rest in the shelter: restore of hp & mp, clear temporally attributes, clear used consumables (shelter of level 3 is required)\\n    /// @dev It's OTHER_5 in deploy script, but internally it has subtype 4, see gen_others.ts\\n    REST_IN_SHELTER_4,\\n\\n    /// @notice OTHER_4 Stub item that has no logic in contracts, but it has correct (not empty) packedMetaData\\n    /// @dev It's OTHER_4 in deploy script, but internally it has subtype 5, see gen_others.ts\\n    EMPTY_NO_LOGIC_5,\\n\\n    END_SLOT\\n  }\\n  struct OtherItemReduceFragility {\\n    /// @notice \\\"Other\\\" item kind. It MUST BE first field in the struct.\\n    uint8 kind;\\n\\n    /// @notice Value on which the fragility will be reduced.\\n    /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n    uint248 value;\\n  }\\n  ///endregion ------------------------ Item type \\\"Other\\\"\\n\\n  struct AugmentOptParams {\\n    /// @notice Optional protective item\\n    /// @dev SCR-1263: If the protective item specified\\n    /// than failed augmentation doesn't destroy main item but reduces its augmentation level to the zero instead.\\n    /// Protective item is configured in ItemControllerHelper.\\n    address protectiveItem;\\n    uint protectiveItemId;\\n  }\\n\\n  struct ResetAugmentationData {\\n    /// @notice Moment of the first augmentation if any\\n    uint tsFirstAugmentation;\\n\\n    /// @notice Values of the item attributes before the first augmentation\\n    /// @dev Use PackingLib.toInt32ArrayWithIds to decode attribute ids and values\\n    bytes32[] itemAttributes;\\n\\n    /// @notice Values of the caster attributes before the first augmentation\\n    /// @dev Use PackingLib.toInt32ArrayWithIds to decode attribute ids and values\\n    bytes32[] itemCasterAttributes;\\n\\n    /// @notice Values of the target attributes before the first augmentation\\n    /// @dev Use PackingLib.toInt32ArrayWithIds to decode attribute ids and values\\n    bytes32[] itemTargetAttributes;\\n\\n    /// @notice packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    bytes32 itemAttackInfo;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function itemMeta(address item) external view returns (ItemMeta memory meta);\\n\\n  function augmentInfo(address item) external view returns (address token, uint amount);\\n\\n  function genAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genCasterAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genTargetAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genAttackInfo(address item) external view returns (AttackInfo memory info);\\n\\n  function itemInfo(address item, uint itemId) external view returns (ItemInfo memory info);\\n\\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId);\\n\\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats);\\n\\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function itemAttackInfo(address item, uint itemId) external view returns (AttackInfo memory info);\\n\\n  function score(address item, uint tokenId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address item, uint tokenId) external view returns (bool);\\n\\n  // ---\\n\\n  function mint(address item, address recipient) external returns (uint itemId);\\n\\n  function reduceDurability(address hero, uint heroId, uint8 biome, bool reduceDurabilityAllSkills) external;\\n\\n  function destroy(address item, uint tokenId) external;\\n\\n  function takeOffDirectly(\\n    address item,\\n    uint itemId,\\n    address hero,\\n    uint heroId,\\n    uint8 itemSlot,\\n    address destination,\\n    bool broken\\n  ) external;\\n\\n  /// @notice SIP-003: item fragility counter that displays the chance of an unsuccessful repair.\\n  /// @dev [0...100%], decimals 3, so the value is in the range [0...10_000]\\n  function itemFragility(address item, uint itemId) external view returns (uint);\\n\\n  /// @notice SIP-003: The quest mechanic that previously burned the item will increase its fragility by 1%\\n  function incBrokenItemFragility(address item, uint itemId) external;\\n\\n  function equip(\\n    address hero,\\n    uint heroId,\\n    address[] calldata items,\\n    uint[] calldata itemIds,\\n    uint8[] calldata itemSlots\\n  ) external;\\n}\\n\",\"keccak256\":\"0x1f2001fd779237da65009e09352df63d1408c04cc9f86099bb7efb6eae1ebf88\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemControllerHelper.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\n/// @notice Helper contract owned by ItemController only, it reduces data and code size in ItemController\\ninterface IItemControllerHelper {\\n\\n  enum GlobalParam {\\n    UNKNOWN_0,\\n\\n    /// @notice Address of the nft. User should own such nft to be able to combine items. 0 is allowed (no keyPass)\\n    UNION_KEY_PASS_ITEM_1,\\n\\n    /// @notice Generator of ID for union combinations\\n    UNION_ID_COUNTER_2,\\n\\n    /// @notice SCR-1263: protective item for augmentation\\n    AUGMENTATION_PROTECTIVE_ITEM_3\\n  }\\n\\n  /// @custom:storage-location erc7201:item.controller.helper.main\\n  struct MainState {\\n    /// @notice Universal mapping to store various addresses and numbers (params of the contract)\\n    mapping (GlobalParam param => uint value) globalParam;\\n\\n    //region ------------------------ SCB-1028: combine multiple items to new more powerful item\\n\\n    /// @notice Union ID generated using {UNION_ID_COUNTER_2} => configuration\\n    mapping (uint configId => UnionConfig) unionConfig;\\n\\n    /// @notice List of configId of all registered union configs\\n    EnumerableSet.UintSet listUnionConfigs;\\n\\n    //endregion ------------------------ SCB-1028: combine multiple items to new more powerful item\\n  }\\n\\n  struct UnionConfig {\\n    /// @notice Each union has unique ID\\n    /// @dev Assume that 96 bits are enough to store any id => configId + itemToMint = 1 slot\\n    uint96 configId;\\n\\n    /// @notice Result item that will be minted in exchange of destroying of the combined {items} of the given {count}\\n    address itemToMint;\\n\\n    /// @notice List of items that can be combined. We need to store the list to be able to display it on UI only\\n    address[] items;\\n\\n    /// @notice Count of items that can be combined. We need to store the list to be able to display it on UI only\\n    uint[] count;\\n  }\\n\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function prepareToCombine(address user, uint configId, address[] memory items, uint[][] memory tokens) external view returns (address);\\n  function getAugmentationProtectiveItem() external view returns (address);\\n}\\n\",\"keccak256\":\"0x09cf6a7a94edb1750d1e6362efec0908a50451438be11d4198e627daf1f64ac1\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IMinter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\n\\ninterface IMinter {\\n\\n  function amountForDungeon(uint dungeonBiomeLevel, uint heroLevel) external view returns (uint);\\n\\n  function mintDungeonReward(uint64 dungeonId, uint dungeonBiomeLevel, uint heroLevel) external returns (uint amount);\\n\\n}\\n\",\"keccak256\":\"0x3b8a36fc894e406919648722291fe3b2b196791734eb9b11d4d60c37c6d92ae7\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IOracle {\\n\\n  function getRandomNumber(uint max, uint seed) external returns (uint);\\n\\n  function getRandomNumberInRange(uint min, uint max, uint seed) external returns (uint);\\n\\n}\\n\",\"keccak256\":\"0x75a2bed27cbd9be6c76b6f3e941ee5f6f55380f61cd867254a0c766fc3b71976\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IPvpController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\n\\ninterface IPvpController {\\n  enum PvpParams {\\n    NONE_0,\\n    /// @notice Hero can be pvp-staked if his level is greater of equal to the given min level\\n    MIN_HERO_LEVEL_1,\\n\\n    /// @notice Address of IGuildStakingAdapter, can be not initialized\\n    GUILD_STAKING_ADAPTER_2,\\n\\n    /// @notice Unique ID of the pvp-fight (each pvp-fight consists from multiple turns)\\n    FIGHT_COUNTER_3\\n\\n    // max 255 params because enum is uint8 by default\\n  }\\n\\n  /// @custom:storage-location erc7201:pvp.controller.main\\n  struct MainState {\\n    /// @notice Mapping to store various params of PvpController\\n    mapping(PvpParams param => uint value) pvpParam;\\n\\n    /// @notice Current states of biomes\\n    mapping(uint8 biome => BiomeData) biomeState;\\n\\n    /// @notice Biomes owned by the guilds\\n    mapping(uint guildId => uint8 biome) ownedBiome;\\n\\n    mapping(uint epochWeek => EpochData) epochData;\\n  }\\n\\n  struct EpochData {\\n    /// @notice Current state of the user in the current epoch\\n    mapping (address user => PvpUserState) pvpUserState;\\n\\n    /// @notice biome data for the given epoch\\n    mapping(uint8 biome => EpochBiomeData) epochBiomeData;\\n\\n    /// @notice All prepared pvp-fights for the given user\\n    /// Index of currently active fight is stored in {pvpUserState.activeFightIndex1}\\n    mapping (address user => PvpFightData[]) fightData;\\n\\n    /// @notice All currently registered packed-heroes\\n    EnumerableSet.UintSet stakedHeroes;\\n\\n    /// @notice Weekly request of the guild to dominate at the given biome starting from the next week\\n    mapping(uint guildId => uint8 biome) targetBiome;\\n\\n    /// @notice All guilds pretend for the given biome\\n    mapping(uint8 biome => EnumerableSet.UintSet guildIds) biomeGuilds;\\n  }\\n\\n  /// @notice Current state of the user. Possible states: user has or hasn't staked a hero in pvp.\\n  /// Each user is able to stake pvp-heroes multiple times per epoch\\n  /// but the user is able to stake only 1 pvp-hero at any moment.\\n  /// @dev Implementation assumes that the struct occupies single slot, the struct is read as a whole\\n  struct PvpUserState {\\n    /// @notice Domination biome at the moment of staking\\n    /// @dev not 0 if the user has pvp-staked hero\\n    uint8 biome;\\n\\n    /// @notice 1-based index of currently active fight in {fightData} (the fight is either prepared or in-progress).\\n    /// 0 - there is no active fight\\n    uint32 activeFightIndex1;\\n\\n    /// @notice How many times the user has staked heroes for PVP\\n    /// @dev Max possible value is limited by MAX_NUMBER_STAKES_FOR_USER_PER_EPOCH\\n    uint32 numHeroesStaked;\\n\\n    /// @notice User's guild at the moment of staking\\n    /// 0 if user has no hero staked in pvp currently\\n    uint64 guildId;\\n\\n    /// @notice Total number of pvp-fights performed since the last call of addPvpHero.\\n    /// @dev All pvp-fights are won here because looser is auto removed.\\n    uint8 countFights;\\n\\n    /// @notice Max number of pvp-fights allowed by the user per single call of addPvpHero, 0 - no limits\\n    uint8 maxFights;\\n\\n    /// @notice Unique id of the current pvp-fight (the fight with activeFightIndex1)\\n    uint48 fightId;\\n  }\\n\\n  struct BiomeData {\\n    /// @notice Biome owner - the guild that dominates in the biome at the given epoch. He has a right to get a tax\\n    /// @dev Assume here that uint64 is enough to store any guildId. It allows us to store whole struct in a single slot\\n    uint64 guildBiomeOwnerId;\\n\\n    /// @notice Current epoch (last epoch for which pvp-battle was made)\\n    /// 0 if epoch was never started\\n    uint32 startedEpochWeek;\\n\\n    /// @notice Number of consecutive epochs during which {guildBiomeOwnerId} wasn't changed\\n    uint16 dominationCounter;\\n  }\\n\\n  struct EpochBiomeData {\\n    /// @notice List of guilds asked for domination in the biome => total points scored by the guilds in the given epoch\\n    /// @dev guildId => count points\\n    EnumerableMap.UintToUintMap guildPoints;\\n\\n    /// @notice All users free for pvp-fight\\n    /// User is added here on registration and removed as soon as the fight for the user is initialized.\\n    mapping(uint guildId => EnumerableSet.AddressSet) freeUsers;\\n\\n    /// @notice All users (from the {guilds}) provided heroes for pvp\\n    /// @dev guildId => (user address => packedHero (hero + heroId))\\n    mapping(uint guildId => EnumerableMap.AddressToUintMap) registeredHeroes;\\n\\n    /// @notice The skills and attack type selected in advance\\n    mapping(bytes32 packedHero => bytes) pvpStrategy;\\n  }\\n\\n  enum PvpFightStatus {\\n    /// @notice No fight, the hero doesn't have selected opponent\\n    NOT_INITIALIZED_0,\\n\\n    /// @notice The hero has opponent, the fight is not started\\n    PREPARED_1,\\n\\n    /// @notice The fight is started but not completed\\n    FIGHTING_2,\\n\\n    /// @notice The fight is completed, the hero is the winner\\n    WINNER_3,\\n\\n    /// @notice The fight is completed, the hero is the looser\\n    LOSER_4\\n  }\\n\\n  /// @notice Current state of the fight\\n  /// @dev Implementation assumes that the struct occupies single slot, the struct is read as a whole\\n  /// @dev We don't store biome and guildId here. This info is stored in user state and can be lost after fight ending.\\n  struct PvpFightData {\\n    /// @notice address of user whose hero is the fight opponent\\n    address fightOpponent;\\n\\n    /// @notice Current status of PVP-fight\\n    PvpFightStatus fightStatus;\\n\\n    /// @notice Current value of the health (only when fightStatus is FIGHTING_2)\\n    uint32 health;\\n\\n    /// @notice Current value of the mana (only when fightStatus is FIGHTING_2)\\n    uint32 mana;\\n\\n    /// @notice Number of moves made (only when fightStatus is FIGHTING_2)\\n    uint8 countTurns;\\n  }\\n\\n  /// @dev Implementation assumes that the struct occupies single slot, the struct is read as a whole\\n  struct PvpFightResults {\\n    bool completed;\\n    uint8 totalCountFights;\\n    uint32 healthHero;\\n    uint32 healthOpponent;\\n    uint32 manaConsumedHero;\\n    uint32 manaConsumedOpponent;\\n  }\\n\\n  /// @notice Strategy how to use attack info\\n  enum PvpBehaviourStrategyKinds {\\n    /// @notice Use all skills, use magic attack if it's available\\n    /// @dev {PvpStrategyDefault} is used as data in {addPvpHero}\\n    DEFAULT_STRATEGY_0\\n\\n    // new strategies are able to use different structures to store data passed to {addPvpHero}\\n  }\\n\\n  /// @notice The data provided by user at the staking with {DEFAULT_STRATEGY_0}\\n  struct PvpStrategyDefault {\\n    /// @notice Should be equal to DEFAULT_STRATEGY_0\\n    uint behaviourStrategyKind;\\n    IFightCalculator.AttackInfo attackInfo;\\n  }\\n\\n  struct HeroData {\\n    address hero;\\n    uint heroId;\\n    bytes pvpStrategy;\\n  }\\n\\n  /// ------------------------------------------------------------------------------------------------------------------\\n  /// ------------------------------------------------------------------------------------------------------------------\\n  /// ------------------------------------------------------------------------------------------------------------------\\n\\n  /// @notice Update epoch if necessary and return actual biome owner and tax\\n  /// @return guildId Owner of the biome\\n  /// @return taxPercent Tax percent , [0...100_000], decimals 3\\n  function refreshBiomeTax(uint8 biome) external returns (uint guildId, uint taxPercent);\\n\\n  function isHeroStakedCurrently(address hero, uint heroId) external view returns (bool staked);\\n  function onGuildDeletion(uint guildId) external;\\n}\",\"keccak256\":\"0x9af8cb3a40e61bb50dbb672847272498d5e87f4eca22ff7598dbb48970321ad1\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IReinforcementController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\n/// @notice Terms\\n/// Reinforcement v1: helper is selected randomly in askHero, fixed part of rewards (tokens and NFT) is sent to the helper.\\n/// Guild reinforcement: helper is selected from guild heroes. Rewards are sent to guild bank.\\n/// Reinforcement v2: helper is selected manually in askHeroV2, helper receives fixed amount.\\ninterface IReinforcementController {\\n\\n  enum ConfigParams {\\n    /// @notice Packed MinMaxBoardV2\\n    V2_MIN_MAX_BOARD_0\\n  }\\n\\n  /// @custom:storage-location erc7201:reinforcement.controller.main\\n  struct MainState {\\n\\n    // ------------------------ Reinforcement v1\\n\\n    /// @dev minLvl8 + minLifeChances8\\n    bytes32 config;\\n    /// @dev hero token + hero id => heroInfo(biome8 + score128 + fee8 + stakeTs64)\\n    mapping(bytes32 => bytes32) _stakedHeroes;\\n    /// @dev biome => helperAdr+id\\n    mapping(uint => EnumerableSet.Bytes32Set) _internalIdsByBiomes;\\n    /// @dev biome => score  // The field is deprecated and not updated any more\\n    mapping(uint => uint) maxScore;\\n    /// @dev heroAdr+id => itemAdr+id\\n    mapping(bytes32 => bytes32[]) _heroNftRewards;\\n    /// @dev heroAdr+id => tokenAdr and amount map\\n    mapping(bytes32 => EnumerableMap.AddressToUintMap) _heroTokenRewards;\\n\\n\\n    // ------------------------ Guild reinforcement\\n\\n    /// @notice All staked guild heroes for the given guild\\n    /// @dev helper (hero token + hero id) => guild\\n    mapping(bytes32 packedHero => uint guildId) stakedGuildHeroes;\\n\\n    /// @notice All guild heroes that are currently in use by guild reinforcement\\n    /// It's allowed to withdraw a hero before reinforcement releasing,\\n    /// so it's possible to have !0 in {guildBusyHelpers} and 0 in {stakedGuildHeroes} simultaneously.\\n    /// @dev helper (hero token + hero id) => guildId (guild at the moment of askGuildReinforcement)\\n    mapping(bytes32 packedHero => uint guildId) busyGuildHelpers;\\n\\n    /// @notice All (free and busy) staked guild heroes per guild.\\n    /// guild => (packed helper => guild where the helper is busy currently)\\n    /// @dev There is a chance that guilds are different here\\n    /// i.e. hero can be:\\n    /// 1) added to G1 2) staked in G1 3) asked for help 4) withdrawn 5) G1=>G2 6) staked in G2\\n    /// In such case guildHelpers[G2][hero] = G1, guildHelpers[G1][hero] = 0\\n    /// After releasing guildHelpers[G2][hero] = 0\\n    mapping(uint guildId => EnumerableMap.Bytes32ToUintMap) guildHelpers;\\n\\n    /// @notice Moment of withdrawing the hero from staking. Next staking is possible in 1 day since withdrawing\\n    mapping(bytes32 packedHero => uint lastWithdrawTimestamp) lastGuildHeroWithdrawTs;\\n\\n\\n    // ------------------------ Reinforcement v2\\n    /// @notice Map to store various config params\\n    mapping(ConfigParams paramId => uint) configParams;\\n\\n    mapping(bytes32 packedHero => HeroInfoV2) stakedHeroesV2;\\n\\n    /// @notice biome => set of packedHero. All staked heroes (they can be busy of free currently)\\n    mapping(uint biome => EnumerableSet.Bytes32Set) heroesByBiomeV2;\\n\\n    mapping(uint biome => LastWindowsV2) stat24hV2;\\n  }\\n\\n\\n  /// @notice Deprecated. Reinforcement v1\\n  struct HeroInfo {\\n    uint8 biome;\\n    uint score; // stored in 128 but easy to use 256\\n    /// @notice To helper ratio\\n    uint8 fee;\\n    uint64 stakeTs;\\n  }\\n\\n  struct HeroInfoV2 {\\n    uint8 biome;\\n    uint64 stakeTs;\\n    /// @notice Amount of game token that is paid to the helper at the moment of the call {askHeroV2}\\n    uint128 rewardAmount;\\n  }\\n\\n  /// @notice Statistic of askHeroV2 calls per last 24 hours at the moment of the last call\\n  struct LastWindowsV2 {\\n    /// @notice 24 hours are divided on 8 intervals, each interval is 3 hour\\n    /// Current basket has index {basketIndex}\\n    /// {baskets[current basket]} contains \\\"old\\\" value.\\n    /// New value for the current basket is collected in {basketValue}.\\n    /// The value for the current basket is calculated as weighted average of old and new values.\\n    /// New value replaces the old value at the moment of changing current basket index.\\n    uint24[8] baskets;\\n    /// @notice New value (hits counter) for current basket\\n    uint24 basketValue;\\n    /// @notice Abs. index of the current basket (abs. hour / 3)\\n    uint48 basketIndex;\\n  }\\n\\n  /// @dev 1 slot\\n  struct ConfigReinforcementV2 {\\n    /// @notice if Number-of-askHeroV2-calls is below given value then burn fee has min value\\n    uint32 minNumberHits;\\n    /// @notice if Number-of-askHeroV2-calls is above given value then burn fee has max value\\n    uint32 maxNumberHits;\\n    /// @notice Lowest fee = amountForDungeon / given value, i.e. 100 => amountForDungeon/100 as lower fee\\n    uint32 lowDivider;\\n    /// @notice Highest fee = amountForDungeon / given value, i.e. 2 => amountForDungeon/2 as highest fee\\n    uint32 highDivider;\\n    /// @notice Limit for min level of the staked hero\\n    /// In practice we need following limitation: (stats.level < 5 || (stats.level - 5) / 5 < biome)\\n    /// so, levelLimit should be equal 5\\n    /// In tests we need to be able to disable such limitation, so levelLimit = 0 allow to disable that constraint\\n    uint8 levelLimit;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function toHelperRatio(address heroToken, uint heroId) external view returns (uint);\\n\\n  function isStaked(address heroToken, uint heroId) external view returns (bool);\\n\\n  function registerTokenReward(address heroToken, uint heroId, address token, uint amount) external;\\n\\n  function registerNftReward(address heroToken, uint heroId, address token, uint tokenId) external;\\n\\n  function askHeroV2(address hero, uint heroId, address helper, uint helperId) external returns (int32[] memory attributes);\\n\\n  function askGuildHero(address hero, uint heroId, address helper, uint helperId) external returns (int32[] memory attributes);\\n\\n  /// @notice Return the guild in which the hero is currently asked for guild reinforcement\\n  function busyGuildHelperOf(address heroToken, uint heroId) external view returns (uint guildId);\\n\\n  function releaseGuildHero(address helperHeroToken, uint helperHeroTokenId) external;\\n}\",\"keccak256\":\"0x9db4175e2a6415c55ef773a1abd960feba58b2973afce83691762fb679d7fd13\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IRewardsPool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IRewardsPool {\\n\\n  /// @custom:storage-location erc7201:rewards.pool.main\\n  struct MainState {\\n    mapping(address token => uint baseAmountValue) baseAmounts;\\n  }\\n\\n  function balanceOfToken(address token) external view returns (uint);\\n\\n  function rewardAmount(address token, uint maxBiome, uint maxNgLevel, uint biome, uint heroNgLevel) external view returns (uint);\\n\\n  function sendReward(address token, uint rewardAmount_, address receiver) external;\\n\\n  function lostProfitPercent(uint maxBiome, uint maxNgLevel, uint heroNgLevel) external view returns (uint percent);\\n}\\n\",\"keccak256\":\"0x1059791209fc6106767c7c2d894b38a08ef2d806eff084b07f663d25fdf18609\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IShelterAuction.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IShelterAuction {\\n  enum ShelterAuctionParams {\\n    NONE_0,\\n    POSITION_COUNTER_1,\\n    BID_COUNTER_2,\\n    FEE_3\\n\\n    // max 255 params because enum is uint8 by default\\n  }\\n\\n  //region ------------------------ Data types\\n  /// @custom:storage-location erc7201:shelter.auction.main\\n  struct MainState {\\n\\n    /// @notice Mapping to store auction params (i.e. counters)\\n    mapping(ShelterAuctionParams param => uint value) params;\\n\\n    /// @notice Hold all positions. Any record should not be removed\\n    mapping(uint positionId => Position) positions;\\n\\n    /// @dev BidId => Bid. Hold all bids. Any record should not be removed\\n    mapping(uint bidId => AuctionBid) auctionBids;\\n\\n    /// @notice List of currently opened positions\\n    EnumerableSet.UintSet openPositions;\\n\\n    /// @notice Seller to position map\\n    /// At any moment each guild can have only one opened position to sell\\n    mapping(uint sellerGuildId => uint openedPositionId) sellerPosition;\\n\\n    /// @notice Position that the buyer is going to purchase.\\n    /// At any moment each guild can have only one opened position to purchase\\n    mapping(uint buyerGuildId => BuyerPositionData) buyerPosition;\\n\\n    /// @notice All open and close bids for the given position\\n    mapping(uint positionId => uint[] bidIds) positionToBidIds;\\n\\n    /// @notice Timestamp of the last bid for the auction\\n    mapping(uint positionId => uint timestamp) lastAuctionBidTs;\\n}\\n\\n  struct Position {\\n    bool open;\\n    /// @notice User that opens the position. The user belongs to the guild with id = {sellerGuildId}\\n    address seller;\\n\\n    /// @notice Assume that shelter can be stored as uint64\\n    uint64 shelterId;\\n\\n    uint128 positionId;\\n\\n    /// @notice Min allowed (initial) auction price. Only first bid is able to use it.\\n    uint128 minAuctionPrice;\\n\\n    uint128 sellerGuildId;\\n  }\\n\\n  struct AuctionBid {\\n    /// @notice Only last bid is opened, all previous bids are closed automatically\\n    bool open;\\n    /// @notice User that opens the bid. The user belongs to the guild with id = {buyerGuildId}\\n    address buyer;\\n\\n    uint128 bidId;\\n    uint128 positionId;\\n    /// @notice Bid amount in terms of game token. This amount is transferred from guild Bank to ShelterAuction balance\\n    uint128 amount;\\n    uint128 buyerGuildId;\\n  }\\n\\n  struct BuyerPositionData {\\n    /// @notice ID of the position that the buyer is going to purchase\\n    uint128 positionId;\\n\\n    /// @notice 0-based index of the opened bid in {positionToBidIds}\\n    uint128 bidIndex;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function positionBySeller(uint sellerGuildId_) external view returns (uint positionId);\\n  function positionByBuyer(uint buyerGuildId) external view returns (uint positionId, uint bidIndex);\\n  function posByShelter(uint shelterId_) external view returns (uint positionId);\\n}\",\"keccak256\":\"0x2139f56cdf5acc01ec04ce9deed599eca687f98b00c3d1969d4b78b97ff911d6\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IShelterController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IShelterController {\\n  /// @custom:storage-location erc7201:shelter.controller.main\\n  struct MainState {\\n    /// @notice List of items allowed to be purchased in the shelter\\n    mapping(uint shelterId => EnumerableSet.AddressSet) shelterItems;\\n\\n    /// @notice Data of items available for purchasing in the given shelter\\n    mapping(uint shelterId => mapping(address item => ShelterItemData)) shelterItemData;\\n\\n    // @notice Statistics how much items were purchased per day\\n    mapping(uint shelterId => mapping(uint32 epochDay => mapping(address item => uint))) countPurchasedItems;\\n\\n    /// @notice List of registered shelters in {biome}\\n    mapping(uint biome => EnumerableSet.UintSet shelterUids) shelters;\\n\\n    /// @notice Initial price of the shelters in game tokens\\n    mapping(uint shelterId => uint) shelterPrices;\\n\\n    /// @notice Shelters belong to a specific guild (not the player)\\n    /// Shelters can be free (don't belong to any guild)\\n    mapping(uint shelterId => uint guildId) shelterToGuild;\\n\\n    /// @notice Each guild can own 0 or 1 shelter\\n    mapping(uint guildId => uint shelterId) guildToShelter;\\n  }\\n\\n  struct ShelterItemData {\\n    /// @notice Price of the item in pvp-points\\n    uint64 priceInPvpPoints;\\n    /// @notice Price of the item game token\\n    uint128 priceInGameToken;\\n    /// @notice Max number of items that can be purchases per day in the shelter. 0 - no limitations\\n    uint16 maxItemsPerDayLimit;\\n  }\\n\\n  /// ----------------------------------------------------------------------------------------------\\n\\n  function clearShelter(uint guildId) external;\\n  function guildToShelter(uint guildId) external view returns (uint shelterId);\\n  function changeShelterOwner(uint shelterId, uint newOwnerGuildId) external;\\n  function shelterToGuild(uint shelterId) external view returns (uint guildId);\\n}\",\"keccak256\":\"0xc8b28682a31cb937edc424881e770259f07587eb9fb64de723d9b8ff6369f322\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStatController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IStatController {\\n\\n  /// @custom:storage-location erc7201:stat.controller.main\\n  struct MainState {\\n    mapping(bytes32 => bytes32[]) heroTotalAttributes;\\n    /// @dev heroAdr+heroId => int32 packed strength, dexterity, vitality, energy\\n    mapping(bytes32 => bytes32) _heroCore;\\n    mapping(bytes32 => bytes32[]) heroBonusAttributes;\\n    mapping(bytes32 => bytes32[]) heroTemporallyAttributes;\\n    /// @dev heroAdr+heroId => uint32 packed level, experience, life, mana, lifeChances\\n    mapping(bytes32 => bytes32) heroStats;\\n    /// @dev heroAdr+heroId+itemSlot => itemAdr + itemId\\n    mapping(bytes32 => bytes32) heroSlots;\\n    /// @dev heroAdr+heroId => busy slots uint8[] packed\\n    mapping(bytes32 => bytes32) heroBusySlots;\\n    mapping(bytes32 => EnumerableSet.AddressSet) usedConsumables;\\n    /// @dev heroCustomDataV2 is used instead\\n    mapping(bytes32 => mapping(bytes32 => uint)) _deprecated_heroCustomData;\\n    mapping(bytes32 => uint) globalCustomData;\\n\\n    /// @notice packNftIdWithValue(hero, heroId, ngLevel) => hero custom data map\\n    /// @dev initially it was packedHero => hero custom data map\\n    mapping(bytes32 => EnumerableMap.Bytes32ToUintMap) heroCustomDataV2;\\n  }\\n\\n\\n  enum ATTRIBUTES {\\n    // core\\n    STRENGTH, // 0\\n    DEXTERITY, // 1\\n    VITALITY, // 2\\n    ENERGY, // 3\\n    // attributes\\n    DAMAGE_MIN, // 4\\n    DAMAGE_MAX, // 5\\n    ATTACK_RATING, // 6\\n    DEFENSE, // 7\\n    BLOCK_RATING, // 8\\n    LIFE, // 9\\n    MANA, // 10\\n    // resistance\\n    FIRE_RESISTANCE, // 11\\n    COLD_RESISTANCE, // 12\\n    LIGHTNING_RESISTANCE, // 13\\n    // dmg against\\n    DMG_AGAINST_HUMAN, // 14\\n    DMG_AGAINST_UNDEAD, // 15\\n    DMG_AGAINST_DAEMON, // 16\\n    DMG_AGAINST_BEAST, // 17\\n\\n    // defence against\\n    DEF_AGAINST_HUMAN, // 18\\n    DEF_AGAINST_UNDEAD, // 19\\n    DEF_AGAINST_DAEMON, // 20\\n    DEF_AGAINST_BEAST, // 21\\n\\n    // --- unique, not augmentable\\n    // hero will not die until have positive chances\\n    LIFE_CHANCES, // 22\\n    // increase chance to get an item\\n    MAGIC_FIND, // 23\\n    // decrease chance to get an item\\n    DESTROY_ITEMS, // 24\\n    // percent of chance x2 dmg\\n    CRITICAL_HIT, // 25\\n    // dmg factors\\n    MELEE_DMG_FACTOR, // 26\\n    FIRE_DMG_FACTOR, // 27\\n    COLD_DMG_FACTOR, // 28\\n    LIGHTNING_DMG_FACTOR, // 29\\n    // increase attack rating on given percent\\n    AR_FACTOR, // 30\\n    // percent of damage will be converted to HP\\n    LIFE_STOLEN_PER_HIT, // 31\\n    // amount of mana restored after each battle\\n    MANA_AFTER_KILL, // 32\\n    // reduce all damage on percent after all other reductions\\n    DAMAGE_REDUCTION, // 33\\n\\n    // -- statuses\\n    // chance to stun an enemy, stunned enemy skip next hit\\n    STUN, // 34\\n    // chance burn an enemy, burned enemy will loss 50% of defence\\n    BURN, // 35\\n    // chance freeze an enemy, frozen enemy will loss 50% of MELEE damage\\n    FREEZE, // 36\\n    // chance to reduce enemy's attack rating on 50%\\n    CONFUSE, // 37\\n    // chance curse an enemy, cursed enemy will loss 50% of resistance\\n    CURSE, // 38\\n    // percent of dmg return to attacker\\n    REFLECT_DAMAGE_MELEE, // 39\\n    REFLECT_DAMAGE_MAGIC, // 40\\n    // chance to poison enemy, poisoned enemy will loss 10% of the current health\\n    POISON, // 41\\n    // reduce chance get any of uniq statuses\\n    RESIST_TO_STATUSES, // 42\\n\\n    END_SLOT // 43\\n  }\\n\\n  // possible\\n  // HEAL_FACTOR\\n\\n  struct CoreAttributes {\\n    int32 strength;\\n    int32 dexterity;\\n    int32 vitality;\\n    int32 energy;\\n  }\\n\\n  struct ChangeableStats {\\n    uint32 level;\\n    uint32 experience;\\n    uint32 life;\\n    uint32 mana;\\n    uint32 lifeChances;\\n  }\\n\\n  enum ItemSlots {\\n    UNKNOWN, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    BOOTS, // 6\\n    RIGHT_RING, // 7\\n    LEFT_RING, // 8\\n    RIGHT_HAND, // 9\\n    LEFT_HAND, // 10\\n    TWO_HAND, // 11\\n    SKILL_1, // 12\\n    SKILL_2, // 13\\n    SKILL_3, // 14\\n    END_SLOT // 15\\n  }\\n\\n  struct NftItem {\\n    address token;\\n    uint tokenId;\\n  }\\n\\n  enum Race {\\n    UNKNOWN, // 0\\n    HUMAN, // 1\\n    UNDEAD, // 2\\n    DAEMON, // 3\\n    BEAST, // 4\\n    END_SLOT // 5\\n  }\\n\\n  struct ChangeAttributesInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    int32[] changeAttributes;\\n    bool add;\\n    bool temporally;\\n  }\\n\\n  struct BuffInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    uint32 heroLevel;\\n    address[] buffTokens;\\n    uint[] buffTokenIds;\\n  }\\n\\n  /// @dev This struct is used inside event, so it's moved here from lib\\n  struct ActionInternalInfo {\\n    int32[] posAttributes;\\n    int32[] negAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintedItems;\\n  }\\n\\n  function initNewHero(address token, uint tokenId, uint heroClass) external;\\n\\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory);\\n\\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32);\\n\\n  function heroAttributesLength(address token, uint tokenId) external view returns (uint);\\n\\n  function heroBaseAttributes(address token, uint tokenId) external view returns (CoreAttributes memory);\\n\\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint);\\n\\n  function globalCustomData(bytes32 index) external view returns (uint);\\n\\n  function heroStats(address token, uint tokenId) external view returns (ChangeableStats memory);\\n\\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked);\\n\\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory);\\n\\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function levelUp(address token, uint tokenId, uint heroClass, CoreAttributes memory change) external returns (uint newLvl);\\n\\n  function changeHeroItemSlot(\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) external;\\n\\n  function changeCurrentStats(\\n    address token,\\n    uint tokenId,\\n    ChangeableStats memory change,\\n    bool increase\\n  ) external;\\n\\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external;\\n\\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external;\\n\\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external;\\n\\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external;\\n\\n  function buffHero(BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed);\\n\\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external;\\n\\n  function setGlobalCustomData(bytes32 index, uint value) external;\\n\\n  /// @notice Restore life and mana during reinforcement\\n  /// @dev Life and mana will be increased on ((current life/mana attr value) - (prev life/mana attr value))\\n  /// @param prevAttributes Hero attributes before reinforcement\\n  function restoreLifeAndMana(address heroToken, uint heroTokenId, int32[] memory prevAttributes) external;\\n\\n  function reborn(address heroToken, uint heroTokenId, uint heroClass) external;\\n}\\n\",\"keccak256\":\"0x76f41b42703aa0c36784f125a2d66ca2f1f642ab23f34da31e3982a48259f802\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStoryController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../lib/ControllerContextLib.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\nimport \\\"./IHeroController.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n\\ninterface IStoryController {\\n\\n  enum AnswerResultId {\\n    UNKNOWN, // 0\\n    SUCCESS, // 1\\n    ATTRIBUTE_FAIL, // 2\\n    RANDOM_FAIL, // 3\\n    DELAY_FAIL, // 4\\n    HERO_CUSTOM_DATA_FAIL, // 5\\n    GLOBAL_CUSTOM_DATA_FAIL, // 6\\n\\n    END_SLOT\\n  }\\n\\n  enum CustomDataResult {\\n    UNKNOWN, // 0\\n    HERO_SUCCESS, // 1\\n    HERO_FAIL, // 2\\n    GLOBAL_SUCCESS, // 3\\n    GLOBAL_FAIL, // 4\\n\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:story.controller.main\\n  struct MainState {\\n\\n    // --- STORY REG INFO ---\\n\\n    /// @dev Uniq story identification.\\n    mapping(uint32 => uint16) storyIds;\\n    /// @dev Revers mapping for stories for using in the next object rewrite logic.\\n    mapping(uint16 => uint32) idToStory;\\n    /// @dev Store used ids for stories.\\n    mapping(uint16 => bool) _usedStoryIds;\\n    /// @dev Prevent register the story twice\\n    mapping(uint32 => bool) registeredStories;\\n\\n    // --- ANSWER MAPPING ---\\n\\n    /// @dev storyId => all story pages. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.UintSet) allStoryPages;\\n\\n    /// @dev storyId => all possible answers. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.Bytes32Set) allStoryAnswers;\\n\\n    /// @dev storyId + pageId + heroClass (zero is default answers) => storyId + pageId + heroClass (zero is default answers) + answerId\\n    mapping(bytes32 => bytes32[]) answers;\\n    /// @dev answerUnPackedId + answerResultId => nextPageIds (will be chosen randomly from this array)\\n    ///      where answerResultId is:\\n    ///      0 - unknown,\\n    ///      1 - success,\\n    ///      2 - attr fail\\n    ///      3 - random fail\\n    ///      4 - delay fail\\n    ///      5 - hero custom data fail\\n    ///      6 - global custom data fail\\n    ///      see COUNT_ANSWER_RESULT_IDS\\n    mapping(bytes32 => uint16[]) nextPageIds;\\n    /// @dev story + pageId + heroClass (zero is default answers) => random nextObjs (adr + id, like packed nft id)\\n    mapping(bytes32 => uint32[]) nextObjectsRewrite;\\n\\n    /// @dev answerPackedId => packed array of uint32[]\\n    ///      0 - random requirement(uint32, 1 - 99% success of this action, zero means no check)\\n    ///      1 - delay requirement(uint32, if time since the last call more than this value the check is fail, zero means no check)\\n    ///      2 - isFinalAnswer(uint8)\\n    mapping(bytes32 => bytes32) answerAttributes;\\n\\n    // --- ANSWER REQUIREMENTS ---\\n\\n    /// @dev answerPackedId => array of AttributeRequirementsPacked\\n    mapping(bytes32 => bytes32[]) attributeRequirements;\\n    /// @dev answerPackedId=> array of ItemRequirementsPacked\\n    mapping(bytes32 => bytes32[]) itemRequirements;\\n    /// @dev answerPackedId => array of TokenRequirementsPacked\\n    mapping(bytes32 => bytes32[]) tokenRequirements;\\n    /// @dev answerPackedId => custom data for hero\\n    mapping(bytes32 => CustomDataRequirementPacked[]) heroCustomDataRequirement;\\n    /// @dev answerPackedId => global custom data\\n    mapping(bytes32 => CustomDataRequirementPacked[]) globalCustomDataRequirement;\\n\\n    // --- ANSWER RESULTS ---\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) successInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) successInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) successInfoMintItems;\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) failInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) failInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) failInfoMintItems;\\n\\n    /// @dev answerUnPackedId + CustomDataResult => custom data array change\\n    ///      where CustomDataResult is\\n    ///      1 - hero success\\n    ///      2 - hero fail\\n    ///      3 - global success\\n    ///      4 - global fail\\n    ///      see COUNT_CUSTOM_DATA_RESULT_IDS\\n    mapping(bytes32 => bytes32[]) customDataResult;\\n\\n    /// @notice answerPackedId => slot+chance+stopIfBurnt\\n    /// @dev Since SIP-003 the items are not burn but broke\\n    mapping(bytes32 => bytes32[]) burnItem;\\n\\n    // --- GENERAL STORY REQUIREMENTS ---\\n\\n    /// @dev story => Custom hero data requirements for a story. If exist and hero is not eligible should be not chose in a dungeon.\\n    mapping(uint => CustomDataRequirementRangePacked[]) storyRequiredHeroData;\\n    /// @dev story => Minimal level for the history. 0 means no requirements.\\n    mapping(uint => uint) storyRequiredLevel;\\n\\n    // --- HERO STATES ---\\n\\n    /// @dev hero + heroId + storyId => pageId + heroLastActionTS\\n    mapping(bytes32 => bytes32) heroState;\\n\\n    // --- OTHER ---\\n\\n    /// @dev storyId => build hash for the last update\\n    mapping(uint16 => uint) storyBuildHash;\\n\\n    /// @notice Number of already minted items by the user within the given iteration of the story.\\n    /// Only minting of the given number of items is allowed per iteration (see MAX_MINTED_ITEMS_PER_ITERATION).\\n    /// @dev hero, heroId, story => mintedInIteration\\n    /// This map is not cleared: storyId:objectId is 1:1, each object has own sequence of iterations without duplicates\\n    mapping(bytes32 => mapping(uint iteration => uint countMintedItems)) mintedInIteration;\\n\\n    /// @notice True if the story is allowed to be skipped, see SCR-1248\\n    EnumerableSet.UintSet skippableStory;\\n  }\\n\\n  /// @dev We need to have flat structure coz Solidity can not handle arrays of structs properly\\n  struct StoryMetaInfo {\\n    uint16 storyId;\\n\\n    // --- story reqs\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n    uint minLevel;\\n\\n    // --- answer reqs\\n\\n    AnswersMeta answersMeta;\\n    AnswerNextPageMeta answerNextPage;\\n    AnswerAttributeRequirementsMeta answerAttributeRequirements;\\n    AnswerItemRequirementsMeta answerItemRequirements;\\n    AnswerTokenRequirementsMeta answerTokenRequirements;\\n    AnswerAttributesMeta answerAttributes;\\n    AnswerCustomDataMeta answerHeroCustomDataRequirement;\\n    AnswerCustomDataMeta answerGlobalCustomDataRequirement;\\n\\n    // --- answer results\\n\\n    AnswerBurnRandomItemMeta answerBurnRandomItemMeta;\\n    NextObjRewriteMeta nextObjRewriteMeta;\\n\\n    // --- story results\\n\\n    AnswerResultMeta successInfo;\\n    AnswerResultMeta failInfo;\\n\\n    AnswerCustomDataResultMeta successHeroCustomData;\\n    AnswerCustomDataResultMeta failHeroCustomData;\\n    AnswerCustomDataResultMeta successGlobalCustomData;\\n    AnswerCustomDataResultMeta failGlobalCustomData;\\n  }\\n\\n  struct NextObjRewriteMeta {\\n    uint16[] nextObjPageIds;\\n    uint8[] nextObjHeroClasses;\\n    uint32[][] nextObjIds;\\n  }\\n\\n  struct AnswersMeta {\\n    uint16[] answerPageIds;\\n    uint8[] answerHeroClasses;\\n    uint16[] answerIds;\\n  }\\n\\n  struct AnswerNextPageMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint8[] answerResultIds;\\n    uint16[][] answerNextPageIds;\\n  }\\n\\n  struct AnswerAttributeRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    bool[][] cores;\\n    uint8[][] ids;\\n    int32[][] values;\\n  }\\n\\n  struct AnswerItemRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireItems;\\n    bool[][] requireItemBurn;\\n    bool[][] requireItemEquipped;\\n  }\\n\\n  struct AnswerTokenRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireToken;\\n    uint88[][] requireAmount;\\n    bool[][] requireTransfer;\\n  }\\n\\n  struct AnswerAttributesMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint32[] randomRequirements;\\n    uint32[] delayRequirements;\\n    bool[] isFinalAnswer;\\n  }\\n\\n  struct AnswerCustomDataMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    bool[][] mandatory;\\n    uint64[][] dataValuesMin;\\n    uint64[][] dataValuesMax;\\n  }\\n\\n  struct AnswerResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    uint8[][] attributeIds;\\n    /// @dev Max value is limitied by int24, see toBytes32ArrayWithIds impl\\n    int32[][] attributeValues;\\n\\n    uint32[] experience;\\n    int32[] heal;\\n    int32[] manaRegen;\\n    int32[] lifeChancesRecovered;\\n    int32[] damage;\\n    int32[] manaConsumed;\\n\\n    address[][] mintItems;\\n    uint32[][] mintItemsChances;\\n  }\\n\\n  struct AnswerCustomDataResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    int16[][] dataValues;\\n  }\\n\\n  struct AnswerBurnRandomItemMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    /// @notice 0 - random slot\\n    uint8[][] slots;\\n    /// @notice typical chances are [0..100] (no decimals here)\\n    uint64[][] chances;\\n    /// @notice Since SIP-003 the burning is replaced by breaking bu the name is kept as is\\n    bool[][] isStopIfBurnt;\\n  }\\n\\n  struct CustomDataRequirementPacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + mandatory(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct CustomDataRequirementRangePacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + isHeroData(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct StatsChange {\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n  }\\n\\n  struct StoryActionContext {\\n    uint stageId;\\n    uint iteration;\\n    bytes32 answerIdHash;\\n    bytes32 answerAttributes;\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IOracle oracle;\\n    uint8 heroClassFromAnswerHash;\\n    uint8 biome;\\n    uint16 storyId;\\n    uint16 storyIdFromAnswerHash;\\n    uint16 pageIdFromAnswerHash;\\n    uint16 answerNumber;\\n    uint16 pageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint40 heroLastActionTS;\\n    uint80 heroTokenId;\\n    IStatController.ChangeableStats heroStats;\\n  }\\n\\n  // --- WRITE ---\\n\\n  function storyAction(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) external returns (IGOC.ActionResult memory);\\n\\n  // --- READ ---\\n\\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function idToStory(uint16 id) external view returns (uint32 objectId);\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId);\\n\\n  function storyIds(uint32 objectId) external view returns (uint16);\\n\\n  function registeredStories(uint32 objectId) external view returns (bool);\\n\\n  function skippableStory(uint16 storyId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xeac9e7fe282320b84466c974533f30b7e4c96b8ce94d40a63ef394928059bc4a\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/ITreasury.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface ITreasury {\\n\\n  function balanceOfToken(address token) external view returns (uint);\\n\\n  function sendToDungeon(address dungeon, address token, uint amount) external;\\n}\\n\",\"keccak256\":\"0x0977372e2310cd09e7b99c5f2b1af75949bf18ebcabfd0fc114e4f8714760414\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IUserController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IUserController {\\n\\n  //region ------------------------ Data types\\n\\n  enum LootBoxKind {\\n    /// @notice small loot box - reward for the daily activity\\n    DAILY_0,\\n    /// @notice large loot box - reward for the weekly activity (daily activity is passed each ot of the 7 days)\\n    WEEKLY_1,\\n\\n    END_SLOT\\n  }\\n\\n  /// @dev registerPassedDungeon assumes that the whole struct takes single slot only, not more\\n  struct UserActivity {\\n    /// @notice A day for which the daily activity is calculated (see counterXXX below)\\n    /// The number of days since 1970-01-01\\n    uint32 epochDay;\\n\\n    /// @notice A week for which total count of daily activities were calculated\\n    /// The number of weeks since (1970-01-01 Thursday) - 3 days = (1969-12-29 Monday)\\n    uint32 epochWeek;\\n\\n    /// @notice Count of dungeons passed during the day\\n    uint32 counterPassedDungeons;\\n    /// @notice Count of PvP during the day\\n    uint32 counterPvp;\\n\\n    /// @notice Count of daily activities completed per the week\\n    uint16 dailyActivities;\\n\\n    /// @notice Daily activity is completed and small loot box is added to the earned loot boxes\\n    bool dailyLootBoxReceived;\\n    /// @notice Weekly activity is completed and large loot box is added to the earned loot boxes\\n    bool weeklyLootBoxReceived;\\n  }\\n\\n  struct EarnedLootBoxes {\\n    /// @notice Count of loot boxes earned by daily activity\\n    uint32 dailyCounter;\\n    /// @notice Count of loot boxes earned by weekly activity\\n    uint32 weeklyCounter;\\n  }\\n\\n  struct LootBoxConfig {\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n    uint maxDropItems;\\n  }\\n\\n  enum UserControllerParam {\\n    /// @notice Price of story skipping in game points\\n    PRICE_STORY_SKIPPING_1\\n  }\\n\\n  /// @custom:storage-location erc7201:user.controller.main\\n  struct MainState {\\n    /// @notice Amount of sacra required to rename user account\\n    uint feeRenaming;\\n\\n    /// @dev user EOA => account name\\n    mapping(address => string) userAccountName;\\n\\n    /// @dev name => user EOA, needs for checking uniq names\\n    mapping(string => address) nameToUserAccount;\\n\\n    /// @notice user => daily activity info\\n    mapping(address => UserActivity) userActivity;\\n\\n    /// @notice user => earned loot boxes\\n    mapping(address => EarnedLootBoxes) counterLootBoxes;\\n\\n    /// @notice Configs of loot boxes of various kinds\\n    mapping(LootBoxKind => LootBoxConfig) lootBoxConfig;\\n\\n    /// @dev Deprecated, controller is used instead.\\n    address userTokensVault;\\n\\n    /// @dev user EOA => account avatar\\n    mapping(address => string) userAvatar;\\n\\n    // @notice Hall of Fame: ngLevel [1...99] => who opened the NG_LEVEL first\\n    mapping(uint8 ngLevel => FameHallData) fameHall;\\n\\n    /// @notice Points earned for passing dungeons\\n    mapping(address user => uint gamePoints) gamePoints;\\n\\n    /// @notice List of objects (currently only stories) passed by the given account\\n    /// @dev hashes of the stories are as encodePacked(\\\"STORY_{ID}\\\")\\n    mapping(address user => EnumerableSet.Bytes32Set hashes) passedObjects;\\n\\n    /// @notice Values of various params, see {UserControllerParam}\\n    mapping(UserControllerParam paramId => uint value) userControllerParams;\\n  }\\n\\n  struct FameHallData {\\n    // ------------ slot 1\\n    /// @notice The hero who opened given the NG_LEVEL first\\n    address hero;\\n    uint64 heroId;\\n    // ------------ slot 2\\n    /// @notice The owner of the hero\\n    address heroOwner;\\n    /// @notice Timestamp of the moment of the opening given NG_LEVEL\\n    uint64 tsOpen;\\n  }\\n\\n  //endregion ------------------------ Data types\\n\\n  /// @notice Register daily activity - a dungeon was passed\\n  /// @param user Owner of the hero who has passed the dungeon\\n  function registerPassedDungeon(address user) external;\\n\\n  /// @notice Register daily activity - PvP was made\\n  /// @param user Owner of the hero who has taken participation in the PvP\\n  function registerPvP(address user, bool isWinner) external;\\n\\n  function registerFameHallHero(address hero, uint heroId, uint8 openedNgLevel) external;\\n\\n  function useGamePointsToSkipStore(address user, uint16 storyId) external;\\n\\n  function setStoryPassed(address user, uint16 storyId) external;\\n\\n  function isStoryPassed(address user, uint16 storyId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa6cb408a8c73afc71c4ebee178257123ee65ed09fb96c2a806b5a83e0dac2140\",\"license\":\"BUSL-1.1\"},\"contracts/lib/AppLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @notice Common internal utils, shared constants\\nlibrary AppLib {\\n\\n  /// @notice Biome owner has the right to receive 1% tax on any income in the biome. Decimals 3.\\n  /// The final value of tax is in the range [1..10]%, it depends on total liquidity staked by the guild\\n  uint internal constant BIOME_TAX_PERCENT_MIN = 1_000; // 1%\\n\\n  /// @notice Max possible value of biome owner tax percent, decimals 3.\\n  uint internal constant BIOME_TAX_PERCENT_MAX = 10_000; // 10%\\n\\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\\n  /// @dev Should NOT be used for third-party pools\\n  function approveIfNeeded(address token, uint amount, address spender) internal {\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\n      IERC20(token).approve(spender, type(uint).max);\\n    }\\n  }\\n\\n  /// @dev Remove from array the item with given id and move the last item on it place\\n  ///      Use with mapping for keeping indexes in correct ordering\\n  function removeIndexed(\\n    uint256[] storage array,\\n    mapping(uint256 => uint256) storage indexes,\\n    uint256 id\\n  ) internal {\\n    uint256 lastId = array[array.length - 1];\\n    uint256 index = indexes[id];\\n    indexes[lastId] = index;\\n    indexes[id] = type(uint256).max;\\n    array[index] = lastId;\\n    array.pop();\\n  }\\n\\n  /// @notice Return a-b OR zero if a < b\\n  function sub0(uint32 a, uint32 b) internal pure returns (uint32) {\\n    return a > b ? a - b : 0;\\n  }\\n}\\n\",\"keccak256\":\"0x0f7680143b82bce36ebc739a16cf8f2ede8a231a9448f3e56816c0710c66cc04\",\"license\":\"BUSL-1.1\"},\"contracts/lib/CalcLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\n\\nlibrary CalcLib {\\n\\n  uint32 public constant MAX_CHANCE = 1e9;\\n\\n  function minI32(int32 a, int32 b) internal pure returns (int32) {\\n    return a < b ? a : b;\\n  }\\n\\n  function max32(int32 a, int32 b) internal pure returns (int32) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function absDiff(int32 a, int32 b) internal pure returns (uint32) {\\n    if (!((a >= 0 && b >= 0) || (a <= 0 && b <= 0))) revert IAppErrors.AbsDiff(a, b);\\n    if (a < 0) {\\n      a = - a;\\n    }\\n    if (b < 0) {\\n      b = - b;\\n    }\\n    return uint32(uint(int(a >= b ? a - b : b - a)));\\n  }\\n\\n  function toUint(int32 n) internal pure returns (uint) {\\n    if (n <= 0) {\\n      return 0;\\n    }\\n    return uint(int(n));\\n  }\\n\\n  function toInt32(uint a) internal pure returns (int32){\\n    if (a >= uint(int(type(int32).max))) {\\n      return type(int32).max;\\n    }\\n    return int32(int(a));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandom(uint maxValue) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n\\n    uint salt = genSalt();\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), salt))) % (maxValue + 1));\\n  }\\n\\n  function genSalt() internal view returns (uint salt) {\\n    // skale has a RNG Endpoint\\n    if (\\n      block.chainid == uint(1351057110)\\n      || block.chainid == uint(37084624)\\n    ) {\\n      assembly {\\n        let freemem := mload(0x40)\\n        let start_addr := add(freemem, 0)\\n        if iszero(staticcall(gas(), 0x18, 0, 0, start_addr, 32)) {\\n          invalid()\\n        }\\n        salt := mload(freemem)\\n      }\\n    }\\n  }\\n\\n  function pseudoRandomUint32(uint32 maxValue) internal view returns (uint32) {\\n    return uint32(pseudoRandom(uint(maxValue)));\\n  }\\n\\n  /// @notice Generate pseudo-random uint in the range [0..maxValue) using Solady pseudo-random function\\n  function nextPrng(LibPRNG.PRNG memory prng, uint maxValue) internal pure returns (uint) {\\n    return LibPRNG.next(prng) % maxValue;\\n  }\\n\\n  /// @notice pseudoRandomUint32 with customizable pseudoRandom()\\n  function pseudoRandomUint32Flex(\\n    uint32 maxValue,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint32) {\\n    return uint32(random_(uint(maxValue)));\\n  }\\n\\n  function pseudoRandomInt32(int32 maxValue) internal view returns (int32) {\\n    bool neg;\\n    if (maxValue < 0) {\\n      neg = true;\\n      maxValue = - maxValue;\\n    }\\n    uint32 v = uint32(pseudoRandom(uint(int(maxValue))));\\n    return neg\\n      ? - int32(int(uint(v)))\\n      : int32(int(uint(v)));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandomWithSeed(uint maxValue, uint seed) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    uint salt = genSalt();\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), seed, salt))) % (maxValue + 1));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  function pseudoRandomInRange(uint min, uint max) internal view returns (uint) {\\n    if (min >= max) {\\n      return max;\\n    }\\n    uint r = pseudoRandom(max - min);\\n    return min + r;\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  ///      Equal to pseudoRandomInRange(min, max, pseudoRandom)\\n  function pseudoRandomInRangeFlex(\\n    uint min,\\n    uint max,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint) {\\n    return min >= max ? max : min + random_(max - min);\\n  }\\n\\n  function minusWithZeroFloor(uint a, uint b) internal pure returns (uint){\\n    if (a <= b) {\\n      return 0;\\n    }\\n    return a - b;\\n  }\\n\\n  function minusWithMinFloorI32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) - int(b) < type(int32).min) {\\n      return type(int32).min;\\n    }\\n    return a - b;\\n  }\\n\\n  function plusWithMaxFloor32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) + int(b) >= type(int32).max) {\\n      return type(int32).max;\\n    }\\n    return a + b;\\n  }\\n\\n  function sqrt(uint x) internal pure returns (uint z) {\\n    assembly {\\n    // Start off with z at 1.\\n      z := 1\\n\\n    // Used below to help find a nearby power of 2.\\n      let y := x\\n\\n    // Find the lowest power of 2 that is at least sqrt(x).\\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n        y := shr(128, y) // Like dividing by 2 ** 128.\\n        z := shl(64, z) // Like multiplying by 2 ** 64.\\n      }\\n      if iszero(lt(y, 0x10000000000000000)) {\\n        y := shr(64, y) // Like dividing by 2 ** 64.\\n        z := shl(32, z) // Like multiplying by 2 ** 32.\\n      }\\n      if iszero(lt(y, 0x100000000)) {\\n        y := shr(32, y) // Like dividing by 2 ** 32.\\n        z := shl(16, z) // Like multiplying by 2 ** 16.\\n      }\\n      if iszero(lt(y, 0x10000)) {\\n        y := shr(16, y) // Like dividing by 2 ** 16.\\n        z := shl(8, z) // Like multiplying by 2 ** 8.\\n      }\\n      if iszero(lt(y, 0x100)) {\\n        y := shr(8, y) // Like dividing by 2 ** 8.\\n        z := shl(4, z) // Like multiplying by 2 ** 4.\\n      }\\n      if iszero(lt(y, 0x10)) {\\n        y := shr(4, y) // Like dividing by 2 ** 4.\\n        z := shl(2, z) // Like multiplying by 2 ** 2.\\n      }\\n      if iszero(lt(y, 0x8)) {\\n      // Equivalent to 2 ** z.\\n        z := shl(1, z)\\n      }\\n\\n    // Shifting right by 1 is like dividing by 2.\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n\\n    // Compute a rounded down version of z.\\n      let zRoundDown := div(x, z)\\n\\n    // If zRoundDown is smaller, use it.\\n      if lt(zRoundDown, z) {\\n        z := zRoundDown\\n      }\\n    }\\n  }\\n\\n  /*********************************************\\n *              PRB-MATH                      *\\n *   https://github.com/hifi-finance/prb-math *\\n **********************************************/\\n  /// @notice Calculates the binary logarithm of x.\\n  ///\\n  /// @dev Based on the iterative approximation algorithm.\\n  /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n  ///\\n  /// Requirements:\\n  /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n  ///\\n  /// Caveats:\\n  /// - The results are nor perfectly accurate to the last decimal,\\n  ///   due to the lossy precision of the iterative approximation.\\n  ///\\n  /// @param x The unsigned 60.18-decimal fixed-point number for which\\n  ///           to calculate the binary logarithm.\\n  /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n  function log2(uint256 x) internal pure returns (uint256 result) {\\n    if (x < 1e18) revert IAppErrors.TooLowX(x);\\n\\n    // Calculate the integer part of the logarithm\\n    // and add it to the result and finally calculate y = x * 2^(-n).\\n    uint256 n = mostSignificantBit(x / 1e18);\\n\\n    // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number.\\n    // The operation can't overflow because n is maximum 255 and SCALE is 1e18.\\n    uint256 rValue = n * 1e18;\\n\\n    // This is y = x * 2^(-n).\\n    uint256 y = x >> n;\\n\\n    // If y = 1, the fractional part is zero.\\n    if (y == 1e18) {\\n      return rValue;\\n    }\\n\\n    // Calculate the fractional part via the iterative approximation.\\n    // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n    for (uint256 delta = 5e17; delta > 0; delta >>= 1) {\\n      y = (y * y) / 1e18;\\n\\n      // Is y^2 > 2 and so in the range [2,4)?\\n      if (y >= 2 * 1e18) {\\n        // Add the 2^(-m) factor to the logarithm.\\n        rValue += delta;\\n\\n        // Corresponds to z/2 on Wikipedia.\\n        y >>= 1;\\n      }\\n    }\\n    return rValue;\\n  }\\n\\n  /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n  /// @dev See the note on msb in the \\\"Find First Set\\\"\\n  ///      Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n  /// @param x The uint256 number for which to find the index of the most significant bit.\\n  /// @return msb The index of the most significant bit as an uint256.\\n  //noinspection NoReturn\\n  function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n    if (x >= 2 ** 128) {\\n      x >>= 128;\\n      msb += 128;\\n    }\\n    if (x >= 2 ** 64) {\\n      x >>= 64;\\n      msb += 64;\\n    }\\n    if (x >= 2 ** 32) {\\n      x >>= 32;\\n      msb += 32;\\n    }\\n    if (x >= 2 ** 16) {\\n      x >>= 16;\\n      msb += 16;\\n    }\\n    if (x >= 2 ** 8) {\\n      x >>= 8;\\n      msb += 8;\\n    }\\n    if (x >= 2 ** 4) {\\n      x >>= 4;\\n      msb += 4;\\n    }\\n    if (x >= 2 ** 2) {\\n      x >>= 2;\\n      msb += 2;\\n    }\\n    if (x >= 2 ** 1) {\\n      // No need to shift x any more.\\n      msb += 1;\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x7df92aac39866072cfba309c8e1928ab48c64c01fec09659a783f9708bd70750\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ControllerContextLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\nimport \\\"../interfaces/IDungeonFactory.sol\\\";\\nimport \\\"../interfaces/IReinforcementController.sol\\\";\\nimport \\\"../interfaces/IGameToken.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IUserController.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IRewardsPool.sol\\\";\\nimport \\\"../interfaces/IPvpController.sol\\\";\\nimport \\\"../interfaces/IItemBoxController.sol\\\";\\n\\n/// @notice Provide context-struct with all controller addresses and routines for lazy init\\n/// Usage:\\n///       Create an instance of the structure\\n///               cc = ControllerContextLib.init(controller);\\n///       access controller directly\\n///               cc.controller.xxx();\\n///       access other contracts indirectly\\n///               sc = ControllerContextLib.statController(cc);\\nlibrary ControllerContextLib {\\n  //region ----------------- Data types\\n  enum CacheIndex {\\n    STAT_CONTROLLER_0,\\n    STORY_CONTROLLER_1,\\n    ORACLE_2,\\n    TREASURY_3,\\n    DUNGEON_FACTORY_4,\\n    GOC_5,\\n    REINFORCEMENT_CONTROLLER_6,\\n    ITEM_CONTROLLER_7,\\n    HERO_CONTROLLER_8,\\n    GAME_TOKEN_9,\\n    USER_CONTROLLER_10,\\n    GUILD_CONTROLLER_11,\\n    PVP_CONTROLLER_12,\\n    REWARDS_POOL_13,\\n    ITEM_BOX_CONTROLLER_14\\n  }\\n\\n  uint constant private CACHE_SIZE = 15;\\n\\n  struct ControllerContext {\\n    /// @notice Direct access to the controller\\n    IController controller;\\n\\n    /// @notice All lazy-initialized addresses in order of {CacheIndex}\\n    address[CACHE_SIZE] cache;\\n  }\\n  //endregion ----------------- Data types\\n\\n  //region ----------------- Initialization and _lazyInit\\n  function init(IController controller) internal pure returns (ControllerContext memory cc) {\\n    cc.controller = controller;\\n    return cc;\\n  }\\n\\n  function _lazyInit(\\n    ControllerContext memory cc,\\n    CacheIndex index,\\n    function () external view returns(address) getter\\n  ) internal view returns (address) {\\n    address a = cc.cache[uint(index)];\\n    if (a != address(0)) return a;\\n\\n    cc.cache[uint(index)] = getter();\\n    return cc.cache[uint(index)];\\n  }\\n  //endregion ----------------- Initialization and _lazyInit\\n\\n  //region ----------------- Access with lazy initialization\\n  function statController(ControllerContext memory cc) internal view returns (IStatController) {\\n    return IStatController(_lazyInit(cc, CacheIndex.STAT_CONTROLLER_0, cc.controller.statController));\\n  }\\n\\n  function storyController(ControllerContext memory cc) internal view returns (IStoryController) {\\n    return IStoryController(_lazyInit(cc, CacheIndex.STORY_CONTROLLER_1, cc.controller.storyController));\\n  }\\n\\n  function oracle(ControllerContext memory cc) internal view returns (IOracle) {\\n    return IOracle(_lazyInit(cc, CacheIndex.ORACLE_2, cc.controller.oracle));\\n  }\\n\\n  function treasury(ControllerContext memory cc) internal view returns (ITreasury) {\\n    return ITreasury(_lazyInit(cc, CacheIndex.TREASURY_3, cc.controller.treasury));\\n  }\\n\\n  function dungeonFactory(ControllerContext memory cc) internal view returns (IDungeonFactory) {\\n    return IDungeonFactory(_lazyInit(cc, CacheIndex.DUNGEON_FACTORY_4, cc.controller.dungeonFactory));\\n  }\\n\\n  function gameObjectController(ControllerContext memory cc) internal view returns (IGOC) {\\n    return IGOC(_lazyInit(cc, CacheIndex.GOC_5, cc.controller.gameObjectController));\\n  }\\n\\n  function reinforcementController(ControllerContext memory cc) internal view returns (IReinforcementController) {\\n    return IReinforcementController(_lazyInit(cc, CacheIndex.REINFORCEMENT_CONTROLLER_6, cc.controller.reinforcementController));\\n  }\\n\\n  function itemController(ControllerContext memory cc) internal view returns (IItemController) {\\n    return IItemController(_lazyInit(cc, CacheIndex.ITEM_CONTROLLER_7, cc.controller.itemController));\\n  }\\n\\n  function heroController(ControllerContext memory cc) internal view returns (IHeroController) {\\n    return IHeroController(_lazyInit(cc, CacheIndex.HERO_CONTROLLER_8, cc.controller.heroController));\\n  }\\n\\n  function gameToken(ControllerContext memory cc) internal view returns (IGameToken) {\\n    return IGameToken(_lazyInit(cc, CacheIndex.GAME_TOKEN_9, cc.controller.gameToken));\\n  }\\n\\n  function userController(ControllerContext memory cc) internal view returns (IUserController) {\\n    return IUserController(_lazyInit(cc, CacheIndex.USER_CONTROLLER_10, cc.controller.userController));\\n  }\\n\\n  function guildController(ControllerContext memory cc) internal view returns (IGuildController) {\\n    return IGuildController(_lazyInit(cc, CacheIndex.GUILD_CONTROLLER_11, cc.controller.guildController));\\n  }\\n\\n  function pvpController(ControllerContext memory cc) internal view returns (IPvpController) {\\n    return IPvpController(_lazyInit(cc, CacheIndex.PVP_CONTROLLER_12, cc.controller.pvpController));\\n  }\\n\\n  function rewardsPool(ControllerContext memory cc) internal view returns (IRewardsPool) {\\n    return IRewardsPool(_lazyInit(cc, CacheIndex.REWARDS_POOL_13, cc.controller.rewardsPool));\\n  }\\n\\n  function itemBoxController(ControllerContext memory cc) internal view returns (IItemBoxController) {\\n    return IItemBoxController(_lazyInit(cc, CacheIndex.ITEM_BOX_CONTROLLER_14, cc.controller.itemBoxController));\\n  }\\n  //endregion ----------------- Access with lazy initialization\\n}\",\"keccak256\":\"0x8fa8be52cfba698f7e5a39c5043f05bddd9629868982402238b4294a9bbadb68\",\"license\":\"BUSL-1.1\"},\"contracts/lib/FightLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IFightCalculator.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../lib/StatLib.sol\\\";\\nimport \\\"../lib/CalcLib.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\nimport \\\"../solady/FixedPointMathLib.sol\\\";\\n\\nlibrary FightLib {\\n  using PackingLib for bytes32;\\n  using CalcLib for int32;\\n\\n  //region ------------------------ Data types\\n  struct AttackResult {\\n    int32 defenderHealth;\\n    int32 damage;\\n    int32 lifeStolen;\\n    int32 reflectDamage;\\n    uint8 critical;\\n    uint8 missed;\\n    uint8 blocked;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Constants\\n  uint internal constant MAX_FIGHT_CYCLES = 100;\\n  int32 internal constant RESISTANCE_DENOMINATOR = 100;\\n  int32 internal constant _MAX_RESIST = 90;\\n\\n  /// @notice SIP-002 constant: desired capacity\\n  uint internal constant CAPACITY_RESISTS_DEFS = 90;\\n  /// @notice SIP-002 constant: desired capacity\\n  uint internal constant CAPACITY_CRITICAL_HIT_STATUSES = 100;\\n  /// @notice SIP-002 constant: the factor of how fast the value will reach the capacity\\n  uint internal constant K_FACTOR = 100;\\n  /// @notice ln(2), decimals 18\\n  int internal constant LN2 = 693147180559945309;\\n\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Main logic\\n\\n  /// @dev Items ownership must be checked before\\n  ///      it is no write actions but we need to emit an event for properly handle the battle on UI\\n  ///      return huge structs more expensive that call an event here\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests\\n  function fight(\\n    IItemController ic,\\n    IFightCalculator.FightCall memory callData,\\n    IFightCalculator.FightCallAdd memory callDataAdd,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (\\n    IFightCalculator.FightResult memory\\n  ) {\\n    IFightCalculator.FightInfoInternal memory fResult = prepareFightInternalInfo(ic, callData.fighterA, callData.fighterB);\\n\\n    fightProcessing(fResult, random_);\\n\\n    if (callDataAdd.fightId == 0) {\\n      // not pvp fight\\n      emit IApplicationEvents.FightResultProcessed(callDataAdd.msgSender, fResult, callData, callData.iteration);\\n    } else {\\n      // pvp fight\\n      emit IApplicationEvents.PvpFightResultProcessed(callDataAdd.fightId, callDataAdd.msgSender, fResult, callData.turn, callData.heroAdr, callData.heroId);\\n    }\\n\\n    return IFightCalculator.FightResult({\\n      healthA: fResult.fighterA.health,\\n      healthB: fResult.fighterB.health,\\n      manaConsumedA: fResult.fighterA.manaConsumed,\\n      manaConsumedB: fResult.fighterB.manaConsumed\\n    });\\n  }\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ High level of internal logic\\n  function fightProcessing(\\n    IFightCalculator.FightInfoInternal memory fResult,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n\\n    bool firstA = calcFirstHit(fResult);\\n\\n    setStatuses(fResult, firstA, random_);\\n    setStatuses(fResult, !firstA, random_);\\n\\n    reduceAttributesByStatuses(fResult.fighterA.info.fighterAttributes, fResult.fighterA.statuses, fResult.fighterB.info.fighterAttributes);\\n    reduceAttributesByStatuses(fResult.fighterB.info.fighterAttributes, fResult.fighterB.statuses, fResult.fighterA.info.fighterAttributes);\\n\\n    AttackResult memory resultA = processAttack(fResult, true, random_);\\n    AttackResult memory resultB = processAttack(fResult, false, random_);\\n\\n    fResult.fighterA.statuses.gotCriticalHit = resultA.critical != 0;\\n    fResult.fighterA.statuses.missed = resultA.missed != 0;\\n    fResult.fighterA.statuses.hitBlocked = resultA.blocked != 0;\\n\\n    fResult.fighterB.statuses.gotCriticalHit = resultB.critical != 0;\\n    fResult.fighterB.statuses.missed = resultB.missed != 0;\\n    fResult.fighterB.statuses.hitBlocked = resultB.blocked != 0;\\n\\n    reduceHp(\\n      firstA ? resultA : resultB,\\n      firstA ? resultB : resultA,\\n      firstA ? fResult.fighterA : fResult.fighterB,\\n      firstA ? fResult.fighterB : fResult.fighterA\\n    );\\n\\n    // restore health from stolen life\\n    stealLife(fResult.fighterA, resultA);\\n    stealLife(fResult.fighterB, resultB);\\n  }\\n\\n  function processAttack(\\n    IFightCalculator.FightInfoInternal memory fResult,\\n    bool isA,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (AttackResult memory attackResult) {\\n\\n    int32 defenderHealth = isA ? fResult.fighterB.health : fResult.fighterA.health;\\n\\n    if (skipTurn(fResult, isA)) {\\n      return AttackResult({\\n        defenderHealth: defenderHealth,\\n        damage: 0,\\n        lifeStolen: 0,\\n        reflectDamage: 0,\\n        critical: 0,\\n        missed: 0,\\n        blocked: 0\\n      });\\n    }\\n\\n    IFightCalculator.FighterInfo memory attackerInfo = isA ? fResult.fighterA.info : fResult.fighterB.info;\\n    IFightCalculator.FighterInfo memory defenderInfo = isA ? fResult.fighterB.info : fResult.fighterA.info;\\n\\n    if (attackerInfo.attackType == IFightCalculator.AttackType.MELEE) {\\n      attackResult = meleeDamageCalculation(attackerInfo, defenderInfo, defenderHealth, random_);\\n    } else if (attackerInfo.attackType == IFightCalculator.AttackType.MAGIC) {\\n      attackResult = magicDamageCalculation(\\n        attackerInfo,\\n        defenderInfo,\\n        isA ? fResult.fighterA.magicAttack : fResult.fighterB.magicAttack,\\n        defenderHealth,\\n        random_\\n      );\\n    } else {\\n      revert IAppErrors.NotAType(uint(attackerInfo.attackType));\\n    }\\n  }\\n  //endregion ------------------------ High level of internal logic\\n\\n  //region ------------------------ Internal logic\\n  function prepareFightInternalInfo(\\n    IItemController ic,\\n    IFightCalculator.FighterInfo memory fighterA,\\n    IFightCalculator.FighterInfo memory fighterB\\n  ) internal view returns (IFightCalculator.FightInfoInternal memory) {\\n    IFightCalculator.FightInfoInternal memory fInfo;\\n    _setFightData(ic, fighterA, fInfo.fighterA);\\n    _setFightData(ic, fighterB, fInfo.fighterB);\\n    return fInfo;\\n  }\\n\\n  /// @dev A part of prepareFightInternalInfo\\n  function _setFightData(\\n    IItemController ic,\\n    IFightCalculator.FighterInfo memory fighter,\\n    IFightCalculator.Fighter memory dest\\n  ) internal view {\\n    dest.info = fighter;\\n    dest.health = int32(fighter.fighterStats.life);\\n    if (fighter.attackToken != address(0)) {\\n      if (fighter.attackType != IFightCalculator.AttackType.MAGIC) revert IAppErrors.NotMagic();\\n      dest.magicAttack = ic.itemAttackInfo(fighter.attackToken, fighter.attackTokenId);\\n    }\\n    // dest.manaConsumed is 0 by default, in current implementation we don't need to change it\\n  }\\n\\n  /// @param random_ Either _pseudoRandom or pseudo-random for ut\\n  function statusChance(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IItemController.AttackInfo memory attackerMA,\\n    IStatController.ATTRIBUTES index,\\n    int32 resist,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (bool) {\\n    int32 chance = _getChance(attackerInfo, attackerMA.aType, index, resist);\\n    if (chance == 0) {\\n      return false;\\n    }\\n    if (chance >= RESISTANCE_DENOMINATOR) {\\n      return true;\\n    }\\n    return random_(RESISTANCE_DENOMINATOR.toUint()) < chance.toUint();\\n  }\\n\\n  /// @notice set fResult.fighterB.statuses (for isA = true) or fResult.fighterA.statuses (for isA = false)\\n  /// @param random_ Either _pseudoRandom or pseudo-random for ut\\n  function setStatuses(\\n    IFightCalculator.FightInfoInternal memory fResult,\\n    bool isA,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    // setStatuses is called twice one by one: first time for A, second time for B\\n    // if stun is set for A, setStatuses is skipped for B completely\\n    if (!skipTurn(fResult, isA)) {\\n      IFightCalculator.FighterInfo memory attackerInfo = isA ? fResult.fighterA.info : fResult.fighterB.info;\\n      IFightCalculator.FighterInfo memory defenderInfo = isA ? fResult.fighterB.info : fResult.fighterA.info;\\n\\n      IItemController.AttackInfo memory attackerMA = isA ? fResult.fighterA.magicAttack : fResult.fighterB.magicAttack;\\n\\n      IFightCalculator.Statuses memory statuses = isA ? fResult.fighterB.statuses : fResult.fighterA.statuses;\\n\\n      int32 resist = _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.RESIST_TO_STATUSES);\\n\\n      statuses.stun = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.STUN, resist, random_);\\n      statuses.burn = statusChance(\\n        attackerInfo,\\n        attackerMA,\\n        IStatController.ATTRIBUTES.BURN,\\n        _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.FIRE_RESISTANCE),\\n        random_\\n      );\\n      statuses.freeze = statusChance(\\n        attackerInfo,\\n        attackerMA,\\n        IStatController.ATTRIBUTES.FREEZE,\\n        _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.COLD_RESISTANCE),\\n        random_\\n      );\\n      statuses.confuse = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.CONFUSE, resist, random_);\\n      statuses.curse = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.CURSE, resist, random_);\\n      statuses.poison = statusChance(attackerInfo, attackerMA, IStatController.ATTRIBUTES.POISON, resist, random_);\\n    }\\n  }\\n\\n  function magicDamageCalculation(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IFightCalculator.FighterInfo memory defenderInfo,\\n    IItemController.AttackInfo memory magicAttack,\\n    int32 defenderHealth,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (AttackResult memory attackResult) {\\n    // generate damage\\n    int32 damage = getMagicDamage(\\n      attackerInfo,\\n      magicAttack,\\n      CalcLib.pseudoRandomInRangeFlex(magicAttack.min.toUint(), magicAttack.max.toUint(), random_)\\n    );\\n    damage = increaseMagicDmgByFactor(damage, attackerInfo, magicAttack.aType);\\n    damage = increaseRaceDmg(damage, attackerInfo, defenderInfo.race);\\n    bool critical = isCriticalHit(attackerInfo, random_(RESISTANCE_DENOMINATOR.toUint()));\\n    damage = critical ? damage * 2 : damage;\\n\\n    // decrease damage\\n    damage = decreaseRaceDmg(damage, defenderInfo, attackerInfo.race);\\n    damage = decreaseDmgByDmgReduction(damage, defenderInfo);\\n\\n    if (magicAttack.aType == IItemController.AttackType.FIRE) {\\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.FIRE_RESISTANCE);\\n    } else if (magicAttack.aType == IItemController.AttackType.COLD) {\\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.COLD_RESISTANCE);\\n    } else if (magicAttack.aType == IItemController.AttackType.LIGHTNING) {\\n      damage -= _calcDmgInline(damage, defenderInfo, IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE);\\n    }\\n\\n    int32 defenderHealthResult = defenderHealth < damage ? int32(0) : defenderHealth - damage;\\n    damage = defenderHealth - defenderHealthResult;\\n\\n    return AttackResult({\\n      defenderHealth: defenderHealthResult,\\n      damage: damage,\\n      lifeStolen: lifeStolenPerHit(damage, attackerInfo),\\n      reflectDamage: reflectMagicDmg(damage, defenderInfo) + reflectChaos(magicAttack, attackerInfo, random_(1e18)),\\n      critical: critical ? uint8(1) : uint8(0),\\n      missed: 0,\\n      blocked: 0\\n    });\\n  }\\n\\n  function meleeDamageCalculation(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IFightCalculator.FighterInfo memory defenderInfo,\\n    int32 defenderHealth,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (AttackResult memory attackResult) {\\n    attackResult = (new AttackResult[](1))[0];\\n\\n    // generate damage\\n    int32 damage = getDamage(attackerInfo.fighterAttributes, random_);\\n    damage = increaseMeleeDmgByFactor(damage, attackerInfo);\\n    damage = increaseRaceDmg(damage, attackerInfo, defenderInfo.race);\\n    attackResult.critical = isCriticalHit(attackerInfo, random_(RESISTANCE_DENOMINATOR.toUint())) ? uint8(1) : uint8(0);\\n    damage = attackResult.critical == 0 ? damage : damage * 2;\\n\\n    // decrease damage\\n    damage = decreaseRaceDmg(damage, defenderInfo, attackerInfo.race);\\n    damage = decreaseDmgByDmgReduction(damage, defenderInfo);\\n\\n    attackResult.missed = random_(1e18) > StatLib.chanceToHit(\\n      _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.ATTACK_RATING).toUint(),\\n      _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.DEFENSE).toUint(),\\n      attackerInfo.fighterStats.level,\\n      defenderInfo.fighterStats.level,\\n      _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.AR_FACTOR).toUint()\\n    ) ? 1 : 0;\\n\\n    attackResult.blocked = (random_(100) < _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.BLOCK_RATING).toUint()) ? 1 : 0;\\n\\n    if (attackResult.missed != 0 || attackResult.blocked != 0) {\\n      damage = 0;\\n    }\\n\\n    int32 defenderHealthResult = defenderHealth <= damage ? int32(0) : defenderHealth - damage;\\n    damage = defenderHealth - defenderHealthResult;\\n\\n\\n    attackResult.defenderHealth = defenderHealthResult;\\n    attackResult.damage = damage;\\n    attackResult.lifeStolen = lifeStolenPerHit(damage, attackerInfo);\\n    attackResult.reflectDamage = reflectMeleeDmg(damage, defenderInfo);\\n  }\\n\\n  function getDamage(\\n    int32[] memory attributes,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (int32) {\\n    return int32(int(CalcLib.pseudoRandomInRangeFlex(\\n      _getAttrValue(attributes, IStatController.ATTRIBUTES.DAMAGE_MIN).toUint(),\\n      _getAttrValue(attributes, IStatController.ATTRIBUTES.DAMAGE_MAX).toUint(),\\n      random_\\n    )));\\n  }\\n\\n  //endregion ------------------------ Internal logic\\n\\n  //region ------------------------ Pure utils\\n\\n  /// @notice Modify values in {targetAttributes} and {casterAttributes} according to {statuses}\\n  function reduceAttributesByStatuses(\\n    int32[] memory targetAttributes,\\n    IFightCalculator.Statuses memory statuses,\\n    int32[] memory casterAttributes\\n  ) internal pure {\\n\\n    if (statuses.burn) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.DEFENSE)] -= (targetAttributes[uint(IStatController.ATTRIBUTES.DEFENSE)] / 3);\\n      targetAttributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)] += 50;\\n      casterAttributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)] += 10;\\n      casterAttributes[uint(IStatController.ATTRIBUTES.DESTROY_ITEMS)] += 20;\\n    }\\n    if (statuses.freeze) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] -= targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] / 3;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)] += 50;\\n    }\\n    if (statuses.confuse) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] /= 2;\\n    }\\n    if (statuses.curse) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)] /= 2;\\n      targetAttributes[uint(IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE)] /= 2;\\n    }\\n    if (statuses.stun) {\\n      casterAttributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)] += 10;\\n    }\\n    if (statuses.poison) {\\n      targetAttributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] /= 2;\\n    }\\n\\n  }\\n\\n  /// @notice Calculate new damage value depending on {defenderRace} and value of corresponded DMG_AGAINST_XXX attribute\\n  /// @param defenderRace See IStatController.Race\\n  /// @return Updated damage value\\n  function increaseRaceDmg(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo, uint defenderRace)\\n  internal pure returns (int32) {\\n    if (defenderRace == uint(IStatController.Race.HUMAN)) {\\n      return dmg + _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.DMG_AGAINST_HUMAN) * dmg / RESISTANCE_DENOMINATOR;\\n    } else if (defenderRace == uint(IStatController.Race.UNDEAD)) {\\n      return dmg + _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.DMG_AGAINST_UNDEAD) * dmg / RESISTANCE_DENOMINATOR;\\n    } else if (defenderRace == uint(IStatController.Race.DAEMON)) {\\n      return dmg + _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.DMG_AGAINST_DAEMON) * dmg / RESISTANCE_DENOMINATOR;\\n    } else if (defenderRace == uint(IStatController.Race.BEAST)) {\\n      return dmg + _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.DMG_AGAINST_BEAST) * dmg / RESISTANCE_DENOMINATOR;\\n    } else {\\n      return dmg;\\n    }\\n  }\\n\\n  /// @notice Decrease damage depending on {attackerRace}\\n  function decreaseRaceDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo, uint attackerRace) internal pure returns (int32) {\\n    if (attackerRace == uint(IStatController.Race.HUMAN)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_HUMAN);\\n    } else if (attackerRace == uint(IStatController.Race.UNDEAD)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_UNDEAD);\\n    } else if (attackerRace == uint(IStatController.Race.DAEMON)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_DAEMON);\\n    } else if (attackerRace == uint(IStatController.Race.BEAST)) {\\n      return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DEF_AGAINST_BEAST);\\n    } else {\\n      return dmg;\\n    }\\n  }\\n\\n  /// @notice Calculate damage after Melee-attack\\n  function increaseMeleeDmgByFactor(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo) internal pure returns (int32){\\n    return dmg + _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.MELEE_DMG_FACTOR) * dmg / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  /// @notice Calculate damage after Magic-attack\\n  function increaseMagicDmgByFactor(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo, IItemController.AttackType aType) internal pure returns (int32) {\\n    if (aType == IItemController.AttackType.FIRE) {\\n      return dmg + dmg * _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.FIRE_DMG_FACTOR) / RESISTANCE_DENOMINATOR;\\n    } else if (aType == IItemController.AttackType.COLD) {\\n      return dmg + dmg * _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.COLD_DMG_FACTOR) / RESISTANCE_DENOMINATOR;\\n    } else if (aType == IItemController.AttackType.LIGHTNING) {\\n      return dmg + dmg * _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.LIGHTNING_DMG_FACTOR) / RESISTANCE_DENOMINATOR;\\n    } else {\\n      return dmg;\\n    }\\n  }\\n\\n  /// @notice Reduce damage depending on value of Damage Reduction attribute\\n  function decreaseDmgByDmgReduction(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\\n    return dmg - _calcDmgInline(dmg, defenderInfo, IStatController.ATTRIBUTES.DAMAGE_REDUCTION);\\n  }\\n\\n  /// @notice Calculate poison damage < {health}\\n  function poisonDmg(int32 health, IFightCalculator.Statuses memory statuses) internal pure returns (int32) {\\n    // poison should not kill\\n    if (statuses.poison && health.toUint() > 1) {\\n      // at least 1 dmg\\n      return int32(int(Math.max(health.toUint() / 10, 1)));\\n    }\\n    return 0;\\n  }\\n\\n  /// @notice Reduce health of the fighters according to attacks results, calc damagePoison, damage and damageReflect.\\n  function reduceHp(\\n    AttackResult memory firstAttack,\\n    AttackResult memory secondAttack,\\n    IFightCalculator.Fighter memory firstFighter,\\n    IFightCalculator.Fighter memory secondFighter\\n  ) internal pure {\\n    secondFighter.health = firstAttack.defenderHealth;\\n    firstFighter.damage = firstAttack.damage;\\n\\n    // hit only if second fighter survived\\n    if (secondFighter.health != 0) {\\n      firstFighter.health = secondAttack.defenderHealth;\\n      secondFighter.damage = secondAttack.damage;\\n\\n      // reflect damage from second to first\\n      secondFighter.damageReflect = (CalcLib.minI32(firstAttack.reflectDamage, firstFighter.health));\\n      firstFighter.health -= secondFighter.damageReflect;\\n\\n      // reflect damage from first to second\\n      firstFighter.damageReflect = (CalcLib.minI32(secondAttack.reflectDamage, secondFighter.health));\\n      secondFighter.health -= firstFighter.damageReflect;\\n    }\\n\\n    // poison second firstly (he got damage and statuses early)\\n    firstFighter.damagePoison = poisonDmg(secondFighter.health, secondFighter.statuses);\\n    secondFighter.health -= firstFighter.damagePoison;\\n\\n    // poison first fighter\\n    secondFighter.damagePoison = poisonDmg(firstFighter.health, firstFighter.statuses);\\n    firstFighter.health -= secondFighter.damagePoison;\\n  }\\n\\n  /// @notice Calculate life-stolen-per-hit value for the given {damage} value\\n  function lifeStolenPerHit(int32 dmg, IFightCalculator.FighterInfo memory attackerInfo) internal pure returns (int32) {\\n    return dmg * _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.LIFE_STOLEN_PER_HIT) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  /// @notice Increase {fighter.health} on the value of life-stolen-per-hit (only if the health > 0)\\n  function stealLife(IFightCalculator.Fighter memory fighter, AttackResult memory attackResult) internal pure {\\n    if (fighter.health != 0) {\\n      int32 newHealth = fighter.health + attackResult.lifeStolen;\\n      int32 maxHealth = _getAttrValue(fighter.info.fighterAttributes, IStatController.ATTRIBUTES.LIFE);\\n      fighter.health = (CalcLib.minI32(newHealth, maxHealth));\\n    }\\n  }\\n\\n  function skipTurn(IFightCalculator.FightInfoInternal memory fResult, bool isA) internal pure returns (bool) {\\n    return isA ? fResult.fighterA.statuses.stun : fResult.fighterB.statuses.stun;\\n  }\\n\\n  /// @notice Detect which hero is faster and makes the hit first. Magic is faster melee.\\n  /// Otherwise first hit is made by the fighter with higher attack rating (A is selected if the ratings are equal)\\n  function calcFirstHit(IFightCalculator.FightInfoInternal memory fInfo) internal pure returns (bool aFirst){\\n    if (fInfo.fighterA.info.attackType == IFightCalculator.AttackType.MAGIC) {\\n      if (fInfo.fighterB.info.attackType == IFightCalculator.AttackType.MAGIC) {\\n        // if both fighters use magic we check attack rating\\n        aFirst = isAttackerFaster(fInfo.fighterA.info, fInfo.fighterB.info);\\n      } else {\\n        // otherwise, magic always faster than melee\\n        aFirst = true;\\n      }\\n    } else {\\n      if (fInfo.fighterB.info.attackType == IFightCalculator.AttackType.MAGIC) {\\n        // if fighter use magic he will be faster\\n        aFirst = false;\\n      } else {\\n        // otherwise, check attack rating\\n        aFirst = isAttackerFaster(fInfo.fighterA.info, fInfo.fighterB.info);\\n      }\\n    }\\n  }\\n\\n  function isAttackerFaster(\\n    IFightCalculator.FighterInfo memory fighterAInfo,\\n    IFightCalculator.FighterInfo memory fighterBInfo\\n  ) internal pure returns (bool) {\\n    return _getAttrValue(fighterAInfo.fighterAttributes, IStatController.ATTRIBUTES.ATTACK_RATING)\\n      >= _getAttrValue(fighterBInfo.fighterAttributes, IStatController.ATTRIBUTES.ATTACK_RATING);\\n  }\\n\\n  function reflectMeleeDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\\n    return dmg * _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.REFLECT_DAMAGE_MELEE) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  function reflectMagicDmg(int32 dmg, IFightCalculator.FighterInfo memory defenderInfo) internal pure returns (int32) {\\n    return dmg * _getAttrValue(defenderInfo.fighterAttributes, IStatController.ATTRIBUTES.REFLECT_DAMAGE_MAGIC) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  function _getChance(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IItemController.AttackType aType,\\n    IStatController.ATTRIBUTES index,\\n    int32 resist\\n  ) internal pure returns (int32 chance) {\\n    int32 chanceBase = attackerInfo.fighterAttributes[uint(index)];\\n\\n    if (attackerInfo.attackType == IFightCalculator.AttackType.MAGIC) {\\n      if (index == IStatController.ATTRIBUTES.BURN && aType == IItemController.AttackType.FIRE) {\\n        chanceBase += int32(20);\\n      }\\n      if (index == IStatController.ATTRIBUTES.FREEZE && aType == IItemController.AttackType.COLD) {\\n        chanceBase += int32(20);\\n      }\\n      if (index == IStatController.ATTRIBUTES.CONFUSE && aType == IItemController.AttackType.LIGHTNING) {\\n        chanceBase += int32(20);\\n      }\\n    }\\n\\n    chance = _getAdjustedAttributeValue(chanceBase, index);\\n\\n    return chance - chance * (CalcLib.minI32(resist, _MAX_RESIST)) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  /// @param randomValue Result of call _pseudoRandom, value in the range [0...RESISTANCE_DENOMINATOR)\\n  function isCriticalHit(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    uint randomValue\\n  ) internal pure returns (bool) {\\n    return randomValue < _getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.CRITICAL_HIT).toUint();\\n  }\\n\\n  /// @param randomValue Result of call CalcLib.pseudoRandom(1e18)\\n  function reflectChaos(\\n    IItemController.AttackInfo memory magicAttack,\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    uint randomValue\\n  ) internal pure returns (int32) {\\n    return (magicAttack.aType == IItemController.AttackType.CHAOS && randomValue > 5e17)\\n      ? int32(attackerInfo.fighterStats.life) / int32(2)\\n      : int32(0);\\n  }\\n\\n  function _calcDmgInline(int32 dmg, IFightCalculator.FighterInfo memory info, IStatController.ATTRIBUTES index) internal pure returns (int32) {\\n    return dmg * (CalcLib.minI32(_getAttrValue(info.fighterAttributes, index), _MAX_RESIST)) / RESISTANCE_DENOMINATOR;\\n  }\\n\\n  function getMagicDamage(\\n    IFightCalculator.FighterInfo memory attackerInfo,\\n    IItemController.AttackInfo memory mAttack,\\n    uint randomValue_\\n  ) internal pure returns (int32) {\\n\\n    int32 attributeFactorResult = (_getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.STRENGTH) * mAttack.attributeFactors.strength / 100);\\n    attributeFactorResult += (_getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.DEXTERITY) * mAttack.attributeFactors.dexterity / 100);\\n    attributeFactorResult += (_getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.VITALITY) * mAttack.attributeFactors.vitality / 100);\\n    attributeFactorResult += (_getAttrValue(attackerInfo.fighterAttributes, IStatController.ATTRIBUTES.ENERGY) * mAttack.attributeFactors.energy / 100);\\n\\n    return int32(int(randomValue_)) + attributeFactorResult;\\n  }\\n  //endregion ------------------------ Pure utils\\n\\n  //region ------------------------ SIP-002\\n\\n  /// @notice SIP-002: Implement smooth increase that approaches to y0 but never reaches that value\\n  /// @dev https://discord.com/channels/1134537718039318608/1265261881652674631\\n  /// @param y0 is desired capacity, 90 for resists/defs, 100 for critical hit and statuses\\n  /// @param x current value, base attribute. Assume x >= 0\\n  /// @param k is the factor of how fast the value will reach 90 capacity, k=100 by default\\n  /// @return new attribute value that is used in calculations, decimals 18\\n  function getReducedValue(uint y0, uint x, uint k) internal pure returns (uint) {\\n    // 2^n = exp(ln(2^n)) = exp(n * ln2)\\n    int t = FixedPointMathLib.expWad(-int(x) * LN2 / int(k));\\n    return t < 0\\n      ? 0 // some mistake happens (???)\\n      : y0 * (1e18 - uint(t));\\n  }\\n\\n  /// @notice Apply {getReducedValue} to the given attribute, change value in place\\n  function _getAdjustedValue(int32 attributeValue, uint y0, uint k) internal pure returns (int32) {\\n    return attributeValue <= 0\\n      ? int32(0) // negative values => 0\\n      : int32(int(getReducedValue(y0, uint(int(attributeValue)), k) / 1e18));\\n  }\\n\\n  /// @notice Return adjusted attribute value. Adjust selected attributes using y=z(1\\u22122^(\\u2212x/k)) formula\\n  /// Value in array {attributes} is NOT changed.\\n  function _getAttrValue(int32[] memory attributes, IStatController.ATTRIBUTES attrId) internal pure returns (int32) {\\n    return _getAdjustedAttributeValue(attributes[uint(attrId)], attrId);\\n  }\\n\\n  function _getAdjustedAttributeValue(int32 value, IStatController.ATTRIBUTES attrId) internal pure returns (int32) {\\n    if (\\n      attrId == IStatController.ATTRIBUTES.BLOCK_RATING\\n      || attrId == IStatController.ATTRIBUTES.FIRE_RESISTANCE\\n      || attrId == IStatController.ATTRIBUTES.COLD_RESISTANCE\\n      || attrId == IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE\\n      || attrId == IStatController.ATTRIBUTES.DEF_AGAINST_HUMAN\\n      || attrId == IStatController.ATTRIBUTES.DEF_AGAINST_UNDEAD\\n      || attrId == IStatController.ATTRIBUTES.DEF_AGAINST_DAEMON\\n      || attrId == IStatController.ATTRIBUTES.DEF_AGAINST_BEAST\\n      || attrId == IStatController.ATTRIBUTES.DAMAGE_REDUCTION\\n      || attrId == IStatController.ATTRIBUTES.RESIST_TO_STATUSES\\n    ) {\\n      // use CAPACITY_RESISTS_DEFS, K_FACTOR\\n      return _getAdjustedValue(value, CAPACITY_RESISTS_DEFS, K_FACTOR);\\n    } else if (\\n      attrId == IStatController.ATTRIBUTES.CRITICAL_HIT\\n      || attrId == IStatController.ATTRIBUTES.STUN\\n      || attrId == IStatController.ATTRIBUTES.BURN\\n      || attrId == IStatController.ATTRIBUTES.FREEZE\\n      || attrId == IStatController.ATTRIBUTES.CONFUSE\\n      || attrId == IStatController.ATTRIBUTES.CURSE\\n      || attrId == IStatController.ATTRIBUTES.POISON\\n    ) {\\n      // use CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR\\n      return _getAdjustedValue(value, CAPACITY_CRITICAL_HIT_STATUSES, K_FACTOR);\\n    } else {\\n      return value;\\n    }\\n  }\\n\\n  //endregion ------------------------ SIP-002\\n\\n}\\n\",\"keccak256\":\"0xd200680ad921066e1dd29eba34cf8a722f3491628cb264ab16a4deb081c39004\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ItemLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IItem.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IItemControllerHelper.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./ControllerContextLib.sol\\\";\\nimport \\\"./ShelterLib.sol\\\";\\nimport \\\"./StatLib.sol\\\";\\n\\nlibrary ItemLib {\\n  using CalcLib for int32;\\n  using PackingLib for address;\\n  using PackingLib for bytes32;\\n  using PackingLib for bytes32[];\\n  using PackingLib for uint32[];\\n  using PackingLib for int32[];\\n\\n  //region ------------------------ Constants\\n  /// @dev should be 20%\\n  uint private constant AUGMENT_FACTOR = 5;\\n  uint private constant AUGMENT_CHANCE = 0.7e18;\\n  uint private constant MAX_AUGMENTATION_LEVEL = 20;\\n\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"item.controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0xe78a2879cd91c3f7b62ea14e72546fed47c40919bca4daada532a5fa05ac6700;\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Data types\\n  struct GenerateAttributesContext {\\n    /// @notice True if max allowed amount of random attributes were reached inside {_prepareAttributes}\\n    bool stopGenerateRandom;\\n    /// @notice Flag - attribute was generated. The array matches to info.ids\\n    bool[] usedIndexes;\\n    /// @notice Ids of the generated attributes\\n    uint8[] ids;\\n    /// @notice Randomly selected values of the generated attributes\\n    int32[] values;\\n    /// @notice Counter of the stored values into {ids} and {values}\\n    uint counter;\\n    /// @notice Total number of random attributes that were generated inside {_prepareAttributes}\\n    uint randomAttrCounter;\\n    /// @notice Total sum of all {random} values for random attributes generated in {_prepareAttributes}\\n    uint randomSum;\\n    /// @notice Total sum of all chances of the random attributes generated in {_prepareAttributes}\\n    uint chancesSum;\\n    /// @notice Total number of random attributes that can be generated\\n    uint totalRandomAttrsPossible;\\n  }\\n\\n  struct MintItemInfo {\\n    uint8 maxItems;\\n    int32 magicFind;\\n    int32 destroyItems;\\n    uint32[] mintItemsChances;\\n    IOracle oracle;\\n    address[] mintItems;\\n    uint amplifier;\\n    uint seed;\\n    /// @notice Penalty to reduce chance as chance/delta if the hero not in his biome\\n    /// @dev Use StatLib.mintDropChanceDelta\\n    uint mintDropChanceDelta;\\n    /// @notice SCR-1064: drop chance depends on NG_LEVEL, decimals 18, value is in the range [0...1e18]\\n    /// it's always 100% for NG0 (no reduce, value is 1e18)\\n    /// Use {dropChancePercent} to calculate actual value\\n    uint mintDropChanceNgLevelMultiplier;\\n  }\\n\\n  struct ItemWithId {\\n    address item;\\n    uint itemId;\\n  }\\n\\n  struct SenderInfo {\\n    address msgSender;\\n    bool isEoa;\\n  }\\n\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Restrictions\\n  function onlyDeployer(IController c, address sender) internal view {\\n    if (!c.isDeployer(sender)) revert IAppErrors.ErrorNotDeployer(sender);\\n  }\\n\\n  function onlyEOA(bool isEoa) internal view {\\n    if (!isEoa) {\\n      revert IAppErrors.NotEOA(msg.sender);\\n    }\\n  }\\n\\n  function onlyStoryController(IController c) internal view {\\n    if (msg.sender != c.storyController()) revert IAppErrors.ErrorNotStoryController();\\n  }\\n\\n  function onlyNotEquippedItem(address item, uint itemId) internal view {\\n    if (_S().equippedOn[item.packNftId(itemId)] != bytes32(0)) revert IAppErrors.ItemEquipped(item, itemId);\\n  }\\n\\n  function onlyNotConsumable(IItemController.ItemMeta memory meta, address item) internal pure {\\n    if (\\n      uint(meta.itemType) == 0\\n      || meta.itemMetaType == uint8(IItemController.ItemMetaType.CONSUMABLE) // todo probably first check is enough?\\n    ) revert IAppErrors.Consumable(item);\\n  }\\n\\n  function checkPauseEoa(SenderInfo memory senderInfo, IController controller) internal view {\\n    onlyEOA(senderInfo.isEoa);\\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\\n  }\\n\\n  function onlyRegisteredControllers(ControllerContextLib.ControllerContext memory cc) internal view {\\n    if (\\n      msg.sender != address(ControllerContextLib.dungeonFactory(cc))\\n      && msg.sender != address(ControllerContextLib.reinforcementController(cc))\\n      && msg.sender != address(ControllerContextLib.pvpController(cc))\\n    ) revert IAppErrors.ErrorForbidden(msg.sender);\\n  }\\n\\n  function checkRequirements(\\n    ControllerContextLib.ControllerContext memory cc,\\n    address hero,\\n    uint heroId,\\n    IStatController.CoreAttributes memory requirements\\n  ) internal view {\\n    IStatController.CoreAttributes memory attributes = ControllerContextLib.statController(cc).heroBaseAttributes(hero, heroId);\\n    if (\\n      requirements.strength > attributes.strength\\n      || requirements.dexterity > attributes.dexterity\\n      || requirements.vitality > attributes.vitality\\n      || requirements.energy > attributes.energy\\n    ) revert IAppErrors.RequirementsToItemAttributes();\\n  }\\n\\n  /// @notice ensure that the user belongs to a guild, the guild has a shelter, the shelter has highest level 3\\n  function _onlyMemberOfGuildWithShelterMaxLevel(ControllerContextLib.ControllerContext memory cc, address msgSender) internal view {\\n    // ensure that signer belongs to a guild and the guild has a shelter of ANY level\\n    IGuildController gc = ControllerContextLib.guildController(cc);\\n    if (address(gc) == address(0)) revert IAppErrors.NotInitialized();\\n\\n    uint guildId = gc.memberOf(msgSender);\\n    if (guildId == 0) revert IAppErrors.NotGuildMember();\\n\\n    uint shelterId = gc.guildToShelter(guildId);\\n    if (shelterId == 0) revert IAppErrors.GuildHasNoShelter();\\n\\n    // only highest level of shelters gives possibility to exit from dungeon\\n    (, uint8 shelterLevel,) = PackingLib.unpackShelterId(shelterId);\\n    if (shelterLevel != ShelterLib.MAX_SHELTER_LEVEL) revert IAppErrors.TooLowShelterLevel(shelterLevel, ShelterLib.MAX_SHELTER_LEVEL);\\n  }\\n\\n  function onlyOwner(address token, uint tokenId, address sender) internal view {\\n    if (IERC721(token).ownerOf(tokenId) != sender) revert IAppErrors.ErrorNotOwner(token, tokenId);\\n  }\\n\\n  function onlyAliveHero(ControllerContextLib.ControllerContext memory cc, address hero, uint heroId) internal view {\\n    if (!ControllerContextLib.statController(cc).isHeroAlive(hero, heroId)) revert IAppErrors.ErrorHeroIsDead(hero, heroId);\\n  }\\n\\n  /// @notice Hero belongs to the {sender} and\\n  /// 1) in sandbox mode: the item belongs to the same hero\\n  /// 2) in not sandbox mode: the item either belongs to the same sender\\n  /// or the item is sandbox item that belongs to the hero 2 (upgraded)\\n  /// and the hero 2 belongs to the same sender\\n  /// @param sandboxMode Sandbox mode of the given hero\\n  /// @return inSandbox True if the item is located in some sandbox (the hero or some other hero)\\n  function onlyItemOwner(\\n    ControllerContextLib.ControllerContext memory cc,\\n    ItemWithId memory itemData,\\n    address hero,\\n    uint heroId,\\n    address msgSender,\\n    IHeroController.SandboxMode sandboxMode,\\n    bool checkIfHeroAlive\\n  ) internal view returns (bool inSandbox) {\\n    onlyOwner(hero, heroId, msgSender);\\n\\n    if (checkIfHeroAlive) {\\n      ItemLib.onlyAliveHero(cc, hero, heroId);\\n    }\\n\\n    bool checkSenderIsItemOwner;\\n    if (sandboxMode == IHeroController.SandboxMode.SANDBOX_MODE_1) {\\n      // the hero is in the sandbox mode, he can use only his own items from the sandbox\\n      inSandbox = _checkInSandbox(cc, itemData, hero, heroId);\\n      // not-upgraded hero has sandbox item outside of the sandbox .. it means the item is equipped on the hero\\n      if (!inSandbox) revert IAppErrors.SandboxItemAlreadyEquipped();\\n    } else {\\n      // let's detect item owner\\n      (address hero2, uint heroId2) = ControllerContextLib.itemBoxController(cc).itemHero(itemData.item, itemData.itemId);\\n      if (hero2 == address(0)) {\\n        checkSenderIsItemOwner = true;\\n      } else if (hero2 == hero && heroId == heroId2) {\\n        inSandbox = _checkInSandbox(cc, itemData, hero, heroId);\\n      } else {\\n        IHeroController.SandboxMode sandboxMode2 = ItemLib._getSandboxMode(cc, hero2, heroId2);\\n        if (sandboxMode2 == IHeroController.SandboxMode.NORMAL_MODE_0) {\\n          checkSenderIsItemOwner = true;\\n        } else if (sandboxMode2 == IHeroController.SandboxMode.SANDBOX_MODE_1) {\\n          revert IAppErrors.SandboxModeNotAllowed();\\n        } else {\\n          inSandbox = _checkInSandbox(cc, itemData, hero2, heroId2);\\n          if (inSandbox) {\\n            onlyOwner(hero2, heroId2, msgSender);\\n          } else {\\n            checkSenderIsItemOwner = true;\\n          }\\n        }\\n      }\\n    }\\n    if (checkSenderIsItemOwner) {\\n      onlyOwner(itemData.item, itemData.itemId, msgSender);\\n    }\\n\\n    return inSandbox;\\n  }\\n\\n  function _checkInSandbox(\\n    ControllerContextLib.ControllerContext memory cc,\\n    ItemWithId memory itemData,\\n    address hero,\\n    uint heroId\\n  ) internal view returns (bool) {\\n    IItemBoxController.ItemState itemState = ControllerContextLib.itemBoxController(cc).itemState(hero, heroId, itemData.item, itemData.itemId);\\n    if (itemState == IItemBoxController.ItemState.NOT_REGISTERED_0) revert IAppErrors.SandboxItemNotRegistered();\\n    if (itemState == IItemBoxController.ItemState.NOT_AVAILABLE_1) revert IAppErrors.SandboxItemNotActive();\\n    return itemState == IItemBoxController.ItemState.INSIDE_2;\\n  }\\n\\n  /// @notice Either both items belong to the {sender} or both sandbox-items belong to the same hero of the given {sender}\\n  /// @return [item is in the sandbox, other item is in the sandbox]\\n  function _checkOwnerItems(\\n    ControllerContextLib.ControllerContext memory cc,\\n    ItemWithId memory item,\\n    ItemWithId memory otherItem,\\n    address sender\\n  ) internal view returns (bool[2] memory) {\\n\\n    (address hero1, uint heroId1, IHeroController.SandboxMode sandboxMode1, bool inSandbox1) = _checkSingleItem(cc, item, sender);\\n    (address hero2, uint heroId2, IHeroController.SandboxMode sandboxMode2, bool inSandbox2) = _checkSingleItem(cc, otherItem, sender);\\n\\n    if (sandboxMode1 == IHeroController.SandboxMode.SANDBOX_MODE_1 || sandboxMode2 == IHeroController.SandboxMode.SANDBOX_MODE_1) {\\n      if (hero1 != hero2 || heroId1 != heroId2) revert IAppErrors.SandboxDifferentHeroesNotAllowed();\\n    }\\n\\n    return [inSandbox1, inSandbox2];\\n  }\\n\\n  /// @dev a part of {_checkOwnerItems}\\n  function _checkSingleItem(ControllerContextLib.ControllerContext memory cc, ItemWithId memory item, address sender) internal view returns (\\n    address hero,\\n    uint heroId,\\n    IHeroController.SandboxMode sandboxMode,\\n    bool inSandbox\\n  ) {\\n    (hero, heroId) = ControllerContextLib.itemBoxController(cc).itemHero(item.item, item.itemId);\\n\\n    sandboxMode = hero == address(0)\\n      ? IHeroController.SandboxMode.NORMAL_MODE_0\\n      : ItemLib._getSandboxMode(cc, hero, heroId);\\n\\n    inSandbox = hero != address(0) && onlyItemOwner(cc, item, hero, heroId, sender, sandboxMode, true);\\n\\n    if (hero == address(0)) {\\n      onlyOwner(item.item, item.itemId, sender);\\n    } else {\\n      onlyOwner(hero, heroId, sender);\\n    }\\n  }\\n\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ STORAGE\\n  function _S() internal pure returns (IItemController.MainState storage s) {\\n    assembly {\\n      s.slot := MAIN_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n  //endregion ------------------------ STORAGE\\n\\n  //region ------------------------ Main logic\\n\\n  /// @notice Mint new item, setup attributes, make extra setup if necessary (setup attack item, buff item)\\n  /// @param sender Dungeon Factory / User Controller / Guild Controller are allowed\\n  /// @param item Item to be minted\\n  /// @param recipient The item is minted for the given recipient\\n  /// @return itemId Id of the newly minted item\\n  function mintNewItem(\\n    IController controller,\\n    address sender,\\n    address item,\\n    address recipient\\n  ) external returns (uint itemId) {\\n    IItemController.MainState storage s = _S();\\n    ControllerContextLib.ControllerContext memory ctx = ControllerContextLib.init(controller);\\n\\n    address guildController = address(ControllerContextLib.guildController(ctx));\\n    address shelterController = guildController == address(0)\\n      ? address(0)\\n      : IGuildController(guildController).shelterController();\\n\\n    if (\\n      address(ControllerContextLib.dungeonFactory(ctx)) != sender\\n      && address(ControllerContextLib.userController(ctx)) != sender\\n      && guildController != sender\\n      && shelterController != sender\\n      && address(ControllerContextLib.itemController(ctx)) != sender\\n      && address(ControllerContextLib.heroController(ctx)) != sender\\n    ) revert IAppErrors.MintNotAllowed();\\n\\n    itemId = IItem(item).mintFor(recipient);\\n\\n    IItemController.MintInfo memory info;\\n\\n    (\\n      info.meta,\\n      info.attributesIds,\\n      info.attributesValues,\\n      info.itemRarity\\n    ) = _setupNewAttributes(s, item, itemId, CalcLib.pseudoRandom);\\n\\n    // setup extra info\\n\\n    if (info.meta.itemMetaType == uint8(IItemController.ItemMetaType.ATTACK)) {\\n      info.attackInfo = unpackItemAttackInfo(_setupNewAttackItem(s, item, itemId));\\n    } else if (info.meta.itemMetaType == uint8(IItemController.ItemMetaType.BUFF)) {\\n      (\\n        info.casterIds,\\n        info.casterValues,\\n        info.targetIds,\\n        info.targetValues\\n      ) = _setupNewBuffItem(s, item, itemId, CalcLib.pseudoRandom);\\n    }\\n    // consumable stats unchangeable, get them by address\\n\\n    emit IApplicationEvents.NewItemMinted(item, itemId, info);\\n  }\\n\\n  /// @notice Mint random items, not more than {info.maxItems}\\n  function mintRandomItems(MintItemInfo memory info) internal returns (address[] memory) {\\n    return _mintRandomItems(info, CalcLib.nextPrng);\\n  }\\n\\n  function applyActionMasks(\\n    uint actionMask,\\n    IStatController statController,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external {\\n    if ((actionMask & (2 ** uint(IItemController.ConsumableActionBits.CLEAR_TEMPORARY_ATTRIBUTES_0))) != 0) {\\n      statController.clearTemporallyAttributes(heroToken, heroTokenId);\\n    }\\n  }\\n\\n  function destroy(IController controller, address msgSender, address item, uint itemId) external {\\n    address owner = IERC721(item).ownerOf(itemId);\\n    address itemBox = controller.itemBoxController();\\n    bool sandbox = owner == itemBox;\\n\\n    if (\\n      controller.gameObjectController() != msgSender\\n      && controller.storyController() != msgSender\\n    ) {\\n      if (sandbox) {\\n        (address hero, uint heroId) = IItemBoxController(itemBox).itemHero(item, itemId);\\n        address heroOwner = IERC721(hero).ownerOf(heroId);\\n        if (heroOwner != msgSender) revert IAppErrors.ErrorForbidden(msgSender);\\n      } else {\\n        if (owner != msgSender) revert IAppErrors.ErrorForbidden(msgSender);\\n      }\\n    }\\n\\n    ItemLib.onlyNotEquippedItem(item, itemId);\\n\\n    _destroy(ControllerContextLib.init(controller), item, itemId, sandbox);\\n  }\\n\\n  /// @notice Destroy {consumed item} to augment given {item}.\\n  /// There is a chance of 30% that the item will be destroyed instead of augmentation.\\n  /// SCR-1263: Protective item allows to avoid item destruction in fail case - augmentation is reset instead.\\n  function augment(\\n    ItemLib.SenderInfo memory senderInfo,\\n    address controller_,\\n    address item,\\n    uint itemId,\\n    uint consumedItemId,\\n    IItemController.AugmentOptParams memory opt,\\n    IItemControllerHelper itemControllerHelper\\n  ) external {\\n    ControllerContextLib.ControllerContext memory cc = ControllerContextLib.init(IController(controller_));\\n\\n    ( // restrictions are checked inside {_prepareToAugment}\\n      IItemController.ItemMeta memory meta,\\n      IItemController.ItemInfo memory _itemInfo,\\n      bool[2] memory inSandbox\\n    ) = _prepareToAugment(_S(), cc, senderInfo, item, itemId, consumedItemId);\\n\\n    ItemLib.onlyNotConsumable(meta, item);\\n    if (_itemInfo.augmentationLevel >= MAX_AUGMENTATION_LEVEL) revert IAppErrors.TooHighAgLevel(_itemInfo.augmentationLevel);\\n\\n    // ----------------- destroy consumable item\\n    ItemLib._destroy(cc, item, consumedItemId, inSandbox[1]);\\n\\n    { // ----------------- get augmentation fee\\n      address augToken = _sendFee(cc.controller, item, senderInfo.msgSender, 1);\\n      // we check augToken for 0 AFTER sendFee to avoid second reading of augmentInfo\\n      if (augToken == address(0)) revert IAppErrors.ZeroAugmentation();\\n    }\\n\\n    // ----------------- check protective item if any\\n    bool protectiveInSandbox;\\n    if (opt.protectiveItem != address(0)) {\\n      // SCR-1263: If the item was augmented first time before introducing SCR-1263, _resetAugmentation is empty.\\n      // So, there is no way to use protective item.\\n      if (\\n        (_itemInfo.augmentationLevel != 0)\\n        && (0 == _S()._resetAugmentation[item.packNftId(itemId)].tsFirstAugmentation)\\n      ) revert IAppErrors.NoFirstAugmentationInfo();\\n\\n      if (opt.protectiveItem != itemControllerHelper.getAugmentationProtectiveItem()) revert IAppErrors.NotAugmentationProtectiveItem(opt.protectiveItem);\\n\\n      protectiveInSandbox = ItemLib._checkOwnerItems(cc, ItemLib.ItemWithId(item, itemId), ItemLib.ItemWithId(opt.protectiveItem, opt.protectiveItemId), senderInfo.msgSender)[1];\\n    }\\n\\n    // ----------------- augmentation\\n    bytes32 packedItemId = item.packNftId(itemId);\\n    if (IOracle(ControllerContextLib.oracle(cc)).getRandomNumber(1e18, 0) < AUGMENT_CHANCE) {\\n      IItemController.AugmentInfo memory _augmentInfo = _applyAugmentation(_S(), packedItemId, meta, _itemInfo);\\n      emit IApplicationEvents.Augmented(item, itemId, consumedItemId, _itemInfo.augmentationLevel, _augmentInfo);\\n    } else {\\n      if (opt.protectiveItem != address(0)) {\\n        // protective item exists, so don't destroy base item but reduce its augmentation level to 0\\n        // and restore its attributes to original (stored before the first augmentation) values.\\n        IItemController.AugmentInfo memory _augmentInfo = _resetAugmentation(_S(), packedItemId, meta, _itemInfo);\\n        emit IApplicationEvents.ResetAugmentation(item, itemId, consumedItemId, _augmentInfo);\\n      } else {\\n        ItemLib._destroy(cc, item, itemId, inSandbox[0]);\\n        emit IApplicationEvents.NotAugmented(item, itemId, consumedItemId, _itemInfo.augmentationLevel);\\n      }\\n    }\\n\\n    // ----------------- destroy protective item\\n    if (opt.protectiveItem != address(0)) {\\n      ItemLib._destroy(cc, opt.protectiveItem, opt.protectiveItemId, protectiveInSandbox);\\n    }\\n  }\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ Internal logic - augmentation\\n  /// @notice Decrease attribute values back to original values. Set augmentation level to 0\\n  function _resetAugmentation(\\n    IItemController.MainState storage s,\\n    bytes32 packedItemId,\\n    IItemController.ItemMeta memory meta,\\n    IItemController.ItemInfo memory _itemInfo\\n  ) internal returns (\\n    IItemController.AugmentInfo memory augmentInfo\\n  ) {\\n    IItemController.ResetAugmentationData storage resetData = s._resetAugmentation[packedItemId];\\n\\n    {\\n      bytes32[] memory data = resetData.itemAttributes;\\n      s._itemAttributes[packedItemId] = data;\\n      (augmentInfo.attributesValues, augmentInfo.attributesIds) = PackingLib.toInt32ArrayWithIds(data);\\n    }\\n\\n    if (_itemInfo.augmentationLevel != 0) {\\n      if (meta.itemMetaType == uint8(IItemController.ItemMetaType.ATTACK)) {\\n        bytes32 data = resetData.itemAttackInfo;\\n        s._itemAttackInfo[packedItemId] = data;\\n        augmentInfo.attackInfo = ItemLib.unpackItemAttackInfo(data);\\n      } else if (meta.itemMetaType == uint8(IItemController.ItemMetaType.BUFF)) {\\n        {\\n          bytes32[] memory data = resetData.itemCasterAttributes;\\n          s._itemCasterAttributes[packedItemId] = data;\\n          (augmentInfo.casterValues, augmentInfo.casterIds) = PackingLib.toInt32ArrayWithIds(data);\\n        }\\n        {\\n          bytes32[] memory data = resetData.itemTargetAttributes;\\n          s._itemTargetAttributes[packedItemId] = data;\\n          (augmentInfo.targetValues, augmentInfo.targetIds) = PackingLib.toInt32ArrayWithIds(data);\\n        }\\n      }\\n    }\\n\\n    // reset aug level\\n    _itemInfo.augmentationLevel = 0;\\n    s.itemInfo[packedItemId] = ItemLib.packItemInfo(_itemInfo);\\n\\n    return augmentInfo;\\n  }\\n\\n  /// @notice Successful augmentation - increase attribute values. Increase augmentation level.\\n  function _applyAugmentation(\\n    IItemController.MainState storage s,\\n    bytes32 packedItemId,\\n    IItemController.ItemMeta memory meta,\\n    IItemController.ItemInfo memory _itemInfo\\n  ) internal returns (\\n    IItemController.AugmentInfo memory augmentInfo\\n  ) {\\n    IItemController.ResetAugmentationData storage resetData = s._resetAugmentation[packedItemId];\\n\\n    // SCR-1263: Save original attributes values before increasing to be able to restore them during augmentation reset.\\n    bool saveBeforeAugmentation = _itemInfo.augmentationLevel == 0 && resetData.tsFirstAugmentation == 0;\\n\\n    { // augment base\\n      bytes32[] memory data = s._itemAttributes[packedItemId];\\n      (augmentInfo.attributesValues, augmentInfo.attributesIds) = _augmentAttributes(data, true);\\n      s._itemAttributes[packedItemId] = augmentInfo.attributesValues.toBytes32ArrayWithIds(augmentInfo.attributesIds);\\n\\n      if (saveBeforeAugmentation) {\\n        resetData.tsFirstAugmentation = block.timestamp;\\n        resetData.itemAttributes = data;\\n      }\\n    }\\n\\n    // additionally\\n    if (meta.itemMetaType == uint8(IItemController.ItemMetaType.ATTACK)) {\\n      bytes32 data = s._itemAttackInfo[packedItemId];\\n      augmentInfo.attackInfo = ItemLib.unpackItemAttackInfo(data);\\n      augmentInfo.attackInfo.min = _augmentAttribute(augmentInfo.attackInfo.min);\\n      augmentInfo.attackInfo.max = _augmentAttribute(augmentInfo.attackInfo.max);\\n      s._itemAttackInfo[packedItemId] = ItemLib.packItemAttackInfo(augmentInfo.attackInfo);\\n      if (saveBeforeAugmentation) {\\n        resetData.itemAttackInfo = data;\\n      }\\n    } else if (meta.itemMetaType == uint8(IItemController.ItemMetaType.BUFF)) {\\n      { // caster\\n        bytes32[] memory data = s._itemCasterAttributes[packedItemId];\\n        (augmentInfo.casterValues, augmentInfo.casterIds) = _augmentAttributes(data, true);\\n        s._itemCasterAttributes[packedItemId] = augmentInfo.casterValues.toBytes32ArrayWithIds(augmentInfo.casterIds);\\n        if (saveBeforeAugmentation) {\\n          resetData.itemCasterAttributes = data;\\n        }\\n      }\\n\\n      { // target\\n        bytes32[] memory data = s._itemTargetAttributes[packedItemId];\\n        (augmentInfo.targetValues, augmentInfo.targetIds) = _augmentAttributes(data, false);\\n        s._itemTargetAttributes[packedItemId] = augmentInfo.targetValues.toBytes32ArrayWithIds(augmentInfo.targetIds);\\n        if (saveBeforeAugmentation) {\\n          resetData.itemTargetAttributes = data;\\n        }\\n      }\\n    }\\n\\n    // increase aug level\\n    _itemInfo.augmentationLevel = _itemInfo.augmentationLevel + 1;\\n    s.itemInfo[packedItemId] = ItemLib.packItemInfo(_itemInfo);\\n\\n    return augmentInfo;\\n  }\\n\\n  /// @return augToken Return augToken to avoid repeat reading of augmentInfo inside augment()\\n  function _sendFee(\\n    IController controller,\\n    address item,\\n    address msgSender,\\n    uint divider\\n  ) internal returns (address augToken) {\\n    (address token, uint amount) = _S().augmentInfo[item].unpackAddressWithAmount();\\n    if (token != address(0)) {\\n      controller.process(token, amount / divider, msgSender);\\n    }\\n    return token;\\n  }\\n\\n\\n  /// @notice Initialization for augment() and repairDurability()\\n  /// Get {meta} and {info}, check some restrictions\\n  /// @return meta Metadata of the item\\n  /// @return info Unpacked item info\\n  /// @return inSandbox [item is in the sandbox, consumable item is in the sandbox]\\n  function _prepareToAugment(\\n    IItemController.MainState storage s_,\\n    ControllerContextLib.ControllerContext memory cc,\\n    ItemLib.SenderInfo memory senderInfo,\\n    address item,\\n    uint itemId,\\n    uint consumedItemId\\n  ) internal view returns (\\n    IItemController.ItemMeta memory meta,\\n    IItemController.ItemInfo memory info,\\n    bool[2] memory inSandbox\\n  ) {\\n    ItemLib.checkPauseEoa(senderInfo, cc.controller);\\n\\n    ItemLib.onlyNotEquippedItem(item, itemId);\\n    ItemLib.onlyNotEquippedItem(item, consumedItemId);\\n\\n    inSandbox = ItemLib._checkOwnerItems(cc, ItemLib.ItemWithId(item, itemId), ItemLib.ItemWithId(item, consumedItemId), senderInfo.msgSender);\\n\\n    if (itemId == consumedItemId) revert IAppErrors.SameIdsNotAllowed();\\n    meta = ItemLib.unpackedItemMeta(s_.itemMeta[item]);\\n    info = ItemLib.unpackedItemInfo(s_.itemInfo[item.packNftId(itemId)]);\\n\\n    return (meta, info, inSandbox);\\n  }\\n\\n\\n  /// @notice Modify either positive or negative values\\n  /// @param ignoreNegative True - leave unchanged all negative values, False - don't change all positive values\\n  function _augmentAttributes(bytes32[] memory packedAttr, bool ignoreNegative) internal pure returns (\\n    int32[] memory values,\\n    uint8[] memory ids\\n  ) {\\n    (values, ids) = packedAttr.toInt32ArrayWithIds();\\n    for (uint i; i < values.length; ++i) {\\n      // do not increase destroy item attribute\\n      if(uint(ids[i]) == uint(IStatController.ATTRIBUTES.DESTROY_ITEMS)) {\\n        continue;\\n      }\\n      if ((ignoreNegative && values[i] > 0) || (!ignoreNegative && values[i] < 0)) {\\n        values[i] = _augmentAttribute(values[i]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Increase/decrease positive/negative value on ceil(value/20) but at least on 1\\n  function _augmentAttribute(int32 value) internal pure returns (int32) {\\n    if (value == 0) {\\n      return 0;\\n    }\\n    // bonus must be not lower than 1\\n    if (value > 0) {\\n      return value + int32(int(Math.max(Math.ceilDiv(value.toUint(), AUGMENT_FACTOR), 1)));\\n    } else {\\n      return value - int32(int(Math.max(Math.ceilDiv((- value).toUint(), AUGMENT_FACTOR), 1)));\\n    }\\n  }\\n  //endregion ------------------------ Internal logic - augmentation\\n\\n  //region ------------------------ Internal logic\\n  function _destroy(ControllerContextLib.ControllerContext memory cc, address item, uint itemId, bool inSandbox) internal {\\n    if (inSandbox) {\\n      ControllerContextLib.itemBoxController(cc).destroyItem(item, itemId);\\n    } else {\\n      IItem(item).burn(itemId);\\n    }\\n    emit IApplicationEvents.Destroyed(item, itemId);\\n  }\\n\\n  /// @param nextPrng_ CalcLib.nextPrng, param is required by unit tests\\n  function _mintRandomItems(\\n    MintItemInfo memory info,\\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\\n  ) internal returns (address[] memory) {\\n\\n    // if hero is not in his biome do not mint at all\\n    if (info.mintDropChanceDelta != 0) {\\n      return new address[](0);\\n    }\\n\\n    uint len = info.mintItems.length;\\n\\n    // Fisher\\u2013Yates shuffle\\n    LibPRNG.PRNG memory prng = LibPRNG.PRNG(info.oracle.getRandomNumber(CalcLib.MAX_CHANCE, info.seed));\\n    uint[] memory indices = new uint[](len);\\n    for (uint i = 1; i < len; ++i) {\\n      indices[i] = i;\\n    }\\n    LibPRNG.shuffle(prng, indices);\\n\\n    address[] memory minted = new address[](len);\\n    uint mintedLength;\\n    uint di = Math.min(CalcLib.toUint(info.destroyItems), 100);\\n\\n    for (uint i; i < len; ++i) {\\n      if (info.mintItemsChances[indices[i]] > CalcLib.MAX_CHANCE) {\\n        revert IAppErrors.TooHighChance(info.mintItemsChances[indices[i]]);\\n      }\\n\\n      uint chance = _adjustChance(info.mintItemsChances[indices[i]], info, di);\\n\\n      // need to call random in each loop coz each minted item should have dedicated chance\\n      uint rnd = nextPrng_(prng, CalcLib.MAX_CHANCE); // randomWithSeed_(CalcLib.MAX_CHANCE, rndSeed);\\n\\n      if (chance != 0 && (chance >= CalcLib.MAX_CHANCE || rnd < chance)) {\\n        // There is no break here: the cycle is continued even if the number of the minted items reaches the max.\\n        // The reason: gas consumption of success operation must be great of equal of the gas consumption of fail op.\\n        if (mintedLength < info.maxItems) {\\n          minted[i] = info.mintItems[indices[i]];\\n          ++mintedLength;\\n        }\\n      }\\n    }\\n\\n    address[] memory mintedAdjusted = new address[](mintedLength);\\n    uint j;\\n    for (uint i; i < len; ++i) {\\n      if (minted[i] != address(0)) {\\n        mintedAdjusted[j] = minted[i];\\n        ++j;\\n      }\\n    }\\n\\n    return mintedAdjusted;\\n  }\\n\\n  /// @notice Apply all corrections to the chance of item drop\\n  /// There are two params to increase chances: amplifier and magicFind\\n  /// There are two params to decrease chances: destroyItems and mintDropChanceNgLevelMultiplier\\n  /// @param info Assume here, that info.mintDropChanceNgLevelMultiplier is in the range [0..1e18]\\n  /// @param di Assume that di <= 100\\n  function _adjustChance(uint32 itemChance, MintItemInfo memory info, uint di) internal pure returns (uint) {\\n    uint chance = uint(itemChance) * Math.min(1e18, info.mintDropChanceNgLevelMultiplier) / 1e18;\\n    chance += chance * info.amplifier / StatLib._MAX_AMPLIFIER;\\n    chance += chance * CalcLib.toUint(info.magicFind) / 100;\\n    chance -= chance * di / 100;\\n    return chance;\\n  }\\n\\n  function _setupNewAttributes(\\n    IItemController.MainState storage s,\\n    address item,\\n    uint itemId,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (\\n    IItemController.ItemMeta memory meta,\\n    uint8[] memory ids,\\n    int32[] memory values,\\n    IItemController.ItemRarity itemRarity\\n  ){\\n    meta = unpackedItemMeta(s.itemMeta[item]);\\n    (ids, values, itemRarity) = _generateAttributes(unpackItemGenerateInfo(s.generateInfoAttributes[item]), meta, random_);\\n\\n    bytes32 packedItemId = item.packNftId(itemId);\\n    if (ids.length != 0) {\\n      s._itemAttributes[packedItemId] = values.toBytes32ArrayWithIds(ids);\\n    }\\n\\n    s.itemInfo[packedItemId] = PackingLib.packItemInfo(uint8(itemRarity), 0, meta.baseDurability);\\n  }\\n\\n  function _setupNewAttackItem(IItemController.MainState storage s, address item, uint itemId) internal returns (bytes32 attackInfo){\\n    // we just write data for attack item, no need to generate, it will be augmented later so need individual data for itemId\\n    attackInfo = s.generateInfoAttack[item];\\n    s._itemAttackInfo[item.packNftId(itemId)] = attackInfo;\\n  }\\n\\n  function _setupNewBuffItem(\\n    IItemController.MainState storage s,\\n    address item,\\n    uint itemId,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (\\n    uint8[] memory casterIds,\\n    int32[] memory casterValues,\\n    uint8[] memory targetIds,\\n    int32[] memory targetValues\\n  ){\\n\\n    // CASTER\\n    (casterIds, casterValues) = _generateSimpleAttributes(\\n      unpackItemGenerateInfo(s.generateInfoCasterAttributes[item]),\\n      true,\\n      random_\\n    );\\n\\n    if (casterIds.length != 0) {\\n      s._itemCasterAttributes[item.packNftId(itemId)] = casterValues.toBytes32ArrayWithIds(casterIds);\\n    }\\n\\n    // TARGET\\n    (targetIds, targetValues) = _generateSimpleAttributes(\\n      unpackItemGenerateInfo(s.generateInfoTargetAttributes[item]),\\n      true,\\n      random_\\n    );\\n\\n    if (targetIds.length != 0) {\\n      s._itemTargetAttributes[item.packNftId(itemId)] = targetValues.toBytes32ArrayWithIds(targetIds);\\n    }\\n  }\\n\\n  /// @notice Generate all mandatory attributes and try to generate required number of random attributes.\\n  /// Generate at least {info.minRandomAttributes} of random attributes if it's possible\\n  /// but not more than {info.maxRandomAttributes}. Value of each attribute is generated randomly according its chances.\\n  /// @param meta Assume, that meta.min != 0, meta.max != 0 and both meta.min and meta.min should have same sign\\n  /// because results value cannot be 0\\n  /// @return ids Ids of the attributes, zero id is allowed\\n  /// @return values Randomly generated attributes values, min <= value <= max\\n  /// @return itemRarity Rarity of the item (Either meta.defaultRarity or calculated if there is no default rarity)\\n  function _generateAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    IItemController.ItemMeta memory meta,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    uint8[] memory ids,\\n    int32[] memory values,\\n    IItemController.ItemRarity itemRarity\\n  ) {\\n    GenerateAttributesContext memory ctx;\\n\\n    uint len = info.ids.length;\\n    if (len != 0) {\\n      ctx.ids = new uint8[](len);\\n      ctx.values = new int32[](len);\\n      ctx.usedIndexes = new bool[](len);\\n\\n      // Fisher\\u2013Yates shuffle\\n      _shuffleInfo(info, random_);\\n\\n      // initialize ctx by initial values\\n      // generate all mandatory attributes, try to generate not more than {meta.maxRandomAttributes} random attributes\\n      _prepareAttributes(info, meta.maxRandomAttributes, ctx, random_);\\n\\n      // generate missing random attributes if it's necessary, ctx.counter is incremented\\n      _generateMissingRandomAttributes(info, meta.minRandomAttributes, ctx, random_);\\n\\n      itemRarity = meta.defaultRarity == 0\\n        ? _calculateRarity(ctx.randomSum, ctx.chancesSum, ctx.randomAttrCounter, meta.maxRandomAttributes)\\n        : IItemController.ItemRarity(meta.defaultRarity);\\n    } else {\\n      itemRarity = IItemController.ItemRarity.UNKNOWN;\\n    }\\n\\n    (ids, values) = _fixLengthsIdsValues(ctx.ids, ctx.values, ctx.counter);\\n  }\\n\\n  /// @notice Generate missing random attributes if necessary\\n  function _generateMissingRandomAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    uint8 minRandomAttributes,\\n    GenerateAttributesContext memory ctx,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint attrToGen = Math.min(ctx.totalRandomAttrsPossible, minRandomAttributes);\\n    if (ctx.randomAttrCounter < attrToGen && ctx.totalRandomAttrsPossible > ctx.randomAttrCounter) {\\n      // it's necessary AND possible to generate more random attributes\\n      uint possibleRemainingAttrs = ctx.totalRandomAttrsPossible - ctx.randomAttrCounter;\\n      uint remainingAttrsToGen = attrToGen - ctx.randomAttrCounter;\\n\\n      uint[] memory indicesToGen = new uint[](possibleRemainingAttrs);\\n      uint indicesToGenCounter;\\n\\n      // enumerate all attributes, add all indices of not-generated attributes to {indexesToGen}\\n      for (uint i; i < info.ids.length; ++i) {\\n        // mandatory attrs should be already generated and no need to check\\n        if (!ctx.usedIndexes[i]) {\\n          indicesToGen[indicesToGenCounter] = i;\\n          indicesToGenCounter++;\\n        }\\n      }\\n\\n      // Shuffle indices of not-generated attributes using Fisher\\u2013Yates shuffle\\n      if (possibleRemainingAttrs > 1) {\\n        for (uint i; i < possibleRemainingAttrs - 1; ++i) {\\n          uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, possibleRemainingAttrs - 1, random_);\\n          (indicesToGen[randomIndex], indicesToGen[i]) = (indicesToGen[i], indicesToGen[randomIndex]);\\n        }\\n      }\\n      // Generate necessary amount of attributes. Fist (shuffled) attributes are selected (MAX_CHANCE is used for each)\\n      for (uint i; i < remainingAttrsToGen; ++i) {\\n        uint idx = indicesToGen[i];\\n        (int32 attr,) = _generateAttribute(info.mins[idx], info.maxs[idx], CalcLib.MAX_CHANCE, random_);\\n        ctx.ids[ctx.counter] = info.ids[idx];\\n        ctx.values[ctx.counter] = attr;\\n        ctx.counter++;\\n      }\\n    }\\n  }\\n\\n  /// @notice Generate all mandatory attributes, generate not more than {meta.maxRandomAttributes} random attributes.\\n  /// Updates context:\\n  ///   {ctx.totalRandomAttrsPossible} - total number of possible random attributes\\n  ///   {ctx.randomAttrCounter} - total number of generated random attributes  <= {maxRandomAttributes}\\n  ///   {ctx.randomSum} = sum of random of all random attributes.\\n  ///   {ctx.chancesSum} = sum of chances of all random attributes.\\n  ///   {ctx.counter} = total number of generated attributes. Values of ctx.ids, ctx.values, ctx.usedIndexes are\\n  ///   initialized in the range [0...ctx.counter)\\n  /// @param ctx Empty struct but arrays ids, values and usedIndexes should be allocated for info.ids.length items\\n  function _prepareAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    uint8 maxRandomAttributes,\\n    GenerateAttributesContext memory ctx,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint len = info.ids.length;\\n    for (uint i; i < len; ++i) {\\n      if (info.chances[i] != CalcLib.MAX_CHANCE) {\\n        ctx.totalRandomAttrsPossible++;\\n      }\\n\\n      if (info.chances[i] >= CalcLib.MAX_CHANCE || !ctx.stopGenerateRandom) {\\n        (int32 attr, uint random) = _generateAttribute(info.mins[i], info.maxs[i], info.chances[i], random_);\\n\\n        // count only random attributes for calc rarity\\n        if (attr != 0) {\\n\\n          if (\\n            info.chances[i] < CalcLib.MAX_CHANCE\\n            // && random != 0 // commented: random = 0 can produce crash in _generateMissingRandomAttributes\\n          ) {\\n            ctx.randomAttrCounter++;\\n            ctx.randomSum += random;\\n            ctx.chancesSum += info.chances[i];\\n          }\\n          ctx.ids[ctx.counter] = info.ids[i];\\n          ctx.values[ctx.counter] = attr;\\n          ctx.counter++;\\n          ctx.usedIndexes[i] = true;\\n        }\\n\\n        // it is a bit less fair random for attrs in the end of the list, however we assume it should be pretty rare case\\n        if (ctx.randomAttrCounter == maxRandomAttributes) {\\n          ctx.stopGenerateRandom = true;\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Shuffle info arrays using Fisher\\u2013Yates shuffle algo\\n  function _shuffleInfo(\\n    IItemController.ItemGenerateInfo memory info,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint len = info.ids.length;\\n    if (len > 1) {\\n      for (uint i; i < len - 1; i++) {\\n        uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, len - 1, random_);\\n\\n        (info.ids[randomIndex], info.ids[i]) = (info.ids[i], info.ids[randomIndex]);\\n        (info.mins[randomIndex], info.mins[i]) = (info.mins[i], info.mins[randomIndex]);\\n        (info.maxs[randomIndex], info.maxs[i]) = (info.maxs[i], info.maxs[randomIndex]);\\n        (info.chances[randomIndex], info.chances[i]) = (info.chances[i], info.chances[randomIndex]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Generate array [0,1,2.. N-1] and shuffle it using Fisher\\u2013Yates shuffle algo\\n  function _shuffleIndices(\\n    uint countItems,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint[] memory indices){\\n    indices = new uint[](countItems);\\n    for (uint i = 1; i < countItems; ++i) {\\n      indices[i] = i;\\n    }\\n    if (countItems > 1) {\\n      for (uint i; i < countItems - 1; i++) {\\n        uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, countItems - 1, random_);\\n        (indices[randomIndex], indices[i]) = (indices[i], indices[randomIndex]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Reduce lengths of {ids} and {values} to {count}\\n  function _fixLengthsIdsValues(uint8[] memory ids, int32[] memory values, uint count) internal pure returns (\\n    uint8[] memory idsOut,\\n    int32[] memory valuesOut\\n  ) {\\n    if (count == ids.length) {\\n      return (ids, values);\\n    }\\n\\n    idsOut = new uint8[](count);\\n    valuesOut = new int32[](count);\\n    for (uint i; i < count; ++i) {\\n      idsOut[i] = ids[i];\\n      valuesOut[i] = values[i];\\n    }\\n    return (idsOut, valuesOut);\\n  }\\n\\n  /// @param random_ Pass CalcLib.pseudoRandom here, param is required for unit tests. Max value is MAX_CHANCE\\n  function _generateSimpleAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    bool maxChance,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    uint8[] memory ids,\\n    int32[] memory values\\n  ) {\\n    uint len = info.ids.length;\\n    ids = new uint8[](len);\\n    values = new int32[](len);\\n\\n    uint n = 0;\\n    for (uint i; i < len; ++i) {\\n      (int32 attr,) = _generateAttribute(\\n        info.mins[i],\\n        info.maxs[i],\\n        maxChance ? CalcLib.MAX_CHANCE : info.chances[i],\\n        random_\\n      );\\n      if (attr != 0) {\\n        ids[n] = info.ids[i];\\n        values[n] = attr;\\n        ++n;\\n      }\\n    }\\n\\n    return _fixLengthsIdsValues(ids, values, n);\\n  }\\n\\n  //endregion ------------------------ Internal logic\\n\\n  //region ------------------------ Internal utils\\n  /// @param chance Chance in the range [0...MAX_CHANCE], MAX_CHANCE=1e9 means \\\"mandatory\\\" element.\\n  /// @param random_ Pass CalcLib.pseudoRandom here, param is required for unit tests\\n  /// @return attr Either 0 or min <= attr <= max\\n  /// @return rnd Random value in the range [0...MAX_CHANCE]; It's always 0 for mandatory elements\\n  function _generateAttribute(\\n    int32 min,\\n    int32 max,\\n    uint32 chance,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    int32 attr,\\n    uint rnd\\n  ) {\\n    if (chance > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighChance(chance);\\n\\n    uint diff = uint(CalcLib.absDiff(min, max));\\n\\n    if (chance < CalcLib.MAX_CHANCE) {\\n      uint32 random = CalcLib.pseudoRandomUint32Flex(CalcLib.MAX_CHANCE, random_);\\n      if (random < chance) {\\n        uint r = uint(CalcLib.MAX_CHANCE - random * (CalcLib.MAX_CHANCE / chance));\\n        int32 k = int32(int(r * diff / uint(CalcLib.MAX_CHANCE)));\\n        return (min + k, random);\\n      }\\n    } else { // chance == CalcLib.MAX_CHANCE => mandatory element\\n      if (diff == 0) {\\n        return (min, 0);\\n      } else {\\n        uint r = uint(CalcLib.pseudoRandomUint32Flex(CalcLib.MAX_CHANCE, random_));\\n        int32 k = int32(int(r % (diff + 1)));\\n\\n        // return zero random - no need to calc rarity for mandatory elements\\n        return (min + k, 0);\\n      }\\n    }\\n\\n    return (0, 0);\\n  }\\n\\n  /// @notice Calculate item rarity\\n  /// @param randomSum Total sum random values of all random attributes in ItemGenerateInfo, [0...MAX_CHANCE/attrCounter]\\n  /// @param chancesSum Total sum of all random chances in ItemGenerateInfo\\n  /// @param attrCounter Count of random attributes in ItemGenerateInfo\\n  /// @param maxAttr Index of max allowed random attribute (all attributes with higher indices are not random)\\n  /// @return item rarity\\n  function _calculateRarity(uint randomSum, uint chancesSum, uint attrCounter, uint maxAttr) internal pure returns (\\n    IItemController.ItemRarity\\n  ) {\\n    if (attrCounter == 0) {\\n      return IItemController.ItemRarity.NORMAL;\\n    }\\n\\n    uint random = randomSum / attrCounter;\\n    uint averageChance = chancesSum / attrCounter;\\n\\n    if (random > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighRandom(random);\\n\\n    if (random < averageChance / 4 && attrCounter == maxAttr) {\\n      return IItemController.ItemRarity.RARE;\\n    } else if (random < averageChance * 3 / 4) {\\n      return attrCounter > 2\\n        ? IItemController.ItemRarity.RARE\\n        : IItemController.ItemRarity.MAGIC;\\n    } else {\\n      return attrCounter > 1\\n        ? IItemController.ItemRarity.MAGIC\\n        : IItemController.ItemRarity.NORMAL;\\n    }\\n  }\\n\\n  function _getSandboxMode(ControllerContextLib.ControllerContext memory cc, address hero, uint heroId) internal view returns (\\n    IHeroController.SandboxMode sandboxMode\\n  ) {\\n    return IHeroController.SandboxMode(ControllerContextLib.heroController(cc).sandboxMode(hero, heroId));\\n  }\\n  //endregion ------------------------ Internal utils\\n\\n  //region ------------------------ PACKING\\n\\n  function packItemGenerateInfo(IItemController.ItemGenerateInfo memory info) internal pure returns (bytes32[] memory result) {\\n    uint len = info.ids.length;\\n    if (len != info.mins.length || len != info.maxs.length || len != info.chances.length) {\\n      revert IAppErrors.LengthsMismatch();\\n    }\\n\\n    result = new bytes32[](len);\\n\\n    for (uint i; i < len; ++i) {\\n      result[i] = PackingLib.packItemGenerateInfo(info.ids[i], info.mins[i], info.maxs[i], info.chances[i]);\\n    }\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32[] memory gen) internal pure returns (\\n    IItemController.ItemGenerateInfo memory\\n  ) {\\n    uint length = gen.length;\\n\\n    uint8[] memory ids = new uint8[](length);\\n    int32[] memory mins = new int32[](length);\\n    int32[] memory maxs = new int32[](length);\\n    uint32[] memory chances = new uint32[](length);\\n\\n    for (uint i; i < length; ++i) {\\n      (ids[i], mins[i], maxs[i], chances[i]) = gen[i].unpackItemGenerateInfo();\\n    }\\n\\n    return IItemController.ItemGenerateInfo(ids, mins, maxs, chances);\\n  }\\n\\n  function packItemMeta(IItemController.ItemMeta memory meta) internal pure returns (bytes32) {\\n    return PackingLib.packItemMeta(\\n      meta.itemMetaType,\\n      meta.itemLevel,\\n      uint8(meta.itemType),\\n      meta.baseDurability,\\n      meta.defaultRarity,\\n      meta.minRandomAttributes,\\n      meta.maxRandomAttributes,\\n      meta.manaCost,\\n      meta.requirements\\n    );\\n  }\\n\\n  function unpackedItemMeta(bytes32 meta) internal pure returns (IItemController.ItemMeta memory result) {\\n    return meta.unpackItemMeta();\\n  }\\n\\n  function packItemInfo(IItemController.ItemInfo memory info) internal pure returns (bytes32) {\\n    return PackingLib.packItemInfo(uint8(info.rarity), info.augmentationLevel, info.durability);\\n  }\\n\\n  function unpackedItemInfo(bytes32 info) internal pure returns (IItemController.ItemInfo memory result) {\\n    uint8 rarity;\\n    (rarity, result.augmentationLevel, result.durability) = info.unpackItemInfo();\\n\\n    result.rarity = IItemController.ItemRarity(rarity);\\n    return result;\\n  }\\n\\n  function packItemAttackInfo(IItemController.AttackInfo memory info) internal pure returns (bytes32) {\\n    return PackingLib.packItemAttackInfo(\\n      uint8(info.aType),\\n      info.min,\\n      info.max,\\n      info.attributeFactors.strength,\\n      info.attributeFactors.dexterity,\\n      info.attributeFactors.vitality,\\n      info.attributeFactors.energy\\n    );\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 info) internal pure returns (IItemController.AttackInfo memory result) {\\n    IStatController.CoreAttributes memory fs;\\n    uint8 aType;\\n    (aType, result.min, result.max, fs.strength, fs.dexterity, fs.vitality, fs.energy) = info.unpackItemAttackInfo();\\n\\n    result.aType = IItemController.AttackType(aType);\\n    result.attributeFactors = fs;\\n\\n    return result;\\n  }\\n  //endregion ------------------------ PACKING\\n}\\n\",\"keccak256\":\"0x744d313a38f67b2f2239920380452371c7c0469f0388dff182eb5aa01bf5ce3f\",\"license\":\"BUSL-1.1\"},\"contracts/lib/MonsterLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\nimport \\\"./StatLib.sol\\\";\\nimport \\\"./ItemLib.sol\\\";\\nimport \\\"./StringLib.sol\\\";\\nimport \\\"./FightLib.sol\\\";\\nimport \\\"./RewardsPoolLib.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IFightCalculator.sol\\\";\\nimport \\\"../interfaces/IDungeonFactory.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary MonsterLib {\\n  using CalcLib for int32;\\n  using PackingLib for bytes32;\\n  using PackingLib for bytes32[];\\n  using PackingLib for uint16;\\n  using PackingLib for uint8;\\n  using PackingLib for address;\\n  using PackingLib for uint32[];\\n  using PackingLib for uint32;\\n  using PackingLib for uint64;\\n  using PackingLib for int32[];\\n  using PackingLib for int32;\\n\\n  /// @notice Max value for monster rarity and monster/dungeon multiplier\\n  uint32 internal constant _MAX_AMPLIFIER = 1e9;\\n  uint private constant _TOTAL_SUPPLY_BASE = 10_000_000e18;\\n\\n  /// @notice Base monster multiplier for NG+. Multiplier = base multiplier * hero ng_level\\n  uint internal constant _MONSTER_MULTIPLIER_NGP_BASE = uint(_MAX_AMPLIFIER);\\n\\n  //region ------------------------ Data types\\n  struct AdrContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IOracle oracle;\\n    IStatController statController;\\n    IItemController itemController;\\n    uint heroTokenId;\\n  }\\n\\n  struct FightInternalInfo {\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 heroLifeRegen;\\n    int32 heroHp;\\n    int32 monsterHp;\\n    uint32 monsterRarity;\\n    IFightCalculator.FighterInfo heroFightInfo;\\n    IFightCalculator.FighterInfo monsterFightInfo;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Main logic\\n\\n  /// @param heroNgLevel Pass type(uint8).max for !NG+\\n  function initialGeneration(\\n    IGOC.MonsterInfo storage mInfo,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint iteration,\\n    uint8 heroNgLevel\\n  ) internal {\\n    return _initialGeneration(mInfo, heroToken, heroTokenId, iteration, _pseudoRandom, heroNgLevel);\\n  }\\n\\n  /// @notice Fight, post fight, generate fight results\\n  /// @return result Fields objectId, heroToken, heroTokenId, iteration remain uninitialized here.\\n  /// Caller is responsible to set that values.\\n  /// @dev weird, but memory ctx is more efficient here than calldata ctx\\n  function action(IGOC.ActionContext memory ctx, IGOC.MonsterInfo storage mInfo) external returns (\\n    IGOC.ActionResult memory result,\\n    uint8 turn\\n  ) {\\n    return _action(ctx, mInfo, _pseudoRandom, FightLib.fight);\\n  }\\n\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ Internal calculations\\n  function _action(\\n    IGOC.ActionContext memory ctx,\\n    IGOC.MonsterInfo storage mInfo,\\n    function (uint) internal view returns (uint) random_,\\n    function(\\n      IItemController,\\n      IFightCalculator.FightCall memory,\\n      IFightCalculator.FightCallAdd memory,\\n      function (uint) internal view returns (uint)\\n    ) internal returns (IFightCalculator.FightResult memory) fight_\\n  ) internal returns (\\n    IGOC.ActionResult memory result,\\n    uint8 turn\\n  ) {\\n    AdrContext memory adrCtx = _context(ctx);\\n    IGOC.GeneratedMonster memory gen = unpackGeneratedMonster(mInfo._generatedMonsters[ctx.heroToken.packNftId(ctx.heroTokenId)][ctx.iteration]);\\n    turn = gen.turnCounter;\\n\\n    (FightInternalInfo memory fInfo, IGOC.MonsterGenInfo memory genInfo) = _fight(ctx, mInfo, gen, adrCtx, random_, fight_);\\n    result = _postFight(mInfo, ctx, adrCtx, fInfo, genInfo, gen);\\n  }\\n\\n  /// @dev This function was extracted from {action()} to simplify unit testing\\n  /// @param gen These values CAN BE modified in place in some cases.\\n  /// @return result Fields objectId, heroToken, heroTokenId, iteration remain uninitialized here.\\n  /// Caller is responsible to set that values.\\n  function _postFight(\\n    IGOC.MonsterInfo storage mInfo,\\n    IGOC.ActionContext memory ctx,\\n    AdrContext memory adrCtx,\\n    FightInternalInfo memory fInfo,\\n    IGOC.MonsterGenInfo memory genInfo,\\n    IGOC.GeneratedMonster memory gen\\n  ) internal returns (\\n    IGOC.ActionResult memory result\\n  ) {\\n    bytes32 heroPackedId = ctx.heroToken.packNftId(ctx.heroTokenId);\\n    if (gen.turnCounter > 100) {\\n      // instant kill hero if too long battle\\n      fInfo.heroHp = 0;\\n    }\\n\\n    bool isMonsterDead = fInfo.monsterHp == 0;\\n    bool isHeroDead = fInfo.heroHp == 0;\\n\\n    if (isMonsterDead) {\\n      _bossDefeated(adrCtx, ctx);\\n    }\\n\\n    if (isMonsterDead || isHeroDead) {\\n      if (gen.generated) {\\n        delete mInfo._generatedMonsters[heroPackedId][ctx.iteration];\\n      }\\n      // assume that if the hero is dead clearUsedConsumables will be called in _objectAction\\n      if (isMonsterDead) {\\n        adrCtx.statController.clearUsedConsumables(ctx.heroToken, ctx.heroTokenId);\\n      }\\n    } else {\\n      if (gen.generated) {\\n        gen.hp = fInfo.monsterHp;\\n        gen.turnCounter = gen.turnCounter + 1;\\n      } else {\\n        // new instance of gen is created\\n        gen = IGOC.GeneratedMonster({\\n          generated: true,\\n          amplifier: fInfo.monsterRarity,\\n          hp: fInfo.monsterHp,\\n          turnCounter: 1\\n        });\\n      }\\n\\n      mInfo._generatedMonsters[heroPackedId][ctx.iteration] = packGeneratedMonster(gen);\\n    }\\n\\n    if (isMonsterDead) {\\n      bytes32 index = _getMonsterCounterIndex(ctx.objectId);\\n      uint curValue = adrCtx.statController.heroCustomData(ctx.heroToken, ctx.heroTokenId, index);\\n      adrCtx.statController.setHeroCustomData(ctx.heroToken, ctx.heroTokenId, index, curValue + 1);\\n    }\\n\\n    // --- generate result\\n    result.kill = isHeroDead;\\n    result.experience = isMonsterDead\\n      ? StatLib.expPerMonster(\\n        fInfo.monsterFightInfo.fighterStats.experience,\\n        fInfo.monsterRarity,\\n        fInfo.heroFightInfo.fighterStats.experience,\\n        fInfo.heroFightInfo.fighterStats.level,\\n        ctx.biome\\n      )\\n      : 0;\\n\\n    result.heal = fInfo.heroLifeRegen;\\n    result.manaRegen = isMonsterDead ? fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MANA_AFTER_KILL)] : int32(0);\\n    // result.lifeChancesRecovered = 0; // zero by default\\n    result.damage = fInfo.damage;\\n    result.manaConsumed = fInfo.manaConsumed;\\n    result.mintItems = isMonsterDead\\n      ? _mintRandomItems(fInfo, ctx, genInfo, CalcLib.nextPrng)\\n      : new address[](0);\\n    result.completed = isMonsterDead || isHeroDead;\\n\\n    return result;\\n  }\\n\\n  /// @notice Generate new {GeneratedMonster} and put it to {mInfo._generatedMonsters}\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...MAX_AMPLIFIER]\\n  /// @param heroNgLevel Assume type(uint8).max for !NG+\\n  function _initialGeneration(\\n    IGOC.MonsterInfo storage mInfo,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint iteration,\\n    function (uint) internal view returns (uint) random_,\\n    uint8 heroNgLevel\\n  ) internal {\\n    IGOC.GeneratedMonster memory gen = IGOC.GeneratedMonster({\\n      generated: true,\\n      amplifier: uint32(random_(_MAX_AMPLIFIER)),\\n      hp: 0,\\n      turnCounter: 0\\n    });\\n\\n    IGOC.MonsterGenInfo memory info = unpackMonsterInfo(mInfo);\\n\\n    (int32[] memory attributes,) = generateMonsterAttributes(\\n      info.attributeIds,\\n      info.attributeValues,\\n      gen.amplifier,\\n      monsterMultiplier(heroNgLevel),\\n      info.experience\\n    );\\n    gen.hp = attributes[uint(IStatController.ATTRIBUTES.LIFE)];\\n\\n    mInfo._generatedMonsters[heroToken.packNftId(heroTokenId)][iteration] = packGeneratedMonster(gen);\\n  }\\n\\n  function _bossDefeated(AdrContext memory adrCtx, IGOC.ActionContext memory ctx) internal {\\n    if (ctx.objectSubType == uint8(IGOC.ObjectSubType.BOSS_3)) {\\n      IDungeonFactory(adrCtx.controller.dungeonFactory()).setBossCompleted(ctx.objectId, ctx.heroToken, ctx.heroTokenId, ctx.biome);\\n    }\\n  }\\n\\n  function _collectHeroFighterInfo(\\n    IFightCalculator.AttackInfo memory attackInfo,\\n    AdrContext memory adrContext\\n  ) internal view returns (\\n    IFightCalculator.FighterInfo memory fInfo,\\n    int32 manaConsumed\\n  ) {\\n    IStatController.ChangeableStats memory heroStats = adrContext.statController.heroStats(adrContext.heroToken, adrContext.heroTokenId);\\n\\n    (int32[] memory heroAttributes, int32 _manaConsumed) = _buffAndGetHeroAttributes(\\n      heroStats.level,\\n      attackInfo.skillTokens,\\n      attackInfo.skillTokenIds,\\n      adrContext.statController,\\n      adrContext.heroToken,\\n      adrContext.heroTokenId\\n    );\\n\\n    manaConsumed = _manaConsumed;\\n\\n    if (attackInfo.attackType == IFightCalculator.AttackType.MAGIC) {\\n      manaConsumed += int32(adrContext.itemController.itemMeta(attackInfo.attackToken).manaCost);\\n    }\\n\\n    fInfo = IFightCalculator.FighterInfo({\\n      fighterAttributes: heroAttributes,\\n      fighterStats: heroStats,\\n      attackType: attackInfo.attackType,\\n      attackToken: attackInfo.attackToken,\\n      attackTokenId: attackInfo.attackTokenId,\\n      race: uint(IStatController.Race.HUMAN)\\n    });\\n  }\\n\\n  function _buffAndGetHeroAttributes(\\n    uint level,\\n    address[] memory skillTokens,\\n    uint[] memory skillTokenIds,\\n    IStatController statController,\\n    address heroToken,\\n    uint heroTokenId\\n  ) internal view returns (\\n    int32[] memory heroAttributes,\\n    int32 manaConsumed\\n  ) {\\n    return statController.buffHero(IStatController.BuffInfo({\\n      heroToken: heroToken,\\n      heroTokenId: heroTokenId,\\n      heroLevel: uint32(level),\\n      buffTokens: skillTokens,\\n      buffTokenIds: skillTokenIds\\n    }));\\n  }\\n\\n  /// @notice Get skill tokens, ensure that they are equipped on, add skill-tokens target attributes to hero attributes\\n  /// @param attributes Hero attributes. These values are incremented in place\\n  // @param heroAttackInfo Checked attack info. Assume that all skill tokens belong either to the hero or to the helper.\\n  function _debuff(\\n    int32[] memory attributes,\\n    IFightCalculator.AttackInfo memory attackInfo,\\n    IItemController itemController\\n  ) internal view {\\n    uint length = attackInfo.skillTokens.length;\\n    for (uint i; i < length; ++i) {\\n      (int32[] memory values, uint8[] memory ids) = itemController.targetAttributes(attackInfo.skillTokens[i], attackInfo.skillTokenIds[i]);\\n      StatLib.attributesAdd(attributes, StatLib.valuesToFullAttributesArray(values, ids));\\n    }\\n  }\\n\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...MAX_AMPLIFIER]\\n  function _collectMonsterFighterInfo(\\n    IGOC.MultiplierInfo memory multiplierInfo,\\n    IGOC.MonsterInfo storage mInfo,\\n    IGOC.GeneratedMonster memory gen,\\n    IFightCalculator.AttackInfo memory heroAttackInfo,\\n    uint heroLevel,\\n    AdrContext memory adrCtx,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    IFightCalculator.FighterInfo memory fighterInfo,\\n    uint32 rarity,\\n    IGOC.MonsterGenInfo memory genInfo\\n  ) {\\n    IFightCalculator.AttackInfo memory attackInfo;\\n\\n    rarity = gen.generated ? gen.amplifier : uint32(random_(_MAX_AMPLIFIER));\\n    (\\n      fighterInfo.fighterAttributes,\\n      fighterInfo.fighterStats.level,\\n      fighterInfo.fighterStats.experience,\\n      attackInfo,\\n      genInfo\\n    ) = _generateMonsterInfo(\\n      mInfo,\\n      rarity,\\n      monsterMultiplier(multiplierInfo.heroNgLevel),\\n      heroLevel,\\n      multiplierInfo.biome,\\n      random_\\n    );\\n\\n    _debuff(fighterInfo.fighterAttributes, heroAttackInfo, adrCtx.itemController);\\n\\n    fighterInfo.fighterStats.life = gen.generated\\n      ? uint32(gen.hp)\\n      : fighterInfo.fighterStats.life = uint32(CalcLib.max32(fighterInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.LIFE)], int32(1)));\\n\\n    fighterInfo.fighterStats.mana = uint32(fighterInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MANA)]);\\n\\n    fighterInfo.attackType = attackInfo.attackType;\\n    fighterInfo.attackToken = attackInfo.attackToken;\\n    fighterInfo.attackTokenId = attackInfo.attackTokenId;\\n    fighterInfo.race = genInfo.race;\\n\\n    return (fighterInfo, rarity, genInfo);\\n  }\\n\\n  /// @notice Fight between the hero and the monster\\n  /// @param random_ Pass _pseudoRandom here, param is required to simplify unit testing\\n  /// @param fight_ Pass FightLib.fight here, param is required to simplify unit testing\\n  function _fight(\\n    IGOC.ActionContext memory ctx,\\n    IGOC.MonsterInfo storage mInfo,\\n    IGOC.GeneratedMonster memory gen,\\n    AdrContext memory adrCtx,\\n    function (uint) internal view returns (uint) random_,\\n    function(\\n      IItemController,\\n      IFightCalculator.FightCall memory,\\n      IFightCalculator.FightCallAdd memory,\\n      function (uint) internal view returns (uint)\\n    ) internal returns (IFightCalculator.FightResult memory) fight_\\n  ) internal returns (\\n    FightInternalInfo memory fInfo,\\n    IGOC.MonsterGenInfo memory info\\n  ) {\\n    IFightCalculator.FighterInfo memory heroFightInfo;\\n    IFightCalculator.FighterInfo memory monsterFightInfo;\\n\\n    {\\n      IFightCalculator.AttackInfo memory heroAttackInfo = decodeAndCheckAttackInfo(\\n        adrCtx.itemController,\\n        IHeroController(IController(adrCtx.controller).heroController()),\\n        ctx.data,\\n        adrCtx.heroToken,\\n        adrCtx.heroTokenId\\n      );\\n\\n      // use fInfo.manaConsumed and fInfo.monsterRarity to story values temporally to avoid creation of additional vars\\n      (heroFightInfo, fInfo.manaConsumed) = _collectHeroFighterInfo(heroAttackInfo, adrCtx);\\n      (monsterFightInfo, fInfo.monsterRarity, info) = _collectMonsterFighterInfo(\\n        IGOC.MultiplierInfo({\\n          biome: ctx.biome,\\n          heroNgLevel: ctx.heroNgLevel\\n        }),\\n        mInfo,\\n        gen,\\n        heroAttackInfo,\\n        heroFightInfo.fighterStats.level,\\n        adrCtx,\\n        random_\\n      );\\n    }\\n\\n    // >>> FIGHT!\\n    IFightCalculator.FightResult memory fightResult = fight_(\\n      adrCtx.itemController,\\n      IFightCalculator.FightCall({\\n        fighterA: heroFightInfo,\\n        fighterB: monsterFightInfo,\\n        dungeonId: ctx.dungeonId,\\n        objectId: ctx.objectId,\\n        heroAdr: adrCtx.heroToken,\\n        heroId: adrCtx.heroTokenId,\\n        stageId: ctx.stageId,\\n        iteration: ctx.iteration,\\n        turn: gen.turnCounter\\n      }),\\n      IFightCalculator.FightCallAdd({\\n        msgSender: ctx.sender,\\n        fightId: 0\\n      }),\\n      random_\\n    );\\n\\n    fInfo = FightInternalInfo({\\n      manaConsumed: fInfo.manaConsumed + fightResult.manaConsumedA,\\n      monsterRarity: fInfo.monsterRarity,\\n      damage: _calcDmg(int32(heroFightInfo.fighterStats.life), fightResult.healthA),\\n      heroFightInfo: heroFightInfo,\\n      monsterFightInfo: monsterFightInfo,\\n      heroLifeRegen: fightResult.healthA > int32(heroFightInfo.fighterStats.life) ? fightResult.healthA - int32(heroFightInfo.fighterStats.life) : int32(0),\\n      heroHp: fightResult.healthA,\\n      monsterHp: fightResult.healthB\\n    });\\n  }\\n\\n  /// @param random_ Pass _pseudoRandom here, param is required for unit tests, range [0...1e18]\\n  /// @return attributes Attributes amplified on amplifier and dungeonMultiplier\\n  /// @return level Result level in the range: [mInfo.level .. heroLevel]\\n  /// @return experience Experience amplified on amplifier and dungeonMultiplier\\n  /// @return attackInfo Attack info. For magic hero attack type monster will have melee in half hits (randomly)\\n  /// @return info Unpacked data from {mInfo}, some fields can be uninitialized, see comments to unpackMonsterInfo (!)\\n  function _generateMonsterInfo(\\n    IGOC.MonsterInfo storage mInfo,\\n    uint32 amplifier,\\n    uint dungeonMultiplier,\\n    uint heroLevel,\\n    uint biome,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    int32[] memory attributes,\\n    uint32 level,\\n    uint32 experience,\\n    IFightCalculator.AttackInfo memory attackInfo,\\n    IGOC.MonsterGenInfo memory info\\n  ) {\\n    info = unpackMonsterInfo(mInfo);\\n\\n    level = uint32(info.level);\\n    if (level < heroLevel + 1) {\\n      level = uint32(Math.min(level + ((heroLevel - level) * 10 / 15), biome * 5));\\n    }\\n\\n    if (info.attackType == uint8(IFightCalculator.AttackType.MAGIC)) {\\n      // sometimes use melee (25% chance)\\n      uint rnd = random_(1e18);\\n      if (rnd > 0.75e18) {\\n        attackInfo.attackType = IFightCalculator.AttackType.MELEE;\\n      } else {\\n        attackInfo.attackType = IFightCalculator.AttackType.MAGIC;\\n        attackInfo.attackToken = info.attackToken;\\n        attackInfo.attackTokenId = info.attackTokenId;\\n      }\\n    } else {\\n      attackInfo.attackType = IFightCalculator.AttackType(info.attackType);\\n    }\\n\\n    (attributes, experience) = generateMonsterAttributes(\\n      info.attributeIds,\\n      info.attributeValues,\\n      amplifier,\\n      dungeonMultiplier,\\n      info.experience\\n    );\\n\\n    return (attributes, level, experience, attackInfo, info);\\n  }\\n\\n  function _mintRandomItems(\\n    FightInternalInfo memory fInfo,\\n    IGOC.ActionContext memory ctx,\\n    IGOC.MonsterGenInfo memory genInfo,\\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\\n  ) internal returns (\\n    address[] memory\\n  ) {\\n    return ItemLib._mintRandomItems(\\n      ItemLib.MintItemInfo({\\n        mintItems: genInfo.mintItems,\\n        mintItemsChances: genInfo.mintItemsChances,\\n        amplifier: fInfo.monsterRarity,\\n        seed: 0,\\n        oracle: IOracle(ctx.controller.oracle()),\\n        magicFind: fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.MAGIC_FIND)],\\n        destroyItems: fInfo.heroFightInfo.fighterAttributes[uint(IStatController.ATTRIBUTES.DESTROY_ITEMS)],\\n        maxItems: genInfo.maxDropItems,\\n        mintDropChanceDelta: ctx.objectSubType == uint8(IGOC.ObjectSubType.BOSS_3) ? 0 : // do not reduce drop for bosses at all\\n        StatLib.mintDropChanceDelta(\\n          fInfo.heroFightInfo.fighterStats.experience,\\n          uint8(fInfo.heroFightInfo.fighterStats.level),\\n          ctx.biome\\n        ),\\n        mintDropChanceNgLevelMultiplier: _getMintDropChanceNgLevelMultiplier(ctx)\\n      }),\\n      nextPrng_\\n    );\\n  }\\n\\n  /// @return drop chance multiplier, decimals 1e18; result value is guaranteed to be <= 1e18\\n  function _getMintDropChanceNgLevelMultiplier(IGOC.ActionContext memory ctx) internal view returns (uint) {\\n    return Math.min(1e18, RewardsPoolLib.dropChancePercent(\\n      IDungeonFactory(ctx.controller.dungeonFactory()).maxAvailableBiome(),\\n      IHeroController(ctx.controller.heroController()).maxOpenedNgLevel(),\\n      ctx.heroNgLevel\\n    ));\\n  }\\n\\n  //endregion ------------------------ Internal calculations\\n\\n  //region ------------------------ Utils\\n\\n  function _context(IGOC.ActionContext memory ctx) internal view returns (AdrContext memory context) {\\n    context = AdrContext({\\n      sender: ctx.sender,\\n      heroToken: ctx.heroToken,\\n      heroTokenId: ctx.heroTokenId,\\n      controller: ctx.controller,\\n      oracle: IOracle(ctx.controller.oracle()),\\n      statController: IStatController(ctx.controller.statController()),\\n      itemController: IItemController(ctx.controller.itemController())\\n    });\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 gen) internal pure returns (IGOC.GeneratedMonster memory result) {\\n    (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) = gen.unpackGeneratedMonster();\\n    result = IGOC.GeneratedMonster({\\n      generated: generated,\\n      amplifier: amplifier,\\n      hp: hp,\\n      turnCounter: turnCounter\\n    });\\n  }\\n\\n  function packGeneratedMonster(IGOC.GeneratedMonster memory gen) internal pure returns (bytes32) {\\n    return PackingLib.packGeneratedMonster(gen.generated, gen.amplifier, gen.hp, gen.turnCounter);\\n  }\\n\\n  function packMonsterInfo(IGOC.MonsterGenInfo memory mInfo, IGOC.MonsterInfo storage info) internal {\\n    info.attributes = mInfo.attributeValues.toBytes32ArrayWithIds(mInfo.attributeIds);\\n    info.stats = PackingLib.packMonsterStats(mInfo.level, mInfo.race, mInfo.experience, mInfo.maxDropItems);\\n    info.attackInfo = PackingLib.packAttackInfo(mInfo.attackToken, mInfo.attackTokenId, mInfo.attackType);\\n\\n    uint len = mInfo.mintItems.length;\\n    bytes32[] memory mintItems = new bytes32[](len);\\n\\n    for (uint i; i < len; ++i) {\\n      mintItems[i] = mInfo.mintItems[i].packItemMintInfo(mInfo.mintItemsChances[i]);\\n    }\\n\\n    info.mintItems = mintItems;\\n  }\\n\\n  /// @return Attention: Following fields are not initialized: biome, subType, monsterId\\n  function unpackMonsterInfo(IGOC.MonsterInfo storage mInfo) internal view returns (IGOC.MonsterGenInfo memory) {\\n    IGOC.MonsterGenInfo memory result;\\n    (result.attributeValues, result.attributeIds) = mInfo.attributes.toInt32ArrayWithIds();\\n    (result.level, result.race, result.experience, result.maxDropItems) = mInfo.stats.unpackMonsterStats();\\n    (result.attackToken, result.attackTokenId, result.attackType) = mInfo.attackInfo.unpackAttackInfo();\\n\\n    uint len = mInfo.mintItems.length;\\n    result.mintItems = new address[](len);\\n    result.mintItemsChances = new uint32[](len);\\n\\n    for (uint i = 0; i < len; i++) {\\n      (result.mintItems[i], result.mintItemsChances[i]) = mInfo.mintItems[i].unpackItemMintInfo();\\n    }\\n\\n    // Attention: result.biome, result.subType, result.monsterId are not initialized\\n    return result;\\n  }\\n\\n  /// @notice Decode attack info. Ensure that attack token belongs to the hero.\\n  /// Ensure that skill tokens belong to the hero OR to the current helper (SIP-001)\\n  function decodeAndCheckAttackInfo(\\n    IItemController ic,\\n    IHeroController heroController,\\n    bytes memory data,\\n    address heroToken,\\n    uint heroId\\n  ) internal view returns (IFightCalculator.AttackInfo memory) {\\n    (IFightCalculator.AttackInfo memory attackInfo) = abi.decode(data, (IFightCalculator.AttackInfo));\\n\\n    if (uint(attackInfo.attackType) == 0) revert IAppErrors.UnknownAttackType(uint(attackInfo.attackType));\\n\\n    if (attackInfo.attackToken != address(0)) {\\n      (address h, uint hId) = ic.equippedOn(attackInfo.attackToken, attackInfo.attackTokenId);\\n      if (heroToken != h || hId != heroId) revert IAppErrors.NotYourAttackItem();\\n    }\\n\\n    (address helperHeroToken, uint helperHeroId) = heroController.heroReinforcementHelp(heroToken, heroId);\\n    for (uint i; i < attackInfo.skillTokens.length; ++i) {\\n      (address h, uint hId) = ic.equippedOn(attackInfo.skillTokens[i], attackInfo.skillTokenIds[i]);\\n      if (\\n        (heroToken != h || hId != heroId)\\n        && ((helperHeroToken == address(0)) || (helperHeroToken != h || helperHeroId != hId))\\n      ) revert IAppErrors.NotYourBuffItem();\\n    }\\n\\n    return attackInfo;\\n  }\\n\\n  /// @dev Monsters power is increased on 100% with each increment of hero NG_LEVEL\\n  function monsterMultiplier(uint8 heroNgLevel) internal pure returns (uint) {\\n    return _MONSTER_MULTIPLIER_NGP_BASE * uint(heroNgLevel);\\n  }\\n\\n  function amplifyMonsterAttribute(int32 value, uint32 amplifier, uint dungeonMultiplier) internal pure returns (int32) {\\n    if (value == 0) {\\n      return 0;\\n    }\\n\\n    int destValue = int(value)\\n      + (int(value) * int(uint(amplifier)) / int(uint(_MAX_AMPLIFIER)))\\n      + (int(value) * int(dungeonMultiplier) / int(uint(_MAX_AMPLIFIER)));\\n    if (destValue > type(int32).max || destValue < type(int32).min) revert IAppErrors.IntValueOutOfRange(destValue);\\n\\n    return int32(destValue);\\n  }\\n\\n  /// @dev A wrapper around {CalcLib.pseudoRandom} to pass it as param (to be able to implement unit tests}\\n  function _pseudoRandom(uint max) internal view returns (uint) {\\n    return CalcLib.pseudoRandom(max);\\n  }\\n\\n  /// @notice Amplify values of the attributes and of the experience\\n  ///         using randomly generated {amplifier} and {dungeonMultiplier}.\\n  ///         Attributes = amplify(ids, values), experience = amplify(baseExperience)\\n  function generateMonsterAttributes(\\n    uint8[] memory ids,\\n    int32[] memory values,\\n    uint32 amplifier,\\n    uint dungeonMultiplier,\\n    uint32 baseExperience\\n  ) internal pure returns (\\n    int32[] memory attributes,\\n    uint32 experience\\n  ) {\\n    // reduce random\\n    amplifier = amplifier / 4;\\n\\n    attributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < ids.length; ++i) {\\n      attributes[ids[i]] = amplifyMonsterAttribute(values[i], amplifier, dungeonMultiplier);\\n    }\\n    experience = uint32(amplifyMonsterAttribute(int32(baseExperience), amplifier, 0));\\n  }\\n\\n  function _calcDmg(int32 heroLifeBefore, int32 heroLifeAfter) internal pure returns (int32 damage) {\\n    return heroLifeAfter == 0\\n      ? heroLifeBefore\\n      : heroLifeBefore - CalcLib.minI32(heroLifeAfter, heroLifeBefore);\\n  }\\n\\n  function _getMonsterCounterIndex(uint32 objectId) internal pure returns (bytes32) {\\n    return bytes32(abi.encodePacked(\\\"MONSTER_\\\", StringLib._toString(uint(objectId))));\\n  }\\n  //endregion ------------------------ Utils\\n\\n\\n}\\n\",\"keccak256\":\"0xe16b830d84989b1577c42a9b1589de42f9639292ac5f99f1434aca13d375918a\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PackingLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\n\\nlibrary PackingLib {\\n\\n  //////////////////////////\\n  // ---- PACKING LOGIC ----\\n  //////////////////////////\\n\\n  //region ------------------------------------ COMMON\\n\\n  function packNftId(address token, uint id) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert IAppErrors.TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n  }\\n\\n  function unpackNftId(bytes32 data) internal pure returns (address token, uint id) {\\n    token = address(uint160(uint(data)));\\n    id = uint(data) >> 160;\\n  }\\n\\n  function packAddressWithAmount(address token, uint amount) internal pure returns (bytes32 data) {\\n    if (amount > uint(type(uint96).max)) revert IAppErrors.TooHighValue(amount);\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(uint96(amount))) << 160;\\n  }\\n\\n  function unpackAddressWithAmount(bytes32 data) internal pure returns (address token, uint amount) {\\n    token = address(uint160(uint(data)));\\n    amount = uint(data) >> 160;\\n  }\\n\\n  function packItemMintInfo(address item, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(chance)) << 160;\\n  }\\n\\n  function unpackItemMintInfo(bytes32 data) internal pure returns (address item, uint32 chance) {\\n    item = address(uint160(uint(data)));\\n    chance = uint32(uint(data) >> 160);\\n  }\\n\\n  /// @param customDataIndex We assume, that two lowest bytes of this string are always zero\\n  /// So, the string looks like following: 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// Last 2 bytes will be used to encode {value}\\n  function packCustomDataChange(bytes32 customDataIndex, int16 value) internal pure returns (bytes32 data) {\\n    if (uint(customDataIndex) != (uint(customDataIndex) >> 16) << 16) revert IAppErrors.IncompatibleInputString();\\n    data = bytes32(uint(customDataIndex));\\n    data |= bytes32(uint(uint16(value)));\\n  }\\n\\n  function unpackCustomDataChange(bytes32 data) internal pure returns (bytes32 customDataIndex, int16 value) {\\n    customDataIndex = bytes32((uint(data) >> 16) << 16);\\n    value = int16(int(uint(uint16(uint(data)))));\\n  }\\n\\n  /// @dev min(uint64) + max(uint64) + isHeroData/isMandatory(uint8)\\n  function packCustomDataRequirements(uint64 min, uint64 max, bool key) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(min));\\n    data |= bytes32(uint(max)) << 64;\\n    data |= bytes32(uint(key ? uint8(1) : uint8(0))) << (64 + 64);\\n  }\\n\\n  function unpackCustomDataRequirements(bytes32 data) internal pure returns (uint64 min, uint64 max, bool key) {\\n    min = uint64(uint(data));\\n    max = uint64(uint(data) >> 64);\\n    key = uint8(uint(data) >> (64 + 64)) == uint8(1);\\n  }\\n\\n  function packStatsChange(\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(experience));\\n    data |= bytes32(uint(uint32(heal))) << 32;\\n    data |= bytes32(uint(uint32(manaRegen))) << (32 + 32);\\n    data |= bytes32(uint(uint32(lifeChancesRecovered))) << (32 + 32 + 32);\\n    data |= bytes32(uint(uint32(damage))) << (32 + 32 + 32 + 32);\\n    data |= bytes32(uint(uint32(manaConsumed))) << (32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackStatsChange(bytes32 data) internal pure returns (\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) {\\n    experience = uint32(uint(data));\\n    heal = int32(int(uint(data) >> 32));\\n    manaRegen = int32(int(uint(data) >> (32 + 32)));\\n    lifeChancesRecovered = int32(int(uint(data) >> (32 + 32 + 32)));\\n    damage = int32(int(uint(data) >> (32 + 32 + 32 + 32)));\\n    manaConsumed = int32(int(uint(data) >> (32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packNftIdWithValue(address token, uint id, uint32 value) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert IAppErrors.TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n    serialized |= bytes32(uint(value)) << 160 + 64;\\n  }\\n\\n  function unpackNftIdWithValue(bytes32 data) internal pure returns (address token, uint id, uint32 value) {\\n    token = address(uint160(uint(data)));\\n    id = uint64(uint(data) >> 160);\\n    value = uint32(uint(data) >> 160 + 64);\\n  }\\n  //endregion ------------------------------------ COMMON\\n\\n  //region ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(bytes20(objectAddress));\\n    packedData |= bytes32(uint(objectId) << 32);\\n    packedData |= bytes32(uint(objectType) << 24);\\n  }\\n\\n  function unpackMapObject(bytes32 packedData) internal pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\\n    objectAddress = address(bytes20(packedData));\\n    objectId = uint64(uint(packedData) >> 32);\\n    objectType = uint8(uint(packedData) >> 24);\\n  }\\n\\n  function packCoordinate(uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(x));\\n    packedData |= bytes32(uint(y) << 128);\\n  }\\n\\n  function unpackCoordinate(bytes32 packedData) internal pure returns (uint128 x, uint128 y) {\\n    x = uint128(uint(packedData));\\n    y = uint128(uint(packedData) >> 128);\\n  }\\n\\n  /// @param x Assume x <= max uint64\\n  /// @param y Assume y <= max uint64\\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    // 256 => 128 + 128;\\n    // 1) 128 is used for biomeMapFieldId, territoryNumber and probably other fields in the future\\n    // 2) 128 is used to store x, y as uint64, uint64\\n\\n    // we will use uint64 for coordinates assuming it is more than enough for biome map\\n    packedData = bytes32(uint(biomeMapFieldId));\\n    packedData |= bytes32(uint(territoryNumber) << (8));\\n    packedData |= bytes32(uint(uint64(x)) << 128);\\n    packedData |= bytes32(uint(uint64(y)) << (64 + 128));\\n  }\\n\\n  function unpackBattlefieldId(bytes32 packedData) internal pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\\n    biomeMapFieldId = uint8(uint(packedData));\\n    territoryNumber = uint8(uint(packedData) >> (8));\\n    x = uint128(uint64(uint(packedData) >> (128)));\\n    y = uint128(uint64(uint(packedData) >> (64 + 128)));\\n  }\\n  //endregion ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  //region ------------------------------------ REINFORCEMENT\\n\\n  function packReinforcementHeroInfo(uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(biome));\\n    packedData |= bytes32(uint(score) << 8);\\n    packedData |= bytes32(uint(fee) << (8 + 128));\\n    packedData |= bytes32(uint(stakeTs) << (8 + 128 + 8));\\n  }\\n\\n  function unpackReinforcementHeroInfo(bytes32 packedData) internal pure returns (uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) {\\n    biome = uint8(uint(packedData));\\n    score = uint128(uint(packedData) >> 8);\\n    fee = uint8(uint(packedData) >> (8 + 128));\\n    stakeTs = uint64(uint(packedData) >> (8 + 128 + 8));\\n  }\\n\\n  function packConfigReinforcementV2(uint32 min, uint32 max, uint32 lowDivider, uint32 highDivider, uint8 levelLimit) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(min));\\n    packedData |= bytes32(uint(max) << 32);\\n    packedData |= bytes32(uint(lowDivider) << 64);\\n    packedData |= bytes32(uint(highDivider) << 96);\\n    packedData |= bytes32(uint(levelLimit) << 128);\\n  }\\n\\n  function unpackConfigReinforcementV2(bytes32 packedData) internal pure returns (uint32 min, uint32 max, uint32 lowDivider, uint32 highDivider, uint8 levelLimit) {\\n    min = uint32(uint(packedData));\\n    max = uint32(uint(packedData) >> 32);\\n    lowDivider = uint32(uint(packedData) >> 64);\\n    highDivider = uint32(uint(packedData) >> 96);\\n    levelLimit = uint8(uint(packedData) >> 128);\\n  }\\n  //endregion ------------------------------------ REINFORCEMENT\\n\\n  //region ------------------------------------ DUNGEON\\n\\n  function packDungeonKey(address heroAdr, uint80 heroId, uint16 dungLogicNum) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(dungLogicNum)) << (160 + 80);\\n  }\\n\\n  function unpackDungeonKey(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 dungLogicNum) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    dungLogicNum = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  // --- GAME OBJECTS ---\\n\\n  function packIterationKey(address heroAdr, uint64 heroId, uint32 objId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(objId)) << (160 + 64);\\n  }\\n\\n  function unpackIterationKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint32 objId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    objId = uint32(uint(data) >> (160 + 64));\\n  }\\n\\n  function packMonsterStats(\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(level));\\n    data |= bytes32(uint(race)) << 8;\\n    data |= bytes32(uint(experience)) << (8 + 8);\\n    data |= bytes32(uint(maxDropItems)) << (8 + 8 + 32);\\n  }\\n\\n  function unpackMonsterStats(bytes32 data) internal pure returns (\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) {\\n    level = uint8(uint(data));\\n    race = uint8(uint(data) >> 8);\\n    experience = uint32(uint(data) >> (8 + 8));\\n    maxDropItems = uint8(uint(data) >> (8 + 8 + 32));\\n  }\\n\\n  function packAttackInfo(\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(attackToken)));\\n    data |= bytes32(uint(attackTokenId)) << 160;\\n    data |= bytes32(uint(attackType)) << (160 + 64);\\n  }\\n\\n  function unpackAttackInfo(bytes32 data) internal pure returns (\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) {\\n    attackToken = address(uint160(uint(data)));\\n    attackTokenId = uint64(uint(data) >> 160);\\n    attackType = uint8(uint(data) >> (160 + 64));\\n  }\\n\\n  function packPlayedObjKey(address heroAdr, uint64 heroId, uint8 oType, uint8 biome) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(oType)) << (160 + 64);\\n    data |= bytes32(uint(biome)) << (160 + 64 + 8);\\n  }\\n\\n  function unpackPlayedObjKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint8 oType, uint8 biome) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    oType = uint8(uint(data) >> (160 + 64));\\n    biome = uint8(uint(data) >> (160 + 64 + 8));\\n  }\\n\\n  function packGeneratedMonster(bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint8(generated ? 1 : 0)));\\n    data |= bytes32(uint(amplifier)) << 8;\\n    data |= bytes32(uint(uint32(hp))) << (8 + 32);\\n    data |= bytes32(uint(turnCounter)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 data) internal pure returns (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) {\\n    generated = uint8(uint(data)) == uint8(1);\\n    amplifier = uint32(uint(data) >> 8);\\n    hp = int32(int(uint(data) >> (8 + 32)));\\n    turnCounter = uint8(uint(data) >> (8 + 32 + 32));\\n  }\\n  //endregion ------------------------------------ DUNGEON\\n\\n  //region ------------------------------------ ITEMS\\n\\n  /// @notice itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n  /// @param itemType This is ItemType enum\\n  function packItemMeta(\\n    uint8 itemMetaType,\\n    uint8 itemLvl,\\n    uint8 itemType,\\n    uint16 baseDurability,\\n    uint8 defaultRarity,\\n    uint8 minAttr,\\n    uint8 maxAttr,\\n    uint32 manaCost,\\n    IStatController.CoreAttributes memory req\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(itemMetaType));\\n    data |= bytes32(uint(itemLvl)) << 8;\\n    data |= bytes32(uint(itemType)) << (8 + 8);\\n    data |= bytes32(uint(baseDurability)) << (8 + 8 + 8);\\n    data |= bytes32(uint(defaultRarity)) << (8 + 8 + 8 + 16);\\n    data |= bytes32(uint(minAttr)) << (8 + 8 + 8 + 16 + 8);\\n    data |= bytes32(uint(maxAttr)) << (8 + 8 + 8 + 16 + 8 + 8);\\n    data |= bytes32(uint(manaCost)) << (8 + 8 + 8 + 16 + 8 + 8 + 8);\\n    data |= bytes32(uint(int(req.strength))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32);\\n    data |= bytes32(uint(int(req.dexterity))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32);\\n    data |= bytes32(uint(int(req.vitality))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(req.energy))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemMeta(bytes32 data) internal pure returns (IItemController.ItemMeta memory) {\\n    IItemController.ItemMeta memory result;\\n\\n    result.itemMetaType = uint8(uint(data));\\n    result.itemLevel = uint8(uint(data) >> 8);\\n    result.itemType = IItemController.ItemType(uint8(uint(data) >> (8 + 8)));\\n    result.baseDurability = uint16(uint(data) >> (8 + 8 + 8));\\n    result.defaultRarity = uint8(uint(data) >> (8 + 8 + 8 + 16));\\n    result.minRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8));\\n    result.maxRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8));\\n    result.manaCost = uint32(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8));\\n    result.requirements.strength = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32)));\\n    result.requirements.dexterity = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32)));\\n    result.requirements.vitality = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32)));\\n    result.requirements.energy = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32)));\\n\\n    return result;\\n  }\\n\\n  function packItemGenerateInfo(uint8 id, int32 min, int32 max, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(id));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(chance)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32 data) internal pure returns (uint8 id, int32 min, int32 max, uint32 chance) {\\n    id = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    chance = uint32(uint(data) >> (8 + 32 + 32));\\n  }\\n\\n  function packItemAttackInfo(\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attackType));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(int(factorStr))) << (8 + 32 + 32);\\n    data |= bytes32(uint(int(factorDex))) << (8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorVit))) << (8 + 32 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorEng))) << (8 + 32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 data) internal pure returns (\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) {\\n    attackType = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    factorStr = int32(int(uint(data) >> (8 + 32 + 32)));\\n    factorDex = int32(int(uint(data) >> (8 + 32 + 32 + 32)));\\n    factorVit = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32)));\\n    factorEng = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packItemInfo(uint8 rarity, uint8 augmentationLevel, uint16 durability) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(rarity));\\n    data |= bytes32(uint(augmentationLevel)) << 8;\\n    data |= bytes32(uint(durability)) << (8 + 8);\\n  }\\n\\n  function unpackItemInfo(bytes32 data) internal pure returns (uint8 rarity, uint8 augmentationLevel, uint16 durability) {\\n    rarity = uint8(uint(data));\\n    augmentationLevel = uint8(uint(data) >> 8);\\n    durability = uint16(uint(data) >> (8 + 8));\\n  }\\n\\n  function packItemBoxItemInfo(bool withdrawn, uint64 timestamp) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint8(withdrawn ? 1 : 0)));\\n    data |= bytes32(uint(timestamp)) << 8;\\n  }\\n\\n  function unpackItemBoxItemInfo(bytes32 data) internal pure returns (bool withdrawn, uint64 timestamp) {\\n    withdrawn = uint8(uint(data)) != 0;\\n    timestamp = uint64(uint(data) >> 8);\\n  }\\n  //endregion ------------------------------------ ITEMS\\n\\n  //region ------------------------------------ STORIES\\n\\n  function packStoryPageId(uint16 storyId, uint16 pageId, uint8 heroClass) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n  }\\n\\n  function unpackStoryPageId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n  }\\n\\n  function packStoryAnswerId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n  }\\n\\n  function unpackStoryAnswerId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n  }\\n\\n  function packStoryNextPagesId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(resultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryNextPagesId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    resultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryAttributeRequirement(uint8 attributeIndex, int32 value, bool isCore) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attributeIndex));\\n    data |= bytes32(uint(uint32(value))) << 8;\\n    data |= bytes32(uint(isCore ? uint8(1) : uint8(0))) << (8 + 32);\\n  }\\n\\n  function unpackStoryAttributeRequirement(bytes32 data) internal pure returns (uint8 attributeIndex, int32 value, bool isCore) {\\n    attributeIndex = uint8(uint(data));\\n    value = int32(int(uint(data) >> 8));\\n    isCore = uint8(uint(data) >> (8 + 32)) == uint8(1);\\n  }\\n\\n  function packStoryItemRequirement(address item, bool requireItemBurn, bool requireItemEquipped) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(requireItemBurn ? uint8(1) : uint8(0))) << 160;\\n    data |= bytes32(uint(requireItemEquipped ? uint8(1) : uint8(0))) << (160 + 8);\\n  }\\n\\n  function unpackStoryItemRequirement(bytes32 data) internal pure returns (address item, bool requireItemBurn, bool requireItemEquipped) {\\n    item = address(uint160(uint(data)));\\n    requireItemBurn = uint8(uint(data) >> 160) == uint8(1);\\n    requireItemEquipped = uint8(uint(data) >> (160 + 8)) == uint8(1);\\n  }\\n\\n  /// @dev max amount is 309,485,009 for token with 18 decimals\\n  function packStoryTokenRequirement(address token, uint88 amount, bool requireTransfer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(amount)) << 160;\\n    data |= bytes32(uint(requireTransfer ? uint8(1) : uint8(0))) << (160 + 88);\\n  }\\n\\n  function unpackStoryTokenRequirement(bytes32 data) internal pure returns (address token, uint88 amount, bool requireTransfer) {\\n    token = address(uint160(uint(data)));\\n    amount = uint88(uint(data) >> 160);\\n    requireTransfer = uint8(uint(data) >> (160 + 88)) == uint8(1);\\n  }\\n\\n  function packStoryCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(customDataResultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryCustomDataResult(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    customDataResultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryHeroState(uint16 pageId, uint40 heroLastActionTS) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(pageId));\\n    data |= bytes32(uint(heroLastActionTS)) << 16;\\n  }\\n\\n  function unpackStoryHeroState(bytes32 data) internal pure returns (uint16 pageId, uint40 heroLastActionTS) {\\n    pageId = uint16(uint(data));\\n    heroLastActionTS = uint40(uint(data) >> 16);\\n  }\\n\\n  function packStoryHeroStateId(address heroAdr, uint80 heroId, uint16 storyId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(storyId)) << (160 + 80);\\n  }\\n\\n  function unpackStoryHeroStateId(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 storyId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    storyId = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  function packStorySimpleRequirement(uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(randomRequirement));\\n    data |= bytes32(uint(delayRequirement)) << 32;\\n    data |= bytes32(uint(isFinalAnswer ? uint8(1) : uint8(0))) << (32 + 32);\\n  }\\n\\n  function unpackStorySimpleRequirement(bytes32 data) internal pure returns (uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) {\\n    randomRequirement = uint32(uint(data));\\n    delayRequirement = uint32(uint(data) >> 32);\\n    isFinalAnswer = uint8(uint(data) >> (32 + 32)) == uint8(1);\\n  }\\n\\n  function packBreakInfo(uint8 slot, uint64 chance, bool stopIfBroken) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(slot));\\n    data |= bytes32(uint(chance)) << 8;\\n    data |= bytes32(uint(stopIfBroken ? uint8(1) : uint8(0))) << (8 + 64);\\n  }\\n\\n  function unpackBreakInfo(bytes32 data) internal pure returns (uint8 slot, uint64 chance, bool stopIfBurned) {\\n    slot = uint8(uint(data));\\n    chance = uint64(uint(data) >> 8);\\n    stopIfBurned = uint8(uint(data) >> (8 + 64)) == uint8(1);\\n  }\\n  //endregion ------------------------------------ STORIES\\n\\n  //region ------------------------------------ Hero controller\\n  function packTierHero(uint8 tier, address hero) internal pure returns (bytes32 packedTierHero) {\\n    packedTierHero = bytes32(uint(tier));\\n    packedTierHero |= bytes32(uint(uint160(hero)) << 8);\\n  }\\n\\n  function unpackTierHero(bytes32 packedTierHero) internal pure returns (uint8 tier, address hero) {\\n    tier = uint8(uint(packedTierHero));\\n    hero = address(uint160(uint(packedTierHero) >> 8));\\n  }\\n\\n  //endregion ------------------------------------ Hero controller\\n\\n  ////////////////////////////////////////////////////////////////////////////////////\\n  // ---- ARRAYS LOGIC ----\\n  ////////////////////////////////////////////////////////////////////////////////////\\n\\n  //region ------------------------------------ SIMPLE ARRAYS\\n\\n\\n  function packUint8Array(uint8[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 32) revert IAppErrors.OutOfBounds(len, 32);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 8);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {packUint8Array} for small number of items\\n  ///         It allows to exclude dynamic array creation.\\n  function packUint8Array3(uint8 a, uint8 b, uint8 c) internal pure returns (bytes32) {\\n    bytes32 result = bytes32(uint(a));\\n    result |= bytes32(uint(b)) << (1 * 8);\\n    result |= bytes32(uint(c)) << (2 * 8);\\n    return result;\\n  }\\n\\n\\n  function unpackUint8Array(bytes32 data) internal pure returns (uint8[] memory) {\\n    uint8[] memory result = new uint8[](32);\\n    for (uint i = 0; i < 32; i++) {\\n      result[i] = uint8(uint(data) >> (i * 8));\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {unpackUint8Array} for small number of items\\n  ///         It allows to exclude only first 3 values\\n  function unpackUint8Array3(bytes32 data) internal pure returns (uint8 a, uint8 b, uint8 c) {\\n    a = uint8(uint(data));\\n    b = uint8(uint(data) >> (1 * 8));\\n    c = uint8(uint(data) >> (2 * 8));\\n  }\\n\\n  function changeUnit8ArrayWithCheck(bytes32 data, uint index, uint8 value, uint8 expectedPrevValue) internal pure returns (bytes32 newData) {\\n    uint8[] memory arr = unpackUint8Array(data);\\n    if (arr[index] != expectedPrevValue) revert IAppErrors.UnexpectedValue(uint(expectedPrevValue), uint(arr[index]));\\n    arr[index] = value;\\n    return packUint8Array(arr);\\n  }\\n\\n  function packInt32Array(int32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert IAppErrors.OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i; i < len; i++) {\\n      result |= bytes32(uint(uint32(data[i]))) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackInt32Array(bytes32 data) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = int32(int(uint(data) >> (i * 32)));\\n    }\\n    return result;\\n  }\\n\\n  function packUint32Array(uint32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert IAppErrors.OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackUint32Array(bytes32 data) internal pure returns (uint32[] memory) {\\n    uint32[] memory result = new uint32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = uint32(uint(data) >> (i * 32));\\n    }\\n    return result;\\n  }\\n  //endregion ------------------------------------ SIMPLE ARRAYS\\n\\n  //region ------------------------------------ COMPLEX ARRAYS\\n\\n  // We should represent arrays without concrete size.\\n  // For this reason we must not revert IAppErrors.on out of bounds but return zero value instead.\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getInt32AsInt24(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n//    if (idx / 8 >= arr.length) {\\n//      return int32(0);\\n//    }\\n//    return int32(int24(int(uint(arr[idx / 8]) >> ((idx % 8) * 32))));\\n//  }\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getUnit8From32Step(bytes32[] memory arr, uint idx) internal pure returns (uint8) {\\n//    if (idx / 8 >= arr.length) {\\n//      return uint8(0);\\n//    }\\n//    return uint8(uint(arr[idx / 8]) >> ((idx % 8) * 32 + 24));\\n//  }\\n\\n  function getInt32Memory(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function getInt32(bytes32[] storage arr, uint idx) internal view returns (int32) {\\n    // additional gas usage, but we should not revert IAppErrors.on out of bounds\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function setInt32(bytes32[] storage arr, uint idx, int32 value) internal {\\n    uint pos = idx / 8;\\n    uint shift = (idx % 8) * 32;\\n\\n    uint curLength = arr.length;\\n    if (pos >= curLength) {\\n      arr.push(0);\\n      for (uint i = curLength; i < pos; ++i) {\\n        arr.push(0);\\n      }\\n    }\\n\\n    arr[pos] = bytes32(uint(arr[pos]) & ~(uint(0xffffffff) << shift) | (uint(uint32(value)) & 0xffffffff) << shift);\\n  }\\n\\n  /// @notice Increment {idx}-th item on {value}\\n  function changeInt32(bytes32[] storage arr, uint idx, int32 value) internal returns (int32 newValue, int32 change) {\\n    int32 cur = int32(int(getInt32(arr, idx)));\\n    int newValueI = int(cur) + int(value);\\n    newValue = int32(newValueI);\\n    change = int32(newValueI - int(cur));\\n\\n    setInt32(arr, idx, newValue);\\n  }\\n\\n  function toInt32Array(bytes32[] memory arr, uint size) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](size);\\n    for (uint i = 0; i < arr.length; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= size) break;\\n        result[idx] = getInt32Memory(arr, idx);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array\\n  function toBytes32Array(int32[] memory arr) internal pure returns (bytes32[] memory) {\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n        result[i] |= bytes32(uint(uint32(arr[idx]))) << (j * 32);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array using last 8bytes for ids\\n  ///      we can not use zero values coz will not able to properly unpack it later\\n  function toBytes32ArrayWithIds(int32[] memory arr, uint8[] memory ids) internal pure returns (bytes32[] memory) {\\n    if (arr.length != ids.length) revert IAppErrors.LengthsMismatch();\\n\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n\\n        if (arr[idx] > type(int24).max || arr[idx] < type(int24).min) revert IAppErrors.IntOutOfRange(int(arr[idx]));\\n        if (arr[idx] == 0) revert IAppErrors.ZeroValue();\\n        result[i] |= bytes32(uint(uint24(int24(arr[idx])))) << (j * 32);\\n        result[i] |= bytes32(uint(ids[idx])) << (j * 32 + 24);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev we do not know exact size of array, assume zero values is not acceptable for this array\\n  function toInt32ArrayWithIds(bytes32[] memory arr) internal pure returns (int32[] memory values, uint8[] memory ids) {\\n    uint len = arr.length;\\n    uint size = len * 8;\\n    int32[] memory valuesTmp = new int32[](size);\\n    uint8[] memory idsTmp = new uint8[](size);\\n    uint counter;\\n    for (uint i = 0; i < len; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        // if (idx >= size) break;  // it looks like a useless check\\n        valuesTmp[idx] = int32(int24(int(uint(arr[i]) >> (j * 32)))); // getInt32AsInt24(arr, idx);\\n        idsTmp[idx] = uint8(uint(arr[i]) >> (j * 32 + 24)); // getUnit8From32Step(arr, idx);\\n        if (valuesTmp[idx] == 0) {\\n          break;\\n        }\\n        counter++;\\n      }\\n    }\\n\\n    values = new int32[](counter);\\n    ids = new uint8[](counter);\\n    for (uint i; i < counter; ++i) {\\n      values[i] = valuesTmp[i];\\n      ids[i] = idsTmp[i];\\n    }\\n  }\\n  //endregion ------------------------------------ COMPLEX ARRAYS\\n\\n  //region ------------------------------------ Guilds\\n  /// @dev ShelterID is uint. But in the code we assume that this ID can be stored as uint64 (see auctions)\\n  /// @param biome 1, 2, 3...\\n  /// @param shelterLevel 1, 2 or 3.\\n  /// @param shelterIndex 0, 1, 2 ...\\n  function packShelterId(uint8 biome, uint8 shelterLevel, uint8 shelterIndex) internal pure returns (uint) {\\n    return uint(biome) | (uint(shelterLevel) << 8) | (uint(shelterIndex) << 16);\\n  }\\n\\n  function unpackShelterId(uint shelterId) internal pure returns (uint8 biome, uint8 shelterLevel, uint8 shelterIndex) {\\n    return (uint8(shelterId), uint8(shelterId >> 8), uint8(shelterId >> 16));\\n  }\\n  //endregion ------------------------------------ Guilds\\n\\n  //region ------------------------------------ Metadata of IItemController.OtherSubtypeKind\\n\\n  function getOtherItemTypeKind(bytes memory packedData) internal pure returns (IItemController.OtherSubtypeKind) {\\n    bytes32 serialized;\\n    assembly {\\n      serialized := mload(add(packedData, 32))\\n    }\\n    uint8 kind = uint8(uint(serialized));\\n    if (kind == 0 || kind >= uint8(IItemController.OtherSubtypeKind.END_SLOT)) revert IAppErrors.IncorrectOtherItemTypeKind(kind);\\n    return IItemController.OtherSubtypeKind(kind);\\n  }\\n\\n  function packOtherItemReduceFragility(uint value) internal pure returns (bytes memory packedData) {\\n    bytes32 serialized = bytes32(uint(uint8(IItemController.OtherSubtypeKind.REDUCE_FRAGILITY_1)));\\n    serialized |= bytes32(uint(uint248(value))) << 8;\\n    return bytes.concat(serialized);\\n  }\\n\\n  function unpackOtherItemReduceFragility(bytes memory packedData) internal pure returns (uint) {\\n    bytes32 serialized;\\n    assembly {\\n      serialized := mload(add(packedData, 32))\\n    }\\n    uint8 kind = uint8(uint(serialized));\\n    if (kind != uint8(IItemController.OtherSubtypeKind.REDUCE_FRAGILITY_1)) revert IAppErrors.IncorrectOtherItemTypeKind(kind);\\n    uint value = uint248(uint(serialized) >> 8);\\n    return value;\\n  }\\n  //endregion ------------------------------------ Metadata of IItemController.OtherSubtypeKind\\n\\n  //region ------------------------------------ Metadata of IPvpController.PvpAttackInfoDefaultStrategy\\n  function getPvpBehaviourStrategyKind(bytes memory encodedData) internal pure returns (uint) {\\n    bytes32 serialized;\\n    assembly {\\n      serialized := mload(add(encodedData, 64)) // first 32 bytes contain 0x20 and indicate array, we need to read second 32 bytes to get first uint in the struct\\n    }\\n\\n    return uint(serialized);\\n  }\\n  //endregion ------------------------------------ Metadata of IPvpController.PvpAttackInfoDefaultStrategy\\n\\n}\\n\",\"keccak256\":\"0x2c8652b2e7d685dc36cefd6c6bb81f116b72909e103879c1afb2e2e92821f83e\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PvpAttackLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IPvpController.sol\\\";\\nimport \\\"../interfaces/IReinforcementController.sol\\\";\\nimport \\\"../interfaces/IGuildStakingAdapter.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./ControllerContextLib.sol\\\";\\nimport \\\"./ScoreLib.sol\\\";\\nimport \\\"./MonsterLib.sol\\\";\\nimport \\\"./AppLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\nimport \\\"./PvpControllerLib.sol\\\";\\nimport \\\"./ReinforcementControllerLib.sol\\\";\\n\\nlibrary PvpAttackLib {\\n\\n  //region ------------------------ Constants\\n  /// @notice Max total count of turns per pvp-fight\\n  uint internal constant MAX_COUNT_TURNS = 100;\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Data types\\n  struct PvpFightContext {\\n    uint8 turn;\\n    IFightCalculator.AttackInfo heroAttackInfo;\\n    IFightCalculator.AttackInfo opponentAttackInfo;\\n    int32 heroBuffManaConsumed;\\n    int32 opponentBuffManaConsumed;\\n  }\\n\\n  struct PvpFightParams {\\n    /// @notice Max count of fights between the heroes\\n    uint8 maxCountTurns;\\n    /// @notice Count of fights made (max count is limited by 100)\\n    uint8 countTurnsMade;\\n    uint48 fightId;\\n    /// @notice User that starts the fight\\n    address msgSender;\\n    IItemController itemController;\\n    IStatController statController;\\n    IStatController.ChangeableStats heroStats;\\n    IStatController.ChangeableStats opponentStats;\\n  }\\n\\n  //endregion ------------------------ Data types\\n\\n  //endregion ------------------------ Action\\n\\n  /// @notice Start or continue fighting between the hero and his opponent.\\n  /// A series of fights takes place until the health of one heroes drops to zero.\\n  /// If the total number of fights reaches 100 and none of the heroes' health reaches zero,\\n  /// the winner is a hero with the most lives. If the numbers of lives are equal, the winner is selected randomly.\\n  /// @dev Assume here that both hero tokens are not burnt\\n  function pvpFight(\\n    PvpFightParams memory p,\\n    IPvpController.HeroData memory hero,\\n    IPvpController.HeroData memory opponent\\n  ) external returns (\\n    IPvpController.PvpFightResults memory fightResult\\n  ) {\\n    return _pvpFight(p, hero, opponent, CalcLib.pseudoRandom, FightLib.fight);\\n  }\\n\\n  /// @param random_ Pass _pseudoRandom here, param is required to simplify unit testing\\n  /// @param fight_ Pass FightLib.fight here, param is required to simplify unit testing\\n  function _pvpFight(\\n    PvpFightParams memory p,\\n    IPvpController.HeroData memory hero,\\n    IPvpController.HeroData memory opponent,\\n    function (uint) internal view returns (uint) random_,\\n    function(\\n      IItemController,\\n      IFightCalculator.FightCall memory,\\n      IFightCalculator.FightCallAdd memory,\\n      function (uint) internal view returns (uint)\\n    ) internal returns (IFightCalculator.FightResult memory) fight_\\n  ) internal returns (\\n    IPvpController.PvpFightResults memory fightResult\\n  ) {\\n    PvpFightContext memory v;\\n\\n    // check attackInfo and remove all unusable tokens from there\\n    // these attackInfo will be used as a base to generate attackInfo on each turn\\n    v.heroAttackInfo = _prepareAttackInfo(p.itemController, hero);\\n    v.opponentAttackInfo = _prepareAttackInfo(p.itemController, opponent);\\n\\n    // fight until one of the heroes dies OR max count of turns is reached\\n    fightResult = IPvpController.PvpFightResults({\\n      completed: p.heroStats.life == 0 || p.opponentStats.life == 0,\\n      totalCountFights: p.countTurnsMade,\\n      healthHero: p.heroStats.life,\\n      healthOpponent: p.opponentStats.life,\\n      manaConsumedHero: 0,\\n      manaConsumedOpponent: 0\\n    });\\n\\n    if (!fightResult.completed) {\\n      for (uint8 i; i < p.maxCountTurns; ++i) {\\n        IFightCalculator.FighterInfo memory heroFightInfo;\\n        (heroFightInfo, v.heroBuffManaConsumed) = _generateHeroFightInfo(\\n          p.statController,\\n          p.itemController,\\n          p.heroStats,\\n          v.heroAttackInfo,\\n          hero,\\n          fightResult.healthHero,\\n          fightResult.manaConsumedHero\\n        );\\n        IFightCalculator.FighterInfo memory opponentFightInfo;\\n        (opponentFightInfo, v.opponentBuffManaConsumed) = _generateHeroFightInfo(\\n          p.statController,\\n          p.itemController,\\n          p.opponentStats,\\n          v.opponentAttackInfo,\\n          opponent,\\n          fightResult.healthOpponent,\\n          fightResult.manaConsumedOpponent\\n        );\\n        MonsterLib._debuff(opponentFightInfo.fighterAttributes, v.heroAttackInfo, p.itemController);\\n        MonsterLib._debuff(heroFightInfo.fighterAttributes, v.opponentAttackInfo, p.itemController);\\n\\n        // take into account all mana consumed by buff\\n        fightResult.manaConsumedHero = _subMana(fightResult.manaConsumedHero, -v.heroBuffManaConsumed);\\n        fightResult.manaConsumedOpponent = _subMana(fightResult.manaConsumedOpponent, -v.opponentBuffManaConsumed);\\n\\n        v.turn = fightResult.totalCountFights; // abs index of the fight, it's important for UI\\n        IFightCalculator.FightResult memory result = fight_(\\n          p.itemController,\\n          IFightCalculator.FightCall({\\n            fighterA: heroFightInfo,\\n            fighterB: opponentFightInfo,\\n            dungeonId: 0,\\n            objectId: 0,\\n            heroAdr: hero.hero,\\n            heroId: hero.heroId,\\n            stageId: 0,\\n            iteration: 0,\\n            turn: v.turn\\n          }),\\n          IFightCalculator.FightCallAdd({\\n            msgSender: p.msgSender,\\n            fightId: p.fightId\\n          }),\\n          random_\\n        );\\n        // assume that fight_ emits PvpFightResultProcessed with all detailed info for the current turn of the fight\\n        // so there is no other event here\\n\\n        fightResult.healthHero = uint32(result.healthA);\\n        fightResult.healthOpponent = uint32(result.healthB);\\n        fightResult.manaConsumedHero += uint32(result.manaConsumedA);\\n        fightResult.manaConsumedOpponent += uint32(result.manaConsumedB);\\n        fightResult.totalCountFights++;\\n\\n        if (fightResult.healthHero == 0 || fightResult.healthOpponent == 0 || fightResult.totalCountFights >= MAX_COUNT_TURNS) {\\n          fightResult.completed = true;\\n          break;\\n        }\\n      }\\n    }\\n\\n    return fightResult;\\n  }\\n\\n  //endregion ------------------------ Action\\n\\n  //region ------------------------ Internal logic - prepare attack info\\n  /// @notice Check {hero.attackInfo} passed by the hero's user and exclude any not-valid tokens\\n  /// Selection of magic attack/skill on this stage means that they SHOULD BE used but ONLY IF it's possible.\\n  function _prepareAttackInfo(IItemController ic, IPvpController.HeroData memory hero) internal view returns (\\n    IFightCalculator.AttackInfo memory dest\\n  ) {\\n    // assume here that hero hero.pvpStrategy has kind DEFAULT_STRATEGY_0 (we check it on staking)\\n    IPvpController.PvpStrategyDefault memory decoded = abi.decode(hero.pvpStrategy, (IPvpController.PvpStrategyDefault));\\n\\n    dest.attackType = IFightCalculator.AttackType.MELEE;\\n    if (decoded.attackInfo.attackType == IFightCalculator.AttackType.MAGIC) {\\n      if (decoded.attackInfo.attackToken != address(0)) {\\n        (address h, uint hId) = ic.equippedOn(decoded.attackInfo.attackToken, decoded.attackInfo.attackTokenId);\\n        if (hero.hero == h && hId == hero.heroId) {\\n          dest.attackType = IFightCalculator.AttackType.MAGIC;\\n          dest.attackToken = decoded.attackInfo.attackToken;\\n          dest.attackTokenId = decoded.attackInfo.attackTokenId;\\n        }\\n      }\\n    }\\n    // keep only actually equipped skills\\n    uint len = decoded.attackInfo.skillTokens.length;\\n    if (len != 0) {\\n      uint countValidTokens = 0;\\n      uint[] memory indicesValidTokens = new uint[](len);\\n      for (uint i; i < len; ++i) {\\n        (address h, uint hId) = ic.equippedOn(decoded.attackInfo.skillTokens[i], decoded.attackInfo.skillTokenIds[i]);\\n        if (hero.hero == h && hId == hero.heroId) {\\n          indicesValidTokens[countValidTokens++] = i;\\n        }\\n      }\\n      dest.skillTokenIds = new uint[](countValidTokens);\\n      dest.skillTokens = new address[](countValidTokens);\\n      for (uint i; i < countValidTokens; ++i) {\\n        dest.skillTokens[i] = decoded.attackInfo.skillTokens[indicesValidTokens[i]];\\n        dest.skillTokenIds[i] = decoded.attackInfo.skillTokenIds[indicesValidTokens[i]];\\n      }\\n    }\\n\\n    return dest;\\n  }\\n\\n  function _generateHeroFightInfo(\\n    IStatController statController,\\n    IItemController itemController,\\n    IStatController.ChangeableStats memory heroStats,\\n    IFightCalculator.AttackInfo memory heroAttackInfo,\\n    IPvpController.HeroData memory hero,\\n    uint32 healthHero,\\n    uint32 manaConsumedHero\\n  ) internal view returns (\\n    IFightCalculator.FighterInfo memory,\\n    int32 manaConsumed\\n  ) {\\n    // use all available skills to buff\\n    int32[] memory heroAttributes;\\n    (heroAttributes, manaConsumed) = MonsterLib._buffAndGetHeroAttributes(\\n      heroStats.level,\\n      heroAttackInfo.skillTokens,\\n      heroAttackInfo.skillTokenIds,\\n      statController,\\n      hero.hero,\\n      hero.heroId\\n    );\\n    uint32 newMana = _subMana(heroStats.mana, int32(int(uint(manaConsumedHero))) + manaConsumed);\\n\\n    // generate attack info\\n    IFightCalculator.AttackInfo memory attackInfo;\\n    attackInfo.attackType = IFightCalculator.AttackType.MELEE;\\n    if (newMana != 0) {\\n      if (heroAttackInfo.attackType == IFightCalculator.AttackType.MAGIC) {\\n        uint32 manaCost = itemController.itemMeta(heroAttackInfo.attackToken).manaCost;\\n        if (newMana >= manaCost) {\\n          attackInfo.attackType = IFightCalculator.AttackType.MAGIC;\\n          attackInfo.attackToken = heroAttackInfo.attackToken;\\n          attackInfo.attackTokenId = heroAttackInfo.attackTokenId;\\n          newMana -= manaCost;\\n          manaConsumed += int32(int(uint(manaCost)));\\n        }\\n      }\\n    }\\n\\n    IFightCalculator.FighterInfo memory fi = IFightCalculator.FighterInfo({\\n      fighterAttributes: heroAttributes,\\n\\n    // take into account health and mana already lost in the current fight\\n      fighterStats: IStatController.ChangeableStats({\\n      level: heroStats.level,\\n      lifeChances: heroStats.lifeChances,\\n      experience: heroStats.experience,\\n      mana: newMana,\\n      life: healthHero\\n    }),\\n      attackType: attackInfo.attackType,\\n      attackToken: attackInfo.attackToken,\\n      attackTokenId: attackInfo.attackTokenId,\\n      race: uint(IStatController.Race.HUMAN)\\n    });\\n\\n    return (fi, manaConsumed);\\n  }\\n\\n  function _subMana(uint32 mana, int32 consumedMana) internal pure returns (uint32) {\\n    return consumedMana < 0\\n      ? mana + uint32(-consumedMana)\\n      : AppLib.sub0(mana, uint32(consumedMana));\\n  }\\n  //endregion ------------------------ Internal logic - prepare attack info\\n\\n}\\n\",\"keccak256\":\"0xfd8f68554518f541bbe7dfff0e2b8276caa86d84ebfd76ad8a960c88fd4556f6\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PvpControllerLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IPvpController.sol\\\";\\nimport \\\"../interfaces/IReinforcementController.sol\\\";\\nimport \\\"../interfaces/IGuildStakingAdapter.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./ControllerContextLib.sol\\\";\\nimport \\\"./ScoreLib.sol\\\";\\nimport \\\"./MonsterLib.sol\\\";\\nimport \\\"./AppLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\nimport \\\"./ReinforcementControllerLib.sol\\\";\\n\\nlibrary PvpControllerLib {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\\n  using EnumerableMap for EnumerableMap.UintToUintMap;\\n\\n  //region ------------------------ Constants\\n\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"pvp.controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant PVP_CONTROLLER_STORAGE_LOCATION = 0x6750db0cf5db3c73c8abbeff54ef9c65daabbed6967cb68f37e0698f5fc7bb00;\\n\\n  /// @notice First guild level starting from which the pvp-fights are allowed\\n  uint internal constant MIN_GUILD_LEVEL_REQUIRED_FOR_PVP = 3;\\n\\n  /// @notice Fight-winner is allowed to make more pvp-fights in the same epoch\\n  bool internal constant MULTI_FIGHTS_PER_EPOCH_ALLOWED_FOR_WINNERS = true;\\n\\n  /// @notice Hero can be pvp-staked if his level is greater of equal to the given min level\\n  uint32 internal constant DEFAULT_MIN_HERO_LEVEL = 5;\\n\\n  /// @notice Max number of heroes that any user can pvp-stakes per single epoch\\n  /// @dev uint32 is used to be able to store max value inside UserState, -1 is for unit tests\\n  uint32 internal constant MAX_NUMBER_STAKES_FOR_USER_PER_EPOCH = type(uint32).max - 1;\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Data types\\n  struct AddPvpHeroLocal {\\n    uint8 targetBiome;\\n    uint32 week;\\n    bytes32 packedHero;\\n    IGuildController guildController;\\n    IHeroController heroController;\\n    IStatController statController;\\n    address opponent;\\n    bytes32 opponentPackedHero;\\n    uint opponentGuildId;\\n    uint guildId;\\n    IPvpController.PvpUserState userState;\\n    SetupPvpFightParams eventParams;\\n  }\\n\\n  struct SetupPvpFightParams {\\n    uint32 week;\\n    address hero;\\n    uint heroId;\\n    bytes32 opponentPackedHero;\\n  }\\n\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Storage\\n\\n  function _S() internal pure returns (IPvpController.MainState storage s) {\\n    assembly {\\n      s.slot := PVP_CONTROLLER_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n  //endregion ------------------------ Storage\\n\\n  //region ------------------------ Restrictions\\n  function _onlyNotPaused(IController controller) internal view {\\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\\n  }\\n\\n  function _onlyGuildController(IController controller) internal view {\\n    if (controller.guildController() != msg.sender) revert IAppErrors.ErrorNotGuildController();\\n  }\\n\\n  function _onlyDeployer(IController controller) internal view {\\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n\\n  function _onlyUserWithRegisteredPvpHeroWithoutFights(IPvpController.PvpUserState memory userState) internal pure {\\n    if (userState.biome == 0) revert IAppErrors.PvpHeroNotRegistered();\\n    if (userState.activeFightIndex1 != 0) revert IAppErrors.PvpHeroHasInitializedFight();\\n  }\\n\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ View\\n  function getBiomeOwner(uint8 biome) internal view returns (uint guildId) {\\n    return _S().biomeState[biome].guildBiomeOwnerId;\\n  }\\n\\n  function getStartedEpoch(uint8 biome) internal view returns (uint32 epochWeek) {\\n    return _S().biomeState[biome].startedEpochWeek;\\n  }\\n\\n  function getDominationCounter(uint8 biome) internal view returns (uint16 dominationCounter) {\\n    return _S().biomeState[biome].dominationCounter;\\n  }\\n\\n  /// @notice List of guilds that send domination request for the biome\\n  function getBiomeGuilds(uint8 biome, uint32 epochWeek) internal view returns (uint[] memory guildIds) {\\n    return _S().epochData[epochWeek].biomeGuilds[biome].values();\\n  }\\n\\n  /// @return biome Biome where the guild is going to dominate in the given epoch\\n  function getDominationRequest(uint guildId, uint32 epochWeek) internal view returns (uint8 biome) {\\n    return _S().epochData[epochWeek].targetBiome[guildId];\\n  }\\n\\n  function getGuildPoints(uint8 biome, uint32 epochWeek, uint guildId) internal view returns (uint) {\\n    (bool exist, uint countPoints) = _S().epochData[epochWeek].epochBiomeData[biome].guildPoints.tryGet(guildId);\\n    return exist ? countPoints : 0;\\n  }\\n\\n  function getFreeUsers(uint8 biome, uint32 epochWeek, uint guildId) internal view returns (address[] memory) {\\n    return _S().epochData[epochWeek].epochBiomeData[biome].freeUsers[guildId].values();\\n  }\\n\\n  function getPvpStrategy(uint8 biome, uint32 epochWeek, address hero, uint heroId) internal view returns (bytes memory) {\\n    return _S().epochData[epochWeek].epochBiomeData[biome].pvpStrategy[PackingLib.packNftId(hero, heroId)];\\n  }\\n\\n  function getPvpStrategyKind(uint8 biome, uint32 epochWeek, address hero, uint heroId) internal view returns (uint) {\\n    return PackingLib.getPvpBehaviourStrategyKind(_S().epochData[epochWeek].epochBiomeData[biome].pvpStrategy[PackingLib.packNftId(hero, heroId)]);\\n  }\\n\\n  function getFightDataLength(uint32 epochWeek, address user) internal view returns (uint) {\\n    return _S().epochData[epochWeek].fightData[user].length;\\n  }\\n\\n  function getFightDataByIndex(uint32 epochWeek, address user, uint index0) internal view returns (IPvpController.PvpFightData memory) {\\n    return _S().epochData[epochWeek].fightData[user][index0];\\n  }\\n\\n  function registeredUsers(uint8 biome, uint32 epochWeek, uint guildId) internal view returns (address[] memory) {\\n    return _S().epochData[epochWeek].epochBiomeData[biome].registeredHeroes[guildId].keys();\\n  }\\n\\n  function registeredHero(uint8 biome, uint32 epochWeek, uint guildId, address user) internal view returns (address hero, uint heroId) {\\n    (bool exist, uint packedHero) = _S().epochData[epochWeek].epochBiomeData[biome].registeredHeroes[guildId].tryGet(user);\\n    if (exist) {\\n      (hero, heroId) = PackingLib.unpackNftId(bytes32(packedHero));\\n    }\\n    return (hero, heroId);\\n  }\\n\\n  function ownedBiome(uint guildId) internal view returns (uint8 biome) {\\n    return _S().ownedBiome[guildId];\\n  }\\n\\n  /// @notice Get biome tax\\n  /// @return guildId Owner of the biome\\n  /// @return taxPercent Final tax percent, [0...100_000], decimals 3\\n  function getBiomeTax(uint8 biome) internal view returns (uint guildId, uint taxPercent) {\\n    return _getBiomeTax(_S().biomeState[biome]);\\n  }\\n\\n  /// @notice Check if the user has a pvp-hero registered for pvp-fight in the given epoch\\n  function hasPvpHero(address user, uint guildId, uint32 week) internal view returns (bool) {\\n    IPvpController.EpochData storage epochData = _S().epochData[week];\\n    uint8 biome = epochData.targetBiome[guildId];\\n    return biome == 0\\n      ? false\\n      : epochData.epochBiomeData[biome].registeredHeroes[guildId].contains(user);\\n  }\\n\\n  /// @notice Check if the given hero is staked in pvp controller in the given epoch\\n  function isHeroStaked(address hero, uint heroId, uint32 epochWeek) internal view returns (bool staked) {\\n    IPvpController.EpochData storage epochData = _S().epochData[epochWeek];\\n    return epochData.stakedHeroes.contains(uint(PackingLib.packNftId(hero, heroId)));\\n  }\\n\\n  function getUserState(uint32 week, address user) internal view returns (IPvpController.PvpUserState memory) {\\n    return _S().epochData[week].pvpUserState[user];\\n  }\\n\\n  function getMinHeroLevel() internal view returns (uint) {\\n    return _S().pvpParam[IPvpController.PvpParams.MIN_HERO_LEVEL_1];\\n  }\\n\\n  function getCounterFightId() internal view returns (uint48) {\\n    return uint48(_S().pvpParam[IPvpController.PvpParams.FIGHT_COUNTER_3]);\\n  }\\n\\n  function getGuildStakingAdapter() internal view returns (address) {\\n    return address(uint160(_S().pvpParam[IPvpController.PvpParams.GUILD_STAKING_ADAPTER_2]));\\n  }\\n\\n  //endregion ------------------------ View\\n\\n  //region ------------------------ Deployer actions\\n  function setMinHeroLevel(IController controller, uint level) internal {\\n    _onlyDeployer(controller);\\n\\n    _S().pvpParam[IPvpController.PvpParams.MIN_HERO_LEVEL_1] = level;\\n    emit IApplicationEvents.SetMinHeroLevel(level);\\n  }\\n\\n  function setGuildStakingAdapter(IController controller, address adapter_) internal {\\n    _onlyDeployer(controller);\\n\\n    _S().pvpParam[IPvpController.PvpParams.GUILD_STAKING_ADAPTER_2] = uint(uint160(adapter_));\\n    emit IApplicationEvents.SetGuildStakingAdapter(adapter_);\\n  }\\n  //endregion ------------------------ Deployer actions\\n\\n  //region ------------------------ Domination actions\\n\\n  /// @notice Create new request for domination. New request can be created once per epoch\\n  /// @param biome Biome selected by the guild for domination in the current epoch\\n  /// @param random_ CalcLib.pseudoRandom, required for unit tests\\n  function selectBiomeForDomination(\\n    address msgSender,\\n    IController controller,\\n    uint8 biome,\\n    uint blockTimestamp,\\n    function (uint) internal view returns (uint) random_\\n  ) internal {\\n    _onlyNotPaused(controller);\\n    IGuildController guildController = IGuildController(controller.guildController());\\n\\n    if (biome == 0) revert IAppErrors.ErrorIncorrectBiome(biome);\\n    (uint guildId,) = _checkPermissions(guildController, msgSender, IGuildController.GuildRightBits.DOMINATION_REQUEST_13);\\n\\n    {\\n      (,,, uint8 guildLevel,,) = guildController.getGuildData(guildId);\\n      if (guildLevel < MIN_GUILD_LEVEL_REQUIRED_FOR_PVP) revert IAppErrors.TooLowGuildLevel();\\n    }\\n\\n    uint32 week = getCurrentEpochWeek(blockTimestamp);\\n    IPvpController.EpochData storage epochData = _S().epochData[week];\\n\\n    if (epochData.targetBiome[guildId] != 0) revert IAppErrors.BiomeAlreadySelected();\\n\\n    _updateEpoch(biome, blockTimestamp, random_);\\n\\n    // register new domination request\\n    epochData.targetBiome[guildId] = biome;\\n    epochData.biomeGuilds[biome].add(guildId);\\n\\n    emit IApplicationEvents.AddBiomeRequest(msgSender, biome, guildId, week);\\n  }\\n\\n  /// @notice Register hero for pvp. User is able to register only one hero at any moment.\\n  /// @param random_ CalcLib.pseudoRandom, required for unit tests\\n  function addPvpHero(\\n    address msgSender,\\n    IController controller,\\n    address hero,\\n    uint heroId,\\n    bytes memory pvpStrategyData,\\n    uint8 maxFights,\\n    uint blockTimestamp,\\n    function (uint) internal view returns (uint) random_\\n  ) internal {\\n    _onlyNotPaused(controller);\\n\\n    AddPvpHeroLocal memory v;\\n    v.guildController = IGuildController(controller.guildController());\\n    v.heroController = IHeroController(controller.heroController());\\n    v.statController = IStatController(controller.statController());\\n    v.week = getCurrentEpochWeek(blockTimestamp);\\n\\n    // any guild member can participate in pvp, no permissions are required\\n    (v.guildId, v.targetBiome) = _getTargetDominationBiomeWithCheck(msgSender, v.guildController, v.week, true);\\n\\n    if (IERC721(hero).ownerOf(heroId) != msgSender) revert IAppErrors.ErrorNotOwner(hero, heroId);\\n    if (v.heroController.heroClass(hero) == 0) revert IAppErrors.ErrorHeroIsNotRegistered(hero);\\n    if (IReinforcementController(controller.reinforcementController()).isStaked(hero, heroId)) revert IAppErrors.Staked(hero, heroId);\\n    if (!v.statController.isHeroAlive(hero, heroId)) revert IAppErrors.ErrorHeroIsDead(hero, heroId);\\n    if (v.heroController.sandboxMode(hero, heroId) == uint8(IHeroController.SandboxMode.SANDBOX_MODE_1)) revert IAppErrors.SandboxModeNotAllowed();\\n    if (IDungeonFactory(controller.dungeonFactory()).currentDungeon(hero, heroId) != 0) revert IAppErrors.HeroInDungeon();\\n    if (v.heroController.countHeroTransfers(hero, heroId) > 1) revert IAppErrors.HeroWasTransferredBetweenAccounts();\\n\\n    // assume here that there is no reason to check guild level - it's high enough as soon as targetBiome != 0\\n\\n    {\\n      uint32 heroLevel = v.statController.heroStats(hero, heroId).level;\\n      if (heroLevel < getMinHeroLevel()) revert IAppErrors.ErrorLevelTooLow(heroLevel);\\n    }\\n\\n    _updateEpoch(v.targetBiome, blockTimestamp, random_);\\n\\n    // check current fight status\\n    IPvpController.EpochData storage epochData = _S().epochData[v.week];\\n    v.userState = epochData.pvpUserState[msgSender];\\n\\n    if (v.userState.biome != 0) revert IAppErrors.UserHasRegisteredPvpHeroInBiome(v.userState.biome);\\n    if (v.userState.numHeroesStaked >= MAX_NUMBER_STAKES_FOR_USER_PER_EPOCH) revert IAppErrors.UserNotAllowedForPvpInCurrentEpoch(v.week);\\n\\n    // register new hero\\n    IPvpController.EpochBiomeData storage epochBiomeData = epochData.epochBiomeData[v.targetBiome];\\n    v.packedHero = PackingLib.packNftId(hero, heroId);\\n\\n    { // attackInfo params are NOT validated here, they will be checked just before using\\n      uint pvpStrategyKind = PackingLib.getPvpBehaviourStrategyKind(pvpStrategyData);\\n      if (pvpStrategyKind != uint(IPvpController.PvpBehaviourStrategyKinds.DEFAULT_STRATEGY_0)) revert IAppErrors.UnknownPvpStrategy();\\n      epochBiomeData.pvpStrategy[v.packedHero] = pvpStrategyData;\\n    }\\n\\n    epochBiomeData.registeredHeroes[v.guildId].set(msgSender, uint(v.packedHero));\\n    epochData.stakedHeroes.add(uint(v.packedHero));\\n\\n    // initialize new user state\\n    epochData.pvpUserState[msgSender] = IPvpController.PvpUserState({\\n      biome: v.targetBiome,\\n      guildId: uint64(v.guildId),\\n      activeFightIndex1: 0,  // there is no active fight at this moment\\n      numHeroesStaked: 1 + v.userState.numHeroesStaked,\\n      countFights: 0,\\n      maxFights: maxFights,\\n      fightId: 0  // there is no active fight at this moment\\n    });\\n\\n    // emit PvpHeroAdded before emitting of PreparePvpFight\\n    emit IApplicationEvents.PvpHeroAdded(msgSender, v.guildId, hero, heroId, v.week, v.targetBiome);\\n\\n    // try to find opponent for the newly registered hero and initialize the fight if an opponent is found\\n    (v.opponent, v.opponentPackedHero, v.opponentGuildId) = _findPvpOpponent(v.guildController, v.targetBiome, epochData, v.guildId, random_);\\n    if (v.opponent == address(0)) {\\n      epochBiomeData.freeUsers[v.guildId].add(msgSender);\\n    } else {\\n      v.eventParams = SetupPvpFightParams({\\n        week: v.week,\\n        hero: hero,\\n        heroId: heroId,\\n        opponentPackedHero: v.opponentPackedHero\\n      });\\n      _setupPvpFight(v.targetBiome, epochData, msgSender, v.opponent, v.guildId, v.opponentGuildId, v.eventParams);\\n    }\\n  }\\n\\n  /// @notice Remove pvp-hero registered by the {msgSender}.\\n  /// It's allowed only if pvp-hero has no initialized fight.\\n  function removePvpHero(address msgSender, IController controller, uint blockTimestamp) internal {\\n    _onlyNotPaused(controller);\\n\\n    uint32 week = getCurrentEpochWeek(blockTimestamp);\\n\\n    IPvpController.EpochData storage epochData = _S().epochData[week];\\n    IPvpController.PvpUserState memory userState = epochData.pvpUserState[msgSender];\\n    _onlyUserWithRegisteredPvpHeroWithoutFights(userState);\\n\\n    IPvpController.EpochBiomeData storage epochBiomeData = epochData.epochBiomeData[userState.biome];\\n    _removePvpHero(week, epochData, epochBiomeData, userState, msgSender, true);\\n  }\\n\\n  /// @param manualRemoving True if the hero is remove manually by the user, false - he is removed automatically after the fight\\n  function _removePvpHero(\\n    uint32 week,\\n    IPvpController.EpochData storage epochData,\\n    IPvpController.EpochBiomeData storage epochBiomeData,\\n    IPvpController.PvpUserState memory userState,\\n    address user,\\n    bool manualRemoving\\n  ) internal {\\n    address hero;\\n    uint heroId;\\n    (bool exist, uint packedHeroAsUint) = epochBiomeData.registeredHeroes[userState.guildId].tryGet(user);\\n    if (exist) {\\n      epochBiomeData.registeredHeroes[userState.guildId].remove(user);\\n      epochData.stakedHeroes.remove(packedHeroAsUint);\\n      (hero, heroId) = PackingLib.unpackNftId(bytes32(packedHeroAsUint));\\n    }\\n    epochBiomeData.freeUsers[userState.guildId].remove(user);\\n\\n    epochData.pvpUserState[user] = IPvpController.PvpUserState({\\n      activeFightIndex1: 0,\\n      biome: 0,\\n      guildId: 0,\\n      numHeroesStaked: userState.numHeroesStaked,\\n      countFights: 0,\\n      maxFights: 0,\\n      fightId: 0\\n    });\\n\\n    emit IApplicationEvents.PvpHeroRemoved(user, userState.guildId, week, userState.biome, hero, heroId, manualRemoving);\\n  }\\n\\n\\n  /// @notice Change epoch if the current epoch is completed, update biome owner\\n  /// @param random_ CalcLib.pseudoRandom, required for unit tests\\n  function updateEpoch(\\n    uint8 biome,\\n    uint blockTimestamp,\\n    function (uint) internal view returns (uint) random_\\n  ) internal {\\n    // no restrictions to call\\n\\n    _updateEpoch(biome, blockTimestamp, random_);\\n  }\\n\\n  /// @notice Update epoch if necessary and get biome tax that takes into current biome owner\\n  /// @return guildId Owner of the biome\\n  /// @return taxPercent Tax percent in favor of the biome owner. [0...100_000], decimals 3\\n  function refreshBiomeTax(\\n    uint8 biome,\\n    uint blockTimestamp,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (uint guildId, uint taxPercent) {\\n    // no restrictions to call though this method is intended to be called by DungeonFactory\\n    IPvpController.BiomeData memory biomeData = _updateEpoch(biome, blockTimestamp, random_);\\n    return _getBiomeTax(biomeData);\\n  }\\n\\n  /// @notice Called by GuildController when the guild is deleted\\n  function onGuildDeletion(IController controller, uint guildId) internal {\\n    _onlyGuildController(controller);\\n\\n    IPvpController.EpochData storage epochData = _S().epochData[getCurrentEpochWeek(block.timestamp)];\\n    uint8 targetBiome = epochData.targetBiome[guildId];\\n    if (targetBiome != 0) {\\n      // deleted guild cannot be selected for new fights anymore\\n      epochData.biomeGuilds[targetBiome].remove(guildId);\\n    }\\n\\n    // deleted guild cannot own a biome anymore\\n    uint8 _ownedBiome = _S().ownedBiome[guildId];\\n    if (_ownedBiome != 0) {\\n      delete _S().ownedBiome[guildId];\\n      delete _S().biomeState[_ownedBiome];\\n    }\\n  }\\n  //endregion ------------------------ Domination actions\\n\\n  //region ------------------------ Domination internal\\n\\n  /// @notice Finalize passed epoch, initialize first epoch.\\n  /// Detect a winner for biome if it's not detected yet.\\n  function _updateEpoch(\\n    uint8 biome,\\n    uint blockTimestamp,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (IPvpController.BiomeData memory biomeData) {\\n    biomeData = _S().biomeState[biome];\\n    uint32 week = getCurrentEpochWeek(blockTimestamp);\\n    if (biomeData.startedEpochWeek == 0) {\\n      // initialize first epoch\\n      biomeData.startedEpochWeek = week;\\n      _S().biomeState[biome] = biomeData;\\n      emit IApplicationEvents.FirstPvpEpoch(biome, week);\\n    } else {\\n      if (week != biomeData.startedEpochWeek) {\\n        // started epoch has passed, it's time to sum up the results\\n        uint[] memory guildIds = _S().epochData[biomeData.startedEpochWeek].biomeGuilds[biome].values();\\n\\n        // detect new biome owner\\n        uint guildBiomeOwnerId = _detectBiomeOwner(biome, biomeData.startedEpochWeek, guildIds, random_);\\n\\n        if (guildBiomeOwnerId == 0) {\\n          // new biome owner is not detected .. keep previous one\\n          guildBiomeOwnerId = biomeData.guildBiomeOwnerId;\\n        }\\n\\n        if (guildBiomeOwnerId != biomeData.guildBiomeOwnerId) {\\n          uint8 prevBiome = _S().ownedBiome[guildBiomeOwnerId];\\n\\n          // clear data for prev owner of the biome\\n          if (biomeData.guildBiomeOwnerId != 0) {\\n            delete _S().ownedBiome[biomeData.guildBiomeOwnerId];\\n          }\\n\\n          // clear previously owned biome\\n          if (prevBiome != 0) {\\n            _S().biomeState[prevBiome].guildBiomeOwnerId = 0;\\n            _S().biomeState[prevBiome].dominationCounter = 0;\\n          }\\n\\n        // update ownedBiome\\n          _S().ownedBiome[guildBiomeOwnerId] = biome;\\n        }\\n\\n        // update biome state\\n        biomeData = IPvpController.BiomeData({\\n          guildBiomeOwnerId: uint64(guildBiomeOwnerId),\\n          startedEpochWeek: week,\\n          dominationCounter: guildBiomeOwnerId == biomeData.guildBiomeOwnerId && guildBiomeOwnerId != 0\\n            ? biomeData.dominationCounter + uint16(week - biomeData.startedEpochWeek) // penalty for repeat domination\\n            : 0\\n        });\\n        _S().biomeState[biome] = biomeData;\\n\\n        emit IApplicationEvents.UpdatePvpEpoch(biome, week, guildBiomeOwnerId);\\n      }\\n    }\\n  }\\n\\n  /// @notice Select a winner - the guild with max number of points\\n  /// If several guilds have same number of points, the winner is selected randomly\\n  /// @param random_ CalcLib.pseudoRandom, required for unit tests\\n  /// @return guildBiomeOwnerId New guild biome owner. If new biome owner is not detected, prev biome owner is returned\\n  function _detectBiomeOwner(\\n    uint8 biome,\\n    uint week,\\n    uint[] memory guildIds,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint guildBiomeOwnerId) {\\n\\n    uint len = guildIds.length;\\n    uint[] memory guildPoints = new uint[](len);\\n\\n    uint selectedIndexP1; // 1-based index of the first winner guild in {guildPoints}\\n    uint countWinners; // total count of winners - the guilds with equal max number of points\\n\\n    // find all winners - the guilds with max number of points\\n    IPvpController.EpochBiomeData storage epochBiomeData = _S().epochData[week].epochBiomeData[biome];\\n    for (uint i; i < len; ++i) {\\n      (bool exist, uint countPoints) = epochBiomeData.guildPoints.tryGet(guildIds[i]);\\n      if (exist && countPoints != 0) {\\n        guildPoints[i] = countPoints;\\n        if (selectedIndexP1 == 0 || guildPoints[selectedIndexP1 - 1] < countPoints) {\\n          selectedIndexP1 = i + 1;\\n          countWinners = 1;\\n        } else if (guildPoints[selectedIndexP1 - 1] == countPoints) {\\n          countWinners++;\\n        }\\n      }\\n    }\\n\\n    // select random winner from all potential winners\\n    if (selectedIndexP1 != 0) {\\n      uint indexWinner = countWinners == 1 ? 0 : random_(countWinners - 1);\\n      if (indexWinner == 0) {\\n        guildBiomeOwnerId = guildIds[selectedIndexP1 - 1];\\n      } else {\\n        for (uint i = selectedIndexP1; i < len; ++i) {\\n          if (guildPoints[i] == guildPoints[selectedIndexP1 - 1]) {\\n            if (indexWinner == 1) {\\n              guildBiomeOwnerId = guildIds[i];\\n              break;\\n            } else {\\n              indexWinner--;\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    return guildBiomeOwnerId;\\n  }\\n\\n  /// @notice Try to find pvp-opponent for the hero.\\n  /// @param heroGuildId Guild of the hero\\n  /// @param random_ CalcLib.pseudoRandom, required for unit tests\\n  function _findPvpOpponent(\\n    IGuildController guildController,\\n    uint8 biome,\\n    IPvpController.EpochData storage epochData,\\n    uint heroGuildId,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    address opponentUser,\\n    bytes32 opponentPackedHero,\\n    uint opponentGuildId\\n  ) {\\n    (,,,uint8 guildLevel,,) = guildController.getGuildData(heroGuildId);\\n    if (guildLevel >= MIN_GUILD_LEVEL_REQUIRED_FOR_PVP) {\\n      IPvpController.EpochBiomeData storage epochBiomeData = epochData.epochBiomeData[biome];\\n      opponentGuildId = _selectPvpOpponentGuild(guildController, epochData.biomeGuilds[biome], epochBiomeData, heroGuildId, random_);\\n      if (opponentGuildId != 0) {\\n        (opponentUser, opponentPackedHero) = _selectPvpOpponent(epochBiomeData, opponentGuildId, random_);\\n        if (opponentPackedHero == 0) revert IAppErrors.ZeroAddress();\\n\\n        // Pvp-fight is initialized, but not started\\n        // One of the users should start the fight manually\\n      }\\n    }\\n\\n    return (opponentUser, opponentPackedHero, opponentGuildId);\\n  }\\n\\n  /// @notice Prepare the fight: hero vs opponent.\\n  /// Both the hero and his opponent are prepared to the fight in result, but the fight is not started.\\n  /// @param heroOwner Owner of the selected hero\\n  function _setupPvpFight(\\n    uint8 biome,\\n    IPvpController.EpochData storage epochData,\\n    address heroOwner,\\n    address opponentUser,\\n    uint heroGuildId,\\n    uint opponentGuildId,\\n    SetupPvpFightParams memory eventParams\\n  ) internal {\\n    // Set up the fight between the hero and his opponent\\n    epochData.fightData[heroOwner].push(IPvpController.PvpFightData({\\n      fightOpponent: opponentUser,\\n      fightStatus: IPvpController.PvpFightStatus.PREPARED_1,\\n      health: 0,\\n      countTurns: 0,\\n      mana: 0\\n    }));\\n\\n    epochData.fightData[opponentUser].push(IPvpController.PvpFightData({\\n      fightOpponent: heroOwner,\\n      fightStatus: IPvpController.PvpFightStatus.PREPARED_1,\\n      health: 0,\\n      countTurns: 0,\\n      mana: 0\\n    }));\\n\\n    // update users states\\n    uint48 fightId = _generateFightId();\\n    epochData.pvpUserState[heroOwner].activeFightIndex1 = uint32(epochData.fightData[heroOwner].length);\\n    epochData.pvpUserState[heroOwner].fightId = fightId;\\n\\n    epochData.pvpUserState[opponentUser].activeFightIndex1 = uint32(epochData.fightData[opponentUser].length);\\n    epochData.pvpUserState[opponentUser].fightId = fightId;\\n\\n    // remove free users (assume, that remove doesn't revert if user is not there)\\n    epochData.epochBiomeData[biome].freeUsers[heroGuildId].remove(heroOwner);\\n    epochData.epochBiomeData[biome].freeUsers[opponentGuildId].remove(opponentUser);\\n\\n    (address opponentHero, uint opponentHeroId) = PackingLib.unpackNftId(bytes32(eventParams.opponentPackedHero));\\n    emit IApplicationEvents.PreparePvpFight(\\n      fightId,\\n      eventParams.week,\\n      eventParams.hero, eventParams.heroId, heroGuildId,\\n      opponentHero, opponentHeroId, opponentGuildId\\n    );\\n  }\\n\\n  /// @notice Select random guild suitable to select pvp-opponent.\\n  /// The guild should have at least 1 free hero. The guild should have enough level.\\n  /// Relation between the guilds of the selected opponents should be \\\"war\\\".\\n  /// The opponents should belong to the different guilds.\\n  function _selectPvpOpponentGuild(\\n    IGuildController guildController,\\n    EnumerableSet.UintSet storage biomeGuilds,\\n    IPvpController.EpochBiomeData storage epochBiomeData,\\n    uint heroGuildId,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint resultGuildId) {\\n    // select first guild randomly\\n    // enumerate all guilds one by one (loop) and find first guild with available free hero\\n    uint len = biomeGuilds.length();\\n\\n    // biomeGuilds should have at least two guild: hero's guild and opponent's guild\\n    // if there is only 1 guild it means that this is hero's guild and no opponent is available\\n    if (len > 1) {\\n      uint index0 = random_(len - 1);\\n      uint index = index0;\\n      while (true) {\\n        uint guildId = biomeGuilds.at(index);\\n        (,,,uint8 guildLevel,,) = guildController.getGuildData(guildId);\\n\\n        if (guildLevel >= MIN_GUILD_LEVEL_REQUIRED_FOR_PVP\\n        && epochBiomeData.freeUsers[guildId].length() != 0\\n        && heroGuildId != guildId\\n          && !guildController.isPeacefulRelation(heroGuildId, guildId)\\n        ) {\\n          resultGuildId = guildId;\\n          break;\\n        }\\n\\n        index = index + 1 == len ? 0 : index + 1; // loop\\n        if (index == index0) {\\n          // guild wasn't found\\n          break;\\n        }\\n      }\\n    }\\n\\n    return resultGuildId;\\n  }\\n\\n  /// @notice Select random pvp-opponent in the given {guild}\\n  function _selectPvpOpponent(\\n    IPvpController.EpochBiomeData storage epochBiomeData,\\n    uint guildId,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (address user, bytes32 packedHero) {\\n    EnumerableSet.AddressSet storage freeUsers = epochBiomeData.freeUsers[guildId];\\n    uint len = freeUsers.length();\\n    if (len != 0) {\\n      uint index = len == 1 ? 0 : random_(len - 1);\\n      user = freeUsers.at(index);\\n      packedHero = bytes32(epochBiomeData.registeredHeroes[guildId].get(user));\\n    }\\n\\n    return (user, packedHero);\\n  }\\n\\n  /// @return guildId Guild to which {msgSender} belongs, revert if 0\\n  /// @return targetBiome Domination biome of the guild, revert if 0\\n  function _getTargetDominationBiomeWithCheck(address msgSender, IGuildController guildController, uint32 week, bool revertOnZero) internal view returns (\\n    uint guildId,\\n    uint8 targetBiome\\n  ) {\\n    guildId = guildController.memberOf(msgSender);\\n    if (revertOnZero && guildId == 0) revert IAppErrors.NotGuildMember();\\n\\n    targetBiome = guildId == 0\\n      ? 0\\n      : _S().epochData[week].targetBiome[guildId];\\n    if (revertOnZero && targetBiome == 0) revert IAppErrors.NoDominationRequest();\\n  }\\n\\n  /// @notice Get biome tax that takes into account extra fee ratio provided by GuildStakingAdapter\\n  /// @return guildId Owner of the biome\\n  /// @return taxPercent Final tax percent that takes into account possible penalty. [0...100_000], decimals 3\\n  function _getBiomeTax(IPvpController.BiomeData memory biomeData) internal view returns (uint guildId, uint taxPercent) {\\n    guildId = biomeData.guildBiomeOwnerId;\\n    taxPercent = guildId == 0 ? 0 : AppLib.BIOME_TAX_PERCENT_MIN;\\n\\n    if (guildId != 0) {\\n      // increment tax value depending on the liquidity amount staked by the guild\\n      address guildStakingAdapter = address(uint160(_S().pvpParam[IPvpController.PvpParams.GUILD_STAKING_ADAPTER_2]));\\n      if (guildStakingAdapter != address(0)) {\\n\\n        // staked amount in game token\\n        uint extraFeeRatio = IGuildStakingAdapter(guildStakingAdapter).getExtraFeeRatio(guildId);\\n\\n        taxPercent += (AppLib.BIOME_TAX_PERCENT_MAX - AppLib.BIOME_TAX_PERCENT_MIN) * Math.min(extraFeeRatio, 1e18) / 1e18;\\n      }\\n    }\\n  }\\n\\n  //endregion ------------------------ Domination internal\\n\\n  //region ------------------------ Utils\\n  function getCurrentEpochWeek(uint blockTimestamp) internal pure returns (uint32) {\\n    return _getEpochWeek(uint32(blockTimestamp / 86400));\\n  }\\n\\n  /// @notice Calculate week for the given day. Assume that first day of the week is Monday\\n  function _getEpochWeek(uint epochDay) internal pure returns (uint32) {\\n    return uint32((epochDay + 3) / 7); // + 3 to move start of the first week to Monday 1969-12-29\\n  }\\n\\n  /// @notice Check if the {user} has given permission in the guild. Permissions are specified by bitmask {rights}.\\n  /// Admin is marked by zero bit, he has all permissions always.\\n  function _checkPermissions(IGuildController guildController, address user, IGuildController.GuildRightBits right) internal view returns (uint guildId, uint rights) {\\n    guildId = guildController.memberOf(user);\\n    rights = guildController.getRights(user);\\n\\n    if (guildId == 0) revert IAppErrors.NotGuildMember();\\n\\n    if (!(\\n      (rights & (2 ** uint(IGuildController.GuildRightBits.ADMIN_0))) != 0\\n      || (rights & (2 ** uint(right))) != 0\\n    )) {\\n      revert IAppErrors.GuildActionForbidden(uint(right));\\n    }\\n  }\\n\\n  function _getPointsWithPenalty(uint points_, uint dominationCounter) internal pure returns (uint) {\\n    uint penalty;\\n    if (dominationCounter != 0) {\\n      if (dominationCounter == 1) penalty = 10;\\n      else if (dominationCounter == 2) penalty = 25;\\n      else if (dominationCounter == 3) penalty = 38;\\n      else if (dominationCounter == 4) penalty = 50;\\n      else if (dominationCounter == 5) penalty = 61;\\n      else if (dominationCounter == 6) penalty = 70;\\n      else if (dominationCounter == 7) penalty = 78;\\n      else if (dominationCounter == 8) penalty = 84;\\n      else if (dominationCounter == 9) penalty = 89;\\n      else if (dominationCounter == 10) penalty = 93;\\n      else if (dominationCounter == 11) penalty = 96;\\n      else penalty = 98;\\n    }\\n\\n    return points_ * (100 - penalty) / 100;\\n  }\\n\\n  /// @notice Generate unique id of the pvp-fight (each pvp-fight consists from multiple turns)\\n  function _generateFightId() internal returns (uint48 fightId) {\\n    fightId = 1 + uint48(_S().pvpParam[IPvpController.PvpParams.FIGHT_COUNTER_3]);\\n    _S().pvpParam[IPvpController.PvpParams.FIGHT_COUNTER_3] = fightId;\\n  }\\n  //endregion ------------------------ Utils\\n}\",\"keccak256\":\"0x2c276697ade024f064c320a8de89975c130344421af682b02b4d624ad4d5e09a\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PvpFightLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IPvpController.sol\\\";\\nimport \\\"../interfaces/IReinforcementController.sol\\\";\\nimport \\\"../interfaces/IGuildStakingAdapter.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./ControllerContextLib.sol\\\";\\nimport \\\"./ScoreLib.sol\\\";\\nimport \\\"./MonsterLib.sol\\\";\\nimport \\\"./AppLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\nimport \\\"./PvpControllerLib.sol\\\";\\nimport \\\"./PvpAttackLib.sol\\\";\\nimport \\\"./ReinforcementControllerLib.sol\\\";\\n\\nlibrary PvpFightLib {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\\n  using EnumerableMap for EnumerableMap.UintToUintMap;\\n\\n  //region ------------------------ Constants\\n  /// @notice Max total count of turns per pvp-fight\\n  uint internal constant MAX_COUNT_TURNS = 100;\\n\\n  /// @notice Heroes do real damage to each other in PVP (items can be broken, hp/mp can be reduced, loser looses 1 life chance)\\n  bool internal constant REAL_DAMAGE_IN_FIGHTS = true;\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Data types\\n\\n  struct HeroContext {\\n    bool isWinner;\\n    IPvpController.PvpFightStatus fightStatus;\\n    /// @notice Target domination biome of the hero's guild\\n    uint8 targetBiome;\\n    uint32 statLife;\\n    uint32 statMana;\\n    /// @notice Score of the hero's opponent received by the hero's guild\\n    uint prize;\\n    IPvpController.HeroData heroData;\\n    IStatController.ChangeableStats stats;\\n    IPvpController.PvpUserState userState;\\n  }\\n\\n  struct StartFightContext {\\n    bool technicalDefeat;\\n    uint32 week;\\n    IGuildController guildController;\\n    IStatController statController;\\n    IItemController itemController;\\n    IUserController userController;\\n    IHeroController heroController;\\n    HeroContext hero;\\n    HeroContext opponent;\\n    IPvpController.PvpFightResults fightResult;\\n  }\\n\\n  struct PrepareFightLocal {\\n    uint8 biome;\\n    uint32 week;\\n    address opponent;\\n    IGuildController guildController;\\n    bytes32 opponentPackedHero;\\n    uint opponentGuildId;\\n  }\\n\\n  struct SavePvpResultsOnCompletionLocal {\\n    bool alive;\\n    bool keepStaked;\\n    bool died;\\n  }\\n\\n  struct SaveFightResultsInput {\\n    address user;\\n    address otherUser;\\n    bool isHero;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ PvP actions\\n\\n  /// @notice Find opponent for the user's hero, prepare the fight\\n  /// @dev Normally the fight is prepared automatically on hero registration.\\n  /// In some cases it doesn't happen and the preparation should be made manually.\\n  /// Ex: Two guilds had peaceful relation. Users of the both guilds registered their heroes.\\n  /// As soon as there are no other guilds, the fights are not initialized.\\n  /// The guilds change their relation to \\\"war\\\". Now users should initialize the fights manually.\\n  /// @param random_ CalcLib.pseudoRandom, required for unit tests\\n  function prepareFight(\\n    address msgSender,\\n    IController controller,\\n    uint blockTimestamp,\\n    function (uint) internal view returns (uint) random_\\n  ) internal {\\n    PvpControllerLib._onlyNotPaused(controller);\\n    PrepareFightLocal memory v;\\n\\n    v.guildController = IGuildController(controller.guildController());\\n    v.week = PvpControllerLib.getCurrentEpochWeek(blockTimestamp);\\n    (, v.biome) = PvpControllerLib._getTargetDominationBiomeWithCheck(msgSender, v.guildController, v.week, true);\\n\\n    IPvpController.EpochData storage epochData = PvpControllerLib._S().epochData[v.week];\\n    IPvpController.PvpUserState memory userState = epochData.pvpUserState[msgSender];\\n    PvpControllerLib._onlyUserWithRegisteredPvpHeroWithoutFights(userState);\\n\\n    (v.opponent, v.opponentPackedHero, v.opponentGuildId) = PvpControllerLib._findPvpOpponent(v.guildController, v.biome, epochData, userState.guildId, random_);\\n    if (v.opponent == address(0)) revert IAppErrors.PvpFightOpponentNotFound();\\n\\n    IPvpController.HeroData memory heroData = _getHeroData(epochData.epochBiomeData[userState.biome], userState.guildId, msgSender);\\n    PvpControllerLib._setupPvpFight(v.biome, epochData, msgSender, v.opponent, userState.guildId, v.opponentGuildId, PvpControllerLib.SetupPvpFightParams({\\n      week: v.week,\\n      hero: heroData.hero,\\n      heroId: heroData.heroId,\\n      opponentPackedHero: v.opponentPackedHero\\n    }));\\n  }\\n\\n  /// @notice Start set of fight turns. Each set can include no more than {maxCountTurns} turns.\\n  /// The whole fight = {set of turns}, set of turn = {turns}, 1 transaction = 1 set of turns.\\n  /// Heroes must fight until one of the heroes has zero lives left.\\n  /// Total number of turns cannot exceed {MAX_COUNT_TURNS}.\\n  /// In this case, the hero with the most lives is chosen as the winner.\\n  function startFight(address msgSender, IController controller, uint blockTimestamp, uint8 maxCountTurns) external {\\n    _doMultipleTurns(msgSender, controller, blockTimestamp, maxCountTurns, CalcLib.pseudoRandom, _pvpFight);\\n  }\\n  //endregion ------------------------ PvP actions\\n\\n  //region ------------------------ PvP fight\\n  /// @dev Wrapper function for {PvpAttackLib.pvpFight} to be able to pass it into {_doMultipleTurns}\\n  function _pvpFight(\\n    PvpAttackLib.PvpFightParams memory p,\\n    IPvpController.HeroData memory hero,\\n    IPvpController.HeroData memory opponent\\n  ) internal returns (IPvpController.PvpFightResults memory fightResult) {\\n    return PvpAttackLib.pvpFight(p, hero, opponent);\\n  }\\n\\n  /// @notice Execute no more than {maxCountTurns} turns\\n  /// @param maxCountTurns Max number of turns that can be performed during this call\\n  /// @param random_ Pass _pseudoRandom here, the param is required to simplify unit testing\\n  /// @param fight_ Pass {_pvpFight} here, the param is required to simplify unit testing\\n  function _doMultipleTurns(\\n    address msgSender,\\n    IController controller,\\n    uint blockTimestamp,\\n    uint8 maxCountTurns,\\n    function (uint) internal view returns (uint) random_,\\n    function (\\n      PvpAttackLib.PvpFightParams memory,\\n      IPvpController.HeroData memory,\\n      IPvpController.HeroData memory\\n    ) internal returns (IPvpController.PvpFightResults memory) fight_\\n  ) internal {\\n    PvpControllerLib._onlyNotPaused(controller);\\n\\n    StartFightContext memory v;\\n\\n    v.itemController = IItemController(controller.itemController());\\n    v.userController = IUserController(controller.userController());\\n    v.guildController = IGuildController(controller.guildController());\\n    v.statController = IStatController(controller.statController());\\n    v.heroController = IHeroController(controller.heroController());\\n    v.week = PvpControllerLib.getCurrentEpochWeek(blockTimestamp);\\n\\n    IPvpController.EpochData storage epochData = PvpControllerLib._S().epochData[v.week];\\n\\n    // set up v.XXX.biome, v.XXX.userState and v.XXX.fightData for each hero\\n    IPvpController.PvpFightData memory heroFightData = _initBiomeUserStateFightData(msgSender, v, epochData, true);\\n    IPvpController.PvpFightData memory opponentFightData = _initBiomeUserStateFightData(heroFightData.fightOpponent, v, epochData, false);\\n\\n    IPvpController.EpochBiomeData storage epochBiomeData = epochData.epochBiomeData[v.hero.userState.biome];\\n\\n    // set up v.XXX.heroData and v.XXX.stats for each hero\\n    _initStatsHeroData(msgSender, v, epochBiomeData, heroFightData, true);\\n    _initStatsHeroData(heroFightData.fightOpponent, v, epochBiomeData, opponentFightData, false);\\n\\n    // ---------------- technical defeat\\n    // pvp-fight was started then the guild has changed domination request to different biome\\n    // pvp-fight is continued, but now fight's biome is different from target one => technical defeat of the hero\\n    // such situation is possible for any hero and even for the both at the same time\\n    (v.technicalDefeat, v.hero.isWinner) = _checkTechnicalDefeat(\\n      v.hero.userState.biome != v.hero.targetBiome,\\n      v.opponent.userState.biome != v.opponent.targetBiome,\\n      random_\\n    );\\n\\n    // ---------------- fights\\n    if (v.technicalDefeat) {\\n      v.opponent.isWinner = !v.hero.isWinner;\\n      v.fightResult = IPvpController.PvpFightResults({\\n        healthHero: v.hero.isWinner ? v.hero.stats.life : 0,\\n        healthOpponent: v.opponent.isWinner ? v.opponent.stats.life : 0,\\n        completed: true,\\n        totalCountFights: heroFightData.countTurns,\\n        manaConsumedHero: v.hero.isWinner ? 0 : v.hero.stats.mana,\\n        manaConsumedOpponent: v.opponent.isWinner ? 0 : v.opponent.stats.mana\\n      });\\n    } else {\\n      v.fightResult = fight_(\\n        PvpAttackLib.PvpFightParams({\\n          msgSender: msgSender,\\n          fightId: v.hero.userState.fightId,\\n          statController: v.statController,\\n          itemController: v.itemController,\\n          maxCountTurns: maxCountTurns,\\n          heroStats: v.hero.stats,\\n          opponentStats : v.opponent.stats,\\n          countTurnsMade: heroFightData.countTurns // opponent has exactly same count of turns\\n        }),\\n        v.hero.heroData,\\n        v.opponent.heroData\\n      );\\n\\n      if (v.fightResult.completed) {\\n        (v.hero.isWinner, v.opponent.isWinner) = _getWinners(v.fightResult, random_);\\n      }\\n    }\\n\\n    // ---------------- save results\\n    _saveFightResults(SaveFightResultsInput(msgSender, heroFightData.fightOpponent, true), v, epochData, epochBiomeData);\\n    _saveFightResults(SaveFightResultsInput(heroFightData.fightOpponent, msgSender, false), v, epochData, epochBiomeData);\\n\\n    if (v.fightResult.completed) {\\n      _emitFightCompleted(v);\\n    }\\n  }\\n\\n  /// @notice Initialize v.XXX.heroData, v.XXX.stats, v.XXX.statLife/Mana for the given hero\\n  function _initStatsHeroData(\\n    address user,\\n    StartFightContext memory v,\\n    IPvpController.EpochBiomeData storage epochBiomeData,\\n    IPvpController.PvpFightData memory fightData,\\n    bool isHero\\n  ) internal view {\\n    HeroContext memory h = isHero ? v.hero : v.opponent;\\n\\n    // v.opponentGuildId can be 0 if the opponent was removed from the guild\\n    // in this case opponentData will contain zeros too => technical defeat with looserScore = 0\\n    h.heroData = _getHeroData(epochBiomeData, h.userState.guildId, user);\\n\\n    // get hero and opponent states\\n    h.stats = v.statController.heroStats(h.heroData.hero, h.heroData.heroId);\\n\\n    // store current stat-values - these are values for the moment before starting the fight\\n    h.statLife = h.stats.life;\\n    h.statMana = h.stats.mana;\\n\\n    // override life and mana in hero state if the fight has been started and now it is being continued\\n    if (fightData.fightStatus == IPvpController.PvpFightStatus.FIGHTING_2) {\\n      h.stats.life = fightData.health;\\n      h.stats.mana = fightData.mana;\\n    }\\n  }\\n\\n  /// @notice Initialize v.XXX.biome, v.XXX.userState and fightData for the given hero\\n  function _initBiomeUserStateFightData(address user, StartFightContext memory v, IPvpController.EpochData storage epochData, bool isHero) internal view returns (\\n    IPvpController.PvpFightData memory heroFightData\\n  ){\\n    HeroContext memory h = isHero ? v.hero : v.opponent;\\n\\n    (, h.targetBiome) = PvpControllerLib._getTargetDominationBiomeWithCheck(user, v.guildController, v.week, isHero);\\n    h.userState = epochData.pvpUserState[user];\\n    if (h.userState.activeFightIndex1 == 0) {\\n      // ensure that the fighting is prepared and not completed\\n      revert IAppErrors.PvpFightIsNotPrepared(h.targetBiome, v.week, user);\\n    }\\n    heroFightData = PvpControllerLib.getFightDataByIndex(v.week, user, h.userState.activeFightIndex1 - 1);\\n\\n    if (\\n      heroFightData.fightStatus == IPvpController.PvpFightStatus.WINNER_3\\n      || heroFightData.fightStatus == IPvpController.PvpFightStatus.LOSER_4\\n    ) revert IAppErrors.PvpFightIsCompleted(h.targetBiome, v.week, user);\\n  }\\n\\n  function _saveFightResults(\\n    SaveFightResultsInput memory p,\\n    StartFightContext memory v,\\n    IPvpController.EpochData storage epochData,\\n    IPvpController.EpochBiomeData storage epochBiomeData\\n  ) internal {\\n    HeroContext memory h = p.isHero ? v.hero : v.opponent;\\n    HeroContext memory other = p.isHero ? v.opponent : v.hero;\\n\\n    if (v.fightResult.completed) {\\n      // update final state (the fight is completed)\\n      h.fightStatus = h.isWinner ? IPvpController.PvpFightStatus.WINNER_3 : IPvpController.PvpFightStatus.LOSER_4;\\n\\n      // looser always lost all mp and hp\\n      if (!h.isWinner) {\\n        if (p.isHero) {\\n          v.fightResult.healthHero = 0;\\n          v.fightResult.manaConsumedHero = v.hero.stats.mana;\\n        } else {\\n          v.fightResult.healthOpponent = 0;\\n          v.fightResult.manaConsumedOpponent = v.opponent.stats.mana;\\n        }\\n      }\\n\\n      // update winner guild points for biome domination\\n      // Possible edge cases: hero/opponent is the winner, but his guild has different target now.\\n      // In such cases guild doesn't receive guild points of the winner\\n      h.prize = h.isWinner && h.userState.biome == h.targetBiome\\n        // apply penalty for repeat domination to the the number of pvp-points\\n        ? PvpControllerLib._getPointsWithPenalty(\\n          v.heroController.score(other.heroData.hero, other.heroData.heroId),\\n          PvpControllerLib._S().biomeState[h.targetBiome].dominationCounter\\n        )\\n        : 0;\\n\\n      _savePvpResultsOnCompletion(p, v, epochData, epochBiomeData, REAL_DAMAGE_IN_FIGHTS);\\n\\n      // reset all buffs and clear usage of the consumables\\n      v.statController.clearTemporallyAttributes(h.heroData.hero, h.heroData.heroId);\\n      v.statController.clearUsedConsumables(h.heroData.hero, h.heroData.heroId);\\n\\n    } else {\\n      // update intermediate state (the fight is not completed, new set of fight is required)\\n      h.fightStatus = IPvpController.PvpFightStatus.FIGHTING_2;\\n    }\\n\\n    epochData.fightData[p.user][h.userState.activeFightIndex1 - 1] = IPvpController.PvpFightData({\\n      fightStatus: h.fightStatus,\\n      fightOpponent: p.otherUser,\\n      countTurns: v.fightResult.totalCountFights,\\n      health: p.isHero ? v.fightResult.healthHero : v.fightResult.healthOpponent,\\n      mana: AppLib.sub0(h.stats.mana, p.isHero ? v.fightResult.manaConsumedHero : v.fightResult.manaConsumedOpponent)\\n    });\\n  }\\n\\n  /// @notice Save results of completed PVP fight: update guild points, register daily activity, update core stat,\\n  /// reduce durability, add the winner to the list of heroes free for fight.\\n  /// @param realDamageAllowed For tests, the value is REAL_DAMAGE_IN_FIGHTS\\n  function _savePvpResultsOnCompletion(\\n    SaveFightResultsInput memory p,\\n    StartFightContext memory c,\\n    IPvpController.EpochData storage epochData,\\n    IPvpController.EpochBiomeData storage epochBiomeData,\\n    bool realDamageAllowed\\n  ) internal {\\n    SavePvpResultsOnCompletionLocal memory v;\\n\\n    HeroContext memory h = p.isHero ? c.hero : c.opponent;\\n    uint32 fightResultHealth = p.isHero ? c.fightResult.healthHero : c.fightResult.healthOpponent;\\n    uint32 fightResultConsumedMana = p.isHero ? c.fightResult.manaConsumedHero : c.fightResult.manaConsumedOpponent;\\n\\n    // update guild points counter for the guild of the winner\\n    if (h.isWinner) {\\n      (bool exist, uint guildPoints) = epochBiomeData.guildPoints.tryGet(h.userState.guildId);\\n      epochBiomeData.guildPoints.set(h.userState.guildId, (exist ? guildPoints : 0) + h.prize);\\n\\n      // update global guild points counter\\n      // assume here, that uint64 is enough to store any sums of scores\\n      if (h.prize != 0) {\\n        c.guildController.incPvpCounter(h.userState.guildId, uint64(h.prize));\\n      }\\n    }\\n\\n    // both users register daily activity\\n    c.userController.registerPvP(p.user, h.isWinner);\\n\\n    v.alive = h.isWinner;\\n\\n    // winner is kept staked OR can be auto-removed if maxFights-limit is reached\\n    // loser's hero is auto-removed always and should be staked again\\n    v.keepStaked = v.alive && (h.userState.maxFights == 0 || h.userState.maxFights > h.userState.countFights + 1);\\n    v.died = !v.alive && h.stats.lifeChances <= 1;\\n\\n    if (realDamageAllowed) {\\n      // update hp, mp, lc\\n\\n      if (fightResultHealth == 0 && v.alive) {\\n        // winner has new life = 0 => he loses life chance in the same way as the looser and should be removed\\n        v.alive = false;\\n        v.keepStaked = false;\\n      }\\n\\n      if (!v.died) {\\n        { // decrease life, mana and probably life-chance\\n          IStatController.ChangeableStats memory cs = IStatController.ChangeableStats({\\n            level: 0,\\n            experience: 0,\\n            life: AppLib.sub0(h.statLife, fightResultHealth),\\n          // the fight consists from many turns, here:\\n          // v.heroStatMana = mana before starting the fight (== starting the turn)\\n          // v.heroStats.mana = mana at the moment of the beginning current set of fights\\n          // v.fightResult.manaConsumedHero = mana consumed during current set of fights\\n          // mana = total value of mana consumed from starting the fight\\n            mana: AppLib.sub0(h.statMana, (AppLib.sub0(h.stats.mana, fightResultConsumedMana))),\\n            lifeChances: v.alive ? 0 : 1\\n          });\\n          c.statController.changeCurrentStats(h.heroData.hero, h.heroData.heroId, cs, false);\\n        }\\n\\n        if (!v.alive) {\\n          // hero has lost once life chance, but result life chance > 0 => restore life and mana\\n          IStatController.ChangeableStats memory cs = IStatController.ChangeableStats({\\n            level: 0,\\n            experience: 0,\\n            life: _getHeroAttribute(c.statController, h, IStatController.ATTRIBUTES.LIFE),\\n            mana: _getHeroAttribute(c.statController, h, IStatController.ATTRIBUTES.MANA),\\n            lifeChances: 0\\n          });\\n          c.statController.changeCurrentStats(h.heroData.hero, h.heroData.heroId, cs, true);\\n        }\\n      }\\n      // reduce durability of all equipped items (including all skills), take off broken items\\n      c.itemController.reduceDurability(h.heroData.hero, h.heroData.heroId, h.userState.biome, true);\\n    }\\n\\n    if (v.keepStaked) {\\n      // update user state\\n      epochData.pvpUserState[p.user] = IPvpController.PvpUserState({\\n        activeFightIndex1: 0,\\n        biome: h.userState.biome,\\n        guildId: h.userState.guildId,\\n        numHeroesStaked: epochData.pvpUserState[p.user].numHeroesStaked,\\n        countFights: h.userState.countFights + 1, // overflow is not possible, see keepStaked above\\n        maxFights: h.userState.maxFights,\\n        fightId: 0 // there is no active fight anymore\\n      });\\n\\n      // add the (only live) winner back to the list of the users free for pvp\\n      epochBiomeData.freeUsers[h.userState.guildId].add(p.user);\\n    } else {\\n      PvpControllerLib._removePvpHero(c.week, epochData, epochBiomeData, h.userState, p.user, false);\\n    }\\n\\n    if (realDamageAllowed && v.died) {\\n      _killHero(c.heroController, c.guildController, h, (p.isHero ? c.opponent : c.hero).userState.guildId);\\n    }\\n  }\\n\\n  function _getHeroAttribute(IStatController statController, HeroContext memory h, IStatController.ATTRIBUTES attribute) internal view returns (uint32) {\\n    return uint32(uint(int(statController.heroAttribute(h.heroData.hero, h.heroData.heroId, uint(attribute)))));\\n  }\\n\\n  /// @notice Kill the hero and send all items to the winner's guild bank\\n  function _killHero(IHeroController heroController, IGuildController guildController, HeroContext memory hero, uint opponentGuildId) internal {\\n    bytes32[] memory dropItems = heroController.kill(hero.heroData.hero, hero.heroData.heroId);\\n    uint len = dropItems.length;\\n    if (len != 0) {\\n      address guildBank = guildController.getGuildBank(\\n        hero.isWinner\\n          // the hero is winner but he is dead, all drop is sent to the bank of the hero's guild\\n          ? hero.userState.guildId\\n          // the hero is looser and he is dead, all drop is send to the bank of the opponent's guild\\n          : opponentGuildId\\n      );\\n\\n      if (guildBank == address(0)) revert IAppErrors.ZeroAddress(); // weird case, it should never appear\\n\\n      address[] memory items = new address[](len);\\n      uint[] memory itemIds = new uint[](len);\\n      for (uint i; i < len; ++i) {\\n        (items[i], itemIds[i]) = PackingLib.unpackNftId(dropItems[i]);\\n\\n        // SCR-1253: Attention: GuildBank with version below 1.0.2 was not inherited from ERC721Holder (mistake).\\n        // As result, safeTransferFrom doesn't work with such banks, they must be updated. So, use transferFrom here.\\n        IERC721(items[i]).transferFrom(address(this), guildBank, itemIds[i]);\\n      }\\n      emit IApplicationEvents.AddPvpFightItems(hero.userState.fightId, items, itemIds);\\n    }\\n  }\\n\\n  /// @notice The hero with greater health is the winner. If healths are the same the winner is selected randomly\\n  /// If both heroes have zero lives assume that they are both winners.\\n  function _getWinners(\\n    IPvpController.PvpFightResults memory fightResult,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (bool isHeroWinner, bool isOpponentWinner) {\\n    if (fightResult.healthHero > fightResult.healthOpponent) {\\n      isHeroWinner = true;\\n    } else if (fightResult.healthHero < fightResult.healthOpponent) {\\n      isOpponentWinner = true;\\n    } else {\\n      if (fightResult.healthHero == 0) {\\n        // special case: both heroes have zero health => they are both WINNERS\\n        isHeroWinner = true;\\n        isOpponentWinner = true;\\n      } else {\\n        // special case: both heroes have same NOT ZERO health => the winner is selected randomly\\n        isHeroWinner = random_(1) == 0;\\n        isOpponentWinner = !isHeroWinner;\\n      }\\n    }\\n\\n    return (isHeroWinner, isOpponentWinner);\\n  }\\n\\n  function _getHeroData(IPvpController.EpochBiomeData storage epochBiomeData, uint guildId, address user) internal view returns (\\n    IPvpController.HeroData memory heroData\\n  ) {\\n    (bool exist, uint packedHeroAsInt) = epochBiomeData.registeredHeroes[guildId].tryGet(user);\\n    if (! exist) revert IAppErrors.ErrorHeroIsNotRegistered(address(0)); // edge case (?)\\n\\n    bytes32 packedHero = bytes32(packedHeroAsInt);\\n    (heroData.hero, heroData.heroId) = PackingLib.unpackNftId(packedHero);\\n    heroData.pvpStrategy = epochBiomeData.pvpStrategy[packedHero];\\n\\n    return heroData;\\n  }\\n\\n  /// @notice Check if technical defeat detected (the defeat without actual fighting)\\n  /// @param heroHasTechnicalDefeat Special case: the hero has technical defeat\\n  /// if he fights in biome X but his guild has changed domination request to biome Y\\n  /// @param opponentHasTechnicalDefeat Special case: the opponent has technical defeat\\n  /// if he fights in biome X but his guild has changed domination request to biome Y\\n  /// @return technicalDefeat Technical defeat is detected\\n  /// @return isHeroWinner Hero is the winner in the detected technical defeat\\n  function _checkTechnicalDefeat(\\n    bool heroHasTechnicalDefeat,\\n    bool opponentHasTechnicalDefeat,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    bool technicalDefeat,\\n    bool isHeroWinner\\n  ) {\\n    technicalDefeat = heroHasTechnicalDefeat || opponentHasTechnicalDefeat;\\n    if (technicalDefeat) {\\n      if (heroHasTechnicalDefeat) {\\n        if (opponentHasTechnicalDefeat) {\\n          // both heroes have technical defeats, the winner is selected randomly\\n          isHeroWinner = random_(1) == 0;\\n        } else {\\n          // the opponent is the winner, by default: isHeroWinner = false;\\n        }\\n      } else {\\n        isHeroWinner = true;\\n      }\\n    }\\n\\n    return (technicalDefeat, isHeroWinner);\\n  }\\n\\n  //endregion ------------------------ PvP fight\\n\\n  //region ------------------------ Events\\n  function _emitFightCompleted(StartFightContext memory v) internal {\\n    emit IApplicationEvents.PvpFightCompleted(\\n      v.fightResult,\\n      v.hero.userState.fightId,\\n      [v.hero.heroData.hero, v.opponent.heroData.hero],\\n      [v.hero.userState.guildId, v.opponent.userState.guildId],\\n      [v.hero.isWinner, v.opponent.isWinner],\\n      [v.hero.prize, v.opponent.prize],\\n      v.technicalDefeat\\n    );\\n  }\\n\\n  //endregion ------------------------ Events\\n}\",\"keccak256\":\"0xc3aa24ed8fe198945391324d8fa48f083967be0e206e9b9e450423ac0f9bd191\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ReinforcementControllerLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IDungeonFactory.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IGameToken.sol\\\";\\nimport \\\"../interfaces/IMinter.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\nimport \\\"../interfaces/IReinforcementController.sol\\\";\\nimport \\\"../lib/CalcLib.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\nimport \\\"../lib/AppLib.sol\\\";\\n\\nlibrary ReinforcementControllerLib {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\\n  using EnumerableMap for EnumerableMap.Bytes32ToUintMap;\\n  using PackingLib for bytes32;\\n  using PackingLib for address;\\n  using PackingLib for uint8[];\\n\\n  //region ------------------------ Constants\\n\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"reinforcement.controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0x5a053c541e08c6bd7dfc3042a100e83af246544a23ecda1a47bf22b441b00c00;\\n  uint internal constant _SEARCH_WINDOW = 100;\\n  int32 internal constant _ATTRIBUTES_RATIO = 20;\\n  uint internal constant _FEE_MIN = 10;\\n  uint internal constant _TO_HELPER_RATIO_MAX = 50;\\n  uint internal constant _STAKE_REDUCE_DELAY = 7 days;\\n  uint internal constant _DELAY_FACTOR = 2;\\n  uint internal constant _SIP001_COUNT_REQUIRED_SKILLS = 3;\\n\\n  /// @notice Min level of shelter where guild reinforcement is allowed. 2, 3 - allowed, 1 - forbidden.\\n  uint internal constant MIN_SHELTER_LEVEL_GUILD_REINFORCEMENT_ALLOWED = 2;\\n\\n  /// @notice Guild hero staking is not allowed during following period after withdrawing the hero\\n  uint internal constant HERO_COOLDOWN_PERIOD_AFTER_GUILD_HERO_WITHDRAWING = 1 days;\\n\\n  uint internal constant STATUS_HELPER_FREE = 0;\\n\\n  /// @notice 24 hours is divided on \\\"baskets\\\". Each basket covers given interval of the hours.\\n  uint constant internal BASKET_INTERVAL = 3;\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Restrictions\\n\\n  function onlyHeroController(IController controller) internal view returns (address heroController){\\n    heroController = controller.heroController();\\n    if (heroController != msg.sender) revert IAppErrors.ErrorNotHeroController(msg.sender);\\n  }\\n\\n  /// @notice Ensure that the user is a member of a guild, the guild has a shelter and the shelter has level > 1\\n  function onlyGuildWithShelterEnoughLevel(IGuildController gc, uint guildId) internal view {\\n    uint shelterId = gc.guildToShelter(guildId);\\n    if (shelterId == 0) revert IAppErrors.GuildHasNoShelter();\\n\\n    (, uint8 shelterLevel, ) = PackingLib.unpackShelterId(shelterId);\\n    if (shelterLevel < MIN_SHELTER_LEVEL_GUILD_REINFORCEMENT_ALLOWED) revert IAppErrors.ShelterHasNotEnoughLevelForReinforcement();\\n  }\\n\\n  function onlyNotPausedEoaOwner(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId) internal view {\\n    if (!isEoa) revert IAppErrors.ErrorOnlyEoa();\\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\\n    if (IERC721(heroToken).ownerOf(heroId) != msgSender) revert IAppErrors.ErrorNotOwner(heroToken, heroId);\\n  }\\n\\n  function onlyDungeonFactory(IController controller) internal view {\\n    if (controller.dungeonFactory() != msg.sender) revert IAppErrors.ErrorNotDungeonFactory(msg.sender);\\n  }\\n\\n  function onlyDeployer(IController controller) internal view {\\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n\\n  function _checkStakeAllowed(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId)\\n  internal view returns (IHeroController){\\n    onlyNotPausedEoaOwner(isEoa, controller, msgSender, heroToken, heroId);\\n\\n    IHeroController hc = IHeroController(controller.heroController());\\n    if (hc.heroClass(heroToken) == 0) revert IAppErrors.ErrorHeroIsNotRegistered(heroToken);\\n\\n    if (IDungeonFactory(controller.dungeonFactory()).currentDungeon(heroToken, heroId) != 0) revert IAppErrors.HeroInDungeon();\\n    if (isStaked(heroToken, heroId)) revert IAppErrors.AlreadyStaked();\\n    address pvpController = controller.pvpController();\\n    if (pvpController != address(0)) {\\n      if (IPvpController(pvpController).isHeroStakedCurrently(heroToken, heroId)) revert IAppErrors.PvpStaked();\\n    }\\n\\n    if (hc.sandboxMode(heroToken, heroId) == uint8(IHeroController.SandboxMode.SANDBOX_MODE_1)) revert IAppErrors.SandboxModeNotAllowed();\\n\\n    return hc;\\n  }\\n\\n  function _checkWithdrawAllowed(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId) internal view {\\n    onlyNotPausedEoaOwner(isEoa, controller, msgSender, heroToken, heroId);\\n    if (IHeroController(controller.heroController()).heroClass(heroToken) == 0) revert IAppErrors.ErrorHeroIsNotRegistered(heroToken);\\n  }\\n\\n  function _memberOf(IController controller, address msgSender) internal view returns (IGuildController gc, uint guildId) {\\n    gc = IGuildController(controller.guildController());\\n    guildId = gc.memberOf(msgSender);\\n    if (guildId == 0) revert IAppErrors.NotGuildMember();\\n  }\\n\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ VIEWS\\n\\n  function _S() internal pure returns (IReinforcementController.MainState storage s) {\\n    assembly {\\n      s.slot := MAIN_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n\\n  function toHelperRatio(IController controller, address heroToken, uint heroId) internal view returns (uint) {\\n    // Assume that this function is called by dungeonLib before reinforcement releasing\\n    // so for guild-reinforcement we can detect guild by guildHelperOf\\n    uint guildId = busyGuildHelperOf(heroToken, heroId);\\n    if (guildId == 0) {\\n      // Helper doesn't receive any reward at the end of the dungeon in Reinforcement V2\\n      // fixed reward-amount is paid to the helper in askHeroV2, that's all\\n      return 0;\\n    }  else {\\n      // guild reinforcement\\n      // assume that guildController is initialized\\n      (, , , , , uint _toHelperRatio) = IGuildController(controller.guildController()).getGuildData(guildId);\\n      return _toHelperRatio;\\n    }\\n  }\\n\\n  function heroInfo(address heroToken, uint heroId) internal view returns (IReinforcementController.HeroInfo memory) {\\n    return unpackHeroInfo(_S()._stakedHeroes[heroToken.packNftId(heroId)]);\\n  }\\n\\n  function heroInfoV2(address heroToken, uint heroId) internal view returns (IReinforcementController.HeroInfoV2 memory) {\\n    return _S().stakedHeroesV2[heroToken.packNftId(heroId)];\\n  }\\n\\n  /// @notice Check if the hero is staked using classic or guild reinforcement\\n  function isStaked(address heroToken, uint heroId) internal view returns (bool) {\\n    return isStakedV2(heroToken, heroId)\\n      || getStakedHelperGuild(heroToken, heroId) != 0\\n      || isStakedV1(heroToken, heroId);\\n  }\\n\\n  function isStakedV1(address heroToken, uint heroId) internal view returns (bool) {\\n    return heroInfo(heroToken, heroId).biome != 0;\\n  }\\n\\n  function isStakedV2(address heroToken, uint heroId) internal view returns (bool) {\\n    return heroInfoV2(heroToken, heroId).biome != 0;\\n  }\\n\\n  /// @return Return the guild in which the hero is staked for guild reinforcement\\n  function getStakedHelperGuild(address heroToken, uint heroId) internal view returns (uint) {\\n    return _S().stakedGuildHeroes[heroToken.packNftId(heroId)];\\n  }\\n\\n  function stakedGuildHelpersLength(uint guildId) internal view returns (uint) {\\n    return _S().guildHelpers[guildId].length();\\n  }\\n\\n  function stakedGuildHelperByIndex(uint guildId, uint index) internal view returns (\\n    address helper,\\n    uint helperId,\\n    uint busyInGuildId\\n  ) {\\n    bytes32 packedHelper;\\n    (packedHelper, busyInGuildId) =  _S().guildHelpers[guildId].at(index);\\n    (helper, helperId) = PackingLib.unpackNftId(packedHelper);\\n  }\\n\\n  function earned(address heroToken, uint heroId) internal view returns (\\n    address[] memory tokens,\\n    uint[] memory amounts,\\n    address[] memory nfts,\\n    uint[] memory ids\\n  ){\\n    EnumerableMap.AddressToUintMap storage erc20Rewards = _S()._heroTokenRewards[heroToken.packNftId(heroId)];\\n    uint length = erc20Rewards.length();\\n    tokens = new address[](length);\\n    amounts = new uint[](length);\\n    for (uint i; i < length; ++i) {\\n      (tokens[i], amounts[i]) = erc20Rewards.at(i);\\n    }\\n\\n    bytes32[] storage nftRewards = _S()._heroNftRewards[heroToken.packNftId(heroId)];\\n    length = nftRewards.length;\\n    nfts = new address[](length);\\n    ids = new uint[](length);\\n    for (uint i; i < length; ++i) {\\n      (nfts[i], ids[i]) = PackingLib.unpackNftId(nftRewards[i]);\\n    }\\n  }\\n\\n  /// @notice Return the guild in which the hero is currently asked for guild reinforcement\\n  function busyGuildHelperOf(address heroToken, uint heroId) internal view returns (uint guildId) {\\n    return _S().busyGuildHelpers[heroToken.packNftId(heroId)];\\n  }\\n\\n  /// @notice Return moment of last withdrawing of the hero from guild reinforcement\\n  function lastGuildHeroWithdrawTs(address heroToken, uint heroId) internal view returns (uint guildId) {\\n    return _S().lastGuildHeroWithdrawTs[heroToken.packNftId(heroId)];\\n  }\\n\\n  function getConfigV2() internal view returns (uint32 minNumberHits, uint32 maxNumberHits, uint32 lowDivider, uint32 highDivider, uint8 levelLimit) {\\n    return PackingLib.unpackConfigReinforcementV2(\\n      bytes32(_S().configParams[IReinforcementController.ConfigParams.V2_MIN_MAX_BOARD_0])\\n    );\\n  }\\n\\n  function getFeeAmount(address gameToken, uint hitsLast24h, uint8 biome) internal view returns (uint feeAmount) {\\n    return _getFeeAmount(gameToken, hitsLast24h, biome);\\n  }\\n\\n  function getHitsNumberPerLast24Hours(uint8 biome, uint blockTimestamp) internal view returns (uint hitsLast24h) {\\n    IReinforcementController.LastWindowsV2 memory stat24h = _S().stat24hV2[biome];\\n    (hitsLast24h, ) = getHitsNumberPerLast24Hours(blockTimestamp, BASKET_INTERVAL, stat24h);\\n  }\\n\\n  function getLastWindowsV2(uint8 biome) internal view returns (IReinforcementController.LastWindowsV2 memory) {\\n    return _S().stat24hV2[biome];\\n  }\\n\\n  function heroesByBiomeV2Length(uint8 biome) internal view returns (uint) {\\n    return _S().heroesByBiomeV2[biome].length();\\n  }\\n\\n  function heroesByBiomeV2ByIndex(uint8 biome, uint index) internal view returns (address helper, uint helperId) {\\n    bytes32 packedHelper =_S().heroesByBiomeV2[biome].at(index);\\n    (helper, helperId) = PackingLib.unpackNftId(packedHelper);\\n  }\\n\\n  function heroesByBiomeV2(uint8 biome) internal view returns (address[] memory helpers, uint[] memory helperIds) {\\n    EnumerableSet.Bytes32Set storage packedHeroes = _S().heroesByBiomeV2[biome];\\n    uint len = packedHeroes.length();\\n\\n    helpers = new address[](len);\\n    helperIds = new uint[](len);\\n\\n    for (uint i; i < len; ++i) {\\n      (helpers[i], helperIds[i]) = PackingLib.unpackNftId(packedHeroes.at(i));\\n    }\\n    return (helpers, helperIds);\\n  }\\n\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ GOV ACTIONS\\n  function setConfigV2(IController controller, IReinforcementController.ConfigReinforcementV2 memory config) internal {\\n    onlyDeployer(controller);\\n    _S().configParams[IReinforcementController.ConfigParams.V2_MIN_MAX_BOARD_0] = uint(\\n      PackingLib.packConfigReinforcementV2(config.minNumberHits, config.maxNumberHits, config.lowDivider, config.highDivider, config.levelLimit)\\n    );\\n  }\\n\\n  //endregion ------------------------ GOV ACTIONS\\n\\n  //region ------------------------ Reinforcement V1\\n  /// @notice Reverse operation for {stakeHero}\\n  function withdrawHero(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId) internal {\\n    IReinforcementController.MainState storage s = _S();\\n\\n    _checkWithdrawAllowed(isEoa, controller, msgSender, heroToken, heroId);\\n\\n    (uint8 biome, , , ) = PackingLib.unpackReinforcementHeroInfo(s._stakedHeroes[heroToken.packNftId(heroId)]);\\n    if (biome == 0) revert IAppErrors.NotStaked();\\n\\n    s._internalIdsByBiomes[biome].remove(heroToken.packNftId(heroId));\\n    delete s._stakedHeroes[heroToken.packNftId(heroId)];\\n\\n    emit IApplicationEvents.HeroWithdraw(heroToken, heroId);\\n  }\\n\\n  function unpackHeroInfo(bytes32 packed) internal pure returns (IReinforcementController.HeroInfo memory info) {\\n    (info.biome, info.score, info.fee, info.stakeTs) = PackingLib.unpackReinforcementHeroInfo(packed);\\n    return info;\\n  }\\n  //endregion ------------------------ Reinforcement V1\\n\\n  //region ------------------------ Rewards for reinforcement of any kind\\n  /// @notice For classic reinforcement: register reward in _S(), keep tokens on balance of this contract\\n  /// For guild reinforcement: re-send reward to the guild bank.\\n  /// @dev Only for dungeon. Assume the tokens already sent to this contract.\\n  function registerTokenReward(IController controller, address heroToken, uint heroId, address token, uint amount) internal {\\n    onlyDungeonFactory(controller);\\n\\n    uint guildId = busyGuildHelperOf(heroToken, heroId);\\n    if (guildId == 0) {\\n      // classic reinforcement: save all rewards to _heroTokenRewards\\n      EnumerableMap.AddressToUintMap storage rewards = _S()._heroTokenRewards[heroToken.packNftId(heroId)];\\n\\n      (,uint existAmount) = rewards.tryGet(token);\\n      rewards.set(token, existAmount + amount);\\n\\n      emit IApplicationEvents.TokenRewardRegistered(heroToken, heroId, token, amount, existAmount + amount);\\n    } else {\\n      // guild reinforcement: send all rewards to guild bank\\n      // assume that guildController is initialized\\n      address guildBank = IGuildController(controller.guildController()).getGuildBank(guildId);\\n      IERC20(token).transfer(guildBank, amount);\\n      emit IApplicationEvents.GuildTokenRewardRegistered(heroToken, heroId, token, amount, guildId);\\n    }\\n  }\\n\\n  /// @notice For classic reinforcement: register reward in _S(), keep the token on balance of this contract\\n  /// For guild reinforcement: re-send NFT-reward to the guild bank.\\n  /// @dev Only for dungeon. Assume the NFT already sent to this contract.\\n  function registerNftReward(IController controller, address heroToken, uint heroId, address token, uint tokenId) internal {\\n    onlyDungeonFactory(controller);\\n\\n    uint guildId = busyGuildHelperOf(heroToken, heroId);\\n    if (guildId == 0) {\\n        // classic reinforcement: save all rewards to _heroNftRewards\\n      _S()._heroNftRewards[heroToken.packNftId(heroId)].push(token.packNftId(tokenId));\\n\\n      emit IApplicationEvents.NftRewardRegistered(heroToken, heroId, token, tokenId);\\n    } else {\\n      // guild reinforcement: send all rewards to guild bank\\n      // assume that guildController is initialized\\n      address guildBank = IGuildController(controller.guildController()).getGuildBank(guildId);\\n      IERC721(token).transferFrom(address(this), guildBank, tokenId);\\n\\n      emit IApplicationEvents.GuildNftRewardRegistered(heroToken, heroId, token, tokenId, guildId);\\n    }\\n  }\\n\\n  function claimAll(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId) internal {\\n    onlyNotPausedEoaOwner(isEoa, controller, msgSender, heroToken, heroId);\\n\\n    _claimAllTokenRewards(heroToken, heroId, msgSender);\\n    _claimAllNftRewards(heroToken, heroId, msgSender);\\n  }\\n\\n  function claimNft(\\n    bool isEoa,\\n    IController controller,\\n    address msgSender,\\n    address heroToken,\\n    uint heroId,\\n    uint countNft\\n  ) internal {\\n    onlyNotPausedEoaOwner(isEoa, controller, msgSender, heroToken, heroId);\\n\\n    _claimNftRewards(heroToken, heroId, msgSender, countNft);\\n  }\\n  //endregion ------------------------ Rewards for reinforcement of any kind\\n\\n  //region ------------------------ Guild reinforcement\\n  function stakeGuildHero(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId) internal {\\n    _checkStakeAllowed(isEoa, controller, msgSender, heroToken, heroId);\\n\\n    IReinforcementController.MainState storage s = _S();\\n    bytes32 packedHero = heroToken.packNftId(heroId);\\n\\n    (, uint guildId) = _memberOf(controller, msgSender);\\n\\n    uint lastGuildHeroWithdraw = s.lastGuildHeroWithdrawTs[packedHero];\\n    if (block.timestamp - HERO_COOLDOWN_PERIOD_AFTER_GUILD_HERO_WITHDRAWING < lastGuildHeroWithdraw) revert IAppErrors.GuildReinforcementCooldownPeriod();\\n\\n    s.stakedGuildHeroes[packedHero] = guildId;\\n\\n    // there is a chance that the hero is being used in reinforcement as result of previous staking\\n    uint busyByGuidId = s.busyGuildHelpers[packedHero];\\n    s.guildHelpers[guildId].set(packedHero, busyByGuidId);\\n\\n    emit IApplicationEvents.GuildHeroStaked(heroToken, heroId, guildId);\\n  }\\n\\n  function withdrawGuildHero(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId) internal {\\n    _checkWithdrawAllowed(isEoa, controller, msgSender, heroToken, heroId);\\n\\n    IReinforcementController.MainState storage s = _S();\\n    bytes32 packedHero = heroToken.packNftId(heroId);\\n\\n    uint guildId = s.stakedGuildHeroes[packedHero];\\n    if (guildId == 0) revert IAppErrors.NotStakedInGuild();\\n\\n    delete s.stakedGuildHeroes[packedHero];\\n    if (s.guildHelpers[guildId].contains(packedHero)) {\\n      s.guildHelpers[guildId].remove(packedHero);\\n    }\\n\\n    s.lastGuildHeroWithdrawTs[packedHero] = block.timestamp;\\n\\n    emit IApplicationEvents.GuildHeroWithdrawn(heroToken, heroId, guildId);\\n  }\\n\\n  /// @param hero Assume that the hero has no reinforcement, it's checked inside ItemController\\n  /// @param helper Desired helper. It should be staked by a member of the user's guild.\\n  function askGuildHero(IController controller, address hero, uint heroId, address helper, uint helperId) internal returns (\\n    int32[] memory attributes\\n  ) {\\n    onlyHeroController(controller);\\n\\n    address user = IERC721(hero).ownerOf(heroId);\\n    IReinforcementController.MainState storage s = _S();\\n    (IGuildController gc, uint guildId) = _memberOf(controller, user);\\n\\n    onlyGuildWithShelterEnoughLevel(gc, guildId);\\n\\n    // ensure that the helper is free\\n    bytes32 packedHelper = PackingLib.packNftId(helper, helperId);\\n    EnumerableMap.Bytes32ToUintMap storage guildHelpers = s.guildHelpers[guildId];\\n    if (!guildHelpers.contains(packedHelper)) revert IAppErrors.GuildHelperNotAvailable(guildId, helper, helperId);\\n\\n    // mark the helper as busy\\n    guildHelpers.set(packedHelper, guildId);\\n    s.busyGuildHelpers[packedHelper] = guildId;\\n\\n    attributes = _getReinforcementAttributes(controller, helper, helperId);\\n\\n    emit IApplicationEvents.GuildHeroAsked(helper, helperId, guildId, user);\\n    return attributes;\\n  }\\n\\n  function releaseGuildHero(IController controller, address helperHeroToken, uint helperHeroTokenId) internal {\\n    onlyHeroController(controller);\\n\\n    bytes32 packedHero = helperHeroToken.packNftId(helperHeroTokenId);\\n    IReinforcementController.MainState storage s = _S();\\n\\n    // there is a chance that the helperId is already burnt\\n    // see test \\\"use guild reinforcement - burn the helper-hero that is being used by reinforcement\\\"\\n    // so, we cannot check HeroBase(helperHeroToken).ownerOf(helperHeroTokenId) here without try/catch\\n    address owner = getHeroTokenOwnerSafe(helperHeroToken, helperHeroTokenId);\\n\\n    if (s.busyGuildHelpers[packedHero] == 0) revert IAppErrors.NotBusyGuildHelper();\\n\\n    uint guildIdStakedIn = s.stakedGuildHeroes[packedHero];\\n    if (guildIdStakedIn != 0) {\\n      s.guildHelpers[guildIdStakedIn].set(packedHero, 0); // free for use in guild reinforcement again\\n    }\\n\\n    s.busyGuildHelpers[packedHero] = 0;\\n\\n    emit IApplicationEvents.GuildHeroReleased(helperHeroToken, helperHeroTokenId, guildIdStakedIn, owner);\\n  }\\n  //endregion ------------------------ Guild reinforcement\\n\\n  //region ------------------------ Reinforcement V2\\n  /// @notice Stake hero in reinforcement-v2\\n  /// @param rewardAmount Reward required by the helper for the help.\\n  function stakeHeroV2(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId, uint rewardAmount) internal {\\n    IReinforcementController.MainState storage s = _S();\\n\\n    if (rewardAmount == 0) revert IAppErrors.ZeroAmount();\\n\\n    IHeroController heroController = _checkStakeAllowed(isEoa, controller, msgSender, heroToken, heroId);\\n    IStatController statController = IStatController(controller.statController());\\n\\n    uint8 biome = heroController.heroBiome(heroToken, heroId);\\n\\n    {\\n      (, , , , uint8 levelLimit) = getConfigV2();\\n      IStatController.ChangeableStats memory stats = statController.heroStats(heroToken, heroId);\\n      if (levelLimit != 0) { // levelLimit can be 0 in functional tests\\n        if (stats.level > levelLimit && (stats.level - levelLimit) / levelLimit > biome) revert IAppErrors.StakeHeroNotStats();\\n      }\\n      if (stats.lifeChances == 0) revert IAppErrors.ErrorHeroIsDead(heroToken, heroId);\\n    }\\n\\n    s.heroesByBiomeV2[biome].add(heroToken.packNftId(heroId));\\n\\n    s.stakedHeroesV2[heroToken.packNftId(heroId)] = IReinforcementController.HeroInfoV2({\\n      biome: biome,\\n      stakeTs: uint64(block.timestamp),\\n      rewardAmount: uint128(rewardAmount)\\n    });\\n\\n    emit IApplicationEvents.HeroStakedV2(heroToken, heroId, biome, rewardAmount);\\n  }\\n\\n  /// @notice Reverse operation for {stakeHeroV2}\\n  function withdrawHeroV2(bool isEoa, IController controller, address msgSender, address heroToken, uint heroId) internal {\\n    IReinforcementController.MainState storage s = _S();\\n\\n    _checkWithdrawAllowed(isEoa, controller, msgSender, heroToken, heroId);\\n    bytes32 packedHero = heroToken.packNftId(heroId);\\n\\n    IReinforcementController.HeroInfoV2 memory _heroInfoV2 = s.stakedHeroesV2[packedHero];\\n    if (_heroInfoV2.biome == 0) revert IAppErrors.NotStaked();\\n\\n    s.heroesByBiomeV2[_heroInfoV2.biome].remove(packedHero);\\n    delete s.stakedHeroesV2[packedHero];\\n\\n    emit IApplicationEvents.HeroWithdraw(heroToken, heroId);\\n  }\\n\\n  /// @notice {hero} asks help of the {helper}\\n  /// Hero owner sends reward amount to the helper owner as the reward for the help.\\n  /// Hero owner sends fixed fee to controller using standard process-routine.\\n  /// Size of the fixed fee depends on total number of calls of {askHeroV2} for last 24 hours since the current moment.\\n  /// Durability of all equipped items of the helper are reduced.\\n  /// Assume, that hero owner approves rewardAmount + fixed fee to reinforcementController-contract\\n  /// - rewardAmount: amount required by the helper (see {heroInfoV2})\\n  /// - fixed fee: fee taken by controller (see {getFeeAmount})\\n  function askHeroV2(IController controller, address hero, uint heroId, address helper, uint helperId, uint blockTimestamp) internal returns (\\n    int32[] memory attributes\\n  ) {\\n    // assume that the signer (HeroController) has checked that the hero and helper are registered, controller is not paused\\n    uint8 heroBiome;\\n    {\\n      address heroController = onlyHeroController(controller);\\n      heroBiome = IHeroController(heroController).heroBiome(hero, heroId);\\n    }\\n\\n    address gameToken = controller.gameToken();\\n\\n    IReinforcementController.HeroInfoV2 memory _heroInfo = _S().stakedHeroesV2[helper.packNftId(helperId)];\\n    if (_heroInfo.biome != heroBiome) revert IAppErrors.HelperNotAvailableInGivenBiome();\\n\\n    // calculate number of calls for the last 24 hours starting from the current moment\\n    uint hitsLast24h = _getHitsLast24h(heroBiome, blockTimestamp);\\n\\n    // calculate fixed fee and send it to the treasury\\n    uint fixedFee = _getFeeAmount(gameToken, hitsLast24h, heroBiome);\\n\\n    {\\n      address heroOwner = IERC721(hero).ownerOf(heroId);\\n      IERC20(gameToken).transferFrom(heroOwner, address(this), fixedFee + _heroInfo.rewardAmount);\\n    }\\n\\n    { // send reward amount from msgSender to helper\\n      address helperOwner = IERC721(helper).ownerOf(helperId);\\n      IERC20(gameToken).transfer(helperOwner, _heroInfo.rewardAmount);\\n    }\\n\\n    AppLib.approveIfNeeded(gameToken, fixedFee, address(controller));\\n    controller.process(gameToken, fixedFee, address(this));\\n\\n    attributes = _getReinforcementAttributes(controller, helper, helperId);\\n\\n    // reduceDurability of all equipped items of the helper\\n    IItemController(controller.itemController()).reduceDurability(helper, helperId, heroBiome, true);\\n\\n    emit IApplicationEvents.HeroAskV2(helper, helperId, hitsLast24h, fixedFee, _heroInfo.rewardAmount);\\n\\n    return attributes;\\n  }\\n\\n  //endregion ------------------------ Reinforcement V2\\n\\n  //region ------------------------ Internal logic\\n  /// @notice Increment counter of hits, calculate actual number of hits for 24 hours starting from the current moment\\n  /// @return hitsLast24h Number of calls for the last 24 hours, decimals 18\\n  function _getHitsLast24h(uint biome, uint blockTimestamp) internal returns (uint hitsLast24h) {\\n    IReinforcementController.LastWindowsV2 memory stat24h = _S().stat24hV2[biome];\\n    (hitsLast24h, stat24h) = getHitsNumberPerLast24Hours(blockTimestamp, BASKET_INTERVAL, stat24h);\\n    _S().stat24hV2[biome] = stat24h; // save updated statistics for last 24 hours\\n  }\\n\\n  function _getReinforcementAttributes(IController controller, address heroToken, uint heroTokenId) internal view returns (\\n    int32[] memory attributes\\n  ) {\\n    IStatController sc = IStatController(controller.statController());\\n    uint[] memory indexes = new uint[](12);\\n\\n    indexes[0] = uint(IStatController.ATTRIBUTES.STRENGTH);\\n    indexes[1] = uint(IStatController.ATTRIBUTES.DEXTERITY);\\n    indexes[2] = uint(IStatController.ATTRIBUTES.VITALITY);\\n    indexes[3] = uint(IStatController.ATTRIBUTES.ENERGY);\\n    indexes[4] = uint(IStatController.ATTRIBUTES.DAMAGE_MIN);\\n    indexes[5] = uint(IStatController.ATTRIBUTES.DAMAGE_MAX);\\n    indexes[6] = uint(IStatController.ATTRIBUTES.ATTACK_RATING);\\n    indexes[7] = uint(IStatController.ATTRIBUTES.DEFENSE);\\n    indexes[8] = uint(IStatController.ATTRIBUTES.BLOCK_RATING);\\n    indexes[9] = uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE);\\n    indexes[10] = uint(IStatController.ATTRIBUTES.COLD_RESISTANCE);\\n    indexes[11] = uint(IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE);\\n\\n    return _generateReinforcementAttributes(sc, indexes, heroToken, heroTokenId);\\n  }\\n\\n  /// @notice Claim all rewards from {_heroTokenRewards} to {recipient}, remove data from {_heroTokenRewards}\\n  function _claimAllTokenRewards(address heroToken, uint heroId, address recipient) internal {\\n    EnumerableMap.AddressToUintMap storage rewards = _S()._heroTokenRewards[heroToken.packNftId(heroId)];\\n    uint length = rewards.length();\\n    address[] memory tokens = new address[](length);\\n    for (uint i; i < length; ++i) {\\n      (address token, uint amount) = rewards.at(i);\\n      IERC20(token).transfer(recipient, amount);\\n      emit IApplicationEvents.ClaimedToken(heroToken, heroId, token, amount, recipient);\\n\\n      tokens[i] = token;\\n    }\\n\\n    // need to remove after the ordered reading for handle all elements, just remove the struct will not work coz contains mapping inside\\n    for (uint i; i < length; ++i) {\\n      rewards.remove(tokens[i]);\\n    }\\n  }\\n\\n  function _claimAllNftRewards(address heroToken, uint heroId, address recipient) internal {\\n    bytes32[] storage rewards = _S()._heroNftRewards[heroToken.packNftId(heroId)];\\n    uint length = rewards.length;\\n    for (uint i; i < length; ++i) {\\n      (address token, uint id) = rewards[i].unpackNftId();\\n      IERC721(token).safeTransferFrom(address(this), recipient, id);\\n      emit IApplicationEvents.ClaimedItem(heroToken, heroId, token, id, recipient);\\n    }\\n    // a simple array can be just deleted\\n    delete _S()._heroNftRewards[heroToken.packNftId(heroId)];\\n  }\\n\\n  /// @notice Claim last {countNft} NFTs and remove them from {_heroNftRewards}\\n  function _claimNftRewards(address heroToken, uint heroId, address recipient, uint countNft) internal {\\n    bytes32[] storage rewards = _S()._heroNftRewards[heroToken.packNftId(heroId)];\\n\\n    uint length = rewards.length;\\n    uint indexLastToDelete = countNft >= length\\n      ? 0\\n      : length - countNft;\\n\\n    while (length != indexLastToDelete) {\\n      (address token, uint id) = rewards[length - 1].unpackNftId();\\n      IERC721(token).safeTransferFrom(address(this), recipient, id);\\n      emit IApplicationEvents.ClaimedItem(heroToken, heroId, token, id, recipient);\\n      length--;\\n\\n      // if we are going to remove all items we can just delete all items at the end\\n      // otherwise we should pop the items one by one\\n      if (indexLastToDelete != 0) {\\n        rewards.pop();\\n      }\\n    }\\n\\n    if (length == 0) {\\n      delete _S()._heroNftRewards[heroToken.packNftId(heroId)];\\n    }\\n  }\\n\\n  function _generateReinforcementAttributes(IStatController sc, uint[] memory indexes, address heroToken, uint heroId)\\n  internal view returns (int32[] memory attributes) {\\n    attributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < indexes.length; ++i) {\\n      attributes[indexes[i]] = CalcLib.max32(sc.heroAttribute(heroToken, heroId, indexes[i]) * _ATTRIBUTES_RATIO / 100, 1);\\n    }\\n  }\\n  //endregion ------------------------ Internal logic\\n\\n  //region ------------------------ Fixed fee calculation V2\\n\\n  /// @notice hitsLast24h Number of hits per last 24 hours, decimals 18\\n  function _getFeeAmount(address gameToken, uint hitsLast24h, uint8 biome) internal view returns (uint) {\\n\\n    // get min-max range for the burn fee\\n    (uint32 minNumberHits, uint32 maxNumberHits, uint32 lowDivider, uint32 highDivider,) = getConfigV2();\\n    uint min = 1e18 * uint(minNumberHits);\\n    uint max = 1e18 * uint(maxNumberHits);\\n\\n    // get max amount of the fee using original minter.amountForDungeon\\n    // we should pass heroBiome EXACTLY same to dungeonBiomeLevel\\n    // to avoid reducing base because of the difference heroBiome and dungeonBiomeLevel, see {amountForDungeon}\\n    IMinter minter = IMinter(IGameToken(gameToken).minter());\\n    uint amountForDungeon = minter.amountForDungeon(biome, biome) * 10;\\n\\n    // calculate fee\\n    if (hitsLast24h < min) hitsLast24h = min;\\n    if (hitsLast24h > max) hitsLast24h = max;\\n\\n    uint f = 1e18 * (hitsLast24h - min) / (max - min);\\n    return amountForDungeon / lowDivider + f * (amountForDungeon / highDivider - amountForDungeon / lowDivider) / 1e18;\\n  }\\n\\n  /// @notice Process the next call of askHeroV2\\n  /// @return hitsLast24h Number of askHeroV2-calls for last 24 hours, decimals 18\\n  /// @return dest Updated last-24hours-window-statistics to be stored in the storage\\n  function getHitsNumberPerLast24Hours(\\n    uint blockTimestamp,\\n    uint basketInterval,\\n    IReinforcementController.LastWindowsV2 memory s\\n  ) internal pure returns (\\n    uint hitsLast24h,\\n    IReinforcementController.LastWindowsV2 memory dest\\n  ) {\\n    uint countBaskets = 24 / basketInterval;\\n    uint hour = blockTimestamp / 60 / 60;\\n\\n    // get absolute index of basket for the current hour\\n    uint targetBasketIndex = hour / basketInterval;\\n\\n    if (s.basketIndex == targetBasketIndex) {\\n      // current basket is not changed, increase the counter\\n      if (s.basketValue < type(uint24).max) {\\n        s.basketValue++;\\n      }\\n    } else {\\n      // current basket is changed\\n      // save value of previous basket to {baskets} and start counting from the zero\\n      s.baskets[s.basketIndex % countBaskets] = s.basketValue;\\n\\n      // clear outdated baskets if some baskets were skipped (users didn't make any actions too long)\\n      if (targetBasketIndex >= s.basketIndex + countBaskets) {\\n        for (uint i; i < countBaskets; ++i) {\\n          s.baskets[i] = 0;\\n        }\\n      } else {\\n        for (uint i = s.basketIndex + 1; i < targetBasketIndex; ++i) {\\n          s.baskets[i % countBaskets] = 0;\\n        }\\n      }\\n\\n      s.basketValue = 1;\\n      s.basketIndex = uint48(targetBasketIndex);\\n    }\\n\\n    // calculate sum for last 24 hours\\n    uint m = 1e18 * (blockTimestamp - targetBasketIndex * basketInterval * 60 * 60) / (basketInterval * 60 * 60);\\n    uint bi = s.basketIndex % countBaskets;\\n    for (uint i; i < countBaskets; ++i) {\\n      if (i == bi) {\\n        hitsLast24h += uint(s.baskets[i]) * (1e18 - m) + m * uint(s.basketValue);\\n      } else {\\n        hitsLast24h += uint(s.baskets[i]) * 1e18;\\n      }\\n    }\\n\\n    return (hitsLast24h, s);\\n  }\\n  //endregion ------------------------ Fixed fee calculation V2\\n\\n  //region ------------------------ Common utils\\n  /// @return heroOwner Return token owner or zero address if the hero token is burnt\\n  function getHeroTokenOwnerSafe(address heroToken, uint heroTokenId) internal view returns (address heroOwner) {\\n    if (heroToken == address(0) || heroTokenId == 0) return address(0);\\n\\n    try IERC721(heroToken).ownerOf(heroTokenId) returns (address owner) {\\n      // there is a chance that the hero token is already burnt\\n      // so, we cannot call {ownerOf} without try/catch\\n      heroOwner = owner;\\n    } catch {}\\n\\n    return heroOwner;\\n  }\\n  //endregion ------------------------ Common utils\\n}\\n\",\"keccak256\":\"0xb9842eb03ad69074910137f51d2650128bc1b3c4001a6261b8222e33cd90ea91\",\"license\":\"BUSL-1.1\"},\"contracts/lib/RewardsPoolLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IGameToken.sol\\\";\\nimport \\\"../interfaces/IRewardsPool.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../proxy/Controllable.sol\\\";\\n\\nlibrary RewardsPoolLib {\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"rewards.pool.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant REWARDS_POOL_STORAGE_LOCATION = 0x6ad655e44097c54b487e7c9215cc0bbf37bbe7fc2f8034e2ddf6749036fda500; // rewards.pool.main\\n\\n  //region ------------------------ Storage\\n\\n  function _S() internal pure returns (IRewardsPool.MainState storage s) {\\n    assembly {\\n      s.slot := REWARDS_POOL_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n  //endregion ------------------------ Storage\\n\\n  //region ------------------------ Restrictions\\n  function onlyHeroController(IController controller) internal view {\\n    if (controller.heroController() != msg.sender) revert IAppErrors.ErrorNotHeroController(msg.sender);\\n  }\\n\\n  function _onlyDeployer(IController controller) internal view {\\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n\\n  function _onlyGovernance(IController controller) internal view {\\n    if (controller.governance() != msg.sender) revert IAppErrors.NotGovernance(msg.sender);\\n  }\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ View\\n  function balanceOfToken(address token) internal view returns (uint) {\\n    return IERC20(token).balanceOf(address(this));\\n  }\\n\\n  function baseAmount(address token) internal view returns (uint) {\\n    return _S().baseAmounts[token];\\n  }\\n\\n  /// @param maxBiome Max available biome, see {IDungeonFactory.state.maxBiome}\\n  /// @param maxNgLevel Max opened NG_LEVEL, see {IHeroController.state.maxOpenedNgLevel}\\n  /// @param biome Current hero biome [0..19\\n  /// @param heroNgLevel Current hero NG_LVL [0..99]\\n  /// @return Reward percent, decimals 18\\n  function rewardPercent(uint maxBiome, uint maxNgLevel, uint biome, uint heroNgLevel) internal pure returns (uint) {\\n    // biome_sum = max biome*(max biome+1)/2\\n    // biome_weight = biome / biome_sum\\n    // reward_percent = biome_weight * (1 + NG_LVL) / ng_sum\\n    return  1e18 * biome * (1 + heroNgLevel)\\n      / (maxBiome * (maxBiome + 1) / 2) // biome_sum\\n      / getNgSum(maxNgLevel);\\n  }\\n\\n  /// @notice be definition  ng_sum  = (max_ng + 1) * (max_ng+2) / 2\\n  function getNgSum(uint maxNgLevel) internal pure returns (uint) {\\n    return ((maxNgLevel + 1) * (maxNgLevel + 2) / 2);\\n  }\\n\\n  function rewardAmount(address token, uint maxBiome, uint maxNgLevel, uint biome, uint heroNgLevel) internal view returns (uint) {\\n    return baseAmount(token) * rewardPercent(maxBiome, maxNgLevel, biome, heroNgLevel) / 1e18;\\n  }\\n\\n  /// @notice Calculate lost profit amount in percents in the case when hero is created on {heroNgLevel} > 0\\n  /// @param maxBiome Max available biome, see {IDungeonFactory.state.maxBiome}\\n  /// @param maxNgLevel Max opened NG_LEVEL, see {IHeroController.state.maxOpenedNgLevel}\\n  /// @param heroNgLevel NG_LVL [1..99] where the hero is created, assume heroNgLevel > 0\\n  /// @return Lost reward percent, decimals 18\\n  function lostProfitPercent(uint maxBiome, uint maxNgLevel, uint heroNgLevel) internal pure returns (uint) {\\n    uint percent;\\n    for (uint8 ngLevel = 0; ngLevel < heroNgLevel; ++ngLevel) {\\n      percent += totalProfitOnLevel(maxBiome, maxNgLevel, ngLevel);\\n    }\\n    return percent;\\n  }\\n\\n  /// @notice SCR-1064: Calculate a percent to reduce drop chance of the monsters on various NG-levels.\\n  /// The percent is reverse to the percent of the rewards.\\n  /// @param maxBiome Max available biome, see {IDungeonFactory.state.maxBiome}\\n  /// @param maxNgLevel Max opened NG_LEVEL, see {IHeroController.state.maxOpenedNgLevel}\\n  /// @param heroNgLevel NG_LVL [1..99] where the hero is created, assume heroNgLevel > 0\\n  /// @return Drop chance percent, decimals 18\\n  function dropChancePercent(uint maxBiome, uint maxNgLevel, uint heroNgLevel) internal pure returns (uint) {\\n    if (heroNgLevel == 0) return 1e18; // NG0 is special case - drop is NOT reduced\\n\\n    return heroNgLevel > maxNgLevel\\n      ? 0\\n      : totalProfitOnLevel(maxBiome, maxNgLevel, maxNgLevel - heroNgLevel + 1);\\n  }\\n\\n  /// @notice Calculate total percent of rewards in all biomes on the given {ngLevel}\\n  function totalProfitOnLevel(uint maxBiome, uint maxNgLevel, uint ngLevel) internal pure returns (uint percent) {\\n    for (uint8 biome = 1; biome <= maxBiome; ++biome) {\\n      percent += rewardPercent(maxBiome, maxNgLevel, biome, ngLevel);\\n    }\\n    return percent;\\n  }\\n  //endregion ------------------------ View\\n\\n  //region ------------------------ Gov actions\\n  function setBaseAmount(IController controller, address token, uint baseAmount_) internal {\\n    _onlyDeployer(controller);\\n\\n    emit IApplicationEvents.BaseAmountChanged(_S().baseAmounts[token], baseAmount_);\\n    _S().baseAmounts[token] = baseAmount_;\\n  }\\n\\n  function withdraw(IController controller, address token, uint amount, address receiver) internal {\\n    _onlyGovernance(controller);\\n\\n    IERC20(token).transfer(receiver, amount);\\n  }\\n  //endregion ------------------------ Gov actions\\n\\n  //region ------------------------ Logic\\n  /// @notice Send {amount} of the {token} to the {dungeon}\\n  /// @dev Assume here that all calculations and checks are made on dungeonFactory-side\\n  function sendReward(IController controller, address token, uint rewardAmount_, address receiver) internal {\\n    onlyHeroController(controller);\\n\\n    uint balance = IERC20(token).balanceOf(address(this));\\n    if (balance >= rewardAmount_) {\\n      IERC20(token).transfer(receiver, rewardAmount_);\\n      emit IApplicationEvents.RewardSentToUser(receiver, token, rewardAmount_);\\n    } else {\\n      // there is not enough amount on reward pool balance\\n      // just register reward in events\\n      // assume that the reward should be paid to the receiver later manually\\n      emit IApplicationEvents.NotEnoughReward(receiver, token, rewardAmount_);\\n    }\\n  }\\n\\n  //endregion ------------------------ Logic\\n\\n}\\n\",\"keccak256\":\"0x7247419aeb0a36bc2bd0b51ccdadff8ba5eb3b78aa5e3260f8b5815cd602aa33\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ScoreLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\n\\nlibrary ScoreLib {\\n  using CalcLib for int32;\\n\\n  // core\\n  uint public constant STRENGTH = 100;\\n  uint public constant DEXTERITY = 100;\\n  uint public constant VITALITY = 100;\\n  uint public constant ENERGY = 100;\\n\\n  // attributes\\n  uint public constant MELEE_DAMAGE = 10;\\n  uint public constant ATTACK_RATING = 3;\\n  uint public constant DEFENCE = 10;\\n  uint public constant BLOCK_RATING = 500;\\n  uint public constant LIFE = 10;\\n  uint public constant MANA = 10;\\n\\n  uint public constant LIFE_CHANCES = 10_000;\\n  uint public constant MAGIC_FIND = 300;\\n  uint public constant CRITICAL_HIT = 150;\\n  uint public constant DMG_FACTOR = 200;\\n\\n  uint public constant AR_FACTOR = 200;\\n  uint public constant LIFE_STOLEN_PER_HIT = 1000;\\n  uint public constant MANA_AFTER_KILL = 1000;\\n  uint public constant DAMAGE_REDUCTION = 500;\\n  uint public constant REFLECT_DAMAGE = 250;\\n  uint public constant RESIST_TO_STATUSES = 70;\\n\\n  // resistance\\n  uint public constant ELEMENT_RESIST = 100;\\n\\n  // race specific attributes\\n  uint public constant RACE_SPECIFIC = 20;\\n\\n  // statuses\\n  uint public constant STATUSES = 100;\\n\\n  // items\\n  uint public constant DURABILITY_SCORE = 1;\\n\\n  // hero\\n  uint public constant HERO_LEVEL_SCORE = 1000;\\n\\n  /// @param isForReinforcement If true calculate score using 12 main attributes only. Otherwise use all attributes.\\n  function attributesScore(int32[] memory attributes, bool isForReinforcement) internal pure returns (uint) {\\n    uint result;\\n    {\\n      result += (attributes[uint(IStatController.ATTRIBUTES.STRENGTH)]).toUint() * STRENGTH\\n        + (attributes[uint(IStatController.ATTRIBUTES.DEXTERITY)]).toUint() * DEXTERITY\\n        + (attributes[uint(IStatController.ATTRIBUTES.VITALITY)]).toUint() * VITALITY\\n        + (attributes[uint(IStatController.ATTRIBUTES.ENERGY)]).toUint() * ENERGY\\n        + (attributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)]).toUint() * ATTACK_RATING\\n        + (attributes[uint(IStatController.ATTRIBUTES.DEFENSE)]).toUint() * DEFENCE\\n        + (attributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)]).toUint() * BLOCK_RATING\\n        + Math.average(attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)].toUint(), attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)].toUint()) * MELEE_DAMAGE\\n      ;\\n    }\\n    {\\n      result +=\\n        (attributes[uint(IStatController.ATTRIBUTES.FIRE_RESISTANCE)]).toUint() * ELEMENT_RESIST\\n        + (attributes[uint(IStatController.ATTRIBUTES.COLD_RESISTANCE)]).toUint() * ELEMENT_RESIST\\n        + (attributes[uint(IStatController.ATTRIBUTES.LIGHTNING_RESISTANCE)]).toUint() * ELEMENT_RESIST;\\n    }\\n\\n    if (! isForReinforcement) {\\n      {\\n        result +=\\n          (attributes[uint(IStatController.ATTRIBUTES.LIFE)]).toUint() * LIFE\\n          + (attributes[uint(IStatController.ATTRIBUTES.MANA)]).toUint() * MANA;\\n      }\\n      {\\n        result +=\\n          (attributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_HUMAN)]).toUint() * RACE_SPECIFIC\\n          + (attributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_UNDEAD)]).toUint() * RACE_SPECIFIC\\n          + (attributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_DAEMON)]).toUint() * RACE_SPECIFIC\\n          + (attributes[uint(IStatController.ATTRIBUTES.DMG_AGAINST_BEAST)]).toUint() * RACE_SPECIFIC\\n          + (attributes[uint(IStatController.ATTRIBUTES.DEF_AGAINST_HUMAN)]).toUint() * RACE_SPECIFIC\\n          + (attributes[uint(IStatController.ATTRIBUTES.DEF_AGAINST_UNDEAD)]).toUint() * RACE_SPECIFIC\\n          + (attributes[uint(IStatController.ATTRIBUTES.DEF_AGAINST_DAEMON)]).toUint() * RACE_SPECIFIC\\n          + (attributes[uint(IStatController.ATTRIBUTES.DEF_AGAINST_BEAST)]).toUint() * RACE_SPECIFIC;\\n      }\\n      {\\n        result +=\\n          (attributes[uint(IStatController.ATTRIBUTES.STUN)]).toUint() * STATUSES\\n          + (attributes[uint(IStatController.ATTRIBUTES.BURN)]).toUint() * STATUSES\\n          + (attributes[uint(IStatController.ATTRIBUTES.FREEZE)]).toUint() * STATUSES\\n          + (attributes[uint(IStatController.ATTRIBUTES.CONFUSE)]).toUint() * STATUSES\\n          + (attributes[uint(IStatController.ATTRIBUTES.CURSE)]).toUint() * STATUSES\\n          + (attributes[uint(IStatController.ATTRIBUTES.POISON)]).toUint() * STATUSES;\\n      }\\n      {\\n        result +=\\n          (attributes[uint(IStatController.ATTRIBUTES.LIFE_CHANCES)]).toUint() * LIFE_CHANCES\\n          + (attributes[uint(IStatController.ATTRIBUTES.MAGIC_FIND)]).toUint() * MAGIC_FIND\\n          + (attributes[uint(IStatController.ATTRIBUTES.CRITICAL_HIT)]).toUint() * CRITICAL_HIT\\n          + (attributes[uint(IStatController.ATTRIBUTES.MELEE_DMG_FACTOR)]).toUint() * DMG_FACTOR\\n          + (attributes[uint(IStatController.ATTRIBUTES.FIRE_DMG_FACTOR)]).toUint() * DMG_FACTOR\\n          + (attributes[uint(IStatController.ATTRIBUTES.COLD_DMG_FACTOR)]).toUint() * DMG_FACTOR\\n          + (attributes[uint(IStatController.ATTRIBUTES.LIGHTNING_DMG_FACTOR)]).toUint() * DMG_FACTOR;\\n      }\\n      {\\n        result +=\\n          (attributes[uint(IStatController.ATTRIBUTES.AR_FACTOR)]).toUint() * AR_FACTOR\\n          + (attributes[uint(IStatController.ATTRIBUTES.LIFE_STOLEN_PER_HIT)]).toUint() * LIFE_STOLEN_PER_HIT\\n          + (attributes[uint(IStatController.ATTRIBUTES.MANA_AFTER_KILL)]).toUint() * MANA_AFTER_KILL\\n          + (attributes[uint(IStatController.ATTRIBUTES.DAMAGE_REDUCTION)]).toUint() * DAMAGE_REDUCTION\\n          + (attributes[uint(IStatController.ATTRIBUTES.REFLECT_DAMAGE_MELEE)]).toUint() * REFLECT_DAMAGE\\n          + (attributes[uint(IStatController.ATTRIBUTES.REFLECT_DAMAGE_MAGIC)]).toUint() * REFLECT_DAMAGE\\n          + (attributes[uint(IStatController.ATTRIBUTES.RESIST_TO_STATUSES)]).toUint() * RESIST_TO_STATUSES;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  function itemScore(int32[] memory attributes, uint16 baseDurability) internal pure returns (uint) {\\n    return attributesScore(attributes, false) + baseDurability * DURABILITY_SCORE;\\n  }\\n\\n  function heroScore(int32[] memory attributes, uint level) internal pure returns (uint) {\\n    return attributesScore(attributes, true) + level * HERO_LEVEL_SCORE;\\n  }\\n\\n}\\n\",\"keccak256\":\"0x9d06dbef4c287c46ba6699a46cb1d528962a0b75c0a6345ed7f7dfe462a519c4\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ShelterLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../interfaces/IShelterController.sol\\\";\\nimport \\\"../interfaces/IShelterController.sol\\\";\\nimport \\\"../interfaces/IUserController.sol\\\";\\nimport \\\"../lib/StringLib.sol\\\";\\nimport \\\"../token/GuildBank.sol\\\";\\nimport \\\"./StatLib.sol\\\";\\nimport \\\"../interfaces/IShelterAuction.sol\\\";\\n\\nlibrary ShelterLib {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using EnumerableSet for EnumerableSet.UintSet;\\n\\n  //region ------------------------ Constants\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"shelter.controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant SHELTER_CONTROLLER_STORAGE_LOCATION = 0x5a293071b39954a4fcf98ae7184af7c6201e972e15842b884f1ad071e9bded00; // shelter.controller.main\\n\\n  uint8 internal constant MIN_SHELTER_LEVEL = 1;\\n  uint8 internal constant MAX_SHELTER_LEVEL = 3;\\n  //endregion ------------------------ Constants\\n\\n  //region ------------------------ Restrictions\\n  function _onlyDeployer(IController controller) internal view {\\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n\\n  function _onlyGuildController(address guildController) internal view {\\n    if (msg.sender != guildController) revert IAppErrors.ErrorNotGuildController();\\n  }\\n\\n  function _notPaused(IController controller) internal view {\\n    if (controller.onPause()) revert IAppErrors.ErrorPaused();\\n  }\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ Storage\\n\\n  function _S() internal pure returns (IShelterController.MainState storage s) {\\n    assembly {\\n      s.slot := SHELTER_CONTROLLER_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n  //endregion ------------------------ Storage\\n\\n  //region ------------------------ Shelter view\\n  /// @notice Get list of all registered shelters in the given {biome}\\n  function getShelters(uint8 biome) internal view returns (uint[] memory shelterIds) {\\n    return _S().shelters[biome].values();\\n  }\\n\\n  /// @notice Get initial price of the given shelter. The price is used if the shelter doesn't belong to any guild\\n  function getShelterPrice(uint shelterId) internal view returns (uint price) {\\n    return _S().shelterPrices[shelterId];\\n  }\\n\\n  /// @notice Get shelter which belongs to the given guild\\n  function guildToShelter(uint guildId) internal view returns (uint shelterId) {\\n    return _S().guildToShelter[guildId];\\n  }\\n\\n  /// @notice Get guild to which the given shelter belongs\\n  function shelterToGuild(uint shelterId) internal view returns (uint guildId) {\\n    return _S().shelterToGuild[shelterId];\\n  }\\n\\n  /// @notice Get shelter of the guild to which the user belongs\\n  function getShelterId(IGuildController guildController, address user) internal view returns (uint shelterId) {\\n    uint guildId = guildController.memberOf(user);\\n    return guildId == 0\\n      ? 0\\n      : _S().guildToShelter[guildId];\\n  }\\n\\n  /// @notice List of items that can be bought in the shelter of the given level in the given biome\\n  function getShelterItems(uint shelterId) internal view returns (address[] memory items) {\\n    return _S().shelterItems[shelterId].values();\\n  }\\n\\n  function getShelterItemData(uint shelterId, address item) internal view returns (\\n    uint64 priceInPvpPoints,\\n    uint128 priceInGameToken,\\n    uint16 maxItemsPerDayLimit\\n  ) {\\n    IShelterController.ShelterItemData memory data = _S().shelterItemData[shelterId][item];\\n    return (\\n      data.priceInPvpPoints,\\n      data.priceInGameToken,\\n      data.maxItemsPerDayLimit\\n    );\\n  }\\n\\n  /// @notice How many {item} instances were purchased per {epochDay} in the given {shelterId}\\n  /// @param epochDay TimestampInSeconds / 24 * 60 * 60\\n  function getCountPurchasedItems(address item, uint shelterId, uint32 epochDay) internal view returns (uint) {\\n    return _S().countPurchasedItems[shelterId][epochDay][item];\\n  }\\n\\n  //endregion ------------------------ Shelter view\\n\\n  //region ------------------------ Shelter config\\n  /// @notice Register new shelter or overwrite exist. Only registered shelters can be purchased.\\n  /// @param shelterId ID should be generated using {PackingLib.packShelterId}\\n  /// @param price Initial shelter price in game tokens\\n  function setShelter(IController controller, uint shelterId, uint price) internal {\\n    ShelterLib._onlyDeployer(controller);\\n\\n    (uint8 biome, uint8 shelterLevel, ) = PackingLib.unpackShelterId(shelterId);\\n\\n    if (biome == 0 || biome > StatLib.MAX_POSSIBLE_BIOME) revert IAppErrors.ErrorIncorrectBiome(biome);\\n    if (price == 0) revert IAppErrors.ZeroValueNotAllowed();\\n    if (shelterLevel < MIN_SHELTER_LEVEL || shelterLevel > MAX_SHELTER_LEVEL) revert IAppErrors.IncorrectShelterLevel(shelterLevel);\\n\\n    _S().shelterPrices[shelterId] = price;\\n    _S().shelters[biome].add(shelterId);\\n\\n    emit IApplicationEvents.RegisterShelter(shelterId, price);\\n  }\\n\\n  /// @notice Set items that can be purchases in the given shelter: remove previously stored items, add new items.\\n  /// @param shelterId ID should be generated using {PackingLib.packShelterId}\\n  /// @param items List of item tokens\\n  /// @param pricesInPvpPoints Prices in pvp-points. The points are taken from guild balance at the moment of purchasing\\n  /// @param pricesInGameTokens Additional prices in game tokens. Can contain zeros.\\n  /// @param maxItemsPerDayLimits Indicate how many item instances the users can purchase per day. 0 - no limitations\\n  function setShelterItems(\\n    IController controller,\\n    uint shelterId,\\n    address[] memory items,\\n    uint64[] memory pricesInPvpPoints,\\n    uint128[] memory pricesInGameTokens,\\n    uint16[] memory maxItemsPerDayLimits\\n  ) internal {\\n    ShelterLib._onlyDeployer(controller);\\n\\n    uint len = items.length;\\n    if (len != pricesInPvpPoints.length || len != pricesInGameTokens.length || len != maxItemsPerDayLimits.length) {\\n      revert IAppErrors.LengthsMismatch();\\n    }\\n\\n    EnumerableSet.AddressSet storage set = _S().shelterItems[shelterId];\\n\\n    // remove previously stored items\\n    address[] memory prevItems = set.values();\\n    uint prevItemsLen = prevItems.length;\\n    for (uint i; i < prevItemsLen; ++i) {\\n      set.remove(prevItems[i]);\\n      delete _S().shelterItemData[shelterId][prevItems[i]];\\n    }\\n\\n    // add new items\\n    for (uint i; i < len; ++i) {\\n      set.add(items[i]);\\n      if (pricesInPvpPoints[i] == 0 && pricesInGameTokens[i] == 0) revert IAppErrors.FreeShelterItemsAreNotAllowed(shelterId, items[i]);\\n      _S().shelterItemData[shelterId][items[i]] = IShelterController.ShelterItemData({\\n        priceInPvpPoints: pricesInPvpPoints[i],\\n        priceInGameToken: pricesInGameTokens[i],\\n        maxItemsPerDayLimit: maxItemsPerDayLimits[i]\\n      });\\n    }\\n\\n    emit IApplicationEvents.SetShelterItems(shelterId, items, pricesInPvpPoints, pricesInGameTokens, maxItemsPerDayLimits);\\n  }\\n  //endregion ------------------------ Shelter config\\n\\n  //region ------------------------ Shelter actions\\n\\n  /// @notice Guild buys a shelter that doesn't belong to any guild. It pays default prices and changes owner of the shelter.\\n  function buyShelter(IController controller, address msgSender, uint shelterId) internal {\\n    _notPaused(controller);\\n\\n    IGuildController guildController = IGuildController(controller.guildController());\\n    (uint guildId,) = guildController.checkPermissions(msgSender, uint(IGuildController.GuildRightBits.CHANGE_SHELTER_3));\\n\\n    // only registered shelter can be purchased\\n    (uint8 biome, , ) = PackingLib.unpackShelterId(shelterId);\\n    if (!_S().shelters[biome].contains(shelterId)) revert IAppErrors.ShelterIsNotRegistered();\\n\\n    // Each guild is able to have only 1 shelter. Exist shelter should be sold or left\\n    if (_S().guildToShelter[guildId] != 0) revert IAppErrors.GuildAlreadyHasShelter();\\n    if (_S().shelterToGuild[shelterId] != 0) revert IAppErrors.ShelterIsBusy();\\n\\n    { // Shelter can be bought only if there is no auction bid\\n      address shelterAuction = guildController.shelterAuctionController();\\n      if (shelterAuction != address(0)) {\\n        (uint positionId,) = IShelterAuction(shelterAuction).positionByBuyer(guildId);\\n        if (positionId != 0) revert IAppErrors.AuctionBidOpened(positionId);\\n      }\\n    }\\n\\n    // pay for the shelter from the guild bank\\n    uint shelterPrice = getShelterPrice(shelterId);\\n    guildController.payFromGuildBank(guildId, shelterPrice);\\n\\n    // register ownership\\n    _S().guildToShelter[guildId] = shelterId;\\n    _S().shelterToGuild[shelterId] = guildId;\\n\\n    emit IApplicationEvents.BuyShelter(guildId, shelterId);\\n  }\\n\\n  /// @notice Guild leaves the shelter. The shelter becomes free, it can be bought by any guild by default price\\n  function leaveShelter(IController controller, address msgSender, uint shelterId) internal {\\n    _notPaused(controller);\\n\\n    IGuildController guildController = IGuildController(controller.guildController());\\n    (uint guildId,) = guildController.checkPermissions(msgSender, uint(IGuildController.GuildRightBits.CHANGE_SHELTER_3));\\n\\n    if (_S().guildToShelter[guildId] != shelterId) revert IAppErrors.ShelterIsNotOwnedByTheGuild();\\n    if (shelterId == 0) revert IAppErrors.GuildHasNoShelter();\\n\\n    { // Shelter can be sold only if there is no opened auction position\\n      address shelterAuction = guildController.shelterAuctionController();\\n      if (shelterAuction != address(0)) {\\n        uint positionId = IShelterAuction(shelterAuction).positionBySeller(guildId);\\n        if (positionId != 0) revert IAppErrors.AuctionPositionOpened(positionId);\\n      }\\n    }\\n\\n    // unregister ownership\\n    delete _S().guildToShelter[guildId];\\n    delete _S().shelterToGuild[shelterId];\\n\\n    emit IApplicationEvents.LeaveShelter(guildId, shelterId);\\n  }\\n\\n  /// @notice Purchase the {item} in the shelter that belongs to the guild to which {msgSender} belongs\\n  function purchaseShelterItem(IController controller, address msgSender, address item, uint blockTimestamp) internal {\\n    _notPaused(controller);\\n\\n    IGuildController guildController = IGuildController(controller.guildController());\\n    // no permission are required - any guild member is able to purchase shelter item\\n    // but the member should either be owner or should have enough pvp-points capacity, see restriction below\\n    uint guildId = _getValidGuildId(guildController, msgSender);\\n\\n    uint shelterId = _S().guildToShelter[guildId];\\n    if (shelterId == 0) revert IAppErrors.GuildHasNoShelter();\\n\\n    if (! _S().shelterItems[shelterId].contains(item)) revert IAppErrors.ShelterHasNotItem(shelterId, item);\\n\\n    // total number of the item instances that can be minted per day CAN BE limited\\n    IShelterController.ShelterItemData memory itemData = _S().shelterItemData[shelterId][item];\\n    uint numSoldItems;\\n    {\\n      uint32 epochDay = uint32(blockTimestamp / 86400);\\n\\n      mapping(address => uint) storage countPurchasedItems = _S().countPurchasedItems[shelterId][epochDay];\\n      numSoldItems = countPurchasedItems[item];\\n\\n      if (itemData.maxItemsPerDayLimit != 0) {\\n        if (numSoldItems >= itemData.maxItemsPerDayLimit) revert IAppErrors.MaxNumberItemsSoldToday(numSoldItems, itemData.maxItemsPerDayLimit);\\n      }\\n      countPurchasedItems[item] = numSoldItems + 1;\\n    }\\n\\n    // user pays for the item by pvp-points and/or by game token (it depends on the item settings)\\n    if (itemData.priceInPvpPoints != 0) {\\n      guildController.usePvpPoints(guildId, msgSender, itemData.priceInPvpPoints);\\n    }\\n\\n    if (itemData.priceInGameToken != 0) {\\n      guildController.payFromBalance(itemData.priceInGameToken, msgSender);\\n      //_process(controller, itemData.priceInGameToken, msgSender);\\n    }\\n\\n    // mint the item\\n    IItemController(controller.itemController()).mint(item, msgSender);\\n\\n    emit IApplicationEvents.PurchaseShelterItem(msgSender, item, numSoldItems + 1, itemData.priceInPvpPoints, itemData.priceInGameToken);\\n  }\\n\\n  /// @notice clear necessary data to indicate that the guiles leaves the shelter\\n  function clearShelter(address guildController, uint guildId) internal {\\n    _onlyGuildController(guildController);\\n\\n    uint shelterId = _S().guildToShelter[guildId];\\n    if (shelterId != 0) {\\n      // assume, that msgSender shouldn't have permission CHANGE_SHELTER_3 here\\n\\n      // ensure that there is no open position for the shelter on auction\\n      address shelterAuction = IGuildController(guildController).shelterAuctionController();\\n      if (shelterAuction != address(0)) {\\n        uint positionId = IShelterAuction(shelterAuction).positionBySeller(guildId);\\n        if (positionId != 0) revert IAppErrors.AuctionPositionOpened(positionId);\\n      }\\n\\n      delete _S().guildToShelter[guildId];\\n      delete _S().shelterToGuild[shelterId];\\n\\n      emit IApplicationEvents.LeaveShelter(guildId, shelterId);\\n    }\\n\\n  }\\n  //endregion ------------------------ Shelter actions\\n\\n  //region ------------------------ Interaction with auctions\\n  function changeShelterOwner(IController controller, uint shelterId, uint newOwnerGuildId) internal {\\n    // we assume, that all checks are performed on ShelterAuction side, so we need min checks here\\n    address shelterAuction = IGuildController(controller.guildController()).shelterAuctionController();\\n    if (shelterAuction == address(0) || msg.sender != shelterAuction) revert IAppErrors.NotShelterAuction();\\n\\n    uint prevGuildId = _S().shelterToGuild[shelterId];\\n    delete _S().guildToShelter[prevGuildId];\\n    _S().shelterToGuild[shelterId] = newOwnerGuildId;\\n    _S().guildToShelter[newOwnerGuildId] = shelterId;\\n\\n    emit IApplicationEvents.ChangeShelterOwner(shelterId, prevGuildId, newOwnerGuildId);\\n  }\\n\\n  //endregion ------------------------ Interaction with auctions\\n\\n  //region ------------------------ Internal logic\\n  function _getValidGuildId(IGuildController guildController, address user) internal view returns (uint guildId) {\\n    guildId = guildController.memberOf(user);\\n    if (guildId == 0) revert IAppErrors.NotGuildMember();\\n  }\\n  //endregion ------------------------ Internal logic\\n\\n\\n}\\n\",\"keccak256\":\"0xcd3dc6a4f1cd3e8f9b6fd495b022db5d28a40095a069478b46d6d9f1378b9490\",\"license\":\"BUSL-1.1\"},\"contracts/lib/SlotsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\\n/// @author bogdoslav\\nlibrary SlotsLib {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant SLOT_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  // ************* GETTERS *******************\\n\\n  /// @dev Gets a slot as bytes32\\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as an address\\n  function getAddress(bytes32 slot) internal view returns (address result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as uint256\\n  function getUint(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  // ************* ARRAY GETTERS *******************\\n\\n  /// @dev Gets an array length\\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  // ************* SETTERS *******************\\n\\n  /// @dev Sets a slot with bytes32\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, bytes32 value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with address\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, address value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with uint\\n  function set(bytes32 slot, uint value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x52ede981a6bb509c0dce07a0373e3c073c24fd16ca4ca7fbaa24f6c8b747b45b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StatLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\n\\nlibrary StatLib {\\n  using PackingLib for bytes32[];\\n  using PackingLib for bytes32;\\n  using PackingLib for uint32[];\\n  using PackingLib for int32[];\\n  using CalcLib for int32;\\n\\n  //region --------------------------- Constants\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant STAT_LIB_VERSION = \\\"1.0.0\\\";\\n  uint32 public constant MAX_LEVEL = 99;\\n\\n  uint public constant BASE_EXPERIENCE = 100_000;\\n  uint public constant BIOME_LEVEL_STEP = 5;\\n  uint internal constant _MAX_AMPLIFIER = 1e18;\\n  uint private constant _PRECISION = 1e18;\\n  uint private constant VIRTUAL_LEVEL_GAP = 2;\\n\\n  /// @dev Assume MAX_BIOME * BIOME_LEVEL_STEP < MAX_LEVEL + 1, see dungeonTreasuryReward\\n  uint public constant MAX_POSSIBLE_BIOME = 19;\\n  //endregion --------------------------- Constants\\n\\n  //region --------------------------- Data types\\n\\n  struct BaseMultiplier {\\n    uint minDamage;\\n    uint maxDamage;\\n    uint attackRating;\\n    uint defense;\\n    uint blockRating;\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct LevelUp {\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct InitialHero {\\n    IStatController.CoreAttributes core;\\n    BaseMultiplier multiplier;\\n    LevelUp levelUp;\\n    int32 baseLifeChances;\\n  }\\n\\n  enum HeroClasses {\\n    UNKNOWN,\\n    THRALL,\\n    SAVAGE,\\n    MAGE,\\n    ASSASSIN,\\n    GHOST,\\n    HAMMERGINA,\\n    END_SLOT\\n  }\\n  //endregion --------------------------- Data types\\n\\n  //region --------------------------- BASE\\n\\n  function isNetworkWithOldSavage() public view returns (bool) {\\n    return block.chainid == uint(111188) || block.chainid == uint(250);\\n  }\\n\\n  // --- HERO 1 (Slave) ---\\n\\n  function initialHero1() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 15,\\n      vitality: 30,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 2e18,\\n      blockRating: 0.1e18,\\n      life: 1.5e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 2e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 2 (Spata) ---\\n\\n  function initialHero2() internal view returns (InitialHero memory) {\\n\\n    bool old = isNetworkWithOldSavage();\\n\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 30,\\n      dexterity: 5,\\n      vitality: 25,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: old ? 0.25e18 : 0.5e18,\\n      attackRating: old ? 2e18 : 3e18,\\n      defense: 1e18,\\n      blockRating: 0.08e18,\\n      life: 1.3e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.8e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 3 (Decidia) ---\\n\\n  function initialHero3() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 10,\\n      dexterity: 15,\\n      vitality: 20,\\n      energy: 25\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 1e18,\\n      blockRating: 0.1e18,\\n      life: 1e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.3e18,\\n      mana: 2e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 4 (Innatus) ---\\n\\n  function initialHero4() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 25,\\n      vitality: 15,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 4e18,\\n      defense: 3e18,\\n      blockRating: 0.2e18,\\n      life: 1.2e18,\\n      mana: 1e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 5 (F2P) ---\\n\\n  function initialHero5() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 20,\\n      dexterity: 20,\\n      vitality: 20,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: 0.25e18,\\n      attackRating: 3e18,\\n      defense: 2.5e18,\\n      blockRating: 0.15e18,\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // --- HERO 6 (F2P) HAMMERGINA ---\\n\\n  function initialHero6() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 50,\\n      dexterity: 30,\\n      vitality: 50,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.2e18,\\n      maxDamage: 0.3e18,\\n      attackRating: 5e18,\\n      defense: 3e18,\\n      blockRating: 0.15e18,\\n      life: 2e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // ------\\n\\n  function initialHero(uint heroClass) internal view returns (InitialHero memory) {\\n    if (heroClass == 1) {\\n      return initialHero1();\\n    } else if (heroClass == 2) {\\n      return initialHero2();\\n    } else if (heroClass == 3) {\\n      return initialHero3();\\n    } else if (heroClass == 4) {\\n      return initialHero4();\\n    } else if (heroClass == 5) {\\n      return initialHero5();\\n    } else if (heroClass == 6) {\\n      return initialHero6();\\n    } else {\\n      revert IAppErrors.UnknownHeroClass(heroClass);\\n    }\\n  }\\n  //endregion --------------------------- BASE\\n\\n  //region --------------------------- CALCULATIONS\\n\\n  function minDamage(int32 strength, uint heroClass) internal view returns (int32) {\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.minDamage / _PRECISION));\\n  }\\n\\n  function maxDamage(int32 strength, uint heroClass) internal view returns (int32){\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.maxDamage / _PRECISION));\\n  }\\n\\n  function attackRating(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.attackRating / _PRECISION));\\n  }\\n\\n  function defense(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.defense / _PRECISION));\\n  }\\n\\n  function blockRating(int32 dexterity, uint heroClass) internal view returns (int32){\\n    return int32(int(Math.min((dexterity.toUint() * initialHero(heroClass).multiplier.blockRating / _PRECISION), 75)));\\n  }\\n\\n  function life(int32 vitality, uint heroClass, uint32 level) internal view returns (int32){\\n    return int32(int(\\n      (vitality.toUint() * initialHero(heroClass).multiplier.life / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.life / _PRECISION)\\n    ));\\n  }\\n\\n  function mana(int32 energy, uint heroClass, uint32 level) internal view returns (int32){\\n    return int32(int(\\n      (energy.toUint() * initialHero(heroClass).multiplier.mana / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.mana / _PRECISION)\\n    ));\\n  }\\n\\n  function lifeChances(uint heroClass, uint32 /*level*/) internal view returns (int32){\\n    return initialHero(heroClass).baseLifeChances;\\n  }\\n\\n  function levelExperience(uint32 level) internal pure returns (uint32) {\\n    if (level == 0 || level >= MAX_LEVEL) {\\n      return 0;\\n    }\\n    return uint32(uint(level) * BASE_EXPERIENCE * (67e17 - CalcLib.log2((uint(MAX_LEVEL - level + 2)) * 1e18)) / 1e18);\\n  }\\n\\n  function chanceToHit(\\n    uint attackersAttackRating,\\n    uint defendersDefenceRating,\\n    uint attackersLevel,\\n    uint defendersLevel,\\n    uint arFactor\\n  ) internal pure returns (uint) {\\n    attackersAttackRating += attackersAttackRating * arFactor / 100;\\n    uint x = Math.max(attackersAttackRating, 1);\\n    uint y = Math.max(attackersAttackRating + defendersDefenceRating, 1);\\n    uint z = attackersLevel;\\n    uint k = defendersLevel / 2;\\n    uint xy = x * 1e18 / y;\\n    uint zk = z * 1e18 / (attackersLevel + k);\\n    uint base = 2 * xy * zk / 1e18;\\n    return Math.max(Math.min(base, 0.95e18), 0.2e18);\\n  }\\n\\n  function experienceToVirtualLevel(uint experience, uint startFromLevel) internal pure returns (uint level) {\\n    level = startFromLevel;\\n    for (; level < MAX_LEVEL;) {\\n      if (levelExperience(uint32(level)) >= (experience + 1)) {\\n        break;\\n      }\\n      unchecked{++level;}\\n    }\\n  }\\n\\n  function expPerMonster(uint32 monsterExp, uint monsterRarity, uint32 /*heroExp*/, uint32 /*heroCurrentLvl*/, uint /*monsterBiome*/) internal pure returns (uint32) {\\n    // do not reduce exp per level, it is no economical sense\\n    return uint32(uint(monsterExp) + uint(monsterExp) * monsterRarity / _MAX_AMPLIFIER);\\n  }\\n\\n  /// @notice Allow to calculate delta param for {mintDropChance}\\n  function mintDropChanceDelta(uint heroCurrentExp, uint heroCurrentLevel, uint monsterBiome) internal pure returns (uint) {\\n    uint heroBiome = getVirtualLevel(heroCurrentExp, heroCurrentLevel, true) / StatLib.BIOME_LEVEL_STEP + 1;\\n    return heroBiome > monsterBiome ? 2 ** (heroBiome - monsterBiome + 10) : 0;\\n  }\\n\\n  function getVirtualLevel(uint heroCurrentExp, uint heroCurrentLevel, bool withGap) internal pure returns (uint) {\\n    uint virtualLevel = StatLib.experienceToVirtualLevel(heroCurrentExp, heroCurrentLevel);\\n    if (withGap && (virtualLevel + 1) > VIRTUAL_LEVEL_GAP) {\\n      virtualLevel -= VIRTUAL_LEVEL_GAP;\\n    }\\n    return virtualLevel;\\n  }\\n\\n  function initAttributes(\\n    bytes32[] storage attributes,\\n    uint heroClass,\\n    uint32 level,\\n    IStatController.CoreAttributes memory base\\n  ) internal returns (uint32[] memory result) {\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.STRENGTH), base.strength);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEXTERITY), base.dexterity);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.VITALITY), base.vitality);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ENERGY), base.energy);\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN), minDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX), maxDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING), attackRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE), defense(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING), blockRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE), life(base.vitality, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA), mana(base.energy, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE_CHANCES), lifeChances(heroClass, level));\\n\\n    result = new uint32[](3);\\n    result[0] = uint32(life(base.vitality, heroClass, level).toUint());\\n    result[1] = uint32(mana(base.energy, heroClass, level).toUint());\\n    result[2] = uint32(lifeChances(heroClass, uint32(level)).toUint());\\n  }\\n\\n  function updateCoreDependAttributesInMemory(\\n    int32[] memory attributes,\\n    int32[] memory bonus,\\n    uint heroClass,\\n    uint32 level\\n  ) internal view returns (int32[] memory) {\\n    int32 strength = attributes[uint(IStatController.ATTRIBUTES.STRENGTH)];\\n    int32 dexterity = attributes[uint(IStatController.ATTRIBUTES.DEXTERITY)];\\n    int32 vitality = attributes[uint(IStatController.ATTRIBUTES.VITALITY)];\\n    int32 energy = attributes[uint(IStatController.ATTRIBUTES.ENERGY)];\\n\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] = minDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)];\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] = maxDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)];\\n    attributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] = attackRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.ATTACK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.DEFENSE)] = defense(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DEFENSE)];\\n    attributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] = blockRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.BLOCK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.LIFE)] = life(vitality, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.LIFE)];\\n    attributes[uint(IStatController.ATTRIBUTES.MANA)] = mana(energy, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.MANA)];\\n    return attributes;\\n  }\\n\\n  function updateCoreDependAttributes(\\n    bytes32[] storage attributes,\\n    bytes32[] storage bonusMain,\\n    bytes32[] storage bonusExtra,\\n    IStatController.ChangeableStats memory _heroStats,\\n    uint index,\\n    uint heroClass,\\n    int32 base\\n  ) internal {\\n    if (index == uint(IStatController.ATTRIBUTES.STRENGTH)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN),\\n        StatLib.minDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n      );\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX),\\n        StatLib.maxDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.DEXTERITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING),\\n        StatLib.attackRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE),\\n        StatLib.defense(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING),\\n        StatLib.blockRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.VITALITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE),\\n        StatLib.life(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.ENERGY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA),\\n        StatLib.mana(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n      );\\n    }\\n  }\\n\\n  function attributesAdd(int32[] memory base, int32[] memory add) internal pure returns (int32[] memory) {\\n    unchecked{\\n      for (uint i; i < base.length; ++i) {\\n        base[i] += add[i];\\n      }\\n    }\\n    return base;\\n  }\\n\\n// Currently this function is not used\\n//  function attributesRemove(int32[] memory base, int32[] memory remove) internal pure returns (int32[] memory) {\\n//    unchecked{\\n//      for (uint i; i < base.length; ++i) {\\n//        base[i] = CalcLib.minusWithMinFloorI32(base[i], remove[i]);\\n//      }\\n//    }\\n//    return base;\\n//  }\\n\\n  function packChangeableStats(IStatController.ChangeableStats memory stats) internal pure returns (bytes32) {\\n    uint32[] memory cData = new uint32[](5);\\n    cData[0] = stats.level;\\n    cData[1] = stats.experience;\\n    cData[2] = stats.life;\\n    cData[3] = stats.mana;\\n    cData[4] = stats.lifeChances;\\n\\n    return cData.packUint32Array();\\n  }\\n\\n  function unpackChangeableStats(bytes32 data) internal pure returns (IStatController.ChangeableStats memory result) {\\n    uint32[] memory cData = data.unpackUint32Array();\\n    return IStatController.ChangeableStats({\\n      level: cData[0],\\n      experience: cData[1],\\n      life: cData[2],\\n      mana: cData[3],\\n      lifeChances: cData[4]\\n    });\\n  }\\n\\n  function bytesToFullAttributesArray(bytes32[] memory attributes) internal pure returns (int32[] memory result) {\\n    (int32[] memory values, uint8[] memory ids) = attributes.toInt32ArrayWithIds();\\n    return valuesToFullAttributesArray(values, ids);\\n  }\\n\\n  function valuesToFullAttributesArray(int32[] memory values, uint8[] memory ids) internal pure returns (int32[] memory result) {\\n    result = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < values.length; ++i) {\\n      int32 value = values[i];\\n      if (value != 0) {\\n        result[ids[i]] = value;\\n      }\\n    }\\n  }\\n  //endregion --------------------------- CALCULATIONS\\n\\n}\\n\",\"keccak256\":\"0x582a05f0eab2a0d8b7d95e13626e959df6260d56f61735f995e420af7e9841bc\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StringLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n\\nlibrary StringLib {\\n\\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n  function toString(uint value) external pure returns (string memory) {\\n    return _toString(value);\\n  }\\n\\n  function _toString(uint value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint temp = value;\\n    uint digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  function toAsciiString(address x) external pure returns (string memory) {\\n    return _toAsciiString(x);\\n  }\\n\\n  function _toAsciiString(address x) internal pure returns (string memory) {\\n    bytes memory s = new bytes(40);\\n    for (uint i = 0; i < 20; i++) {\\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n      bytes1 hi = bytes1(uint8(b) / 16);\\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n      s[2 * i] = _char(hi);\\n      s[2 * i + 1] = _char(lo);\\n    }\\n    return string(s);\\n  }\\n\\n  function char(bytes1 b) external pure returns (bytes1 c) {\\n    return _char(b);\\n  }\\n\\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n    else return bytes1(uint8(b) + 0x57);\\n  }\\n\\n  function concat(string memory a, string memory b) internal pure returns (string memory) {\\n    return string(abi.encodePacked(a, b));\\n  }\\n\\n  function isASCIILettersOnly(string memory str) internal pure returns (bool) {\\n    bytes memory b = bytes(str);\\n    for (uint i = 0; i < b.length; i++) {\\n      if (uint8(b[i]) < 32 || uint8(b[i]) > 127) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\",\"keccak256\":\"0xcf94b1e6e63466d0100f5181a080968017995f5019a2cfdb35f1ae4a3b7dab3b\",\"license\":\"BUSL-1.1\"},\"contracts/openzeppelin/ERC721Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n  /**\\n   * @dev See {IERC721Receiver-onERC721Received}.\\n   *\\n   * Always returns `IERC721Receiver.onERC721Received.selector`.\\n   */\\n  function onERC721Received(\\n    address,\\n    address,\\n    uint256,\\n    bytes memory\\n  ) public virtual override returns (bytes4) {\\n    return this.onERC721Received.selector;\\n  }\\n}\\n\",\"keccak256\":\"0xaf4708e1efc6a96ca12406877a82d66ea4bc82b71b26e982a70b0ce8755d8eed\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  // To implement this library for multiple types with as little code repetition as possible, we write it in\\n  // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\\n  // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\\n  // This means that we can only create new EnumerableMaps for types that fit in bytes32.\\n\\n  /**\\n   * @dev Query for a nonexistent map key.\\n     */\\n  error EnumerableMapNonexistentKey(bytes32 key);\\n\\n  struct Bytes32ToBytes32Map {\\n    // Storage of keys\\n    EnumerableSet.Bytes32Set _keys;\\n    mapping(bytes32 key => bytes32) _values;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n    map._values[key] = value;\\n    return map._keys.add(key);\\n  }\\n\\n  /**\\n   * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n    delete map._values[key];\\n    return map._keys.remove(key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n    return map._keys.contains(key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n    return map._keys.length();\\n  }\\n\\n  /**\\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n    bytes32 key = map._keys.at(index);\\n    return (key, map._values[key]);\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == bytes32(0)) {\\n      return (contains(map, key), bytes32(0));\\n    } else {\\n      return (true, value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == 0 && !contains(map, key)) {\\n      revert EnumerableMapNonexistentKey(key);\\n    }\\n    return value;\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n    return map._keys.values();\\n  }\\n\\n  // UintToUintMap\\n\\n  struct UintToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key)));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintToAddressMap\\n\\n  struct UintToAddressMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressToUintMap\\n\\n  struct AddressToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n    return remove(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (address(uint160(uint256(key))), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // Bytes32ToUintMap\\n\\n  struct Bytes32ToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, key, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n    return remove(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n    return contains(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (key, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, key);\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, key));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x5052395b3d57e4347a977f96eba69188b4a952594afae411910995ecab5c1d05\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position is the index of the value in the `values` array plus 1.\\n    // Position 0 is used to mean a value is not in the set.\\n    mapping(bytes32 value => uint256) _positions;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._positions[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We cache the value's position to prevent multiple reads from the same storage slot\\n    uint256 position = set._positions[value];\\n\\n    if (position != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 valueIndex = position - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (valueIndex != lastIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the lastValue to the index where the value to delete is\\n        set._values[valueIndex] = lastValue;\\n        // Update the tracked position of the lastValue (that was just moved)\\n        set._positions[lastValue] = position;\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the tracked position for the deleted slot\\n      delete set._positions[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._positions[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n     */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xd5483249a7bac53a40791ade8d640831cdec526eea6b42a4db68f2ce13c008fa\",\"license\":\"MIT\"},\"contracts/openzeppelin/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n  struct InitializableStorage {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n         */\\n    uint64 _initialized;\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n    bool _initializing;\\n  }\\n\\n  // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n  /**\\n   * @dev The contract is already initialized.\\n     */\\n  error InvalidInitialization();\\n\\n  /**\\n   * @dev The contract is not initializing.\\n     */\\n  error NotInitializing();\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n  event Initialized(uint64 version);\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier initializer() {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    // Cache values to avoid duplicated sloads\\n    bool isTopLevelCall = !$._initializing;\\n    uint64 initialized = $._initialized;\\n\\n    // Allowed calls:\\n    // - initialSetup: the contract is not in the initializing state and no previous version was\\n    //                 initialized\\n    // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n    //                 current contract is just being deployed\\n    bool initialSetup = initialized == 0 && isTopLevelCall;\\n    bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n    if (!initialSetup && !construction) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = 1;\\n    if (isTopLevelCall) {\\n      $._initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      $._initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier reinitializer(uint64 version) {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing || $._initialized >= version) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = version;\\n    $._initializing = true;\\n    _;\\n    $._initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n  modifier onlyInitializing() {\\n    _checkInitializing();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n  function _checkInitializing() internal view virtual {\\n    if (!_isInitializing()) {\\n      revert NotInitializing();\\n    }\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n  function _disableInitializers() internal virtual {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing) {\\n      revert InvalidInitialization();\\n    }\\n    if ($._initialized != type(uint64).max) {\\n      $._initialized = type(uint64).max;\\n      emit Initialized(type(uint64).max);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n  function _getInitializedVersion() internal view returns (uint64) {\\n    return _getInitializableStorage()._initialized;\\n  }\\n\\n  /**\\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n  function _isInitializing() internal view returns (bool) {\\n    return _getInitializableStorage()._initializing;\\n  }\\n\\n  /**\\n   * @dev Returns a pointer to the storage namespace.\\n     */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n    assembly {\\n      $.slot := INITIALIZABLE_STORAGE\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x80aa3fc0fc9afdf84bd1a51716150cd13041f42d920a9afa8020ea41cf673809\",\"license\":\"MIT\"},\"contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n\\n  /**\\n    * @dev Muldiv operation overflow.\\n   */\\n  error MathOverflowedMulDiv();\\n\\n  enum Rounding {\\n    Floor, // Toward negative infinity\\n    Ceil, // Toward positive infinity\\n    Trunc, // Toward zero\\n    Expand // Away from zero\\n  }\\n\\n  /**\\n   * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      uint256 c = a + b;\\n      if (c < a) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b > a) return (false, 0);\\n      return (true, a - b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n      if (a == 0) return (true, 0);\\n      uint256 c = a * b;\\n      if (c / a != b) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a / b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a % b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (b == 0) {\\n      // Guarantee the same behavior as in a regular Solidity division.\\n      return a / b;\\n    }\\n\\n    // The following calculation ensures accurate ceiling division without overflow.\\n    // Since a is non-zero, (a - 1) / b will not overflow.\\n    // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n    // but the largest value we can obtain is type(uint256).max - 1, which happens\\n    // when a = type(uint256).max and b = 1.\\n    unchecked {\\n      return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n    unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n      uint256 prod0 = x * y; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n      if (prod1 == 0) {\\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n        // The surrounding unchecked block does not change this fact.\\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n        return prod0 / denominator;\\n      }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n      if (denominator <= prod1) {\\n        revert MathOverflowedMulDiv();\\n      }\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n      uint256 remainder;\\n      assembly {\\n      // Compute remainder using mulmod.\\n        remainder := mulmod(x, y, denominator)\\n\\n      // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n    // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n      uint256 twos = denominator & (0 - denominator);\\n      assembly {\\n      // Divide denominator by twos.\\n        denominator := div(denominator, twos)\\n\\n      // Divide [prod1 prod0] by twos.\\n        prod0 := div(prod0, twos)\\n\\n      // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n\\n    // Shift in bits from prod1 into prod0.\\n      prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n      uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n    // works in modular arithmetic, doubling the correct bits in each step.\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n      result = prod0 * inverse;\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n    unchecked {\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      return min(result, a / result);\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = sqrt(a);\\n      return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 128;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 64;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 32;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 16;\\n      }\\n      if (value >> 8 > 0) {\\n        value >>= 8;\\n        result += 8;\\n      }\\n      if (value >> 4 > 0) {\\n        value >>= 4;\\n        result += 4;\\n      }\\n      if (value >> 2 > 0) {\\n        value >>= 2;\\n        result += 2;\\n      }\\n      if (value >> 1 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log2(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >= 10 ** 64) {\\n        value /= 10 ** 64;\\n        result += 64;\\n      }\\n      if (value >= 10 ** 32) {\\n        value /= 10 ** 32;\\n        result += 32;\\n      }\\n      if (value >= 10 ** 16) {\\n        value /= 10 ** 16;\\n        result += 16;\\n      }\\n      if (value >= 10 ** 8) {\\n        value /= 10 ** 8;\\n        result += 8;\\n      }\\n      if (value >= 10 ** 4) {\\n        value /= 10 ** 4;\\n        result += 4;\\n      }\\n      if (value >= 10 ** 2) {\\n        value /= 10 ** 2;\\n        result += 2;\\n      }\\n      if (value >= 10 ** 1) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log10(value);\\n      return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 16;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 8;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 4;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 2;\\n      }\\n      if (value >> 8 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log256(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n  function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n    return uint8(rounding) % 2 == 1;\\n  }\\n\\n}\\n\",\"keccak256\":\"0x4d972e3e1d79f693b6cb42007d23c27256cb6f087392edea24b93585a822572c\",\"license\":\"MIT\"},\"contracts/proxy/Controllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Initializable.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../lib/SlotsLib.sol\\\";\\n\\n/// @title Implement basic functionality for any contract that require strict control\\n/// @dev Can be used with upgradeable pattern.\\n///      Require call __Controllable_init() in any case.\\n/// @author belbix\\nabstract contract Controllable is Initializable, IControllable {\\n  using SlotsLib for bytes32;\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant CONTROLLABLE_VERSION = \\\"1.0.0\\\";\\n\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.revision\\\")) - 1);\\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.prev_logic\\\")) - 1);\\n\\n  event ContractInitialized(address controller, uint ts, uint block);\\n  event RevisionIncreased(uint value, address oldLogic);\\n\\n  // init implementation contract\\n  constructor() initializer {}\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\n  /// @dev Use it only once after first logic setup\\n  /// @param controller_ Controller address\\n  function __Controllable_init(address controller_) internal onlyInitializing {\\n    _init(controller_);\\n  }\\n\\n  function _init(address controller_) private {\\n    require(controller_ != address(0), \\\"Zero controller\\\");\\n    _CONTROLLER_SLOT.set(controller_);\\n    _CREATED_SLOT.set(block.timestamp);\\n    _CREATED_BLOCK_SLOT.set(block.number);\\n    emit ContractInitialized(controller_, block.timestamp, block.number);\\n  }\\n\\n  /// @dev Return true if given address is controller\\n  function isController(address value_) public override view returns (bool) {\\n    return value_ == controller();\\n  }\\n\\n  /// @notice Return true if given address is setup as governance in Controller\\n  function isGovernance(address value_) public override view returns (bool) {\\n    return IController(controller()).governance() == value_;\\n  }\\n\\n  /// @dev Contract upgrade counter\\n  function revision() external view override returns (uint) {\\n    return _REVISION_SLOT.getUint();\\n  }\\n\\n  /// @dev Previous logic implementation\\n  function previousImplementation() external view override returns (address) {\\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\\n  }\\n\\n  // ************* SETTERS/GETTERS *******************\\n\\n  /// @notice Return controller address saved in the contract slot\\n  function controller() public view override returns (address) {\\n    return _CONTROLLER_SLOT.getAddress();\\n  }\\n\\n  /// @notice Return creation timestamp\\n  /// @return Creation timestamp\\n  function created() external view override returns (uint256) {\\n    return _CREATED_SLOT.getUint();\\n  }\\n\\n  /// @notice Return creation block number\\n  /// @return Creation block number\\n  function createdBlock() external override view returns (uint256) {\\n    return _CREATED_BLOCK_SLOT.getUint();\\n  }\\n\\n  /// @dev Revision should be increased on each contract upgrade\\n  function increaseRevision(address oldLogic) external override {\\n    require(msg.sender == address(this), \\\"Increase revision forbidden\\\");\\n    uint r = _REVISION_SLOT.getUint() + 1;\\n    _REVISION_SLOT.set(r);\\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\\n    emit RevisionIncreased(r, oldLogic);\\n  }\\n\\n}\\n\",\"keccak256\":\"0x1edc53f0d11834bebf4485746d04112ed10db9d4cb19b4945362c593ebf97daf\",\"license\":\"BUSL-1.1\"},\"contracts/relay/ERC2771Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.1;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\n// based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol\\nabstract contract ERC2771Context {\\n  // for whitelist new relayers need to add new constants and update proxies\\n  address private constant GELATO_RELAY_1_BALANCE_ERC_2771 = 0xd8253782c45a12053594b9deB72d8e8aB2Fca54c;\\n  address private constant SACRA_RELAY = 0x52CEba41Da235Af367bFC0b0cCd3314cb901bB5F;\\n  address private constant SACRA_RELAY_2 = 0x102f1f556cD9C3D5f820E6920A8931657c5Da21B;\\n\\n  function isTrustedForwarder(address forwarder) public view virtual returns (bool){\\n    return forwarder == GELATO_RELAY_1_BALANCE_ERC_2771 || forwarder == SACRA_RELAY || forwarder == SACRA_RELAY_2;\\n  }\\n\\n  function _msgSender() internal view virtual returns (address sender) {\\n    if (isTrustedForwarder(msg.sender)) {\\n      // The assembly code is more direct than the Solidity version using `abi.decode`.\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n      }\\n      return sender;\\n    } else {\\n      return msg.sender;\\n    }\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    if (isTrustedForwarder(msg.sender)) {\\n      return msg.data[: msg.data.length - 20];\\n    } else {\\n      return msg.data;\\n    }\\n  }\\n\\n  /// @notice Return true if given address is not a smart contract but a wallet address.\\n  /// @dev It is not 100% guarantee after EIP-3074 implementation, use it as an additional check.\\n  /// @return true if the address is a wallet.\\n  function _isNotSmartContract() internal view returns (bool) {\\n    return isTrustedForwarder(msg.sender) || msg.sender == tx.origin;\\n  }\\n\\n  function onlyEOA() internal view {\\n    if (!_isNotSmartContract()) {\\n      revert IAppErrors.NotEOA(msg.sender);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x7af64d60f6e51e2595b6412b2c4e4ed51a9895851eba74ad2444124d26163180\",\"license\":\"MIT\"},\"contracts/solady/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error FactorialOverflow();\\n\\n    /// @dev The operation failed, due to an overflow.\\n    error RPowOverflow();\\n\\n    /// @dev The mantissa is too big to fit.\\n    error MantissaOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error SMulWadFailed();\\n\\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\\n    error DivWadFailed();\\n\\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\\n    error SDivWadFailed();\\n\\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\\n    error MulDivFailed();\\n\\n    /// @dev The division failed, as the denominator is zero.\\n    error DivFailed();\\n\\n    /// @dev The full precision multiply-divide operation failed, either due\\n    /// to the result being larger than 256 bits, or a division by a zero.\\n    error FullMulDivFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /// @dev The input outside the acceptable domain.\\n    error OutOfDomain();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(x, y)\\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := sdiv(z, WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(x, WAD)\\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\\n            if iszero(and(iszero(iszero(y)), eq(sdiv(z, WAD), x))) {\\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := sdiv(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `x` to the power of `y`.\\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Using `ln(x)` means `x` must be greater than 0.\\n        return expWad((lnWad(x) * y) / int256(WAD));\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/22/exp-ln\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is less than 0.5 we return zero.\\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\\n            if (x <= -41446531673892822313) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) \\u2248 135`.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // `k` is in the range `[-61, 195]`.\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // `p` is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already `2**96` too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range `(0.09, 0.25) * 2**96`.\\n\\n            // We now need to multiply r by:\\n            // - The scale factor `s \\u2248 6.031367120`.\\n            // - The `2**k` factor from the range reduction.\\n            // - The `1e18 / 2**96` factor for base conversion.\\n            // We do this all at once, with an intermediate result in `2**213`\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256(\\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\\n            );\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/22/exp-ln\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\\n            // We do this by multiplying by `2**96 / 10**18`. But since\\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\\n            // and add `ln(2**96 / 10**18)` at the end.\\n\\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // We place the check here for more optimal stack operations.\\n            if iszero(sgt(x, 0)) {\\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // forgefmt: disable-next-item\\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x := shr(159, shl(r, x))\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // `p` is made monic, we will multiply by a scale factor later.\\n            // forgefmt: disable-next-item\\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\\n                sar(96, mul(add(43456485725739037958740375743393,\\n                sar(96, mul(add(24828157081833163892658089445524,\\n                sar(96, mul(add(3273285459638523848632254066296,\\n                    x), x))), x))), x)), 11111509109440967052023855526967)\\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\\n\\n            // `q` is monic by convention.\\n            let q := add(5573035233440673466300451813936, x)\\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\\n\\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\\n\\n            // Finalization, we need to:\\n            // - Multiply by the scale factor `s = 5.549\\u2026`.\\n            // - Add `ln(2**96 / 10**18)`.\\n            // - Add `k * ln(2)`.\\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\\n\\n            // The q polynomial is known not to have zeros in the domain.\\n            // No scaling required because p is already `2**96` too large.\\n            p := sdiv(p, q)\\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\\n            p := mul(1677202110996718588342820967067443963516166, p)\\n            // Add `ln(2) * k * 5**18 * 2**192`.\\n            // forgefmt: disable-next-item\\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\\n            // Base conversion: mul `2**18 / 2**192`.\\n            r := sar(174, p)\\n        }\\n    }\\n\\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\\n        // forgefmt: disable-next-item\\n        unchecked {\\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\\n            int256 wad = int256(WAD);\\n            int256 p = x;\\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\\n            uint256 i = 4; // Number of iterations.\\n            if (w <= 0x1ffffffffffff) {\\n                if (-0x4000000000000 <= w) {\\n                    i = 1; // Inputs near zero only take one step to converge.\\n                } else if (w <= -0x3ffffffffffffff) {\\n                    i = 32; // Inputs near `-1/e` take very long to converge.\\n                }\\n            } else if (w >> 63 == 0) {\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    // Inline log2 for more performance, since the range is small.\\n                    let v := shr(49, w)\\n                    let l := shl(3, lt(0xff, v))\\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\\n                    c := gt(l, 60)\\n                    i := add(2, add(gt(l, 53), c))\\n                }\\n            } else {\\n                int256 ll = lnWad(w = lnWad(w));\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\\n                    i := add(3, iszero(shr(68, x)))\\n                    c := iszero(shr(143, x))\\n                }\\n                if (c == 0) {\\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\\n                        int256 e = expWad(w);\\n                        /// @solidity memory-safe-assembly\\n                        assembly {\\n                            let t := mul(w, div(e, wad))\\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\\n                        }\\n                        if (p <= w) break;\\n                        p = w;\\n                    } while (--i != 0);\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        w := sub(w, sgt(w, 2))\\n                    }\\n                    return w;\\n                }\\n            }\\n            do { // Otherwise, use Halley's for faster convergence.\\n                int256 e = expWad(w);\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let t := add(w, wad)\\n                    let s := sub(mul(w, e), mul(x, wad))\\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\\n                }\\n                if (p <= w) break;\\n                p = w;\\n            } while (--i != c);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                w := sub(w, sgt(w, 2))\\n            }\\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\\n            if (c != 0) {\\n                int256 t = w | 1;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    x := sdiv(mul(x, wad), t)\\n                }\\n                x = (t * (wad + lnWad(x)));\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    w := sdiv(x, add(wad, t))\\n                }\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  GENERAL NUMBER UTILITIES                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Remco Bloemen under MIT license: https://2\\u03c0.com/21/muldiv\\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                // 512-bit multiply `[p1 p0] = x * y`.\\n                // Compute the product mod `2**256` and mod `2**256 - 1`\\n                // then use the Chinese Remainder Theorem to reconstruct\\n                // the 512 bit result. The result is stored in two 256\\n                // variables such that `product = p1 * 2**256 + p0`.\\n\\n                // Least significant 256 bits of the product.\\n                result := mul(x, y) // Temporarily use `result` as `p0` to save gas.\\n                let mm := mulmod(x, y, not(0))\\n                // Most significant 256 bits of the product.\\n                let p1 := sub(mm, add(result, lt(mm, result)))\\n\\n                // Handle non-overflow cases, 256 by 256 division.\\n                if iszero(p1) {\\n                    if iszero(d) {\\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    result := div(result, d)\\n                    break\\n                }\\n\\n                // Make sure the result is less than `2**256`. Also prevents `d == 0`.\\n                if iszero(gt(d, p1)) {\\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n\\n                /*------------------- 512 by 256 division --------------------*/\\n\\n                // Make division exact by subtracting the remainder from `[p1 p0]`.\\n                // Compute remainder using mulmod.\\n                let r := mulmod(x, y, d)\\n                // `t` is the least significant bit of `d`.\\n                // Always greater or equal to 1.\\n                let t := and(d, sub(0, d))\\n                // Divide `d` by `t`, which is a power of two.\\n                d := div(d, t)\\n                // Invert `d mod 2**256`\\n                // Now that `d` is an odd number, it has an inverse\\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\\n                // Compute the inverse by starting with a seed that is correct\\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\\n                let inv := xor(2, mul(3, d))\\n                // Now use Newton-Raphson iteration to improve the precision.\\n                // Thanks to Hensel's lifting lemma, this also works in modular\\n                // arithmetic, doubling the correct bits in each step.\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\\n                result :=\\n                    mul(\\n                        // Divide [p1 p0] by the factors of two.\\n                        // Shift in bits from `p1` into `p0`. For this we need\\n                        // to flip `t` such that it is `2**256 / t`.\\n                        or(\\n                            mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)),\\n                            div(sub(result, r), t)\\n                        ),\\n                        // inverse mod 2**256\\n                        mul(inv, sub(2, mul(d, inv)))\\n                    )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Uniswap-v3-core under MIT license:\\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        result = fullMulDiv(x, y, d);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mulmod(x, y, d) {\\n                result := add(result, 1)\\n                if iszero(result) {\\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `floor(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), d)\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x / d)`.\\n    /// Reverts if `d` is zero.\\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(d) {\\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\\n    /// Reverts if the computation overflows.\\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\\n            if x {\\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\\n                let half := shr(1, b) // Divide `b` by 2.\\n                // Divide `y` by 2 every iteration.\\n                for { y := shr(1, y) } y { y := shr(1, y) } {\\n                    let xx := mul(x, x) // Store x squared.\\n                    let xxRound := add(xx, half) // Round to the nearest number.\\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\\n                    if or(lt(xxRound, xx), shr(128, x)) {\\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\\n                    // If `y` is odd:\\n                    if and(y, 1) {\\n                        let zx := mul(z, x) // Compute `z * x`.\\n                        let zxRound := add(zx, half) // Round to the nearest number.\\n                        // If `z * x` overflowed or `zx + half` overflowed:\\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\\n                            // Revert if `x` is non-zero.\\n                            if iszero(iszero(x)) {\\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\\n                                revert(0x1c, 0x04)\\n                            }\\n                        }\\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`.\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\\n            z := shl(shr(1, r), z)\\n\\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\\n\\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\\n\\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\\n\\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\\n            // Then we can estimate `sqrt(y)` using\\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\\n\\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If `x+1` is a perfect square, the Babylonian method cycles between\\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    /// @dev Returns the cube root of `x`.\\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n\\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\\n\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n\\n            z := sub(z, lt(div(x, mul(z, z)), z))\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`, denominated in `WAD`.\\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = 10 ** 9;\\n            if (x <= type(uint256).max / 10 ** 36 - 1) {\\n                x *= 10 ** 18;\\n                z = 1;\\n            }\\n            z *= sqrt(x);\\n        }\\n    }\\n\\n    /// @dev Returns the cube root of `x`, denominated in `WAD`.\\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = 10 ** 12;\\n            if (x <= (type(uint256).max / 10 ** 36) * 10 ** 18 - 1) {\\n                if (x >= type(uint256).max / 10 ** 36) {\\n                    x *= 10 ** 18;\\n                    z = 10 ** 6;\\n                } else {\\n                    x *= 10 ** 36;\\n                    z = 1;\\n                }\\n            }\\n            z *= cbrt(x);\\n        }\\n    }\\n\\n    /// @dev Returns the factorial of `x`.\\n    function factorial(uint256 x) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, 58)) {\\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            for { result := 1 } x { x := sub(x, 1) } { result := mul(result, x) }\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`.\\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\\n    /// Returns 0 if `x` is zero.\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0x0706060506020504060203020504030106050205030304010505030400000000))\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`, rounded up.\\n    /// Returns 0 if `x` is zero.\\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\\n        r = log2(x);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := add(r, lt(shl(r, 1), x))\\n        }\\n    }\\n\\n    /// @dev Returns the log10 of `x`.\\n    /// Returns 0 if `x` is zero.\\n    function log10(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\\n                x := div(x, 100000000000000000000000000000000000000)\\n                r := 38\\n            }\\n            if iszero(lt(x, 100000000000000000000)) {\\n                x := div(x, 100000000000000000000)\\n                r := add(r, 20)\\n            }\\n            if iszero(lt(x, 10000000000)) {\\n                x := div(x, 10000000000)\\n                r := add(r, 10)\\n            }\\n            if iszero(lt(x, 100000)) {\\n                x := div(x, 100000)\\n                r := add(r, 5)\\n            }\\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\\n        }\\n    }\\n\\n    /// @dev Returns the log10 of `x`, rounded up.\\n    /// Returns 0 if `x` is zero.\\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\\n        r = log10(x);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := add(r, lt(exp(10, r), x))\\n        }\\n    }\\n\\n    /// @dev Returns the log256 of `x`.\\n    /// Returns 0 if `x` is zero.\\n    function log256(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the log256 of `x`, rounded up.\\n    /// Returns 0 if `x` is zero.\\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\\n        r = log256(x);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := add(r, lt(shl(shl(3, r), 1), x))\\n        }\\n    }\\n\\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mantissa := x\\n            if mantissa {\\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\\n                    exponent := 33\\n                }\\n                if iszero(mod(mantissa, 10000000000000000000)) {\\n                    mantissa := div(mantissa, 10000000000000000000)\\n                    exponent := add(exponent, 19)\\n                }\\n                if iszero(mod(mantissa, 1000000000000)) {\\n                    mantissa := div(mantissa, 1000000000000)\\n                    exponent := add(exponent, 12)\\n                }\\n                if iszero(mod(mantissa, 1000000)) {\\n                    mantissa := div(mantissa, 1000000)\\n                    exponent := add(exponent, 6)\\n                }\\n                if iszero(mod(mantissa, 10000)) {\\n                    mantissa := div(mantissa, 10000)\\n                    exponent := add(exponent, 4)\\n                }\\n                if iszero(mod(mantissa, 100)) {\\n                    mantissa := div(mantissa, 100)\\n                    exponent := add(exponent, 2)\\n                }\\n                if iszero(mod(mantissa, 10)) {\\n                    mantissa := div(mantissa, 10)\\n                    exponent := add(exponent, 1)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\\n    /// enough to fit in the desired unsigned integer type:\\n    /// ```\\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\\n    /// ```\\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if shr(249, x) {\\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            packed := or(shl(7, x), packed)\\n        }\\n    }\\n\\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\\n        unchecked {\\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = (x & y) + ((x ^ y) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\\n        }\\n    }\\n\\n    /// @dev Returns the absolute value of `x`.\\n    function abs(int256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(sar(255, x), add(sar(255, x), x))\\n        }\\n    }\\n\\n    /// @dev Returns the absolute distance between `x` and `y`.\\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(mul(xor(sub(y, x), sub(x, y)), sgt(x, y)), sub(y, x))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\\n        }\\n    }\\n\\n    /// @dev Returns greatest common divisor of `x` and `y`.\\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { z := x } y {} {\\n                let t := y\\n                y := mod(z, y)\\n                z := t\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RAW NUMBER OPERATIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := smod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := addmod(x, y, d)\\n        }\\n    }\\n\\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mulmod(x, y, d)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf147bc4008b46ef438b2dd77a7a2dbf6ba9f13049f9a13c82a9cdf03923516ab\",\"license\":\"MIT\"},\"contracts/solady/LibPRNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for generating pseudorandom numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\\n/// @author LazyShuffler based on NextShuffler by aschlosberg (divergencearran)\\n/// (https://github.com/divergencetech/ethier/blob/main/contracts/random/NextShuffler.sol)\\nlibrary LibPRNG {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The initial length must be greater than zero and less than `2**32 - 1`.\\n    error InvalidInitialLazyShufflerLength();\\n\\n    /// @dev The new length must not be less than the current length.\\n    error InvalidNewLazyShufflerLength();\\n\\n    /// @dev The lazy shuffler has not been initialized.\\n    error LazyShufflerNotInitialized();\\n\\n    /// @dev Cannot double initialize the lazy shuffler.\\n    error LazyShufflerAlreadyInitialized();\\n\\n    /// @dev The lazy shuffle has finished.\\n    error LazyShuffleFinished();\\n\\n    /// @dev The queried index is out of bounds.\\n    error LazyShufflerGetOutOfBounds();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pseudorandom number state in memory.\\n    struct PRNG {\\n        uint256 state;\\n    }\\n\\n    /// @dev A lazy Fisher-Yates shuffler for a range `[0..n)` in storage.\\n    struct LazyShuffler {\\n        // Bits Layout:\\n        // - [0..31]    `numShuffled`\\n        // - [32..223]  `permutationSlot`\\n        // - [224..255] `length`\\n        uint256 _state;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Seeds the `prng` with `state`.\\n    function seed(PRNG memory prng, uint256 state) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(prng, state)\\n        }\\n    }\\n\\n    /// @dev Returns the next pseudorandom uint256.\\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\\n        // We simply use `keccak256` for a great balance between\\n        // runtime gas costs, bytecode size, and statistical properties.\\n        //\\n        // A high-quality LCG with a 32-byte state\\n        // is only about 30% more gas efficient during runtime,\\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\\n        // when this function is inlined.\\n        //\\n        // Using this method is about 2x more efficient than\\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n        }\\n    }\\n\\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\\n    /// between 0 (inclusive) and `upper` (exclusive).\\n    /// If your modulus is big, this method is recommended\\n    /// for uniform sampling to avoid modulo bias.\\n    /// For uniform sampling across all uint256 values,\\n    /// or for small enough moduli such that the bias is neligible,\\n    /// use {next} instead.\\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := keccak256(prng, 0x20)\\n                mstore(prng, result)\\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\\n            }\\n            result := mod(result, upper)\\n        }\\n    }\\n\\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n\\n                    {\\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                let b := add(a, 0x01)\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let o := mod(shr(128, r), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n\\n                    {\\n                        let o := mod(and(r, mask), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the standard normal distribution denominated in `WAD`.\\n    function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\\n            // The chance of drawing a sample outside 10 \\u03c3 from the standard normal distribution\\n            // is \\u2248 0.000000000000000000000015, which is insignificant for most practical purposes.\\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\\n            let s := 0x1000000000000000100000000000000010000000000000001\\n            let r1 := mulmod(result, a, n)\\n            let r2 := mulmod(r1, a, n)\\n            let r3 := mulmod(r2, a, n)\\n            // forgefmt: disable-next-item\\n            result := sub(sar(96, mul(26614938895861601847173011183,\\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the unit exponential distribution denominated in `WAD`.\\n    function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\\n            // Gas usage varies, starting from about 172+ gas.\\n            let r := keccak256(prng, 0x20)\\n            mstore(prng, r)\\n            let p := shl(129, r)\\n            let w := shl(1, r)\\n            if iszero(gt(w, p)) {\\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n                for {} 1 {} {\\n                    r := mulmod(r, a, n)\\n                    if iszero(lt(shl(129, r), w)) {\\n                        r := mulmod(r, a, n)\\n                        result := add(1000000000000000000, result)\\n                        w := shl(1, r)\\n                        p := shl(129, r)\\n                        if iszero(lt(w, p)) { break }\\n                        continue\\n                    }\\n                    w := shl(1, r)\\n                    if iszero(lt(w, shl(129, r))) { break }\\n                }\\n            }\\n            result := add(div(p, shl(129, 170141183460469231732)), result)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*       STORAGE-BASED RANGE LAZY SHUFFLING OPERATIONS        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Initializes the state for lazy-shuffling the range `[0..n)`.\\n    /// Reverts if `n == 0 || n >= 2**32 - 1`.\\n    /// Reverts if `$` has already been initialized.\\n    /// If you need to reduce the length after initialization, just use a fresh new `$`.\\n    function initialize(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sload($.slot) {\\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, $.slot)\\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Increases the length of `$`.\\n    /// Reverts if `$` has not been initialized.\\n    function grow(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            // If the new length is smaller than the old length, revert.\\n            if lt(n, shr(224, state)) {\\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\\n        }\\n    }\\n\\n    /// @dev Restarts the shuffler by setting `numShuffled` to zero,\\n    /// such that all elements can be drawn again.\\n    /// Restarting does NOT clear the internal permutation, nor changes the length.\\n    /// Even with the same sequence of randomness, reshuffling can yield different results.\\n    function restart(LazyShuffler storage $) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot)\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, shl(32, shr(32, state)))\\n        }\\n    }\\n\\n    /// @dev Returns the number of elements that have been shuffled.\\n    function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := and(0xffffffff, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns the length of `$`.\\n    /// Returns zero if `$` is not initialized, else a non-zero value less than `2**32 - 1`.\\n    function length(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := shr(224, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns if `$` has been initialized.\\n    function initialized(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(iszero(sload($.slot)))\\n        }\\n    }\\n\\n    /// @dev Returns if there are any more elements left to shuffle.\\n    /// Reverts if `$` is not initialized.\\n    function finished(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := eq(shr(224, state), and(0xffffffff, state))\\n        }\\n    }\\n\\n    /// @dev Returns the current value stored at `index`, accounting for all historical shuffling.\\n    /// Reverts if `index` is greater than or equal to the `length` of `$`.\\n    function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            let n := shr(224, state) // Length of `$`.\\n            if iszero(lt(index, n)) {\\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let u32 := gt(n, 0xfffe)\\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\\n            result := and(m, shr(o, sload(s)))\\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\\n        }\\n    }\\n\\n    /// @dev Does a single Fisher-Yates shuffle step, increments the `numShuffled` in `$`,\\n    /// and returns the next value in the shuffled range.\\n    /// `randomness` can be taken from a good-enough source, or a higher quality source like VRF.\\n    /// Reverts if there are no more values to shuffle, which includes the case if `$` is not initialized.\\n    function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function _get(u32_, state_, i_) -> _value {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                _value := and(m_, shr(o_, sload(s_)))\\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\\n            }\\n            function _set(u32_, state_, i_, value_) {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                let v_ := sload(s_) // Bucket slot value.\\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\\n            }\\n            let state := sload($.slot) // The packed value at `$`.\\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\\n            let n := shr(224, state) // Length of `$`.\\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\\n            if iszero(remainder) {\\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\\n            chosen := _get(gt(n, 0xfffe), state, index)\\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdcb71f8dc72bb7384776154ca24d34c23e3c9bcf124bc75f0d2e379f9ebd021d\",\"license\":\"MIT\"},\"contracts/token/GuildBank.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n/**\\n            \\u2592\\u2593\\u2592  \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2593\\n             \\u2592\\u2588\\u2588\\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593  \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n              \\u2592\\u2588\\u2588\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592 \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n               \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592                   \\u2592\\u2588\\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                     \\u2592\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592     \\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                   \\u2592\\u2592\\u2592\\u2592\\u2592   \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                         \\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                       \\u2592\\u2588\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\n                        \\u2592\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592       \\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\n                          \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593   \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                           \\u2592\\u2592\\u2593\\u2593\\u2592   \\u2592\\u2588\\u2588\\u2593\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                  \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                                 \\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                                \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n      \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593                  \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                      \\u2592\\u2593\\u2593\\n    \\u2592\\u2593\\u2588\\u2592   \\u2592\\u2592\\u2588\\u2592\\u2592                   \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2592\\u2593\\u2593\\u2592\\n   \\u2592\\u2592\\u2588\\u2592       \\u2593\\u2592                    \\u2592\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2588\\u2593\\u2592\\n   \\u2593\\u2592\\u2588\\u2588\\u2593\\u2592                             \\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2592\\n    \\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2593\\u2592        \\u2592\\u2592\\u2592         \\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592\\u2592\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2592 \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n     \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2592\\u2592\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2593\\u2593     \\u2593\\u2593  \\u2593\\u2593\\u2588\\u2593   \\u2592\\u2592\\u2593\\u2593   \\u2592\\u2592\\u2588\\u2592   \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n            \\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592  \\u2592\\u2593\\u2593\\u2593\\u2592\\u2588\\u2592   \\u2592\\u2592\\u2592\\u2588\\u2592          \\u2592\\u2592\\u2588\\u2593\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592   \\u2593\\u2588\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\n \\u2592            \\u2592\\u2593\\u2593\\u2588\\u2593  \\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2593  \\u2592\\u2588\\u2593\\u2593\\u2592          \\u2593\\u2593\\u2588\\u2593\\u2592\\u2593\\u2588\\u2593\\u2592\\u2592   \\u2593\\u2588\\u2593        \\u2593\\u2588\\u2588\\u2588\\u2593\\n\\u2593\\u2593\\u2592         \\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592\\u2592\\u2593\\u2588\\u2592   \\u2592\\u2593\\u2588\\u2588\\u2593  \\u2593\\u2588\\u2588\\u2593\\u2592     \\u2592\\u2588\\u2593 \\u2593\\u2593\\u2588\\u2588   \\u2592\\u2593\\u2593\\u2593\\u2592\\u2592\\u2593\\u2588\\u2593        \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2592\\n \\u2588\\u2588\\u2593\\u2593\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592\\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592     \\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592\\n*/\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IGuildBank.sol\\\";\\nimport \\\"../interfaces/IGuildController.sol\\\";\\nimport \\\"../openzeppelin/ERC721Holder.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\n\\n/// @dev SCR-1253: ERC721Holder was added in 1.0.2.\\n/// So, safeTransferFrom won't work with all contract instances with the lower version. They should be upgraded.\\ncontract GuildBank is IGuildBank, ERC721Holder {\\n\\n  //region ------------------------ CONSTANTS\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant VERSION = \\\"1.0.2\\\";\\n  //endregion ------------------------ CONSTANTS\\n\\n  //region ------------------------ Members\\n  IGuildController immutable public guildController;\\n  uint immutable public guildId;\\n  //endregion ------------------------ Members\\n\\n  //region ------------------------ Restrictions and constructor\\n  function _onlyGuildController(address msgSender) internal view {\\n    if (msgSender != address(guildController)) revert IAppErrors.GuildControllerOnly();\\n  }\\n\\n  constructor (address guildController_, uint guildId_) {\\n    guildController = IGuildController(guildController_);\\n    guildId = guildId_;\\n  }\\n  //endregion ------------------------ Restrictions and constructor\\n\\n  //region ------------------------ ERC20\\n  function transfer(address token, address recipient, uint amount) external {\\n    _onlyGuildController(msg.sender);\\n\\n    IERC20(token).transfer(recipient, amount);\\n    emit IApplicationEvents.GuildBankTransfer(token, recipient, amount);\\n  }\\n\\n  function approve(address token, address spender, uint256 amount) external returns (bool) {\\n    _onlyGuildController(msg.sender);\\n\\n    return IERC20(token).approve(spender, amount);\\n  }\\n  //endregion ------------------------ ERC20\\n\\n  //region ------------------------ ERC721\\n  function transferNft(address to, address nft, uint256 tokenId) external {\\n    _onlyGuildController(msg.sender);\\n\\n    IERC721(nft).transferFrom(address(this), to, tokenId);\\n    emit IApplicationEvents.GuildBankTransferNft(to, nft, tokenId);\\n  }\\n\\n  function transferNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external {\\n    _onlyGuildController(msg.sender);\\n\\n    uint len = nfts.length;\\n    if (len != tokenIds.length) revert IAppErrors.LengthsMismatch();\\n\\n    for (uint i; i < len; ++i) {\\n      IERC721(nfts[i]).transferFrom(address(this), to, tokenIds[i]);\\n    }\\n    emit IApplicationEvents.GuildBankTransferNftMulti(to, nfts, tokenIds);\\n  }\\n\\n  function approveNft(address to, address nft, uint256 tokenId) external {\\n    _onlyGuildController(msg.sender);\\n\\n    IERC721(nft).approve(to, tokenId);\\n  }\\n\\n  function approveNftMulti(address to, address[] memory nfts, uint256[] memory tokenIds) external {\\n    _onlyGuildController(msg.sender);\\n\\n    uint len = nfts.length;\\n    if (len != tokenIds.length) revert IAppErrors.LengthsMismatch();\\n\\n    for (uint i; i < len; ++i) {\\n      IERC721(nfts[i]).approve(to, tokenIds[i]);\\n    }\\n  }\\n  //endregion ------------------------ ERC721\\n}\",\"keccak256\":\"0xa5903c407caf6aed8068f963fc10f1333837b62cc89439aa5b1aad638a7f8fc1\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b507ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00805468010000000000000000810460ff1615906001600160401b03166000811580156200005d5750825b90506000826001600160401b031660011480156200007a5750303b155b90508115801562000089575080155b15620000a85760405163f92ee8a960e01b815260040160405180910390fd5b84546001600160401b03191660011785558315620000d757845460ff60401b1916680100000000000000001785555b83156200011e57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b50505050506155b080620001336000396000f3fe608060405234801561001057600080fd5b50600436106102555760003560e01c80637cc9638011610147578063cb80c82f116100be578063cb80c82f1461062e578063ce24c6e514610641578063ce4a79a914610654578063d2336d2e14610667578063d49e18be1461066f578063dee1f0e414610682578063e22d24af14610695578063e89acf061461069d578063f2f17ec8146106a5578063f77c4791146106c6578063f88cb61d146106ce578063ffa1ad741461058957600080fd5b80637cc96380146104b9578063859ec734146104c1578063901bccda146104d457806390c928cd146104e757806390e52dc3146104fa578063936725ec14610589578063991bb818146105ba5780639d0bcca0146105cd578063a399f0d7146105e2578063b2c56c9b146105f5578063b429afeb14610608578063c5beb1e01461061b57600080fd5b80633349eafa116101db5780633349eafa146103a357806342be39a4146103b6578063454ac5c8146103dc5780634593144c146103ef57806347ff6204146103f75780634fac6ccd14610417578063572b6c051461042a5780635ecd46781461044d57806361aa8057146104605780636672009e1461047357806371c2b99c146104935780637a5654d8146104a657600080fd5b806306575c891461025a5780630984b3cb1461027c5780630abb07c3146102a4578063150b7a02146102c55780631518fc25146102fc57806319ab453c1461031c5780631b541a351461033157806325b3b32c146103445780632b529bde146103575780632fe7b1b51461037c578063325a19f11461039b575b600080fd5b6102626106d6565b60405163ffffffff90911681526020015b60405180910390f35b61028f61028a3660046149f0565b6106e6565b60408051928352602083019190915201610273565b6102b76102b2366004614a34565b6106ff565b604051908152602001610273565b6102e36102d3366004614b30565b630a85bd0160e11b949350505050565b6040516001600160e01b03199091168152602001610273565b61030f61030a366004614b9b565b610714565b6040516102739190614bc9565b61032f61032a366004614c0d565b610720565b005b6102b761033f366004614c2a565b610836565b61032f610352366004614c6b565b61084b565b61036a610365366004614c6b565b61085f565b60405160ff9091168152602001610273565b61038461086a565b60405165ffffffffffff9091168152602001610273565b6102b7610874565b61036a6103b1366004614c84565b6108a8565b6103c96103c43660046149f0565b6108b4565b60405161ffff9091168152602001610273565b6102626103ea366004614c6b565b6108bf565b6102b76108ca565b61040a610405366004614ca9565b6108fa565b6040516102739190614cef565b61032f610425366004614c0d565b61090d565b61043d610438366004614c0d565b610a1f565b6040519015158152602001610273565b61043d61045b366004614d5e565b610a94565b6102b761046e3660046149f0565b610aa1565b610486610481366004614c2a565b610aac565b6040516102739190614da0565b61032f6104a1366004614c0d565b610ab9565b6104866104b4366004614c2a565b610aca565b6102b7610ad7565b6102626104cf3660046149f0565b610af5565b61032f6104e23660046149f0565b610b00565b6102b76104f5366004614de1565b610b1d565b61050d610508366004614a34565b610b34565b6040516102739190600060e08201905060ff8351168252602083015163ffffffff808216602085015280604086015116604085015250506001600160401b03606084015116606083015260ff608084015116608083015260ff60a08401511660a083015265ffffffffffff60c08401511660c083015292915050565b6105ad604051806040016040528060058152602001640312e302e360dc1b81525081565b6040516102739190614e82565b6105ad6105c8366004614de1565b610b46565b6105d5610b54565b6040516102739190614e95565b61032f6105f0366004614ea9565b610b84565b61043d610603366004614d5e565b610baa565b61043d610616366004614c0d565b610bb7565b61028f6106293660046149f0565b610bdc565b61032f61063c366004614c6b565b610be8565b61032f61064f3660046149f0565b610bf9565b61043d610662366004614f14565b610c06565b61032f610c1b565b61032f61067d3660046149f0565b610c39565b61043d610690366004614c0d565b610cd3565b61032f610d58565b6102b7610d71565b6106b86106b3366004614f40565b610d7b565b604051610273929190614f88565b6105d5610d98565b6105d5610dc8565b60006106e142610dd2565b905090565b6000806106f68342610def610e9f565b91509150915091565b600061070b8383610ec8565b90505b92915050565b606061070b8383610f0b565b600061072a610f47565b805490915060ff600160401b82041615906001600160401b03166000811580156107515750825b90506000826001600160401b0316600114801561076d5750303b155b90508115801561077b575080155b156107995760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff1916600117855583156107c357845460ff60401b1916600160401b1785555b6107cc86610f6b565b60056107d6610f7c565b600160009081526020919091526040902055831561082e57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b6000610843848484610fa0565b949350505050565b61085c610856610d98565b82611001565b50565b600061070e826110f2565b60006106e1611113565b60006106e16108a460017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b614fb7565b5490565b600061070b8383611147565b600061070e82611181565b600061070e82610dd2565b60006106e16108a460017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1614fb7565b6109026148ed565b6108438484846111b2565b33301461095f5760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b600061097d6108a4600160008051602061555b833981519152614fb7565b610988906001614fca565b90506109aa816109a7600160008051602061555b833981519152614fb7565b55565b6109d9826109a760017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4614fb7565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c891015b60405180910390a15050565b60006001600160a01b03821673d8253782c45a12053594b9deb72d8e8ab2fca54c1480610a6857506001600160a01b0382167352ceba41da235af367bfc0b0ccd3314cb901bb5f145b8061070e57506001600160a01b03821673102f1f556cd9c3d5f820e6920a8931657c5da21b1492915050565b600061084384848461129b565b600061070e826112d9565b6060610843848484611308565b61085c610ac4610d98565b8261134f565b60606108438484846113af565b60006106e16108a4600160008051602061555b833981519152614fb7565b600061070e826113f3565b61085c610b0b611426565b610b13610d98565b8342610def61144b565b6000610b2b8585858561169f565b95945050505050565b610b3c61491d565b61070b8383611782565b6060610b2b8585858561183d565b60006106e16108a460017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4614fb7565b610ba4610b8f611426565b610b97610d98565b8686868642610def611920565b50505050565b6000610843848484612551565b6000610bc1610d98565b6001600160a01b0316826001600160a01b0316149050919050565b6000806106f6836125cf565b61085c610bf3610d98565b82612639565b61085c8142610def61268e565b600061070b8383610c1642610dd2565b61129b565b610c37610c26611426565b610c2e610d98565b42610def612699565b565b73536edbB5eEDaD839155E70510Bb1F55604dF3d0c638eb687a9610c5b611426565b610c63610d98565b6040516001600160e01b031960e085901b1681526001600160a01b0392831660048201529116602482015242604482015260ff8416606482015260840160006040518083038186803b158015610cb857600080fd5b505af4158015610ccc573d6000803e3d6000fd5b5050505050565b6000816001600160a01b0316610ce7610d98565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d24573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d489190614fdd565b6001600160a01b03161492915050565b610c37610d63611426565b610d6b610d98565b4261292c565b60006106e1612a33565b600080610d8a86868686612a46565b915091505b94509492505050565b60006106e16108a460017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618614fb7565b60006106e1612ab7565b600061070e610de46201518084615010565b63ffffffff16612aca565b600081600003610e0157506000919050565b6000610e0b612ae3565b9050610e18836001614fca565b4340414443423a5a88604051602001610e7598979695949392919097885260609690961b6001600160601b0319166020880152603487019490945260548601929092526074850152609484015260b483015260d482015260f40190565b6040516020818303038152906040528051906020012060001c610e989190615024565b9392505050565b6000806000610eaf868686612b1a565b9050610eba81612f49565b92509250505b935093915050565b6000610ed2610f7c565b63ffffffff84166000908152600391909101602090815260408083206001600160a01b0386168452600201909152902054905092915050565b606061070b610f18610f7c565b63ffffffff841660009081526003919091016020908152604080832060ff88168452600601909152902061305c565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b610f73613069565b61085c8161308e565b7f6750db0cf5db3c73c8abbeff54ef9c65daabbed6967cb68f37e0698f5fc7bb0090565b6000806000610fe584610fb1610f7c565b63ffffffff80891660009081526003929092016020908152604080842060ff8d16855260010190915290912091906131ad16565b9150915081610ff5576000610ff7565b805b9695505050505050565b61100a826131cb565b6000611014610f7c565b600301600061102242610dd2565b63ffffffff1681526020808201929092526040908101600090812085825260058101909352205490915060ff1680156110755760ff811660009081526006830160205260409020611073908461325e565b505b600061107f610f7c565b6000858152600291909101602052604090205460ff1690508015610ccc576110a5610f7c565b600085815260029190910160205260409020805460ff191690556110c7610f7c565b60ff821660009081526001919091016020526040902080546001600160701b03191690555050505050565b60006110fc610f7c565b600092835260020160205250604090205460ff1690565b600061111d610f7c565b600060035b600381111561113357611133614cd9565b815260200190815260200160002054905090565b6000611151610f7c565b63ffffffff9290921660009081526003909201602090815260408084209484526005909401905250205460ff1690565b600061118b610f7c565b60ff9290921660009081526001909201602052506040902054600160601b900461ffff1690565b6111ba6148ed565b6111c2610f7c565b63ffffffff85166000908152600391909101602090815260408083206001600160a01b0387168452600201909152902080548390811061120457611204615038565b60009182526020918290206040805160a08101909152910180546001600160a01b03811683529192909190830190600160a01b900460ff16600481111561124d5761124d614cd9565b600481111561125e5761125e614cd9565b81529054600160a81b810463ffffffff9081166020840152600160c81b8204166040830152600160e81b900460ff16606090910152949350505050565b6000806112a6610f7c565b60030160008463ffffffff1681526020019081526020016000209050610b2b6112cf868661326a565b60038301906132ba565b60006112e3610f7c565b60ff90921660009081526001929092016020525060409020546001600160401b031690565b6060610843611315610f7c565b63ffffffff851660009081526003919091016020908152604080832060ff89168452600101825280832086845260040190915290206132d2565b611358826132df565b806001600160a01b031661136a610f7c565b600060028152602001908152602001600020819055507fb55212beea0c27733221a3151de625a0f9a00c6435c0ec42102d42180204eb2c81604051610a139190614e95565b60606108436113bc610f7c565b63ffffffff8516600090815260039182016020908152604080832060ff8a168452600101825280832087845290930190522061305c565b60006113fd610f7c565b60ff9290921660009081526001909201602052506040902054600160401b900463ffffffff1690565b600061143133610a1f565b15611443575060131936013560601c90565b503390565b90565b6114548461336b565b6000846001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa158015611494573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114b89190614fdd565b90508360ff166000036114e357604051637d34ca9360e01b815260ff85166004820152602401610956565b60006114f18288600d6133eb565b50604051636f8eecbb60e11b8152600481018290529091506000906001600160a01b0384169063df1dd97690602401600060405180830381865afa15801561153d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261156591908101906150af565b5050935050505060038160ff161015611591576040516368dfb41160e11b815260040160405180910390fd5b50600061159d85610dd2565b905060006115a9610f7c565b63ffffffff8316600090815260039190910160209081526040808320868452600581019092529091205490915060ff16156115f757604051637e524e1960e01b815260040160405180910390fd5b611602878787612b1a565b5060008381526005820160209081526040808320805460ff191660ff8c16908117909155835260068401909152902061163b9084613558565b50604080516001600160a01b038b16815260ff8916602082015290810184905263ffffffff831660608201527f5e1c8323b6cf985eec8241831ea88c82e70a972471b5f5b9afcb5fc46b5eb24a9060800160405180910390a1505050505050505050565b6000610b2b6116ac610f7c565b63ffffffff861660009081526003919091016020908152604080832060ff8a1684526001019091528120600501906116e4868661326a565b815260200190815260200160002080546116fd90615151565b80601f016020809104026020016040519081016040528092919081815260200182805461172990615151565b80156117765780601f1061174b57610100808354040283529160200191611776565b820191906000526020600020905b81548152906001019060200180831161175957829003601f168201915b50505050506040015190565b61178a61491d565b611792610f7c565b63ffffffff9384166000908152600391909101602090815260408083206001600160a01b0395909516835293815290839020835160e081018552905460ff80821683526101008204871693830193909352600160281b810490951693810193909352600160481b84046001600160401b03166060840152600160881b840481166080840152600160901b84041660a083015250600160981b90910465ffffffffffff1660c082015290565b6060611847610f7c565b63ffffffff851660009081526003919091016020908152604080832060ff8916845260010190915281206005019061187f858561326a565b8152602001908152602001600020805461189890615151565b80601f01602080910402602001604051908101604052809291908181526020018280546118c490615151565b80156119115780601f106118e657610100808354040283529160200191611911565b820191906000526020600020905b8154815290600101906020018083116118f457829003601f168201915b50505050509050949350505050565b6119298761336b565b611931614959565b876001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa15801561196f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119939190614fdd565b81606001906001600160a01b031690816001600160a01b031681525050876001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190614fdd565b81608001906001600160a01b031690816001600160a01b031681525050876001600160a01b0316628e96916040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a6c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a909190614fdd565b6001600160a01b031660a0820152611aa783610dd2565b63ffffffff16602082018190526060820151611ac7918b91906001613564565b60ff1682526101208201526040516331a9108f60e11b8152600481018790526001600160a01b038a81169190891690636352211e90602401602060405180830381865afa158015611b1c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b409190614fdd565b6001600160a01b031614611b6b57868660405163547208b960e11b8152600401610956929190614f88565b80608001516001600160a01b0316631789b7b1886040518263ffffffff1660e01b8152600401611b9b9190614e95565b602060405180830381865afa158015611bb8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bdc919061518b565b60ff16600003611c01578660405163adc7fced60e01b81526004016109569190614e95565b876001600160a01b0316632f91ede96040518163ffffffff1660e01b8152600401602060405180830381865afa158015611c3f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c639190614fdd565b6001600160a01b0316635451da1b88886040518363ffffffff1660e01b8152600401611c90929190614f88565b602060405180830381865afa158015611cad573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cd191906151a8565b15611cf3578686604051634f38de4760e11b8152600401610956929190614f88565b8060a001516001600160a01b031663f16a306688886040518363ffffffff1660e01b8152600401611d25929190614f88565b602060405180830381865afa158015611d42573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6691906151a8565b611d8757868660405163033aace360e41b8152600401610956929190614f88565b608081015160405163dec38e7760e01b81526001916001600160a01b03169063dec38e7790611dbc908b908b90600401614f88565b602060405180830381865afa158015611dd9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611dfd919061518b565b60ff1603611e1e57604051631ed7101960e21b815260040160405180910390fd5b876001600160a01b031663683fedf76040518163ffffffff1660e01b8152600401602060405180830381865afa158015611e5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e809190614fdd565b6001600160a01b0316639a641e0288886040518363ffffffff1660e01b8152600401611ead929190614f88565b602060405180830381865afa158015611eca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611eee91906151ca565b6001600160401b031615611f145760405162dc1c0b60e01b815260040160405180910390fd5b608081015160405163ec5316b560e01b81526001916001600160a01b03169063ec5316b590611f49908b908b90600401614f88565b602060405180830381865afa158015611f66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f8a91906151e5565b1115611fa957604051639928185760e01b815260040160405180910390fd5b60a0810151604051631a95890960e31b81526000916001600160a01b03169063d4ac484890611fde908b908b90600401614f88565b60a060405180830381865afa158015611ffb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061201f91906151fe565b51905061202a612a33565b8163ffffffff16101561205857604051634bebee7f60e01b815263ffffffff82166004820152602401610956565b508051612066908484612b1a565b506000612071610f7c565b60208381015163ffffffff9081166000908152600393909301825260408084206001600160a01b038f16855280845293819020815160e081018352905460ff80821683526101008204851695830195909552600160281b810490931691810191909152600160481b82046001600160401b03166060820152600160881b820483166080820152600160901b8204831660a0820152600160981b90910465ffffffffffff1660c0820152610140850181905251919250161561215257610140820151516040516321da897960e11b815260ff9091166004820152602401610956565b612161600163ffffffff615295565b63ffffffff168261014001516040015163ffffffff16106121a35760208201516040516305eee3b960e11b815263ffffffff9091166004820152602401610956565b815160ff16600090815260018201602052604090206121c2898961326a565b604084015260006121d4886040015190565b905080156121f55760405163d860955b60e01b815260040160405180910390fd5b6040808501516000908152600584016020522061221289826152ff565b50506040808401516101208501516000908152600484016020529190912061223b918d9061366e565b50604083015161224f906003840190613558565b506040805160e081018252845160ff1681526000602082015261014085015182015190918201906122819060016153be565b63ffffffff1681526020018461012001516001600160401b03168152602001600060ff1681526020018760ff168152602001600065ffffffffffff168152508260000160008d6001600160a01b03166001600160a01b0316815260200190815260200160002060008201518160000160006101000a81548160ff021916908360ff16021790555060208201518160000160016101000a81548163ffffffff021916908363ffffffff16021790555060408201518160000160056101000a81548163ffffffff021916908363ffffffff16021790555060608201518160000160096101000a8154816001600160401b0302191690836001600160401b0316021790555060808201518160000160116101000a81548160ff021916908360ff16021790555060a08201518160000160126101000a81548160ff021916908360ff16021790555060c08201518160000160136101000a81548165ffffffffffff021916908365ffffffffffff1602179055509050507f2521d98b2c88e19cb124cca9f2860404ff4e038f074120bbc3d69e2c751ffc928b8461012001518b8b87602001518860000151604051612476969594939291906001600160a01b0396871681526020810195909552929094166040840152606083015263ffffffff92909216608082015260ff9190911660a082015260c00190565b60405180910390a1612498836060015184600001518486610120015188613684565b61010086015260e08501526001600160a01b031660c084018190526124dd57610120830151600090815260038201602052604090206124d7908c613786565b50612544565b6040518060800160405280846020015163ffffffff1681526020018a6001600160a01b031681526020018981526020018460e001518152508361016001819052506125448360000151838d8660c0015187610120015188610100015189610160015161379b565b5050505050505050505050565b60008061255c610f7c565b63ffffffff8416600090815260039190910160209081526040808320878452600581019092529091205490915060ff1680156125c35760ff81166000908152600183016020908152604080832088845260040190915290206125be9087613c49565b610ff7565b50600095945050505050565b6000806106f66125dd610f7c565b60ff851660009081526001919091016020908152604091829020825160608101845290546001600160401b0381168252600160401b810463ffffffff1692820192909252600160601b90910461ffff1691810191909152612f49565b612642826132df565b8061264b610f7c565b6001600090815260209182526040908190209290925590518281527fee3ba0763748d6e285026c82cf5f0233531ace4040dce0d5c4434c55bf5cd9399101610a13565b610ba4838383612b1a565b6126a28361336b565b6040805160c081018252600080825260208201819052918101829052606081018290526080810182905260a0810191909152836001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa158015612712573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127369190614fdd565b6001600160a01b0316606082015261274d83610dd2565b63ffffffff1660208201819052606082015161276d918791906001613564565b60ff16825250600061277d610f7c565b60208381015163ffffffff9081166000908152600393909301825260408084206001600160a01b038b16855280845293819020815160e081018352905460ff80821683526101008204851695830195909552600160281b810490931691810191909152600160481b82046001600160401b03166060820152600160881b820483166080820152600160901b820490921660a0830152600160981b900465ffffffffffff1660c082015290915061283281613c5e565b612854836060015184600001518484606001516001600160401b031688613684565b60a086015260808501526001600160a01b03166040840181905261288b57604051633381fb0d60e01b815260040160405180910390fd5b805160ff166000908152600183016020526040812060608301516128b991906001600160401b03168a613cac565b90506129228460000151848a876040015186606001516001600160401b03168960a0015160405180608001604052808c6020015163ffffffff16815260200189600001516001600160a01b03168152602001896020015181526020018c6080015181525061379b565b5050505050505050565b6129358261336b565b600061294082610dd2565b9050600061294c610f7c565b63ffffffff8381166000908152600392909201602090815260408084206001600160a01b038a16855280835293819020815160e081018352905460ff80821683526101008204861694830194909452600160281b810490941691810191909152600160481b83046001600160401b03166060820152600160881b830482166080820152600160901b830490911660a0820152600160981b90910465ffffffffffff1660c08201529091506129ff81613c5e565b805160ff1660009081526001808401602052604090912090612a2a9085908590849086908c90613dd1565b50505050505050565b6000612a3d610f7c565b60006001611122565b600080600080612a9785612a58610f7c565b63ffffffff808b1660009081526003929092016020908152604080842060ff8f16855260010182528084208c8552600401909152909120919061409d16565b915091508115612aac57925060a083901c9150825b505094509492505050565b6000612ac1610f7c565b60006002611122565b60006007612ad9836003614fca565b61070e9190615010565b60006350877ed6461480612afa5750630235ddd046145b15611448576040518060208160008060185afa612b1357fe5b5051905090565b6040805160608101825260008082526020820181905291810191909152612b3f610f7c565b60ff8516600090815260019190910160209081526040808320815160608101835290546001600160401b0381168252600160401b810463ffffffff1693820193909352600160601b90920461ffff16908201529150612b9d84610dd2565b9050816020015163ffffffff16600003612c6c5763ffffffff8116602083015281612bc6610f7c565b60ff8716600081815260019290920160209081526040928390208451815486840151968601516001600160401b039092166001600160601b031990911617600160401b63ffffffff978816021761ffff60601b1916600160601b61ffff909216919091021790558251918252928416928101929092527f1122d4fb8516daedc106927e0acc4baf5f6be5f82112b501be8790859c3d4d9b910160405180910390a1612f41565b816020015163ffffffff168163ffffffff1614612f41576000612cc1612c90610f7c565b60208086015163ffffffff1660009081526003929092018152604080832060ff8b168452600601909152902061305c565b90506000612cdb87856020015163ffffffff1684886140b5565b905080600003612cf2575082516001600160401b03165b83516001600160401b03168114612e1b576000612d0d610f7c565b60008381526002919091016020526040902054855160ff90911691506001600160401b031615612d6557612d3f610f7c565b85516001600160401b0316600090815260029190910160205260409020805460ff191690555b60ff811615612dec576000612d78610f7c565b60ff8316600090815260019190910160205260408120805467ffffffffffffffff19166001600160401b039390931692909217909155612db6610f7c565b60ff8316600090815260019190910160205260409020805461ffff92909216600160601b0261ffff60601b199092169190911790555b87612df5610f7c565b600084815260029190910160205260409020805460ff191660ff92909216919091179055505b6040518060600160405280826001600160401b031681526020018463ffffffff16815260200185600001516001600160401b031683148015612e5c57508215155b612e67576000612e85565b6020860151612e769086615295565b8660400151612e8591906153db565b61ffff169052935083612e96610f7c565b60ff8916600081815260019290920160209081526040928390208451815486840151968601516001600160401b039092166001600160601b031990911617600160401b63ffffffff978816021761ffff60601b1916600160601b61ffff9092169190910217905582519182529286169281019290925281018290527f1ffb10ddeed1be3e5ce0225fdd14d2df110d52b970118a7f9d58de2ecce3c0629060600160405180910390a150505b509392505050565b80516001600160401b031660008115612f64576103e8612f67565b60005b90508115613057576000612f79610f7c565b60026000908152602091909152604090205490506001600160a01b03811615613055576040516306d71c2560e51b8152600481018490526000906001600160a01b0383169063dae384a090602401602060405180830381865afa158015612fe4573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061300891906151e5565b9050670de0b6b3a764000061302582670de0b6b3a764000061432d565b6130336103e8612710614fb7565b61303d91906153f6565b6130479190615010565b6130519084614fca565b9250505b505b915091565b60606000610e9883614343565b61307161439f565b610c3757604051631afcd79f60e31b815260040160405180910390fd5b6001600160a01b0381166130d65760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b6044820152606401610956565b613105816109a760017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618614fb7565b613134426109a760017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b614fb7565b613163436109a760017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1614fb7565b604080516001600160a01b0383168152426020820152438183015290517f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe2367134269181900360600190a150565b60008080806131bc86866143b9565b909450925050505b9250929050565b336001600160a01b0316816001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa158015613213573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132379190614fdd565b6001600160a01b03161461085c576040516302619f2b60e51b815260040160405180910390fd5b600061070b83836143fb565b60006001600160401b0382111561329757604051633995b34160e01b815260048101839052602401610956565b5067ffffffffffffffff60a01b60a09190911b166001600160a01b039091161790565b6000818152600183016020526040812054151561070b565b60606000610e98836144f5565b604051631430d62960e21b81526001600160a01b038216906350c358a49061330b903390600401614e95565b602060405180830381865afa158015613328573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061334c91906151a8565b61085c573360405163451cea1760e11b81526004016109569190614e95565b806001600160a01b03166318d928316040518163ffffffff1660e01b8152600401602060405180830381865afa1580156133a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133cd91906151a8565b1561085c57604051635e1633d360e11b815260040160405180910390fd5b600080846001600160a01b0316633b4c9891856040518263ffffffff1660e01b815260040161341a9190614e95565b602060405180830381865afa158015613437573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061345b91906151e5565b6040516373cf874b60e11b81529092506001600160a01b0386169063e79f0e969061348a908790600401614e95565b602060405180830381865afa1580156134a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134cb91906151e5565b9050816000036134ee57604051632f6c853960e11b815260040160405180910390fd5b6134fa600060026154e9565b8116151580613526575082600d81111561351657613516614cd9565b6135219060026154e9565b811615155b610ec05782600d81111561353c5761353c614cd9565b604051630d816ed160e01b815260040161095691815260200190565b600061070b8383614500565b600080846001600160a01b0316633b4c9891876040518263ffffffff1660e01b81526004016135939190614e95565b602060405180830381865afa1580156135b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135d491906151e5565b91508280156135e1575081155b156135ff57604051632f6c853960e11b815260040160405180910390fd5b811561363d5761360d610f7c565b63ffffffff851660009081526003919091016020908152604080832085845260050190915290205460ff16613640565b60005b9050828015613650575060ff8116155b15610d8f57604051632e8e6b7560e11b815260040160405180910390fd5b6000610843846001600160a01b0385168461454f565b600080600080886001600160a01b031663df1dd976876040518263ffffffff1660e01b81526004016136b891815260200190565b600060405180830381865afa1580156136d5573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526136fd91908101906150af565b5050935050505060038160ff161061377a5760ff88166000908152600188016020908152604080832060068b0190925290912061373e908b90838a8a61456c565b925082156137785761375181848861472b565b909550935060008490036137785760405163d92e233d60e01b815260040160405180910390fd5b505b50955095509592505050565b600061070b836001600160a01b038416614500565b6001600160a01b0385811660009081526002880160209081526040808320815160a08101835289861681526001818501818152938201869052606082018690526080820186905282549081018355918552929093208251930180546001600160a01b0319811694909516938417815590519193909283916001600160a81b03191617600160a01b83600481111561383457613834614cd9565b0217905550604082810151825460608086015160809687015160ff16600160e81b0260ff60e81b1963ffffffff928316600160c81b0263ffffffff60c81b1993909616600160a81b029290921667ffffffffffffffff60a81b19909416939093179390931792909216179092556001600160a01b03878116600090815260028b016020908152838220845160a0810186528c85168152600181840181815296820185905296810184905296870183905280549586018155825290208451930180546001600160a01b031981169490921693841781559151919283916001600160a81b03191617600160a01b83600481111561393157613931614cd9565b021790555060408201518154606084015160809094015167ffffffffffffffff60a81b19909116600160a81b63ffffffff9384160263ffffffff60c81b191617600160c81b92909416919091029290921760ff60e81b1916600160e81b60ff9093169290920291909117905560006139a76147af565b9050866002016000876001600160a01b03166001600160a01b0316815260200190815260200160002080549050876000016000886001600160a01b03166001600160a01b0316815260200190815260200160002060000160016101000a81548163ffffffff021916908363ffffffff16021790555080876000016000886001600160a01b03166001600160a01b0316815260200190815260200160002060000160136101000a81548165ffffffffffff021916908365ffffffffffff160217905550866002016000866001600160a01b03166001600160a01b0316815260200190815260200160002080549050876000016000876001600160a01b03166001600160a01b0316815260200190815260200160002060000160016101000a81548163ffffffff021916908363ffffffff16021790555080876000016000876001600160a01b03166001600160a01b0316815260200190815260200160002060000160136101000a81548165ffffffffffff021916908365ffffffffffff160217905550613b6a868860010160008b60ff1660ff16815260200190815260200160002060030160008781526020019081526020016000206147fe90919063ffffffff16565b5060ff8816600090815260018801602090815260408083208684526003019091529020613b9790866147fe565b50600080613bac84606001519060a082901c90565b85516020808801516040808a0151815165ffffffffffff8b16815263ffffffff909516938501939093526001600160a01b03918216908401526060830191909152608082018a9052831660a082015260c0810182905260e0810188905291935091507fd7da27827582ad8f7f3f4fc8a20f7be83108736c88b28aa3b41dccf6ad6e877990610100015b60405180910390a150505050505050505050565b600061070b836001600160a01b038416614813565b805160ff16600003613c83576040516315e0349160e11b815260040160405180910390fd5b602081015163ffffffff161561085c576040516366fab05760e01b815260040160405180910390fd5b60408051606080820183526000808352602083015291810191909152600083815260048501602052604081208190613ce4908561409d565b9150915081613d0957600060405163adc7fced60e01b81526004016109569190614e95565b808060a081901c6020808701919091526001600160a01b039091168552600082815260058901909152604090208054613d4190615151565b80601f0160208091040260200160405190810160405280929190818152602001828054613d6d90615151565b8015613dba5780601f10613d8f57610100808354040283529160200191613dba565b820191906000526020600020905b815481529060010190602001808311613d9d57829003601f168201915b505050505084604001819052505050509392505050565b60608301516001600160401b031660009081526004850160205260408120819081908190613dff908761409d565b915091508115613e4b5760608701516001600160401b031660009081526004890160205260409020613e31908761481f565b50613e3f60038a018261325e565b50925060a083901c9150825b60608701516001600160401b031660009081526003890160205260409020613e7390876147fe565b506040518060e00160405280600060ff168152602001600063ffffffff168152602001886040015163ffffffff16815260200160006001600160401b03168152602001600060ff168152602001600060ff168152602001600065ffffffffffff16815250896000016000886001600160a01b03166001600160a01b0316815260200190815260200160002060008201518160000160006101000a81548160ff021916908360ff16021790555060208201518160000160016101000a81548163ffffffff021916908363ffffffff16021790555060408201518160000160056101000a81548163ffffffff021916908363ffffffff16021790555060608201518160000160096101000a8154816001600160401b0302191690836001600160401b0316021790555060808201518160000160116101000a81548160ff021916908360ff16021790555060a08201518160000160126101000a81548160ff021916908360ff16021790555060c08201518160000160136101000a81548165ffffffffffff021916908365ffffffffffff1602179055509050507f43123e2ba4590155d8a1fddade2bb91cc46a6ce2a49d8fba12fdeae963bc7be88688606001518c8a6000015188888b604051613c3597969594939291906001600160a01b0397881681526001600160401b0396909616602087015263ffffffff94909416604086015260ff929092166060850152909316608083015260a082019290925290151560c082015260e00190565b60008080806131bc866001600160a01b0387166143b9565b815160009081816001600160401b038111156140d3576140d3614a6d565b6040519080825280602002602001820160405280156140fc578160200160208202803683370190505b509050600080600061410c610f7c565b60008a81526003919091016020908152604080832060ff8e168452600101909152812091505b8581101561422b5760008061416c8b848151811061415257614152615038565b6020026020010151856000016131ad90919063ffffffff16565b9150915081801561417c57508015155b15614221578087848151811061419457614194615038565b60209081029190910101528515806141ce575080876141b4600189614fb7565b815181106141c4576141c4615038565b6020026020010151105b156141e9576141de836001614fca565b955060019450614221565b80876141f6600189614fb7565b8151811061420657614206615038565b602002602001015103614221578461421d816154f5565b9550505b5050600101614132565b508215614320576000826001146142585761425361424a600185614fb7565b8963ffffffff16565b61425b565b60005b9050806000036142905788614271600186614fb7565b8151811061428157614281615038565b6020026020010151965061431e565b835b8681101561431c57856142a6600187614fb7565b815181106142b6576142b6615038565b60200260200101518682815181106142d0576142d0615038565b6020026020010151036143145781600103614306578981815181106142f7576142f7615038565b6020026020010151975061431c565b816143108161550e565b9250505b600101614292565b505b505b5050505050949350505050565b600081831061433c578161070b565b5090919050565b60608160000180548060200260200160405190810160405280929190818152602001828054801561439357602002820191906000526020600020905b81548152602001906001019080831161437f575b50505050509050919050565b60006143a9610f47565b54600160401b900460ff16919050565b60008181526002830160205260408120548190806143e8576143db8585614813565b9250600091506131c49050565b6001925090506131c4565b509250929050565b600081815260018301602052604081205480156144e457600061441f600183614fb7565b855490915060009061443390600190614fb7565b905080821461449857600086600001828154811061445357614453615038565b906000526020600020015490508087600001848154811061447657614476615038565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806144a9576144a9615525565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061070e565b600091505061070e565b5092915050565b606061070e8261305c565b60008181526001830160205260408120546145475750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561070e565b50600061070e565b600082815260028401602052604081208290556108438484613558565b60008061457886614834565b9050600181111561472157600061459c614593600184614fb7565b8563ffffffff16565b9050805b60006145ac898361483e565b604051636f8eecbb60e11b8152600481018290529091506000906001600160a01b038c169063df1dd97690602401600060405180830381865afa1580156145f7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261461f91908101906150af565b5050935050505060038160ff16101580156146515750600082815260038a016020526040902061464e90614834565b15155b801561465d5750818814155b80156146d65750604051630562452b60e21b815260048101899052602481018390526001600160a01b038c169063158914ac90604401602060405180830381865afa1580156146b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146d491906151a8565b155b156146e35750935061471e565b846146ef846001614fca565b14614704576146ff836001614fca565b614707565b60005b925083830361471757505061471e565b50506145a0565b50505b5095945050505050565b6000828152600384016020526040812081908161474782614834565b905080156147a55760008160011461477557614770614767600184614fb7565b8763ffffffff16565b614778565b60005b9050614784838261483e565b600088815260048a01602052604090209095506147a1908661484a565b9350505b5050935093915050565b60006147b9610f7c565b6003600090815260209190915260409020546147d690600161553b565b90508065ffffffffffff166147e9610f7c565b60036000908152602091909152604090205590565b600061070b836001600160a01b0384166143fb565b600061070b83836132ba565b600061070b836001600160a01b03841661485f565b600061070e825490565b600061070b838361487c565b600061070b836001600160a01b0384166148a6565b6000818152600283016020526040812081905561070b838361325e565b600082600001828154811061489357614893615038565b9060005260206000200154905092915050565b6000818152600283016020526040812054801580156148cc57506148ca8484614813565b155b1561070b5760405163015ab34360e11b815260048101849052602401610956565b6040805160a081019091526000808252602082019081526000602082018190526040820181905260609091015290565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c081019190915290565b6040805161018081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081019190915261014081016149b761491d565b81526040805160808101825260008082526020828101829052928201819052606082015291015290565b60ff8116811461085c57600080fd5b600060208284031215614a0257600080fd5b813561070b816149e1565b63ffffffff8116811461085c57600080fd5b6001600160a01b038116811461085c57600080fd5b60008060408385031215614a4757600080fd5b8235614a5281614a0d565b91506020830135614a6281614a1f565b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715614aab57614aab614a6d565b604052919050565b60006001600160401b03821115614acc57614acc614a6d565b50601f01601f191660200190565b600082601f830112614aeb57600080fd5b8135614afe614af982614ab3565b614a83565b818152846020838601011115614b1357600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060808587031215614b4657600080fd5b8435614b5181614a1f565b93506020850135614b6181614a1f565b92506040850135915060608501356001600160401b03811115614b8357600080fd5b614b8f87828801614ada565b91505092959194509250565b60008060408385031215614bae57600080fd5b8235614bb9816149e1565b91506020830135614a6281614a0d565b6020808252825182820181905260009190848201906040850190845b81811015614c0157835183529284019291840191600101614be5565b50909695505050505050565b600060208284031215614c1f57600080fd5b813561070b81614a1f565b600080600060608486031215614c3f57600080fd5b8335614c4a816149e1565b92506020840135614c5a81614a0d565b929592945050506040919091013590565b600060208284031215614c7d57600080fd5b5035919050565b60008060408385031215614c9757600080fd5b823591506020830135614a6281614a0d565b600080600060608486031215614cbe57600080fd5b8335614cc981614a0d565b92506020840135614c5a81614a1f565b634e487b7160e01b600052602160045260246000fd5b81516001600160a01b03168152602082015160a082019060058110614d2457634e487b7160e01b600052602160045260246000fd5b80602084015250604083015163ffffffff8082166040850152806060860151166060850152505060ff608084015116608083015292915050565b600080600060608486031215614d7357600080fd5b8335614d7e81614a1f565b9250602084013591506040840135614d9581614a0d565b809150509250925092565b6020808252825182820181905260009190848201906040850190845b81811015614c015783516001600160a01b031683529284019291840191600101614dbc565b60008060008060808587031215614df757600080fd5b8435614e02816149e1565b93506020850135614e1281614a0d565b92506040850135614e2281614a1f565b9396929550929360600135925050565b60005b83811015614e4d578181015183820152602001614e35565b50506000910152565b60008151808452614e6e816020860160208601614e32565b601f01601f19169290920160200192915050565b60208152600061070b6020830184614e56565b6001600160a01b0391909116815260200190565b60008060008060808587031215614ebf57600080fd5b8435614eca81614a1f565b93506020850135925060408501356001600160401b03811115614eec57600080fd5b614ef887828801614ada565b9250506060850135614f09816149e1565b939692955090935050565b60008060408385031215614f2757600080fd5b8235614f3281614a1f565b946020939093013593505050565b60008060008060808587031215614f5657600080fd5b8435614f61816149e1565b93506020850135614f7181614a0d565b9250604085013591506060850135614f0981614a1f565b6001600160a01b03929092168252602082015260400190565b634e487b7160e01b600052601160045260246000fd5b8181038181111561070e5761070e614fa1565b8082018082111561070e5761070e614fa1565b600060208284031215614fef57600080fd5b815161070b81614a1f565b634e487b7160e01b600052601260045260246000fd5b60008261501f5761501f614ffa565b500490565b60008261503357615033614ffa565b500690565b634e487b7160e01b600052603260045260246000fd5b600082601f83011261505f57600080fd5b815161506d614af982614ab3565b81815284602083860101111561508257600080fd5b610843826020830160208701614e32565b80516001600160401b03811681146150aa57600080fd5b919050565b60008060008060008060c087890312156150c857600080fd5b86516001600160401b03808211156150df57600080fd5b6150eb8a838b0161504e565b9750602089015191508082111561510157600080fd5b5061510e89828a0161504e565b955050604087015161511f81614a1f565b6060880151909450615130816149e1565b925061513e60808801615093565b915060a087015190509295509295509295565b600181811c9082168061516557607f821691505b60208210810361518557634e487b7160e01b600052602260045260246000fd5b50919050565b60006020828403121561519d57600080fd5b815161070b816149e1565b6000602082840312156151ba57600080fd5b8151801515811461070b57600080fd5b6000602082840312156151dc57600080fd5b61070b82615093565b6000602082840312156151f757600080fd5b5051919050565b600060a0828403121561521057600080fd5b60405160a081018181106001600160401b038211171561523257615232614a6d565b604052825161524081614a0d565b8152602083015161525081614a0d565b6020820152604083015161526381614a0d565b6040820152606083015161527681614a0d565b6060820152608083015161528981614a0d565b60808201529392505050565b63ffffffff8281168282160390808211156144ee576144ee614fa1565b601f8211156152fa576000816000526020600020601f850160051c810160208610156152db5750805b601f850160051c820191505b8181101561082e578281556001016152e7565b505050565b81516001600160401b0381111561531857615318614a6d565b61532c816153268454615151565b846152b2565b602080601f83116001811461536157600084156153495750858301515b600019600386901b1c1916600185901b17855561082e565b600085815260208120601f198616915b8281101561539057888601518255948401946001909101908401615371565b50858210156153ae5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b63ffffffff8181168382160190808211156144ee576144ee614fa1565b61ffff8181168382160190808211156144ee576144ee614fa1565b808202811582820484141761070e5761070e614fa1565b600181815b808511156143f357816000190482111561542e5761542e614fa1565b8085161561543b57918102915b93841c9390800290615412565b6000826154575750600161070e565b816154645750600061070e565b816001811461547a5760028114615484576154a0565b600191505061070e565b60ff84111561549557615495614fa1565b50506001821b61070e565b5060208310610133831016604e8410600b84101617156154c3575081810a61070e565b6154cd838361540d565b80600019048211156154e1576154e1614fa1565b029392505050565b600061070b8383615448565b60006001820161550757615507614fa1565b5060010190565b60008161551d5761551d614fa1565b506000190190565b634e487b7160e01b600052603160045260246000fd5b65ffffffffffff8181168382160190808211156144ee576144ee614fa156fe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda26469706673582212204affa8f29f3c0492de33f003f072fc29d6cb8c9e4e5b2760f520527e986d3ea264736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106102555760003560e01c80637cc9638011610147578063cb80c82f116100be578063cb80c82f1461062e578063ce24c6e514610641578063ce4a79a914610654578063d2336d2e14610667578063d49e18be1461066f578063dee1f0e414610682578063e22d24af14610695578063e89acf061461069d578063f2f17ec8146106a5578063f77c4791146106c6578063f88cb61d146106ce578063ffa1ad741461058957600080fd5b80637cc96380146104b9578063859ec734146104c1578063901bccda146104d457806390c928cd146104e757806390e52dc3146104fa578063936725ec14610589578063991bb818146105ba5780639d0bcca0146105cd578063a399f0d7146105e2578063b2c56c9b146105f5578063b429afeb14610608578063c5beb1e01461061b57600080fd5b80633349eafa116101db5780633349eafa146103a357806342be39a4146103b6578063454ac5c8146103dc5780634593144c146103ef57806347ff6204146103f75780634fac6ccd14610417578063572b6c051461042a5780635ecd46781461044d57806361aa8057146104605780636672009e1461047357806371c2b99c146104935780637a5654d8146104a657600080fd5b806306575c891461025a5780630984b3cb1461027c5780630abb07c3146102a4578063150b7a02146102c55780631518fc25146102fc57806319ab453c1461031c5780631b541a351461033157806325b3b32c146103445780632b529bde146103575780632fe7b1b51461037c578063325a19f11461039b575b600080fd5b6102626106d6565b60405163ffffffff90911681526020015b60405180910390f35b61028f61028a3660046149f0565b6106e6565b60408051928352602083019190915201610273565b6102b76102b2366004614a34565b6106ff565b604051908152602001610273565b6102e36102d3366004614b30565b630a85bd0160e11b949350505050565b6040516001600160e01b03199091168152602001610273565b61030f61030a366004614b9b565b610714565b6040516102739190614bc9565b61032f61032a366004614c0d565b610720565b005b6102b761033f366004614c2a565b610836565b61032f610352366004614c6b565b61084b565b61036a610365366004614c6b565b61085f565b60405160ff9091168152602001610273565b61038461086a565b60405165ffffffffffff9091168152602001610273565b6102b7610874565b61036a6103b1366004614c84565b6108a8565b6103c96103c43660046149f0565b6108b4565b60405161ffff9091168152602001610273565b6102626103ea366004614c6b565b6108bf565b6102b76108ca565b61040a610405366004614ca9565b6108fa565b6040516102739190614cef565b61032f610425366004614c0d565b61090d565b61043d610438366004614c0d565b610a1f565b6040519015158152602001610273565b61043d61045b366004614d5e565b610a94565b6102b761046e3660046149f0565b610aa1565b610486610481366004614c2a565b610aac565b6040516102739190614da0565b61032f6104a1366004614c0d565b610ab9565b6104866104b4366004614c2a565b610aca565b6102b7610ad7565b6102626104cf3660046149f0565b610af5565b61032f6104e23660046149f0565b610b00565b6102b76104f5366004614de1565b610b1d565b61050d610508366004614a34565b610b34565b6040516102739190600060e08201905060ff8351168252602083015163ffffffff808216602085015280604086015116604085015250506001600160401b03606084015116606083015260ff608084015116608083015260ff60a08401511660a083015265ffffffffffff60c08401511660c083015292915050565b6105ad604051806040016040528060058152602001640312e302e360dc1b81525081565b6040516102739190614e82565b6105ad6105c8366004614de1565b610b46565b6105d5610b54565b6040516102739190614e95565b61032f6105f0366004614ea9565b610b84565b61043d610603366004614d5e565b610baa565b61043d610616366004614c0d565b610bb7565b61028f6106293660046149f0565b610bdc565b61032f61063c366004614c6b565b610be8565b61032f61064f3660046149f0565b610bf9565b61043d610662366004614f14565b610c06565b61032f610c1b565b61032f61067d3660046149f0565b610c39565b61043d610690366004614c0d565b610cd3565b61032f610d58565b6102b7610d71565b6106b86106b3366004614f40565b610d7b565b604051610273929190614f88565b6105d5610d98565b6105d5610dc8565b60006106e142610dd2565b905090565b6000806106f68342610def610e9f565b91509150915091565b600061070b8383610ec8565b90505b92915050565b606061070b8383610f0b565b600061072a610f47565b805490915060ff600160401b82041615906001600160401b03166000811580156107515750825b90506000826001600160401b0316600114801561076d5750303b155b90508115801561077b575080155b156107995760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff1916600117855583156107c357845460ff60401b1916600160401b1785555b6107cc86610f6b565b60056107d6610f7c565b600160009081526020919091526040902055831561082e57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b6000610843848484610fa0565b949350505050565b61085c610856610d98565b82611001565b50565b600061070e826110f2565b60006106e1611113565b60006106e16108a460017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b614fb7565b5490565b600061070b8383611147565b600061070e82611181565b600061070e82610dd2565b60006106e16108a460017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1614fb7565b6109026148ed565b6108438484846111b2565b33301461095f5760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b600061097d6108a4600160008051602061555b833981519152614fb7565b610988906001614fca565b90506109aa816109a7600160008051602061555b833981519152614fb7565b55565b6109d9826109a760017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4614fb7565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c891015b60405180910390a15050565b60006001600160a01b03821673d8253782c45a12053594b9deb72d8e8ab2fca54c1480610a6857506001600160a01b0382167352ceba41da235af367bfc0b0ccd3314cb901bb5f145b8061070e57506001600160a01b03821673102f1f556cd9c3d5f820e6920a8931657c5da21b1492915050565b600061084384848461129b565b600061070e826112d9565b6060610843848484611308565b61085c610ac4610d98565b8261134f565b60606108438484846113af565b60006106e16108a4600160008051602061555b833981519152614fb7565b600061070e826113f3565b61085c610b0b611426565b610b13610d98565b8342610def61144b565b6000610b2b8585858561169f565b95945050505050565b610b3c61491d565b61070b8383611782565b6060610b2b8585858561183d565b60006106e16108a460017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e4614fb7565b610ba4610b8f611426565b610b97610d98565b8686868642610def611920565b50505050565b6000610843848484612551565b6000610bc1610d98565b6001600160a01b0316826001600160a01b0316149050919050565b6000806106f6836125cf565b61085c610bf3610d98565b82612639565b61085c8142610def61268e565b600061070b8383610c1642610dd2565b61129b565b610c37610c26611426565b610c2e610d98565b42610def612699565b565b73__$695852aadc1d4ca48ce3d505359eaf15eb$__638eb687a9610c5b611426565b610c63610d98565b6040516001600160e01b031960e085901b1681526001600160a01b0392831660048201529116602482015242604482015260ff8416606482015260840160006040518083038186803b158015610cb857600080fd5b505af4158015610ccc573d6000803e3d6000fd5b5050505050565b6000816001600160a01b0316610ce7610d98565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d24573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d489190614fdd565b6001600160a01b03161492915050565b610c37610d63611426565b610d6b610d98565b4261292c565b60006106e1612a33565b600080610d8a86868686612a46565b915091505b94509492505050565b60006106e16108a460017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618614fb7565b60006106e1612ab7565b600061070e610de46201518084615010565b63ffffffff16612aca565b600081600003610e0157506000919050565b6000610e0b612ae3565b9050610e18836001614fca565b4340414443423a5a88604051602001610e7598979695949392919097885260609690961b6001600160601b0319166020880152603487019490945260548601929092526074850152609484015260b483015260d482015260f40190565b6040516020818303038152906040528051906020012060001c610e989190615024565b9392505050565b6000806000610eaf868686612b1a565b9050610eba81612f49565b92509250505b935093915050565b6000610ed2610f7c565b63ffffffff84166000908152600391909101602090815260408083206001600160a01b0386168452600201909152902054905092915050565b606061070b610f18610f7c565b63ffffffff841660009081526003919091016020908152604080832060ff88168452600601909152902061305c565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b610f73613069565b61085c8161308e565b7f6750db0cf5db3c73c8abbeff54ef9c65daabbed6967cb68f37e0698f5fc7bb0090565b6000806000610fe584610fb1610f7c565b63ffffffff80891660009081526003929092016020908152604080842060ff8d16855260010190915290912091906131ad16565b9150915081610ff5576000610ff7565b805b9695505050505050565b61100a826131cb565b6000611014610f7c565b600301600061102242610dd2565b63ffffffff1681526020808201929092526040908101600090812085825260058101909352205490915060ff1680156110755760ff811660009081526006830160205260409020611073908461325e565b505b600061107f610f7c565b6000858152600291909101602052604090205460ff1690508015610ccc576110a5610f7c565b600085815260029190910160205260409020805460ff191690556110c7610f7c565b60ff821660009081526001919091016020526040902080546001600160701b03191690555050505050565b60006110fc610f7c565b600092835260020160205250604090205460ff1690565b600061111d610f7c565b600060035b600381111561113357611133614cd9565b815260200190815260200160002054905090565b6000611151610f7c565b63ffffffff9290921660009081526003909201602090815260408084209484526005909401905250205460ff1690565b600061118b610f7c565b60ff9290921660009081526001909201602052506040902054600160601b900461ffff1690565b6111ba6148ed565b6111c2610f7c565b63ffffffff85166000908152600391909101602090815260408083206001600160a01b0387168452600201909152902080548390811061120457611204615038565b60009182526020918290206040805160a08101909152910180546001600160a01b03811683529192909190830190600160a01b900460ff16600481111561124d5761124d614cd9565b600481111561125e5761125e614cd9565b81529054600160a81b810463ffffffff9081166020840152600160c81b8204166040830152600160e81b900460ff16606090910152949350505050565b6000806112a6610f7c565b60030160008463ffffffff1681526020019081526020016000209050610b2b6112cf868661326a565b60038301906132ba565b60006112e3610f7c565b60ff90921660009081526001929092016020525060409020546001600160401b031690565b6060610843611315610f7c565b63ffffffff851660009081526003919091016020908152604080832060ff89168452600101825280832086845260040190915290206132d2565b611358826132df565b806001600160a01b031661136a610f7c565b600060028152602001908152602001600020819055507fb55212beea0c27733221a3151de625a0f9a00c6435c0ec42102d42180204eb2c81604051610a139190614e95565b60606108436113bc610f7c565b63ffffffff8516600090815260039182016020908152604080832060ff8a168452600101825280832087845290930190522061305c565b60006113fd610f7c565b60ff9290921660009081526001909201602052506040902054600160401b900463ffffffff1690565b600061143133610a1f565b15611443575060131936013560601c90565b503390565b90565b6114548461336b565b6000846001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa158015611494573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114b89190614fdd565b90508360ff166000036114e357604051637d34ca9360e01b815260ff85166004820152602401610956565b60006114f18288600d6133eb565b50604051636f8eecbb60e11b8152600481018290529091506000906001600160a01b0384169063df1dd97690602401600060405180830381865afa15801561153d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261156591908101906150af565b5050935050505060038160ff161015611591576040516368dfb41160e11b815260040160405180910390fd5b50600061159d85610dd2565b905060006115a9610f7c565b63ffffffff8316600090815260039190910160209081526040808320868452600581019092529091205490915060ff16156115f757604051637e524e1960e01b815260040160405180910390fd5b611602878787612b1a565b5060008381526005820160209081526040808320805460ff191660ff8c16908117909155835260068401909152902061163b9084613558565b50604080516001600160a01b038b16815260ff8916602082015290810184905263ffffffff831660608201527f5e1c8323b6cf985eec8241831ea88c82e70a972471b5f5b9afcb5fc46b5eb24a9060800160405180910390a1505050505050505050565b6000610b2b6116ac610f7c565b63ffffffff861660009081526003919091016020908152604080832060ff8a1684526001019091528120600501906116e4868661326a565b815260200190815260200160002080546116fd90615151565b80601f016020809104026020016040519081016040528092919081815260200182805461172990615151565b80156117765780601f1061174b57610100808354040283529160200191611776565b820191906000526020600020905b81548152906001019060200180831161175957829003601f168201915b50505050506040015190565b61178a61491d565b611792610f7c565b63ffffffff9384166000908152600391909101602090815260408083206001600160a01b0395909516835293815290839020835160e081018552905460ff80821683526101008204871693830193909352600160281b810490951693810193909352600160481b84046001600160401b03166060840152600160881b840481166080840152600160901b84041660a083015250600160981b90910465ffffffffffff1660c082015290565b6060611847610f7c565b63ffffffff851660009081526003919091016020908152604080832060ff8916845260010190915281206005019061187f858561326a565b8152602001908152602001600020805461189890615151565b80601f01602080910402602001604051908101604052809291908181526020018280546118c490615151565b80156119115780601f106118e657610100808354040283529160200191611911565b820191906000526020600020905b8154815290600101906020018083116118f457829003601f168201915b50505050509050949350505050565b6119298761336b565b611931614959565b876001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa15801561196f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119939190614fdd565b81606001906001600160a01b031690816001600160a01b031681525050876001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190614fdd565b81608001906001600160a01b031690816001600160a01b031681525050876001600160a01b0316628e96916040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a6c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a909190614fdd565b6001600160a01b031660a0820152611aa783610dd2565b63ffffffff16602082018190526060820151611ac7918b91906001613564565b60ff1682526101208201526040516331a9108f60e11b8152600481018790526001600160a01b038a81169190891690636352211e90602401602060405180830381865afa158015611b1c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b409190614fdd565b6001600160a01b031614611b6b57868660405163547208b960e11b8152600401610956929190614f88565b80608001516001600160a01b0316631789b7b1886040518263ffffffff1660e01b8152600401611b9b9190614e95565b602060405180830381865afa158015611bb8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bdc919061518b565b60ff16600003611c01578660405163adc7fced60e01b81526004016109569190614e95565b876001600160a01b0316632f91ede96040518163ffffffff1660e01b8152600401602060405180830381865afa158015611c3f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c639190614fdd565b6001600160a01b0316635451da1b88886040518363ffffffff1660e01b8152600401611c90929190614f88565b602060405180830381865afa158015611cad573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cd191906151a8565b15611cf3578686604051634f38de4760e11b8152600401610956929190614f88565b8060a001516001600160a01b031663f16a306688886040518363ffffffff1660e01b8152600401611d25929190614f88565b602060405180830381865afa158015611d42573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6691906151a8565b611d8757868660405163033aace360e41b8152600401610956929190614f88565b608081015160405163dec38e7760e01b81526001916001600160a01b03169063dec38e7790611dbc908b908b90600401614f88565b602060405180830381865afa158015611dd9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611dfd919061518b565b60ff1603611e1e57604051631ed7101960e21b815260040160405180910390fd5b876001600160a01b031663683fedf76040518163ffffffff1660e01b8152600401602060405180830381865afa158015611e5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e809190614fdd565b6001600160a01b0316639a641e0288886040518363ffffffff1660e01b8152600401611ead929190614f88565b602060405180830381865afa158015611eca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611eee91906151ca565b6001600160401b031615611f145760405162dc1c0b60e01b815260040160405180910390fd5b608081015160405163ec5316b560e01b81526001916001600160a01b03169063ec5316b590611f49908b908b90600401614f88565b602060405180830381865afa158015611f66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f8a91906151e5565b1115611fa957604051639928185760e01b815260040160405180910390fd5b60a0810151604051631a95890960e31b81526000916001600160a01b03169063d4ac484890611fde908b908b90600401614f88565b60a060405180830381865afa158015611ffb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061201f91906151fe565b51905061202a612a33565b8163ffffffff16101561205857604051634bebee7f60e01b815263ffffffff82166004820152602401610956565b508051612066908484612b1a565b506000612071610f7c565b60208381015163ffffffff9081166000908152600393909301825260408084206001600160a01b038f16855280845293819020815160e081018352905460ff80821683526101008204851695830195909552600160281b810490931691810191909152600160481b82046001600160401b03166060820152600160881b820483166080820152600160901b8204831660a0820152600160981b90910465ffffffffffff1660c0820152610140850181905251919250161561215257610140820151516040516321da897960e11b815260ff9091166004820152602401610956565b612161600163ffffffff615295565b63ffffffff168261014001516040015163ffffffff16106121a35760208201516040516305eee3b960e11b815263ffffffff9091166004820152602401610956565b815160ff16600090815260018201602052604090206121c2898961326a565b604084015260006121d4886040015190565b905080156121f55760405163d860955b60e01b815260040160405180910390fd5b6040808501516000908152600584016020522061221289826152ff565b50506040808401516101208501516000908152600484016020529190912061223b918d9061366e565b50604083015161224f906003840190613558565b506040805160e081018252845160ff1681526000602082015261014085015182015190918201906122819060016153be565b63ffffffff1681526020018461012001516001600160401b03168152602001600060ff1681526020018760ff168152602001600065ffffffffffff168152508260000160008d6001600160a01b03166001600160a01b0316815260200190815260200160002060008201518160000160006101000a81548160ff021916908360ff16021790555060208201518160000160016101000a81548163ffffffff021916908363ffffffff16021790555060408201518160000160056101000a81548163ffffffff021916908363ffffffff16021790555060608201518160000160096101000a8154816001600160401b0302191690836001600160401b0316021790555060808201518160000160116101000a81548160ff021916908360ff16021790555060a08201518160000160126101000a81548160ff021916908360ff16021790555060c08201518160000160136101000a81548165ffffffffffff021916908365ffffffffffff1602179055509050507f2521d98b2c88e19cb124cca9f2860404ff4e038f074120bbc3d69e2c751ffc928b8461012001518b8b87602001518860000151604051612476969594939291906001600160a01b0396871681526020810195909552929094166040840152606083015263ffffffff92909216608082015260ff9190911660a082015260c00190565b60405180910390a1612498836060015184600001518486610120015188613684565b61010086015260e08501526001600160a01b031660c084018190526124dd57610120830151600090815260038201602052604090206124d7908c613786565b50612544565b6040518060800160405280846020015163ffffffff1681526020018a6001600160a01b031681526020018981526020018460e001518152508361016001819052506125448360000151838d8660c0015187610120015188610100015189610160015161379b565b5050505050505050505050565b60008061255c610f7c565b63ffffffff8416600090815260039190910160209081526040808320878452600581019092529091205490915060ff1680156125c35760ff81166000908152600183016020908152604080832088845260040190915290206125be9087613c49565b610ff7565b50600095945050505050565b6000806106f66125dd610f7c565b60ff851660009081526001919091016020908152604091829020825160608101845290546001600160401b0381168252600160401b810463ffffffff1692820192909252600160601b90910461ffff1691810191909152612f49565b612642826132df565b8061264b610f7c565b6001600090815260209182526040908190209290925590518281527fee3ba0763748d6e285026c82cf5f0233531ace4040dce0d5c4434c55bf5cd9399101610a13565b610ba4838383612b1a565b6126a28361336b565b6040805160c081018252600080825260208201819052918101829052606081018290526080810182905260a0810191909152836001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa158015612712573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127369190614fdd565b6001600160a01b0316606082015261274d83610dd2565b63ffffffff1660208201819052606082015161276d918791906001613564565b60ff16825250600061277d610f7c565b60208381015163ffffffff9081166000908152600393909301825260408084206001600160a01b038b16855280845293819020815160e081018352905460ff80821683526101008204851695830195909552600160281b810490931691810191909152600160481b82046001600160401b03166060820152600160881b820483166080820152600160901b820490921660a0830152600160981b900465ffffffffffff1660c082015290915061283281613c5e565b612854836060015184600001518484606001516001600160401b031688613684565b60a086015260808501526001600160a01b03166040840181905261288b57604051633381fb0d60e01b815260040160405180910390fd5b805160ff166000908152600183016020526040812060608301516128b991906001600160401b03168a613cac565b90506129228460000151848a876040015186606001516001600160401b03168960a0015160405180608001604052808c6020015163ffffffff16815260200189600001516001600160a01b03168152602001896020015181526020018c6080015181525061379b565b5050505050505050565b6129358261336b565b600061294082610dd2565b9050600061294c610f7c565b63ffffffff8381166000908152600392909201602090815260408084206001600160a01b038a16855280835293819020815160e081018352905460ff80821683526101008204861694830194909452600160281b810490941691810191909152600160481b83046001600160401b03166060820152600160881b830482166080820152600160901b830490911660a0820152600160981b90910465ffffffffffff1660c08201529091506129ff81613c5e565b805160ff1660009081526001808401602052604090912090612a2a9085908590849086908c90613dd1565b50505050505050565b6000612a3d610f7c565b60006001611122565b600080600080612a9785612a58610f7c565b63ffffffff808b1660009081526003929092016020908152604080842060ff8f16855260010182528084208c8552600401909152909120919061409d16565b915091508115612aac57925060a083901c9150825b505094509492505050565b6000612ac1610f7c565b60006002611122565b60006007612ad9836003614fca565b61070e9190615010565b60006350877ed6461480612afa5750630235ddd046145b15611448576040518060208160008060185afa612b1357fe5b5051905090565b6040805160608101825260008082526020820181905291810191909152612b3f610f7c565b60ff8516600090815260019190910160209081526040808320815160608101835290546001600160401b0381168252600160401b810463ffffffff1693820193909352600160601b90920461ffff16908201529150612b9d84610dd2565b9050816020015163ffffffff16600003612c6c5763ffffffff8116602083015281612bc6610f7c565b60ff8716600081815260019290920160209081526040928390208451815486840151968601516001600160401b039092166001600160601b031990911617600160401b63ffffffff978816021761ffff60601b1916600160601b61ffff909216919091021790558251918252928416928101929092527f1122d4fb8516daedc106927e0acc4baf5f6be5f82112b501be8790859c3d4d9b910160405180910390a1612f41565b816020015163ffffffff168163ffffffff1614612f41576000612cc1612c90610f7c565b60208086015163ffffffff1660009081526003929092018152604080832060ff8b168452600601909152902061305c565b90506000612cdb87856020015163ffffffff1684886140b5565b905080600003612cf2575082516001600160401b03165b83516001600160401b03168114612e1b576000612d0d610f7c565b60008381526002919091016020526040902054855160ff90911691506001600160401b031615612d6557612d3f610f7c565b85516001600160401b0316600090815260029190910160205260409020805460ff191690555b60ff811615612dec576000612d78610f7c565b60ff8316600090815260019190910160205260408120805467ffffffffffffffff19166001600160401b039390931692909217909155612db6610f7c565b60ff8316600090815260019190910160205260409020805461ffff92909216600160601b0261ffff60601b199092169190911790555b87612df5610f7c565b600084815260029190910160205260409020805460ff191660ff92909216919091179055505b6040518060600160405280826001600160401b031681526020018463ffffffff16815260200185600001516001600160401b031683148015612e5c57508215155b612e67576000612e85565b6020860151612e769086615295565b8660400151612e8591906153db565b61ffff169052935083612e96610f7c565b60ff8916600081815260019290920160209081526040928390208451815486840151968601516001600160401b039092166001600160601b031990911617600160401b63ffffffff978816021761ffff60601b1916600160601b61ffff9092169190910217905582519182529286169281019290925281018290527f1ffb10ddeed1be3e5ce0225fdd14d2df110d52b970118a7f9d58de2ecce3c0629060600160405180910390a150505b509392505050565b80516001600160401b031660008115612f64576103e8612f67565b60005b90508115613057576000612f79610f7c565b60026000908152602091909152604090205490506001600160a01b03811615613055576040516306d71c2560e51b8152600481018490526000906001600160a01b0383169063dae384a090602401602060405180830381865afa158015612fe4573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061300891906151e5565b9050670de0b6b3a764000061302582670de0b6b3a764000061432d565b6130336103e8612710614fb7565b61303d91906153f6565b6130479190615010565b6130519084614fca565b9250505b505b915091565b60606000610e9883614343565b61307161439f565b610c3757604051631afcd79f60e31b815260040160405180910390fd5b6001600160a01b0381166130d65760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b6044820152606401610956565b613105816109a760017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c3618614fb7565b613134426109a760017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b614fb7565b613163436109a760017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f1614fb7565b604080516001600160a01b0383168152426020820152438183015290517f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe2367134269181900360600190a150565b60008080806131bc86866143b9565b909450925050505b9250929050565b336001600160a01b0316816001600160a01b03166325eb1c876040518163ffffffff1660e01b8152600401602060405180830381865afa158015613213573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132379190614fdd565b6001600160a01b03161461085c576040516302619f2b60e51b815260040160405180910390fd5b600061070b83836143fb565b60006001600160401b0382111561329757604051633995b34160e01b815260048101839052602401610956565b5067ffffffffffffffff60a01b60a09190911b166001600160a01b039091161790565b6000818152600183016020526040812054151561070b565b60606000610e98836144f5565b604051631430d62960e21b81526001600160a01b038216906350c358a49061330b903390600401614e95565b602060405180830381865afa158015613328573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061334c91906151a8565b61085c573360405163451cea1760e11b81526004016109569190614e95565b806001600160a01b03166318d928316040518163ffffffff1660e01b8152600401602060405180830381865afa1580156133a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133cd91906151a8565b1561085c57604051635e1633d360e11b815260040160405180910390fd5b600080846001600160a01b0316633b4c9891856040518263ffffffff1660e01b815260040161341a9190614e95565b602060405180830381865afa158015613437573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061345b91906151e5565b6040516373cf874b60e11b81529092506001600160a01b0386169063e79f0e969061348a908790600401614e95565b602060405180830381865afa1580156134a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134cb91906151e5565b9050816000036134ee57604051632f6c853960e11b815260040160405180910390fd5b6134fa600060026154e9565b8116151580613526575082600d81111561351657613516614cd9565b6135219060026154e9565b811615155b610ec05782600d81111561353c5761353c614cd9565b604051630d816ed160e01b815260040161095691815260200190565b600061070b8383614500565b600080846001600160a01b0316633b4c9891876040518263ffffffff1660e01b81526004016135939190614e95565b602060405180830381865afa1580156135b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135d491906151e5565b91508280156135e1575081155b156135ff57604051632f6c853960e11b815260040160405180910390fd5b811561363d5761360d610f7c565b63ffffffff851660009081526003919091016020908152604080832085845260050190915290205460ff16613640565b60005b9050828015613650575060ff8116155b15610d8f57604051632e8e6b7560e11b815260040160405180910390fd5b6000610843846001600160a01b0385168461454f565b600080600080886001600160a01b031663df1dd976876040518263ffffffff1660e01b81526004016136b891815260200190565b600060405180830381865afa1580156136d5573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526136fd91908101906150af565b5050935050505060038160ff161061377a5760ff88166000908152600188016020908152604080832060068b0190925290912061373e908b90838a8a61456c565b925082156137785761375181848861472b565b909550935060008490036137785760405163d92e233d60e01b815260040160405180910390fd5b505b50955095509592505050565b600061070b836001600160a01b038416614500565b6001600160a01b0385811660009081526002880160209081526040808320815160a08101835289861681526001818501818152938201869052606082018690526080820186905282549081018355918552929093208251930180546001600160a01b0319811694909516938417815590519193909283916001600160a81b03191617600160a01b83600481111561383457613834614cd9565b0217905550604082810151825460608086015160809687015160ff16600160e81b0260ff60e81b1963ffffffff928316600160c81b0263ffffffff60c81b1993909616600160a81b029290921667ffffffffffffffff60a81b19909416939093179390931792909216179092556001600160a01b03878116600090815260028b016020908152838220845160a0810186528c85168152600181840181815296820185905296810184905296870183905280549586018155825290208451930180546001600160a01b031981169490921693841781559151919283916001600160a81b03191617600160a01b83600481111561393157613931614cd9565b021790555060408201518154606084015160809094015167ffffffffffffffff60a81b19909116600160a81b63ffffffff9384160263ffffffff60c81b191617600160c81b92909416919091029290921760ff60e81b1916600160e81b60ff9093169290920291909117905560006139a76147af565b9050866002016000876001600160a01b03166001600160a01b0316815260200190815260200160002080549050876000016000886001600160a01b03166001600160a01b0316815260200190815260200160002060000160016101000a81548163ffffffff021916908363ffffffff16021790555080876000016000886001600160a01b03166001600160a01b0316815260200190815260200160002060000160136101000a81548165ffffffffffff021916908365ffffffffffff160217905550866002016000866001600160a01b03166001600160a01b0316815260200190815260200160002080549050876000016000876001600160a01b03166001600160a01b0316815260200190815260200160002060000160016101000a81548163ffffffff021916908363ffffffff16021790555080876000016000876001600160a01b03166001600160a01b0316815260200190815260200160002060000160136101000a81548165ffffffffffff021916908365ffffffffffff160217905550613b6a868860010160008b60ff1660ff16815260200190815260200160002060030160008781526020019081526020016000206147fe90919063ffffffff16565b5060ff8816600090815260018801602090815260408083208684526003019091529020613b9790866147fe565b50600080613bac84606001519060a082901c90565b85516020808801516040808a0151815165ffffffffffff8b16815263ffffffff909516938501939093526001600160a01b03918216908401526060830191909152608082018a9052831660a082015260c0810182905260e0810188905291935091507fd7da27827582ad8f7f3f4fc8a20f7be83108736c88b28aa3b41dccf6ad6e877990610100015b60405180910390a150505050505050505050565b600061070b836001600160a01b038416614813565b805160ff16600003613c83576040516315e0349160e11b815260040160405180910390fd5b602081015163ffffffff161561085c576040516366fab05760e01b815260040160405180910390fd5b60408051606080820183526000808352602083015291810191909152600083815260048501602052604081208190613ce4908561409d565b9150915081613d0957600060405163adc7fced60e01b81526004016109569190614e95565b808060a081901c6020808701919091526001600160a01b039091168552600082815260058901909152604090208054613d4190615151565b80601f0160208091040260200160405190810160405280929190818152602001828054613d6d90615151565b8015613dba5780601f10613d8f57610100808354040283529160200191613dba565b820191906000526020600020905b815481529060010190602001808311613d9d57829003601f168201915b505050505084604001819052505050509392505050565b60608301516001600160401b031660009081526004850160205260408120819081908190613dff908761409d565b915091508115613e4b5760608701516001600160401b031660009081526004890160205260409020613e31908761481f565b50613e3f60038a018261325e565b50925060a083901c9150825b60608701516001600160401b031660009081526003890160205260409020613e7390876147fe565b506040518060e00160405280600060ff168152602001600063ffffffff168152602001886040015163ffffffff16815260200160006001600160401b03168152602001600060ff168152602001600060ff168152602001600065ffffffffffff16815250896000016000886001600160a01b03166001600160a01b0316815260200190815260200160002060008201518160000160006101000a81548160ff021916908360ff16021790555060208201518160000160016101000a81548163ffffffff021916908363ffffffff16021790555060408201518160000160056101000a81548163ffffffff021916908363ffffffff16021790555060608201518160000160096101000a8154816001600160401b0302191690836001600160401b0316021790555060808201518160000160116101000a81548160ff021916908360ff16021790555060a08201518160000160126101000a81548160ff021916908360ff16021790555060c08201518160000160136101000a81548165ffffffffffff021916908365ffffffffffff1602179055509050507f43123e2ba4590155d8a1fddade2bb91cc46a6ce2a49d8fba12fdeae963bc7be88688606001518c8a6000015188888b604051613c3597969594939291906001600160a01b0397881681526001600160401b0396909616602087015263ffffffff94909416604086015260ff929092166060850152909316608083015260a082019290925290151560c082015260e00190565b60008080806131bc866001600160a01b0387166143b9565b815160009081816001600160401b038111156140d3576140d3614a6d565b6040519080825280602002602001820160405280156140fc578160200160208202803683370190505b509050600080600061410c610f7c565b60008a81526003919091016020908152604080832060ff8e168452600101909152812091505b8581101561422b5760008061416c8b848151811061415257614152615038565b6020026020010151856000016131ad90919063ffffffff16565b9150915081801561417c57508015155b15614221578087848151811061419457614194615038565b60209081029190910101528515806141ce575080876141b4600189614fb7565b815181106141c4576141c4615038565b6020026020010151105b156141e9576141de836001614fca565b955060019450614221565b80876141f6600189614fb7565b8151811061420657614206615038565b602002602001015103614221578461421d816154f5565b9550505b5050600101614132565b508215614320576000826001146142585761425361424a600185614fb7565b8963ffffffff16565b61425b565b60005b9050806000036142905788614271600186614fb7565b8151811061428157614281615038565b6020026020010151965061431e565b835b8681101561431c57856142a6600187614fb7565b815181106142b6576142b6615038565b60200260200101518682815181106142d0576142d0615038565b6020026020010151036143145781600103614306578981815181106142f7576142f7615038565b6020026020010151975061431c565b816143108161550e565b9250505b600101614292565b505b505b5050505050949350505050565b600081831061433c578161070b565b5090919050565b60608160000180548060200260200160405190810160405280929190818152602001828054801561439357602002820191906000526020600020905b81548152602001906001019080831161437f575b50505050509050919050565b60006143a9610f47565b54600160401b900460ff16919050565b60008181526002830160205260408120548190806143e8576143db8585614813565b9250600091506131c49050565b6001925090506131c4565b509250929050565b600081815260018301602052604081205480156144e457600061441f600183614fb7565b855490915060009061443390600190614fb7565b905080821461449857600086600001828154811061445357614453615038565b906000526020600020015490508087600001848154811061447657614476615038565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806144a9576144a9615525565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061070e565b600091505061070e565b5092915050565b606061070e8261305c565b60008181526001830160205260408120546145475750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561070e565b50600061070e565b600082815260028401602052604081208290556108438484613558565b60008061457886614834565b9050600181111561472157600061459c614593600184614fb7565b8563ffffffff16565b9050805b60006145ac898361483e565b604051636f8eecbb60e11b8152600481018290529091506000906001600160a01b038c169063df1dd97690602401600060405180830381865afa1580156145f7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261461f91908101906150af565b5050935050505060038160ff16101580156146515750600082815260038a016020526040902061464e90614834565b15155b801561465d5750818814155b80156146d65750604051630562452b60e21b815260048101899052602481018390526001600160a01b038c169063158914ac90604401602060405180830381865afa1580156146b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146d491906151a8565b155b156146e35750935061471e565b846146ef846001614fca565b14614704576146ff836001614fca565b614707565b60005b925083830361471757505061471e565b50506145a0565b50505b5095945050505050565b6000828152600384016020526040812081908161474782614834565b905080156147a55760008160011461477557614770614767600184614fb7565b8763ffffffff16565b614778565b60005b9050614784838261483e565b600088815260048a01602052604090209095506147a1908661484a565b9350505b5050935093915050565b60006147b9610f7c565b6003600090815260209190915260409020546147d690600161553b565b90508065ffffffffffff166147e9610f7c565b60036000908152602091909152604090205590565b600061070b836001600160a01b0384166143fb565b600061070b83836132ba565b600061070b836001600160a01b03841661485f565b600061070e825490565b600061070b838361487c565b600061070b836001600160a01b0384166148a6565b6000818152600283016020526040812081905561070b838361325e565b600082600001828154811061489357614893615038565b9060005260206000200154905092915050565b6000818152600283016020526040812054801580156148cc57506148ca8484614813565b155b1561070b5760405163015ab34360e11b815260048101849052602401610956565b6040805160a081019091526000808252602082019081526000602082018190526040820181905260609091015290565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c081019190915290565b6040805161018081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081019190915261014081016149b761491d565b81526040805160808101825260008082526020828101829052928201819052606082015291015290565b60ff8116811461085c57600080fd5b600060208284031215614a0257600080fd5b813561070b816149e1565b63ffffffff8116811461085c57600080fd5b6001600160a01b038116811461085c57600080fd5b60008060408385031215614a4757600080fd5b8235614a5281614a0d565b91506020830135614a6281614a1f565b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715614aab57614aab614a6d565b604052919050565b60006001600160401b03821115614acc57614acc614a6d565b50601f01601f191660200190565b600082601f830112614aeb57600080fd5b8135614afe614af982614ab3565b614a83565b818152846020838601011115614b1357600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060808587031215614b4657600080fd5b8435614b5181614a1f565b93506020850135614b6181614a1f565b92506040850135915060608501356001600160401b03811115614b8357600080fd5b614b8f87828801614ada565b91505092959194509250565b60008060408385031215614bae57600080fd5b8235614bb9816149e1565b91506020830135614a6281614a0d565b6020808252825182820181905260009190848201906040850190845b81811015614c0157835183529284019291840191600101614be5565b50909695505050505050565b600060208284031215614c1f57600080fd5b813561070b81614a1f565b600080600060608486031215614c3f57600080fd5b8335614c4a816149e1565b92506020840135614c5a81614a0d565b929592945050506040919091013590565b600060208284031215614c7d57600080fd5b5035919050565b60008060408385031215614c9757600080fd5b823591506020830135614a6281614a0d565b600080600060608486031215614cbe57600080fd5b8335614cc981614a0d565b92506020840135614c5a81614a1f565b634e487b7160e01b600052602160045260246000fd5b81516001600160a01b03168152602082015160a082019060058110614d2457634e487b7160e01b600052602160045260246000fd5b80602084015250604083015163ffffffff8082166040850152806060860151166060850152505060ff608084015116608083015292915050565b600080600060608486031215614d7357600080fd5b8335614d7e81614a1f565b9250602084013591506040840135614d9581614a0d565b809150509250925092565b6020808252825182820181905260009190848201906040850190845b81811015614c015783516001600160a01b031683529284019291840191600101614dbc565b60008060008060808587031215614df757600080fd5b8435614e02816149e1565b93506020850135614e1281614a0d565b92506040850135614e2281614a1f565b9396929550929360600135925050565b60005b83811015614e4d578181015183820152602001614e35565b50506000910152565b60008151808452614e6e816020860160208601614e32565b601f01601f19169290920160200192915050565b60208152600061070b6020830184614e56565b6001600160a01b0391909116815260200190565b60008060008060808587031215614ebf57600080fd5b8435614eca81614a1f565b93506020850135925060408501356001600160401b03811115614eec57600080fd5b614ef887828801614ada565b9250506060850135614f09816149e1565b939692955090935050565b60008060408385031215614f2757600080fd5b8235614f3281614a1f565b946020939093013593505050565b60008060008060808587031215614f5657600080fd5b8435614f61816149e1565b93506020850135614f7181614a0d565b9250604085013591506060850135614f0981614a1f565b6001600160a01b03929092168252602082015260400190565b634e487b7160e01b600052601160045260246000fd5b8181038181111561070e5761070e614fa1565b8082018082111561070e5761070e614fa1565b600060208284031215614fef57600080fd5b815161070b81614a1f565b634e487b7160e01b600052601260045260246000fd5b60008261501f5761501f614ffa565b500490565b60008261503357615033614ffa565b500690565b634e487b7160e01b600052603260045260246000fd5b600082601f83011261505f57600080fd5b815161506d614af982614ab3565b81815284602083860101111561508257600080fd5b610843826020830160208701614e32565b80516001600160401b03811681146150aa57600080fd5b919050565b60008060008060008060c087890312156150c857600080fd5b86516001600160401b03808211156150df57600080fd5b6150eb8a838b0161504e565b9750602089015191508082111561510157600080fd5b5061510e89828a0161504e565b955050604087015161511f81614a1f565b6060880151909450615130816149e1565b925061513e60808801615093565b915060a087015190509295509295509295565b600181811c9082168061516557607f821691505b60208210810361518557634e487b7160e01b600052602260045260246000fd5b50919050565b60006020828403121561519d57600080fd5b815161070b816149e1565b6000602082840312156151ba57600080fd5b8151801515811461070b57600080fd5b6000602082840312156151dc57600080fd5b61070b82615093565b6000602082840312156151f757600080fd5b5051919050565b600060a0828403121561521057600080fd5b60405160a081018181106001600160401b038211171561523257615232614a6d565b604052825161524081614a0d565b8152602083015161525081614a0d565b6020820152604083015161526381614a0d565b6040820152606083015161527681614a0d565b6060820152608083015161528981614a0d565b60808201529392505050565b63ffffffff8281168282160390808211156144ee576144ee614fa1565b601f8211156152fa576000816000526020600020601f850160051c810160208610156152db5750805b601f850160051c820191505b8181101561082e578281556001016152e7565b505050565b81516001600160401b0381111561531857615318614a6d565b61532c816153268454615151565b846152b2565b602080601f83116001811461536157600084156153495750858301515b600019600386901b1c1916600185901b17855561082e565b600085815260208120601f198616915b8281101561539057888601518255948401946001909101908401615371565b50858210156153ae5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b63ffffffff8181168382160190808211156144ee576144ee614fa1565b61ffff8181168382160190808211156144ee576144ee614fa1565b808202811582820484141761070e5761070e614fa1565b600181815b808511156143f357816000190482111561542e5761542e614fa1565b8085161561543b57918102915b93841c9390800290615412565b6000826154575750600161070e565b816154645750600061070e565b816001811461547a5760028114615484576154a0565b600191505061070e565b60ff84111561549557615495614fa1565b50506001821b61070e565b5060208310610133831016604e8410600b84101617156154c3575081810a61070e565b6154cd838361540d565b80600019048211156154e1576154e1614fa1565b029392505050565b600061070b8383615448565b60006001820161550757615507614fa1565b5060010190565b60008161551d5761551d614fa1565b506000190190565b634e487b7160e01b600052603160045260246000fd5b65ffffffffffff8181168382160190808211156144ee576144ee614fa156fe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda26469706673582212204affa8f29f3c0492de33f003f072fc29d6cb8c9e4e5b2760f520527e986d3ea264736f6c63430008170033",
  "libraries": {
    "PvpFightLib": "0x536edbB5eEDaD839155E70510Bb1F55604dF3d0c"
  },
  "devdoc": {
    "errors": {
      "EnumerableMapNonexistentKey(bytes32)": [
        {
          "details": "Query for a nonexistent map key."
        }
      ],
      "InvalidInitialization()": [
        {
          "details": "The contract is already initialized."
        }
      ],
      "NotInitializing()": [
        {
          "details": "The contract is not initializing."
        }
      ]
    },
    "events": {
      "Initialized(uint64)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      },
      "PvpHeroRemoved(address,uint256,uint256,uint8,address,uint256,bool)": {
        "params": {
          "manuallyRemoved": "True - removed manually by the user, false - removed automatically after the fight"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "addPvpHero(address,uint256,bytes,uint8)": {
        "params": {
          "pvpStrategy": "abi.encode(PvpAttackInfoDefaultStrategy)"
        }
      },
      "created()": {
        "returns": {
          "_0": "Creation timestamp"
        }
      },
      "createdBlock()": {
        "returns": {
          "_0": "Creation block number"
        }
      },
      "getBiomeTax(uint8)": {
        "returns": {
          "guildId": "Owner of the biome",
          "taxPercent": "Final tax percent, [0...100_000], decimals 3"
        }
      },
      "getDominationRequest(uint256,uint32)": {
        "returns": {
          "biome": "Biome where the guild is going to dominate in the given epoch"
        }
      },
      "increaseRevision(address)": {
        "details": "Revision should be increased on each contract upgrade"
      },
      "isController(address)": {
        "details": "Return true if given address is controller"
      },
      "onERC721Received(address,address,uint256,bytes)": {
        "details": "See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."
      },
      "previousImplementation()": {
        "details": "Previous logic implementation"
      },
      "refreshBiomeTax(uint8)": {
        "returns": {
          "guildId": "Owner of the biome",
          "taxPercent": "Tax percent [0...100_000], decimals 3"
        }
      },
      "revision()": {
        "details": "Contract upgrade counter"
      }
    },
    "stateVariables": {
      "VERSION": {
        "details": "Should be incremented when contract changed"
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "BiomeAlreadySelected()": [
        {
          "notice": "Target biome can be selected only once per epoch"
        }
      ],
      "UserHasRegisteredPvpHeroInBiome(uint8)": [
        {
          "notice": "User should unregister pvp-hero from prev biome and only then register it in the new biome"
        }
      ]
    },
    "kind": "user",
    "methods": {
      "CONTROLLABLE_VERSION()": {
        "notice": "Version of the contract"
      },
      "VERSION()": {
        "notice": "Version of the contract"
      },
      "addPvpHero(address,uint256,bytes,uint8)": {
        "notice": "Stake hero for pvp for the current epoch. User is able to register a hero only once per epoch, the hero cannot be replaced, only removed."
      },
      "controller()": {
        "notice": "Return controller address saved in the contract slot"
      },
      "created()": {
        "notice": "Return creation timestamp"
      },
      "createdBlock()": {
        "notice": "Return creation block number"
      },
      "getBiomeGuilds(uint8,uint32)": {
        "notice": "List of guilds that send domination request for the biome"
      },
      "getBiomeTax(uint8)": {
        "notice": "Get biome tax"
      },
      "getCurrentEpochWeek(uint256)": {
        "notice": "Get week for the given timestamp. Assume that first day of the week is Monday"
      },
      "getFightDataLength(uint32,address)": {
        "notice": "Number of pvp-fights registered for the user in the given epoch"
      },
      "getMinHeroLevel()": {
        "notice": "Get min hero level allowed for pvp-fight"
      },
      "hasPvpHero(address,uint256,uint32)": {
        "notice": "Check if the user has a pvp-hero registered for pvp-fight in the given epoch"
      },
      "isGovernance(address)": {
        "notice": "Return true if given address is setup as governance in Controller"
      },
      "isHeroStaked(address,uint256,uint32)": {
        "notice": "Check if the given hero is staked in pvp controller in the given epoch"
      },
      "isHeroStakedCurrently(address,uint256)": {
        "notice": "Check if the given hero is staked in pvp controller in the current epoch"
      },
      "ownedBiome(uint256)": {
        "notice": "Biome owned currently by the given guild"
      },
      "refreshBiomeTax(uint8)": {
        "notice": "Update epoch if necessary and return biome owner and biome tax"
      },
      "registeredHero(uint8,uint32,uint256,address)": {
        "notice": "Hero registered by the user for pvp-fight in the given week and biome"
      },
      "registeredUsers(uint8,uint32,uint256)": {
        "notice": "List of the users registered for pvp-fight in the given week and biome"
      },
      "removePvpHero()": {
        "notice": "Withdraw hero from pvp for the current epoch"
      },
      "selectBiomeForDomination(uint8)": {
        "notice": "Select new domination target once per epoch"
      },
      "updateEpoch(uint8)": {
        "notice": "Change epoch if the current epoch is completed, update biome owner"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}