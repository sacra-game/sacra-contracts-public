{
  "address": "0x6BD6979fe0345A9c02bF5Fa714003C428627F353",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "pageId",
          "type": "uint16"
        },
        {
          "internalType": "uint16",
          "name": "pageIdFromAnswerHash",
          "type": "uint16"
        }
      ],
      "name": "AnswerPageIdMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "internalType": "uint16",
          "name": "storyIdFromAnswerHash",
          "type": "uint16"
        }
      ],
      "name": "AnswerStoryIdMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ErrorNotDeployer",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ErrorNotObjectController",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidInitialization",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotAnswer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotInitializing",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroStoryIdStoryAction",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ts",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "block",
          "type": "uint256"
        }
      ],
      "name": "ContractInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "version",
          "type": "uint64"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "dungeonId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "objectId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "nftToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "nftId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "stageId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "iteration",
          "type": "uint256"
        }
      ],
      "name": "ItemBurned",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "RevisionIncreased",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CONTROLLABLE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "allStoryAnswers",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        }
      ],
      "name": "allStoryAnswersLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "allStoryPages",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        }
      ],
      "name": "allStoryPagesLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "created",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "createdBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "internalType": "uint80",
          "name": "heroId",
          "type": "uint80"
        }
      ],
      "name": "currentHeroAnswers",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "buildHash",
          "type": "uint256"
        }
      ],
      "name": "finalizeStoryRegistration",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "hero",
          "type": "address"
        },
        {
          "internalType": "uint80",
          "name": "heroId",
          "type": "uint80"
        },
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        }
      ],
      "name": "heroPage",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "pageId",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        }
      ],
      "name": "idToStory",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "increaseRevision",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "controller_",
          "type": "address"
        }
      ],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isController",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "value_",
          "type": "address"
        }
      ],
      "name": "isGovernance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        }
      ],
      "name": "isStoryAvailableForHero",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC721Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "previousImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "registeredStories",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "removeStory",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "maxIterations",
          "type": "uint256"
        }
      ],
      "name": "removeStoryAnswersMeta",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "maxIterations",
          "type": "uint256"
        }
      ],
      "name": "removeStoryPagesMeta",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "revision",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "storyId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32[]",
              "name": "requiredCustomDataIndex",
              "type": "bytes32[]"
            },
            {
              "internalType": "uint64[]",
              "name": "requiredCustomDataMinValue",
              "type": "uint64[]"
            },
            {
              "internalType": "uint64[]",
              "name": "requiredCustomDataMaxValue",
              "type": "uint64[]"
            },
            {
              "internalType": "bool[]",
              "name": "requiredCustomDataIsHero",
              "type": "bool[]"
            },
            {
              "internalType": "uint256",
              "name": "minLevel",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "answerPageIds",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "answerHeroClasses",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerIds",
                  "type": "uint16[]"
                }
              ],
              "internalType": "struct IStoryController.AnswersMeta",
              "name": "answersMeta",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "answerResultIds",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[][]",
                  "name": "answerNextPageIds",
                  "type": "uint16[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerNextPageMeta",
              "name": "answerNextPage",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "bool[][]",
                  "name": "cores",
                  "type": "bool[][]"
                },
                {
                  "internalType": "uint8[][]",
                  "name": "ids",
                  "type": "uint8[][]"
                },
                {
                  "internalType": "int32[][]",
                  "name": "values",
                  "type": "int32[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerAttributeRequirementsMeta",
              "name": "answerAttributeRequirements",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "address[][]",
                  "name": "requireItems",
                  "type": "address[][]"
                },
                {
                  "internalType": "bool[][]",
                  "name": "requireItemBurn",
                  "type": "bool[][]"
                },
                {
                  "internalType": "bool[][]",
                  "name": "requireItemEquipped",
                  "type": "bool[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerItemRequirementsMeta",
              "name": "answerItemRequirements",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "address[][]",
                  "name": "requireToken",
                  "type": "address[][]"
                },
                {
                  "internalType": "uint88[][]",
                  "name": "requireAmount",
                  "type": "uint88[][]"
                },
                {
                  "internalType": "bool[][]",
                  "name": "requireTransfer",
                  "type": "bool[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerTokenRequirementsMeta",
              "name": "answerTokenRequirements",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint32[]",
                  "name": "randomRequirements",
                  "type": "uint32[]"
                },
                {
                  "internalType": "uint32[]",
                  "name": "delayRequirements",
                  "type": "uint32[]"
                },
                {
                  "internalType": "bool[]",
                  "name": "isFinalAnswer",
                  "type": "bool[]"
                }
              ],
              "internalType": "struct IStoryController.AnswerAttributesMeta",
              "name": "answerAttributes",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "bytes32[][]",
                  "name": "dataIndexes",
                  "type": "bytes32[][]"
                },
                {
                  "internalType": "bool[][]",
                  "name": "mandatory",
                  "type": "bool[][]"
                },
                {
                  "internalType": "uint64[][]",
                  "name": "dataValuesMin",
                  "type": "uint64[][]"
                },
                {
                  "internalType": "uint64[][]",
                  "name": "dataValuesMax",
                  "type": "uint64[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerCustomDataMeta",
              "name": "answerHeroCustomDataRequirement",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "bytes32[][]",
                  "name": "dataIndexes",
                  "type": "bytes32[][]"
                },
                {
                  "internalType": "bool[][]",
                  "name": "mandatory",
                  "type": "bool[][]"
                },
                {
                  "internalType": "uint64[][]",
                  "name": "dataValuesMin",
                  "type": "uint64[][]"
                },
                {
                  "internalType": "uint64[][]",
                  "name": "dataValuesMax",
                  "type": "uint64[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerCustomDataMeta",
              "name": "answerGlobalCustomDataRequirement",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[][]",
                  "name": "slots",
                  "type": "uint8[][]"
                },
                {
                  "internalType": "uint64[][]",
                  "name": "chances",
                  "type": "uint64[][]"
                },
                {
                  "internalType": "bool[][]",
                  "name": "isStopIfBurnt",
                  "type": "bool[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerBurnRandomItemMeta",
              "name": "answerBurnRandomItemMeta",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "nextObjPageIds",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "nextObjHeroClasses",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint32[][]",
                  "name": "nextObjIds",
                  "type": "uint32[][]"
                }
              ],
              "internalType": "struct IStoryController.NextObjRewriteMeta",
              "name": "nextObjRewriteMeta",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[][]",
                  "name": "attributeIds",
                  "type": "uint8[][]"
                },
                {
                  "internalType": "int32[][]",
                  "name": "attributeValues",
                  "type": "int32[][]"
                },
                {
                  "internalType": "uint32[]",
                  "name": "experience",
                  "type": "uint32[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "heal",
                  "type": "int32[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "manaRegen",
                  "type": "int32[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "lifeChancesRecovered",
                  "type": "int32[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "damage",
                  "type": "int32[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "manaConsumed",
                  "type": "int32[]"
                },
                {
                  "internalType": "address[][]",
                  "name": "mintItems",
                  "type": "address[][]"
                },
                {
                  "internalType": "uint32[][]",
                  "name": "mintItemsChances",
                  "type": "uint32[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerResultMeta",
              "name": "successInfo",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[][]",
                  "name": "attributeIds",
                  "type": "uint8[][]"
                },
                {
                  "internalType": "int32[][]",
                  "name": "attributeValues",
                  "type": "int32[][]"
                },
                {
                  "internalType": "uint32[]",
                  "name": "experience",
                  "type": "uint32[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "heal",
                  "type": "int32[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "manaRegen",
                  "type": "int32[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "lifeChancesRecovered",
                  "type": "int32[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "damage",
                  "type": "int32[]"
                },
                {
                  "internalType": "int32[]",
                  "name": "manaConsumed",
                  "type": "int32[]"
                },
                {
                  "internalType": "address[][]",
                  "name": "mintItems",
                  "type": "address[][]"
                },
                {
                  "internalType": "uint32[][]",
                  "name": "mintItemsChances",
                  "type": "uint32[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerResultMeta",
              "name": "failInfo",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "bytes32[][]",
                  "name": "dataIndexes",
                  "type": "bytes32[][]"
                },
                {
                  "internalType": "int16[][]",
                  "name": "dataValues",
                  "type": "int16[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerCustomDataResultMeta",
              "name": "successHeroCustomData",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "bytes32[][]",
                  "name": "dataIndexes",
                  "type": "bytes32[][]"
                },
                {
                  "internalType": "int16[][]",
                  "name": "dataValues",
                  "type": "int16[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerCustomDataResultMeta",
              "name": "failHeroCustomData",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "bytes32[][]",
                  "name": "dataIndexes",
                  "type": "bytes32[][]"
                },
                {
                  "internalType": "int16[][]",
                  "name": "dataValues",
                  "type": "int16[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerCustomDataResultMeta",
              "name": "successGlobalCustomData",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint16[]",
                  "name": "pageId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "uint8[]",
                  "name": "heroClass",
                  "type": "uint8[]"
                },
                {
                  "internalType": "uint16[]",
                  "name": "answerId",
                  "type": "uint16[]"
                },
                {
                  "internalType": "bytes32[][]",
                  "name": "dataIndexes",
                  "type": "bytes32[][]"
                },
                {
                  "internalType": "int16[][]",
                  "name": "dataValues",
                  "type": "int16[][]"
                }
              ],
              "internalType": "struct IStoryController.AnswerCustomDataResultMeta",
              "name": "failGlobalCustomData",
              "type": "tuple"
            }
          ],
          "internalType": "struct IStoryController.StoryMetaInfo",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setAllStoryFields",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "bool[][]",
              "name": "cores",
              "type": "bool[][]"
            },
            {
              "internalType": "uint8[][]",
              "name": "ids",
              "type": "uint8[][]"
            },
            {
              "internalType": "int32[][]",
              "name": "values",
              "type": "int32[][]"
            }
          ],
          "internalType": "struct IStoryController.AnswerAttributeRequirementsMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setAnswerAttributeRequirements",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint32[]",
              "name": "randomRequirements",
              "type": "uint32[]"
            },
            {
              "internalType": "uint32[]",
              "name": "delayRequirements",
              "type": "uint32[]"
            },
            {
              "internalType": "bool[]",
              "name": "isFinalAnswer",
              "type": "bool[]"
            }
          ],
          "internalType": "struct IStoryController.AnswerAttributesMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setAnswerAttributes",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "bytes32[][]",
              "name": "dataIndexes",
              "type": "bytes32[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "mandatory",
              "type": "bool[][]"
            },
            {
              "internalType": "uint64[][]",
              "name": "dataValuesMin",
              "type": "uint64[][]"
            },
            {
              "internalType": "uint64[][]",
              "name": "dataValuesMax",
              "type": "uint64[][]"
            }
          ],
          "internalType": "struct IStoryController.AnswerCustomDataMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setAnswerGlobalCustomDataRequirementMeta",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "bytes32[][]",
              "name": "dataIndexes",
              "type": "bytes32[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "mandatory",
              "type": "bool[][]"
            },
            {
              "internalType": "uint64[][]",
              "name": "dataValuesMin",
              "type": "uint64[][]"
            },
            {
              "internalType": "uint64[][]",
              "name": "dataValuesMax",
              "type": "uint64[][]"
            }
          ],
          "internalType": "struct IStoryController.AnswerCustomDataMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setAnswerHeroCustomDataRequirementMeta",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "address[][]",
              "name": "requireItems",
              "type": "address[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "requireItemBurn",
              "type": "bool[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "requireItemEquipped",
              "type": "bool[][]"
            }
          ],
          "internalType": "struct IStoryController.AnswerItemRequirementsMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setAnswerItemRequirements",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "answerResultIds",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[][]",
              "name": "answerNextPageIds",
              "type": "uint16[][]"
            }
          ],
          "internalType": "struct IStoryController.AnswerNextPageMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setAnswerNextPageMeta",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "address[][]",
              "name": "requireToken",
              "type": "address[][]"
            },
            {
              "internalType": "uint88[][]",
              "name": "requireAmount",
              "type": "uint88[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "requireTransfer",
              "type": "bool[][]"
            }
          ],
          "internalType": "struct IStoryController.AnswerTokenRequirementsMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setAnswerTokenRequirementsMeta",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "internalType": "uint16[]",
          "name": "answerPageIds",
          "type": "uint16[]"
        },
        {
          "internalType": "uint8[]",
          "name": "answerHeroClasses",
          "type": "uint8[]"
        },
        {
          "internalType": "uint16[]",
          "name": "answerIds",
          "type": "uint16[]"
        }
      ],
      "name": "setAnswersMeta",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[][]",
              "name": "slots",
              "type": "uint8[][]"
            },
            {
              "internalType": "uint64[][]",
              "name": "chances",
              "type": "uint64[][]"
            },
            {
              "internalType": "bool[][]",
              "name": "isStopIfBurnt",
              "type": "bool[][]"
            }
          ],
          "internalType": "struct IStoryController.AnswerBurnRandomItemMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setBurnItemsMeta",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "bytes32[][]",
              "name": "dataIndexes",
              "type": "bytes32[][]"
            },
            {
              "internalType": "int16[][]",
              "name": "dataValues",
              "type": "int16[][]"
            }
          ],
          "internalType": "struct IStoryController.AnswerCustomDataResultMeta",
          "name": "meta",
          "type": "tuple"
        },
        {
          "internalType": "enum IStoryController.CustomDataResult",
          "name": "type_",
          "type": "uint8"
        }
      ],
      "name": "setCustomDataResult",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[][]",
              "name": "attributeIds",
              "type": "uint8[][]"
            },
            {
              "internalType": "int32[][]",
              "name": "attributeValues",
              "type": "int32[][]"
            },
            {
              "internalType": "uint32[]",
              "name": "experience",
              "type": "uint32[]"
            },
            {
              "internalType": "int32[]",
              "name": "heal",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "manaRegen",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "lifeChancesRecovered",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "damage",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "manaConsumed",
              "type": "int32[]"
            },
            {
              "internalType": "address[][]",
              "name": "mintItems",
              "type": "address[][]"
            },
            {
              "internalType": "uint32[][]",
              "name": "mintItemsChances",
              "type": "uint32[][]"
            }
          ],
          "internalType": "struct IStoryController.AnswerResultMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setFailInfo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "nextObjPageIds",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "nextObjHeroClasses",
              "type": "uint8[]"
            },
            {
              "internalType": "uint32[][]",
              "name": "nextObjIds",
              "type": "uint32[][]"
            }
          ],
          "internalType": "struct IStoryController.NextObjRewriteMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setNextObjRewriteMeta",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "internalType": "bytes32[]",
          "name": "requiredCustomDataIndex",
          "type": "bytes32[]"
        },
        {
          "internalType": "uint64[]",
          "name": "requiredCustomDataMinValue",
          "type": "uint64[]"
        },
        {
          "internalType": "uint64[]",
          "name": "requiredCustomDataMaxValue",
          "type": "uint64[]"
        },
        {
          "internalType": "bool[]",
          "name": "requiredCustomDataIsHero",
          "type": "bool[]"
        },
        {
          "internalType": "uint256",
          "name": "minLevel",
          "type": "uint256"
        }
      ],
      "name": "setStoryCustomDataRequirements",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint16[]",
              "name": "pageId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[]",
              "name": "heroClass",
              "type": "uint8[]"
            },
            {
              "internalType": "uint16[]",
              "name": "answerId",
              "type": "uint16[]"
            },
            {
              "internalType": "uint8[][]",
              "name": "attributeIds",
              "type": "uint8[][]"
            },
            {
              "internalType": "int32[][]",
              "name": "attributeValues",
              "type": "int32[][]"
            },
            {
              "internalType": "uint32[]",
              "name": "experience",
              "type": "uint32[]"
            },
            {
              "internalType": "int32[]",
              "name": "heal",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "manaRegen",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "lifeChancesRecovered",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "damage",
              "type": "int32[]"
            },
            {
              "internalType": "int32[]",
              "name": "manaConsumed",
              "type": "int32[]"
            },
            {
              "internalType": "address[][]",
              "name": "mintItems",
              "type": "address[][]"
            },
            {
              "internalType": "uint32[][]",
              "name": "mintItemsChances",
              "type": "uint32[][]"
            }
          ],
          "internalType": "struct IStoryController.AnswerResultMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "name": "setSuccessInfo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "dungeonId",
          "type": "uint64"
        },
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "stageId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "heroToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "heroTokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "biome",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "iteration",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "storyAction",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "kill",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "completed",
              "type": "bool"
            },
            {
              "internalType": "address",
              "name": "heroToken",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "mintItems",
              "type": "address[]"
            },
            {
              "internalType": "int32",
              "name": "heal",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "manaRegen",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "lifeChancesRecovered",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "damage",
              "type": "int32"
            },
            {
              "internalType": "int32",
              "name": "manaConsumed",
              "type": "int32"
            },
            {
              "internalType": "uint32",
              "name": "objectId",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "experience",
              "type": "uint32"
            },
            {
              "internalType": "uint256",
              "name": "heroTokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "iteration",
              "type": "uint256"
            },
            {
              "internalType": "uint32[]",
              "name": "rewriteNextObject",
              "type": "uint32[]"
            }
          ],
          "internalType": "struct IGOC.ActionResult",
          "name": "result",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "storyId",
          "type": "uint16"
        }
      ],
      "name": "storyBuildHash",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "objectId",
          "type": "uint32"
        }
      ],
      "name": "storyIds",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x672299e9bda39cd381515232eb1920dfb321e2ddbb62fb5115b4740f17d26a6c",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0x6BD6979fe0345A9c02bF5Fa714003C428627F353",
    "transactionIndex": 4,
    "gasUsed": "4749789",
    "logsBloom": "0x00000000020000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000080000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x00044d8c000008d98083c508fc1cb0a3243095a965c0bcf7f75c5fb26f87ccf2",
    "transactionHash": "0x672299e9bda39cd381515232eb1920dfb321e2ddbb62fb5115b4740f17d26a6c",
    "logs": [
      {
        "transactionIndex": 4,
        "blockNumber": 80919437,
        "transactionHash": "0x672299e9bda39cd381515232eb1920dfb321e2ddbb62fb5115b4740f17d26a6c",
        "address": "0x6BD6979fe0345A9c02bF5Fa714003C428627F353",
        "topics": [
          "0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 18,
        "blockHash": "0x00044d8c000008d98083c508fc1cb0a3243095a965c0bcf7f75c5fb26f87ccf2"
      }
    ],
    "blockNumber": 80919437,
    "cumulativeGasUsed": "6293719",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 4,
  "solcInputHash": "ab128610a613a12ee3464e154c92869f",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"pageId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"pageIdFromAnswerHash\",\"type\":\"uint16\"}],\"name\":\"AnswerPageIdMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"storyIdFromAnswerHash\",\"type\":\"uint16\"}],\"name\":\"AnswerStoryIdMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ErrorNotDeployer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ErrorNotObjectController\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAnswer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroStoryIdStoryAction\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"ContractInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dungeonId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stageId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"}],\"name\":\"ItemBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"RevisionIncreased\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTROLLABLE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"allStoryAnswers\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"}],\"name\":\"allStoryAnswersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"allStoryPages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"}],\"name\":\"allStoryPagesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"heroId\",\"type\":\"uint80\"}],\"name\":\"currentHeroAnswers\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"buildHash\",\"type\":\"uint256\"}],\"name\":\"finalizeStoryRegistration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"heroId\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"}],\"name\":\"heroPage\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"pageId\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"}],\"name\":\"idToStory\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"increaseRevision\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value_\",\"type\":\"address\"}],\"name\":\"isGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"}],\"name\":\"isStoryAvailableForHero\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"registeredStories\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"removeStory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"maxIterations\",\"type\":\"uint256\"}],\"name\":\"removeStoryAnswersMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"maxIterations\",\"type\":\"uint256\"}],\"name\":\"removeStoryPagesMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32[]\",\"name\":\"requiredCustomDataIndex\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"requiredCustomDataMinValue\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64[]\",\"name\":\"requiredCustomDataMaxValue\",\"type\":\"uint64[]\"},{\"internalType\":\"bool[]\",\"name\":\"requiredCustomDataIsHero\",\"type\":\"bool[]\"},{\"internalType\":\"uint256\",\"name\":\"minLevel\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"answerPageIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"answerHeroClasses\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerIds\",\"type\":\"uint16[]\"}],\"internalType\":\"struct IStoryController.AnswersMeta\",\"name\":\"answersMeta\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"answerResultIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[][]\",\"name\":\"answerNextPageIds\",\"type\":\"uint16[][]\"}],\"internalType\":\"struct IStoryController.AnswerNextPageMeta\",\"name\":\"answerNextPage\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bool[][]\",\"name\":\"cores\",\"type\":\"bool[][]\"},{\"internalType\":\"uint8[][]\",\"name\":\"ids\",\"type\":\"uint8[][]\"},{\"internalType\":\"int32[][]\",\"name\":\"values\",\"type\":\"int32[][]\"}],\"internalType\":\"struct IStoryController.AnswerAttributeRequirementsMeta\",\"name\":\"answerAttributeRequirements\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"address[][]\",\"name\":\"requireItems\",\"type\":\"address[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"requireItemBurn\",\"type\":\"bool[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"requireItemEquipped\",\"type\":\"bool[][]\"}],\"internalType\":\"struct IStoryController.AnswerItemRequirementsMeta\",\"name\":\"answerItemRequirements\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"address[][]\",\"name\":\"requireToken\",\"type\":\"address[][]\"},{\"internalType\":\"uint88[][]\",\"name\":\"requireAmount\",\"type\":\"uint88[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"requireTransfer\",\"type\":\"bool[][]\"}],\"internalType\":\"struct IStoryController.AnswerTokenRequirementsMeta\",\"name\":\"answerTokenRequirements\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint32[]\",\"name\":\"randomRequirements\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"delayRequirements\",\"type\":\"uint32[]\"},{\"internalType\":\"bool[]\",\"name\":\"isFinalAnswer\",\"type\":\"bool[]\"}],\"internalType\":\"struct IStoryController.AnswerAttributesMeta\",\"name\":\"answerAttributes\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"mandatory\",\"type\":\"bool[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMin\",\"type\":\"uint64[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMax\",\"type\":\"uint64[][]\"}],\"internalType\":\"struct IStoryController.AnswerCustomDataMeta\",\"name\":\"answerHeroCustomDataRequirement\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"mandatory\",\"type\":\"bool[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMin\",\"type\":\"uint64[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMax\",\"type\":\"uint64[][]\"}],\"internalType\":\"struct IStoryController.AnswerCustomDataMeta\",\"name\":\"answerGlobalCustomDataRequirement\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[][]\",\"name\":\"slots\",\"type\":\"uint8[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"chances\",\"type\":\"uint64[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"isStopIfBurnt\",\"type\":\"bool[][]\"}],\"internalType\":\"struct IStoryController.AnswerBurnRandomItemMeta\",\"name\":\"answerBurnRandomItemMeta\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"nextObjPageIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"nextObjHeroClasses\",\"type\":\"uint8[]\"},{\"internalType\":\"uint32[][]\",\"name\":\"nextObjIds\",\"type\":\"uint32[][]\"}],\"internalType\":\"struct IStoryController.NextObjRewriteMeta\",\"name\":\"nextObjRewriteMeta\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[][]\",\"name\":\"attributeIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"int32[][]\",\"name\":\"attributeValues\",\"type\":\"int32[][]\"},{\"internalType\":\"uint32[]\",\"name\":\"experience\",\"type\":\"uint32[]\"},{\"internalType\":\"int32[]\",\"name\":\"heal\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaRegen\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"lifeChancesRecovered\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"damage\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaConsumed\",\"type\":\"int32[]\"},{\"internalType\":\"address[][]\",\"name\":\"mintItems\",\"type\":\"address[][]\"},{\"internalType\":\"uint32[][]\",\"name\":\"mintItemsChances\",\"type\":\"uint32[][]\"}],\"internalType\":\"struct IStoryController.AnswerResultMeta\",\"name\":\"successInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[][]\",\"name\":\"attributeIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"int32[][]\",\"name\":\"attributeValues\",\"type\":\"int32[][]\"},{\"internalType\":\"uint32[]\",\"name\":\"experience\",\"type\":\"uint32[]\"},{\"internalType\":\"int32[]\",\"name\":\"heal\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaRegen\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"lifeChancesRecovered\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"damage\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaConsumed\",\"type\":\"int32[]\"},{\"internalType\":\"address[][]\",\"name\":\"mintItems\",\"type\":\"address[][]\"},{\"internalType\":\"uint32[][]\",\"name\":\"mintItemsChances\",\"type\":\"uint32[][]\"}],\"internalType\":\"struct IStoryController.AnswerResultMeta\",\"name\":\"failInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"int16[][]\",\"name\":\"dataValues\",\"type\":\"int16[][]\"}],\"internalType\":\"struct IStoryController.AnswerCustomDataResultMeta\",\"name\":\"successHeroCustomData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"int16[][]\",\"name\":\"dataValues\",\"type\":\"int16[][]\"}],\"internalType\":\"struct IStoryController.AnswerCustomDataResultMeta\",\"name\":\"failHeroCustomData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"int16[][]\",\"name\":\"dataValues\",\"type\":\"int16[][]\"}],\"internalType\":\"struct IStoryController.AnswerCustomDataResultMeta\",\"name\":\"successGlobalCustomData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"int16[][]\",\"name\":\"dataValues\",\"type\":\"int16[][]\"}],\"internalType\":\"struct IStoryController.AnswerCustomDataResultMeta\",\"name\":\"failGlobalCustomData\",\"type\":\"tuple\"}],\"internalType\":\"struct IStoryController.StoryMetaInfo\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setAllStoryFields\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bool[][]\",\"name\":\"cores\",\"type\":\"bool[][]\"},{\"internalType\":\"uint8[][]\",\"name\":\"ids\",\"type\":\"uint8[][]\"},{\"internalType\":\"int32[][]\",\"name\":\"values\",\"type\":\"int32[][]\"}],\"internalType\":\"struct IStoryController.AnswerAttributeRequirementsMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setAnswerAttributeRequirements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint32[]\",\"name\":\"randomRequirements\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"delayRequirements\",\"type\":\"uint32[]\"},{\"internalType\":\"bool[]\",\"name\":\"isFinalAnswer\",\"type\":\"bool[]\"}],\"internalType\":\"struct IStoryController.AnswerAttributesMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setAnswerAttributes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"mandatory\",\"type\":\"bool[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMin\",\"type\":\"uint64[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMax\",\"type\":\"uint64[][]\"}],\"internalType\":\"struct IStoryController.AnswerCustomDataMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setAnswerGlobalCustomDataRequirementMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"mandatory\",\"type\":\"bool[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMin\",\"type\":\"uint64[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"dataValuesMax\",\"type\":\"uint64[][]\"}],\"internalType\":\"struct IStoryController.AnswerCustomDataMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setAnswerHeroCustomDataRequirementMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"address[][]\",\"name\":\"requireItems\",\"type\":\"address[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"requireItemBurn\",\"type\":\"bool[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"requireItemEquipped\",\"type\":\"bool[][]\"}],\"internalType\":\"struct IStoryController.AnswerItemRequirementsMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setAnswerItemRequirements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"answerResultIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[][]\",\"name\":\"answerNextPageIds\",\"type\":\"uint16[][]\"}],\"internalType\":\"struct IStoryController.AnswerNextPageMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setAnswerNextPageMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"address[][]\",\"name\":\"requireToken\",\"type\":\"address[][]\"},{\"internalType\":\"uint88[][]\",\"name\":\"requireAmount\",\"type\":\"uint88[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"requireTransfer\",\"type\":\"bool[][]\"}],\"internalType\":\"struct IStoryController.AnswerTokenRequirementsMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setAnswerTokenRequirementsMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"internalType\":\"uint16[]\",\"name\":\"answerPageIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"answerHeroClasses\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerIds\",\"type\":\"uint16[]\"}],\"name\":\"setAnswersMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[][]\",\"name\":\"slots\",\"type\":\"uint8[][]\"},{\"internalType\":\"uint64[][]\",\"name\":\"chances\",\"type\":\"uint64[][]\"},{\"internalType\":\"bool[][]\",\"name\":\"isStopIfBurnt\",\"type\":\"bool[][]\"}],\"internalType\":\"struct IStoryController.AnswerBurnRandomItemMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setBurnItemsMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"dataIndexes\",\"type\":\"bytes32[][]\"},{\"internalType\":\"int16[][]\",\"name\":\"dataValues\",\"type\":\"int16[][]\"}],\"internalType\":\"struct IStoryController.AnswerCustomDataResultMeta\",\"name\":\"meta\",\"type\":\"tuple\"},{\"internalType\":\"enum IStoryController.CustomDataResult\",\"name\":\"type_\",\"type\":\"uint8\"}],\"name\":\"setCustomDataResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[][]\",\"name\":\"attributeIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"int32[][]\",\"name\":\"attributeValues\",\"type\":\"int32[][]\"},{\"internalType\":\"uint32[]\",\"name\":\"experience\",\"type\":\"uint32[]\"},{\"internalType\":\"int32[]\",\"name\":\"heal\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaRegen\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"lifeChancesRecovered\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"damage\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaConsumed\",\"type\":\"int32[]\"},{\"internalType\":\"address[][]\",\"name\":\"mintItems\",\"type\":\"address[][]\"},{\"internalType\":\"uint32[][]\",\"name\":\"mintItemsChances\",\"type\":\"uint32[][]\"}],\"internalType\":\"struct IStoryController.AnswerResultMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setFailInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"nextObjPageIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"nextObjHeroClasses\",\"type\":\"uint8[]\"},{\"internalType\":\"uint32[][]\",\"name\":\"nextObjIds\",\"type\":\"uint32[][]\"}],\"internalType\":\"struct IStoryController.NextObjRewriteMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setNextObjRewriteMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32[]\",\"name\":\"requiredCustomDataIndex\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"requiredCustomDataMinValue\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64[]\",\"name\":\"requiredCustomDataMaxValue\",\"type\":\"uint64[]\"},{\"internalType\":\"bool[]\",\"name\":\"requiredCustomDataIsHero\",\"type\":\"bool[]\"},{\"internalType\":\"uint256\",\"name\":\"minLevel\",\"type\":\"uint256\"}],\"name\":\"setStoryCustomDataRequirements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint16[]\",\"name\":\"pageId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"heroClass\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"answerId\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[][]\",\"name\":\"attributeIds\",\"type\":\"uint8[][]\"},{\"internalType\":\"int32[][]\",\"name\":\"attributeValues\",\"type\":\"int32[][]\"},{\"internalType\":\"uint32[]\",\"name\":\"experience\",\"type\":\"uint32[]\"},{\"internalType\":\"int32[]\",\"name\":\"heal\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaRegen\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"lifeChancesRecovered\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"damage\",\"type\":\"int32[]\"},{\"internalType\":\"int32[]\",\"name\":\"manaConsumed\",\"type\":\"int32[]\"},{\"internalType\":\"address[][]\",\"name\":\"mintItems\",\"type\":\"address[][]\"},{\"internalType\":\"uint32[][]\",\"name\":\"mintItemsChances\",\"type\":\"uint32[][]\"}],\"internalType\":\"struct IStoryController.AnswerResultMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"setSuccessInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"dungeonId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"stageId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"biome\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"storyAction\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"kill\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"heroToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"mintItems\",\"type\":\"address[]\"},{\"internalType\":\"int32\",\"name\":\"heal\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaRegen\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"lifeChancesRecovered\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"damage\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"manaConsumed\",\"type\":\"int32\"},{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"heroTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"rewriteNextObject\",\"type\":\"uint32[]\"}],\"internalType\":\"struct IGOC.ActionResult\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"storyId\",\"type\":\"uint16\"}],\"name\":\"storyBuildHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"objectId\",\"type\":\"uint32\"}],\"name\":\"storyIds\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidInitialization()\":[{\"details\":\"The contract is already initialized.\"}],\"NotInitializing()\":[{\"details\":\"The contract is not initializing.\"}]},\"events\":{\"Initialized(uint64)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"}},\"kind\":\"dev\",\"methods\":{\"created()\":{\"returns\":{\"_0\":\"Creation timestamp\"}},\"createdBlock()\":{\"returns\":{\"_0\":\"Creation block number\"}},\"increaseRevision(address)\":{\"details\":\"Revision should be increased on each contract upgrade\"},\"isController(address)\":{\"details\":\"Return true if given address is controller\"},\"onERC721Received(address,address,uint256,bytes)\":{\"details\":\"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`.\"},\"previousImplementation()\":{\"details\":\"Previous logic implementation\"},\"revision()\":{\"details\":\"Contract upgrade counter\"}},\"stateVariables\":{\"VERSION\":{\"details\":\"Should be incremented when contract changed\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"CONTROLLABLE_VERSION()\":{\"notice\":\"Version of the contract\"},\"VERSION()\":{\"notice\":\"Version of the contract\"},\"controller()\":{\"notice\":\"Return controller address saved in the contract slot\"},\"created()\":{\"notice\":\"Return creation timestamp\"},\"createdBlock()\":{\"notice\":\"Return creation block number\"},\"isGovernance(address)\":{\"notice\":\"Return true if given address is setup as governance in Controller\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/StoryController.sol\":\"StoryController\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":50},\"remappings\":[]},\"sources\":{\"contracts/core/StoryController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n/**\\n            \\u2592\\u2593\\u2592  \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2593\\n             \\u2592\\u2588\\u2588\\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593  \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n              \\u2592\\u2588\\u2588\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592 \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n               \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592                   \\u2592\\u2588\\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                     \\u2592\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592     \\u2593\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                   \\u2592\\u2592\\u2592\\u2592\\u2592   \\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                         \\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593      \\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                       \\u2592\\u2588\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592      \\u2592\\u2592\\u2593\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\n                        \\u2592\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592       \\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\n                          \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593   \\u2592\\u2592\\u2592\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                           \\u2592\\u2592\\u2593\\u2593\\u2592   \\u2592\\u2588\\u2588\\u2593\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                  \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n                                 \\u2588\\u2588\\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\n                                \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n                                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\n      \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593                  \\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592                      \\u2592\\u2593\\u2593\\n    \\u2592\\u2593\\u2588\\u2592   \\u2592\\u2592\\u2588\\u2592\\u2592                   \\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2592\\u2593\\u2593\\u2592\\n   \\u2592\\u2592\\u2588\\u2592       \\u2593\\u2592                    \\u2592\\u2588\\u2588\\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2588\\u2593\\u2592\\n   \\u2593\\u2592\\u2588\\u2588\\u2593\\u2592                             \\u2588\\u2588                       \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2588\\u2588\\u2592\\n    \\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2593\\u2592        \\u2592\\u2592\\u2592         \\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592\\u2592\\u2593\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2592 \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n     \\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2592\\u2592\\u2593\\u2592     \\u2592\\u2592\\u2592\\u2593\\u2593     \\u2593\\u2593  \\u2593\\u2593\\u2588\\u2593   \\u2592\\u2592\\u2593\\u2593   \\u2592\\u2592\\u2588\\u2592   \\u2592\\u2593\\u2592\\u2593\\u2588\\u2593\\n            \\u2592\\u2592\\u2593\\u2593\\u2593\\u2592\\u2593\\u2592  \\u2592\\u2593\\u2593\\u2593\\u2592\\u2588\\u2592   \\u2592\\u2592\\u2592\\u2588\\u2592          \\u2592\\u2592\\u2588\\u2593\\u2592\\u2592\\u2592\\u2593\\u2593\\u2593\\u2592   \\u2593\\u2588\\u2588\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\n \\u2592            \\u2592\\u2593\\u2593\\u2588\\u2593  \\u2592\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2588\\u2593  \\u2592\\u2588\\u2593\\u2593\\u2592          \\u2593\\u2593\\u2588\\u2593\\u2592\\u2593\\u2588\\u2593\\u2592\\u2592   \\u2593\\u2588\\u2593        \\u2593\\u2588\\u2588\\u2588\\u2593\\n\\u2593\\u2593\\u2592         \\u2592\\u2592\\u2593\\u2593\\u2588\\u2593\\u2592\\u2592\\u2593\\u2588\\u2592   \\u2592\\u2593\\u2588\\u2588\\u2593  \\u2593\\u2588\\u2588\\u2593\\u2592     \\u2592\\u2588\\u2593 \\u2593\\u2593\\u2588\\u2588   \\u2592\\u2593\\u2593\\u2593\\u2592\\u2592\\u2593\\u2588\\u2593        \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2592\\n \\u2588\\u2588\\u2593\\u2593\\u2592\\u2592\\u2592\\u2592\\u2593\\u2593\\u2588\\u2588\\u2588\\u2593\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592 \\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592\\u2592\\u2592\\u2593\\u2588\\u2593\\u2593\\u2593\\u2593\\u2588\\u2593\\u2593\\u2592\\u2592\\u2593\\u2593\\u2593\\u2593\\u2593\\u2592    \\u2592\\u2593\\u2588\\u2588\\u2588\\u2588\\u2593\\u2592     \\u2593\\u2593\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2593\\u2593\\u2592\\n*/\\npragma solidity 0.8.23;\\n\\nimport \\\"../proxy/Controllable.sol\\\";\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../lib/StoryControllerLib.sol\\\";\\nimport \\\"../openzeppelin/ERC721Holder.sol\\\";\\n\\ncontract StoryController is Controllable, IStoryController, ERC721Holder {\\n  //region ------------------------ CONSTANTS\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant override VERSION = \\\"2.1.1\\\";\\n  //endregion ------------------------ CONSTANTS\\n\\n  //region ------------------------ INITIALIZER\\n\\n  function init(address controller_) external initializer {\\n    __Controllable_init(controller_);\\n  }\\n  //endregion ------------------------ INITIALIZER\\n\\n  //region ------------------------ VIEWS\\n  function idToStory(uint16 storyId) external view returns (uint32) {\\n    return StoryControllerLib.idToStory(storyId);\\n  }\\n\\n  function storyBuildHash(uint16 storyId) external view returns (uint) {\\n    return StoryControllerLib.storyBuildHash(storyId);\\n  }\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view override returns (uint16 pageId) {\\n    return StoryControllerLib.heroPage(hero, heroId, storyId);\\n  }\\n\\n  function storyIds(uint32 objectId) external view override returns (uint16) {\\n    return StoryControllerLib.storyIds(objectId);\\n  }\\n\\n  function registeredStories(uint32 objectId) external view override returns (bool) {\\n    return StoryControllerLib.registeredStories(objectId);\\n  }\\n\\n  function allStoryPagesLength(uint16 storyId) external view returns (uint) {\\n    return StoryControllerLib.allStoryPagesLength(storyId);\\n  }\\n\\n  function allStoryPages(uint16 storyId, uint index) external view returns (uint) {\\n    return StoryControllerLib.allStoryPages(storyId, index);\\n  }\\n\\n  function allStoryAnswersLength(uint16 storyId) external view returns (uint) {\\n    return StoryControllerLib.allStoryAnswersLength(storyId);\\n  }\\n\\n  function allStoryAnswers(uint16 storyId, uint index) external view returns (bytes32) {\\n    return StoryControllerLib.allStoryAnswers(storyId, index);\\n  }\\n\\n  function currentHeroAnswers(uint16 storyId, address hero, uint80 heroId) public view returns (bytes32[] memory) {\\n    return StoryControllerLib.currentHeroAnswers(IController(controller()), storyId, hero, heroId);\\n  }\\n\\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view override returns (bool) {\\n    return StoryControllerLib.isStoryAvailableForHero(IController(controller()), objectId, heroToken, heroTokenId);\\n  }\\n\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ SETTERS\\n\\n  function setAllStoryFields(StoryMetaInfo calldata meta) external {\\n    StoryControllerLib.setAllStoryFields(IController(controller()), meta);\\n  }\\n\\n  function setBurnItemsMeta(uint16 storyId, AnswerBurnRandomItemMeta calldata meta) external {\\n    StoryControllerLib.setBurnItemsMeta(IController(controller()), storyId, meta);\\n  }\\n\\n  function setNextObjRewriteMeta(uint16 storyId, NextObjRewriteMeta calldata meta) external {\\n    StoryControllerLib.setNextObjRewriteMeta(IController(controller()), storyId, meta);\\n  }\\n\\n  function setAnswersMeta(\\n    uint16 storyId,\\n    uint16[] calldata answerPageIds,\\n    uint8[] calldata answerHeroClasses,\\n    uint16[] calldata answerIds\\n  ) external {\\n    StoryControllerLib.setAnswersMeta(IController(controller()), storyId, answerPageIds, answerHeroClasses, answerIds);\\n  }\\n\\n  function setAnswerNextPageMeta(uint16 storyId, AnswerNextPageMeta calldata meta) external {\\n    StoryControllerLib.setAnswerNextPageMeta(IController(controller()), storyId, meta);\\n  }\\n\\n  function setAnswerAttributeRequirements(uint16 storyId, AnswerAttributeRequirementsMeta calldata meta) external {\\n    StoryControllerLib.setAnswerAttributeRequirements(IController(controller()), storyId, meta);\\n  }\\n\\n  function setAnswerItemRequirements(uint16 storyId, AnswerItemRequirementsMeta calldata meta) external {\\n    StoryControllerLib.setAnswerItemRequirements(IController(controller()), storyId, meta);\\n  }\\n\\n  function setAnswerTokenRequirementsMeta(uint16 storyId, AnswerTokenRequirementsMeta calldata meta) external {\\n    StoryControllerLib.setAnswerTokenRequirementsMeta(IController(controller()), storyId, meta);\\n  }\\n\\n  function setAnswerAttributes(uint16 storyId, AnswerAttributesMeta calldata meta) external {\\n    StoryControllerLib.setAnswerAttributes(IController(controller()), storyId, meta);\\n  }\\n\\n  function setAnswerHeroCustomDataRequirementMeta(uint16 storyId, AnswerCustomDataMeta calldata meta) external {\\n    StoryControllerLib.setAnswerHeroCustomDataRequirementMeta(IController(controller()), storyId, meta);\\n  }\\n\\n  function setAnswerGlobalCustomDataRequirementMeta(uint16 storyId, AnswerCustomDataMeta calldata meta) external {\\n    StoryControllerLib.setAnswerGlobalCustomDataRequirementMeta(IController(controller()), storyId, meta);\\n  }\\n\\n  function setSuccessInfo(uint16 storyId, AnswerResultMeta calldata meta) external {\\n    StoryControllerLib.setSuccessInfo(IController(controller()), storyId, meta);\\n  }\\n\\n  function setFailInfo(uint16 storyId, AnswerResultMeta calldata meta) external {\\n    StoryControllerLib.setFailInfo(IController(controller()), storyId, meta);\\n  }\\n\\n  function setCustomDataResult(uint16 storyId, AnswerCustomDataResultMeta calldata meta, CustomDataResult type_) external {\\n    StoryControllerLib.setCustomDataResult(IController(controller()), storyId, meta, type_);\\n  }\\n\\n  function setStoryCustomDataRequirements(\\n    uint16 storyId,\\n    bytes32[] calldata requiredCustomDataIndex,\\n    uint64[] calldata requiredCustomDataMinValue,\\n    uint64[] calldata requiredCustomDataMaxValue,\\n    bool[] calldata requiredCustomDataIsHero,\\n    uint minLevel\\n  ) external {\\n    StoryControllerLib.setStoryCustomDataRequirements(\\n      IController(controller()),\\n      storyId,\\n      requiredCustomDataIndex,\\n      requiredCustomDataMinValue,\\n      requiredCustomDataMaxValue,\\n      requiredCustomDataIsHero,\\n      minLevel\\n    );\\n  }\\n\\n  function finalizeStoryRegistration(uint16 storyId, uint32 objectId, uint buildHash) external {\\n    StoryControllerLib.finalizeStoryRegistration(IController(controller()), storyId, objectId, buildHash);\\n  }\\n  //endregion ------------------------ SETTERS\\n\\n  //region ------------------------ CHANGE META\\n\\n  function removeStory(uint32 objectId) external {\\n    StoryControllerLib.removeStory(IController(controller()), objectId);\\n  }\\n\\n  function removeStoryPagesMeta(uint16 storyId, uint maxIterations) external {\\n    StoryControllerLib.removeStoryPagesMeta(IController(controller()), storyId, maxIterations);\\n  }\\n\\n  function removeStoryAnswersMeta(uint16 storyId, uint maxIterations) external {\\n    StoryControllerLib.removeStoryAnswersMeta(IController(controller()), storyId, maxIterations);\\n  }\\n  //endregion ------------------------ CHANGE META\\n\\n  //region ------------------------ MAIN LOGIC\\n\\n  function storyAction(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) external override returns (IGOC.ActionResult memory result) {\\n    return StoryControllerLib.storyAction(\\n      IController(controller()),\\n      sender,\\n      dungeonId,\\n      objectId,\\n      stageId,\\n      heroToken,\\n      heroTokenId,\\n      biome,\\n      iteration,\\n      data\\n    );\\n  }\\n  //endregion ------------------------ MAIN LOGIC\\n\\n}\\n\",\"keccak256\":\"0x18be6a9f293f7d29a11119b152806cd54bd2bfb2cc60d85cd2936e8666a4a8e7\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IAppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\n/// @notice All errors of the app\\ninterface IAppErrors {\\n  error ZeroAddress();\\n  error ZeroValueNotAllowed();\\n  error LengthsMismatch();\\n  error NotEnoughBalance();\\n\\n  //region Restrictions\\n  error ErrorNotDeployer(address sender);\\n  error ErrorNotGoc();\\n  error NotGovernance(address sender);\\n  error ErrorOnlyEoa();\\n  error NotEOA(address sender);\\n  error ErrorForbidden(address sender);\\n  error ErrorNotItemController(address sender);\\n  error ErrorNotHeroController(address sender);\\n  error ErrorNotDungeonFactory(address sender);\\n  error ErrorNotObjectController(address sender);\\n  //endregion Restrictions\\n\\n  //region Hero\\n  error ErrorHeroIsNotRegistered(address heroToken);\\n  error ErrorHeroIsDead(address heroToken, uint heroTokenId);\\n  error ErrorHeroNotInDungeon();\\n  error HeroInDungeon();\\n  error ErrorNotHeroOwner(address heroToken, address msgSender);\\n  error Staked(address heroToken, uint heroId);\\n  error HeroTokensVaultAlreadySet();\\n  error NameTaken();\\n  error TooBigName();\\n  error WrongSymbolsInTheName();\\n  error NoPayToken(address token, uint payTokenAmount);\\n  error AlreadyHaveReinforcement();\\n  //endregion Hero\\n\\n  //region Dungeon\\n  error ErrorDungeonIsFreeAlready();\\n  error ErrorNoEligibleDungeons();\\n  error ErrorDungeonBusy();\\n  error ErrorNoDungeonsForBiome(uint8 heroBiome);\\n  error ErrorDungeonCompleted();\\n  error ErrorAlreadyInDungeon();\\n  error NotEnoughTokens(uint balance, uint expectedBalance);\\n  error DungeonAlreadySpecific(uint16 dungNum);\\n  error DungeonAlreadySpecific2(uint16 dungNum);\\n  error WrongSpecificDungeon();\\n  //endregion Dungeon\\n\\n  //region Items\\n  error ErrorItemNotEligibleForTheSlot(uint itemType, uint8 itemSlot);\\n  error ErrorItemSlotBusyHand(uint8 slot);\\n  error ErrorItemSlotBusy();\\n  error ErrorItemNotInSlot();\\n  error ErrorConsumableItemIsUsed(address item);\\n  error ErrorCannotRemoveItemFromMap();\\n  error ItemEquipped();\\n  error ZeroItemMetaType();\\n  error ZeroLevel();\\n  error ItemTypeChanged();\\n  error ItemMetaTypeChanged();\\n  error UnknownItem(address item);\\n  error ItemIsAlreadyEquipped(address item);\\n  error ErrorEquipForbidden();\\n  error EquipForbiddenInDungeon();\\n  error TakeOffForbiddenInDungeon();\\n  error Consumable(address item);\\n  error NotConsumable(address item);\\n  error Broken(address item);\\n  error ZeroLife();\\n  error RequirementsToItemAttributes();\\n  error NotEquipped(address item);\\n  error ZeroDurability();\\n  error ZeroAugmentation();\\n  error TooHighAgLevel(uint8 augmentationLevel);\\n  error UseForbiddenZeroPayToken();\\n  error IncorrectMinMaxAttributeRange(int32 min, int32 max);\\n  error SameIdsNotAllowed();\\n  //endregion Items\\n\\n  //region Stages\\n  error ErrorWrongStage(uint stage);\\n  error ErrorNotStages();\\n  //endregion Stages\\n\\n  //region Level\\n  error ErrorWrongLevel(uint heroLevel);\\n  error ErrorLevelTooLow(uint heroLevel);\\n  error ErrorHeroLevelStartFrom1();\\n  error ErrorWrongLevelUpSum();\\n  error ErrorMaxLevel();\\n  //endregion Level\\n\\n  //region Treasure\\n  error ErrorNotValidTreasureToken(address treasureToken);\\n  //endregion Treasure\\n\\n  //region State\\n  error ErrorPaused();\\n  error ErrorNotReady();\\n  error ErrorNotObject1();\\n  error ErrorNotObject2();\\n  error ErrorNotCompleted();\\n  //endregion State\\n\\n  //region Biome\\n  error ErrorNotBiome();\\n  error ErrorIncorrectBiome(uint biome);\\n  error TooHighBiome(uint biome);\\n  //endregion Biome\\n\\n  //region Misc\\n  error ErrorWrongMultiplier(uint multiplier);\\n  error ErrorNotEnoughMana(uint32 mana, uint requiredMana);\\n  error ErrorExperienceMustNotDecrease();\\n  error ErrorNotEnoughExperience();\\n  error ErrorNotChances();\\n  error ErrorNotEligible(address heroToken, uint16 dungNum);\\n  error ErrorZeroKarmaNotAllowed();\\n  //endregion Misc\\n\\n  //region GOC\\n  error GenObjectIdBiomeOverflow(uint8 biome);\\n  error GenObjectIdSubTypeOverflow(uint subType);\\n  error GenObjectIdIdOverflow(uint id);\\n  error UnknownObjectTypeGoc1(uint8 objectType);\\n  error UnknownObjectTypeGoc2(uint8 objectType);\\n  error UnknownObjectTypeGocLib1(uint8 objectType);\\n  error UnknownObjectTypeGocLib2(uint8 objectType);\\n  error UnknownObjectTypeForSubtype(uint8 objectSubType);\\n  error FightDelay();\\n  error ZeroChance();\\n  error TooHighChance(uint32 chance);\\n  error TooHighRandom(uint random);\\n  error EmptyObjects();\\n  error ObjectNotFound();\\n  error WrongGetObjectTypeInput();\\n  error WrongChances(uint32 chances, uint32 maxChances);\\n  //endregion GOC\\n\\n  //region Story\\n  error PageNotRemovedError(uint pageId);\\n  error NotItem1();\\n  error NotItem2();\\n  error NotRandom(uint32 random);\\n  error NotHeroData();\\n  error NotGlobalData();\\n  error ZeroStoryIdRemoveStory();\\n  error ZeroStoryIdStoryAction();\\n  error ZeroStoryIdAction();\\n  error NotEnoughAmount(uint balance, uint requiredAmount);\\n  error NotAnswer();\\n  error AnswerStoryIdMismatch(uint16 storyId, uint16 storyIdFromAnswerHash);\\n  error AnswerPageIdMismatch(uint16 pageId, uint16 pageIdFromAnswerHash);\\n  //endregion Story\\n\\n  //region FightLib\\n  error NotMagic();\\n  error NotAType(uint atype);\\n  //endregion FightLib\\n\\n  //region MonsterLib\\n  error NotYourDebuffItem();\\n  error UnknownAttackType(uint attackType);\\n  error NotYourAttackItem();\\n  error NotYourBuffItem();\\n  //endregion MonsterLib\\n\\n  //region GameToken\\n  error ApproveToZeroAddress();\\n  error MintToZeroAddress();\\n  error TransferToZeroAddress();\\n  error TransferAmountExceedsBalance(uint balance, uint value);\\n  error InsufficientAllowance();\\n  error BurnAmountExceedsBalance();\\n  error NotMinter(address sender);\\n  //endregion GameToken\\n\\n  //region NFT\\n  error TokenTransferNotAllowed();\\n  error IdOverflow(uint id);\\n  error NotExistToken(uint tokenId);\\n  error EquippedItemIsNotAllowedToTransfer(uint tokenId);\\n  //endregion NFT\\n\\n  //region CalcLib\\n  error TooLowX(uint x);\\n  //endregion CalcLib\\n\\n  //region Controller\\n  error NotFutureGovernance(address sender);\\n  //endregion Controller\\n\\n  //region Oracle\\n  error OracleWrongInput();\\n  //region Oracle\\n\\n  //region ReinforcementController\\n  error AlreadyStaked();\\n  error MaxFee(uint8 fee);\\n  error StakeHeroNotStats();\\n  error NotStaked();\\n  error NoStakedHeroes();\\n  //region ReinforcementController\\n\\n  //region SponsoredHero\\n  error InvalidHeroClass();\\n  error ZeroAmount();\\n  error InvalidProof();\\n  error NoHeroesAvailable();\\n  error AlreadyRegistered();\\n  //endregion SponsoredHero\\n\\n  //region SacraRelay\\n  error SacraRelayNotOwner();\\n  error SacraRelayNotDelegator();\\n  error SacraRelayNotOperator();\\n  error SacraRelayInvalidChainId(uint callChainId, uint blockChainId);\\n  error SacraRelayInvalidNonce(uint callNonce, uint txNonce);\\n  error SacraRelayDeadline();\\n  error SacraRelayDelegationExpired();\\n  error SacraRelayNotAllowed();\\n  error SacraRelayInvalidSignature();\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error by selector, see tests\\n  error SacraRelayNoErrorSelector(bytes4 selector, string tracingInfo);\\n  /// @notice This error is generated when custom error is caught\\n  /// There is no info about custom error in SacraRelay\\n  /// but you can decode custom error manually from {errorBytes} as following:\\n  /// if (keccak256(abi.encodeWithSignature(\\\"MyError()\\\")) == keccak256(errorBytes)) { ... }\\n  error SacraRelayUnexpectedReturnData(bytes errorBytes, string tracingInfo);\\n  error SacraRelayCallToNotContract(address notContract, string tracingInfo);\\n  //endregion SacraRelay\\n\\n  //region Misc\\n  error UnknownHeroClass(uint heroClass);\\n  error AbsDiff(int32 a, int32 b);\\n  //region Misc\\n}\\n\",\"keccak256\":\"0xc27d17dbfa76c8ebb21557d83e2ca966cfdf23bff69d6f632c0bf000ec6614b6\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IApplicationEvents.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IDungeonFactory.sol\\\";\\nimport \\\"./IStoryController.sol\\\";\\nimport \\\"./IFightCalculator.sol\\\";\\n\\n/// @notice All events of the app\\ninterface IApplicationEvents {\\n\\n  //region ------------------ StatController\\n  event HeroItemSlotChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint itemType,\\n    uint itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip,\\n    address caller\\n  );\\n  event CurrentStatsChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    IStatController.ChangeableStats change,\\n    bool increase,\\n    address caller\\n  );\\n  event BonusAttributesChanged(\\n    address heroToken,\\n    uint heroTokenId,\\n    bool add,\\n    bool temporally,\\n    address caller\\n  );\\n  event TemporallyAttributesCleared(address heroToken, uint heroTokenId, address caller);\\n  event NewHeroInited(address heroToken, uint heroTokenId, IStatController.ChangeableStats stats);\\n  event LevelUp(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint heroClass,\\n    IStatController.CoreAttributes change\\n  );\\n  event ConsumableUsed(address heroToken, uint heroTokenId, address item);\\n  event RemoveConsumableUsage(address heroToken, uint heroTokenId, address item);\\n  event HeroCustomDataChanged(address token, uint tokenId, bytes32 index, uint value);\\n  event GlobalCustomDataChanged(bytes32 index, uint value);\\n  //endregion ------------------ StatController\\n\\n  //region ------------------ DungeonFactoryController\\n  event DungeonLaunched(\\n    uint16 dungeonLogicNum,\\n    uint64 dungeonId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address treasuryToken,\\n    uint treasuryAmount\\n  );\\n\\n  event BossCompleted(uint32 objectId, uint biome, address hero, uint heroId);\\n  event FreeDungeonAdded(uint8 biome, uint64 dungeonId);\\n\\n  event ObjectOpened(uint64 dungId, address hero, uint id, uint32 objId, uint iteration, uint currentStage);\\n  event Clear(uint64 dungId);\\n\\n  event DungeonLogicRegistered(uint16 dungLogicId, IDungeonFactory.DungeonGenerateInfo info);\\n  event DungeonLogicRemoved(uint16 dungLogicId);\\n  event DungeonSpecificLogicRegistered(uint16 dungLogicId, uint biome, uint heroCls);\\n  event DungeonSpecificLogicRemoved(uint16 dungLogicId, uint heroLvl, uint heroCls);\\n  event DungeonRegistered(uint16 dungLogicId, uint64 dungeonId);\\n  event DungeonRemoved(uint16 dungLogicId, uint64 dungeonId);\\n  event MinLevelForTreasuryChanged(address token, uint level);\\n\\n  event ObjectAction(\\n    uint64 dungId,\\n    IGOC.ActionResult result,\\n    uint currentStage,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint newStage\\n  );\\n  /// @notice On add the item to the dungeon\\n  event AddTreasuryItem(uint64 dungId, address itemAdr, uint itemId);\\n  event AddTreasuryToken(uint64 dungId, address token, uint amount);\\n  event ClaimToken(uint64 dungId, address token, uint amount);\\n  event ClaimItem(uint64 dungId, address token, uint id);\\n\\n  event Entered(uint64 dungId, address hero, uint id);\\n  event DungeonCompleted(uint16 dungLogicNum, uint64 dungId, address hero, uint heroId);\\n  event Exit(uint64 dungId, bool claim);\\n  event FreeDungeonRemoved(uint8 biome, uint64 dungeonId);\\n  event HeroCurrentDungeonChanged(address hero, uint heroId, uint64 dungeonId);\\n  //endregion ------------------ DungeonFactoryController\\n\\n  //region ------------------ GameObjectController\\n  event EventRegistered(uint32 objectId, IGOC.EventRegInfo eventRegInfo);\\n  event StoryRegistered(uint32 objectId, uint16 storyId);\\n  event MonsterRegistered(uint32 objectId, IGOC.MonsterGenInfo monsterGenInfo);\\n  event ObjectRemoved(uint32 objectId);\\n  event ObjectResultEvent(\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    IGOC.ObjectType objectType,\\n    address hero,\\n    uint heroId,\\n    uint8 stageId,\\n    uint iteration,\\n    bytes data,\\n    IGOC.ActionResult result,\\n    uint salt\\n  );\\n  //endregion ------------------ GameObjectController\\n\\n  //region ------------------ StoryController\\n  event SetBurnItemsMeta(uint storyId, IStoryController.AnswerBurnRandomItemMeta meta);\\n  event SetNextObjRewriteMeta(uint storyId, IStoryController.NextObjRewriteMeta meta);\\n  event SetAnswersMeta(uint storyId, uint16[] answerPageIds, uint8[] answerHeroClasses, uint16[] answerIds);\\n  event SetAnswerNextPageMeta(uint storyId, IStoryController.AnswerNextPageMeta meta);\\n  event SetAnswerAttributeRequirements(uint storyId, IStoryController.AnswerAttributeRequirementsMeta meta);\\n  event SetAnswerItemRequirements(uint storyId, IStoryController.AnswerItemRequirementsMeta meta);\\n  event SetAnswerTokenRequirementsMeta(uint storyId, IStoryController.AnswerTokenRequirementsMeta meta);\\n  event SetAnswerAttributes(uint storyId, IStoryController.AnswerAttributesMeta meta);\\n  event SetAnswerHeroCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetAnswerGlobalCustomDataRequirementMeta(uint storyId, IStoryController.AnswerCustomDataMeta meta);\\n  event SetSuccessInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetFailInfo(uint storyId, IStoryController.AnswerResultMeta meta);\\n  event SetCustomDataResult(uint storyId, IStoryController.AnswerCustomDataResultMeta meta, IStoryController.CustomDataResult _type);\\n  event StoryCustomDataRequirements(uint storyId, bytes32 requiredCustomDataIndex, uint requiredCustomDataMinValue, uint requiredCustomDataMaxValue, bool requiredCustomDataIsHero);\\n  event StoryRequiredLevel(uint storyId, uint requiredLevel);\\n  event StoryFinalized(uint32 objectId, uint storyId);\\n  event StoryRemoved(uint32 objectId, uint storyId);\\n\\n  event ItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint objectId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event NotEquippedItemBurned(\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    address nftToken,\\n    uint nftId,\\n    uint stageId,\\n    uint iteration\\n  );\\n\\n  event StoryChangeAttributes(\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint64 dungeonId,\\n    uint storyId,\\n    uint stageId,\\n    uint iteration,\\n    int32[] attributes\\n  );\\n  //endregion ------------------ StoryController\\n\\n  //region ------------------------ HeroController\\n  event HeroTokensVaultSet(address value);\\n  event HeroRegistered(address hero, uint8 heroClass, address payToken, uint payAmount);\\n  event HeroCreated(address hero, uint heroId, string name, address owner, string refCode);\\n  event BiomeChanged(address hero, uint heroId, uint8 biome);\\n  event LevelUp(address hero, uint heroId, address owner, IStatController.CoreAttributes change);\\n  event ReinforcementAsked(address hero, uint heroId, address helpHeroToken, uint helpHeroId);\\n  event ReinforcementReleased(address hero, uint heroId, address helperToken, uint helperId);\\n  event Killed(address hero, uint heroId, address killer, bytes32[] dropItems, uint dropTokenAmount);\\n  //endregion ------------------------ HeroController\\n\\n  //region ------------------------ FightLib\\n  event FightResultProcessed(\\n    address sender,\\n    IFightCalculator.FightInfoInternal result,\\n    IFightCalculator.FightCall callData,\\n    uint iteration\\n  );\\n  //endregion ------------------------ FightLib\\n\\n  //region ------------------------ Oracle\\n  event Random(uint number, uint max);\\n  //endregion ------------------------ Oracle\\n\\n  //region ------------------------ Controller\\n  event OfferGovernance(address newGov);\\n  event GovernanceAccepted(address gov);\\n  event StatControllerChanged(address value);\\n  event StoryControllerChanged(address value);\\n  event GameObjectControllerChanged(address value);\\n  event ReinforcementControllerChanged(address value);\\n  event OracleChanged(address value);\\n  event TreasuryChanged(address value);\\n  event ItemControllerChanged(address value);\\n  event HeroControllerChanged(address value);\\n  event GameTokenChanged(address value);\\n  event DungeonFactoryChanged(address value);\\n  event ProxyUpdated(address proxy, address logic);\\n  event Claimed(address token, uint amount);\\n  event TokenStatusChanged(address token, bool status);\\n  //endregion ------------------------ Controller\\n\\n  //region ------------------------ HeroTokensVault\\n  event Process(address token, uint amount, address from, uint toBurn, uint toTreasury, uint toGov);\\n  //endregion ------------------------ HeroTokensVault\\n\\n  //region ------------------------ ReinforcementController\\n  event HeroStaked(address heroToken, uint heroId, uint biome, uint score);\\n  event HeroWithdraw(address heroToken, uint heroId);\\n  event HeroAsk(address heroToken, uint heroId);\\n  event TokenRewardRegistered(address heroToken, uint heroId, address token, uint amountAdded, uint totalAmount);\\n  event NftRewardRegistered(address heroToken, uint heroId, address token, uint id);\\n  event ToHelperRatioChanged(uint value);\\n  event ClaimedToken(address heroToken, uint heroId, address token, uint amount, address recipient);\\n  event ClaimedItem(address heroToken, uint heroId, address item, uint itemId, address recipient);\\n  event MinLevelChanged(uint8 value);\\n  event MinLifeChancesChanged(uint value);\\n  //endregion ------------------------ ReinforcementController\\n\\n  //region ------------------------ Treasury\\n  event AssetsSentToDungeon(address dungeon, address token, uint amount);\\n  //endregion ------------------------ Treasury\\n\\n  //region ------------------------ EventLib\\n  event EventResult(uint64 dungeonId, address heroToken, uint heroTokenId, uint8 stageId, IStatController.ActionInternalInfo gen, uint iteration);\\n  //endregion ------------------------ EventLib\\n\\n  //region ------------------------ ItemStatsLib\\n  event ItemRegistered(address item, IItemController.RegisterItemParams info);\\n  event ItemRemoved(address item);\\n  event NewItemMinted(address item, uint itemId, IItemController.MintInfo info);\\n  event Equipped(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot);\\n  event TakenOff(address item, uint itemId, address heroToken, uint heroTokenId, uint8 itemSlot, address destination);\\n  event ItemRepaired(address item, uint itemId, uint consumedItemId, uint16 baseDurability);\\n  event Augmented(address item, uint itemId, uint consumedItemId, uint8 augLevel, IItemController.AugmentInfo info);\\n  event NotAugmented(address item, uint itemId, uint consumedItemId, uint8 augLevel);\\n  event ReduceDurability(address item, uint itemId, uint newDurability);\\n  event Used(address item, uint tokenId, address heroToken, uint heroTokenId);\\n  event Destroyed(address item, uint itemId);\\n  //endregion ------------------------ ItemStatsLib\\n\\n  //region ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n  event ChangePauseStatus(bool value);\\n  event MinterChanged(address value);\\n\\n  event UniqueUriChanged(uint id, string uri);\\n  event BaseUriChanged(string uri);\\n\\n  event HeroMinted(uint heroId);\\n  event HeroBurned(uint heroId);\\n  event HeroUriByStatusChanged(string uri, uint statusLvl);\\n\\n  event ItemMinted(uint tokenId);\\n  event ItemBurned(uint tokenId);\\n  event UriByRarityChanged(string uri, uint rarity);\\n  event SponsoredHeroCreated(address msgSender, address heroAddress, uint heroId, string heroName);\\n  //endregion ------------------------ NFT and GameToken (only custom events, not ERC20/721 standards)\\n}\\n\",\"keccak256\":\"0x59c0edaa6af913073e0555125fcde7caac611a153b6905a101d9373b49d76705\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IControllable {\\n\\n  function VERSION() external pure returns (string memory);\\n\\n  function revision() external view returns (uint);\\n\\n  function previousImplementation() external view returns (address);\\n\\n  function isController(address contract_) external view returns (bool);\\n\\n  function isGovernance(address contract_) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0x296b634c46b5d178b2408523fcf569ed370e20a719b7b3f2183b278631b94f65\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IController {\\n\\n  function governance() external view returns (address);\\n\\n  function statController() external view returns (address);\\n\\n  function storyController() external view returns (address);\\n\\n  function gameObjectController() external view returns (address);\\n\\n  function reinforcementController() external view returns (address);\\n\\n  function oracle() external view returns (address);\\n\\n  function treasury() external view returns (address);\\n\\n  function itemController() external view returns (address);\\n\\n  function heroController() external view returns (address);\\n\\n  function dungeonFactory() external view returns (address);\\n\\n  function gameToken() external view returns (address);\\n\\n  function validTreasuryTokens(address token) external view returns (bool);\\n\\n  function isDeployer(address adr) external view returns (bool);\\n\\n  function onPause() external view returns (bool);\\n\\n}\\n\",\"keccak256\":\"0x277b18bde00efe407b007268d6a3b6524498d1616bf9ed9521980dd0048637dc\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDungeonFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"../openzeppelin/EnumerableMap.sol\\\";\\n\\ninterface IDungeonFactory {\\n\\n  /// @custom:storage-location erc7201:dungeon.factory.main\\n  struct MainState {\\n    /// @dev biome => dungeonLaunchedId\\n    mapping(uint => EnumerableSet.UintSet) freeDungeons;\\n    /// @dev hero + heroId + biome (packMapObject) -> completed\\n    mapping(bytes32 => bool) bossCompleted;\\n    /// @dev hero + heroId + dungNum (packDungeonKey) -> completed\\n    mapping(bytes32 => bool) specificDungeonCompleted;\\n    /// @notice Max biome completed by the hero\\n    /// @dev hero + heroId (nftPacked) -> max biome completed\\n    mapping(bytes32 => uint8) maxBiomeCompleted;\\n    /// @notice which dungeon the hero is currently in\\n    /// @dev hero+id => current DungeonId\\n    mapping(bytes32 => uint64) heroCurrentDungeon;\\n\\n    // ---\\n\\n    /// @notice Specific dungeon for the given pair of hero level + hero class\\n    ///         ALl specific dungeons are listed also in allSpecificDungeons\\n    /// @dev packUint8Array(specReqBiome, specReqHeroClass) => dungNum\\n    mapping(bytes32 => uint16) dungeonSpecific;\\n    /// @dev contains all specific dungNum for easy management\\n    EnumerableSet.UintSet allSpecificDungeons;\\n    /// @dev biome => dungNum\\n    mapping(uint8 => EnumerableSet.UintSet) dungeonsLogicByBiome;\\n\\n    // ---\\n\\n    /// @dev max available biome. auto-increment with new dung deploy\\n    uint8 maxBiome;\\n\\n    /// @notice Address of treasure token => min hero level required\\n    /// @dev manual threshold for treasury\\n    mapping(address => uint) minLevelForTreasury;\\n\\n    /// @notice Contains arrays for SKILL_1, SKILL_2, SKILL_3 with 0 or 1\\n    /// i.e. [0, 1, 0] means that durability of SKILL_2 should be reduced\\n    /// @dev hero + heroId => uint8[] array where idx = slotNum\\n    mapping(bytes32 => bytes32) skillSlotsForDurabilityReduction;\\n\\n    /// @notice Counter of dungeons, it's incremented on launch of a new dungeon\\n    uint64 dungeonCounter;\\n\\n    /// @dev dungNum = init attributes\\n    mapping(uint16 => DungeonAttributes) dungeonAttributes;\\n    /// @dev dungeonId => status\\n    mapping(uint64 => DungeonStatus) dungeonStatuses;\\n  }\\n\\n  struct ObjectGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    /// @dev uint8 types, packed using PackingLib.packUint8Array\\n    bytes32[] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    /// @dev uint64 chances\\n    uint32[][] objChancesByStages;\\n  }\\n\\n  struct DungeonGenerateInfo {\\n    /// @notice List of chamber types for each unique object\\n    uint8[][] objTypesByStages;\\n    /// @notice List of chances for each chamber type\\n    uint32[][] objChancesByStages;\\n\\n    uint32[] uniqObjects;\\n\\n    uint8 minLevel;\\n    uint8 maxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n  }\\n\\n  /// @notice Attributes of the given dungeon logic\\n  struct DungeonAttributes {\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    uint8 stages;\\n    uint8 biome;\\n\\n    /// @notice Default list of objects that should be passed in the dungeon\\n    uint32[] uniqObjects;\\n\\n    /// @dev min+max (packUint8Array)\\n    bytes32 minMaxLevel;\\n\\n    bytes32[] requiredCustomDataIndex;\\n    /// @notice Packed DungeonGenerateInfo.requiredCustomData: MinValue, MaxValue, IsHero\\n    /// @dev min+max+isHero(packStoryCustomDataRequirements)\\n    bytes32[] requiredCustomDataValue;\\n\\n    ObjectGenerateInfo info;\\n  }\\n\\n  /// @notice Current status of the given dungeon\\n  struct DungeonStatus {\\n    uint64 dungeonId;\\n    /// @notice Dungeon logic id\\n    uint16 dungNum;\\n\\n    /// @notice True if the dungeon is completed by the hero\\n    bool isCompleted;\\n\\n    /// @notice Hero in the dungeon or 0\\n    address heroToken;\\n    uint heroTokenId;\\n    /// @notice Current object that should be passed by the hero. 0 - new object is not opened\\n    uint32 currentObject;\\n    /// @notice Current stage in the dungeon that should be passed by the hero.\\n    uint8 currentStage;\\n\\n    EnumerableMap.AddressToUintMap treasuryTokens;\\n    /// @notice All items that were minted on result of made actions\\n    bytes32[] treasuryItems;\\n\\n    /// @notice Total number of stages that should be passed to complete the dungeon\\n    /// This value can be bigger than length of uniqObjects\\n    uint8 stages;\\n    /// @notice List of objects to be passed in the stage. The list can be dynamically changed during passing the stages\\n    uint32[] uniqObjects;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////\\n\\n  function launchForNewHero(address heroToken, uint heroTokenId, address owner) external returns (uint64 dungeonId);\\n\\n  function maxBiomeCompleted(address heroToken, uint heroTokenId) external view returns (uint8);\\n\\n  function currentDungeon(address heroToken, uint heroTokenId) external view returns (uint64);\\n\\n  function skillSlotsForDurabilityReduction(address heroToken, uint heroTokenId) external view returns (uint8[] memory result);\\n\\n  function setBossCompleted(uint32 objectId, address heroToken, uint heroTokenId, uint8 heroBiome) external;\\n\\n}\\n\",\"keccak256\":\"0x2f24028d35a06e44dc9bd096d8a1807cfa64518ebd73692a1cc479736814b741\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbca9de297214bb9c30daefda5ecaedd0af2c3e8e0440403ad543fb33528c5ef8\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xa365c0e17de806f6262765ef6236512674ac8563a6ee3436e81cec7b1d87468e\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  /**\\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n   */\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n  /**\\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n   */\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of tokens in ``owner``'s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\n   *\\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n   * The approval is cleared when the token is transferred.\\n   *\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n   *\\n   * Requirements:\\n   *\\n   * - The caller must own the token or be an approved operator.\\n   * - `tokenId` must exist.\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address to, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Returns the account approved for `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  /**\\n   * @dev Approve or remove `operator` as an operator for the caller.\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n   *\\n   * Requirements:\\n   *\\n   * - The `operator` cannot be the caller.\\n   *\\n   * Emits an {ApprovalForAll} event.\\n   */\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  /**\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n   *\\n   * See {setApprovalForAll}\\n   */\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n  /**\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must exist and be owned by `from`.\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0xe7d89e4cdfc41317d90bf469428b6ef17cec6eb6fccab0080bdf0378129d2708\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n  /**\\n   * @dev Returns the total amount of tokens stored by the contract.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n   * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n   * Use along with {totalSupply} to enumerate all tokens.\\n   */\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xfb4922e02edfabbe39d004e4c856701b6911d5d64174097f6c5c2ceee9b6faa3\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n  /**\\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n   * by `operator` from `from`, this function is called.\\n   *\\n   * It must return its Solidity selector to confirm the token transfer.\\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n   *\\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n   */\\n  function onERC721Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xe5e9287463463820051374de194e01b41e1b77c1df73fab6ea0409b485edf33d\",\"license\":\"MIT\"},\"contracts/interfaces/IFightCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface IFightCalculator {\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    MELEE, // 1\\n    MAGIC, // 2\\n    SLOT_3,\\n    SLOT_4,\\n    SLOT_5,\\n    SLOT_6,\\n    SLOT_7,\\n    SLOT_8,\\n    SLOT_9,\\n    SLOT_10\\n  }\\n\\n  /// @notice Attacker info: suitable both for hero and monsters\\n  struct AttackInfo {\\n    /// @notice Type of the attack\\n    /// by default, if attack token presents, it's magic attack and not-magic otherwise\\n    /// but this logic can become more complicated after introducing new attack types\\n    AttackType attackType;\\n    /// @notice NFT selected by hero for attack, it should be equip on.\\n    /// If attacker is a monster, this is a special case (stub NFT with zero ID is used)\\n    address attackToken;\\n    uint attackTokenId;\\n    address[] skillTokens;\\n    uint[] skillTokenIds;\\n  }\\n\\n  struct FighterInfo {\\n    int32[] fighterAttributes;\\n    IStatController.ChangeableStats fighterStats;\\n    AttackType attackType;\\n    address attackToken;\\n    uint attackTokenId;\\n    uint race;\\n  }\\n\\n  struct Statuses {\\n    bool stun;\\n    bool burn;\\n    bool freeze;\\n    bool confuse;\\n    bool curse;\\n    bool poison;\\n    bool gotCriticalHit;\\n    bool missed;\\n    bool hitBlocked;\\n  }\\n\\n  struct FightResult {\\n    int32 healthA;\\n    int32 healthB;\\n    int32 manaConsumedA;\\n    int32 manaConsumedB;\\n  }\\n\\n  struct FightCall {\\n    FighterInfo fighterA;\\n    FighterInfo fighterB;\\n    uint64 dungeonId;\\n    uint32 objectId;\\n    address heroAdr;\\n    uint heroId;\\n    uint8 stageId;\\n    uint iteration;\\n    uint8 turn;\\n  }\\n\\n  struct SkillSlots {\\n    bool slot1;\\n    bool slot2;\\n    bool slot3;\\n  }\\n\\n  //region ------------------------ FightLib-internal (FightInfoInternal is required by IApplicationEvents..)\\n  struct FightInfoInternal {\\n    Fighter fighterA;\\n    Fighter fighterB;\\n  }\\n\\n  struct Fighter {\\n    IFightCalculator.FighterInfo info;\\n    IItemController.AttackInfo magicAttack;\\n    int32 health;\\n    int32 manaConsumed;\\n    int32 damage;\\n    int32 damagePoison;\\n    int32 damageReflect;\\n    IFightCalculator.Statuses statuses;\\n  }\\n  //endregion ------------------------ FightLib-internal\\n\\n  function fight(FightCall memory callData) external returns (FightResult memory);\\n}\\n\",\"keccak256\":\"0xdf9ba809ea21a35a24eed12bf80e53452b0d772623d59211a35498b518eb604b\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IGOC.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\nimport \\\"./IController.sol\\\";\\n\\ninterface IGOC {\\n\\n  enum ObjectType {\\n    UNKNOWN, // 0\\n    EVENT, // 1\\n    MONSTER, // 2\\n    STORY, // 3\\n    END_SLOT\\n  }\\n\\n  enum ObjectSubType {\\n    UNKNOWN_0, // 0\\n    ENEMY_NPC_1, // 1\\n    ENEMY_NPC_SUPER_RARE_2, // 2\\n    BOSS_3, // 3\\n    SHRINE_4, // 4\\n    CHEST_5, // 5\\n    STORY_6, // 6\\n    STORY_UNIQUE_7, // 7\\n    SHRINE_UNIQUE_8, // 8\\n    CHEST_UNIQUE_9, // 9\\n    ENEMY_NPC_UNIQUE_10, // 10\\n    STORY_ON_ROAD_11, // 11\\n    STORY_UNDERGROUND_12, // 12\\n    STORY_NIGHT_CAMP_13, // 13\\n    STORY_MOUNTAIN_14, // 14\\n    STORY_WATER_15, // 15\\n    STORY_CASTLE_16, // 16\\n    STORY_HELL_17, // 17\\n    STORY_SPACE_18, // 18\\n    STORY_WOOD_19, // 19\\n    STORY_CATACOMBS_20, // 20\\n    STORY_BAD_HOUSE_21, // 21\\n    STORY_GOOD_TOWN_22, // 22\\n    STORY_BAD_TOWN_23, // 23\\n    STORY_BANDIT_CAMP_24, // 24\\n    STORY_BEAST_LAIR_25, // 25\\n    STORY_PRISON_26, // 26\\n    STORY_SWAMP_27, // 27\\n    STORY_INSIDE_28, // 28\\n    STORY_OUTSIDE_29, // 29\\n    STORY_INSIDE_RARE_30,\\n    STORY_OUTSIDE_RARE_31,\\n    ENEMY_NPC_INSIDE_32,\\n    ENEMY_NPC_INSIDE_RARE_33,\\n    ENEMY_NPC_OUTSIDE_34,\\n    ENEMY_NPC_OUTSIDE_RARE_35,\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:game.object.controller.main\\n  struct MainState {\\n\\n    /// @dev objId = biome(00) type(00) id(0000) => biome(uint8) + objType(uint8)\\n    /// Id is id of the event, story or monster.\\n    mapping(uint32 => bytes32) objectMeta;\\n\\n    /// @dev biome(uint8) + objType(uint8) => set of object id\\n    mapping(bytes32 => EnumerableSet.UintSet) objectIds;\\n\\n    /// @dev heroAdr180 + heroId64 + cType8 + biome8 => set of already played objects. Should be cleared periodically\\n    mapping(bytes32 => EnumerableSet.UintSet) playedObjects;\\n\\n    /// @dev HeroAdr(160) + heroId(uint64) + objId(uint32) => iteration count. It needs for properly emit events for every new entrance.\\n    mapping(bytes32 => uint) iterations;\\n\\n    /// @dev objId(uint32) => EventInfo\\n    mapping(uint32 => EventInfo) eventInfos;\\n\\n    /// @dev objId(uint32) => storyId\\n    mapping(uint32 => uint16) storyIds;\\n\\n    /// @dev objId(uint32) => MonsterInfo\\n    mapping(uint32 => MonsterInfo) monsterInfos;\\n\\n    /// @dev hero+id => last fight action timestamp\\n    mapping(bytes32 => uint) lastHeroFightTs;\\n\\n    /// @dev delay for user actions in fight (suppose to prevent bot actions)\\n    uint fightDelay;\\n  }\\n\\n  struct ActionResult {\\n    bool kill;\\n    bool completed;\\n    address heroToken;\\n    address[] mintItems;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n    uint32 objectId;\\n    uint32 experience;\\n    uint heroTokenId;\\n    uint iteration;\\n    uint32[] rewriteNextObject;\\n  }\\n\\n  struct EventInfo {\\n    /// @dev chance to use good or bad attributes/stats\\n    uint32 goodChance;\\n\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] goodAttributes;\\n    bytes32[] badAttributes;\\n\\n    /// @dev experience(uint32) + heal(int32) + manaRegen(int32) + lifeChancesRecovered(int32) + damage(int32) + manaConsume(int32) packStatsChange\\n    bytes32 statsChange;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n  }\\n\\n  struct MonsterInfo {\\n    /// @dev toBytes32ArrayWithIds\\n    bytes32[] attributes;\\n    /// @dev level(uint8) + race(uint8) + experience(uint32) + maxDropItems(uint8) packMonsterStats\\n    bytes32 stats;\\n    /// @dev attackToken(160) + attackTokenId(uint64) + attackType(uint8) packAttackInfo\\n    bytes32 attackInfo;\\n\\n    /// @dev item+chance packItemMintInfo\\n    bytes32[] mintItems;\\n\\n    /// @dev heroAdr(160) + heroId(uint64) => iteration => GeneratedMonster packed\\n    mapping(bytes32 => mapping(uint => bytes32)) _generatedMonsters;\\n  }\\n\\n  struct MultiplierInfo {\\n    uint8 biome;\\n    uint totalSupply;\\n  }\\n\\n  struct GeneratedMonster {\\n    bool generated;\\n    uint8 turnCounter;\\n    int32 hp;\\n    uint32 amplifier;\\n  }\\n\\n  struct MonsterGenInfo {\\n    uint16 monsterId;\\n    uint8 biome;\\n    ObjectSubType subType;\\n\\n    uint8[] attributeIds;\\n    int32[] attributeValues;\\n\\n    uint8 level;\\n    uint8 race;\\n    uint32 experience;\\n    uint8 maxDropItems;\\n\\n    address attackToken;\\n    uint64 attackTokenId;\\n    uint8 attackType;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct ActionContext {\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    uint8 biome;\\n    uint8 objectSubType;\\n    uint8 stageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint heroTokenId;\\n    uint salt;\\n    uint iteration;\\n    bytes data;\\n  }\\n\\n  struct EventRegInfo {\\n    uint8 biome;\\n    uint16 eventId;\\n    ObjectSubType subType;\\n\\n    uint32 goodChance;\\n\\n    AttributeGenerateInfo goodAttributes;\\n    AttributeGenerateInfo badAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintItems;\\n    uint32[] mintItemsChances;\\n  }\\n\\n  struct AttributeGenerateInfo {\\n    uint8[] ids;\\n    int32[] values;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n  //////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  /// @dev represent object registration if non zero values\\n  function getObjectMeta(uint32 objectId) external view returns (uint8 biome, uint8 objectSubType);\\n\\n  function isBattleObject(uint32 objectId) external view returns (bool);\\n\\n  function getRandomObject(\\n    uint8[] memory cTypes,\\n    uint32[] memory chances,\\n    uint8 biomeLevel,\\n    address heroToken,\\n    uint heroTokenId\\n  ) external returns (uint32 objectId);\\n\\n  function open(address heroToken, uint heroTokenId, uint32 objectId) external returns (uint iteration);\\n\\n  function action(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 stageId,\\n    bytes memory data\\n  ) external returns (ActionResult memory);\\n\\n}\\n\",\"keccak256\":\"0x6493b091bb99b51586b94064eea3eb60f5fa921c5a6f7e061b3c491a73b89a9e\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IHeroController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IHeroController {\\n\\n  /// @custom:storage-location erc7201:hero.controller.main\\n  struct MainState {\\n\\n    /// @dev A central place for all hero tokens\\n    address heroTokensVault;\\n\\n    /// @dev heroAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) payToken;\\n\\n    /// @dev heroAdr => heroCls8\\n    mapping(address => uint8) heroClass;\\n\\n    // ---\\n\\n    /// @dev hero+id => individual hero name\\n    mapping(bytes32 => string) heroName;\\n\\n    /// @dev name => hero+id, needs for checking uniq names\\n    mapping(string => bytes32) nameToHero;\\n\\n    // ---\\n\\n    /// @dev hero+id => biome\\n    mapping(bytes32 => uint8) heroBiome;\\n\\n    /// @dev hero+id => rein hero+id\\n    mapping(bytes32 => bytes32) reinforcementHero;\\n\\n    /// @dev hero+id => rein packed attributes\\n    mapping(bytes32 => bytes32[]) reinforcementHeroAttributes;\\n  }\\n\\n  function heroClass(address hero) external view returns (uint8);\\n\\n  function heroBiome(address hero, uint heroId) external view returns (uint8);\\n\\n  function payTokenInfo(address hero) external view returns (address token, uint amount);\\n\\n  function heroReinforcementHelp(address hero, uint heroId) external view returns (address helperHeroToken, uint helperHeroId);\\n\\n  function score(address hero, uint heroId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address hero, uint heroId) external view returns (bool);\\n\\n  function heroTokensVault() external view returns (address);\\n\\n  // ---\\n\\n  function create(address hero, string memory heroName_, bool enter) external returns (uint);\\n\\n  function kill(address hero, uint heroId) external returns (bytes32[] memory dropItems);\\n\\n  function releaseReinforcement(address hero, uint heroId) external returns (address helperToken, uint helperId);\\n\\n}\\n\",\"keccak256\":\"0x670ab48074f47c954a571035fb9abf04b193d524768b779047838e0990d39ef1\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItem.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IItem {\\n\\n  function isItem() external pure returns (bool);\\n\\n  function mintFor(address recipient) external returns (uint tokenId);\\n\\n  function burn(uint tokenId) external;\\n\\n  function controlledTransfer(address from, address to, uint tokenId) external;\\n}\\n\",\"keccak256\":\"0x766165af1a0ef65f8969414e165fdbc38294b5f249d280a3be272cbaa90721a7\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IItemController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IStatController.sol\\\";\\nimport \\\"./IGOC.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IItemController {\\n\\n  /// @custom:storage-location erc7201:item.controlbler.main\\n  struct MainState {\\n\\n    ////////////////// GENERATE //////////////////\\n\\n    EnumerableSet.AddressSet items;\\n\\n    /// @dev itemAdr => itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n    mapping(address => bytes32) itemMeta;\\n\\n    /// @dev itemAdr => packed tokenAdr160+ amount96\\n    mapping(address => bytes32) augmentInfo;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoAttributes;\\n\\n    // --- consumable ---\\n\\n    /// @dev itemAdr => ids+values (toBytes32ArrayWithIds)\\n    mapping(address => bytes32[]) _itemConsumableAttributes;\\n\\n    /// @dev itemAdr => IStatController.ChangeableStats packed int32[]\\n    mapping(address => bytes32) itemConsumableStats;\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr => id8 + min(int32) + max(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoCasterAttributes;\\n\\n    /// @dev itemAdr => id8 + minDmg(int32) + maxDmg(int32) + chance32\\n    mapping(address => bytes32[]) generateInfoTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(address => bytes32) generateInfoAttack;\\n\\n    ////////////////// ITEMS INFO //////////////////\\n\\n    /// @dev itemAdr+id => itemRarity8 + augmentationLevel8 + itemDurability16\\n    mapping(bytes32 => bytes32) itemInfo;\\n\\n    /// @dev itemAdr+id => heroAdr+id\\n    mapping(bytes32 => bytes32) equippedOn;\\n\\n    // --- common attr ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemAttributes;\\n\\n    // --- consumable ---\\n\\n    // consumable stats unchangeable, get them by address\\n\\n    // --- buff ---\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemCasterAttributes;\\n\\n    /// @dev itemAdr+Id => ids+values (toBytes32ArrayWithIds)\\n    mapping(bytes32 => bytes32[]) _itemTargetAttributes;\\n\\n    // --- attack ---\\n\\n    /// @dev itemAdr+Id => packed AttackInfo: attackType8 + min32 + max32 + factors(packed core 128)\\n    mapping(bytes32 => bytes32) _itemAttackInfo;\\n\\n  }\\n\\n  struct RegisterItemParams {\\n    ItemMeta itemMeta;\\n    address augmentToken;\\n    uint augmentAmount;\\n    ItemGenerateInfo commonAttributes;\\n\\n    IGOC.AttributeGenerateInfo consumableAttributes;\\n    IStatController.ChangeableStats consumableStats;\\n\\n    ItemGenerateInfo casterAttributes;\\n    ItemGenerateInfo targetAttributes;\\n\\n    AttackInfo genAttackInfo;\\n  }\\n\\n  struct ItemGenerateInfo {\\n    /// @notice Attribute ids\\n    uint8[] ids;\\n    /// @notice Min value of the attribute, != 0\\n    int32[] mins;\\n    /// @notice Max value of the attribute, != 0\\n    int32[] maxs;\\n    /// @notice Chance of the selection [0..MAX_CHANCES]\\n    uint32[] chances;\\n  }\\n\\n  struct ItemMeta {\\n    uint8 itemMetaType;\\n    // Level in range 1-99. Reducing durability in low level dungeons. lvl/5+1 = biome\\n    uint8 itemLevel;\\n    IItemController.ItemType itemType;\\n    uint16 baseDurability;\\n    uint8 defaultRarity;\\n    uint32 manaCost;\\n\\n    // it doesn't include positions with 100% chance\\n    uint8 minRandomAttributes;\\n    uint8 maxRandomAttributes;\\n\\n    IStatController.CoreAttributes requirements;\\n  }\\n\\n  enum FeeType {\\n    UNKNOWN,\\n    REPAIR,\\n    AUGMENT,\\n    STORY,\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemRarity {\\n    UNKNOWN, // 0\\n    NORMAL, // 1\\n    MAGIC, // 2\\n    RARE, // 3\\n    SET, // 4\\n    UNIQUE, // 5\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemType {\\n    NO_SLOT, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    RING, // 6\\n    OFF_HAND, // 7\\n    BOOTS, // 8\\n    ONE_HAND, // 9\\n    TWO_HAND, // 10\\n    SKILL, // 11\\n\\n    END_SLOT\\n  }\\n\\n  enum ItemMetaType {\\n    UNKNOWN, // 0\\n    COMMON, // 1\\n    ATTACK, // 2\\n    BUFF, // 3\\n    CONSUMABLE, // 4\\n\\n    END_SLOT\\n  }\\n\\n  enum AttackType {\\n    UNKNOWN, // 0\\n    FIRE, // 1\\n    COLD, // 2\\n    LIGHTNING, // 3\\n    CHAOS, // 4\\n\\n    END_SLOT\\n  }\\n\\n  struct AttackInfo {\\n    AttackType aType;\\n    int32 min;\\n    int32 max;\\n    // if not zero - activate attribute factor for the attribute\\n    IStatController.CoreAttributes attributeFactors;\\n  }\\n\\n  struct ItemInfo {\\n    ItemRarity rarity;\\n    uint8 augmentationLevel;\\n    uint16 durability;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct MintInfo {\\n    IItemController.ItemMeta meta;\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.ItemRarity itemRarity;\\n\\n    IItemController.AttackInfo attackInfo;\\n\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  /// @dev The struct is used in events, so it's moved here from the lib\\n  struct AugmentInfo {\\n    uint8[] attributesIds;\\n    int32[] attributesValues;\\n    IItemController.AttackInfo attackInfo;\\n    uint8[] casterIds;\\n    int32[] casterValues;\\n    uint8[] targetIds;\\n    int32[] targetValues;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  function itemMeta(address item) external view returns (ItemMeta memory meta);\\n\\n  function augmentInfo(address item) external view returns (address token, uint amount);\\n\\n  function genAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genCasterAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genTargetAttributeInfo(address item) external view returns (ItemGenerateInfo memory info);\\n\\n  function genAttackInfo(address item) external view returns (AttackInfo memory info);\\n\\n  function itemInfo(address item, uint itemId) external view returns (ItemInfo memory info);\\n\\n  function equippedOn(address item, uint itemId) external view returns (address hero, uint heroId);\\n\\n  function itemAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableAttributes(address item) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function consumableStats(address item) external view returns (IStatController.ChangeableStats memory stats);\\n\\n  function casterAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function targetAttributes(address item, uint itemId) external view returns (int32[] memory values, uint8[] memory ids);\\n\\n  function itemAttackInfo(address item, uint itemId) external view returns (AttackInfo memory info);\\n\\n  function score(address item, uint tokenId) external view returns (uint);\\n\\n  function isAllowedToTransfer(address item, uint tokenId) external view returns (bool);\\n\\n  // ---\\n\\n  function mint(address item, address recipient) external returns (uint itemId);\\n\\n  function reduceDurability(address hero, uint heroId, uint8 biome) external;\\n\\n  function destroy(address item, uint tokenId) external;\\n\\n  function takeOffDirectly(\\n    address item,\\n    uint itemId,\\n    address hero,\\n    uint heroId,\\n    uint8 itemSlot,\\n    address destination,\\n    bool broken\\n  ) external;\\n}\\n\",\"keccak256\":\"0x36d2a1f44e3f2308ea27ca7579d40f374efd27e8eca1737253c7b1598313d3f7\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\ninterface IOracle {\\n\\n  function getRandomNumber(uint max, uint seed) external returns (uint);\\n\\n  function getRandomNumberInRange(uint min, uint max, uint seed) external returns (uint);\\n\\n}\\n\",\"keccak256\":\"0x75a2bed27cbd9be6c76b6f3e941ee5f6f55380f61cd867254a0c766fc3b71976\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStatController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStatController {\\n\\n  /// @custom:storage-location erc7201:stat.controller.main\\n  struct MainState {\\n    mapping(bytes32 => bytes32[]) heroTotalAttributes;\\n    /// @dev heroAdr+heroId => int32 packed strength, dexterity, vitality, energy\\n    mapping(bytes32 => bytes32) _heroCore;\\n    mapping(bytes32 => bytes32[]) heroBonusAttributes;\\n    mapping(bytes32 => bytes32[]) heroTemporallyAttributes;\\n    /// @dev heroAdr+heroId => uint32 packed level, experience, life, mana, lifeChances\\n    mapping(bytes32 => bytes32) heroStats;\\n    /// @dev heroAdr+heroId+itemSlot => itemAdr + itemId\\n    mapping(bytes32 => bytes32) heroSlots;\\n    /// @dev heroAdr+heroId => busy slots uint8[] packed\\n    mapping(bytes32 => bytes32) heroBusySlots;\\n    mapping(bytes32 => EnumerableSet.AddressSet) usedConsumables;\\n    mapping(bytes32 => mapping(bytes32 => uint)) heroCustomData;\\n    mapping(bytes32 => uint) globalCustomData;\\n  }\\n\\n\\n  enum ATTRIBUTES {\\n    // core\\n    STRENGTH, // 0\\n    DEXTERITY, // 1\\n    VITALITY, // 2\\n    ENERGY, // 3\\n    // attributes\\n    DAMAGE_MIN, // 4\\n    DAMAGE_MAX, // 5\\n    ATTACK_RATING, // 6\\n    DEFENSE, // 7\\n    BLOCK_RATING, // 8\\n    LIFE, // 9\\n    MANA, // 10\\n    // resistance\\n    FIRE_RESISTANCE, // 11\\n    COLD_RESISTANCE, // 12\\n    LIGHTNING_RESISTANCE, // 13\\n    // dmg against\\n    DMG_AGAINST_HUMAN, // 14\\n    DMG_AGAINST_UNDEAD, // 15\\n    DMG_AGAINST_DAEMON, // 16\\n    DMG_AGAINST_BEAST, // 17\\n\\n    // defence against\\n    DEF_AGAINST_HUMAN, // 18\\n    DEF_AGAINST_UNDEAD, // 19\\n    DEF_AGAINST_DAEMON, // 20\\n    DEF_AGAINST_BEAST, // 21\\n\\n    // --- unique, not augmentable\\n    // hero will not die until have positive chances\\n    LIFE_CHANCES, // 22\\n    // increase chance to get an item\\n    MAGIC_FIND, // 23\\n    // decrease chance to get an item\\n    DESTROY_ITEMS, // 24\\n    // percent of chance x2 dmg\\n    CRITICAL_HIT, // 25\\n    // dmg factors\\n    MELEE_DMG_FACTOR, // 26\\n    FIRE_DMG_FACTOR, // 27\\n    COLD_DMG_FACTOR, // 28\\n    LIGHTNING_DMG_FACTOR, // 29\\n    // increase attack rating on given percent\\n    AR_FACTOR, // 30\\n    // percent of damage will be converted to HP\\n    LIFE_STOLEN_PER_HIT, // 31\\n    // amount of mana restored after each battle\\n    MANA_AFTER_KILL, // 32\\n    // reduce all damage on percent after all other reductions\\n    DAMAGE_REDUCTION, // 33\\n\\n    // -- statuses\\n    // chance to stun an enemy, stunned enemy skip next hit\\n    STUN, // 34\\n    // chance burn an enemy, burned enemy will loss 50% of defence\\n    BURN, // 35\\n    // chance freeze an enemy, frozen enemy will loss 50% of MELEE damage\\n    FREEZE, // 36\\n    // chance to reduce enemy's attack rating on 50%\\n    CONFUSE, // 37\\n    // chance curse an enemy, cursed enemy will loss 50% of resistance\\n    CURSE, // 38\\n    // percent of dmg return to attacker\\n    REFLECT_DAMAGE_MELEE, // 39\\n    REFLECT_DAMAGE_MAGIC, // 40\\n    // chance to poison enemy, poisoned enemy will loss 10% of the current health\\n    POISON, // 41\\n    // reduce chance get any of uniq statuses\\n    RESIST_TO_STATUSES, // 42\\n\\n    END_SLOT // 46\\n  }\\n\\n  // possible\\n  // HEAL_FACTOR\\n\\n  struct CoreAttributes {\\n    int32 strength;\\n    int32 dexterity;\\n    int32 vitality;\\n    int32 energy;\\n  }\\n\\n  struct ChangeableStats {\\n    uint32 level;\\n    uint32 experience;\\n    uint32 life;\\n    uint32 mana;\\n    uint32 lifeChances;\\n  }\\n\\n  enum ItemSlots {\\n    UNKNOWN, // 0\\n    HEAD, // 1\\n    BODY, // 2\\n    GLOVES, // 3\\n    BELT, // 4\\n    AMULET, // 5\\n    BOOTS, // 6\\n    RIGHT_RING, // 7\\n    LEFT_RING, // 8\\n    RIGHT_HAND, // 9\\n    LEFT_HAND, // 10\\n    TWO_HAND, // 11\\n    SKILL_1, // 12\\n    SKILL_2, // 13\\n    SKILL_3, // 14\\n    END_SLOT // 15\\n  }\\n\\n  struct NftItem {\\n    address token;\\n    uint tokenId;\\n  }\\n\\n  enum Race {\\n    UNKNOWN, // 0\\n    HUMAN, // 1\\n    UNDEAD, // 2\\n    DAEMON, // 3\\n    BEAST, // 4\\n    END_SLOT // 5\\n  }\\n\\n  struct ChangeAttributesInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    int32[] changeAttributes;\\n    bool add;\\n    bool temporally;\\n  }\\n\\n  struct BuffInfo {\\n    address heroToken;\\n    uint heroTokenId;\\n    uint32 heroLevel;\\n    address[] buffTokens;\\n    uint[] buffTokenIds;\\n  }\\n\\n  /// @dev This struct is used inside event, so it's moved here from lib\\n  struct ActionInternalInfo {\\n    int32[] posAttributes;\\n    int32[] negAttributes;\\n\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n\\n    address[] mintedItems;\\n  }\\n\\n  function initNewHero(address token, uint tokenId, uint heroClass) external;\\n\\n  function heroAttributes(address token, uint tokenId) external view returns (int32[] memory);\\n\\n  function heroAttribute(address token, uint tokenId, uint index) external view returns (int32);\\n\\n  function heroAttributesLength(address token, uint tokenId) external view returns (uint);\\n\\n  function heroBaseAttributes(address token, uint tokenId) external view returns (CoreAttributes memory);\\n\\n  function heroCustomData(address token, uint tokenId, bytes32 index) external view returns (uint);\\n\\n  function globalCustomData(bytes32 index) external view returns (uint);\\n\\n  function heroStats(address token, uint tokenId) external view returns (ChangeableStats memory);\\n\\n  function heroItemSlot(address token, uint64 tokenId, uint8 itemSlot) external view returns (bytes32 nftPacked);\\n\\n  function heroItemSlots(address heroToken, uint heroTokenId) external view returns (uint8[] memory);\\n\\n  function isHeroAlive(address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function levelUp(address token, uint tokenId, uint heroClass, CoreAttributes memory change) external returns (uint newLvl);\\n\\n  function changeHeroItemSlot(\\n    address heroToken,\\n    uint64 heroTokenId,\\n    uint itemType,\\n    uint8 itemSlot,\\n    address itemToken,\\n    uint itemTokenId,\\n    bool equip\\n  ) external;\\n\\n  function changeCurrentStats(\\n    address token,\\n    uint tokenId,\\n    ChangeableStats memory change,\\n    bool increase\\n  ) external;\\n\\n  function changeBonusAttributes(ChangeAttributesInfo memory info) external;\\n\\n  function registerConsumableUsage(address heroToken, uint heroTokenId, address item) external;\\n\\n  function clearUsedConsumables(address heroToken, uint heroTokenId) external;\\n\\n  function clearTemporallyAttributes(address heroToken, uint heroTokenId) external;\\n\\n  function buffHero(BuffInfo memory info) external view returns (int32[] memory attributes, int32 manaConsumed);\\n\\n  function setHeroCustomData(address token, uint tokenId, bytes32 index, uint value) external;\\n\\n  function setGlobalCustomData(bytes32 index, uint value) external;\\n\\n}\\n\",\"keccak256\":\"0x92bcc6057f867ff0d418fd9ec397578444c5fd6244b979782c2ddd14b607a561\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStoryController.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"./IController.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./IHeroController.sol\\\";\\nimport \\\"../openzeppelin/EnumerableSet.sol\\\";\\n\\ninterface IStoryController {\\n\\n  enum AnswerResultId {\\n    UNKNOWN, // 0\\n    SUCCESS, // 1\\n    ATTRIBUTE_FAIL, // 2\\n    RANDOM_FAIL, // 3\\n    DELAY_FAIL, // 4\\n    HERO_CUSTOM_DATA_FAIL, // 5\\n    GLOBAL_CUSTOM_DATA_FAIL, // 6\\n\\n    END_SLOT\\n  }\\n\\n  enum CustomDataResult {\\n    UNKNOWN, // 0\\n    HERO_SUCCESS, // 1\\n    HERO_FAIL, // 2\\n    GLOBAL_SUCCESS, // 3\\n    GLOBAL_FAIL, // 4\\n\\n    END_SLOT\\n  }\\n\\n  /// @custom:storage-location erc7201:story.controller.main\\n  struct MainState {\\n\\n    // --- STORY REG INFO ---\\n\\n    /// @dev Uniq story identification.\\n    mapping(uint32 => uint16) storyIds;\\n    /// @dev Revers mapping for stories for using in the next object rewrite logic.\\n    mapping(uint16 => uint32) idToStory;\\n    /// @dev Store used ids for stories.\\n    mapping(uint16 => bool) _usedStoryIds;\\n    /// @dev Prevent register the story twice\\n    mapping(uint32 => bool) registeredStories;\\n\\n    // --- ANSWER MAPPING ---\\n\\n    /// @dev storyId => all story pages. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.UintSet) allStoryPages;\\n\\n    /// @dev storyId => all possible answers. We need to have this mapping for properly remove meta info\\n    mapping(uint16 => EnumerableSet.Bytes32Set) allStoryAnswers;\\n\\n    /// @dev storyId + pageId + heroClass (zero is default answers) => storyId + pageId + heroClass (zero is default answers) + answerId\\n    mapping(bytes32 => bytes32[]) answers;\\n    /// @dev answerUnPackedId + answerResultId => nextPageIds (will be chosen randomly from this array)\\n    ///      where answerResultId is:\\n    ///      0 - unknown,\\n    ///      1 - success,\\n    ///      2 - attr fail\\n    ///      3 - random fail\\n    ///      4 - delay fail\\n    ///      5 - hero custom data fail\\n    ///      6 - global custom data fail\\n    ///      see COUNT_ANSWER_RESULT_IDS\\n    mapping(bytes32 => uint16[]) nextPageIds;\\n    /// @dev story + pageId + heroClass (zero is default answers) => random nextObjs (adr + id, like packed nft id)\\n    mapping(bytes32 => uint32[]) nextObjectsRewrite;\\n\\n    /// @dev answerPackedId => packed array of uint32[]\\n    ///      0 - random requirement(uint32, 1 - 99% success of this action, zero means no check)\\n    ///      1 - delay requirement(uint32, if time since the last call more than this value the check is fail, zero means no check)\\n    ///      2 - isFinalAnswer(uint8)\\n    mapping(bytes32 => bytes32) answerAttributes;\\n\\n    // --- ANSWER REQUIREMENTS ---\\n\\n    /// @dev answerPackedId => array of AttributeRequirementsPacked\\n    mapping(bytes32 => bytes32[]) attributeRequirements;\\n    /// @dev answerPackedId=> array of ItemRequirementsPacked\\n    mapping(bytes32 => bytes32[]) itemRequirements;\\n    /// @dev answerPackedId => array of TokenRequirementsPacked\\n    mapping(bytes32 => bytes32[]) tokenRequirements;\\n    /// @dev answerPackedId => custom data for hero\\n    mapping(bytes32 => CustomDataRequirementPacked[]) heroCustomDataRequirement;\\n    /// @dev answerPackedId => global custom data\\n    mapping(bytes32 => CustomDataRequirementPacked[]) globalCustomDataRequirement;\\n\\n    // --- ANSWER RESULTS ---\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) successInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) successInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) successInfoMintItems;\\n\\n    /// @dev answerPackedId => change attributes\\n    mapping(bytes32 => bytes32[]) failInfoAttributes;\\n    /// @dev answerPackedId => change stats\\n    mapping(bytes32 => bytes32) failInfoStats;\\n    /// @dev answerPackedId => mint items\\n    mapping(bytes32 => bytes32[]) failInfoMintItems;\\n\\n    /// @dev answerUnPackedId + CustomDataResult => custom data array change\\n    ///      where CustomDataResult is\\n    ///      1 - hero success\\n    ///      2 - hero fail\\n    ///      3 - global success\\n    ///      4 - global fail\\n    ///      see COUNT_CUSTOM_DATA_RESULT_IDS\\n    mapping(bytes32 => bytes32[]) customDataResult;\\n    /// @dev answerPackedId => slot+chance+stopIfBurnt\\n    mapping(bytes32 => bytes32[]) burnItem;\\n\\n    // --- GENERAL STORY REQUIREMENTS ---\\n\\n    /// @dev story => Custom hero data requirements for a story. If exist and hero is not eligible should be not chose in a dungeon.\\n    mapping(uint => CustomDataRequirementRangePacked[]) storyRequiredHeroData;\\n    /// @dev story => Minimal level for the history. 0 means no requirements.\\n    mapping(uint => uint) storyRequiredLevel;\\n\\n    // --- HERO STATES ---\\n\\n    /// @dev hero + heroId + storyId => pageId + heroLastActionTS\\n    mapping(bytes32 => bytes32) heroState;\\n\\n    // --- OTHER ---\\n\\n    /// @dev storyId => build hash for the last update\\n    mapping(uint16 => uint) storyBuildHash;\\n  }\\n\\n  /// @dev We need to have flat structure coz Solidity can not handle arrays of structs properly\\n  struct StoryMetaInfo {\\n    uint16 storyId;\\n\\n    // --- story reqs\\n\\n    bytes32[] requiredCustomDataIndex;\\n    uint64[] requiredCustomDataMinValue;\\n    uint64[] requiredCustomDataMaxValue;\\n    bool[] requiredCustomDataIsHero;\\n    uint minLevel;\\n\\n    // --- answer reqs\\n\\n    AnswersMeta answersMeta;\\n    AnswerNextPageMeta answerNextPage;\\n    AnswerAttributeRequirementsMeta answerAttributeRequirements;\\n    AnswerItemRequirementsMeta answerItemRequirements;\\n    AnswerTokenRequirementsMeta answerTokenRequirements;\\n    AnswerAttributesMeta answerAttributes;\\n    AnswerCustomDataMeta answerHeroCustomDataRequirement;\\n    AnswerCustomDataMeta answerGlobalCustomDataRequirement;\\n\\n    // --- answer results\\n\\n    AnswerBurnRandomItemMeta answerBurnRandomItemMeta;\\n    NextObjRewriteMeta nextObjRewriteMeta;\\n\\n    // --- story results\\n\\n    AnswerResultMeta successInfo;\\n    AnswerResultMeta failInfo;\\n\\n    AnswerCustomDataResultMeta successHeroCustomData;\\n    AnswerCustomDataResultMeta failHeroCustomData;\\n    AnswerCustomDataResultMeta successGlobalCustomData;\\n    AnswerCustomDataResultMeta failGlobalCustomData;\\n  }\\n\\n  struct NextObjRewriteMeta {\\n    uint16[] nextObjPageIds;\\n    uint8[] nextObjHeroClasses;\\n    uint32[][] nextObjIds;\\n  }\\n\\n  struct AnswersMeta {\\n    uint16[] answerPageIds;\\n    uint8[] answerHeroClasses;\\n    uint16[] answerIds;\\n  }\\n\\n  struct AnswerNextPageMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint8[] answerResultIds;\\n    uint16[][] answerNextPageIds;\\n  }\\n\\n  struct AnswerAttributeRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    bool[][] cores;\\n    uint8[][] ids;\\n    int32[][] values;\\n  }\\n\\n  struct AnswerItemRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireItems;\\n    bool[][] requireItemBurn;\\n    bool[][] requireItemEquipped;\\n  }\\n\\n  struct AnswerTokenRequirementsMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    address[][] requireToken;\\n    uint88[][] requireAmount;\\n    bool[][] requireTransfer;\\n  }\\n\\n  struct AnswerAttributesMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n    uint32[] randomRequirements;\\n    uint32[] delayRequirements;\\n    bool[] isFinalAnswer;\\n  }\\n\\n  struct AnswerCustomDataMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    bool[][] mandatory;\\n    uint64[][] dataValuesMin;\\n    uint64[][] dataValuesMax;\\n  }\\n\\n  struct AnswerResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    uint8[][] attributeIds;\\n    /// @dev Max value is limitied by int24, see toBytes32ArrayWithIds impl\\n    int32[][] attributeValues;\\n\\n    uint32[] experience;\\n    int32[] heal;\\n    int32[] manaRegen;\\n    int32[] lifeChancesRecovered;\\n    int32[] damage;\\n    int32[] manaConsumed;\\n\\n    address[][] mintItems;\\n    uint32[][] mintItemsChances;\\n  }\\n\\n  struct AnswerCustomDataResultMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    bytes32[][] dataIndexes;\\n    int16[][] dataValues;\\n  }\\n\\n  struct AnswerBurnRandomItemMeta {\\n    uint16[] pageId;\\n    uint8[] heroClass;\\n    uint16[] answerId;\\n\\n    /// @notice 0 - random slot\\n    uint8[][] slots;\\n    /// @notice typical chances are [0..100] (no decimals here)\\n    uint64[][] chances;\\n    bool[][] isStopIfBurnt;\\n  }\\n\\n  struct CustomDataRequirementPacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + mandatory(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct CustomDataRequirementRangePacked {\\n    bytes32 index;\\n    /// @dev min(uint64) + max(uint64) + isHeroData(uint8)\\n    bytes32 data;\\n  }\\n\\n  struct StatsChange {\\n    uint32 experience;\\n    int32 heal;\\n    int32 manaRegen;\\n    int32 lifeChancesRecovered;\\n    int32 damage;\\n    int32 manaConsumed;\\n  }\\n\\n  struct StoryActionContext {\\n    uint stageId;\\n    uint iteration;\\n    bytes32 answerIdHash;\\n    bytes32 answerAttributes;\\n    address sender;\\n    address heroToken;\\n    IController controller;\\n    IStatController statController;\\n    IHeroController heroController;\\n    IOracle oracle;\\n    IItemController itemController;\\n    uint8 heroClass;\\n    uint8 heroClassFromAnswerHash;\\n    uint8 biome;\\n    uint16 storyId;\\n    uint16 storyIdFromAnswerHash;\\n    uint16 pageIdFromAnswerHash;\\n    uint16 answerNumber;\\n    uint16 pageId;\\n    uint32 objectId;\\n    uint64 dungeonId;\\n    uint40 heroLastActionTS;\\n    uint80 heroTokenId;\\n    IStatController.ChangeableStats heroStats;\\n  }\\n\\n  // --- WRITE ---\\n\\n  function storyAction(\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) external returns (IGOC.ActionResult memory);\\n\\n  // --- READ ---\\n\\n  function isStoryAvailableForHero(uint32 objectId, address heroToken, uint heroTokenId) external view returns (bool);\\n\\n  function idToStory(uint16 id) external view returns (uint32 objectId);\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) external view returns (uint16 pageId);\\n\\n  function storyIds(uint32 objectId) external view returns (uint16);\\n\\n  function registeredStories(uint32 objectId) external view returns (bool);\\n\\n}\\n\",\"keccak256\":\"0x6bc71b74f885c82d9949c582a49280738feed3af3704e7400d4acc1ba545f32e\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/ITreasury.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./IItemController.sol\\\";\\n\\ninterface ITreasury {\\n\\n  function balanceOfToken(address token) external view returns (uint);\\n\\n  function sendToDungeon(address dungeon, address token, uint amount) external;\\n\\n  function sendFee(address token, uint amount, IItemController.FeeType feeType) external;\\n\\n}\\n\",\"keccak256\":\"0x82d202ce82b2cd5e795d76acdb95248e1816771d4c22e9cee9148ac566566c9d\",\"license\":\"BUSL-1.1\"},\"contracts/lib/CalcLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\n\\nlibrary CalcLib {\\n\\n  uint32 public constant MAX_CHANCE = 1e9;\\n\\n  function minI32(int32 a, int32 b) internal pure returns (int32) {\\n    return a < b ? a : b;\\n  }\\n\\n  function max32(int32 a, int32 b) internal pure returns (int32) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function absDiff(int32 a, int32 b) internal pure returns (uint32) {\\n    if (!((a >= 0 && b >= 0) || (a <= 0 && b <= 0))) revert IAppErrors.AbsDiff(a, b);\\n    if (a < 0) {\\n      a = - a;\\n    }\\n    if (b < 0) {\\n      b = - b;\\n    }\\n    return uint32(uint(int(a >= b ? a - b : b - a)));\\n  }\\n\\n  function toUint(int32 n) internal pure returns (uint) {\\n    if (n < 0) {\\n      return 0;\\n    }\\n    if (n <= 0) {\\n      return 0;\\n    }\\n    return uint(int(n));\\n  }\\n\\n  function toInt32(uint a) internal pure returns (int32){\\n    if (a >= uint(int(type(int32).max))) {\\n      return type(int32).max;\\n    }\\n    return int32(int(a));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandom(uint maxValue) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft()))) % (maxValue + 1));\\n  }\\n\\n  function pseudoRandomUint32(uint32 maxValue) internal view returns (uint32) {\\n    return uint32(pseudoRandom(uint(maxValue)));\\n  }\\n\\n  /// @notice Generate pseudo-random uint in the range [0..maxValue) using Solady pseudo-random function\\n  function nextPrng(LibPRNG.PRNG memory prng, uint maxValue) internal pure returns (uint) {\\n    return LibPRNG.next(prng) % maxValue;\\n  }\\n\\n  /// @notice pseudoRandomUint32 with customizable pseudoRandom()\\n  function pseudoRandomUint32Flex(\\n    uint32 maxValue,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint32) {\\n    return uint32(random_(uint(maxValue)));\\n  }\\n\\n  function pseudoRandomInt32(int32 maxValue) internal view returns (int32) {\\n    bool neg;\\n    if (maxValue < 0) {\\n      neg = true;\\n      maxValue = - maxValue;\\n    }\\n    uint32 v = uint32(pseudoRandom(uint(int(maxValue))));\\n    return neg\\n      ? - int32(int(uint(v)))\\n      : int32(int(uint(v)));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality\\n  function pseudoRandomWithSeed(uint maxValue, uint seed) internal view returns (uint) {\\n    if (maxValue == 0) {\\n      return 0;\\n    }\\n    // pseudo random number\\n    return (uint(keccak256(abi.encodePacked(blockhash(block.number), block.coinbase, block.difficulty, block.number, block.timestamp, tx.gasprice, gasleft(), seed))) % (maxValue + 1));\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  function pseudoRandomInRange(uint min, uint max) internal view returns (uint) {\\n    if (min >= max) {\\n      return max;\\n    }\\n    uint r = pseudoRandom(max - min);\\n    return min + r;\\n  }\\n\\n  /// @dev Simplified pseudo-random for minor functionality, in range\\n  ///      Equal to pseudoRandomInRange(min, max, pseudoRandom)\\n  function pseudoRandomInRangeFlex(\\n    uint min,\\n    uint max,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint) {\\n    return min >= max ? max : min + random_(max - min);\\n  }\\n\\n  function minusWithZeroFloor(uint a, uint b) internal pure returns (uint){\\n    if (a <= b) {\\n      return 0;\\n    }\\n    return a - b;\\n  }\\n\\n  function minusWithMinFloorI32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) - int(b) < type(int32).min) {\\n      return type(int32).min;\\n    }\\n    return a - b;\\n  }\\n\\n  function plusWithMaxFloor32(int32 a, int32 b) internal pure returns (int32){\\n    if (int(a) + int(b) >= type(int32).max) {\\n      return type(int32).max;\\n    }\\n    return a + b;\\n  }\\n\\n  function sqrt(uint x) internal pure returns (uint z) {\\n    assembly {\\n    // Start off with z at 1.\\n      z := 1\\n\\n    // Used below to help find a nearby power of 2.\\n      let y := x\\n\\n    // Find the lowest power of 2 that is at least sqrt(x).\\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n        y := shr(128, y) // Like dividing by 2 ** 128.\\n        z := shl(64, z) // Like multiplying by 2 ** 64.\\n      }\\n      if iszero(lt(y, 0x10000000000000000)) {\\n        y := shr(64, y) // Like dividing by 2 ** 64.\\n        z := shl(32, z) // Like multiplying by 2 ** 32.\\n      }\\n      if iszero(lt(y, 0x100000000)) {\\n        y := shr(32, y) // Like dividing by 2 ** 32.\\n        z := shl(16, z) // Like multiplying by 2 ** 16.\\n      }\\n      if iszero(lt(y, 0x10000)) {\\n        y := shr(16, y) // Like dividing by 2 ** 16.\\n        z := shl(8, z) // Like multiplying by 2 ** 8.\\n      }\\n      if iszero(lt(y, 0x100)) {\\n        y := shr(8, y) // Like dividing by 2 ** 8.\\n        z := shl(4, z) // Like multiplying by 2 ** 4.\\n      }\\n      if iszero(lt(y, 0x10)) {\\n        y := shr(4, y) // Like dividing by 2 ** 4.\\n        z := shl(2, z) // Like multiplying by 2 ** 2.\\n      }\\n      if iszero(lt(y, 0x8)) {\\n      // Equivalent to 2 ** z.\\n        z := shl(1, z)\\n      }\\n\\n    // Shifting right by 1 is like dividing by 2.\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n\\n    // Compute a rounded down version of z.\\n      let zRoundDown := div(x, z)\\n\\n    // If zRoundDown is smaller, use it.\\n      if lt(zRoundDown, z) {\\n        z := zRoundDown\\n      }\\n    }\\n  }\\n\\n  /*********************************************\\n *              PRB-MATH                      *\\n *   https://github.com/hifi-finance/prb-math *\\n **********************************************/\\n  /// @notice Calculates the binary logarithm of x.\\n  ///\\n  /// @dev Based on the iterative approximation algorithm.\\n  /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n  ///\\n  /// Requirements:\\n  /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n  ///\\n  /// Caveats:\\n  /// - The results are nor perfectly accurate to the last decimal,\\n  ///   due to the lossy precision of the iterative approximation.\\n  ///\\n  /// @param x The unsigned 60.18-decimal fixed-point number for which\\n  ///           to calculate the binary logarithm.\\n  /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n  function log2(uint256 x) internal pure returns (uint256 result) {\\n    if (x < 1e18) revert IAppErrors.TooLowX(x);\\n\\n    // Calculate the integer part of the logarithm\\n    // and add it to the result and finally calculate y = x * 2^(-n).\\n    uint256 n = mostSignificantBit(x / 1e18);\\n\\n    // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number.\\n    // The operation can't overflow because n is maximum 255 and SCALE is 1e18.\\n    uint256 rValue = n * 1e18;\\n\\n    // This is y = x * 2^(-n).\\n    uint256 y = x >> n;\\n\\n    // If y = 1, the fractional part is zero.\\n    if (y == 1e18) {\\n      return rValue;\\n    }\\n\\n    // Calculate the fractional part via the iterative approximation.\\n    // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n    for (uint256 delta = 5e17; delta > 0; delta >>= 1) {\\n      y = (y * y) / 1e18;\\n\\n      // Is y^2 > 2 and so in the range [2,4)?\\n      if (y >= 2 * 1e18) {\\n        // Add the 2^(-m) factor to the logarithm.\\n        rValue += delta;\\n\\n        // Corresponds to z/2 on Wikipedia.\\n        y >>= 1;\\n      }\\n    }\\n    return rValue;\\n  }\\n\\n  /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n  /// @dev See the note on msb in the \\\"Find First Set\\\"\\n  ///      Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n  /// @param x The uint256 number for which to find the index of the most significant bit.\\n  /// @return msb The index of the most significant bit as an uint256.\\n  //noinspection NoReturn\\n  function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n    if (x >= 2 ** 128) {\\n      x >>= 128;\\n      msb += 128;\\n    }\\n    if (x >= 2 ** 64) {\\n      x >>= 64;\\n      msb += 64;\\n    }\\n    if (x >= 2 ** 32) {\\n      x >>= 32;\\n      msb += 32;\\n    }\\n    if (x >= 2 ** 16) {\\n      x >>= 16;\\n      msb += 16;\\n    }\\n    if (x >= 2 ** 8) {\\n      x >>= 8;\\n      msb += 8;\\n    }\\n    if (x >= 2 ** 4) {\\n      x >>= 4;\\n      msb += 4;\\n    }\\n    if (x >= 2 ** 2) {\\n      x >>= 2;\\n      msb += 2;\\n    }\\n    if (x >= 2 ** 1) {\\n      // No need to shift x any more.\\n      msb += 1;\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0xd5178ce117e26987cd3cb3496e13bd2c6e7d220557ec25f771444dd2f4d2db5b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/ItemLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./StatLib.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IItem.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../solady/LibPRNG.sol\\\";\\n\\nlibrary ItemLib {\\n  using CalcLib for int32;\\n  using PackingLib for address;\\n  using PackingLib for bytes32;\\n  using PackingLib for bytes32[];\\n  using PackingLib for uint32[];\\n  using PackingLib for int32[];\\n\\n  //region ------------------------ Data types\\n  struct GenerateAttributesContext {\\n    /// @notice True if max allowed amount of random attributes were reached inside {_prepareAttributes}\\n    bool stopGenerateRandom;\\n    /// @notice Flag - attribute was generated. The array matches to info.ids\\n    bool[] usedIndexes;\\n    /// @notice Ids of the generated attributes\\n    uint8[] ids;\\n    /// @notice Randomly selected values of the generated attributes\\n    int32[] values;\\n    /// @notice Counter of the stored values into {ids} and {values}\\n    uint counter;\\n    /// @notice Total number of random attributes that were generated inside {_prepareAttributes}\\n    uint randomAttrCounter;\\n    /// @notice Total sum of all {random} values for random attributes generated in {_prepareAttributes}\\n    uint randomSum;\\n    /// @notice Total sum of all chances of the random attributes generated in {_prepareAttributes}\\n    uint chancesSum;\\n    /// @notice Total number of random attributes that can be generated\\n    uint totalRandomAttrsPossible;\\n  }\\n\\n  struct MintItemInfo {\\n    uint8 biome;\\n    uint8 heroCurrentLvl;\\n    uint8 maxItems;\\n    IOracle oracle;\\n    address[] mintItems;\\n    int32 magicFind;\\n    int32 destroyItems;\\n    uint32[] mintItemsChances;\\n    uint32 heroExp;\\n    uint amplifier;\\n    uint seed;\\n  }\\n  //endregion ------------------------ Data types\\n\\n  //region ------------------------ Main logic\\n\\n  /// @notice Mint new item, setup attributes, make extra setup if necessary (setup attack item, buff item)\\n  /// @param sender Dungeon Factory only is allowed\\n  /// @param item Item to be minted\\n  /// @param recipient The item is minted for the given recipient\\n  /// @return itemId Id of the newly minted item\\n  function mintNewItem(\\n    IItemController.MainState storage s,\\n    IController controller,\\n    address sender,\\n    address item,\\n    address recipient\\n  ) external returns (uint itemId) {\\n    if (controller.dungeonFactory() != sender) revert IAppErrors.ErrorNotDungeonFactory(sender);\\n\\n    itemId = IItem(item).mintFor(recipient);\\n\\n    IItemController.MintInfo memory info;\\n\\n    (\\n      info.meta,\\n      info.attributesIds,\\n      info.attributesValues,\\n      info.itemRarity\\n    ) = _setupNewAttributes(s, item, itemId, CalcLib.pseudoRandom);\\n\\n    // setup extra info\\n\\n    if (info.meta.itemMetaType == uint8(IItemController.ItemMetaType.ATTACK)) {\\n      info.attackInfo = unpackItemAttackInfo(_setupNewAttackItem(s, item, itemId));\\n    } else if (info.meta.itemMetaType == uint8(IItemController.ItemMetaType.BUFF)) {\\n      (\\n        info.casterIds,\\n        info.casterValues,\\n        info.targetIds,\\n        info.targetValues\\n      ) = _setupNewBuffItem(s, item, itemId, CalcLib.pseudoRandom);\\n    }\\n    // consumable stats unchangeable, get them by address\\n\\n    emit IApplicationEvents.NewItemMinted(item, itemId, info);\\n  }\\n\\n  /// @notice Mint random items, not more than {info.maxItems}\\n  function mintRandomItems(MintItemInfo memory info) internal returns (address[] memory) {\\n    return _mintRandomItems(info, CalcLib.nextPrng);\\n  }\\n\\n  //endregion ------------------------ Main logic\\n\\n  //region ------------------------ Internal logic\\n  /// @param nextPrng_ CalcLib.nextPrng, param is required by unit tests\\n  function _mintRandomItems(\\n    MintItemInfo memory info,\\n    function (LibPRNG.PRNG memory, uint) internal view returns (uint) nextPrng_\\n  ) internal returns (address[] memory) {\\n    unchecked {\\n      uint len = info.mintItems.length;\\n\\n    // Fisher\\u2013Yates shuffle\\n      LibPRNG.PRNG memory prng = LibPRNG.PRNG(info.oracle.getRandomNumber(CalcLib.MAX_CHANCE, info.seed));\\n      uint[] memory indices = new uint[](len);\\n      for (uint i = 1; i < len; ++i) {\\n        indices[i] = i;\\n      }\\n      LibPRNG.shuffle(prng, indices);\\n\\n      address[] memory minted = new address[](len);\\n      uint mintedLength;\\n      uint delta = StatLib.mintDropChanceDelta(info.heroExp, info.heroCurrentLvl, info.biome);\\n      uint di = Math.min(uint(int(info.destroyItems)), 100);\\n\\n      for (uint i; i < len; ++i) {\\n        if (info.mintItemsChances[indices[i]] > CalcLib.MAX_CHANCE) {\\n          revert IAppErrors.TooHighChance(info.mintItemsChances[indices[i]]);\\n        }\\n        uint chance = StatLib.mintDropChance(info.mintItemsChances[indices[i]], info.amplifier, delta);\\n        chance += chance * uint(int(info.magicFind)) / 100;\\n        chance -= chance * di / 100;\\n\\n        // need to call random in each loop coz each minted item should have dedicated chance\\n        uint rnd = nextPrng_(prng, CalcLib.MAX_CHANCE); // randomWithSeed_(CalcLib.MAX_CHANCE, rndSeed);\\n\\n        if (chance != 0 && (chance >= CalcLib.MAX_CHANCE || rnd < chance)) {\\n          // There is no break here: the cycle is continued even if the number of the minted items reaches the max.\\n          // The reason: gas consumption of success operation must be great of equal of the gas consumption of fail op.\\n          if (mintedLength < info.maxItems) {\\n            minted[i] = info.mintItems[indices[i]];\\n            ++mintedLength;\\n          }\\n        }\\n      }\\n\\n      address[] memory mintedAdjusted = new address[](mintedLength);\\n      uint j;\\n      for (uint i; i < len; ++i) {\\n        if (minted[i] != address(0)) {\\n          mintedAdjusted[j] = minted[i];\\n          ++j;\\n        }\\n      }\\n\\n      return mintedAdjusted;\\n    }\\n  }\\n\\n  function _setupNewAttributes(\\n    IItemController.MainState storage s,\\n    address item,\\n    uint itemId,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (\\n    IItemController.ItemMeta memory meta,\\n    uint8[] memory ids,\\n    int32[] memory values,\\n    IItemController.ItemRarity itemRarity\\n  ){\\n    meta = unpackedItemMeta(s.itemMeta[item]);\\n    (ids, values, itemRarity) = _generateAttributes(unpackItemGenerateInfo(s.generateInfoAttributes[item]), meta, random_);\\n\\n    bytes32 packedItemId = item.packNftId(itemId);\\n    if (ids.length != 0) {\\n      s._itemAttributes[packedItemId] = values.toBytes32ArrayWithIds(ids);\\n    }\\n\\n    s.itemInfo[packedItemId] = PackingLib.packItemInfo(uint8(itemRarity), 0, meta.baseDurability);\\n  }\\n\\n  function _setupNewAttackItem(IItemController.MainState storage s, address item, uint itemId) internal returns (bytes32 attackInfo){\\n    // we just write data for attack item, no need to generate, it will be augmented later so need individual data for itemId\\n    attackInfo = s.generateInfoAttack[item];\\n    s._itemAttackInfo[item.packNftId(itemId)] = attackInfo;\\n  }\\n\\n  function _setupNewBuffItem(\\n    IItemController.MainState storage s,\\n    address item,\\n    uint itemId,\\n    function (uint) internal view returns (uint) random_\\n  ) internal returns (\\n    uint8[] memory casterIds,\\n    int32[] memory casterValues,\\n    uint8[] memory targetIds,\\n    int32[] memory targetValues\\n  ){\\n\\n    // CASTER\\n    (casterIds, casterValues) = _generateSimpleAttributes(\\n      unpackItemGenerateInfo(s.generateInfoCasterAttributes[item]),\\n      true,\\n      random_\\n    );\\n\\n    if (casterIds.length != 0) {\\n      s._itemCasterAttributes[item.packNftId(itemId)] = casterValues.toBytes32ArrayWithIds(casterIds);\\n    }\\n\\n    // TARGET\\n    (targetIds, targetValues) = _generateSimpleAttributes(\\n      unpackItemGenerateInfo(s.generateInfoTargetAttributes[item]),\\n      true,\\n      random_\\n    );\\n\\n    if (targetIds.length != 0) {\\n      s._itemTargetAttributes[item.packNftId(itemId)] = targetValues.toBytes32ArrayWithIds(targetIds);\\n    }\\n  }\\n\\n  /// @notice Generate all mandatory attributes and try to generate required number of random attributes.\\n  /// Generate at least {info.minRandomAttributes} of random attributes if it's possible\\n  /// but not more than {info.maxRandomAttributes}. Value of each attribute is generated randomly according its chances.\\n  /// @param meta Assume, that meta.min != 0, meta.max != 0 and both meta.min and meta.min should have same sign\\n  /// because results value cannot be 0\\n  /// @return ids Ids of the attributes, zero id is allowed\\n  /// @return values Randomly generated attributes values, min <= value <= max\\n  /// @return itemRarity Rarity of the item (Either meta.defaultRarity or calculated if there is no default rarity)\\n  function _generateAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    IItemController.ItemMeta memory meta,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    uint8[] memory ids,\\n    int32[] memory values,\\n    IItemController.ItemRarity itemRarity\\n  ) {\\n    GenerateAttributesContext memory ctx;\\n\\n    uint len = info.ids.length;\\n    if (len != 0) {\\n      ctx.ids = new uint8[](len);\\n      ctx.values = new int32[](len);\\n      ctx.usedIndexes = new bool[](len);\\n\\n      // Fisher\\u2013Yates shuffle\\n      _shuffleInfo(info, random_);\\n\\n      // initialize ctx by initial values\\n      // generate all mandatory attributes, try to generate not more than {meta.maxRandomAttributes} random attributes\\n      _prepareAttributes(info, meta.maxRandomAttributes, ctx, random_);\\n\\n      // generate missing random attributes if it's necessary, ctx.counter is incremented\\n      _generateMissingRandomAttributes(info, meta.minRandomAttributes, ctx, random_);\\n\\n      itemRarity = meta.defaultRarity == 0\\n        ? _calculateRarity(ctx.randomSum, ctx.chancesSum, ctx.randomAttrCounter, meta.maxRandomAttributes)\\n        : IItemController.ItemRarity(meta.defaultRarity);\\n    } else {\\n      itemRarity = IItemController.ItemRarity.UNKNOWN;\\n    }\\n\\n    (ids, values) = _fixLengthsIdsValues(ctx.ids, ctx.values, ctx.counter);\\n  }\\n\\n  /// @notice Generate missing random attributes if necessary\\n  function _generateMissingRandomAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    uint8 minRandomAttributes,\\n    GenerateAttributesContext memory ctx,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint attrToGen = Math.min(ctx.totalRandomAttrsPossible, minRandomAttributes);\\n    if (ctx.randomAttrCounter < attrToGen && ctx.totalRandomAttrsPossible > ctx.randomAttrCounter) {\\n      // it's necessary AND possible to generate more random attributes\\n      uint possibleRemainingAttrs = ctx.totalRandomAttrsPossible - ctx.randomAttrCounter;\\n      uint remainingAttrsToGen = attrToGen - ctx.randomAttrCounter;\\n\\n      uint[] memory indicesToGen = new uint[](possibleRemainingAttrs);\\n      uint indicesToGenCounter;\\n\\n      // enumerate all attributes, add all indices of not-generated attributes to {indexesToGen}\\n      for (uint i; i < info.ids.length; ++i) {\\n        // mandatory attrs should be already generated and no need to check\\n        if (!ctx.usedIndexes[i]) {\\n          indicesToGen[indicesToGenCounter] = i;\\n          indicesToGenCounter++;\\n        }\\n      }\\n\\n      // Shuffle indices of not-generated attributes using Fisher\\u2013Yates shuffle\\n      if (possibleRemainingAttrs > 1) {\\n        for (uint i; i < possibleRemainingAttrs - 1; ++i) {\\n          uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, possibleRemainingAttrs - 1, random_);\\n          (indicesToGen[randomIndex], indicesToGen[i]) = (indicesToGen[i], indicesToGen[randomIndex]);\\n        }\\n      }\\n      // Generate necessary amount of attributes. Fist (shuffled) attributes are selected (MAX_CHANCE is used for each)\\n      for (uint i; i < remainingAttrsToGen; ++i) {\\n        uint idx = indicesToGen[i];\\n        (int32 attr,) = _generateAttribute(info.mins[idx], info.maxs[idx], CalcLib.MAX_CHANCE, random_);\\n        ctx.ids[ctx.counter] = info.ids[idx];\\n        ctx.values[ctx.counter] = attr;\\n        ctx.counter++;\\n      }\\n    }\\n  }\\n\\n  /// @notice Generate all mandatory attributes, generate not more than {meta.maxRandomAttributes} random attributes.\\n  /// Updates context:\\n  ///   {ctx.totalRandomAttrsPossible} - total number of possible random attributes\\n  ///   {ctx.randomAttrCounter} - total number of generated random attributes  <= {maxRandomAttributes}\\n  ///   {ctx.randomSum} = sum of random of all random attributes.\\n  ///   {ctx.chancesSum} = sum of chances of all random attributes.\\n  ///   {ctx.counter} = total number of generated attributes. Values of ctx.ids, ctx.values, ctx.usedIndexes are\\n  ///   initialized in the range [0...ctx.counter)\\n  /// @param ctx Empty struct but arrays ids, values and usedIndexes should be allocated for info.ids.length items\\n  function _prepareAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    uint8 maxRandomAttributes,\\n    GenerateAttributesContext memory ctx,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint len = info.ids.length;\\n    for (uint i; i < len; ++i) {\\n      if (info.chances[i] != CalcLib.MAX_CHANCE) {\\n        ctx.totalRandomAttrsPossible++;\\n      }\\n\\n      if (info.chances[i] >= CalcLib.MAX_CHANCE || !ctx.stopGenerateRandom) {\\n        (int32 attr, uint random) = _generateAttribute(info.mins[i], info.maxs[i], info.chances[i], random_);\\n//          console.log(\\\"GEN id: %s, value: %s%s\\\", _info.ids[i], attr >= 0 ? '' : '-', attr >= 0 ? uint(int(attr)) : uint(int(- attr)));\\n\\n        // count only random attributes for calc rarity\\n        if (attr != 0) {\\n\\n          if (\\n            info.chances[i] < CalcLib.MAX_CHANCE\\n            // && random != 0 // commented: random = 0 can produce crash in _generateMissingRandomAttributes\\n          ) {\\n            ctx.randomAttrCounter++;\\n            ctx.randomSum += random;\\n            ctx.chancesSum += info.chances[i];\\n          }\\n          ctx.ids[ctx.counter] = info.ids[i];\\n          ctx.values[ctx.counter] = attr;\\n          ctx.counter++;\\n          ctx.usedIndexes[i] = true;\\n        }\\n\\n        // it is a bit less fair random for attrs in the end of the list, however we assume it should be pretty rare case\\n        if (ctx.randomAttrCounter == maxRandomAttributes) {\\n          ctx.stopGenerateRandom = true;\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Shuffle info arrays using Fisher\\u2013Yates shuffle algo\\n  function _shuffleInfo(\\n    IItemController.ItemGenerateInfo memory info,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view {\\n    uint len = info.ids.length;\\n    if (len > 1) {\\n      for (uint i; i < len - 1; i++) {\\n        uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, len - 1, random_);\\n\\n        (info.ids[randomIndex], info.ids[i]) = (info.ids[i], info.ids[randomIndex]);\\n        (info.mins[randomIndex], info.mins[i]) = (info.mins[i], info.mins[randomIndex]);\\n        (info.maxs[randomIndex], info.maxs[i]) = (info.maxs[i], info.maxs[randomIndex]);\\n        (info.chances[randomIndex], info.chances[i]) = (info.chances[i], info.chances[randomIndex]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Generate array [0,1,2.. N-1] and shuffle it using Fisher\\u2013Yates shuffle algo\\n  function _shuffleIndices(\\n    uint countItems,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (uint[] memory indices){\\n    indices = new uint[](countItems);\\n    for (uint i = 1; i < countItems; ++i) {\\n      indices[i] = i;\\n    }\\n    if (countItems > 1) {\\n      for (uint i; i < countItems - 1; i++) {\\n        uint randomIndex = CalcLib.pseudoRandomInRangeFlex(i, countItems - 1, random_);\\n        (indices[randomIndex], indices[i]) = (indices[i], indices[randomIndex]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Reduce lengths of {ids} and {values} to {count}\\n  function _fixLengthsIdsValues(uint8[] memory ids, int32[] memory values, uint count) internal pure returns (\\n    uint8[] memory idsOut,\\n    int32[] memory valuesOut\\n  ) {\\n    if (count == ids.length) {\\n      return (ids, values);\\n    }\\n\\n    idsOut = new uint8[](count);\\n    valuesOut = new int32[](count);\\n    for (uint i; i < count; ++i) {\\n      idsOut[i] = ids[i];\\n      valuesOut[i] = values[i];\\n    }\\n    return (idsOut, valuesOut);\\n  }\\n\\n  /// @param random_ Pass CalcLib.pseudoRandom here, param is required for unit tests. Max value is MAX_CHANCE\\n  function _generateSimpleAttributes(\\n    IItemController.ItemGenerateInfo memory info,\\n    bool maxChance,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    uint8[] memory ids,\\n    int32[] memory values\\n  ) {\\n    uint len = info.ids.length;\\n    ids = new uint8[](len);\\n    values = new int32[](len);\\n\\n    uint n = 0;\\n    for (uint i; i < len; ++i) {\\n      (int32 attr,) = _generateAttribute(\\n        info.mins[i],\\n        info.maxs[i],\\n        maxChance ? CalcLib.MAX_CHANCE : info.chances[i],\\n        random_\\n      );\\n      if (attr != 0) {\\n        ids[n] = info.ids[i];\\n        values[n] = attr;\\n        ++n;\\n      }\\n    }\\n\\n    return _fixLengthsIdsValues(ids, values, n);\\n  }\\n\\n  //endregion ------------------------ Internal logic\\n\\n  //region ------------------------ Internal utils\\n  /// @param chance Chance in the range [0...MAX_CHANCE], MAX_CHANCE=1e9 means \\\"mandatory\\\" element.\\n  /// @param random_ Pass CalcLib.pseudoRandom here, param is required for unit tests\\n  /// @return attr Either 0 or min <= attr <= max\\n  /// @return rnd Random value in the range [0...MAX_CHANCE]; It's always 0 for mandatory elements\\n  function _generateAttribute(\\n    int32 min,\\n    int32 max,\\n    uint32 chance,\\n    function (uint) internal view returns (uint) random_\\n  ) internal view returns (\\n    int32 attr,\\n    uint rnd\\n  ) {\\n    if (chance > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighChance(chance);\\n\\n    uint diff = uint(CalcLib.absDiff(min, max));\\n\\n    if (chance < CalcLib.MAX_CHANCE) {\\n      uint32 random = CalcLib.pseudoRandomUint32Flex(CalcLib.MAX_CHANCE, random_);\\n      if (random < chance) {\\n        uint r = uint(CalcLib.MAX_CHANCE - random * (CalcLib.MAX_CHANCE / chance));\\n        int32 k = int32(int(r * diff / uint(CalcLib.MAX_CHANCE)));\\n        return (min + k, random);\\n      }\\n    } else { // chance == CalcLib.MAX_CHANCE => mandatory element\\n      if (diff == 0) {\\n        return (min, 0);\\n      } else {\\n        uint r = uint(CalcLib.pseudoRandomUint32Flex(CalcLib.MAX_CHANCE, random_));\\n        int32 k = int32(int(r % (diff + 1)));\\n\\n        // return zero random - no need to calc rarity for mandatory elements\\n        return (min + k, 0);\\n      }\\n    }\\n\\n    return (0, 0);\\n  }\\n\\n  /// @notice Calculate item rarity\\n  /// @param randomSum Total sum random values of all random attributes in ItemGenerateInfo, [0...MAX_CHANCE/attrCounter]\\n  /// @param chancesSum Total sum of all random chances in ItemGenerateInfo\\n  /// @param attrCounter Count of random attributes in ItemGenerateInfo\\n  /// @param maxAttr Index of max allowed random attribute (all attributes with higher indices are not random)\\n  /// @return item rarity\\n  function _calculateRarity(uint randomSum, uint chancesSum, uint attrCounter, uint maxAttr) internal pure returns (\\n    IItemController.ItemRarity\\n  ) {\\n    if (attrCounter == 0) {\\n      return IItemController.ItemRarity.NORMAL;\\n    }\\n\\n    uint random = randomSum / attrCounter;\\n    uint averageChance = chancesSum / attrCounter;\\n\\n    if (random > CalcLib.MAX_CHANCE) revert IAppErrors.TooHighRandom(random);\\n\\n    if (random < averageChance / 4 && attrCounter == maxAttr) {\\n      return IItemController.ItemRarity.RARE;\\n    } else if (random < averageChance * 3 / 4) {\\n      return attrCounter > 2\\n        ? IItemController.ItemRarity.RARE\\n        : IItemController.ItemRarity.MAGIC;\\n    } else {\\n      return attrCounter > 1\\n        ? IItemController.ItemRarity.MAGIC\\n        : IItemController.ItemRarity.NORMAL;\\n    }\\n  }\\n  //endregion ------------------------ Internal utils\\n\\n  //region ------------------------ PACKING\\n\\n  function packItemGenerateInfo(IItemController.ItemGenerateInfo memory info) internal pure returns (bytes32[] memory result) {\\n    uint len = info.ids.length;\\n    if (len != info.mins.length || len != info.maxs.length || len != info.chances.length) {\\n      revert IAppErrors.LengthsMismatch();\\n    }\\n\\n    result = new bytes32[](len);\\n\\n    for (uint i; i < len; ++i) {\\n      result[i] = PackingLib.packItemGenerateInfo(info.ids[i], info.mins[i], info.maxs[i], info.chances[i]);\\n    }\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32[] memory gen) internal pure returns (\\n    IItemController.ItemGenerateInfo memory\\n  ) {\\n    uint length = gen.length;\\n\\n    uint8[] memory ids = new uint8[](length);\\n    int32[] memory mins = new int32[](length);\\n    int32[] memory maxs = new int32[](length);\\n    uint32[] memory chances = new uint32[](length);\\n\\n    for (uint i; i < length; ++i) {\\n      (ids[i], mins[i], maxs[i], chances[i]) = gen[i].unpackItemGenerateInfo();\\n    }\\n\\n    return IItemController.ItemGenerateInfo(ids, mins, maxs, chances);\\n  }\\n\\n  function packItemMeta(IItemController.ItemMeta memory meta) internal pure returns (bytes32) {\\n    return PackingLib.packItemMeta(\\n      meta.itemMetaType,\\n      meta.itemLevel,\\n      uint8(meta.itemType),\\n      meta.baseDurability,\\n      meta.defaultRarity,\\n      meta.minRandomAttributes,\\n      meta.maxRandomAttributes,\\n      meta.manaCost,\\n      meta.requirements\\n    );\\n  }\\n\\n  function unpackedItemMeta(bytes32 meta) internal pure returns (IItemController.ItemMeta memory result) {\\n    return meta.unpackItemMeta();\\n  }\\n\\n  function packItemInfo(IItemController.ItemInfo memory info) internal pure returns (bytes32) {\\n    return PackingLib.packItemInfo(uint8(info.rarity), info.augmentationLevel, info.durability);\\n  }\\n\\n  function unpackedItemInfo(bytes32 info) internal pure returns (IItemController.ItemInfo memory result) {\\n    uint8 rarity;\\n    (rarity, result.augmentationLevel, result.durability) = info.unpackItemInfo();\\n\\n    result.rarity = IItemController.ItemRarity(rarity);\\n    return result;\\n  }\\n\\n  function packItemAttackInfo(IItemController.AttackInfo memory info) internal pure returns (bytes32) {\\n    return PackingLib.packItemAttackInfo(\\n      uint8(info.aType),\\n      info.min,\\n      info.max,\\n      info.attributeFactors.strength,\\n      info.attributeFactors.dexterity,\\n      info.attributeFactors.vitality,\\n      info.attributeFactors.energy\\n    );\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 info) internal pure returns (IItemController.AttackInfo memory result) {\\n    IStatController.CoreAttributes memory fs;\\n    uint8 aType;\\n    (aType, result.min, result.max, fs.strength, fs.dexterity, fs.vitality, fs.energy) = info.unpackItemAttackInfo();\\n\\n    result.aType = IItemController.AttackType(aType);\\n    result.attributeFactors = fs;\\n\\n    return result;\\n  }\\n  //endregion ------------------------ PACKING\\n}\\n\",\"keccak256\":\"0x35be525f87553c0d2c6066c366baa6cb25ec073cdb9dab01efdd0db3b98449b1\",\"license\":\"BUSL-1.1\"},\"contracts/lib/PackingLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IItemController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\n\\nlibrary PackingLib {\\n\\n  error TooHighValue(uint value);\\n  error OutOfBounds(uint index, uint length);\\n  error UnexpectedValue(uint expected, uint actual);\\n  error WrongValue(uint newValue, uint actual);\\n  error LengthsMismatch();\\n  error IntOutOfRange(int value);\\n  error ZeroValue();\\n  /// @notice packCustomDataChange requires an input string with two zero bytes at the beginning\\n  ///         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// This error happens if these bytes are not zero\\n  error IncompatibleInputString();\\n\\n  //////////////////////////\\n  // ---- PACKING LOGIC ----\\n  //////////////////////////\\n\\n  //region ------------------------------------ COMMON\\n\\n  function packNftId(address token, uint id) internal pure returns (bytes32 serialized) {\\n    if (id > uint(type(uint64).max)) revert TooHighValue(id);\\n    serialized = bytes32(uint(uint160(token)));\\n    serialized |= bytes32(uint(uint64(id))) << 160;\\n  }\\n\\n  function unpackNftId(bytes32 data) internal pure returns (address token, uint id) {\\n    token = address(uint160(uint(data)));\\n    id = uint(data) >> 160;\\n  }\\n\\n  function packAddressWithAmount(address token, uint amount) internal pure returns (bytes32 data) {\\n    if (amount > uint(type(uint96).max)) revert TooHighValue(amount);\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(uint96(amount))) << 160;\\n  }\\n\\n  function unpackAddressWithAmount(bytes32 data) internal pure returns (address token, uint amount) {\\n    token = address(uint160(uint(data)));\\n    amount = uint(data) >> 160;\\n  }\\n\\n  function packItemMintInfo(address item, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(chance)) << 160;\\n  }\\n\\n  function unpackItemMintInfo(bytes32 data) internal pure returns (address item, uint32 chance) {\\n    item = address(uint160(uint(data)));\\n    chance = uint32(uint(data) >> 160);\\n  }\\n\\n  /// @param customDataIndex We assume, that two lowest bytes of this string are always zero\\n  /// So, the string looks like following: 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0000\\n  /// Last 2 bytes will be used to encode {value}\\n  function packCustomDataChange(bytes32 customDataIndex, int16 value) internal pure returns (bytes32 data) {\\n    if (uint(customDataIndex) != (uint(customDataIndex) >> 16) << 16) revert IncompatibleInputString();\\n    data = bytes32(uint(customDataIndex));\\n    data |= bytes32(uint(uint16(value)));\\n  }\\n\\n  function unpackCustomDataChange(bytes32 data) internal pure returns (bytes32 customDataIndex, int16 value) {\\n    customDataIndex = bytes32((uint(data) >> 16) << 16);\\n    value = int16(int(uint(uint16(uint(data)))));\\n  }\\n\\n  /// @dev min(uint64) + max(uint64) + isHeroData/isMandatory(uint8)\\n  function packCustomDataRequirements(uint64 min, uint64 max, bool key) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(min));\\n    data |= bytes32(uint(max)) << 64;\\n    data |= bytes32(uint(key ? uint8(1) : uint8(0))) << (64 + 64);\\n  }\\n\\n  function unpackCustomDataRequirements(bytes32 data) internal pure returns (uint64 min, uint64 max, bool key) {\\n    min = uint64(uint(data));\\n    max = uint64(uint(data) >> 64);\\n    key = uint8(uint(data) >> (64 + 64)) == uint8(1);\\n  }\\n\\n  function packStatsChange(\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(experience));\\n    data |= bytes32(uint(uint32(heal))) << 32;\\n    data |= bytes32(uint(uint32(manaRegen))) << (32 + 32);\\n    data |= bytes32(uint(uint32(lifeChancesRecovered))) << (32 + 32 + 32);\\n    data |= bytes32(uint(uint32(damage))) << (32 + 32 + 32 + 32);\\n    data |= bytes32(uint(uint32(manaConsumed))) << (32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackStatsChange(bytes32 data) internal pure returns (\\n    uint32 experience,\\n    int32 heal,\\n    int32 manaRegen,\\n    int32 lifeChancesRecovered,\\n    int32 damage,\\n    int32 manaConsumed\\n  ) {\\n    experience = uint32(uint(data));\\n    heal = int32(int(uint(data) >> 32));\\n    manaRegen = int32(int(uint(data) >> (32 + 32)));\\n    lifeChancesRecovered = int32(int(uint(data) >> (32 + 32 + 32)));\\n    damage = int32(int(uint(data) >> (32 + 32 + 32 + 32)));\\n    manaConsumed = int32(int(uint(data) >> (32 + 32 + 32 + 32 + 32)));\\n  }\\n  //endregion ------------------------------------ COMMON\\n\\n  //region ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  function packMapObject(address objectAddress, uint64 objectId, uint8 objectType) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(bytes20(objectAddress));\\n    packedData |= bytes32(uint(objectId) << 32);\\n    packedData |= bytes32(uint(objectType) << 24);\\n  }\\n\\n  function unpackMapObject(bytes32 packedData) internal pure returns (address objectAddress, uint64 objectId, uint8 objectType) {\\n    objectAddress = address(bytes20(packedData));\\n    objectId = uint64(uint(packedData) >> 32);\\n    objectType = uint8(uint(packedData) >> 24);\\n  }\\n\\n  function packCoordinate(uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(x));\\n    packedData |= bytes32(uint(y) << 128);\\n  }\\n\\n  function unpackCoordinate(bytes32 packedData) internal pure returns (uint128 x, uint128 y) {\\n    x = uint128(uint(packedData));\\n    y = uint128(uint(packedData) >> 128);\\n  }\\n\\n  /// @param x Assume x <= max uint64\\n  /// @param y Assume y <= max uint64\\n  function packBattlefieldId(uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) internal pure returns (bytes32 packedData) {\\n    // 256 => 128 + 128;\\n    // 1) 128 is used for biomeMapFieldId, territoryNumber and probably other fields in the future\\n    // 2) 128 is used to store x, y as uint64, uint64\\n\\n    // we will use uint64 for coordinates assuming it is more than enough for biome map\\n    packedData = bytes32(uint(biomeMapFieldId));\\n    packedData |= bytes32(uint(territoryNumber) << (8));\\n    packedData |= bytes32(uint(uint64(x)) << 128);\\n    packedData |= bytes32(uint(uint64(y)) << (64 + 128));\\n  }\\n\\n  function unpackBattlefieldId(bytes32 packedData) internal pure returns (uint8 biomeMapFieldId, uint8 territoryNumber, uint128 x, uint128 y) {\\n    biomeMapFieldId = uint8(uint(packedData));\\n    territoryNumber = uint8(uint(packedData) >> (8));\\n    x = uint128(uint64(uint(packedData) >> (128)));\\n    y = uint128(uint64(uint(packedData) >> (64 + 128)));\\n  }\\n  //endregion ------------------------------------ WORLD/BATTLEFIELD MAP\\n\\n  //region ------------------------------------ REINFORCEMENT\\n\\n  function packReinforcementHeroInfo(uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) internal pure returns (bytes32 packedData) {\\n    packedData = bytes32(uint(biome));\\n    packedData |= bytes32(uint(score) << 8);\\n    packedData |= bytes32(uint(fee) << (8 + 128));\\n    packedData |= bytes32(uint(stakeTs) << (8 + 128 + 8));\\n  }\\n\\n  function unpackReinforcementHeroInfo(bytes32 packedData) internal pure returns (uint8 biome, uint128 score, uint8 fee, uint64 stakeTs) {\\n    biome = uint8(uint(packedData));\\n    score = uint128(uint(packedData) >> 8);\\n    fee = uint8(uint(packedData) >> (8 + 128));\\n    stakeTs = uint64(uint(packedData) >> (8 + 128 + 8));\\n  }\\n  //endregion ------------------------------------ REINFORCEMENT\\n\\n  //region ------------------------------------ DUNGEON\\n\\n  function packDungeonKey(address heroAdr, uint80 heroId, uint16 dungLogicNum) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(dungLogicNum)) << (160 + 80);\\n  }\\n\\n  function unpackDungeonKey(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 dungLogicNum) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    dungLogicNum = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  // --- GAME OBJECTS ---\\n\\n  function packIterationKey(address heroAdr, uint64 heroId, uint32 objId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(objId)) << (160 + 64);\\n  }\\n\\n  function unpackIterationKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint32 objId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    objId = uint32(uint(data) >> (160 + 64));\\n  }\\n\\n  function packMonsterStats(\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(level));\\n    data |= bytes32(uint(race)) << 8;\\n    data |= bytes32(uint(experience)) << (8 + 8);\\n    data |= bytes32(uint(maxDropItems)) << (8 + 8 + 32);\\n  }\\n\\n  function unpackMonsterStats(bytes32 data) internal pure returns (\\n    uint8 level,\\n    uint8 race,\\n    uint32 experience,\\n    uint8 maxDropItems\\n  ) {\\n    level = uint8(uint(data));\\n    race = uint8(uint(data) >> 8);\\n    experience = uint32(uint(data) >> (8 + 8));\\n    maxDropItems = uint8(uint(data) >> (8 + 8 + 32));\\n  }\\n\\n  function packAttackInfo(\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(attackToken)));\\n    data |= bytes32(uint(attackTokenId)) << 160;\\n    data |= bytes32(uint(attackType)) << (160 + 64);\\n  }\\n\\n  function unpackAttackInfo(bytes32 data) internal pure returns (\\n    address attackToken,\\n    uint64 attackTokenId,\\n    uint8 attackType\\n  ) {\\n    attackToken = address(uint160(uint(data)));\\n    attackTokenId = uint64(uint(data) >> 160);\\n    attackType = uint8(uint(data) >> (160 + 64));\\n  }\\n\\n  function packPlayedObjKey(address heroAdr, uint64 heroId, uint8 oType, uint8 biome) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(oType)) << (160 + 64);\\n    data |= bytes32(uint(biome)) << (160 + 64 + 8);\\n  }\\n\\n  function unpackPlayedObjKey(bytes32 data) internal pure returns (address heroAdr, uint64 heroId, uint8 oType, uint8 biome) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint64(uint(data) >> 160);\\n    oType = uint8(uint(data) >> (160 + 64));\\n    biome = uint8(uint(data) >> (160 + 64 + 8));\\n  }\\n\\n  function packGeneratedMonster(bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint8(generated ? 1 : 0)));\\n    data |= bytes32(uint(amplifier)) << 8;\\n    data |= bytes32(uint(uint32(hp))) << (8 + 32);\\n    data |= bytes32(uint(turnCounter)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackGeneratedMonster(bytes32 data) internal pure returns (bool generated, uint32 amplifier, int32 hp, uint8 turnCounter) {\\n    generated = uint8(uint(data)) == uint8(1);\\n    amplifier = uint32(uint(data) >> 8);\\n    hp = int32(int(uint(data) >> (8 + 32)));\\n    turnCounter = uint8(uint(data) >> (8 + 32 + 32));\\n  }\\n  //endregion ------------------------------------ DUNGEON\\n\\n  //region ------------------------------------ ITEMS\\n\\n  /// @notice itemMetaType8 + itemLvl8 + itemType8 + baseDurability16 + defaultRarity8 + minAttr8 + maxAttr8 + manaCost32 + req(packed core 128)\\n  /// @param itemType This is ItemType enum\\n  function packItemMeta(\\n    uint8 itemMetaType,\\n    uint8 itemLvl,\\n    uint8 itemType,\\n    uint16 baseDurability,\\n    uint8 defaultRarity,\\n    uint8 minAttr,\\n    uint8 maxAttr,\\n    uint32 manaCost,\\n    IStatController.CoreAttributes memory req\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(itemMetaType));\\n    data |= bytes32(uint(itemLvl)) << 8;\\n    data |= bytes32(uint(itemType)) << (8 + 8);\\n    data |= bytes32(uint(baseDurability)) << (8 + 8 + 8);\\n    data |= bytes32(uint(defaultRarity)) << (8 + 8 + 8 + 16);\\n    data |= bytes32(uint(minAttr)) << (8 + 8 + 8 + 16 + 8);\\n    data |= bytes32(uint(maxAttr)) << (8 + 8 + 8 + 16 + 8 + 8);\\n    data |= bytes32(uint(manaCost)) << (8 + 8 + 8 + 16 + 8 + 8 + 8);\\n    data |= bytes32(uint(int(req.strength))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32);\\n    data |= bytes32(uint(int(req.dexterity))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32);\\n    data |= bytes32(uint(int(req.vitality))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(req.energy))) << (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemMeta(bytes32 data) internal pure returns (IItemController.ItemMeta memory) {\\n    IItemController.ItemMeta memory result;\\n\\n    result.itemMetaType = uint8(uint(data));\\n    result.itemLevel = uint8(uint(data) >> 8);\\n    result.itemType = IItemController.ItemType(uint8(uint(data) >> (8 + 8)));\\n    result.baseDurability = uint16(uint(data) >> (8 + 8 + 8));\\n    result.defaultRarity = uint8(uint(data) >> (8 + 8 + 8 + 16));\\n    result.minRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8));\\n    result.maxRandomAttributes = uint8(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8));\\n    result.manaCost = uint32(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8));\\n    result.requirements.strength = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32)));\\n    result.requirements.dexterity = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32)));\\n    result.requirements.vitality = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32)));\\n    result.requirements.energy = int32(int(uint(data) >> (8 + 8 + 8 + 16 + 8 + 8 + 8 + 32 + 32 + 32 + 32)));\\n\\n    return result;\\n  }\\n\\n  function packItemGenerateInfo(uint8 id, int32 min, int32 max, uint32 chance) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(id));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(chance)) << (8 + 32 + 32);\\n  }\\n\\n  function unpackItemGenerateInfo(bytes32 data) internal pure returns (uint8 id, int32 min, int32 max, uint32 chance) {\\n    id = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    chance = uint32(uint(data) >> (8 + 32 + 32));\\n  }\\n\\n  function packItemAttackInfo(\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attackType));\\n    data |= bytes32(uint(uint32(min))) << 8;\\n    data |= bytes32(uint(uint32(max))) << (8 + 32);\\n    data |= bytes32(uint(int(factorStr))) << (8 + 32 + 32);\\n    data |= bytes32(uint(int(factorDex))) << (8 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorVit))) << (8 + 32 + 32 + 32 + 32);\\n    data |= bytes32(uint(int(factorEng))) << (8 + 32 + 32 + 32 + 32 + 32);\\n  }\\n\\n  function unpackItemAttackInfo(bytes32 data) internal pure returns (\\n    uint8 attackType,\\n    int32 min,\\n    int32 max,\\n    int32 factorStr,\\n    int32 factorDex,\\n    int32 factorVit,\\n    int32 factorEng\\n  ) {\\n    attackType = uint8(uint(data));\\n    min = int32(int(uint(data) >> 8));\\n    max = int32(int(uint(data) >> (8 + 32)));\\n    factorStr = int32(int(uint(data) >> (8 + 32 + 32)));\\n    factorDex = int32(int(uint(data) >> (8 + 32 + 32 + 32)));\\n    factorVit = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32)));\\n    factorEng = int32(int(uint(data) >> (8 + 32 + 32 + 32 + 32 + 32)));\\n  }\\n\\n  function packItemInfo(uint8 rarity, uint8 augmentationLevel, uint16 durability) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(rarity));\\n    data |= bytes32(uint(augmentationLevel)) << 8;\\n    data |= bytes32(uint(durability)) << (8 + 8);\\n  }\\n\\n  function unpackItemInfo(bytes32 data) internal pure returns (uint8 rarity, uint8 augmentationLevel, uint16 durability) {\\n    rarity = uint8(uint(data));\\n    augmentationLevel = uint8(uint(data) >> 8);\\n    durability = uint16(uint(data) >> (8 + 8));\\n  }\\n  //endregion ------------------------------------ ITEMS\\n\\n  //region ------------------------------------ STORIES\\n\\n  function packStoryPageId(uint16 storyId, uint16 pageId, uint8 heroClass) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n  }\\n\\n  function unpackStoryPageId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n  }\\n\\n  function packStoryAnswerId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n  }\\n\\n  function unpackStoryAnswerId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n  }\\n\\n  function packStoryNextPagesId(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(resultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryNextPagesId(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 resultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    resultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryAttributeRequirement(uint8 attributeIndex, int32 value, bool isCore) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(attributeIndex));\\n    data |= bytes32(uint(uint32(value))) << 8;\\n    data |= bytes32(uint(isCore ? uint8(1) : uint8(0))) << (8 + 32);\\n  }\\n\\n  function unpackStoryAttributeRequirement(bytes32 data) internal pure returns (uint8 attributeIndex, int32 value, bool isCore) {\\n    attributeIndex = uint8(uint(data));\\n    value = int32(int(uint(data) >> 8));\\n    isCore = uint8(uint(data) >> (8 + 32)) == uint8(1);\\n  }\\n\\n  function packStoryItemRequirement(address item, bool requireItemBurn, bool requireItemEquipped) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(item)));\\n    data |= bytes32(uint(requireItemBurn ? uint8(1) : uint8(0))) << 160;\\n    data |= bytes32(uint(requireItemEquipped ? uint8(1) : uint8(0))) << (160 + 8);\\n  }\\n\\n  function unpackStoryItemRequirement(bytes32 data) internal pure returns (address item, bool requireItemBurn, bool requireItemEquipped) {\\n    item = address(uint160(uint(data)));\\n    requireItemBurn = uint8(uint(data) >> 160) == uint8(1);\\n    requireItemEquipped = uint8(uint(data) >> (160 + 8)) == uint8(1);\\n  }\\n\\n  /// @dev max amount is 309,485,009 for token with 18 decimals\\n  function packStoryTokenRequirement(address token, uint88 amount, bool requireTransfer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(token)));\\n    data |= bytes32(uint(amount)) << 160;\\n    data |= bytes32(uint(requireTransfer ? uint8(1) : uint8(0))) << (160 + 88);\\n  }\\n\\n  function unpackStoryTokenRequirement(bytes32 data) internal pure returns (address token, uint88 amount, bool requireTransfer) {\\n    token = address(uint160(uint(data)));\\n    amount = uint88(uint(data) >> 160);\\n    requireTransfer = uint8(uint(data) >> (160 + 88)) == uint8(1);\\n  }\\n\\n  function packStoryCustomDataResult(uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(storyId));\\n    data |= bytes32(uint(pageId)) << 16;\\n    data |= bytes32(uint(heroClass)) << (16 + 16);\\n    data |= bytes32(uint(answerId)) << (16 + 16 + 8);\\n    data |= bytes32(uint(customDataResultId)) << (16 + 16 + 8 + 16);\\n  }\\n\\n  function unpackStoryCustomDataResult(bytes32 data) internal pure returns (uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId, uint8 customDataResultId) {\\n    storyId = uint16(uint(data));\\n    pageId = uint16(uint(data) >> 16);\\n    heroClass = uint8(uint(data) >> (16 + 16));\\n    answerId = uint16(uint(data) >> (16 + 16 + 8));\\n    customDataResultId = uint8(uint(data) >> (16 + 16 + 8 + 16));\\n  }\\n\\n  function packStoryHeroState(uint16 pageId, uint40 heroLastActionTS) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(pageId));\\n    data |= bytes32(uint(heroLastActionTS)) << 16;\\n  }\\n\\n  function unpackStoryHeroState(bytes32 data) internal pure returns (uint16 pageId, uint40 heroLastActionTS) {\\n    pageId = uint16(uint(data));\\n    heroLastActionTS = uint40(uint(data) >> 16);\\n  }\\n\\n  function packStoryHeroStateId(address heroAdr, uint80 heroId, uint16 storyId) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(uint160(heroAdr)));\\n    data |= bytes32(uint(heroId)) << 160;\\n    data |= bytes32(uint(storyId)) << (160 + 80);\\n  }\\n\\n  function unpackStoryHeroStateId(bytes32 data) internal pure returns (address heroAdr, uint80 heroId, uint16 storyId) {\\n    heroAdr = address(uint160(uint(data)));\\n    heroId = uint80(uint(data) >> 160);\\n    storyId = uint16(uint(data) >> (160 + 80));\\n  }\\n\\n  function packStorySimpleRequirement(uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(randomRequirement));\\n    data |= bytes32(uint(delayRequirement)) << 32;\\n    data |= bytes32(uint(isFinalAnswer ? uint8(1) : uint8(0))) << (32 + 32);\\n  }\\n\\n  function unpackStorySimpleRequirement(bytes32 data) internal pure returns (uint32 randomRequirement, uint32 delayRequirement, bool isFinalAnswer) {\\n    randomRequirement = uint32(uint(data));\\n    delayRequirement = uint32(uint(data) >> 32);\\n    isFinalAnswer = uint8(uint(data) >> (32 + 32)) == uint8(1);\\n  }\\n\\n  function packBurnInfo(uint8 slot, uint64 chance, bool stopIfBurned) internal pure returns (bytes32 data) {\\n    data = bytes32(uint(slot));\\n    data |= bytes32(uint(chance)) << 8;\\n    data |= bytes32(uint(stopIfBurned ? uint8(1) : uint8(0))) << (8 + 64);\\n  }\\n\\n  function unpackBurnInfo(bytes32 data) internal pure returns (uint8 slot, uint64 chance, bool stopIfBurned) {\\n    slot = uint8(uint(data));\\n    chance = uint64(uint(data) >> 8);\\n    stopIfBurned = uint8(uint(data) >> (8 + 64)) == uint8(1);\\n  }\\n  //endregion ------------------------------------ STORIES\\n\\n  ////////////////////////////////////////////////////////////////////////////////////\\n  // ---- ARRAYS LOGIC ----\\n  ////////////////////////////////////////////////////////////////////////////////////\\n\\n  //region ------------------------------------ SIMPLE ARRAYS\\n\\n\\n  function packUint8Array(uint8[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 32) revert OutOfBounds(len, 32);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 8);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {packUint8Array} for small number of items\\n  ///         It allows to exclude dynamic array creation.\\n  function packUint8Array3(uint8 a, uint8 b, uint8 c) internal pure returns (bytes32) {\\n    bytes32 result = bytes32(uint(a));\\n    result |= bytes32(uint(b)) << (1 * 8);\\n    result |= bytes32(uint(c)) << (2 * 8);\\n    return result;\\n  }\\n\\n\\n  function unpackUint8Array(bytes32 data) internal pure returns (uint8[] memory) {\\n    uint8[] memory result = new uint8[](32);\\n    for (uint i = 0; i < 32; i++) {\\n      result[i] = uint8(uint(data) >> (i * 8));\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Simple faster version of {unpackUint8Array} for small number of items\\n  ///         It allows to exclude only first 3 values\\n  function unpackUint8Array3(bytes32 data) internal pure returns (uint8 a, uint8 b, uint8 c) {\\n    a = uint8(uint(data));\\n    b = uint8(uint(data) >> (1 * 8));\\n    c = uint8(uint(data) >> (2 * 8));\\n  }\\n\\n  function changeUnit8ArrayWithCheck(bytes32 data, uint index, uint8 value, uint8 expectedPrevValue) internal pure returns (bytes32 newData) {\\n    uint8[] memory arr = unpackUint8Array(data);\\n    if (arr[index] != expectedPrevValue) revert UnexpectedValue(uint(expectedPrevValue), uint(arr[index]));\\n    arr[index] = value;\\n    return packUint8Array(arr);\\n  }\\n\\n  function packInt32Array(int32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i; i < len; i++) {\\n      result |= bytes32(uint(uint32(data[i]))) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackInt32Array(bytes32 data) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = int32(int(uint(data) >> (i * 32)));\\n    }\\n    return result;\\n  }\\n\\n  function packUint32Array(uint32[] memory data) internal pure returns (bytes32) {\\n    uint len = data.length;\\n    if (len > 8) revert OutOfBounds(len, 8);\\n    bytes32 result;\\n    for (uint i = 0; i < len; i++) {\\n      result |= bytes32(uint(data[i])) << (i * 32);\\n    }\\n    return result;\\n  }\\n\\n  function unpackUint32Array(bytes32 data) internal pure returns (uint32[] memory) {\\n    uint32[] memory result = new uint32[](8);\\n    for (uint i = 0; i < 8; i++) {\\n      result[i] = uint32(uint(data) >> (i * 32));\\n    }\\n    return result;\\n  }\\n  //endregion ------------------------------------ SIMPLE ARRAYS\\n\\n  //region ------------------------------------ COMPLEX ARRAYS\\n\\n  // We should represent arrays without concrete size.\\n  // For this reason we must not revert on out of bounds but return zero value instead.\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getInt32AsInt24(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n//    if (idx / 8 >= arr.length) {\\n//      return int32(0);\\n//    }\\n//    return int32(int24(int(uint(arr[idx / 8]) >> ((idx % 8) * 32))));\\n//  }\\n\\n  // we need it for properly unpack packed arrays with ids\\n//  function getUnit8From32Step(bytes32[] memory arr, uint idx) internal pure returns (uint8) {\\n//    if (idx / 8 >= arr.length) {\\n//      return uint8(0);\\n//    }\\n//    return uint8(uint(arr[idx / 8]) >> ((idx % 8) * 32 + 24));\\n//  }\\n\\n  function getInt32Memory(bytes32[] memory arr, uint idx) internal pure returns (int32) {\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function getInt32(bytes32[] storage arr, uint idx) internal view returns (int32) {\\n    // additional gas usage, but we should not revert on out of bounds\\n    if (idx / 8 >= arr.length) {\\n      return int32(0);\\n    }\\n    return int32(int(uint(arr[idx / 8]) >> ((idx % 8) * 32)));\\n  }\\n\\n  function setInt32(bytes32[] storage arr, uint idx, int32 value) internal {\\n    uint pos = idx / 8;\\n    uint shift = (idx % 8) * 32;\\n\\n    uint curLength = arr.length;\\n    if (pos >= curLength) {\\n      arr.push(0);\\n      for (uint i = curLength; i < pos; ++i) {\\n        arr.push(0);\\n      }\\n    }\\n\\n    arr[pos] = bytes32(uint(arr[pos]) & ~(uint(0xffffffff) << shift) | (uint(uint32(value)) & 0xffffffff) << shift);\\n  }\\n\\n  /// @notice Increment {idx}-th item on {value}\\n  function changeInt32(bytes32[] storage arr, uint idx, int32 value) internal returns (int32 newValue, int32 change) {\\n    int32 cur = int32(int(getInt32(arr, idx)));\\n    int newValueI = int(cur) + int(value);\\n    newValue = int32(newValueI);\\n    change = int32(newValueI - int(cur));\\n\\n    setInt32(arr, idx, newValue);\\n  }\\n\\n  function toInt32Array(bytes32[] memory arr, uint size) internal pure returns (int32[] memory) {\\n    int32[] memory result = new int32[](size);\\n    for (uint i = 0; i < arr.length; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= size) break;\\n        result[idx] = getInt32Memory(arr, idx);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array\\n  function toBytes32Array(int32[] memory arr) internal pure returns (bytes32[] memory) {\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n        result[i] |= bytes32(uint(uint32(arr[idx]))) << (j * 32);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev pack int32 array into bytes32 array using last 8bytes for ids\\n  ///      we can not use zero values coz will not able to properly unpack it later\\n  function toBytes32ArrayWithIds(int32[] memory arr, uint8[] memory ids) internal pure returns (bytes32[] memory) {\\n    if (arr.length != ids.length) revert LengthsMismatch();\\n\\n    uint size = arr.length / 8 + 1;\\n    bytes32[] memory result = new bytes32[](size);\\n    for (uint i; i < size; ++i) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        if (idx >= arr.length) break;\\n\\n//        console.log(\\\"toBytes32ArrayWithIds id: %s, value: %s%s\\\", ids[idx], arr[idx] >= 0 ? '' : '-', arr[idx] >= 0 ? uint(int(arr[idx])) : uint(int(-arr[idx])));\\n\\n        if (arr[idx] > type(int24).max || arr[idx] < type(int24).min) revert IntOutOfRange(int(arr[idx]));\\n        if (arr[idx] == 0) revert ZeroValue();\\n        result[i] |= bytes32(uint(uint24(int24(arr[idx])))) << (j * 32);\\n        result[i] |= bytes32(uint(ids[idx])) << (j * 32 + 24);\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /// @dev we do not know exact size of array, assume zero values is not acceptable for this array\\n  function toInt32ArrayWithIds(bytes32[] memory arr) internal pure returns (int32[] memory values, uint8[] memory ids) {\\n    uint len = arr.length;\\n    uint size = len * 8;\\n    int32[] memory valuesTmp = new int32[](size);\\n    uint8[] memory idsTmp = new uint8[](size);\\n    uint counter;\\n    for (uint i = 0; i < len; i++) {\\n      for (uint j; j < 8; ++j) {\\n        uint idx = i * 8 + j;\\n        // if (idx >= size) break;  // it looks like a useless check\\n        valuesTmp[idx] = int32(int24(int(uint(arr[i]) >> (j * 32)))); // getInt32AsInt24(arr, idx);\\n        idsTmp[idx] = uint8(uint(arr[i]) >> (j * 32 + 24)); // getUnit8From32Step(arr, idx);\\n        if (valuesTmp[idx] == 0) {\\n          break;\\n        }\\n        counter++;\\n      }\\n    }\\n\\n    values = new int32[](counter);\\n    ids = new uint8[](counter);\\n    for (uint i; i < counter; ++i) {\\n      values[i] = valuesTmp[i];\\n      ids[i] = idsTmp[i];\\n    }\\n  }\\n  //endregion ------------------------------------ COMPLEX ARRAYS\\n\\n}\\n\",\"keccak256\":\"0x169dec334b08b119f2b91eeb4650ab285440f7f698ad96584bf78c982d9e66ee\",\"license\":\"BUSL-1.1\"},\"contracts/lib/SlotsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\\n/// @author bogdoslav\\nlibrary SlotsLib {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant SLOT_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  // ************* GETTERS *******************\\n\\n  /// @dev Gets a slot as bytes32\\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as an address\\n  function getAddress(bytes32 slot) internal view returns (address result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as uint256\\n  function getUint(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  // ************* ARRAY GETTERS *******************\\n\\n  /// @dev Gets an array length\\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  // ************* SETTERS *******************\\n\\n  /// @dev Sets a slot with bytes32\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, bytes32 value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with address\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, address value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with uint\\n  function set(bytes32 slot, uint value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0x52ede981a6bb509c0dce07a0373e3c073c24fd16ca4ca7fbaa24f6c8b747b45b\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StatLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"./CalcLib.sol\\\";\\nimport \\\"./PackingLib.sol\\\";\\n\\nlibrary StatLib {\\n  using PackingLib for bytes32[];\\n  using PackingLib for bytes32;\\n  using PackingLib for uint32[];\\n  using PackingLib for int32[];\\n  using CalcLib for int32;\\n\\n  //region --------------------------- Constants\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant STAT_LIB_VERSION = \\\"1.0.0\\\";\\n  uint32 public constant MAX_LEVEL = 99;\\n\\n  uint public constant BASE_EXPERIENCE = 100_000;\\n  uint public constant BIOME_LEVEL_STEP = 5;\\n  uint internal constant _MAX_AMPLIFIER = 1e18;\\n  uint private constant _PRECISION = 1e18;\\n\\n  /// @dev Assume MAX_BIOME * BIOME_LEVEL_STEP < MAX_LEVEL + 1, see dungeonTreasuryReward\\n  uint public constant MAX_POSSIBLE_BIOME = 19;\\n  //endregion --------------------------- Constants\\n\\n  //region --------------------------- Data types\\n\\n  struct BaseMultiplier {\\n    uint minDamage;\\n    uint maxDamage;\\n    uint attackRating;\\n    uint defense;\\n    uint blockRating;\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct LevelUp {\\n    uint life;\\n    uint mana;\\n  }\\n\\n  struct InitialHero {\\n    IStatController.CoreAttributes core;\\n    BaseMultiplier multiplier;\\n    LevelUp levelUp;\\n    int32 baseLifeChances;\\n  }\\n\\n  enum HeroClasses {\\n    UNKNOWN,\\n    THRALL,\\n    SAVAGE,\\n    MAGE,\\n    ASSASSIN,\\n    GHOST,\\n    HAMMERGINA,\\n    END_SLOT\\n  }\\n  //endregion --------------------------- Data types\\n\\n  //region --------------------------- BASE\\n\\n  // --- HERO 1 (Slave) ---\\n\\n  function initialHero1() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 15,\\n      vitality: 30,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 2e18,\\n      blockRating: 0.1e18,\\n      life: 1.5e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 2e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 2 (Spata) ---\\n\\n  function initialHero2() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 30,\\n      dexterity: 5,\\n      vitality: 25,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: 0.25e18,\\n      attackRating: 2e18,\\n      defense: 1e18,\\n      blockRating: 0.08e18,\\n      life: 1.3e18,\\n      mana: 0.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.8e18,\\n      mana: 1e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 3 (Decidia) ---\\n\\n  function initialHero3() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 10,\\n      dexterity: 15,\\n      vitality: 20,\\n      energy: 25\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 2e18,\\n      defense: 1e18,\\n      blockRating: 0.1e18,\\n      life: 1e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.3e18,\\n      mana: 2e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 4 (Innatus) ---\\n\\n  function initialHero4() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 15,\\n      dexterity: 25,\\n      vitality: 15,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.1e18,\\n      maxDamage: 0.2e18,\\n      attackRating: 4e18,\\n      defense: 3e18,\\n      blockRating: 0.2e18,\\n      life: 1.2e18,\\n      mana: 1e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 5\\n    });\\n  }\\n\\n  // --- HERO 5 (F2P) ---\\n\\n  function initialHero5() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 20,\\n      dexterity: 20,\\n      vitality: 20,\\n      energy: 10\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.15e18,\\n      maxDamage: 0.25e18,\\n      attackRating: 3e18,\\n      defense: 2.5e18,\\n      blockRating: 0.15e18,\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.5e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // --- HERO 6 (F2P) HAMMERGINA ---\\n\\n  function initialHero6() internal pure returns (InitialHero memory) {\\n    return InitialHero({\\n      core: IStatController.CoreAttributes({\\n      strength: 50,\\n      dexterity: 30,\\n      vitality: 50,\\n      energy: 15\\n    }),\\n\\n      multiplier: BaseMultiplier({\\n      minDamage: 0.2e18,\\n      maxDamage: 0.3e18,\\n      attackRating: 5e18,\\n      defense: 3e18,\\n      blockRating: 0.15e18,\\n      life: 2e18,\\n      mana: 2e18\\n    }),\\n\\n      levelUp: LevelUp({\\n      life: 1.7e18,\\n      mana: 1.5e18\\n    }),\\n\\n      baseLifeChances: 1\\n    });\\n  }\\n\\n  // ------\\n\\n  function initialHero(uint heroClass) internal pure returns (InitialHero memory) {\\n    if (heroClass == 1) {\\n      return initialHero1();\\n    } else if (heroClass == 2) {\\n      return initialHero2();\\n    } else if (heroClass == 3) {\\n      return initialHero3();\\n    } else if (heroClass == 4) {\\n      return initialHero4();\\n    } else if (heroClass == 5) {\\n      return initialHero5();\\n    } else if (heroClass == 6) {\\n      return initialHero6();\\n    } else {\\n      revert IAppErrors.UnknownHeroClass(heroClass);\\n    }\\n  }\\n  //endregion --------------------------- BASE\\n\\n  //region --------------------------- CALCULATIONS\\n\\n  function minDamage(int32 strength, uint heroClass) internal pure returns (int32) {\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.minDamage / _PRECISION));\\n  }\\n\\n  function maxDamage(int32 strength, uint heroClass) internal pure returns (int32){\\n    return int32(int(strength.toUint() * initialHero(heroClass).multiplier.maxDamage / _PRECISION));\\n  }\\n\\n  function attackRating(int32 dexterity, uint heroClass) internal pure returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.attackRating / _PRECISION));\\n  }\\n\\n  function defense(int32 dexterity, uint heroClass) internal pure returns (int32){\\n    return int32(int(dexterity.toUint() * initialHero(heroClass).multiplier.defense / _PRECISION));\\n  }\\n\\n  function blockRating(int32 dexterity, uint heroClass) internal pure returns (int32){\\n    return int32(int(Math.min((dexterity.toUint() * initialHero(heroClass).multiplier.blockRating / _PRECISION), 75)));\\n  }\\n\\n  function life(int32 vitality, uint heroClass, uint32 level) internal pure returns (int32){\\n    return int32(int(\\n      (vitality.toUint() * initialHero(heroClass).multiplier.life / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.life / _PRECISION)\\n    ));\\n  }\\n\\n  function mana(int32 energy, uint heroClass, uint32 level) internal pure returns (int32){\\n    return int32(int(\\n      (energy.toUint() * initialHero(heroClass).multiplier.mana / _PRECISION)\\n      + (uint(level) * initialHero(heroClass).levelUp.mana / _PRECISION)\\n    ));\\n  }\\n\\n  function lifeChances(uint heroClass, uint32 /*level*/) internal pure returns (int32){\\n    return initialHero(heroClass).baseLifeChances;\\n  }\\n\\n  function levelExperience(uint32 level) internal pure returns (uint32) {\\n    if (level == 0 || level >= MAX_LEVEL) {\\n      return 0;\\n    }\\n    return uint32(uint(level) * BASE_EXPERIENCE * (67e17 - CalcLib.log2((uint(MAX_LEVEL - level + 2)) * 1e18)) / 1e18);\\n  }\\n\\n  function chanceToHit(\\n    uint attackersAttackRating,\\n    uint defendersDefenceRating,\\n    uint attackersLevel,\\n    uint defendersLevel,\\n    uint arFactor\\n  ) internal pure returns (uint) {\\n    attackersAttackRating += attackersAttackRating * arFactor / 100;\\n    uint x = Math.max(attackersAttackRating, 1);\\n    uint y = Math.max(attackersAttackRating + defendersDefenceRating, 1);\\n    uint z = attackersLevel;\\n    uint k = defendersLevel / 2;\\n    uint xy = x * 1e18 / y;\\n    uint zk = z * 1e18 / (attackersLevel + k);\\n    uint base = 2 * xy * zk / 1e18;\\n    return Math.max(Math.min(base, 0.95e18), 0.2e18);\\n  }\\n\\n  function experienceToLvl(uint experience, uint startFromLevel) internal pure returns (uint level) {\\n    level = startFromLevel;\\n    for (; level < MAX_LEVEL;) {\\n      if (levelExperience(uint32(level)) >= experience) {\\n        break;\\n      }\\n      unchecked{++level;}\\n    }\\n  }\\n\\n  function expPerMonster(uint32 monsterExp, uint monsterRarity, uint32 heroExp, uint32 heroCurrentLvl, uint monsterBiome) internal pure returns (uint32) {\\n    uint heroLvl = experienceToLvl(uint(heroExp), uint(heroCurrentLvl));\\n    uint heroBiome = heroLvl / StatLib.BIOME_LEVEL_STEP + 1;\\n    uint base = uint(monsterExp) + uint(monsterExp) * monsterRarity / _MAX_AMPLIFIER;\\n\\n    // reduce exp if hero not in his biome\\n    if (heroBiome > monsterBiome) {\\n      base = base / (2 ** (heroBiome - monsterBiome));\\n    }\\n    return uint32(base);\\n  }\\n\\n  /// @notice Allow to calculate delta param for {mintDropChance}\\n  function mintDropChanceDelta(uint experience, uint startFromLevel, uint monsterBiome) internal pure returns (uint) {\\n    uint heroBiome = StatLib.experienceToLvl(experience, startFromLevel) / StatLib.BIOME_LEVEL_STEP + 1;\\n    return heroBiome > monsterBiome ? 2**(heroBiome - monsterBiome) : 0;\\n  }\\n\\n  /// @param delta 2 ** (heroBiome - monsterBiome) or zero if heroBiome < monsterBiome, see {mintDropChanceDelta}\\n  function mintDropChance(uint baseChance, uint monsterRarity, uint delta) internal pure returns (uint) {\\n    uint chance = baseChance + baseChance * monsterRarity / _MAX_AMPLIFIER;\\n\\n    // reduce chance if hero not in his biome\\n    return delta == 0\\n      ? chance\\n      : chance / delta;\\n  }\\n\\n  function initAttributes(\\n    bytes32[] storage attributes,\\n    uint heroClass,\\n    uint32 level,\\n    IStatController.CoreAttributes memory base\\n  ) internal returns (uint32[] memory result) {\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.STRENGTH), base.strength);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEXTERITY), base.dexterity);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.VITALITY), base.vitality);\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ENERGY), base.energy);\\n\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN), minDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX), maxDamage(base.strength, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING), attackRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE), defense(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING), blockRating(base.dexterity, heroClass));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE), life(base.vitality, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA), mana(base.energy, heroClass, level));\\n    attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE_CHANCES), lifeChances(heroClass, level));\\n\\n    result = new uint32[](3);\\n    result[0] = uint32(life(base.vitality, heroClass, level).toUint());\\n    result[1] = uint32(mana(base.energy, heroClass, level).toUint());\\n    result[2] = uint32(lifeChances(heroClass, uint32(level)).toUint());\\n  }\\n\\n  function updateCoreDependAttributesInMemory(\\n    int32[] memory attributes,\\n    int32[] memory bonus,\\n    uint heroClass,\\n    uint32 level\\n  ) internal pure returns (int32[] memory) {\\n    int32 strength = attributes[uint(IStatController.ATTRIBUTES.STRENGTH)];\\n    int32 dexterity = attributes[uint(IStatController.ATTRIBUTES.DEXTERITY)];\\n    int32 vitality = attributes[uint(IStatController.ATTRIBUTES.VITALITY)];\\n    int32 energy = attributes[uint(IStatController.ATTRIBUTES.ENERGY)];\\n\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)] = minDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MIN)];\\n    attributes[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)] = maxDamage(strength, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DAMAGE_MAX)];\\n    attributes[uint(IStatController.ATTRIBUTES.ATTACK_RATING)] = attackRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.ATTACK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.DEFENSE)] = defense(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.DEFENSE)];\\n    attributes[uint(IStatController.ATTRIBUTES.BLOCK_RATING)] = blockRating(dexterity, heroClass) + bonus[uint(IStatController.ATTRIBUTES.BLOCK_RATING)];\\n    attributes[uint(IStatController.ATTRIBUTES.LIFE)] = life(vitality, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.LIFE)];\\n    attributes[uint(IStatController.ATTRIBUTES.MANA)] = mana(energy, heroClass, level) + bonus[uint(IStatController.ATTRIBUTES.MANA)];\\n    return attributes;\\n  }\\n\\n  function updateCoreDependAttributes(\\n    IController controller,\\n    bytes32[] storage attributes,\\n    bytes32[] storage bonusMain,\\n    bytes32[] storage bonusExtra,\\n    IStatController.ChangeableStats memory _heroStats,\\n    uint index,\\n    address heroToken,\\n    int32 base\\n  ) internal {\\n    uint heroClass = IHeroController(controller.heroController()).heroClass(heroToken);\\n    if (index == uint(IStatController.ATTRIBUTES.STRENGTH)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN),\\n        StatLib.minDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MIN))\\n      );\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX),\\n        StatLib.maxDamage(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DAMAGE_MAX))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.DEXTERITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING),\\n        StatLib.attackRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.ATTACK_RATING))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.DEFENSE),\\n        StatLib.defense(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.DEFENSE))\\n      );\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING),\\n        StatLib.blockRating(base, heroClass)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.BLOCK_RATING))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.VITALITY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.LIFE),\\n        StatLib.life(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.LIFE))\\n      );\\n    } else if (index == uint(IStatController.ATTRIBUTES.ENERGY)) {\\n\\n      attributes.setInt32(uint(IStatController.ATTRIBUTES.MANA),\\n        StatLib.mana(base, heroClass, _heroStats.level)\\n        + bonusMain.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n        + bonusExtra.getInt32(uint(IStatController.ATTRIBUTES.MANA))\\n      );\\n    }\\n  }\\n\\n  function attributesAdd(int32[] memory base, int32[] memory add) internal pure returns (int32[] memory) {\\n    unchecked{\\n      for (uint i; i < base.length; ++i) {\\n        base[i] += add[i];\\n      }\\n    }\\n    return base;\\n  }\\n\\n// Currently this function is not used\\n//  function attributesRemove(int32[] memory base, int32[] memory remove) internal pure returns (int32[] memory) {\\n//    unchecked{\\n//      for (uint i; i < base.length; ++i) {\\n//        base[i] = CalcLib.minusWithMinFloorI32(base[i], remove[i]);\\n//      }\\n//    }\\n//    return base;\\n//  }\\n\\n  function packChangeableStats(IStatController.ChangeableStats memory stats) internal pure returns (bytes32) {\\n    uint32[] memory cData = new uint32[](5);\\n    cData[0] = stats.level;\\n    cData[1] = stats.experience;\\n    cData[2] = stats.life;\\n    cData[3] = stats.mana;\\n    cData[4] = stats.lifeChances;\\n\\n    return cData.packUint32Array();\\n  }\\n\\n  function unpackChangeableStats(bytes32 data) internal pure returns (IStatController.ChangeableStats memory result) {\\n    uint32[] memory cData = data.unpackUint32Array();\\n    return IStatController.ChangeableStats({\\n      level: cData[0],\\n      experience: cData[1],\\n      life: cData[2],\\n      mana: cData[3],\\n      lifeChances: cData[4]\\n    });\\n  }\\n\\n  function bytesToFullAttributesArray(bytes32[] memory attributes) internal pure returns (int32[] memory result) {\\n    (int32[] memory values, uint8[] memory ids) = attributes.toInt32ArrayWithIds();\\n    return valuesToFullAttributesArray(values, ids);\\n  }\\n\\n  function valuesToFullAttributesArray(int32[] memory values, uint8[] memory ids) internal pure returns (int32[] memory result) {\\n    result = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n    for (uint i; i < values.length; ++i) {\\n      int32 value = values[i];\\n      if (value != 0) {\\n        result[ids[i]] = value;\\n      }\\n    }\\n  }\\n  //endregion --------------------------- CALCULATIONS\\n\\n}\\n\",\"keccak256\":\"0x7c620e54a4e0a50ebc566ef993d709d6badd2a7e366950513a7641d4414aabd6\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StoryControllerLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\nimport \\\"../proxy/Controllable.sol\\\";\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"../interfaces/IStatController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IHeroController.sol\\\";\\nimport \\\"../lib/StoryLib.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\nimport \\\"../lib/StorySetupLib.sol\\\";\\n\\n\\nlibrary StoryControllerLib {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n  using CalcLib for uint;\\n  using PackingLib for bytes32;\\n  using PackingLib for uint16;\\n  using PackingLib for uint8;\\n  using PackingLib for address;\\n  using PackingLib for uint32[];\\n  using PackingLib for uint32;\\n  using PackingLib for uint64;\\n  using PackingLib for int32[];\\n  using PackingLib for int32;\\n\\n\\n  //region ------------------------ CONSTANTS\\n  /// @dev keccak256(abi.encode(uint256(keccak256(\\\"story.controller.main\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 internal constant MAIN_STORAGE_LOCATION = 0x1fbca2ab9841348cca3f2687c48325e9989a76ad929b9970d1c11e233677cf00;\\n  //endregion ------------------------ CONSTANTS\\n\\n\\n  //region ------------------------ Restrictions\\n  function onlyDeployer(IController controller) internal view {\\n    if (!controller.isDeployer(msg.sender)) revert IAppErrors.ErrorNotDeployer(msg.sender);\\n  }\\n  //endregion ------------------------ Restrictions\\n\\n  //region ------------------------ VIEWS\\n\\n\\n  function _S() internal pure returns (IStoryController.MainState storage s) {\\n    assembly {\\n      s.slot := MAIN_STORAGE_LOCATION\\n    }\\n    return s;\\n  }\\n\\n  function idToStory(uint16 storyId) internal view returns (uint32) {\\n    return _S().idToStory[storyId];\\n  }\\n\\n  function storyBuildHash(uint16 storyId) internal view returns (uint) {\\n    return _S().storyBuildHash[storyId];\\n  }\\n\\n  function heroPage(address hero, uint80 heroId, uint16 storyId) internal view returns (uint16 pageId) {\\n    (pageId,) = _S().heroState[hero.packStoryHeroStateId(heroId, storyId)].unpackStoryHeroState();\\n  }\\n\\n  function storyIds(uint32 objectId) internal view returns (uint16) {\\n    return _S().storyIds[objectId];\\n  }\\n\\n  function registeredStories(uint32 objectId) internal view returns (bool) {\\n    return _S().registeredStories[objectId];\\n  }\\n\\n  function allStoryPagesLength(uint16 storyId) internal view returns (uint) {\\n    return _S().allStoryPages[storyId].length();\\n  }\\n\\n  function allStoryPages(uint16 storyId, uint index) internal view returns (uint) {\\n    return _S().allStoryPages[storyId].at(index);\\n  }\\n\\n  function allStoryAnswersLength(uint16 storyId) internal view returns (uint) {\\n    return _S().allStoryAnswers[storyId].length();\\n  }\\n\\n  function allStoryAnswers(uint16 storyId, uint index) internal view returns (bytes32) {\\n    return _S().allStoryAnswers[storyId].at(index);\\n  }\\n\\n  /// @notice Get list of answers for the current page stored in the hero state\\n  /// @return List of answers for the (page, heroClass). If the list is empty return default answers for (page, 0)\\n  function currentHeroAnswers(IController controller, uint16 storyId, address hero, uint80 heroId) internal view returns (\\n    bytes32[] memory\\n  ) {\\n    IHeroController hc = IHeroController(controller.heroController());\\n\\n    (uint16 pageId,) = _S().heroState[hero.packStoryHeroStateId(heroId, storyId)].unpackStoryHeroState();\\n    bytes32[] memory heroAnswers = _S().answers[storyId.packStoryPageId(pageId, hc.heroClass(hero))];\\n\\n    if (heroAnswers.length == 0) {\\n      heroAnswers = _S().answers[storyId.packStoryPageId(pageId, 0)];\\n    }\\n\\n    if (heroAnswers.length != 0) {\\n      // shuffle answers using Fisher\\u2013Yates shuffle algorithm\\n      for (uint i; i < heroAnswers.length - 1; i++) {\\n        uint randomIndex = CalcLib.pseudoRandomInRange(i, heroAnswers.length - 1);\\n        (heroAnswers[randomIndex], heroAnswers[i]) = (heroAnswers[i], heroAnswers[randomIndex]);\\n      }\\n    }\\n\\n    return heroAnswers;\\n  }\\n\\n  function isStoryAvailableForHero(IController controller, uint32 objectId, address heroToken, uint heroTokenId) internal view returns (bool) {\\n    return StoryLib.isStoryAvailableForHero(_S(), _S().storyIds[objectId], heroToken, heroTokenId, controller.statController());\\n  }\\n\\n  //endregion ------------------------ VIEWS\\n\\n  //region ------------------------ SETTERS\\n\\n  function setAllStoryFields(IController controller, IStoryController.StoryMetaInfo calldata meta) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setAllStoryFields(_S(), meta);\\n  }\\n\\n  function setBurnItemsMeta(\\n    IController controller,\\n    uint16 storyId,\\n    IStoryController.AnswerBurnRandomItemMeta calldata meta\\n  ) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setBurnItemsMeta(_S(), storyId, meta);\\n  }\\n\\n  function setNextObjRewriteMeta(IController controller, uint16 storyId, IStoryController.NextObjRewriteMeta calldata meta) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setNextObjRewriteMeta(_S(), storyId, meta);\\n  }\\n\\n  function setAnswersMeta(\\n    IController controller,\\n    uint16 storyId,\\n    uint16[] calldata answerPageIds,\\n    uint8[] calldata answerHeroClasses,\\n    uint16[] calldata answerIds\\n  ) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setAnswersMeta(_S(), storyId, answerPageIds, answerHeroClasses, answerIds);\\n  }\\n\\n  function setAnswerNextPageMeta(IController controller, uint16 storyId, IStoryController.AnswerNextPageMeta calldata meta) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setAnswerNextPageMeta(_S(), storyId, meta);\\n  }\\n\\n  function setAnswerAttributeRequirements(IController controller, uint16 storyId, IStoryController.AnswerAttributeRequirementsMeta calldata meta) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setAnswerAttributeRequirements(_S(), storyId, meta);\\n  }\\n\\n  function setAnswerItemRequirements(IController controller, uint16 storyId, IStoryController.AnswerItemRequirementsMeta calldata meta) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setAnswerItemRequirements(_S(), storyId, meta);\\n  }\\n\\n  function setAnswerTokenRequirementsMeta(IController controller, uint16 storyId, IStoryController.AnswerTokenRequirementsMeta calldata meta) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setAnswerTokenRequirementsMeta(_S(), storyId, meta);\\n  }\\n\\n  function setAnswerAttributes(IController controller, uint16 storyId, IStoryController.AnswerAttributesMeta calldata meta) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setAnswerAttributes(_S(), storyId, meta);\\n  }\\n\\n  function setAnswerHeroCustomDataRequirementMeta(IController controller, uint16 storyId, IStoryController.AnswerCustomDataMeta calldata meta) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setAnswerHeroCustomDataRequirementMeta(_S(), storyId, meta);\\n  }\\n\\n  function setAnswerGlobalCustomDataRequirementMeta(IController controller, uint16 storyId, IStoryController.AnswerCustomDataMeta calldata meta) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setAnswerGlobalCustomDataRequirementMeta(_S(), storyId, meta);\\n\\n  }\\n\\n  function setSuccessInfo(IController controller, uint16 storyId, IStoryController.AnswerResultMeta calldata meta) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setSuccessInfo(_S(), storyId, meta);\\n  }\\n\\n  function setFailInfo(IController controller, uint16 storyId, IStoryController.AnswerResultMeta calldata meta) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setFailInfo(_S(), storyId, meta);\\n  }\\n\\n  function setCustomDataResult(\\n    IController controller,\\n    uint16 storyId,\\n    IStoryController.AnswerCustomDataResultMeta calldata meta,\\n    IStoryController.CustomDataResult type_\\n  ) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setCustomDataResult(_S(), storyId, meta, type_);\\n  }\\n\\n  function setStoryCustomDataRequirements(\\n    IController controller,\\n    uint16 storyId,\\n    bytes32[] calldata requiredCustomDataIndex,\\n    uint64[] calldata requiredCustomDataMinValue,\\n    uint64[] calldata requiredCustomDataMaxValue,\\n    bool[] calldata requiredCustomDataIsHero,\\n    uint minLevel\\n  ) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.setStoryCustomDataRequirements(_S(), storyId, requiredCustomDataIndex, requiredCustomDataMinValue, requiredCustomDataMaxValue, requiredCustomDataIsHero, minLevel);\\n  }\\n\\n  function finalizeStoryRegistration(IController controller, uint16 storyId, uint32 objectId, uint buildHash) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.finalizeStoryRegistration(_S(), storyId, objectId, buildHash);\\n  }\\n  //endregion ------------------------ SETTERS\\n\\n  //region ------------------------ CHANGE META\\n\\n  function removeStory(IController controller, uint32 objectId) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.removeStory(_S(), objectId);\\n  }\\n\\n  function removeStoryPagesMeta(IController controller, uint16 storyId, uint maxIterations) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.removeStoryPagesMeta(_S(), storyId, maxIterations);\\n  }\\n\\n  function removeStoryAnswersMeta(IController controller, uint16 storyId, uint maxIterations) internal {\\n    onlyDeployer(controller);\\n    StorySetupLib.removeStoryAnswersMeta(_S(), storyId, maxIterations);\\n  }\\n  //endregion ------------------------ CHANGE META\\n\\n  //region ------------------------ MAIN LOGIC\\n\\n  function storyAction(\\n    IController controller,\\n    address sender,\\n    uint64 dungeonId,\\n    uint32 objectId,\\n    uint stageId,\\n    address heroToken,\\n    uint heroTokenId,\\n    uint8 biome,\\n    uint iteration,\\n    bytes memory data\\n  ) internal returns (IGOC.ActionResult memory result) {\\n    if (controller.gameObjectController() != msg.sender) revert IAppErrors.ErrorNotObjectController(msg.sender);\\n\\n    IStatController statController = IStatController(controller.statController());\\n    IStoryController.StoryActionContext memory context = IStoryController.StoryActionContext({\\n      sender: sender,\\n      dungeonId: dungeonId,\\n      objectId: objectId,\\n      storyId: _S().storyIds[objectId],\\n      stageId: stageId,\\n      controller: controller,\\n      statController: statController,\\n      heroToken: heroToken,\\n      heroTokenId: uint80(heroTokenId),\\n      heroClass: 0,\\n      storyIdFromAnswerHash: 0,\\n      pageIdFromAnswerHash: 0,\\n      heroClassFromAnswerHash: 0,\\n      answerNumber: 0,\\n      answerIdHash: _decodeAnswerId(data),\\n      pageId: 0,\\n      heroLastActionTS: 0,\\n      answerAttributes: bytes32(0),\\n      heroStats: statController.heroStats(heroToken, heroTokenId),\\n      biome: biome,\\n      oracle: IOracle(controller.oracle()),\\n      iteration: iteration,\\n      heroController: IHeroController(controller.heroController()),\\n      itemController: IItemController(controller.itemController())\\n    });\\n\\n    if (context.storyId == 0) revert IAppErrors.ZeroStoryIdStoryAction();\\n\\n    context.heroClass = context.heroController.heroClass(heroToken);\\n    context.answerAttributes = _S().answerAttributes[context.answerIdHash];\\n\\n    (context.pageId, context.heroLastActionTS) = _S().heroState[heroToken.packStoryHeroStateId(uint80(heroTokenId), context.storyId)].unpackStoryHeroState();\\n\\n    (context.storyIdFromAnswerHash,\\n      context.pageIdFromAnswerHash,\\n      context.heroClassFromAnswerHash,\\n      context.answerNumber\\n    ) = context.answerIdHash.unpackStoryAnswerId();\\n\\n    result = _handleAnswer(context, currentHeroAnswers(controller, context.storyId, heroToken, uint80(heroTokenId)));\\n  }\\n\\n  /// @param heroAnswers Full list of possible answers (to be able to check that the answer belongs to the list)\\n  function _handleAnswer(IStoryController.StoryActionContext memory context, bytes32[] memory heroAnswers) internal returns (\\n    IGOC.ActionResult memory results\\n  ) {\\n    IStoryController.MainState storage s = _S();\\n\\n    if (heroAnswers.length == 0) {\\n      results.objectId = context.objectId;\\n      results.heroTokenId = context.heroTokenId;\\n      results.heroToken = context.heroToken;\\n      results.completed = true;\\n    } else {\\n      // check ids only if answer exists, for empty answers we can accept empty answer hash from user\\n      if (context.storyId != context.storyIdFromAnswerHash) revert IAppErrors.AnswerStoryIdMismatch(context.storyId, context.storyIdFromAnswerHash);\\n      if (context.pageId != context.pageIdFromAnswerHash) revert IAppErrors.AnswerPageIdMismatch(context.pageId, context.pageIdFromAnswerHash);\\n\\n      // ensure that the given answer belongs to the list of the available answers\\n      StoryLib.checkAnswerIndexValid(heroAnswers, context.answerIdHash);\\n      (,, bool finalAnswer) = context.answerAttributes.unpackStorySimpleRequirement();\\n\\n      // check answer requirements, burn items, transfer tokens and so on\\n      IStoryController.AnswerResultId answerResult = StoryLib.checkAnswer(context, s);\\n\\n      // burn randomly selected items\\n      StoryLib.burn(context, s);\\n\\n      // handle answer - refresh states\\n      uint16 nextPage;\\n      uint16[] memory nextPages;\\n      (results, nextPage, nextPages) = StoryLib.handleAnswer(answerResult, s, context);\\n\\n      if (finalAnswer || nextPages.length == 0) {\\n        results.completed = true;\\n      } else {\\n        s.heroState[context.heroToken.packStoryHeroStateId(context.heroTokenId, context.storyId)] = nextPage.packStoryHeroState(uint40(block.timestamp));\\n      }\\n    }\\n\\n    if (results.completed) {\\n      results.rewriteNextObject = StoryLib.finishStory(context, s);\\n    }\\n\\n    return results;\\n  }\\n  //endregion ------------------------ MAIN LOGIC\\n\\n  //region ------------------------ Utils\\n  function _decodeAnswerId(bytes memory data) internal pure returns (bytes32 answerId) {\\n    (answerId) = abi.decode(data, (bytes32));\\n  }\\n  //endregion ------------------------ Utils\\n\\n}\\n\",\"keccak256\":\"0xc3da49adcdb7bb9b5845cdb75bccd7ab67ea7a8f846cc6600f0532a6d2e7cc9f\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StoryLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\nimport \\\"../interfaces/IGOC.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721Enumerable.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../lib/CalcLib.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\nimport \\\"../lib/ItemLib.sol\\\";\\nimport \\\"../lib/StringLib.sol\\\";\\n\\nlibrary StoryLib {\\n  using CalcLib for uint;\\n  using PackingLib for address;\\n  using PackingLib for uint16;\\n  using PackingLib for bytes32;\\n  using PackingLib for bytes32[];\\n\\n  //region ------------------------ Story logic\\n\\n  /// @notice Make action, increment STORY_XXX hero custom data if the dungeon is completed / hero is killed\\n  function action(IGOC.ActionContext memory ctx, uint16 storyId) internal returns (IGOC.ActionResult memory result) {\\n    if (storyId == 0) revert IAppErrors.ZeroStoryIdAction();\\n\\n    result = IStoryController(ctx.controller.storyController()).storyAction(\\n      ctx.sender,\\n      ctx.dungeonId,\\n      ctx.objectId,\\n      ctx.stageId,\\n      ctx.heroToken,\\n      ctx.heroTokenId,\\n      ctx.biome,\\n      ctx.iteration,\\n      ctx.data\\n    );\\n\\n    if (result.completed || result.kill) {\\n      IStatController statController = IStatController(ctx.controller.statController());\\n      bytes32 index = _getStoryIndex(storyId);\\n      uint curValue = statController.heroCustomData(ctx.heroToken, ctx.heroTokenId, index);\\n      statController.setHeroCustomData(ctx.heroToken, ctx.heroTokenId, index, curValue + 1);\\n    }\\n  }\\n\\n  /// @notice Check if the story is available for the hero\\n  /// The story is available if hero level fits to requirements\\n  /// and if the hero/global custom data requirements are met (current value is inside of [min, max])\\n  function isStoryAvailableForHero(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    address heroToken,\\n    uint heroTokenId,\\n    address statController\\n  ) internal view returns (bool) {\\n    uint reqLvl = s.storyRequiredLevel[storyId];\\n    if (reqLvl != 0 && IStatController(statController).heroStats(heroToken, heroTokenId).level < reqLvl) {\\n      return false;\\n    }\\n\\n    IStoryController.CustomDataRequirementRangePacked[] storage allData = s.storyRequiredHeroData[storyId];\\n    uint len = allData.length;\\n    for (uint i; i < len; ++i) {\\n      IStoryController.CustomDataRequirementRangePacked memory data = allData[i];\\n\\n      if (data.index == bytes32(0)) continue;\\n\\n      (uint64 min, uint64 max, bool isHeroData) = data.data.unpackCustomDataRequirements();\\n\\n      uint value = isHeroData\\n        ? IStatController(statController).heroCustomData(heroToken, heroTokenId, data.index)\\n        : IStatController(statController).globalCustomData(data.index);\\n\\n      if (value < uint(min) || value > uint(max)) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Update bonus attributes, refresh hero states, initialize and return results\\n  /// @param mintItemsData Source for _mintRandomItems, random item (max 1, probably 0) is selected and put to results\\n  /// @param mintItems_ Function _mintRandomItems is passed here. Parameter is required to make unit tests.\\n  function handleResult(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32[] memory attributesChanges,\\n    bytes32 statsChanges,\\n    bytes32[] memory mintItemsData,\\n    function (IStoryController.StoryActionContext memory, bytes32[] memory) internal returns (address[] memory) mintItems_\\n  ) internal returns (IGOC.ActionResult memory result) {\\n    result.heroToken = context.heroToken;\\n    result.heroTokenId = context.heroTokenId;\\n    result.objectId = context.objectId;\\n\\n    int32[] memory attributes = _generateAttributes(attributesChanges);\\n\\n    if (attributes.length != 0) {\\n      context.statController.changeBonusAttributes(IStatController.ChangeAttributesInfo({\\n        heroToken: context.heroToken,\\n        heroTokenId: context.heroTokenId,\\n        changeAttributes: attributes,\\n        add: true,\\n        temporally: true\\n      }));\\n      // changeBonusAttributes can change life and mana, so we need to refresh hero stats. It's safer to do it always\\n      context.heroStats = context.statController.heroStats(context.heroToken, context.heroTokenId);\\n      emit IApplicationEvents.StoryChangeAttributes(\\n        context.objectId,\\n        context.heroToken,\\n        context.heroTokenId,\\n        context.dungeonId,\\n        context.storyId,\\n        context.stageId,\\n        context.iteration,\\n        attributes\\n      );\\n    }\\n\\n    IStoryController.StatsChange memory statsToChange = _generateStats(statsChanges);\\n\\n    if (statsToChange.heal != 0) {\\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.LIFE));\\n      result.heal = max * statsToChange.heal / 100;\\n    }\\n\\n    if (statsToChange.manaRegen != 0) {\\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.MANA));\\n      result.manaRegen = max * statsToChange.manaRegen / 100;\\n    }\\n\\n    if (statsToChange.damage != 0) {\\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.LIFE));\\n      result.damage = max * statsToChange.damage / 100;\\n\\n      if (int32(context.heroStats.life) <= result.damage) {\\n        result.kill = true;\\n      }\\n    }\\n\\n    if (statsToChange.manaConsumed != 0) {\\n      int32 max = context.statController.heroAttribute(context.heroToken, context.heroTokenId, uint(IStatController.ATTRIBUTES.MANA));\\n      result.manaConsumed = CalcLib.minI32(max * statsToChange.manaConsumed / 100, int32(context.heroStats.mana));\\n    }\\n\\n    result.experience = statsToChange.experience;\\n    result.lifeChancesRecovered = statsToChange.lifeChancesRecovered;\\n\\n    if (mintItemsData.length != 0) {\\n      result.mintItems = mintItems_(context, mintItemsData);\\n    }\\n    return result;\\n  }\\n\\n  /// @notice Put data from {heroCustomDatas} and {globalCustomDatas} to {statController}\\n  function handleCustomDataResult(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32[] memory heroCustomDatas,\\n    bytes32[] memory globalCustomDatas\\n  ) internal {\\n    uint len = heroCustomDatas.length;\\n    for (uint i; i < len; ++i) {\\n\\n      (bytes32 customDataIndex, int16 value) = heroCustomDatas[i].unpackCustomDataChange();\\n\\n      if (customDataIndex != 0) {\\n        uint curValue = context.statController.heroCustomData(context.heroToken, context.heroTokenId, customDataIndex);\\n        context.statController.setHeroCustomData(\\n          context.heroToken,\\n          context.heroTokenId,\\n          customDataIndex,\\n          value == 0\\n            ? 0\\n            : value > 0\\n              ? curValue + uint(int(value))\\n              : curValue.minusWithZeroFloor(uint(int(- value)))\\n        );\\n      }\\n    }\\n\\n    len = globalCustomDatas.length;\\n    for (uint i; i < len; ++i) {\\n\\n      (bytes32 customDataIndex, int16 value) = globalCustomDatas[i].unpackCustomDataChange();\\n\\n      if (customDataIndex != 0) {\\n        uint curValue = context.statController.globalCustomData(customDataIndex);\\n        context.statController.setGlobalCustomData(\\n          customDataIndex,\\n          value == 0\\n            ? 0\\n            : value > 0\\n              ? curValue + uint(int(value))\\n              : curValue.minusWithZeroFloor(uint(int(- value)))\\n        );\\n      }\\n    }\\n  }\\n\\n  /// @notice Randomly select one or several burnItems and burn them\\n  function burn(IStoryController.StoryActionContext memory context, IStoryController.MainState storage s) internal {\\n\\n    bytes32[] storage burnInfos = s.burnItem[context.answerIdHash];\\n    uint length = burnInfos.length;\\n\\n    for (uint i; i < length; ++i) {\\n      (uint8 slot, uint64 chance, bool stopIfBurned) = burnInfos[i].unpackBurnInfo();\\n\\n      if (chance != 0 && context.oracle.getRandomNumberInRange(0, 100, 0) <= uint(chance)) {\\n        uint8[] memory busySlots = context.statController.heroItemSlots(context.heroToken, context.heroTokenId);\\n\\n        uint lenBusySlots = busySlots.length;\\n        if (lenBusySlots != 0) {\\n          uint busySlotIndex;\\n          bool itemExist;\\n          if (slot == 0) {\\n            busySlotIndex = context.oracle.getRandomNumberInRange(0, lenBusySlots - 1, 0);\\n            itemExist = true;\\n          } else {\\n            for (uint j; j < lenBusySlots; ++j) {\\n              if (busySlots[j] == slot) {\\n                busySlotIndex = j;\\n                itemExist = true;\\n                break;\\n              }\\n            }\\n          }\\n\\n          if (itemExist) {\\n            _burnItemInHeroSlot(context, busySlots[busySlotIndex]);\\n            if (stopIfBurned) {\\n              break;\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Update internal hero state, generate {result}\\n  /// @param context We update some fields in place, so memory, not calldata here\\n  function handleAnswer(\\n    IStoryController.AnswerResultId answerResultId,\\n    IStoryController.MainState storage s,\\n    IStoryController.StoryActionContext memory context\\n  ) external returns (\\n    IGOC.ActionResult memory result,\\n    uint16 nextPage,\\n    uint16[] memory nextPages\\n  ) {\\n    result.objectId = context.objectId;\\n    result.heroTokenId = context.heroTokenId;\\n    result.heroToken = context.heroToken;\\n\\n    nextPages = s.nextPageIds[context.storyId.packStoryNextPagesId(\\n      context.pageId,\\n      context.heroClassFromAnswerHash,\\n      context.answerNumber,\\n      uint8(answerResultId)\\n    )];\\n    nextPage = _getNextPage(context.oracle, nextPages);\\n\\n    if (answerResultId == IStoryController.AnswerResultId.SUCCESS) {\\n      result = handleResult(\\n        context,\\n        s.successInfoAttributes[context.answerIdHash],\\n        s.successInfoStats[context.answerIdHash],\\n        s.successInfoMintItems[context.answerIdHash],\\n        _mintRandomItems\\n      );\\n\\n      handleCustomDataResult(\\n        context,\\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\\n          context.pageId,\\n          context.heroClassFromAnswerHash,\\n          context.answerNumber,\\n          uint8(IStoryController.CustomDataResult.HERO_SUCCESS)\\n        )],\\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\\n          context.pageId,\\n          context.heroClassFromAnswerHash,\\n          context.answerNumber,\\n          uint8(IStoryController.CustomDataResult.GLOBAL_SUCCESS)\\n        )]\\n      );\\n    } else {\\n      result = handleResult(\\n        context,\\n        s.failInfoAttributes[context.answerIdHash],\\n        s.failInfoStats[context.answerIdHash],\\n        s.failInfoMintItems[context.answerIdHash],\\n        _mintRandomItems\\n      );\\n\\n      handleCustomDataResult(\\n        context,\\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\\n          context.pageId,\\n          context.heroClassFromAnswerHash,\\n          context.answerNumber,\\n          uint8(IStoryController.CustomDataResult.HERO_FAIL)\\n        )],\\n        s.customDataResult[context.storyId.packStoryCustomDataResult(\\n          context.pageId,\\n          context.heroClassFromAnswerHash,\\n          context.answerNumber,\\n          uint8(IStoryController.CustomDataResult.GLOBAL_FAIL)\\n        )]\\n      );\\n    }\\n  }\\n\\n  /// @notice Revert if {heroAnswers} doesn't contain {answerIdHash}\\n  function checkAnswerIndexValid(bytes32[] memory heroAnswers, bytes32 answerIdHash) internal pure {\\n    uint len = heroAnswers.length;\\n    for (uint i; i < len; ++i) {\\n      if (heroAnswers[i] == answerIdHash) return;\\n    }\\n    revert IAppErrors.NotAnswer();\\n  }\\n\\n  /// @notice Clear heroState for the give current story\\n  /// @return nextObjs Default nextObjectsRewrite for the current page (values for 0 hero class)\\n  function finishStory(IStoryController.StoryActionContext memory ctx, IStoryController.MainState storage s) internal returns (\\n    uint32[] memory nextObjs\\n  ) {\\n    delete s.heroState[ctx.heroToken.packStoryHeroStateId(ctx.heroTokenId, ctx.storyId)];\\n    return s.nextObjectsRewrite[ctx.storyId.packStoryPageId(ctx.pageId, 0)];\\n  }\\n\\n  //endregion ------------------------ Story logic\\n\\n  //region ------------------------ Internal utils for story logic\\n\\n  /// @dev This function is made separate to simplify unit testing\\n  function _mintRandomItems(IStoryController.StoryActionContext memory context, bytes32[] memory mintItemsData) internal returns (\\n    address[] memory\\n  ) {\\n    uint len = mintItemsData.length;\\n    address[] memory mintItems = new address[](len);\\n    uint32[] memory mintItemsChances = new uint32[](len);\\n    for (uint i; i < len; ++i) {\\n      (mintItems[i], mintItemsChances[i]) = mintItemsData[i].unpackItemMintInfo();\\n    }\\n\\n    return ItemLib.mintRandomItems(ItemLib.MintItemInfo({\\n      mintItems: mintItems,\\n      mintItemsChances: mintItemsChances,\\n      biome: context.biome,\\n      amplifier: 0,\\n      seed: 0,\\n      oracle: context.oracle,\\n      heroExp: context.heroStats.experience,\\n      heroCurrentLvl: uint8(context.heroStats.level),\\n      magicFind: 0,\\n      destroyItems: 0,\\n      maxItems: 1 // MINT ONLY 1 ITEM!\\n    }));\\n  }\\n\\n  /// @param attributesChanges Values+ids packed using toBytes32ArrayWithIds\\n  function _generateAttributes(bytes32[] memory attributesChanges) internal pure returns (int32[] memory attributes) {\\n    if (attributesChanges.length != 0) {\\n      (int32[] memory values, uint8[] memory ids) = attributesChanges.toInt32ArrayWithIds();\\n      uint len = ids.length;\\n      if (len != 0) {\\n        attributes = new int32[](uint(IStatController.ATTRIBUTES.END_SLOT));\\n        for (uint i; i < len; ++i) {\\n          int32 value = values[i];\\n          attributes[ids[i]] = value;\\n        }\\n      }\\n    }\\n\\n    return attributes;\\n  }\\n\\n  function _generateStats(bytes32 statsChanges) internal pure returns (IStoryController.StatsChange memory change) {\\n    (\\n      change.experience,\\n      change.heal,\\n      change.manaRegen,\\n      change.lifeChancesRecovered,\\n      change.damage,\\n      change.manaConsumed\\n    ) = statsChanges.unpackStatsChange();\\n\\n    return change;\\n  }\\n\\n  /// @notice Take off and destroy the item from the given {slot}\\n  function _burnItemInHeroSlot(IStoryController.StoryActionContext memory ctx, uint8 slot) internal {\\n    (address itemAdr, uint itemId) = ctx.statController.heroItemSlot(ctx.heroToken, uint64(ctx.heroTokenId), slot).unpackNftId();\\n\\n    ctx.itemController.takeOffDirectly(itemAdr, itemId, ctx.heroToken, ctx.heroTokenId, slot, address(this), false);\\n\\n    ctx.itemController.destroy(itemAdr, itemId);\\n\\n    emit IApplicationEvents.ItemBurned(\\n      ctx.heroToken,\\n      ctx.heroTokenId,\\n      ctx.dungeonId,\\n      ctx.objectId,\\n      itemAdr,\\n      itemId,\\n      ctx.stageId,\\n      ctx.iteration\\n    );\\n  }\\n\\n  function _getNextPage(IOracle oracle, uint16[] memory pages) internal returns (uint16) {\\n    if (pages.length == 0) {\\n      return 0;\\n    }\\n    if (pages.length == 1) {\\n      return pages[0];\\n    }\\n    return pages[oracle.getRandomNumberInRange(0, pages.length - 1, 0)];\\n  }\\n\\n  function _getStoryIndex(uint16 storyId) internal pure returns (bytes32) {\\n    return bytes32(abi.encodePacked(\\\"STORY_\\\", StringLib._toString(storyId)));\\n  }\\n  //endregion ------------------------ Internal utils for story logic\\n\\n  //region ------------------------ Check answers\\n\\n  function checkAnswer(\\n    IStoryController.StoryActionContext memory context,\\n    IStoryController.MainState storage s\\n  ) external returns (IStoryController.AnswerResultId result) {\\n    result = checkAnswerAttributes(context, context.answerIdHash, s);\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerItems(context, context.answerIdHash, s);\\n    }\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerTokens(context, context.answerIdHash, s);\\n    }\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerDelay(context);\\n    }\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerHeroCustomData(context, context.answerIdHash, s);\\n    }\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerGlobalCustomData(context, context.answerIdHash, s);\\n    }\\n    if (result == IStoryController.AnswerResultId.SUCCESS) {\\n      result = checkAnswerRandom(context);\\n    }\\n  }\\n\\n  /// @notice Check if hero attribute values meet attribute requirements for the given answer\\n  function checkAnswerAttributes(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32 answerIndex,\\n    IStoryController.MainState storage s\\n  ) internal view returns (IStoryController.AnswerResultId) {\\n    bytes32[] storage reqs = s.attributeRequirements[answerIndex];\\n    uint length = reqs.length;\\n\\n    for (uint i; i < length; ++i) {\\n      (uint8 attributeIndex, int32 value, bool isCore) = reqs[i].unpackStoryAttributeRequirement();\\n      if (isCore) {\\n        IStatController.CoreAttributes memory base = context.statController.heroBaseAttributes(context.heroToken, context.heroTokenId);\\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.STRENGTH) && base.strength < value) {\\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\\n        }\\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.DEXTERITY) && base.dexterity < value) {\\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\\n        }\\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.VITALITY) && base.vitality < value) {\\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\\n        }\\n        if (attributeIndex == uint8(IStatController.ATTRIBUTES.ENERGY) && base.energy < value) {\\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\\n        }\\n      } else {\\n        int32 attr = context.statController.heroAttribute(context.heroToken, context.heroTokenId, attributeIndex);\\n        if (attr < value) {\\n          return IStoryController.AnswerResultId.ATTRIBUTE_FAIL;\\n        }\\n      }\\n    }\\n\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  /// @notice Check item requirements for the given answer, check following issues:\\n  /// 1) For equipped item: check if it is on balance\\n  /// 2) For not equipped item: burn first owned item if requireItemBurn OR check that not equipped item is on balance\\n  function checkAnswerItems(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32 answerIndex,\\n    IStoryController.MainState storage s\\n  ) internal returns (IStoryController.AnswerResultId) {\\n\\n    bytes32[] storage reqs = s.itemRequirements[answerIndex];\\n    uint length = reqs.length;\\n\\n    for (uint i; i < length; ++i) {\\n      (address item, bool requireItemBurn, bool requireItemEquipped) = reqs[i].unpackStoryItemRequirement();\\n\\n      // equipped item is on balance of the heroToken, not on balance of the sender\\n      if (requireItemEquipped && IERC721Enumerable(item).balanceOf(context.heroToken) == 0) {\\n        revert IAppErrors.NotItem1();\\n      }\\n\\n      if (requireItemBurn) {\\n        _burnFirstOwnedItem(context, item);\\n      }\\n\\n      if (!requireItemEquipped && !requireItemBurn) {\\n        if (IERC721Enumerable(item).balanceOf(context.sender) == 0) revert IAppErrors.NotItem2();\\n      }\\n\\n    }\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  /// @notice burn first owned item and generate event\\n  /// @dev Use separate function to workaround stack too deep\\n  function _burnFirstOwnedItem(IStoryController.StoryActionContext memory context, address item) internal {\\n    uint itemId = IERC721Enumerable(item).tokenOfOwnerByIndex(context.sender, 0);\\n    context.itemController.destroy(item, itemId); // destroy reverts if the item is equipped\\n\\n    emit IApplicationEvents.NotEquippedItemBurned(\\n      context.heroToken,\\n      context.heroTokenId,\\n      context.dungeonId,\\n      context.storyId,\\n      item,\\n      itemId,\\n      context.stageId,\\n      context.iteration\\n    );\\n  }\\n\\n  /// @notice Ensure that the sender has enough amounts of the required tokens, send fees to the treasury\\n  function checkAnswerTokens(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32 answerIndex,\\n    IStoryController.MainState storage s\\n  ) internal returns (IStoryController.AnswerResultId) {\\n    bytes32[] memory reqs = s.tokenRequirements[answerIndex];\\n    uint length = reqs.length;\\n    for (uint i; i < length; ++i) {\\n      (address token, uint88 amount, bool requireTransfer) = reqs[i].unpackStoryTokenRequirement();\\n\\n      if (amount != 0) {\\n        uint balance = IERC20(token).balanceOf(context.sender);\\n        if (balance < uint(amount)) revert IAppErrors.NotEnoughAmount(balance, uint(amount));\\n\\n        if (requireTransfer) {\\n          address treasury = context.controller.treasury();\\n          IERC20(token).transferFrom(context.sender, address(this), uint(amount));\\n          IERC20(token).approve(treasury, type(uint).max);\\n          ITreasury(treasury).sendFee(token, uint(amount), IItemController.FeeType.STORY);\\n        }\\n      }\\n    }\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  /// @notice Generate error randomly\\n  function checkAnswerRandom(IStoryController.StoryActionContext memory context) internal returns (IStoryController.AnswerResultId) {\\n    (uint32 random,,) = context.answerAttributes.unpackStorySimpleRequirement();\\n\\n    if (random != 0 && random < 100) {\\n      if (context.oracle.getRandomNumber(100, 0) > uint(random)) {\\n        return IStoryController.AnswerResultId.RANDOM_FAIL;\\n      }\\n    } else if (random > 100) {\\n      revert IAppErrors.NotRandom(random);\\n    }\\n\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  /// @notice Ensure that the answer was given fast enough\\n  function checkAnswerDelay(IStoryController.StoryActionContext memory context) internal view returns (IStoryController.AnswerResultId) {\\n\\n    (,uint32 delay,) = context.answerAttributes.unpackStorySimpleRequirement();\\n\\n    if (delay != 0) {\\n      uint lastCall = uint(context.heroLastActionTS);\\n      if (lastCall != 0 && lastCall < block.timestamp && block.timestamp - lastCall > uint(delay)) {\\n        return IStoryController.AnswerResultId.DELAY_FAIL;\\n      }\\n    }\\n\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  function checkAnswerHeroCustomData(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32 answerIndex,\\n    IStoryController.MainState storage s\\n  ) internal view returns (IStoryController.AnswerResultId) {\\n    return _checkAnswerCustomData(context, s.heroCustomDataRequirement[answerIndex], true);\\n  }\\n\\n  function checkAnswerGlobalCustomData(\\n    IStoryController.StoryActionContext memory context,\\n    bytes32 answerIndex,\\n    IStoryController.MainState storage s\\n  ) internal view returns (IStoryController.AnswerResultId) {\\n    return _checkAnswerCustomData(context, s.globalCustomDataRequirement[answerIndex], false);\\n  }\\n\\n  function _checkAnswerCustomData(\\n    IStoryController.StoryActionContext memory context,\\n    IStoryController.CustomDataRequirementPacked[] memory datas,\\n    bool heroCustomData\\n  ) internal view returns (IStoryController.AnswerResultId) {\\n    uint len = datas.length;\\n    for (uint i; i < len; ++i) {\\n      IStoryController.CustomDataRequirementPacked memory data = datas[i];\\n\\n      if (data.index != 0) {\\n        (uint valueMin, uint valueMax, bool mandatory) = data.data.unpackCustomDataRequirements();\\n        uint heroValue = heroCustomData\\n          ? context.statController.heroCustomData(context.heroToken, context.heroTokenId, data.index)\\n          : context.statController.globalCustomData(data.index);\\n\\n        if (heroValue < valueMin || heroValue > valueMax) {\\n          if (mandatory) {\\n            if (heroCustomData) {\\n              revert IAppErrors.NotHeroData();\\n            } else {\\n              revert IAppErrors.NotGlobalData();\\n            }\\n          } else {\\n            return heroCustomData\\n              ? IStoryController.AnswerResultId.HERO_CUSTOM_DATA_FAIL\\n              : IStoryController.AnswerResultId.GLOBAL_CUSTOM_DATA_FAIL;\\n          }\\n        }\\n      }\\n    }\\n\\n    return IStoryController.AnswerResultId.SUCCESS;\\n  }\\n\\n  //endregion ------------------------ Check answers\\n}\\n\",\"keccak256\":\"0xd6a3be4bdec5b22eda3e108661f3950a9c88246a621d3a5211aa98b33cf0fa33\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StorySetupLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\nimport \\\"../interfaces/IStoryController.sol\\\";\\nimport \\\"../interfaces/IAppErrors.sol\\\";\\nimport \\\"../interfaces/IApplicationEvents.sol\\\";\\nimport \\\"../lib/PackingLib.sol\\\";\\nimport \\\"../lib/StatLib.sol\\\";\\n\\nlibrary StorySetupLib {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n  using PackingLib for bytes32;\\n  using PackingLib for uint16;\\n  using PackingLib for uint8;\\n  using PackingLib for address;\\n  using PackingLib for uint32[];\\n  using PackingLib for uint32;\\n  using PackingLib for uint64;\\n  using PackingLib for int32[];\\n  using PackingLib for int32;\\n\\n  //region ------------------ Data types\\n  struct RemoveStoryContext {\\n    uint8 heroClass;\\n    uint8 answerResultId;\\n    uint8 customDataResultId;\\n    uint16 storyId;\\n    uint16 pageId;\\n    uint16 answerNum;\\n    uint len;\\n    uint[] tmpPages;\\n    bytes32 answerId;\\n    bytes32[] tmpAnswers;\\n  }\\n  //endregion ------------------ Data types\\n\\n  //region ------------------ Set story fields\\n\\n  function setAllStoryFields(IStoryController.MainState storage s, IStoryController.StoryMetaInfo memory meta) external {\\n    setBurnItemsMeta(s, meta.storyId, meta.answerBurnRandomItemMeta);\\n    setNextObjRewriteMeta(s, meta.storyId, meta.nextObjRewriteMeta);\\n    setAnswersMeta(\\n      s,\\n      meta.storyId,\\n      meta.answersMeta.answerPageIds,\\n      meta.answersMeta.answerHeroClasses,\\n      meta.answersMeta.answerIds\\n    );\\n    setAnswerNextPageMeta(s, meta.storyId, meta.answerNextPage);\\n    setAnswerAttributeRequirements(s, meta.storyId, meta.answerAttributeRequirements);\\n    setAnswerItemRequirements(s, meta.storyId, meta.answerItemRequirements);\\n    setAnswerTokenRequirementsMeta(s, meta.storyId, meta.answerTokenRequirements);\\n    setAnswerAttributes(s, meta.storyId, meta.answerAttributes);\\n    setAnswerHeroCustomDataRequirementMeta(s, meta.storyId, meta.answerHeroCustomDataRequirement);\\n    setAnswerGlobalCustomDataRequirementMeta(s, meta.storyId, meta.answerGlobalCustomDataRequirement);\\n\\n    setSuccessInfo(s, meta.storyId, meta.successInfo);\\n    setFailInfo(s, meta.storyId, meta.failInfo);\\n\\n    setCustomDataResult(s, meta.storyId, meta.successHeroCustomData, IStoryController.CustomDataResult.HERO_SUCCESS);\\n    setCustomDataResult(s, meta.storyId, meta.failHeroCustomData, IStoryController.CustomDataResult.HERO_FAIL);\\n    setCustomDataResult(s, meta.storyId, meta.successGlobalCustomData, IStoryController.CustomDataResult.GLOBAL_SUCCESS);\\n    setCustomDataResult(s, meta.storyId, meta.failGlobalCustomData, IStoryController.CustomDataResult.GLOBAL_FAIL);\\n\\n    setStoryCustomDataRequirements(\\n      s,\\n      meta.storyId,\\n      meta.requiredCustomDataIndex,\\n      meta.requiredCustomDataMinValue,\\n      meta.requiredCustomDataMaxValue,\\n      meta.requiredCustomDataIsHero,\\n      meta.minLevel\\n    );\\n\\n  }\\n\\n  function setBurnItemsMeta(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    IStoryController.AnswerBurnRandomItemMeta memory meta\\n  ) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n\\n          bytes32[] storage answersBurn = s.burnItem[answerPackedId];\\n\\n          for (uint j; j < meta.slots[i].length; ++j) {\\n            bytes32 d = meta.slots[i][j].packBurnInfo(meta.chances[i][j], meta.isStopIfBurnt[i][j]);\\n            if (d != bytes32(0)) {\\n              answersBurn.push(d);\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetBurnItemsMeta(storyId, meta);\\n  }\\n\\n  function setNextObjRewriteMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.NextObjRewriteMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.nextObjPageIds.length;\\n      for (uint i; i < len; ++i) {\\n        registerPage(s, storyId, meta.nextObjPageIds[i]);\\n        bytes32 id = storyId.packStoryPageId(meta.nextObjPageIds[i], meta.nextObjHeroClasses[i]);\\n        s.nextObjectsRewrite[id] = meta.nextObjIds[i];\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetNextObjRewriteMeta(storyId, meta);\\n  }\\n\\n  function setAnswersMeta(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    uint16[] memory answerPageIds,\\n    uint8[] memory answerHeroClasses,\\n    uint16[] memory answerIds\\n  ) public {\\n    unchecked {\\n      uint len = answerPageIds.length;\\n      for (uint i; i < len; ++i) {\\n        registerPage(s, storyId, answerPageIds[i]);\\n\\n        bytes32[] storage answersHashes = s.answers[storyId.packStoryPageId(answerPageIds[i], answerHeroClasses[i])];\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, answerPageIds[i], answerHeroClasses[i], answerIds[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          answersHashes.push(answerPackedId);\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswersMeta(storyId, answerPageIds, answerHeroClasses, answerIds);\\n  }\\n\\n  function setAnswerNextPageMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerNextPageMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          bytes32 pagePackedId = storyId.packStoryNextPagesId(\\n            meta.pageId[i],\\n            meta.heroClass[i],\\n            meta.answerId[i],\\n            meta.answerResultIds[i]\\n          );\\n          // pagePackedId cannot be 0 here because answerPackedId is not 0\\n          s.nextPageIds[pagePackedId] = meta.answerNextPageIds[i];\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswerNextPageMeta(storyId, meta);\\n  }\\n\\n  function setAnswerAttributeRequirements(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerAttributeRequirementsMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          bytes32[] storage attrs = s.attributeRequirements[answerPackedId];\\n\\n          for (uint j; j < meta.cores[i].length; ++j) {\\n            bytes32 attributeRequirementsPacked = meta.ids[i][j].packStoryAttributeRequirement(\\n              meta.values[i][j],\\n              meta.cores[i][j]\\n            );\\n\\n            if (attributeRequirementsPacked != bytes32(0)) {\\n              attrs.push(attributeRequirementsPacked);\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswerAttributeRequirements(storyId, meta);\\n  }\\n\\n  function setAnswerItemRequirements(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerItemRequirementsMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          bytes32[] storage attrs = s.itemRequirements[answerPackedId];\\n\\n          for (uint j; j < meta.requireItems[i].length; ++j) {\\n            bytes32 d = meta.requireItems[i][j].packStoryItemRequirement(\\n              meta.requireItemBurn[i][j],\\n              meta.requireItemEquipped[i][j]);\\n\\n            if (d != bytes32(0)) {\\n              attrs.push(d);\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswerItemRequirements(storyId, meta);\\n  }\\n\\n  function setAnswerTokenRequirementsMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerTokenRequirementsMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          bytes32[] storage attrs = s.tokenRequirements[answerPackedId];\\n\\n          for (uint j; j < meta.requireToken[i].length; ++j) {\\n            bytes32 d = meta.requireToken[i][j].packStoryTokenRequirement(\\n              meta.requireAmount[i][j],\\n              meta.requireTransfer[i][j]\\n            );\\n            if (d != bytes32(0)) {\\n              attrs.push(d);\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswerTokenRequirementsMeta(storyId, meta);\\n  }\\n\\n  function setAnswerAttributes(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerAttributesMeta memory meta) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          bytes32 data = meta.randomRequirements[i].packStorySimpleRequirement(\\n            meta.delayRequirements[i],\\n            meta.isFinalAnswer[i]\\n          );\\n\\n          if (data != bytes32(0)) {\\n            s.answerAttributes[answerPackedId] = data;\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetAnswerAttributes(storyId, meta);\\n  }\\n\\n  function setAnswerHeroCustomDataRequirementMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerCustomDataMeta memory meta) public {\\n    _setCustomDataRequirementMeta(s, storyId, meta, s.heroCustomDataRequirement);\\n    emit IApplicationEvents.SetAnswerHeroCustomDataRequirementMeta(storyId, meta);\\n  }\\n\\n  function setAnswerGlobalCustomDataRequirementMeta(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerCustomDataMeta memory meta) public {\\n    _setCustomDataRequirementMeta(s, storyId, meta, s.globalCustomDataRequirement);\\n    emit IApplicationEvents.SetAnswerGlobalCustomDataRequirementMeta(storyId, meta);\\n  }\\n\\n  function setStoryCustomDataRequirements(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    bytes32[] memory requiredCustomDataIndex,\\n    uint64[] memory requiredCustomDataMinValue,\\n    uint64[] memory requiredCustomDataMaxValue,\\n    bool[] memory requiredCustomDataIsHero,\\n    uint minLevel\\n  ) public {\\n    s.storyRequiredLevel[storyId] = minLevel;\\n    emit IApplicationEvents.StoryRequiredLevel(storyId, minLevel);\\n\\n    IStoryController.CustomDataRequirementRangePacked[] storage allData = s.storyRequiredHeroData[storyId];\\n\\n    for (uint i; i < requiredCustomDataIndex.length; ++i) {\\n      allData.push(IStoryController.CustomDataRequirementRangePacked({\\n        index: requiredCustomDataIndex[i],\\n        data: requiredCustomDataMinValue[i].packCustomDataRequirements(\\n          requiredCustomDataMaxValue[i],\\n          requiredCustomDataIsHero[i]\\n        )\\n      }));\\n\\n      emit IApplicationEvents.StoryCustomDataRequirements(storyId, requiredCustomDataIndex[i], requiredCustomDataMinValue[i], requiredCustomDataMaxValue[i], requiredCustomDataIsHero[i]);\\n    }\\n  }\\n\\n  function setSuccessInfo(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerResultMeta memory meta) public {\\n    _setInfo(s, storyId, meta, s.successInfoAttributes, s.successInfoStats, s.successInfoMintItems);\\n    emit IApplicationEvents.SetSuccessInfo(storyId, meta);\\n  }\\n\\n  function setFailInfo(IStoryController.MainState storage s, uint16 storyId, IStoryController.AnswerResultMeta memory meta) public {\\n    _setInfo(s, storyId, meta, s.failInfoAttributes, s.failInfoStats, s.failInfoMintItems);\\n    emit IApplicationEvents.SetFailInfo(storyId, meta);\\n  }\\n\\n  function setCustomDataResult(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    IStoryController.AnswerCustomDataResultMeta memory meta,\\n    IStoryController.CustomDataResult type_\\n  ) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n        if (_registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]) != bytes32(0)) {\\n          bytes32 answerPackedIdWithType = storyId.packStoryCustomDataResult(\\n            meta.pageId[i],\\n            meta.heroClass[i],\\n            meta.answerId[i],\\n            uint8(type_)\\n          );\\n\\n          bytes32[] storage arr = s.customDataResult[answerPackedIdWithType];\\n          for (uint j; j < meta.dataIndexes[i].length; ++j) {\\n            arr.push(meta.dataIndexes[i][j].packCustomDataChange(meta.dataValues[i][j]));\\n          }\\n        }\\n      }\\n    }\\n\\n    emit IApplicationEvents.SetCustomDataResult(storyId, meta, type_);\\n  }\\n\\n  function finalizeStoryRegistration(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    uint32 objectId,\\n    uint buildHash\\n  ) external {\\n    // it's not necessary to remove previously stored data here\\n    // we assume, that old data is already removed completely before registering new data\\n\\n    s.registeredStories[objectId] = true;\\n    // store new used id\\n    s._usedStoryIds[storyId] = true;\\n    // register new id for story\\n    s.storyIds[objectId] = storyId;\\n    s.idToStory[storyId] = objectId;\\n    s.storyBuildHash[storyId] = buildHash;\\n\\n    emit IApplicationEvents.StoryFinalized(objectId, storyId);\\n  }\\n  //endregion ------------------ Set story fields\\n\\n  //region ------------------ Utils to set story fields\\n  function _registerAnswer(IStoryController.MainState storage s,  uint16 storyId, uint16 pageId, uint8 heroClass, uint16 answerId)\\n  internal returns (bytes32 answerPackedId) {\\n    answerPackedId = storyId.packStoryAnswerId(pageId, heroClass, answerId);\\n    if (answerPackedId != bytes32(0)) {\\n      registerAnswer(s, storyId, answerPackedId);\\n    }\\n  }\\n\\n  /// @param map Either heroCustomDataRequirement or globalCustomDataRequirement\\n  function _setCustomDataRequirementMeta(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    IStoryController.AnswerCustomDataMeta memory meta,\\n    mapping(bytes32 => IStoryController.CustomDataRequirementPacked[]) storage map\\n  ) internal {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          IStoryController.CustomDataRequirementPacked[] storage arr = map[answerPackedId];\\n\\n          bytes32[] memory dataIndexes = meta.dataIndexes[i];\\n          bool[] memory mandatory = meta.mandatory[i];\\n          uint64[] memory dataValuesMin = meta.dataValuesMin[i];\\n          uint64[] memory dataValuesMax = meta.dataValuesMax[i];\\n\\n          for (uint j; j < dataIndexes.length; ++j) {\\n            arr.push(\\n              IStoryController.CustomDataRequirementPacked({\\n                index: dataIndexes[j],\\n                data: dataValuesMin[j].packCustomDataRequirements(dataValuesMax[j], mandatory[j])\\n              })\\n            );\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  function _setInfo(\\n    IStoryController.MainState storage s,\\n    uint16 storyId,\\n    IStoryController.AnswerResultMeta memory meta,\\n    mapping(bytes32 => bytes32[]) storage infoAttributes,\\n    mapping(bytes32 => bytes32) storage infoStats,\\n    mapping(bytes32 => bytes32[]) storage infoMintItems\\n  ) public {\\n    unchecked {\\n      uint len = meta.pageId.length;\\n      for (uint i; i < len; ++i) {\\n\\n        bytes32 answerPackedId = _registerAnswer(s, storyId, meta.pageId[i], meta.heroClass[i], meta.answerId[i]);\\n        if (answerPackedId != bytes32(0)) {\\n          if (meta.attributeIds[i].length != 0) {\\n            infoAttributes[answerPackedId] = meta.attributeValues[i].toBytes32ArrayWithIds(meta.attributeIds[i]);\\n          }\\n\\n          bytes32 stats = PackingLib.packStatsChange(\\n            meta.experience[i],\\n            meta.heal[i],\\n            meta.manaRegen[i],\\n            meta.lifeChancesRecovered[i],\\n            meta.damage[i],\\n            meta.manaConsumed[i]\\n          );\\n          if (stats != bytes32(0)) {\\n            infoStats[answerPackedId] = stats;\\n          }\\n\\n          uint lenItems = meta.mintItems[i].length;\\n          if (lenItems != 0) {\\n            bytes32[] memory items = new bytes32[](lenItems);\\n            for (uint j; j < lenItems; ++j) {\\n              items[j] = meta.mintItems[i][j].packItemMintInfo(meta.mintItemsChances[i][j]);\\n            }\\n            infoMintItems[answerPackedId] = items;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  //endregion ------------------ Utils to set story fields\\n\\n  //region ------------------ Remove logic\\n  // WE MUST REMOVE ALL EXIST META!\\n  // otherwise we will still have meta for story id and will totally mess data\\n  function removeStory(IStoryController.MainState storage s, uint32 objectId) external {\\n    if (s.storyIds[objectId] == 0 || !s.registeredStories[objectId]) revert IAppErrors.ZeroStoryIdRemoveStory();\\n\\n    uint16 storyId = s.storyIds[objectId];\\n    delete s._usedStoryIds[storyId];\\n    delete s.storyIds[objectId];\\n    delete s.idToStory[storyId];\\n    delete s.registeredStories[objectId];\\n    delete s.storyBuildHash[storyId];\\n\\n    delete s.storyRequiredHeroData[storyId];\\n    delete s.storyRequiredLevel[storyId];\\n\\n\\n    emit IApplicationEvents.StoryRemoved(objectId, storyId);\\n  }\\n\\n  function removeStoryPagesMeta(IStoryController.MainState storage s, uint16 storyId, uint maxIterations) external {\\n    RemoveStoryContext memory ctx;\\n    ctx.storyId = storyId;\\n\\n    // --- clean all data related to pages ---\\n\\n    EnumerableSet.UintSet storage allPages = s.allStoryPages[ctx.storyId];\\n    ctx.len = allPages.length();\\n    if (ctx.len > maxIterations) {\\n      ctx.len = maxIterations;\\n    }\\n    ctx.tmpPages = new uint[](ctx.len);\\n\\n    for (uint i; i < ctx.len; ++i) {\\n      ctx.tmpPages[i] = allPages.at(i);\\n      ctx.pageId = uint16(ctx.tmpPages[i]);\\n\\n      // zero hero class means all classes\\n      for (ctx.heroClass = 0; ctx.heroClass < uint(StatLib.HeroClasses.END_SLOT); ++ctx.heroClass) {\\n        delete s.answers[ctx.storyId.packStoryPageId(ctx.pageId, ctx.heroClass)];\\n        delete s.nextObjectsRewrite[ctx.storyId.packStoryPageId(ctx.pageId, ctx.heroClass)];\\n      }\\n    }\\n\\n    // remove all pages\\n    for (uint i; i < ctx.tmpPages.length; ++i) {\\n      if (!allPages.remove(ctx.tmpPages[i])) {\\n        revert IAppErrors.PageNotRemovedError(ctx.tmpPages[i]);\\n      }\\n    }\\n  }\\n\\n  function removeStoryAnswersMeta(IStoryController.MainState storage s, uint16 storyId, uint maxIterations) external {\\n    RemoveStoryContext memory ctx;\\n    ctx.storyId = storyId;\\n\\n    // --- clean all data related to answers ---\\n\\n    EnumerableSet.Bytes32Set storage allAnswers = s.allStoryAnswers[ctx.storyId];\\n    ctx.len = allAnswers.length();\\n    if (ctx.len > maxIterations) {\\n      ctx.len = maxIterations;\\n    }\\n    ctx.tmpAnswers = new bytes32[](ctx.len);\\n\\n    for (uint i; i < ctx.len; ++i) {\\n      ctx.answerId = allAnswers.at(i);\\n      ctx.tmpAnswers[i] = ctx.answerId;\\n\\n      (, ctx.pageId, ctx.heroClass, ctx.answerNum) = ctx.answerId.unpackStoryAnswerId();\\n\\n      delete s.answerAttributes[ctx.answerId];\\n      delete s.attributeRequirements[ctx.answerId];\\n      delete s.itemRequirements[ctx.answerId];\\n      delete s.tokenRequirements[ctx.answerId];\\n      delete s.heroCustomDataRequirement[ctx.answerId];\\n      delete s.globalCustomDataRequirement[ctx.answerId];\\n      delete s.successInfoAttributes[ctx.answerId];\\n      delete s.successInfoStats[ctx.answerId];\\n      delete s.successInfoMintItems[ctx.answerId];\\n      delete s.failInfoAttributes[ctx.answerId];\\n      delete s.failInfoStats[ctx.answerId];\\n      delete s.failInfoMintItems[ctx.answerId];\\n      delete s.burnItem[ctx.answerId];\\n\\n      for (ctx.answerResultId = 0; ctx.answerResultId < uint(IStoryController.AnswerResultId.END_SLOT); ++ctx.answerResultId) {\\n        delete s.nextPageIds[ctx.storyId.packStoryNextPagesId(\\n          ctx.pageId,\\n          ctx.heroClass,\\n          ctx.answerNum,\\n          ctx.answerResultId\\n        )];\\n      }\\n\\n      // we assume here, that CustomDataResultId.UNKNOWN = 0 shouldn't be used, so we can skip delete for it\\n      for (ctx.customDataResultId = 1; ctx.customDataResultId < uint(IStoryController.CustomDataResult.END_SLOT); ++ctx.customDataResultId) {\\n        delete s.customDataResult[ctx.storyId.packStoryCustomDataResult(\\n          ctx.pageId,\\n          ctx.heroClass,\\n          ctx.answerNum,\\n          ctx.customDataResultId\\n        )];\\n      }\\n    }\\n\\n    // ATTENTION! need to remove items one by one from sets\\n\\n    // remove all answers\\n    for (uint i; i < ctx.tmpAnswers.length; ++i) {\\n      allAnswers.remove(ctx.tmpAnswers[i]);\\n    }\\n  }\\n  //endregion ------------------ Remove logic\\n\\n  //region ------------------ Utils\\n  function registerAnswer(IStoryController.MainState storage s, uint16 storyId, bytes32 answerId) internal {\\n    s.allStoryAnswers[storyId].add(answerId);\\n  }\\n\\n  function registerPage(IStoryController.MainState storage s, uint16 storyId, uint16 pageId) internal {\\n    s.allStoryPages[storyId].add(pageId);\\n  }\\n  //endregion ------------------ Utils\\n}\\n\",\"keccak256\":\"0xec4dff2a3d570f49724264847031a466fd2cec9a7843789b47615b2d6b8f66b1\",\"license\":\"BUSL-1.1\"},\"contracts/lib/StringLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.23;\\n\\n\\nlibrary StringLib {\\n\\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n  function toString(uint value) external pure returns (string memory) {\\n    return _toString(value);\\n  }\\n\\n  function _toString(uint value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint temp = value;\\n    uint digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  function toAsciiString(address x) external pure returns (string memory) {\\n    return _toAsciiString(x);\\n  }\\n\\n  function _toAsciiString(address x) internal pure returns (string memory) {\\n    bytes memory s = new bytes(40);\\n    for (uint i = 0; i < 20; i++) {\\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n      bytes1 hi = bytes1(uint8(b) / 16);\\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n      s[2 * i] = _char(hi);\\n      s[2 * i + 1] = _char(lo);\\n    }\\n    return string(s);\\n  }\\n\\n  function char(bytes1 b) external pure returns (bytes1 c) {\\n    return _char(b);\\n  }\\n\\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n    else return bytes1(uint8(b) + 0x57);\\n  }\\n\\n  function concat(string memory a, string memory b) internal pure returns (string memory) {\\n    return string(abi.encodePacked(a, b));\\n  }\\n\\n}\\n\",\"keccak256\":\"0xa101d62c068dae579dda1ffa392cbf2acd2fc29a99c2efbdf53349a587b084d6\",\"license\":\"BUSL-1.1\"},\"contracts/openzeppelin/ERC721Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n  /**\\n   * @dev See {IERC721Receiver-onERC721Received}.\\n   *\\n   * Always returns `IERC721Receiver.onERC721Received.selector`.\\n   */\\n  function onERC721Received(\\n    address,\\n    address,\\n    uint256,\\n    bytes memory\\n  ) public virtual override returns (bytes4) {\\n    return this.onERC721Received.selector;\\n  }\\n}\\n\",\"keccak256\":\"0xaf4708e1efc6a96ca12406877a82d66ea4bc82b71b26e982a70b0ce8755d8eed\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  // To implement this library for multiple types with as little code repetition as possible, we write it in\\n  // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\\n  // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\\n  // This means that we can only create new EnumerableMaps for types that fit in bytes32.\\n\\n  /**\\n   * @dev Query for a nonexistent map key.\\n     */\\n  error EnumerableMapNonexistentKey(bytes32 key);\\n\\n  struct Bytes32ToBytes32Map {\\n    // Storage of keys\\n    EnumerableSet.Bytes32Set _keys;\\n    mapping(bytes32 key => bytes32) _values;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n    map._values[key] = value;\\n    return map._keys.add(key);\\n  }\\n\\n  /**\\n   * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n    delete map._values[key];\\n    return map._keys.remove(key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n    return map._keys.contains(key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n    return map._keys.length();\\n  }\\n\\n  /**\\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n    bytes32 key = map._keys.at(index);\\n    return (key, map._values[key]);\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == bytes32(0)) {\\n      return (contains(map, key), bytes32(0));\\n    } else {\\n      return (true, value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n    bytes32 value = map._values[key];\\n    if (value == 0 && !contains(map, key)) {\\n      revert EnumerableMapNonexistentKey(key);\\n    }\\n    return value;\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n    return map._keys.values();\\n  }\\n\\n  // UintToUintMap\\n\\n  struct UintToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(key)));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintToAddressMap\\n\\n  struct UintToAddressMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n    return remove(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(key));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (uint256(key), address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n    return (success, address(uint160(uint256(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressToUintMap\\n\\n  struct AddressToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n    return remove(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n    return contains(map._inner, bytes32(uint256(uint160(key))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (address(uint160(uint256(key))), uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // Bytes32ToUintMap\\n\\n  struct Bytes32ToUintMap {\\n    Bytes32ToBytes32Map _inner;\\n  }\\n\\n  /**\\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n  function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n    return set(map._inner, key, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n    return remove(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns true if the key is in the map. O(1).\\n     */\\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n    return contains(map._inner, key);\\n  }\\n\\n  /**\\n   * @dev Returns the number of elements in the map. O(1).\\n     */\\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n    return length(map._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n    (bytes32 key, bytes32 value) = at(map._inner, index);\\n    return (key, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n    (bool success, bytes32 value) = tryGet(map._inner, key);\\n    return (success, uint256(value));\\n  }\\n\\n  /**\\n   * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n    return uint256(get(map._inner, key));\\n  }\\n\\n  /**\\n   * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = keys(map._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0x5052395b3d57e4347a977f96eba69188b4a952594afae411910995ecab5c1d05\",\"license\":\"MIT\"},\"contracts/openzeppelin/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position is the index of the value in the `values` array plus 1.\\n    // Position 0 is used to mean a value is not in the set.\\n    mapping(bytes32 value => uint256) _positions;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._positions[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We cache the value's position to prevent multiple reads from the same storage slot\\n    uint256 position = set._positions[value];\\n\\n    if (position != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 valueIndex = position - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (valueIndex != lastIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the lastValue to the index where the value to delete is\\n        set._values[valueIndex] = lastValue;\\n        // Update the tracked position of the lastValue (that was just moved)\\n        set._positions[lastValue] = position;\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the tracked position for the deleted slot\\n      delete set._positions[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._positions[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n     */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n     */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n     */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xd5483249a7bac53a40791ade8d640831cdec526eea6b42a4db68f2ce13c008fa\",\"license\":\"MIT\"},\"contracts/openzeppelin/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n  struct InitializableStorage {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n         */\\n    uint64 _initialized;\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n    bool _initializing;\\n  }\\n\\n  // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n  bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n  /**\\n   * @dev The contract is already initialized.\\n     */\\n  error InvalidInitialization();\\n\\n  /**\\n   * @dev The contract is not initializing.\\n     */\\n  error NotInitializing();\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n  event Initialized(uint64 version);\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier initializer() {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    // Cache values to avoid duplicated sloads\\n    bool isTopLevelCall = !$._initializing;\\n    uint64 initialized = $._initialized;\\n\\n    // Allowed calls:\\n    // - initialSetup: the contract is not in the initializing state and no previous version was\\n    //                 initialized\\n    // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n    //                 current contract is just being deployed\\n    bool initialSetup = initialized == 0 && isTopLevelCall;\\n    bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n    if (!initialSetup && !construction) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = 1;\\n    if (isTopLevelCall) {\\n      $._initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      $._initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier reinitializer(uint64 version) {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing || $._initialized >= version) {\\n      revert InvalidInitialization();\\n    }\\n    $._initialized = version;\\n    $._initializing = true;\\n    _;\\n    $._initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n  modifier onlyInitializing() {\\n    _checkInitializing();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n  function _checkInitializing() internal view virtual {\\n    if (!_isInitializing()) {\\n      revert NotInitializing();\\n    }\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n  function _disableInitializers() internal virtual {\\n    // solhint-disable-next-line var-name-mixedcase\\n    InitializableStorage storage $ = _getInitializableStorage();\\n\\n    if ($._initializing) {\\n      revert InvalidInitialization();\\n    }\\n    if ($._initialized != type(uint64).max) {\\n      $._initialized = type(uint64).max;\\n      emit Initialized(type(uint64).max);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n  function _getInitializedVersion() internal view returns (uint64) {\\n    return _getInitializableStorage()._initialized;\\n  }\\n\\n  /**\\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n  function _isInitializing() internal view returns (bool) {\\n    return _getInitializableStorage()._initializing;\\n  }\\n\\n  /**\\n   * @dev Returns a pointer to the storage namespace.\\n     */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n    assembly {\\n      $.slot := INITIALIZABLE_STORAGE\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x80aa3fc0fc9afdf84bd1a51716150cd13041f42d920a9afa8020ea41cf673809\",\"license\":\"MIT\"},\"contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n\\n  /**\\n    * @dev Muldiv operation overflow.\\n   */\\n  error MathOverflowedMulDiv();\\n\\n  enum Rounding {\\n    Floor, // Toward negative infinity\\n    Ceil, // Toward positive infinity\\n    Trunc, // Toward zero\\n    Expand // Away from zero\\n  }\\n\\n  /**\\n   * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      uint256 c = a + b;\\n      if (c < a) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b > a) return (false, 0);\\n      return (true, a - b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\\n     */\\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n      if (a == 0) return (true, 0);\\n      uint256 c = a * b;\\n      if (c / a != b) return (false, 0);\\n      return (true, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a / b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n    unchecked {\\n      if (b == 0) return (false, 0);\\n      return (true, a % b);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (b == 0) {\\n      // Guarantee the same behavior as in a regular Solidity division.\\n      return a / b;\\n    }\\n\\n    // The following calculation ensures accurate ceiling division without overflow.\\n    // Since a is non-zero, (a - 1) / b will not overflow.\\n    // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n    // but the largest value we can obtain is type(uint256).max - 1, which happens\\n    // when a = type(uint256).max and b = 1.\\n    unchecked {\\n      return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n    unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n      uint256 prod0 = x * y; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n      if (prod1 == 0) {\\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n        // The surrounding unchecked block does not change this fact.\\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n        return prod0 / denominator;\\n      }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n      if (denominator <= prod1) {\\n        revert MathOverflowedMulDiv();\\n      }\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n      uint256 remainder;\\n      assembly {\\n      // Compute remainder using mulmod.\\n        remainder := mulmod(x, y, denominator)\\n\\n      // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n    // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n      uint256 twos = denominator & (0 - denominator);\\n      assembly {\\n      // Divide denominator by twos.\\n        denominator := div(denominator, twos)\\n\\n      // Divide [prod1 prod0] by twos.\\n        prod0 := div(prod0, twos)\\n\\n      // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n\\n    // Shift in bits from prod1 into prod0.\\n      prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n      uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n    // works in modular arithmetic, doubling the correct bits in each step.\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n      result = prod0 * inverse;\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n    unchecked {\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      result = (result + a / result) >> 1;\\n      return min(result, a / result);\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = sqrt(a);\\n      return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 128;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 64;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 32;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 16;\\n      }\\n      if (value >> 8 > 0) {\\n        value >>= 8;\\n        result += 8;\\n      }\\n      if (value >> 4 > 0) {\\n        value >>= 4;\\n        result += 4;\\n      }\\n      if (value >> 2 > 0) {\\n        value >>= 2;\\n        result += 2;\\n      }\\n      if (value >> 1 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log2(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >= 10 ** 64) {\\n        value /= 10 ** 64;\\n        result += 64;\\n      }\\n      if (value >= 10 ** 32) {\\n        value /= 10 ** 32;\\n        result += 32;\\n      }\\n      if (value >= 10 ** 16) {\\n        value /= 10 ** 16;\\n        result += 16;\\n      }\\n      if (value >= 10 ** 8) {\\n        value /= 10 ** 8;\\n        result += 8;\\n      }\\n      if (value >= 10 ** 4) {\\n        value /= 10 ** 4;\\n        result += 4;\\n      }\\n      if (value >= 10 ** 2) {\\n        value /= 10 ** 2;\\n        result += 2;\\n      }\\n      if (value >= 10 ** 1) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log10(value);\\n      return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n    unchecked {\\n      if (value >> 128 > 0) {\\n        value >>= 128;\\n        result += 16;\\n      }\\n      if (value >> 64 > 0) {\\n        value >>= 64;\\n        result += 8;\\n      }\\n      if (value >> 32 > 0) {\\n        value >>= 32;\\n        result += 4;\\n      }\\n      if (value >> 16 > 0) {\\n        value >>= 16;\\n        result += 2;\\n      }\\n      if (value >> 8 > 0) {\\n        result += 1;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 result = log256(value);\\n      return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n  function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n    return uint8(rounding) % 2 == 1;\\n  }\\n\\n}\\n\",\"keccak256\":\"0x4d972e3e1d79f693b6cb42007d23c27256cb6f087392edea24b93585a822572c\",\"license\":\"MIT\"},\"contracts/proxy/Controllable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"../openzeppelin/Initializable.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../lib/SlotsLib.sol\\\";\\n\\n/// @title Implement basic functionality for any contract that require strict control\\n/// @dev Can be used with upgradeable pattern.\\n///      Require call __Controllable_init() in any case.\\n/// @author belbix\\nabstract contract Controllable is Initializable, IControllable {\\n  using SlotsLib for bytes32;\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant CONTROLLABLE_VERSION = \\\"1.0.0\\\";\\n\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.revision\\\")) - 1);\\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.prev_logic\\\")) - 1);\\n\\n  event ContractInitialized(address controller, uint ts, uint block);\\n  event RevisionIncreased(uint value, address oldLogic);\\n\\n  // init implementation contract\\n  constructor() initializer {}\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\n  /// @dev Use it only once after first logic setup\\n  /// @param controller_ Controller address\\n  function __Controllable_init(address controller_) internal onlyInitializing {\\n    _init(controller_);\\n  }\\n\\n  function _init(address controller_) private {\\n    require(controller_ != address(0), \\\"Zero controller\\\");\\n    _CONTROLLER_SLOT.set(controller_);\\n    _CREATED_SLOT.set(block.timestamp);\\n    _CREATED_BLOCK_SLOT.set(block.number);\\n    emit ContractInitialized(controller_, block.timestamp, block.number);\\n  }\\n\\n  /// @dev Return true if given address is controller\\n  function isController(address value_) public override view returns (bool) {\\n    return value_ == controller();\\n  }\\n\\n  /// @notice Return true if given address is setup as governance in Controller\\n  function isGovernance(address value_) public override view returns (bool) {\\n    return IController(controller()).governance() == value_;\\n  }\\n\\n  /// @dev Contract upgrade counter\\n  function revision() external view override returns (uint) {\\n    return _REVISION_SLOT.getUint();\\n  }\\n\\n  /// @dev Previous logic implementation\\n  function previousImplementation() external view override returns (address) {\\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\\n  }\\n\\n  // ************* SETTERS/GETTERS *******************\\n\\n  /// @notice Return controller address saved in the contract slot\\n  function controller() public view override returns (address) {\\n    return _CONTROLLER_SLOT.getAddress();\\n  }\\n\\n  /// @notice Return creation timestamp\\n  /// @return Creation timestamp\\n  function created() external view override returns (uint256) {\\n    return _CREATED_SLOT.getUint();\\n  }\\n\\n  /// @notice Return creation block number\\n  /// @return Creation block number\\n  function createdBlock() external override view returns (uint256) {\\n    return _CREATED_BLOCK_SLOT.getUint();\\n  }\\n\\n  /// @dev Revision should be increased on each contract upgrade\\n  function increaseRevision(address oldLogic) external override {\\n    require(msg.sender == address(this), \\\"Increase revision forbidden\\\");\\n    uint r = _REVISION_SLOT.getUint() + 1;\\n    _REVISION_SLOT.set(r);\\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\\n    emit RevisionIncreased(r, oldLogic);\\n  }\\n\\n}\\n\",\"keccak256\":\"0x1edc53f0d11834bebf4485746d04112ed10db9d4cb19b4945362c593ebf97daf\",\"license\":\"BUSL-1.1\"},\"contracts/solady/LibPRNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for generating pseudorandom numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\\n/// @author LazyShuffler based on NextShuffler by aschlosberg (divergencearran)\\n/// (https://github.com/divergencetech/ethier/blob/main/contracts/random/NextShuffler.sol)\\nlibrary LibPRNG {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The initial length must be greater than zero and less than `2**32 - 1`.\\n    error InvalidInitialLazyShufflerLength();\\n\\n    /// @dev The new length must not be less than the current length.\\n    error InvalidNewLazyShufflerLength();\\n\\n    /// @dev The lazy shuffler has not been initialized.\\n    error LazyShufflerNotInitialized();\\n\\n    /// @dev Cannot double initialize the lazy shuffler.\\n    error LazyShufflerAlreadyInitialized();\\n\\n    /// @dev The lazy shuffle has finished.\\n    error LazyShuffleFinished();\\n\\n    /// @dev The queried index is out of bounds.\\n    error LazyShufflerGetOutOfBounds();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev A pseudorandom number state in memory.\\n    struct PRNG {\\n        uint256 state;\\n    }\\n\\n    /// @dev A lazy Fisher-Yates shuffler for a range `[0..n)` in storage.\\n    struct LazyShuffler {\\n        // Bits Layout:\\n        // - [0..31]    `numShuffled`\\n        // - [32..223]  `permutationSlot`\\n        // - [224..255] `length`\\n        uint256 _state;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Seeds the `prng` with `state`.\\n    function seed(PRNG memory prng, uint256 state) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(prng, state)\\n        }\\n    }\\n\\n    /// @dev Returns the next pseudorandom uint256.\\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\\n        // We simply use `keccak256` for a great balance between\\n        // runtime gas costs, bytecode size, and statistical properties.\\n        //\\n        // A high-quality LCG with a 32-byte state\\n        // is only about 30% more gas efficient during runtime,\\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\\n        // when this function is inlined.\\n        //\\n        // Using this method is about 2x more efficient than\\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n        }\\n    }\\n\\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\\n    /// between 0 (inclusive) and `upper` (exclusive).\\n    /// If your modulus is big, this method is recommended\\n    /// for uniform sampling to avoid modulo bias.\\n    /// For uniform sampling across all uint256 values,\\n    /// or for small enough moduli such that the bias is neligible,\\n    /// use {next} instead.\\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := keccak256(prng, 0x20)\\n                mstore(prng, result)\\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\\n            }\\n            result := mod(result, upper)\\n        }\\n    }\\n\\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n\\n                    {\\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                let b := add(a, 0x01)\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let o := mod(shr(128, r), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n\\n                    {\\n                        let o := mod(and(r, mask), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the standard normal distribution denominated in `WAD`.\\n    function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\\n            // The chance of drawing a sample outside 10 \\u03c3 from the standard normal distribution\\n            // is \\u2248 0.000000000000000000000015, which is insignificant for most practical purposes.\\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\\n            let s := 0x1000000000000000100000000000000010000000000000001\\n            let r1 := mulmod(result, a, n)\\n            let r2 := mulmod(r1, a, n)\\n            let r3 := mulmod(r2, a, n)\\n            // forgefmt: disable-next-item\\n            result := sub(sar(96, mul(26614938895861601847173011183,\\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\\n        }\\n    }\\n\\n    /// @dev Returns a sample from the unit exponential distribution denominated in `WAD`.\\n    function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\\n            // Gas usage varies, starting from about 172+ gas.\\n            let r := keccak256(prng, 0x20)\\n            mstore(prng, r)\\n            let p := shl(129, r)\\n            let w := shl(1, r)\\n            if iszero(gt(w, p)) {\\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\\n                for {} 1 {} {\\n                    r := mulmod(r, a, n)\\n                    if iszero(lt(shl(129, r), w)) {\\n                        r := mulmod(r, a, n)\\n                        result := add(1000000000000000000, result)\\n                        w := shl(1, r)\\n                        p := shl(129, r)\\n                        if iszero(lt(w, p)) { break }\\n                        continue\\n                    }\\n                    w := shl(1, r)\\n                    if iszero(lt(w, shl(129, r))) { break }\\n                }\\n            }\\n            result := add(div(p, shl(129, 170141183460469231732)), result)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*       STORAGE-BASED RANGE LAZY SHUFFLING OPERATIONS        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Initializes the state for lazy-shuffling the range `[0..n)`.\\n    /// Reverts if `n == 0 || n >= 2**32 - 1`.\\n    /// Reverts if `$` has already been initialized.\\n    /// If you need to reduce the length after initialization, just use a fresh new `$`.\\n    function initialize(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sload($.slot) {\\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, $.slot)\\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Increases the length of `$`.\\n    /// Reverts if `$` has not been initialized.\\n    function grow(LazyShuffler storage $, uint256 n) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            // If the new length is smaller than the old length, revert.\\n            if lt(n, shr(224, state)) {\\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\\n        }\\n    }\\n\\n    /// @dev Restarts the shuffler by setting `numShuffled` to zero,\\n    /// such that all elements can be drawn again.\\n    /// Restarting does NOT clear the internal permutation, nor changes the length.\\n    /// Even with the same sequence of randomness, reshuffling can yield different results.\\n    function restart(LazyShuffler storage $) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot)\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore($.slot, shl(32, shr(32, state)))\\n        }\\n    }\\n\\n    /// @dev Returns the number of elements that have been shuffled.\\n    function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := and(0xffffffff, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns the length of `$`.\\n    /// Returns zero if `$` is not initialized, else a non-zero value less than `2**32 - 1`.\\n    function length(LazyShuffler storage $) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := shr(224, sload($.slot))\\n        }\\n    }\\n\\n    /// @dev Returns if `$` has been initialized.\\n    function initialized(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(iszero(sload($.slot)))\\n        }\\n    }\\n\\n    /// @dev Returns if there are any more elements left to shuffle.\\n    /// Reverts if `$` is not initialized.\\n    function finished(LazyShuffler storage $) internal view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            if iszero(state) {\\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := eq(shr(224, state), and(0xffffffff, state))\\n        }\\n    }\\n\\n    /// @dev Returns the current value stored at `index`, accounting for all historical shuffling.\\n    /// Reverts if `index` is greater than or equal to the `length` of `$`.\\n    function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let state := sload($.slot) // The packed value at `$`.\\n            let n := shr(224, state) // Length of `$`.\\n            if iszero(lt(index, n)) {\\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let u32 := gt(n, 0xfffe)\\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\\n            result := and(m, shr(o, sload(s)))\\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\\n        }\\n    }\\n\\n    /// @dev Does a single Fisher-Yates shuffle step, increments the `numShuffled` in `$`,\\n    /// and returns the next value in the shuffled range.\\n    /// `randomness` can be taken from a good-enough source, or a higher quality source like VRF.\\n    /// Reverts if there are no more values to shuffle, which includes the case if `$` is not initialized.\\n    function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function _get(u32_, state_, i_) -> _value {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                _value := and(m_, shr(o_, sload(s_)))\\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\\n            }\\n            function _set(u32_, state_, i_, value_) {\\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\\n                let v_ := sload(s_) // Bucket slot value.\\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\\n            }\\n            let state := sload($.slot) // The packed value at `$`.\\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\\n            let n := shr(224, state) // Length of `$`.\\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\\n            if iszero(remainder) {\\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\\n            chosen := _get(gt(n, 0xfffe), state, index)\\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdcb71f8dc72bb7384776154ca24d34c23e3c9bcf124bc75f0d2e379f9ebd021d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b507ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00805468010000000000000000810460ff1615906001600160401b03166000811580156200005d5750825b90506000826001600160401b031660011480156200007a5750303b155b90508115801562000089575080155b15620000a85760405163f92ee8a960e01b815260040160405180910390fd5b84546001600160401b03191660011785558315620000d757845460ff60401b1916680100000000000000001785555b83156200011e57845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505061547080620001336000396000f3fe608060405234801561001057600080fd5b50600436106102295760003560e01c80637cc9638011610131578063cb90acc0116100b3578063cb90acc014610500578063d02a74a414610513578063d6dd327314610526578063dce9127214610539578063dee1f0e41461054c578063e08868ae1461055f578063e893564714610572578063ef76796114610592578063f660b274146105a5578063f77c4791146105b8578063ffa1ad74146105c057600080fd5b80637cc963801461041a5780637f9e78a21461042257806384ff97d414610435578063889700641461044857806392b6c5cf1461045b578063936725ec1461046e5780639d0bcca01461049f578063aa1293d9146104b4578063ac62e9f9146104c7578063b429afeb146104da578063bc982d2b146104ed57600080fd5b80631c1b0daa116101ba5780631c1b0daa1461032a578063325a19f11461034a5780633ed2f89a146103525780634593144c1461036557806349a8ccd51461036d5780634fac6ccd14610393578063509a093f146103a6578063656218ff146103ce5780636eee5afe146103e157806373aeb392146103f4578063788a2d2e1461040757600080fd5b806305f922391461022e5780630c0e97dd146102435780630cac0c1f1461025657806312a554ec14610269578063150b7a021461028f578063152f74f0146102bb57806318daea98146102de57806319ab453c146102f15780631a94214a146103045780631aab826a14610317575b600080fd5b61024161023c366004612cf4565b6105e4565b005b610241610251366004612d49565b6105f8565b610241610264366004612de3565b61060e565b61027c610277366004612ec3565b610634565b6040519081526020015b60405180910390f35b6102a261029d366004612fd3565b610645565b6040516001600160e01b03199091168152602001610286565b6102ce6102c936600461303e565b610656565b6040519015158152602001610286565b61027c6102ec366004612ec3565b61066b565b6102416102ff36600461307f565b610676565b61024161031236600461309c565b610770565b6102416103253660046130c8565b610782565b61033d610338366004613144565b610794565b6040516102869190613282565b61027c6107c3565b6102ce610360366004612cf4565b6107fc565b61027c610807565b61038061037b366004612cf4565b610837565b60405161ffff9091168152602001610286565b6102416103a136600461307f565b610842565b6103b96103b4366004612ec3565b610953565b60405163ffffffff9091168152602001610286565b6102416103dc366004612d49565b61095e565b61027c6103ef366004612ec3565b610970565b6102416104023660046133c9565b61097b565b61027c61041536600461309c565b610993565b61027c6109a6565b610241610430366004613430565b6109c4565b61024161044336600461347c565b6109d6565b61024161045636600461309c565b6109f6565b61038061046936600461353f565b610a08565b610492604051806040016040528060058152602001640312e302e360dc1b81525081565b604051610286919061357d565b6104a7610a15565b60405161028691906135cc565b6102416104c23660046135e0565b610a45565b6102416104d536600461362b565b610a57565b6102ce6104e836600461307f565b610a69565b6102416104fb366004612d49565b610a8e565b61024161050e366004613670565b610aa0565b610241610521366004612d49565b610ab3565b6102416105343660046136a0565b610ac5565b6102416105473660046130c8565b610ad6565b6102ce61055a36600461307f565b610ae8565b61027c61056d36600461309c565b610b6d565b6105856105803660046136db565b610b79565b6040516102869190613722565b6102416105a0366004612d49565b610b8e565b6102416105b3366004613430565b610ba0565b6104a7610bb2565b61049260405180604001604052806005815260200164322e312e3160d81b81525081565b6105f56105ef610bb2565b82610be2565b50565b61060a610603610bb2565b8383610c65565b5050565b610628610619610bb2565b8b8b8b8b8b8b8b8b8b8b610cdc565b50505050505050505050565b600061063f82610d74565b92915050565b630a85bd0160e11b5b949350505050565b600061064e610663610bb2565b858585610d9d565b600061063f82610e44565b6000610680610e6d565b805490915060ff600160401b82041615906001600160401b03166000811580156106a75750825b90506000826001600160401b031660011480156106c35750303b155b9050811580156106d1575080155b156106ef5760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff19166001178555831561071957845460ff60401b1916600160401b1785555b61072286610e91565b831561076857845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b61060a61077b610bb2565b8383610ea2565b61060a61078d610bb2565b8383610f02565b61079c612c6c565b6107b56107a7610bb2565b8b8b8b8b8b8b8b8b8b610f4d565b9a9950505050505050505050565b60006107f76107f360017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b61377c565b5490565b905090565b600061063f826114b7565b60006107f76107f360017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f161377c565b600061063f826114e3565b3330146108945760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b60006108b26107f3600160008051602061541b83398151915261377c565b6108bd90600161378f565b90506108df816108dc600160008051602061541b83398151915261377c565b55565b61090e826108dc60017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e461377c565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c8910160405180910390a15050565b600061063f8261150d565b61060a610969610bb2565b838361153a565b600061063f82611585565b61098e610986610bb2565b8484846115ac565b505050565b600061099f838361162f565b9392505050565b60006107f76107f3600160008051602061541b83398151915261377c565b61060a6109cf610bb2565b838361165a565b6109ed6109e1610bb2565b888888888888886116a5565b50505050505050565b61060a610a01610bb2565b8383611734565b600061064e84848461175f565b60006107f76107f360017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e461377c565b61060a610a50610bb2565b838361178e565b61060a610a62610bb2565b83836117d9565b6000610a73610bb2565b6001600160a01b0316826001600160a01b0316149050919050565b61060a610a99610bb2565b8383611824565b61098e610aab610bb2565b84848461186f565b61060a610abe610bb2565b83836118db565b6105f5610ad0610bb2565b82611926565b61060a610ae1610bb2565b838361196f565b6000816001600160a01b0316610afc610bb2565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b39573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b5d91906137ad565b6001600160a01b03161492915050565b600061099f838361199a565b606061064e610b86610bb2565b8585856119c5565b61060a610b99610bb2565b8383611c84565b61060a610bab610bb2565b8383611ccf565b60006107f76107f360017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c361861377c565b610beb82611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC963a913674b610c0d611d86565b6040516001600160e01b031960e084901b168152600481019190915263ffffffff841660248201526044015b60006040518083038186803b158015610c5157600080fd5b505af4158015610768573d6000803e3d6000fd5b610c6e83611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC963a84d660c610c90611d86565b84846040518463ffffffff1660e01b8152600401610cb093929190613ae9565b60006040518083038186803b158015610cc857600080fd5b505af41580156109ed573d6000803e3d6000fd5b610ce58b611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC963ca473936610d07611d86565b8c8c8c8c8c8c8c8c8c8c6040518c63ffffffff1660e01b8152600401610d379b9a99989796959493929190613b7a565b60006040518083038186803b158015610d4f57600080fd5b505af4158015610d63573d6000803e3d6000fd5b505050505050505050505050505050565b600061063f610d81611d86565b61ffff8416600090815260049190910160205260409020611daa565b6000610e3b610daa611d86565b610db2611d86565b63ffffffff871660009081526020918252604090819020548151628e969160e01b8152915161ffff90911692889288926001600160a01b038d1692628e969192600480820193918290030181865afa158015610e12573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e3691906137ad565b611db4565b95945050505050565b600061063f610e51611d86565b61ffff8416600090815260059190910160205260409020611daa565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b610e99612037565b6105f58161205e565b610eab83611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC9633e8dd868610ecd611d86565b6040516001600160e01b031960e084901b168152600481019190915261ffff8516602482015260448101849052606401610cb0565b610f0b83611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC96301c7664c610f2d611d86565b84846040518463ffffffff1660e01b8152600401610cb093929190613d91565b610f55612c6c565b336001600160a01b03168b6001600160a01b03166389dd9f136040518163ffffffff1660e01b8152600401602060405180830381865afa158015610f9d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fc191906137ad565b6001600160a01b031614610fea57336040516309f23ad160e41b815260040161088b91906135cc565b60008b6001600160a01b0316628e96916040518163ffffffff1660e01b8152600401602060405180830381865afa158015611029573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061104d91906137ad565b905060006040518061030001604052808a815260200186815260200161107286612171565b81526020016000801b81526020018d6001600160a01b03168152602001896001600160a01b031681526020018e6001600160a01b03168152602001836001600160a01b031681526020018e6001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156110fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061111e91906137ad565b6001600160a01b031681526020018e6001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa15801561116a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061118e91906137ad565b6001600160a01b031681526020018e6001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111fe91906137ad565b6001600160a01b03168152600060208201819052604082015260ff8816606082015260800161122b611d86565b63ffffffff8d166000818152602092835260408082205461ffff168552928401819052838301819052606084018190526080840181905260a08401919091526001600160401b038f1660c084015260e08301526001600160501b038a1661010083015251631a95890960e31b8152610120909101906001600160a01b0385169063d4ac4848906112c1908d908d90600401613db4565b60a060405180830381865afa1580156112de573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113029190613dd8565b8152509050806101c0015161ffff16600003611331576040516326358d7f60e21b815260040160405180910390fd5b8061010001516001600160a01b0316631789b7b1896040518263ffffffff1660e01b815260040161136291906135cc565b602060405180830381865afa15801561137f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113a39190613e6f565b60ff166101608201526113b4611d86565b6040808301516000908152600992909201602052902054606082015261141b6113db611d86565b60190160006114038a856101c001518d6001600160a01b03166121879092919063ffffffff16565b81526020019081526020016000205490601082901c90565b64ffffffffff166102a083015261ffff166102408201526040810151601081901c602082901c602883901c846101e0018561020001866101800187610220018461ffff1661ffff168152508460ff1660ff168152508461ffff1661ffff168152508461ffff1661ffff16815250505050506114a6816114a18f846101c001518c8c6119c5565b6121ba565b9d9c50505050505050505050505050565b60006114c1611d86565b63ffffffff909216600090815260039290920160205250604090205460ff1690565b60006114ed611d86565b63ffffffff909216600090815260209290925250604090205461ffff1690565b6000611517611d86565b61ffff909216600090815260019290920160205250604090205463ffffffff1690565b61154383611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC96356814190611565611d86565b84846040518463ffffffff1660e01b8152600401610cb09392919061406e565b600061158f611d86565b61ffff9092166000908152601a9290920160205250604090205490565b6115b584611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC9630324a18c6115d7611d86565b8585856040518563ffffffff1660e01b81526004016115f994939291906141d1565b60006040518083038186803b15801561161157600080fd5b505af4158015611625573d6000803e3d6000fd5b5050505050505050565b600061099f8261163d611d86565b61ffff861660009081526004919091016020526040902090612481565b61166383611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC963b5083ab9611685611d86565b84846040518463ffffffff1660e01b8152600401610cb09392919061447c565b6116ae88611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC96301c3192f6116d0611d86565b898989898989896040518963ffffffff1660e01b81526004016116fa9897969594939291906144d8565b60006040518083038186803b15801561171257600080fd5b505af4158015611726573d6000803e3d6000fd5b505050505050505050505050565b61173d83611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC963b5287c91610ecd611d86565b600061178561176c611d86565b60190160006114036001600160a01b0388168787612187565b50949350505050565b61179783611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC963d335b7f36117b9611d86565b84846040518463ffffffff1660e01b8152600401610cb0939291906145b2565b6117e283611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC9638cd5642c611804611d86565b84846040518463ffffffff1660e01b8152600401610cb0939291906146c4565b61182d83611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC963679dde4c61184f611d86565b84846040518463ffffffff1660e01b8152600401610cb0939291906147b8565b61187884611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC9631c9a900861189a611d86565b6040516001600160e01b031960e084901b168152600481019190915261ffff8616602482015263ffffffff85166044820152606481018490526084016115f9565b6118e483611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC9636b6cc9f8611906611d86565b84846040518463ffffffff1660e01b8152600401610cb0939291906148ac565b61192f82611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC9639c9dc579611951611d86565b836040518363ffffffff1660e01b8152600401610c39929190614a59565b61197883611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC963cbbefc28610f2d611d86565b600061099f826119a8611d86565b61ffff861660009081526005919091016020526040902090612481565b60606000856001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a07573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a2b91906137ad565b90506000611a53611a3a611d86565b60190160006114036001600160a01b038916888b612187565b5090506000611a60611d86565b6006016000611ae284866001600160a01b0316631789b7b18b6040518263ffffffff1660e01b8152600401611a9591906135cc565b602060405180830381865afa158015611ab2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ad69190613e6f565b61ffff8c16919061248d565b8152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015611b3a57602002820191906000526020600020905b815481526020019060010190808311611b26575b505050505090508051600003611bc657611b52611d86565b6006016000611b6661ffff8a16858361248d565b8152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015611bbe57602002820191906000526020600020905b815481526020019060010190808311611baa575b505050505090505b805115611c795760005b60018251611bde919061377c565b811015611c77576000611bfe8260018551611bf9919061377c565b6124b2565b9050828281518110611c1257611c12614d9b565b6020026020010151838281518110611c2c57611c2c614d9b565b6020026020010151848381518110611c4657611c46614d9b565b60200260200101858581518110611c5f57611c5f614d9b565b60209081029190910101919091525250600101611bd0565b505b979650505050505050565b611c8d83611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC963c5828ff1611caf611d86565b84846040518463ffffffff1660e01b8152600401610cb093929190614db1565b611cd883611cfa565b731d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC963751dda43611685611d86565b604051631430d62960e21b81526001600160a01b038216906350c358a490611d269033906004016135cc565b602060405180830381865afa158015611d43573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d679190614ddf565b6105f5573360405163451cea1760e11b815260040161088b91906135cc565b7f1fbca2ab9841348cca3f2687c48325e9989a76ad929b9970d1c11e233677cf0090565b600061063f825490565b61ffff841660009081526018860160205260408120548015801590611e4e5750604051631a95890960e31b815281906001600160a01b0385169063d4ac484890611e049089908990600401613db4565b60a060405180830381865afa158015611e21573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e459190613dd8565b5163ffffffff16105b15611e5d576000915050610e3b565b61ffff861660009081526017880160205260408120805490915b81811015612027576000838281548110611e9357611e93614d9b565b6000918252602091829020604080518082019091526002909202018054808352600190910154928201929092529150611ecc575061201f565b6000806000611eee846020015190604082901c90608083901c60ff1660011490565b925092509250600081611f6c578451604051630a82c86160e01b815260048101919091526001600160a01b038c1690630a82c86190602401602060405180830381865afa158015611f43573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f679190614dfc565b611fe1565b8a6001600160a01b0316631c2aafe78e8e88600001516040518463ffffffff1660e01b8152600401611fa093929190614e15565b602060405180830381865afa158015611fbd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611fe19190614dfc565b9050836001600160401b03168110806120025750826001600160401b031681115b156120195760009950505050505050505050610e3b565b50505050505b600101611e77565b5060019998505050505050505050565b61203f6124e2565b61205c57604051631afcd79f60e31b815260040160405180910390fd5b565b6001600160a01b0381166120a65760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b604482015260640161088b565b6120d5816108dc60017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c361861377c565b612104426108dc60017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b61377c565b612133436108dc60017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f161377c565b7f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe23671342681424360405161216693929190614e15565b60405180910390a150565b60008180602001905181019061063f9190614dfc565b6001600160a01b039290921660a09190911b600160a01b600160f01b03161760f09190911b6001600160f01b0319161790565b6121c2612c6c565b60006121cc611d86565b9050825160000361221d5761026084015163ffffffff166101208301526102c08401516001600160501b031661016083015260a08401516001600160a01b031660408301526001602083015261245f565b836101e0015161ffff16846101c0015161ffff1614612269576101c08401516101e0850151604051636df9cb0960e11b815261ffff92831660048201529116602482015260440161088b565b83610200015161ffff1684610240015161ffff16146122b5576102408401516102008501516040516364f16ac560e01b815261ffff92831660048201529116602482015260440161088b565b6122c38385604001516124fc565b60608401516040805163be03c0c360e01b815291901c60ff166001149060009073caC54849A53d23393C0212a937dEA42f402E99b59063be03c0c39061230f9089908790600401614ff3565b602060405180830381865af415801561232c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123509190615010565b905061235c8684612551565b6000606073caC54849A53d23393C0212a937dEA42f402E99b563341bebc884878b6040518463ffffffff1660e01b815260040161239b93929190615031565b600060405180830381865af41580156123b8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526123e091908101906151dd565b9197509250905083806123f257508051155b15612403576001602087015261245a565b4260101b66ffffffffff00001661ffff8316178560190160006124488b6102c001518c6101c001518d60a001516001600160a01b03166121879092919063ffffffff16565b81526020810191909152604001600020555b505050505b81602001511561247a57612473848261284a565b6101a08301525b5092915050565b600061099f838361294b565b61ffff9290921660109190911b63ffff0000161760209190911b64ff00000000161790565b60008183106124c257508061063f565b60006124d66124d1858561377c565b612975565b905061064e818561378f565b60006124ec610e6d565b54600160401b900460ff16919050565b815160005b81811015612537578284828151811061251c5761251c614d9b565b60200260200101510361252f5750505050565b600101612501565b5060405163e378efef60e01b815260040160405180910390fd5b604080830151600090815260168301602052908120805490915b818110156128435760008060006125ad86858154811061258d5761258d614d9b565b906000526020600020015490600882901c90604883901c60ff1660011490565b925092509250816001600160401b0316600014158015612657575061012088015160405163018c895b60e21b815260006004820181905260646024830181905260448301919091526001600160401b038516926001600160a01b031691630632256c91016020604051808303816000875af1158015612630573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126549190614dfc565b11155b156128355760e088015160a08901516102c08a015160405163fbed9ac560e01b81526000936001600160a01b03169263fbed9ac5926126b5926004016001600160a01b039290921682526001600160501b0316602082015260400190565b600060405180830381865afa1580156126d2573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526126fa919081019061536a565b80519091508015612832576000808660ff166000036127ad576101208c01516001600160a01b0316630632256c600061273460018761377c565b6040516001600160e01b031960e085901b16815260048101929092526024820152600060448201526064016020604051808303816000875af115801561277e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127a29190614dfc565b9150600190506127f4565b60005b838110156127f2578760ff168582815181106127ce576127ce614d9b565b602002602001015160ff16036127ea57809250600191506127f2565b6001016127b0565b505b801561282f5761281d8c85848151811061281057612810614d9b565b6020026020010151612a0b565b841561282f5750505050505050612843565b50505b50505b50505080600101905061256b565b5050505050565b606081601901600061287e856102c00151866101c001518760a001516001600160a01b03166121879092919063ffffffff16565b8152602001908152602001600020600090558160080160006128ba8561024001516000876101c0015161ffff1661248d9092919063ffffffff16565b815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561293e57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff16815260200190600401906020826003010492830192600103820291508084116129015790505b5050505050905092915050565b600082600001828154811061296257612962614d9b565b9060005260206000200154905092915050565b60008160000361298757506000919050565b61299282600161378f565b4340414443423a5a6040516020016129e8979695949392919096875260609590951b6001600160601b0319166020870152603486019390935260548501919091526074840152609483015260b482015260d40190565b6040516020818303038152906040528051906020012060001c61063f91906153f8565b60e082015160a08301516102c0840151604051633bdb788b60e01b81526001600160a01b0392831660048201526001600160401b03909116602482015260ff841660448201526000928392612ab092911690633bdb788b90606401602060405180830381865afa158015612a83573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612aa79190614dfc565b9060a082901c90565b61014086015160a08701516102c0880151604051631af6585960e01b81526001600160a01b0380871660048301526024820186905292831660448201526001600160501b03909116606482015260ff881660848201523060a4820152600060c48201529395509193501690631af658599060e401600060405180830381600087803b158015612b3e57600080fd5b505af1158015612b52573d6000803e3d6000fd5b505050508361014001516001600160a01b031663a24835d183836040518363ffffffff1660e01b8152600401612b89929190613db4565b600060405180830381600087803b158015612ba357600080fd5b505af1158015612bb7573d6000803e3d6000fd5b5050505060a0848101516102c086015161028087015161026088015188516020808b0151604080516001600160a01b0398891681526001600160501b03909716928701929092526001600160401b039094169085015263ffffffff9091166060840152928616608083015292810184905260c081019190915260e08101919091527fdb9d6e401acb3147153857557ad8bbec7bc628d66296e6a3588b8c8ea763268c906101000160405180910390a150505050565b604080516101c08101825260008082526020820181905291810182905260608082018190526080820183905260a0820183905260c0820183905260e0820183905261010082018390526101208201839052610140820183905261016082018390526101808201929092526101a081019190915290565b63ffffffff811681146105f557600080fd5b600060208284031215612d0657600080fd5b813561099f81612ce2565b61ffff811681146105f557600080fd5b8035612d2c81612d11565b919050565b600060c08284031215612d4357600080fd5b50919050565b60008060408385031215612d5c57600080fd5b8235612d6781612d11565b915060208301356001600160401b03811115612d8257600080fd5b612d8e85828601612d31565b9150509250929050565b60008083601f840112612daa57600080fd5b5081356001600160401b03811115612dc157600080fd5b6020830191508360208260051b8501011115612ddc57600080fd5b9250929050565b60008060008060008060008060008060c08b8d031215612e0257600080fd5b612e0b8b612d21565b995060208b01356001600160401b0380821115612e2757600080fd5b612e338e838f01612d98565b909b50995060408d0135915080821115612e4c57600080fd5b612e588e838f01612d98565b909950975060608d0135915080821115612e7157600080fd5b612e7d8e838f01612d98565b909750955060808d0135915080821115612e9657600080fd5b50612ea38d828e01612d98565b9150809450508092505060a08b013590509295989b9194979a5092959850565b600060208284031215612ed557600080fd5b813561099f81612d11565b6001600160a01b03811681146105f557600080fd5b634e487b7160e01b600052604160045260246000fd5b6040516101c081016001600160401b0381118282101715612f2e57612f2e612ef5565b60405290565b604051601f8201601f191681016001600160401b0381118282101715612f5c57612f5c612ef5565b604052919050565b600082601f830112612f7557600080fd5b81356001600160401b03811115612f8e57612f8e612ef5565b612fa1601f8201601f1916602001612f34565b818152846020838601011115612fb657600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060808587031215612fe957600080fd5b8435612ff481612ee0565b9350602085013561300481612ee0565b92506040850135915060608501356001600160401b0381111561302657600080fd5b61303287828801612f64565b91505092959194509250565b60008060006060848603121561305357600080fd5b833561305e81612ce2565b9250602084013561306e81612ee0565b929592945050506040919091013590565b60006020828403121561309157600080fd5b813561099f81612ee0565b600080604083850312156130af57600080fd5b82356130ba81612d11565b946020939093013593505050565b600080604083850312156130db57600080fd5b82356130e681612d11565b915060208301356001600160401b0381111561310157600080fd5b830160e0818603121561311357600080fd5b809150509250929050565b80356001600160401b0381168114612d2c57600080fd5b60ff811681146105f557600080fd5b60008060008060008060008060006101208a8c03121561316357600080fd5b893561316e81612ee0565b985061317c60208b0161311e565b975060408a013561318c81612ce2565b965060608a0135955060808a01356131a381612ee0565b945060a08a0135935060c08a01356131ba81613135565b925060e08a013591506101008a01356001600160401b038111156131dd57600080fd5b6131e98c828d01612f64565b9150509295985092959850929598565b6001600160a01b03169052565b60008151808452602080850194506020840160005b838110156132405781516001600160a01b03168752958201959082019060010161321b565b509495945050505050565b60008151808452602080850194506020840160005b8381101561324057815163ffffffff1687529582019590820190600101613260565b6020815261329560208201835115159052565b600060208301516132aa604084018215159052565b5060408301516132bd60608401826131f9565b5060608301516101c08060808501526132da6101e0850183613206565b915060808501516132f060a086018260030b9052565b5060a085015161330560c086018260030b9052565b5060c085015161331a60e086018260030b9052565b5060e08501516101006133318187018360030b9052565b86015190506101206133478682018360030b9052565b86015190506101406133608682018363ffffffff169052565b86015190506101606133798682018363ffffffff169052565b860151610180868101919091528601516101a080870191909152860151858403601f19018387015290506133ad838261324b565b9695505050505050565b600060a08284031215612d4357600080fd5b6000806000606084860312156133de57600080fd5b83356133e981612d11565b925060208401356001600160401b0381111561340457600080fd5b613410868287016133b7565b92505060408401356006811061342557600080fd5b809150509250925092565b6000806040838503121561344357600080fd5b823561344e81612d11565b915060208301356001600160401b0381111561346957600080fd5b83016101a0818603121561311357600080fd5b60008060008060008060006080888a03121561349757600080fd5b87356134a281612d11565b965060208801356001600160401b03808211156134be57600080fd5b6134ca8b838c01612d98565b909850965060408a01359150808211156134e357600080fd5b6134ef8b838c01612d98565b909650945060608a013591508082111561350857600080fd5b506135158a828b01612d98565b989b979a50959850939692959293505050565b80356001600160501b0381168114612d2c57600080fd5b60008060006060848603121561355457600080fd5b833561355f81612ee0565b925061356d60208501613528565b9150604084013561342581612d11565b60006020808352835180602085015260005b818110156135ab5785810183015185820160400152820161358f565b506000604082860101526040601f19601f8301168501019250505092915050565b6001600160a01b0391909116815260200190565b600080604083850312156135f357600080fd5b82356135fe81612d11565b915060208301356001600160401b0381111561361957600080fd5b83016060818603121561311357600080fd5b6000806040838503121561363e57600080fd5b823561364981612d11565b915060208301356001600160401b0381111561366457600080fd5b612d8e858286016133b7565b60008060006060848603121561368557600080fd5b833561369081612d11565b9250602084013561306e81612ce2565b6000602082840312156136b257600080fd5b81356001600160401b038111156136c857600080fd5b82016102c0818503121561099f57600080fd5b6000806000606084860312156136f057600080fd5b83356136fb81612d11565b9250602084013561370b81612ee0565b915061371960408501613528565b90509250925092565b6020808252825182820181905260009190848201906040850190845b8181101561375a5783518352928401929184019160010161373e565b50909695505050505050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561063f5761063f613766565b8082018082111561063f5761063f613766565b8051612d2c81612ee0565b6000602082840312156137bf57600080fd5b815161099f81612ee0565b6000808335601e198436030181126137e157600080fd5b83016020810192503590506001600160401b0381111561380057600080fd5b8060051b3603821315612ddc57600080fd5b8183526000602080850194508260005b8581101561324057813561383581612d11565b61ffff1687529582019590820190600101613822565b8183526000602080850194508260005b8581101561324057813561386e81613135565b60ff168752958201959082019060010161385b565b80151581146105f557600080fd5b8183526000602080850194508260005b858110156132405781356138b481613883565b1515875295820195908201906001016138a1565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f190189526138fd82886137ca565b613908858284613891565b9a86019a94505050908301906001016138e2565b5090979650505050505050565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f1901895261395e82886137ca565b61396985828461384b565b9a86019a9450505090830190600101613943565b8060030b81146105f557600080fd5b8183526000602080850194508260005b858110156132405781356139af8161397d565b60030b8752958201959082019060010161399c565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f190189526139f982886137ca565b613a0485828461398c565b9a86019a94505050908301906001016139de565b6000613a2482836137ca565b60c08552613a3660c086018284613812565b915050613a4660208401846137ca565b8583036020870152613a5983828461384b565b92505050613a6a60408401846137ca565b8583036040870152613a7d838284613812565b92505050613a8e60608401846137ca565b8583036060870152613aa18382846138c8565b92505050613ab260808401846137ca565b8583036080870152613ac5838284613929565b92505050613ad660a08401846137ca565b85830360a08701526133ad8382846139c4565b83815261ffff83166020820152606060408201526000610e3b6060830184613a18565b81835260006001600160fb1b03831115613b2557600080fd5b8260051b80836020870137939093016020019392505050565b8183526000602080850194508260005b85811015613240576001600160401b03613b678361311e565b1687529582019590820190600101613b4e565b8b815261ffff8b16602082015260e060408201526000613b9e60e083018b8d613b0c565b8281036060840152613bb1818a8c613b3e565b90508281036080840152613bc681888a613b3e565b905082810360a0840152613bdb818688613891565b9150508260c08301529c9b505050505050505050505050565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f19018952613c2982886137ca565b613c34858284613b0c565b9a86019a9450505090830190600101613c0e565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f19018952613c7d82886137ca565b613c88858284613b3e565b9a86019a9450505090830190600101613c62565b6000613ca882836137ca565b60e08552613cba60e086018284613812565b915050613cca60208401846137ca565b8583036020870152613cdd83828461384b565b92505050613cee60408401846137ca565b8583036040870152613d01838284613812565b92505050613d1260608401846137ca565b8583036060870152613d25838284613bf4565b92505050613d3660808401846137ca565b8583036080870152613d498382846138c8565b92505050613d5a60a08401846137ca565b85830360a0870152613d6d838284613c48565b92505050613d7e60c08401846137ca565b85830360c08701526133ad838284613c48565b83815261ffff83166020820152606060408201526000610e3b6060830184613c9c565b6001600160a01b03929092168252602082015260400190565b8051612d2c81612ce2565b600060a08284031215613dea57600080fd5b60405160a081018181106001600160401b0382111715613e0c57613e0c612ef5565b6040528251613e1a81612ce2565b81526020830151613e2a81612ce2565b60208201526040830151613e3d81612ce2565b60408201526060830151613e5081612ce2565b60608201526080830151613e6381612ce2565b60808201529392505050565b600060208284031215613e8157600080fd5b815161099f81613135565b60008383855260208086019550808560051b830101846000805b88811015613f0c57858403601f19018a52613ec183896137ca565b808652868601845b82811015613ef7578335613edc81612ee0565b6001600160a01b031682529288019290880190600101613ec9565b509b87019b9550505091840191600101613ea6565b509198975050505050505050565b6000613f2682836137ca565b60c08552613f3860c086018284613812565b9150506020613f49818501856137ca565b86840383880152613f5b84828461384b565b93505050613f6c60408501856137ca565b8684036040880152613f7f848284613812565b93505050613f9060608501856137ca565b8684036060880152613fa3848284613e8c565b93505050613fb460808501856137ca565b8684036080880152808452828401600582901b850184018360005b8481101561403b57878303601f19018452613fea82876137ca565b80855288850160005b828110156140265783356001600160581b03811680821461401357600080fd5b835250928a0192908a0190600101613ff3565b50958901959450505090860190600101613fcf565b505061404a60a08901896137ca565b9650945088810360a08a01526140618187876138c8565b9998505050505050505050565b83815261ffff83166020820152606060408201526000610e3b6060830184613f1a565b600061409d82836137ca565b60a085526140af60a086018284613812565b91505060206140c0818501856137ca565b868403838801526140d284828461384b565b935050506140e360408501856137ca565b86840360408801526140f6848284613812565b9350505061410760608501856137ca565b868403606088015261411a848284613bf4565b9350505061412b60808501856137ca565b8684036080880152808452828401600582901b850184018360005b848110156141ac57878303601f1901845261416182876137ca565b80855288850160005b828110156141975783358060010b80821461418457600080fd5b835250928a0192908a019060010161416a565b50958901959450505090860190600101614146565b50909998505050505050505050565b634e487b7160e01b600052602160045260246000fd5b84815261ffff841660208201526080604082015260006141f46080830185614091565b905060068310614206576142066141bb565b82606083015295945050505050565b8183526000602080850194508260005b8581101561324057813561423881612ce2565b63ffffffff1687529582019590820190600101614225565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f1901895261428582886137ca565b614290858284614215565b9a86019a945050509083019060010161426a565b60006101a06142b383846137ca565b8286526142c38387018284613812565b925050506142d460208401846137ca565b85830360208701526142e783828461384b565b925050506142f860408401846137ca565b858303604087015261430b838284613812565b9250505061431c60608401846137ca565b858303606087015261432f838284613929565b9250505061434060808401846137ca565b85830360808701526143538382846139c4565b9250505061436460a08401846137ca565b85830360a0870152614377838284614215565b9250505061438860c08401846137ca565b85830360c087015261439b83828461398c565b925050506143ac60e08401846137ca565b85830360e08701526143bf83828461398c565b925050506101006143d2818501856137ca565b868403838801526143e484828461398c565b93505050506101206143f8818501856137ca565b8684038388015261440a84828461398c565b935050505061014061441e818501856137ca565b8684038388015261443084828461398c565b9350505050610160614444818501856137ca565b86840383880152614456848284613e8c565b935050505061018061446a818501856137ca565b86840383880152611c79848284614250565b83815261ffff83166020820152606060408201526000610e3b60608301846142a4565b8183526000602080850194508260005b858110156132405781356144c281612d11565b61ffff16875295820195908201906001016144af565b8881526000602061ffff8a16602084015260a060408401526144fe60a08401898b61449f565b8381036060850152868152879060200160005b8881101561453957823561452481613135565b60ff1682529183019190830190600101614511565b5084810360808601526114a681878961449f565b600061455982836137ca565b6060855261456b606086018284613812565b91505061457b60208401846137ca565b858303602087015261458e83828461384b565b9250505061459f60408401846137ca565b85830360408701526133ad838284614250565b83815261ffff83166020820152606060408201526000610e3b606083018461454d565b60006145e182836137ca565b60a085526145f360a086018284613812565b9150506020614604818501856137ca565b8684038388015261461684828461384b565b9350505061462760408501856137ca565b868403604088015261463a848284613812565b9350505061464b60608501856137ca565b868403606088015261465e84828461384b565b9350505061466f60808501856137ca565b8684036080880152808452828401600582901b850184018360005b848110156141ac57878303601f190184526146a582876137ca565b6146b0858284613812565b95890195945050509086019060010161468a565b83815261ffff83166020820152606060408201526000610e3b60608301846145d5565b60006146f382836137ca565b60c0855261470560c086018284613812565b91505061471560208401846137ca565b858303602087015261472883828461384b565b9250505061473960408401846137ca565b858303604087015261474c838284613812565b9250505061475d60608401846137ca565b8583036060870152614770838284613e8c565b9250505061478160808401846137ca565b85830360808701526147948382846138c8565b925050506147a560a08401846137ca565b85830360a08701526133ad8382846138c8565b83815261ffff83166020820152606060408201526000610e3b60608301846146e7565b60006147e782836137ca565b60c085526147f960c086018284613812565b91505061480960208401846137ca565b858303602087015261481c83828461384b565b9250505061482d60408401846137ca565b8583036040870152614840838284613812565b9250505061485160608401846137ca565b8583036060870152614864838284614215565b9250505061487560808401846137ca565b8583036080870152614888838284614215565b9250505061489960a08401846137ca565b85830360a08701526133ad838284613891565b83815261ffff83166020820152606060408201526000610e3b60608301846147db565b60008235605e198336030181126148e557600080fd5b90910192915050565b60006148fa82836137ca565b6060855261490c606086018284613812565b91505061491c60208401846137ca565b858303602087015261492f83828461384b565b9250505061494060408401846137ca565b85830360408701526133ad838284613812565b60008235609e198336030181126148e557600080fd5b6000823560be198336030181126148e557600080fd5b6000823560de198336030181126148e557600080fd5b60006149a182836137ca565b60c085526149b360c086018284613812565b9150506149c360208401846137ca565b85830360208701526149d683828461384b565b925050506149e760408401846137ca565b85830360408701526149fa838284613812565b92505050614a0b60608401846137ca565b8583036060870152614a1e838284613929565b92505050614a2f60808401846137ca565b8583036080870152614794838284613c48565b6000823561019e198336030181126148e557600080fd5b82815260406020820152614a7b60408201614a7384612d21565b61ffff169052565b6000614a8a60208401846137ca565b6102c0806060860152614aa261030086018385613b0c565b9250614ab160408701876137ca565b9250603f1980878603016080880152614acb858584613b3e565b9450614ada60608901896137ca565b94509150808786030160a0880152614af3858584613b3e565b9450614b0260808901896137ca565b94509150808786030160c0880152614b1b858584613891565b945060a088013560e0880152614b3460c08901896148cf565b93506101009150808786030182880152614b4e85856148ee565b9450614b5d60e0890189614953565b9350610120818887030181890152614b7586866145d5565b9550614b83838a018a614969565b94506101409250818887030183890152614b9d8686613a18565b9550614bab818a018a614969565b945050610160818887030181890152614bc486866146e7565b9550614bd2838a018a614969565b94506101809250818887030183890152614bec8686613f1a565b9550614bfa818a018a614969565b9450506101a0818887030181890152614c1386866147db565b9550614c21838a018a61497f565b94506101c09250818887030183890152614c3b8686613c9c565b9550614c49818a018a61497f565b9450506101e0818887030181890152614c628686613c9c565b9550614c70838a018a614969565b94506102009250818887030183890152614c8a8686614995565b9550614c98818a018a6148cf565b945050610220818887030181890152614cb1868661454d565b9550614cbf838a018a614a42565b94506102409250818887030183890152614cd986866142a4565b9550614ce7818a018a614a42565b945050610260818887030181890152614d0086866142a4565b9550614d0e838a018a614953565b94506102809250818887030183890152614d288686614091565b9550614d36818a018a614953565b9450506102a0818887030181890152614d4f8686614091565b9550614d5d838a018a614953565b9450818887030184890152614d728686614091565b9550614d80818a018a614953565b94505080878603016102e08801525050506133ad8282614091565b634e487b7160e01b600052603260045260246000fd5b83815261ffff83166020820152606060408201526000610e3b6060830184614995565b8051612d2c81613883565b600060208284031215614df157600080fd5b815161099f81613883565b600060208284031215614e0e57600080fd5b5051919050565b6001600160a01b039390931683526020830191909152604082015260600190565b805182526020810151602083015260408101516040830152606081015160608301526080810151614e6a60808401826131f9565b5060a0810151614e7d60a08401826131f9565b5060c0810151614e9060c08401826131f9565b5060e0810151614ea360e08401826131f9565b5061010080820151614eb7828501826131f9565b505061012080820151614ecc828501826131f9565b505061014080820151614ee1828501826131f9565b50506101608181015160ff90811691840191909152610180808301518216908401526101a080830151909116908301526101c08082015161ffff908116918401919091526101e080830151821690840152610200808301518216908401526102208083015182169084015261024080830151909116908301526102608082015163ffffffff90811691840191909152610280808301516001600160401b0316908401526102a08083015164ffffffffff16908401526102c0808301516001600160501b0316908401526102e09182015180518216928401929092526020820151811661030084015260408201518116610320840152606082015181166103408401526080909101511661036090910152565b6103a081016150028285614e36565b826103808301529392505050565b60006020828403121561502257600080fd5b81516008811061099f57600080fd5b6103c0810160088510615046576150466141bb565b84825283602083015261064e6040830184614e36565b60006001600160401b0382111561507557615075612ef5565b5060051b60200190565b600082601f83011261509057600080fd5b815160206150a56150a08361505c565b612f34565b8083825260208201915060208460051b8701019350868411156150c757600080fd5b602086015b848110156150ec5780516150df81612ee0565b83529183019183016150cc565b509695505050505050565b8051612d2c8161397d565b600082601f83011261511357600080fd5b815160206151236150a08361505c565b8083825260208201915060208460051b87010193508684111561514557600080fd5b602086015b848110156150ec57805161515d81612ce2565b835291830191830161514a565b8051612d2c81612d11565b600082601f83011261518657600080fd5b815160206151966150a08361505c565b8083825260208201915060208460051b8701019350868411156151b857600080fd5b602086015b848110156150ec5780516151d081612d11565b83529183019183016151bd565b6000806000606084860312156151f257600080fd5b83516001600160401b038082111561520957600080fd5b908501906101c0828803121561521e57600080fd5b615226612f0b565b61522f83614dd4565b815261523d60208401614dd4565b602082015261524e604084016137a2565b604082015260608301518281111561526557600080fd5b6152718982860161507f565b606083015250615283608084016150f7565b608082015261529460a084016150f7565b60a08201526152a560c084016150f7565b60c08201526152b660e084016150f7565b60e08201526101006152c98185016150f7565b908201526101206152db848201613dcd565b908201526101406152ed848201613dcd565b90820152610160838101519082015261018080840151908201526101a0808401518381111561531b57600080fd5b6153278a828701615102565b8284015250508095505061533d6020870161516a565b9350604086015191508082111561535357600080fd5b5061536086828701615175565b9150509250925092565b6000602080838503121561537d57600080fd5b82516001600160401b0381111561539357600080fd5b8301601f810185136153a457600080fd5b80516153b26150a08261505c565b81815260059190911b820183019083810190878311156153d157600080fd5b928401925b82841015611c795783516153e981613135565b825292840192908401906153d6565b60008261541557634e487b7160e01b600052601260045260246000fd5b50069056fe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda264697066735822122070a601f578c656b8164379610e42e5fc7d4d50d20472e35147461b004831360564736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106102295760003560e01c80637cc9638011610131578063cb90acc0116100b3578063cb90acc014610500578063d02a74a414610513578063d6dd327314610526578063dce9127214610539578063dee1f0e41461054c578063e08868ae1461055f578063e893564714610572578063ef76796114610592578063f660b274146105a5578063f77c4791146105b8578063ffa1ad74146105c057600080fd5b80637cc963801461041a5780637f9e78a21461042257806384ff97d414610435578063889700641461044857806392b6c5cf1461045b578063936725ec1461046e5780639d0bcca01461049f578063aa1293d9146104b4578063ac62e9f9146104c7578063b429afeb146104da578063bc982d2b146104ed57600080fd5b80631c1b0daa116101ba5780631c1b0daa1461032a578063325a19f11461034a5780633ed2f89a146103525780634593144c1461036557806349a8ccd51461036d5780634fac6ccd14610393578063509a093f146103a6578063656218ff146103ce5780636eee5afe146103e157806373aeb392146103f4578063788a2d2e1461040757600080fd5b806305f922391461022e5780630c0e97dd146102435780630cac0c1f1461025657806312a554ec14610269578063150b7a021461028f578063152f74f0146102bb57806318daea98146102de57806319ab453c146102f15780631a94214a146103045780631aab826a14610317575b600080fd5b61024161023c366004612cf4565b6105e4565b005b610241610251366004612d49565b6105f8565b610241610264366004612de3565b61060e565b61027c610277366004612ec3565b610634565b6040519081526020015b60405180910390f35b6102a261029d366004612fd3565b610645565b6040516001600160e01b03199091168152602001610286565b6102ce6102c936600461303e565b610656565b6040519015158152602001610286565b61027c6102ec366004612ec3565b61066b565b6102416102ff36600461307f565b610676565b61024161031236600461309c565b610770565b6102416103253660046130c8565b610782565b61033d610338366004613144565b610794565b6040516102869190613282565b61027c6107c3565b6102ce610360366004612cf4565b6107fc565b61027c610807565b61038061037b366004612cf4565b610837565b60405161ffff9091168152602001610286565b6102416103a136600461307f565b610842565b6103b96103b4366004612ec3565b610953565b60405163ffffffff9091168152602001610286565b6102416103dc366004612d49565b61095e565b61027c6103ef366004612ec3565b610970565b6102416104023660046133c9565b61097b565b61027c61041536600461309c565b610993565b61027c6109a6565b610241610430366004613430565b6109c4565b61024161044336600461347c565b6109d6565b61024161045636600461309c565b6109f6565b61038061046936600461353f565b610a08565b610492604051806040016040528060058152602001640312e302e360dc1b81525081565b604051610286919061357d565b6104a7610a15565b60405161028691906135cc565b6102416104c23660046135e0565b610a45565b6102416104d536600461362b565b610a57565b6102ce6104e836600461307f565b610a69565b6102416104fb366004612d49565b610a8e565b61024161050e366004613670565b610aa0565b610241610521366004612d49565b610ab3565b6102416105343660046136a0565b610ac5565b6102416105473660046130c8565b610ad6565b6102ce61055a36600461307f565b610ae8565b61027c61056d36600461309c565b610b6d565b6105856105803660046136db565b610b79565b6040516102869190613722565b6102416105a0366004612d49565b610b8e565b6102416105b3366004613430565b610ba0565b6104a7610bb2565b61049260405180604001604052806005815260200164322e312e3160d81b81525081565b6105f56105ef610bb2565b82610be2565b50565b61060a610603610bb2565b8383610c65565b5050565b610628610619610bb2565b8b8b8b8b8b8b8b8b8b8b610cdc565b50505050505050505050565b600061063f82610d74565b92915050565b630a85bd0160e11b5b949350505050565b600061064e610663610bb2565b858585610d9d565b600061063f82610e44565b6000610680610e6d565b805490915060ff600160401b82041615906001600160401b03166000811580156106a75750825b90506000826001600160401b031660011480156106c35750303b155b9050811580156106d1575080155b156106ef5760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff19166001178555831561071957845460ff60401b1916600160401b1785555b61072286610e91565b831561076857845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050565b61060a61077b610bb2565b8383610ea2565b61060a61078d610bb2565b8383610f02565b61079c612c6c565b6107b56107a7610bb2565b8b8b8b8b8b8b8b8b8b610f4d565b9a9950505050505050505050565b60006107f76107f360017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b61377c565b5490565b905090565b600061063f826114b7565b60006107f76107f360017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f161377c565b600061063f826114e3565b3330146108945760405162461bcd60e51b815260206004820152601b60248201527a24b731b932b0b9b2903932bb34b9b4b7b7103337b93134b23232b760291b60448201526064015b60405180910390fd5b60006108b26107f3600160008051602061541b83398151915261377c565b6108bd90600161378f565b90506108df816108dc600160008051602061541b83398151915261377c565b55565b61090e826108dc60017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e461377c565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c8910160405180910390a15050565b600061063f8261150d565b61060a610969610bb2565b838361153a565b600061063f82611585565b61098e610986610bb2565b8484846115ac565b505050565b600061099f838361162f565b9392505050565b60006107f76107f3600160008051602061541b83398151915261377c565b61060a6109cf610bb2565b838361165a565b6109ed6109e1610bb2565b888888888888886116a5565b50505050505050565b61060a610a01610bb2565b8383611734565b600061064e84848461175f565b60006107f76107f360017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e461377c565b61060a610a50610bb2565b838361178e565b61060a610a62610bb2565b83836117d9565b6000610a73610bb2565b6001600160a01b0316826001600160a01b0316149050919050565b61060a610a99610bb2565b8383611824565b61098e610aab610bb2565b84848461186f565b61060a610abe610bb2565b83836118db565b6105f5610ad0610bb2565b82611926565b61060a610ae1610bb2565b838361196f565b6000816001600160a01b0316610afc610bb2565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b39573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b5d91906137ad565b6001600160a01b03161492915050565b600061099f838361199a565b606061064e610b86610bb2565b8585856119c5565b61060a610b99610bb2565b8383611c84565b61060a610bab610bb2565b8383611ccf565b60006107f76107f360017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c361861377c565b610beb82611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__63a913674b610c0d611d86565b6040516001600160e01b031960e084901b168152600481019190915263ffffffff841660248201526044015b60006040518083038186803b158015610c5157600080fd5b505af4158015610768573d6000803e3d6000fd5b610c6e83611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__63a84d660c610c90611d86565b84846040518463ffffffff1660e01b8152600401610cb093929190613ae9565b60006040518083038186803b158015610cc857600080fd5b505af41580156109ed573d6000803e3d6000fd5b610ce58b611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__63ca473936610d07611d86565b8c8c8c8c8c8c8c8c8c8c6040518c63ffffffff1660e01b8152600401610d379b9a99989796959493929190613b7a565b60006040518083038186803b158015610d4f57600080fd5b505af4158015610d63573d6000803e3d6000fd5b505050505050505050505050505050565b600061063f610d81611d86565b61ffff8416600090815260049190910160205260409020611daa565b6000610e3b610daa611d86565b610db2611d86565b63ffffffff871660009081526020918252604090819020548151628e969160e01b8152915161ffff90911692889288926001600160a01b038d1692628e969192600480820193918290030181865afa158015610e12573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e3691906137ad565b611db4565b95945050505050565b600061063f610e51611d86565b61ffff8416600090815260059190910160205260409020611daa565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0090565b610e99612037565b6105f58161205e565b610eab83611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__633e8dd868610ecd611d86565b6040516001600160e01b031960e084901b168152600481019190915261ffff8516602482015260448101849052606401610cb0565b610f0b83611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__6301c7664c610f2d611d86565b84846040518463ffffffff1660e01b8152600401610cb093929190613d91565b610f55612c6c565b336001600160a01b03168b6001600160a01b03166389dd9f136040518163ffffffff1660e01b8152600401602060405180830381865afa158015610f9d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fc191906137ad565b6001600160a01b031614610fea57336040516309f23ad160e41b815260040161088b91906135cc565b60008b6001600160a01b0316628e96916040518163ffffffff1660e01b8152600401602060405180830381865afa158015611029573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061104d91906137ad565b905060006040518061030001604052808a815260200186815260200161107286612171565b81526020016000801b81526020018d6001600160a01b03168152602001896001600160a01b031681526020018e6001600160a01b03168152602001836001600160a01b031681526020018e6001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156110fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061111e91906137ad565b6001600160a01b031681526020018e6001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa15801561116a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061118e91906137ad565b6001600160a01b031681526020018e6001600160a01b03166331423c266040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111fe91906137ad565b6001600160a01b03168152600060208201819052604082015260ff8816606082015260800161122b611d86565b63ffffffff8d166000818152602092835260408082205461ffff168552928401819052838301819052606084018190526080840181905260a08401919091526001600160401b038f1660c084015260e08301526001600160501b038a1661010083015251631a95890960e31b8152610120909101906001600160a01b0385169063d4ac4848906112c1908d908d90600401613db4565b60a060405180830381865afa1580156112de573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113029190613dd8565b8152509050806101c0015161ffff16600003611331576040516326358d7f60e21b815260040160405180910390fd5b8061010001516001600160a01b0316631789b7b1896040518263ffffffff1660e01b815260040161136291906135cc565b602060405180830381865afa15801561137f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113a39190613e6f565b60ff166101608201526113b4611d86565b6040808301516000908152600992909201602052902054606082015261141b6113db611d86565b60190160006114038a856101c001518d6001600160a01b03166121879092919063ffffffff16565b81526020019081526020016000205490601082901c90565b64ffffffffff166102a083015261ffff166102408201526040810151601081901c602082901c602883901c846101e0018561020001866101800187610220018461ffff1661ffff168152508460ff1660ff168152508461ffff1661ffff168152508461ffff1661ffff16815250505050506114a6816114a18f846101c001518c8c6119c5565b6121ba565b9d9c50505050505050505050505050565b60006114c1611d86565b63ffffffff909216600090815260039290920160205250604090205460ff1690565b60006114ed611d86565b63ffffffff909216600090815260209290925250604090205461ffff1690565b6000611517611d86565b61ffff909216600090815260019290920160205250604090205463ffffffff1690565b61154383611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__6356814190611565611d86565b84846040518463ffffffff1660e01b8152600401610cb09392919061406e565b600061158f611d86565b61ffff9092166000908152601a9290920160205250604090205490565b6115b584611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__630324a18c6115d7611d86565b8585856040518563ffffffff1660e01b81526004016115f994939291906141d1565b60006040518083038186803b15801561161157600080fd5b505af4158015611625573d6000803e3d6000fd5b5050505050505050565b600061099f8261163d611d86565b61ffff861660009081526004919091016020526040902090612481565b61166383611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__63b5083ab9611685611d86565b84846040518463ffffffff1660e01b8152600401610cb09392919061447c565b6116ae88611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__6301c3192f6116d0611d86565b898989898989896040518963ffffffff1660e01b81526004016116fa9897969594939291906144d8565b60006040518083038186803b15801561171257600080fd5b505af4158015611726573d6000803e3d6000fd5b505050505050505050505050565b61173d83611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__63b5287c91610ecd611d86565b600061178561176c611d86565b60190160006114036001600160a01b0388168787612187565b50949350505050565b61179783611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__63d335b7f36117b9611d86565b84846040518463ffffffff1660e01b8152600401610cb0939291906145b2565b6117e283611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__638cd5642c611804611d86565b84846040518463ffffffff1660e01b8152600401610cb0939291906146c4565b61182d83611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__63679dde4c61184f611d86565b84846040518463ffffffff1660e01b8152600401610cb0939291906147b8565b61187884611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__631c9a900861189a611d86565b6040516001600160e01b031960e084901b168152600481019190915261ffff8616602482015263ffffffff85166044820152606481018490526084016115f9565b6118e483611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__636b6cc9f8611906611d86565b84846040518463ffffffff1660e01b8152600401610cb0939291906148ac565b61192f82611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__639c9dc579611951611d86565b836040518363ffffffff1660e01b8152600401610c39929190614a59565b61197883611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__63cbbefc28610f2d611d86565b600061099f826119a8611d86565b61ffff861660009081526005919091016020526040902090612481565b60606000856001600160a01b031663016dff5d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a07573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a2b91906137ad565b90506000611a53611a3a611d86565b60190160006114036001600160a01b038916888b612187565b5090506000611a60611d86565b6006016000611ae284866001600160a01b0316631789b7b18b6040518263ffffffff1660e01b8152600401611a9591906135cc565b602060405180830381865afa158015611ab2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ad69190613e6f565b61ffff8c16919061248d565b8152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015611b3a57602002820191906000526020600020905b815481526020019060010190808311611b26575b505050505090508051600003611bc657611b52611d86565b6006016000611b6661ffff8a16858361248d565b8152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015611bbe57602002820191906000526020600020905b815481526020019060010190808311611baa575b505050505090505b805115611c795760005b60018251611bde919061377c565b811015611c77576000611bfe8260018551611bf9919061377c565b6124b2565b9050828281518110611c1257611c12614d9b565b6020026020010151838281518110611c2c57611c2c614d9b565b6020026020010151848381518110611c4657611c46614d9b565b60200260200101858581518110611c5f57611c5f614d9b565b60209081029190910101919091525250600101611bd0565b505b979650505050505050565b611c8d83611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__63c5828ff1611caf611d86565b84846040518463ffffffff1660e01b8152600401610cb093929190614db1565b611cd883611cfa565b73__$418e69fab995b7bcb2c7cc5bb73ada6f02$__63751dda43611685611d86565b604051631430d62960e21b81526001600160a01b038216906350c358a490611d269033906004016135cc565b602060405180830381865afa158015611d43573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d679190614ddf565b6105f5573360405163451cea1760e11b815260040161088b91906135cc565b7f1fbca2ab9841348cca3f2687c48325e9989a76ad929b9970d1c11e233677cf0090565b600061063f825490565b61ffff841660009081526018860160205260408120548015801590611e4e5750604051631a95890960e31b815281906001600160a01b0385169063d4ac484890611e049089908990600401613db4565b60a060405180830381865afa158015611e21573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e459190613dd8565b5163ffffffff16105b15611e5d576000915050610e3b565b61ffff861660009081526017880160205260408120805490915b81811015612027576000838281548110611e9357611e93614d9b565b6000918252602091829020604080518082019091526002909202018054808352600190910154928201929092529150611ecc575061201f565b6000806000611eee846020015190604082901c90608083901c60ff1660011490565b925092509250600081611f6c578451604051630a82c86160e01b815260048101919091526001600160a01b038c1690630a82c86190602401602060405180830381865afa158015611f43573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f679190614dfc565b611fe1565b8a6001600160a01b0316631c2aafe78e8e88600001516040518463ffffffff1660e01b8152600401611fa093929190614e15565b602060405180830381865afa158015611fbd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611fe19190614dfc565b9050836001600160401b03168110806120025750826001600160401b031681115b156120195760009950505050505050505050610e3b565b50505050505b600101611e77565b5060019998505050505050505050565b61203f6124e2565b61205c57604051631afcd79f60e31b815260040160405180910390fd5b565b6001600160a01b0381166120a65760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b604482015260640161088b565b6120d5816108dc60017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c361861377c565b612104426108dc60017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b61377c565b612133436108dc60017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f161377c565b7f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe23671342681424360405161216693929190614e15565b60405180910390a150565b60008180602001905181019061063f9190614dfc565b6001600160a01b039290921660a09190911b600160a01b600160f01b03161760f09190911b6001600160f01b0319161790565b6121c2612c6c565b60006121cc611d86565b9050825160000361221d5761026084015163ffffffff166101208301526102c08401516001600160501b031661016083015260a08401516001600160a01b031660408301526001602083015261245f565b836101e0015161ffff16846101c0015161ffff1614612269576101c08401516101e0850151604051636df9cb0960e11b815261ffff92831660048201529116602482015260440161088b565b83610200015161ffff1684610240015161ffff16146122b5576102408401516102008501516040516364f16ac560e01b815261ffff92831660048201529116602482015260440161088b565b6122c38385604001516124fc565b60608401516040805163be03c0c360e01b815291901c60ff166001149060009073__$178ac38bd41d46643174775c0e64a3f7b4$__9063be03c0c39061230f9089908790600401614ff3565b602060405180830381865af415801561232c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123509190615010565b905061235c8684612551565b6000606073__$178ac38bd41d46643174775c0e64a3f7b4$__63341bebc884878b6040518463ffffffff1660e01b815260040161239b93929190615031565b600060405180830381865af41580156123b8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526123e091908101906151dd565b9197509250905083806123f257508051155b15612403576001602087015261245a565b4260101b66ffffffffff00001661ffff8316178560190160006124488b6102c001518c6101c001518d60a001516001600160a01b03166121879092919063ffffffff16565b81526020810191909152604001600020555b505050505b81602001511561247a57612473848261284a565b6101a08301525b5092915050565b600061099f838361294b565b61ffff9290921660109190911b63ffff0000161760209190911b64ff00000000161790565b60008183106124c257508061063f565b60006124d66124d1858561377c565b612975565b905061064e818561378f565b60006124ec610e6d565b54600160401b900460ff16919050565b815160005b81811015612537578284828151811061251c5761251c614d9b565b60200260200101510361252f5750505050565b600101612501565b5060405163e378efef60e01b815260040160405180910390fd5b604080830151600090815260168301602052908120805490915b818110156128435760008060006125ad86858154811061258d5761258d614d9b565b906000526020600020015490600882901c90604883901c60ff1660011490565b925092509250816001600160401b0316600014158015612657575061012088015160405163018c895b60e21b815260006004820181905260646024830181905260448301919091526001600160401b038516926001600160a01b031691630632256c91016020604051808303816000875af1158015612630573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126549190614dfc565b11155b156128355760e088015160a08901516102c08a015160405163fbed9ac560e01b81526000936001600160a01b03169263fbed9ac5926126b5926004016001600160a01b039290921682526001600160501b0316602082015260400190565b600060405180830381865afa1580156126d2573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526126fa919081019061536a565b80519091508015612832576000808660ff166000036127ad576101208c01516001600160a01b0316630632256c600061273460018761377c565b6040516001600160e01b031960e085901b16815260048101929092526024820152600060448201526064016020604051808303816000875af115801561277e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127a29190614dfc565b9150600190506127f4565b60005b838110156127f2578760ff168582815181106127ce576127ce614d9b565b602002602001015160ff16036127ea57809250600191506127f2565b6001016127b0565b505b801561282f5761281d8c85848151811061281057612810614d9b565b6020026020010151612a0b565b841561282f5750505050505050612843565b50505b50505b50505080600101905061256b565b5050505050565b606081601901600061287e856102c00151866101c001518760a001516001600160a01b03166121879092919063ffffffff16565b8152602001908152602001600020600090558160080160006128ba8561024001516000876101c0015161ffff1661248d9092919063ffffffff16565b815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561293e57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff16815260200190600401906020826003010492830192600103820291508084116129015790505b5050505050905092915050565b600082600001828154811061296257612962614d9b565b9060005260206000200154905092915050565b60008160000361298757506000919050565b61299282600161378f565b4340414443423a5a6040516020016129e8979695949392919096875260609590951b6001600160601b0319166020870152603486019390935260548501919091526074840152609483015260b482015260d40190565b6040516020818303038152906040528051906020012060001c61063f91906153f8565b60e082015160a08301516102c0840151604051633bdb788b60e01b81526001600160a01b0392831660048201526001600160401b03909116602482015260ff841660448201526000928392612ab092911690633bdb788b90606401602060405180830381865afa158015612a83573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612aa79190614dfc565b9060a082901c90565b61014086015160a08701516102c0880151604051631af6585960e01b81526001600160a01b0380871660048301526024820186905292831660448201526001600160501b03909116606482015260ff881660848201523060a4820152600060c48201529395509193501690631af658599060e401600060405180830381600087803b158015612b3e57600080fd5b505af1158015612b52573d6000803e3d6000fd5b505050508361014001516001600160a01b031663a24835d183836040518363ffffffff1660e01b8152600401612b89929190613db4565b600060405180830381600087803b158015612ba357600080fd5b505af1158015612bb7573d6000803e3d6000fd5b5050505060a0848101516102c086015161028087015161026088015188516020808b0151604080516001600160a01b0398891681526001600160501b03909716928701929092526001600160401b039094169085015263ffffffff9091166060840152928616608083015292810184905260c081019190915260e08101919091527fdb9d6e401acb3147153857557ad8bbec7bc628d66296e6a3588b8c8ea763268c906101000160405180910390a150505050565b604080516101c08101825260008082526020820181905291810182905260608082018190526080820183905260a0820183905260c0820183905260e0820183905261010082018390526101208201839052610140820183905261016082018390526101808201929092526101a081019190915290565b63ffffffff811681146105f557600080fd5b600060208284031215612d0657600080fd5b813561099f81612ce2565b61ffff811681146105f557600080fd5b8035612d2c81612d11565b919050565b600060c08284031215612d4357600080fd5b50919050565b60008060408385031215612d5c57600080fd5b8235612d6781612d11565b915060208301356001600160401b03811115612d8257600080fd5b612d8e85828601612d31565b9150509250929050565b60008083601f840112612daa57600080fd5b5081356001600160401b03811115612dc157600080fd5b6020830191508360208260051b8501011115612ddc57600080fd5b9250929050565b60008060008060008060008060008060c08b8d031215612e0257600080fd5b612e0b8b612d21565b995060208b01356001600160401b0380821115612e2757600080fd5b612e338e838f01612d98565b909b50995060408d0135915080821115612e4c57600080fd5b612e588e838f01612d98565b909950975060608d0135915080821115612e7157600080fd5b612e7d8e838f01612d98565b909750955060808d0135915080821115612e9657600080fd5b50612ea38d828e01612d98565b9150809450508092505060a08b013590509295989b9194979a5092959850565b600060208284031215612ed557600080fd5b813561099f81612d11565b6001600160a01b03811681146105f557600080fd5b634e487b7160e01b600052604160045260246000fd5b6040516101c081016001600160401b0381118282101715612f2e57612f2e612ef5565b60405290565b604051601f8201601f191681016001600160401b0381118282101715612f5c57612f5c612ef5565b604052919050565b600082601f830112612f7557600080fd5b81356001600160401b03811115612f8e57612f8e612ef5565b612fa1601f8201601f1916602001612f34565b818152846020838601011115612fb657600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060808587031215612fe957600080fd5b8435612ff481612ee0565b9350602085013561300481612ee0565b92506040850135915060608501356001600160401b0381111561302657600080fd5b61303287828801612f64565b91505092959194509250565b60008060006060848603121561305357600080fd5b833561305e81612ce2565b9250602084013561306e81612ee0565b929592945050506040919091013590565b60006020828403121561309157600080fd5b813561099f81612ee0565b600080604083850312156130af57600080fd5b82356130ba81612d11565b946020939093013593505050565b600080604083850312156130db57600080fd5b82356130e681612d11565b915060208301356001600160401b0381111561310157600080fd5b830160e0818603121561311357600080fd5b809150509250929050565b80356001600160401b0381168114612d2c57600080fd5b60ff811681146105f557600080fd5b60008060008060008060008060006101208a8c03121561316357600080fd5b893561316e81612ee0565b985061317c60208b0161311e565b975060408a013561318c81612ce2565b965060608a0135955060808a01356131a381612ee0565b945060a08a0135935060c08a01356131ba81613135565b925060e08a013591506101008a01356001600160401b038111156131dd57600080fd5b6131e98c828d01612f64565b9150509295985092959850929598565b6001600160a01b03169052565b60008151808452602080850194506020840160005b838110156132405781516001600160a01b03168752958201959082019060010161321b565b509495945050505050565b60008151808452602080850194506020840160005b8381101561324057815163ffffffff1687529582019590820190600101613260565b6020815261329560208201835115159052565b600060208301516132aa604084018215159052565b5060408301516132bd60608401826131f9565b5060608301516101c08060808501526132da6101e0850183613206565b915060808501516132f060a086018260030b9052565b5060a085015161330560c086018260030b9052565b5060c085015161331a60e086018260030b9052565b5060e08501516101006133318187018360030b9052565b86015190506101206133478682018360030b9052565b86015190506101406133608682018363ffffffff169052565b86015190506101606133798682018363ffffffff169052565b860151610180868101919091528601516101a080870191909152860151858403601f19018387015290506133ad838261324b565b9695505050505050565b600060a08284031215612d4357600080fd5b6000806000606084860312156133de57600080fd5b83356133e981612d11565b925060208401356001600160401b0381111561340457600080fd5b613410868287016133b7565b92505060408401356006811061342557600080fd5b809150509250925092565b6000806040838503121561344357600080fd5b823561344e81612d11565b915060208301356001600160401b0381111561346957600080fd5b83016101a0818603121561311357600080fd5b60008060008060008060006080888a03121561349757600080fd5b87356134a281612d11565b965060208801356001600160401b03808211156134be57600080fd5b6134ca8b838c01612d98565b909850965060408a01359150808211156134e357600080fd5b6134ef8b838c01612d98565b909650945060608a013591508082111561350857600080fd5b506135158a828b01612d98565b989b979a50959850939692959293505050565b80356001600160501b0381168114612d2c57600080fd5b60008060006060848603121561355457600080fd5b833561355f81612ee0565b925061356d60208501613528565b9150604084013561342581612d11565b60006020808352835180602085015260005b818110156135ab5785810183015185820160400152820161358f565b506000604082860101526040601f19601f8301168501019250505092915050565b6001600160a01b0391909116815260200190565b600080604083850312156135f357600080fd5b82356135fe81612d11565b915060208301356001600160401b0381111561361957600080fd5b83016060818603121561311357600080fd5b6000806040838503121561363e57600080fd5b823561364981612d11565b915060208301356001600160401b0381111561366457600080fd5b612d8e858286016133b7565b60008060006060848603121561368557600080fd5b833561369081612d11565b9250602084013561306e81612ce2565b6000602082840312156136b257600080fd5b81356001600160401b038111156136c857600080fd5b82016102c0818503121561099f57600080fd5b6000806000606084860312156136f057600080fd5b83356136fb81612d11565b9250602084013561370b81612ee0565b915061371960408501613528565b90509250925092565b6020808252825182820181905260009190848201906040850190845b8181101561375a5783518352928401929184019160010161373e565b50909695505050505050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561063f5761063f613766565b8082018082111561063f5761063f613766565b8051612d2c81612ee0565b6000602082840312156137bf57600080fd5b815161099f81612ee0565b6000808335601e198436030181126137e157600080fd5b83016020810192503590506001600160401b0381111561380057600080fd5b8060051b3603821315612ddc57600080fd5b8183526000602080850194508260005b8581101561324057813561383581612d11565b61ffff1687529582019590820190600101613822565b8183526000602080850194508260005b8581101561324057813561386e81613135565b60ff168752958201959082019060010161385b565b80151581146105f557600080fd5b8183526000602080850194508260005b858110156132405781356138b481613883565b1515875295820195908201906001016138a1565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f190189526138fd82886137ca565b613908858284613891565b9a86019a94505050908301906001016138e2565b5090979650505050505050565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f1901895261395e82886137ca565b61396985828461384b565b9a86019a9450505090830190600101613943565b8060030b81146105f557600080fd5b8183526000602080850194508260005b858110156132405781356139af8161397d565b60030b8752958201959082019060010161399c565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f190189526139f982886137ca565b613a0485828461398c565b9a86019a94505050908301906001016139de565b6000613a2482836137ca565b60c08552613a3660c086018284613812565b915050613a4660208401846137ca565b8583036020870152613a5983828461384b565b92505050613a6a60408401846137ca565b8583036040870152613a7d838284613812565b92505050613a8e60608401846137ca565b8583036060870152613aa18382846138c8565b92505050613ab260808401846137ca565b8583036080870152613ac5838284613929565b92505050613ad660a08401846137ca565b85830360a08701526133ad8382846139c4565b83815261ffff83166020820152606060408201526000610e3b6060830184613a18565b81835260006001600160fb1b03831115613b2557600080fd5b8260051b80836020870137939093016020019392505050565b8183526000602080850194508260005b85811015613240576001600160401b03613b678361311e565b1687529582019590820190600101613b4e565b8b815261ffff8b16602082015260e060408201526000613b9e60e083018b8d613b0c565b8281036060840152613bb1818a8c613b3e565b90508281036080840152613bc681888a613b3e565b905082810360a0840152613bdb818688613891565b9150508260c08301529c9b505050505050505050505050565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f19018952613c2982886137ca565b613c34858284613b0c565b9a86019a9450505090830190600101613c0e565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f19018952613c7d82886137ca565b613c88858284613b3e565b9a86019a9450505090830190600101613c62565b6000613ca882836137ca565b60e08552613cba60e086018284613812565b915050613cca60208401846137ca565b8583036020870152613cdd83828461384b565b92505050613cee60408401846137ca565b8583036040870152613d01838284613812565b92505050613d1260608401846137ca565b8583036060870152613d25838284613bf4565b92505050613d3660808401846137ca565b8583036080870152613d498382846138c8565b92505050613d5a60a08401846137ca565b85830360a0870152613d6d838284613c48565b92505050613d7e60c08401846137ca565b85830360c08701526133ad838284613c48565b83815261ffff83166020820152606060408201526000610e3b6060830184613c9c565b6001600160a01b03929092168252602082015260400190565b8051612d2c81612ce2565b600060a08284031215613dea57600080fd5b60405160a081018181106001600160401b0382111715613e0c57613e0c612ef5565b6040528251613e1a81612ce2565b81526020830151613e2a81612ce2565b60208201526040830151613e3d81612ce2565b60408201526060830151613e5081612ce2565b60608201526080830151613e6381612ce2565b60808201529392505050565b600060208284031215613e8157600080fd5b815161099f81613135565b60008383855260208086019550808560051b830101846000805b88811015613f0c57858403601f19018a52613ec183896137ca565b808652868601845b82811015613ef7578335613edc81612ee0565b6001600160a01b031682529288019290880190600101613ec9565b509b87019b9550505091840191600101613ea6565b509198975050505050505050565b6000613f2682836137ca565b60c08552613f3860c086018284613812565b9150506020613f49818501856137ca565b86840383880152613f5b84828461384b565b93505050613f6c60408501856137ca565b8684036040880152613f7f848284613812565b93505050613f9060608501856137ca565b8684036060880152613fa3848284613e8c565b93505050613fb460808501856137ca565b8684036080880152808452828401600582901b850184018360005b8481101561403b57878303601f19018452613fea82876137ca565b80855288850160005b828110156140265783356001600160581b03811680821461401357600080fd5b835250928a0192908a0190600101613ff3565b50958901959450505090860190600101613fcf565b505061404a60a08901896137ca565b9650945088810360a08a01526140618187876138c8565b9998505050505050505050565b83815261ffff83166020820152606060408201526000610e3b6060830184613f1a565b600061409d82836137ca565b60a085526140af60a086018284613812565b91505060206140c0818501856137ca565b868403838801526140d284828461384b565b935050506140e360408501856137ca565b86840360408801526140f6848284613812565b9350505061410760608501856137ca565b868403606088015261411a848284613bf4565b9350505061412b60808501856137ca565b8684036080880152808452828401600582901b850184018360005b848110156141ac57878303601f1901845261416182876137ca565b80855288850160005b828110156141975783358060010b80821461418457600080fd5b835250928a0192908a019060010161416a565b50958901959450505090860190600101614146565b50909998505050505050505050565b634e487b7160e01b600052602160045260246000fd5b84815261ffff841660208201526080604082015260006141f46080830185614091565b905060068310614206576142066141bb565b82606083015295945050505050565b8183526000602080850194508260005b8581101561324057813561423881612ce2565b63ffffffff1687529582019590820190600101614225565b6000838385526020808601955060208560051b8301018460005b8781101561391c57848303601f1901895261428582886137ca565b614290858284614215565b9a86019a945050509083019060010161426a565b60006101a06142b383846137ca565b8286526142c38387018284613812565b925050506142d460208401846137ca565b85830360208701526142e783828461384b565b925050506142f860408401846137ca565b858303604087015261430b838284613812565b9250505061431c60608401846137ca565b858303606087015261432f838284613929565b9250505061434060808401846137ca565b85830360808701526143538382846139c4565b9250505061436460a08401846137ca565b85830360a0870152614377838284614215565b9250505061438860c08401846137ca565b85830360c087015261439b83828461398c565b925050506143ac60e08401846137ca565b85830360e08701526143bf83828461398c565b925050506101006143d2818501856137ca565b868403838801526143e484828461398c565b93505050506101206143f8818501856137ca565b8684038388015261440a84828461398c565b935050505061014061441e818501856137ca565b8684038388015261443084828461398c565b9350505050610160614444818501856137ca565b86840383880152614456848284613e8c565b935050505061018061446a818501856137ca565b86840383880152611c79848284614250565b83815261ffff83166020820152606060408201526000610e3b60608301846142a4565b8183526000602080850194508260005b858110156132405781356144c281612d11565b61ffff16875295820195908201906001016144af565b8881526000602061ffff8a16602084015260a060408401526144fe60a08401898b61449f565b8381036060850152868152879060200160005b8881101561453957823561452481613135565b60ff1682529183019190830190600101614511565b5084810360808601526114a681878961449f565b600061455982836137ca565b6060855261456b606086018284613812565b91505061457b60208401846137ca565b858303602087015261458e83828461384b565b9250505061459f60408401846137ca565b85830360408701526133ad838284614250565b83815261ffff83166020820152606060408201526000610e3b606083018461454d565b60006145e182836137ca565b60a085526145f360a086018284613812565b9150506020614604818501856137ca565b8684038388015261461684828461384b565b9350505061462760408501856137ca565b868403604088015261463a848284613812565b9350505061464b60608501856137ca565b868403606088015261465e84828461384b565b9350505061466f60808501856137ca565b8684036080880152808452828401600582901b850184018360005b848110156141ac57878303601f190184526146a582876137ca565b6146b0858284613812565b95890195945050509086019060010161468a565b83815261ffff83166020820152606060408201526000610e3b60608301846145d5565b60006146f382836137ca565b60c0855261470560c086018284613812565b91505061471560208401846137ca565b858303602087015261472883828461384b565b9250505061473960408401846137ca565b858303604087015261474c838284613812565b9250505061475d60608401846137ca565b8583036060870152614770838284613e8c565b9250505061478160808401846137ca565b85830360808701526147948382846138c8565b925050506147a560a08401846137ca565b85830360a08701526133ad8382846138c8565b83815261ffff83166020820152606060408201526000610e3b60608301846146e7565b60006147e782836137ca565b60c085526147f960c086018284613812565b91505061480960208401846137ca565b858303602087015261481c83828461384b565b9250505061482d60408401846137ca565b8583036040870152614840838284613812565b9250505061485160608401846137ca565b8583036060870152614864838284614215565b9250505061487560808401846137ca565b8583036080870152614888838284614215565b9250505061489960a08401846137ca565b85830360a08701526133ad838284613891565b83815261ffff83166020820152606060408201526000610e3b60608301846147db565b60008235605e198336030181126148e557600080fd5b90910192915050565b60006148fa82836137ca565b6060855261490c606086018284613812565b91505061491c60208401846137ca565b858303602087015261492f83828461384b565b9250505061494060408401846137ca565b85830360408701526133ad838284613812565b60008235609e198336030181126148e557600080fd5b6000823560be198336030181126148e557600080fd5b6000823560de198336030181126148e557600080fd5b60006149a182836137ca565b60c085526149b360c086018284613812565b9150506149c360208401846137ca565b85830360208701526149d683828461384b565b925050506149e760408401846137ca565b85830360408701526149fa838284613812565b92505050614a0b60608401846137ca565b8583036060870152614a1e838284613929565b92505050614a2f60808401846137ca565b8583036080870152614794838284613c48565b6000823561019e198336030181126148e557600080fd5b82815260406020820152614a7b60408201614a7384612d21565b61ffff169052565b6000614a8a60208401846137ca565b6102c0806060860152614aa261030086018385613b0c565b9250614ab160408701876137ca565b9250603f1980878603016080880152614acb858584613b3e565b9450614ada60608901896137ca565b94509150808786030160a0880152614af3858584613b3e565b9450614b0260808901896137ca565b94509150808786030160c0880152614b1b858584613891565b945060a088013560e0880152614b3460c08901896148cf565b93506101009150808786030182880152614b4e85856148ee565b9450614b5d60e0890189614953565b9350610120818887030181890152614b7586866145d5565b9550614b83838a018a614969565b94506101409250818887030183890152614b9d8686613a18565b9550614bab818a018a614969565b945050610160818887030181890152614bc486866146e7565b9550614bd2838a018a614969565b94506101809250818887030183890152614bec8686613f1a565b9550614bfa818a018a614969565b9450506101a0818887030181890152614c1386866147db565b9550614c21838a018a61497f565b94506101c09250818887030183890152614c3b8686613c9c565b9550614c49818a018a61497f565b9450506101e0818887030181890152614c628686613c9c565b9550614c70838a018a614969565b94506102009250818887030183890152614c8a8686614995565b9550614c98818a018a6148cf565b945050610220818887030181890152614cb1868661454d565b9550614cbf838a018a614a42565b94506102409250818887030183890152614cd986866142a4565b9550614ce7818a018a614a42565b945050610260818887030181890152614d0086866142a4565b9550614d0e838a018a614953565b94506102809250818887030183890152614d288686614091565b9550614d36818a018a614953565b9450506102a0818887030181890152614d4f8686614091565b9550614d5d838a018a614953565b9450818887030184890152614d728686614091565b9550614d80818a018a614953565b94505080878603016102e08801525050506133ad8282614091565b634e487b7160e01b600052603260045260246000fd5b83815261ffff83166020820152606060408201526000610e3b6060830184614995565b8051612d2c81613883565b600060208284031215614df157600080fd5b815161099f81613883565b600060208284031215614e0e57600080fd5b5051919050565b6001600160a01b039390931683526020830191909152604082015260600190565b805182526020810151602083015260408101516040830152606081015160608301526080810151614e6a60808401826131f9565b5060a0810151614e7d60a08401826131f9565b5060c0810151614e9060c08401826131f9565b5060e0810151614ea360e08401826131f9565b5061010080820151614eb7828501826131f9565b505061012080820151614ecc828501826131f9565b505061014080820151614ee1828501826131f9565b50506101608181015160ff90811691840191909152610180808301518216908401526101a080830151909116908301526101c08082015161ffff908116918401919091526101e080830151821690840152610200808301518216908401526102208083015182169084015261024080830151909116908301526102608082015163ffffffff90811691840191909152610280808301516001600160401b0316908401526102a08083015164ffffffffff16908401526102c0808301516001600160501b0316908401526102e09182015180518216928401929092526020820151811661030084015260408201518116610320840152606082015181166103408401526080909101511661036090910152565b6103a081016150028285614e36565b826103808301529392505050565b60006020828403121561502257600080fd5b81516008811061099f57600080fd5b6103c0810160088510615046576150466141bb565b84825283602083015261064e6040830184614e36565b60006001600160401b0382111561507557615075612ef5565b5060051b60200190565b600082601f83011261509057600080fd5b815160206150a56150a08361505c565b612f34565b8083825260208201915060208460051b8701019350868411156150c757600080fd5b602086015b848110156150ec5780516150df81612ee0565b83529183019183016150cc565b509695505050505050565b8051612d2c8161397d565b600082601f83011261511357600080fd5b815160206151236150a08361505c565b8083825260208201915060208460051b87010193508684111561514557600080fd5b602086015b848110156150ec57805161515d81612ce2565b835291830191830161514a565b8051612d2c81612d11565b600082601f83011261518657600080fd5b815160206151966150a08361505c565b8083825260208201915060208460051b8701019350868411156151b857600080fd5b602086015b848110156150ec5780516151d081612d11565b83529183019183016151bd565b6000806000606084860312156151f257600080fd5b83516001600160401b038082111561520957600080fd5b908501906101c0828803121561521e57600080fd5b615226612f0b565b61522f83614dd4565b815261523d60208401614dd4565b602082015261524e604084016137a2565b604082015260608301518281111561526557600080fd5b6152718982860161507f565b606083015250615283608084016150f7565b608082015261529460a084016150f7565b60a08201526152a560c084016150f7565b60c08201526152b660e084016150f7565b60e08201526101006152c98185016150f7565b908201526101206152db848201613dcd565b908201526101406152ed848201613dcd565b90820152610160838101519082015261018080840151908201526101a0808401518381111561531b57600080fd5b6153278a828701615102565b8284015250508095505061533d6020870161516a565b9350604086015191508082111561535357600080fd5b5061536086828701615175565b9150509250925092565b6000602080838503121561537d57600080fd5b82516001600160401b0381111561539357600080fd5b8301601f810185136153a457600080fd5b80516153b26150a08261505c565b81815260059190911b820183019083810190878311156153d157600080fd5b928401925b82841015611c795783516153e981613135565b825292840192908401906153d6565b60008261541557634e487b7160e01b600052601260045260246000fd5b50069056fe22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bda264697066735822122070a601f578c656b8164379610e42e5fc7d4d50d20472e35147461b004831360564736f6c63430008170033",
  "libraries": {
    "StoryLib": "0xcaC54849A53d23393C0212a937dEA42f402E99b5",
    "StorySetupLib": "0x1d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC9"
  },
  "devdoc": {
    "errors": {
      "InvalidInitialization()": [
        {
          "details": "The contract is already initialized."
        }
      ],
      "NotInitializing()": [
        {
          "details": "The contract is not initializing."
        }
      ]
    },
    "events": {
      "Initialized(uint64)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      }
    },
    "kind": "dev",
    "methods": {
      "created()": {
        "returns": {
          "_0": "Creation timestamp"
        }
      },
      "createdBlock()": {
        "returns": {
          "_0": "Creation block number"
        }
      },
      "increaseRevision(address)": {
        "details": "Revision should be increased on each contract upgrade"
      },
      "isController(address)": {
        "details": "Return true if given address is controller"
      },
      "onERC721Received(address,address,uint256,bytes)": {
        "details": "See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."
      },
      "previousImplementation()": {
        "details": "Previous logic implementation"
      },
      "revision()": {
        "details": "Contract upgrade counter"
      }
    },
    "stateVariables": {
      "VERSION": {
        "details": "Should be incremented when contract changed"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "CONTROLLABLE_VERSION()": {
        "notice": "Version of the contract"
      },
      "VERSION()": {
        "notice": "Version of the contract"
      },
      "controller()": {
        "notice": "Return controller address saved in the contract slot"
      },
      "created()": {
        "notice": "Return creation timestamp"
      },
      "createdBlock()": {
        "notice": "Return creation block number"
      },
      "isGovernance(address)": {
        "notice": "Return true if given address is setup as governance in Controller"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}